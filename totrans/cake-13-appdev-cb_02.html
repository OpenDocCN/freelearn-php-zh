<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Model Bindings"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Model Bindings</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adding<code class="literal"> Containable</code> to all models</li><li class="listitem" style="list-style-type: disc">Limiting the bindings returned in a find</li><li class="listitem" style="list-style-type: disc">Modifying binding parameters for a find</li><li class="listitem" style="list-style-type: disc">Modifying binding conditions for a find</li><li class="listitem" style="list-style-type: disc">Changing the JOIN type of one-to-one associations</li><li class="listitem" style="list-style-type: disc">Defining multiple associations to the same model</li><li class="listitem" style="list-style-type: disc">Adding bindings on the fly</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec01"/>Introduction</h1></div></div></div><p>This chapter deals with one of the most important aspects of a CakePHP application: the relationship between models, also known as<span class="strong"><strong> model bindings</strong></span> or<span class="strong"><strong> associations</strong></span>.<a id="id35" class="indexterm"/>
</p><p>Being an integral part of any application's logic, it is of crucial importance that we master all aspects of how model bindings can be manipulated to get the data we need, when we need it.</p><p>In order to do so, we will go through a series of recipes that will show us how to change the way bindings are fetched, what bindings and what information from a binding is returned, how to create new bindings, and how to build hierarchical data structures.</p></div></div>
<div class="section" title="Adding Containable to all models"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec02"/>Adding Containable to all models</h1></div></div></div><p>The<code class="literal"> Containable</code> behavior is a part of the CakePHP core, and is probably one of the most important behaviors we have to help us deal with model bindings.<a id="id36" class="indexterm"/>
</p><p>Almost all CakePHP applications will benefit from its functionalities, so in this recipe we see how to enable it for all models.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec01"/>How to do it...</h2></div></div></div><p>Create a file named<code class="literal"> app_model.php</code> and place it in your<code class="literal"> app/</code> folder, with the following contents. If you already have one, make sure that either you add the<code class="literal"> actsAs</code> property shown as follows, or that your<code class="literal"> actsAs</code> property includes<code class="literal"> Containable</code>.<a id="id37" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
class AppModel extends Model {
public $actsAs = array('Containable');
}
?&gt;
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec02"/>How it works...</h2></div></div></div><p>The<code class="literal"> Containable</code> behavior is nothing more and nothing less than a wrapper around the<code class="literal"> bindModel()</code> and<code class="literal"> unbindModel()</code> methods, defined in the CakePHP's<code class="literal"> Model</code> class. It is there to help us deal with the management of associations without having to go through a lengthy process of redefining all the associations when calling one of these methods, thus making our code much more readable and maintainable.<a id="id38" class="indexterm"/>
</p><p>This is a very important point, because a common mistake CakePHP users make is to think that<code class="literal"> Containable</code> is involved in the query-making process, that is, during the stage where CakePHP creates actual SQL queries to fetch data.</p><p>
<code class="literal">Containable</code> saves us some unneeded queries, and optimizes the information that is fetched for each related model, but it will not serve as a way to change how queries are built in CakePHP.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec03"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Limiting the bindings returned in a find</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Modifying binding parameters for a find</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Modifying binding conditions for a find</em></span></li></ul></div></div></div>
<div class="section" title="Limiting the bindings returned in a find"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec03"/>Limiting the bindings returned in a find</h1></div></div></div><p>This recipe shows how to use<code class="literal"> Containable</code> to specify what related models are returned as a result of a<code class="literal"> find</code> operation. It also shows us how to limit which fields are obtained for each association.<a id="id39" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec04"/>Getting ready</h2></div></div></div><p>To go through this recipe we need some sample tables to work with.<a id="id40" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a table named<code class="literal"> families</code>, using the following SQL statement:<div class="informalexample"><pre class="programlisting">CREATE TABLE `families`(
`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,
`name` VARCHAR(255) NOT NULL,
PRIMARY KEY(`id`)
);
</pre></div></li><li class="listitem">Create a table named<code class="literal"> people</code>, using the following SQL statement:<div class="informalexample"><pre class="programlisting">CREATE TABLE `people`(
`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,
`family_id` INT UNSIGNED NOT NULL,
`name` VARCHAR(255) NOT NULL,
`email` VARCHAR(255) NOT NULL,
PRIMARY KEY(`id`),
KEY `family_id`(`family_id`),
CONSTRAINT `people__families` FOREIGN KEY(`family_id`) REFERENCES `families`(`id`)
);
</pre></div></li><li class="listitem">Create a table named<code class="literal"> profiles</code>, using the following SQL statement:<div class="informalexample"><pre class="programlisting">CREATE TABLE `profiles`(
`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,
`person_id` INT UNSIGNED NOT NULL,
`website` VARCHAR(255) default NULL,
`birthdate` DATE default NULL,
PRIMARY KEY(`id`),
KEY `person_id`(`person_id`),
CONSTRAINT `profiles__people` FOREIGN KEY(`person_id`) REFERENCES `people`(`id`)
);
</pre></div></li><li class="listitem">Create a table named<code class="literal"> posts</code>, using the following SQL statement:<div class="informalexample"><pre class="programlisting">CREATE TABLE `posts`(
`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,
`person_id` INT UNSIGNED NOT NULL,
`title` VARCHAR(255) NOT NULL,
`body` TEXT NOT NULL,
`created` DATETIME NOT NULL,
`modified` DATETIME NOT NULL,
PRIMARY KEY(`id`),
KEY `person_id`(`person_id`),
CONSTRAINT `posts__people` FOREIGN KEY(`person_id`) REFERENCES `people`(`id`)
);
</pre></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Even if you do not want to add foreign key constraints to your tables, make sure you use KEYs for each field that is a reference to a record in another table. By doing so, you will significantly improve the speed of your SQL queries when the referenced tables are joined.</p></div></li><li class="listitem">Add some sample data, using the following SQL statements:<div class="informalexample"><pre class="programlisting">INSERT INTO `families`(`id`, `name`) VALUES
(1, 'The Does');
INSERT INTO `people`(`id`, `family_id`, `name`, `email`) VALUES
(1, 1, 'John Doe', 'john.doe@example.com'),
(2, 1, 'Jane Doe', 'jane.doe@example.com');
INSERT INTO `profiles`(`person_id`, `website`, `birthdate`) VALUES
(1, 'http://john.example.com', '1978-07-13'),
(2, NULL, '1981-09-18');
INSERT INTO `posts`(`person_id`, `title`, `body`, `created`, `modified`) VALUES
(1, 'John\'s Post 1', 'Body for John\'s Post 1', NOW(), NOW()),
(1, 'John\'s Post 2', 'Body for John\'s Post 2', NOW(), NOW());
</pre></div></li><li class="listitem">We need<code class="literal"> Containable</code> added to all our models, so follow the recipe<span class="emphasis"><em> Adding Containable to all models</em></span>.<a id="id41" class="indexterm"/></li><li class="listitem">We proceed now to create the main model. Create a file named<code class="literal"> person.php</code> and place it in your<code class="literal"> app/models</code> folder with the following contents:<div class="informalexample"><pre class="programlisting">&lt;?php
class Person extends AppModel {
public $belongsTo = array('Family');
public $hasOne = array('Profile');
public $hasMany = array('Post');
}
?&gt;
</pre></div></li><li class="listitem">Create the model<code class="literal"> Family</code> in a file named<code class="literal"> family.php</code> and place it in your<code class="literal"> app/models</code> folder with the following contents:<div class="informalexample"><pre class="programlisting">&lt;?php
class Family extends AppModel {
public $hasMany = array('Person');
}
?&gt;
</pre></div></li></ol></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec05"/>How to do it...</h3></div></div></div><p>When<code class="literal"> Containable</code> is available for our models, we can add a setting to the<code class="literal"> find</code> operation called<code class="literal"> contain</code>. In that setting we specify, in an array-based hierarchy, the associated data we want returned. A special value<code class="literal"> contain</code> can receive is<code class="literal"> false</code>, or an empty array, which tells<code class="literal"> Containable</code> not to return any associated data.<a id="id42" class="indexterm"/>
</p><p>For example, to get the first<code class="literal"> Person</code> record without associated data, we simply do:</p><div class="informalexample"><pre class="programlisting">$person = $this-&gt;Person-&gt;find('first', array(
'contain' =&gt; false
));
</pre></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note07"/>Note</h3><p>Another way to tell CakePHP not to obtain related data is through the use of the<code class="literal"> recursive</code> find setting. Setting<code class="literal"> recursive</code> to<code class="literal"> -1</code> will have exactly the same effect as setting<code class="literal"> contain</code> to<code class="literal"> false</code>.</p></div><p>If we want to obtain the first<code class="literal"> Person</code> record together with the<code class="literal"> Family</code> they belong to, we do:</p><div class="informalexample"><pre class="programlisting">$person = $this-&gt;Person-&gt;find('first', array(
'contain' =&gt; array('Family')
));
</pre></div><p>Using our sample data, the above query will result in the following array structure:</p><div class="informalexample"><pre class="programlisting">array(
'Person' =&gt; array(
'id' =&gt; '1',
'family_id' =&gt; '1',
'name' =&gt; 'John Doe',
'email' =&gt; 'john.doe@example.com'
),
'Family' =&gt; array(
'id' =&gt; '1',
'name' =&gt; 'The Does'
)
)
</pre></div><p>Let's say that now we also want to obtain all<code class="literal"> Post</code> records for the person and all members in the family that<code class="literal"> Person</code> belongs to. We would then have to do:</p><div class="informalexample"><pre class="programlisting">$person = $this-&gt;Person-&gt;find('first', array(
'contain' =&gt; array(
'Family.Person'
'Post'
)
));
</pre></div><p>The above would result in the following array structure (the<code class="literal"> created</code> and<code class="literal"> modified</code> fields have been removed for readability):<a id="id43" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">array(
'Person' =&gt; array(
'id' =&gt; '1',
'family_id' =&gt; '1',
'name' =&gt; 'John Doe',
'email' =&gt; 'john.doe@example.com'
),
'Family' =&gt; array(
'id' =&gt; '1',
'name' =&gt; 'The Does',
'Person' =&gt; array(
array(
'id' =&gt; '1',
'family_id' =&gt; '1',
'name' =&gt; 'John Doe',
'email' =&gt; 'john.doe@example.com'
),
array(
'id' =&gt; '2',
'family_id' =&gt; '1',
'name' =&gt; 'Jane Doe',
'email' =&gt; 'jane.doe@example.com'
)
)
),
'Post' =&gt; array(
array(
'id' =&gt; '1',
'person_id' =&gt; '1',
'title' =&gt; 'John\'s Post 1',
'body' =&gt; 'Body for John\'s Post 1'
),
array(
'id' =&gt; '2',
'person_id' =&gt; '1',
'title' =&gt; 'John\'s Post 2',
'body' =&gt; 'Body for John\'s Post 2'
)
)
)
</pre></div><p>We can also use<code class="literal"> Containable</code> to specify which fields from a related model we want to fetch. Using the preceding sample, let's limit the<code class="literal"> Post</code> fields so we only return the<code class="literal"> title</code> and the<code class="literal"> Person</code> records for the person's<code class="literal"> Family</code>, so we only return the<code class="literal"> name</code> field. We do so by adding the name of the field to the associated model hierarchy:</p><div class="informalexample"><pre class="programlisting">$person = $this-&gt;Person-&gt;find('first', array(
'contain' =&gt; array(
'Family.Person.name',
'Post.title'
)
));
</pre></div><p>The returned data structure will then look like this:<a id="id44" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">array(
'Person' =&gt; array(
'id' =&gt; '1',
'family_id' =&gt; '1',
'name' =&gt; 'John Doe',
'email' =&gt; 'john.doe@example.com'
),
'Family' =&gt; array(
'id' =&gt; '1',
'name' =&gt; 'The Does',
'Person' =&gt; array(
array(
'name' =&gt; 'John Doe',
'family_id' =&gt; '1',
'id' =&gt; '1'
),
array(
'name' =&gt; 'Jane Doe',
'family_id' =&gt; '1',
'id' =&gt; '2'
)
)
),
'Post' =&gt; array(
array(
'title' =&gt; 'John\'s Post 1',
'id' =&gt; '1',
'person_id' =&gt; '1'
),
array(
'title' =&gt; 'John\'s Post 2',
'id' =&gt; '2',
'person_id' =&gt; '1'
)
)
)
</pre></div><p>You may notice that even when we indicated specific fields for the<code class="literal"> Family =&gt; Person</code> binding, and for the<code class="literal"> Post</code> binding, there are some extra fields being returned. Those fields (such as<code class="literal"> family_id</code>) are needed by CakePHP, and known as foreign key fields, to fetch the associated data, so<code class="literal"> Containable</code> is smart enough to include them in the query.</p><p>Let us say that we also want a person's e-mail. As there is more than a field needed, we will need to use the array notation, using the<code class="literal"> fields</code> setting to specify the list of fields:<a id="id45" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">$person = $this-&gt;Person-&gt;find('first', array(
'contain' =&gt; array(
'Family' =&gt; array(
'Person' =&gt; array(
'fields' =&gt; array('email', 'name')
)
),
'Post.title'
)
));
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec06"/>How it works...</h3></div></div></div><p>We use the<code class="literal"> contain</code> find setting to specify what type of containment we want to use for the find operation. That containment is given as an array, where the array hierarchy mimics that of the model relationships. As the hierarchy can get deep enough to make array notation complex to deal with, the dot notation used throughout this recipe serves as an useful and more readable alternative.<a id="id46" class="indexterm"/>
</p><p>If we want to refer to the model<code class="literal"> Person</code> that belongs to the model<code class="literal"> Family</code>, the proper<code class="literal"> contain</code> syntax for that is<code class="literal"> Person =&gt; Family</code> (we can also use<code class="literal"> Person.Family</code>, which is more concise.)</p><p>We also use the<code class="literal"> fields</code> setting to specify which fields we want fetched for a binding. We do that by specifying an array of field names as part of the binding<code class="literal"> Containable</code> setting.</p><p>
<code class="literal">Containable</code> looks for the<code class="literal"> contain</code> find setting right before we issue a find operation on a model. If it finds one, it alters the model bindings to be returned by issuing<code class="literal"> unbindModel()</code> calls on the appropriate models to unbind those relationships that are not specified in the<code class="literal"> contain</code> find setting. It then sets the<code class="literal"> recursive</code> find setting to the minimum value required to fetch the associated data.</p><p>Let us use a practical example to further understand this wrapping process. Using our<code class="literal"> Person</code> model (which has a<code class="literal"> belongsTo</code> relationship to<code class="literal"> Family</code>, a<code class="literal"> hasOne</code> relationship to<code class="literal"> Profile</code>, and a<code class="literal"> hasMany</code> relationship to<code class="literal"> Post)</code>, the following<code class="literal"> Containable</code> based query:</p><div class="informalexample"><pre class="programlisting">$person = $this-&gt;Person-&gt;find('first', array( 'contain' =&gt; array('Family.Person') ));
</pre></div><p>or the same query using array notation:</p><div class="informalexample"><pre class="programlisting">$person = $this-&gt;Person-&gt;find('first', array( 'contain' =&gt; array('Family' =&gt; 'Person') ));
</pre></div><p>is equivalent to the following set of instructions, which do not use<code class="literal"> Containable</code>, but the built in<code class="literal"> unbindModel()</code> method available in CakePHP's<code class="literal"> Model</code> class:<a id="id47" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">$this-&gt;Person-&gt;unbindModel(array( 'hasOne' =&gt; array('Profile'), 'hasMany' =&gt; array('Post') )); $person = $this-&gt;Person-&gt;find('first', array( 'recursive' =&gt; 2 ));
</pre></div><p>Not using<code class="literal"> Containable</code> is not only much more complicated, but can also pose a problem if we decide to alter some of our relationships. In the preceding example, if we decide to remove the<code class="literal"> Profile</code> binding, or change its relationship type, we would have to modify the<code class="literal"> unbindModel()</code> call. However, if we are using<code class="literal"> Containable</code>, the same code applies, without us having to worry about such changes.</p><div class="section" title="Format of the contain find parameter"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec01"/>Format of the contain find parameter</h4></div></div></div><p>We have seen how to use the<code class="literal"> contain</code> find parameter to limit which bindings are returned after a<code class="literal"> find</code> operation. Even when its format seems self-explanatory, let us go through another example to have a deeper understanding of<code class="literal"> Containable's</code> array notation. Assume that we have the models and relationships shown in the following diagram:<a id="id48" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/1926OS_02_01.jpg" alt="Format of the contain find parameter"/></div><p>Transforming that diagram to something the<code class="literal"> Containable</code> behavior understands is as simple as writing it using an array structure. For example, if we are issuing a<code class="literal"> find</code> operation on the<code class="literal"> User</code> model and we want to refer to the<code class="literal"> Profile</code> relationship, a simple<code class="literal"> array('Profile')</code> expression would suffice, as the<code class="literal"> Profile</code> model is directly related to the<code class="literal"> User</code> model.<a id="id49" class="indexterm"/>
</p><p>If we want to refer to the<code class="literal"> Comment</code> relationship for the<code class="literal"> Article</code> records the<code class="literal"> User</code> is an owner of, which belongs to an<code class="literal"> Article</code> that itself belongs to our<code class="literal"> User</code> model, then we add another dimension to the structure, which is now represented as<code class="literal"> array('Article' =&gt; 'Comment')</code>.</p><p>We can already deduce how the next example will look like. Assume we want to obtain the<code class="literal"> Comment</code> together with the<code class="literal"> Profile</code> of the<code class="literal"> User</code> that commented on each<code class="literal"> Article</code>. The structure will then look like:<code class="literal"> array('Article' =&gt; array('Comment' =&gt; array('User' =&gt; 'Profile')))</code>.</p><p>Sometimes we want to simplify the readability, and fortunately the<code class="literal"> Containable</code> behavior allows the above expression to be rewritten as<code class="literal"> array('Article.Comment.User.Profile')</code>, which is known as dot notation. However, if you want to change other parameters to the binding, then this syntax would have to be changed to the full array-based expression (see section<span class="emphasis"><em> See also</em></span> in this recipe).</p></div><div class="section" title="Reset of binding changes"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl3sec02"/>Reset of binding changes</h4></div></div></div><p>When you issue a find operation that uses the<code class="literal"> Containable</code> behavior to change some of its bindings, CakePHP will reset all bindings' changes to their original states, once the find is completed. This is what is normally wanted on most cases, but there are some scenarios where you want to keep your changes until you manually reset them, such as when you need to issue more than one find operation and have all those finds use the modified bindings.<a id="id50" class="indexterm"/>
</p><p>To force our binding changes to be kept, we use the<code class="literal"> reset</code> option in the<code class="literal"> contain</code> find parameter, setting it to<code class="literal"> false</code>. When we are ready to reset them, we issue a call to the<code class="literal"> resetBindings()</code> method added by the<code class="literal"> Containable</code> behavior to our model. The following sample code shows this procedure:</p><div class="informalexample"><pre class="programlisting">$person = $this-&gt;Person-&gt;find('first', array(
'contain' =&gt; array(
<span class="strong"><strong>'reset' =&gt; false,</strong></span>
'Family'
)
));
// ...
<span class="strong"><strong>$this-&gt;Person-&gt;resetBindings();</strong></span>
</pre></div><p>Another way to achieve the same result is by calling the<code class="literal"> contain()</code> method (setting its first argument to the contained bindings, and its second argument to<code class="literal"> false</code> to indicate that we wish to keep these containments), available to all models that use<code class="literal"> Containable</code>, issue the find (without, need to use the<code class="literal"> contain</code> setting), and then reset the bindings:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$this-&gt;Person-&gt;contain(array('Family'), false);</strong></span>
$person = $this-&gt;Person-&gt;find('first');
// ...
<span class="strong"><strong>$this-&gt;Person-&gt;resetBindings();</strong></span>
</pre></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec07"/>See also</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Modifying binding parameters for a find</em></span></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Modifying binding conditions for a find</em></span></li></ul></div></div></div></div>
<div class="section" title="Modifying binding parameters for a find"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec04"/>Modifying binding parameters for a find</h1></div></div></div><p>This recipe shows how to use<code class="literal"> Containable</code> to change some of the parameters that affect model bindings.<a id="id51" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec08"/>Getting ready</h2></div></div></div><p>To go through this recipe, we need some sample tables to work with.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a table named<code class="literal"> users</code>, using the following SQL statement:<div class="informalexample"><pre class="programlisting">CREATE TABLE `users`(
`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,
`name` VARCHAR(255) NOT NULL,
`email` VARCHAR(255) NOT NULL,
PRIMARY KEY(`id`)
);
</pre></div></li><li class="listitem">Create a table named<code class="literal"> profiles</code>, using the following SQL statement:<div class="informalexample"><pre class="programlisting">CREATE TABLE `profiles`(
`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,
`user_id` INT UNSIGNED NOT NULL,
`website` VARCHAR(255) default NULL,
`birthdate` DATE default NULL,
PRIMARY KEY(`id`),
KEY `user_id`(`user_id`),
CONSTRAINT `profiles__users` FOREIGN KEY(`user_id`) REFERENCES `users`(`id`)
);
</pre></div></li><li class="listitem">Create a table named<code class="literal"> articles</code>, using the following SQL statement:<div class="informalexample"><pre class="programlisting">CREATE TABLE `articles`(
`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,
`user_id` INT UNSIGNED NOT NULL,
`title` VARCHAR(255) NOT NULL,
`body` TEXT NOT NULL,
`published` TINYINT NOT NULL default 1,
`created` DATETIME NOT NULL,
`modified` DATETIME NOT NULL,
PRIMARY KEY(`id`),
KEY `user_id`(`user_id`),
CONSTRAINT `articles__users` FOREIGN KEY(`user_id`) REFERENCES `users`(`id`)
);
</pre></div></li><li class="listitem">Add some sample data, using the following SQL statements:<div class="informalexample"><pre class="programlisting">INSERT INTO `users`(`id`, `name`, `email`) VALUES
(1, 'John Doe', 'john.doe@example.com'),
(2, 'Jane Doe', 'jane.doe@example.com');
INSERT INTO `profiles`(`user_id`, `website`, `birthdate`) VALUES
(1, 'http://john.example.com', '1978-07-13'),
(2, NULL, '1981-09-18');
INSERT INTO `articles`(`user_id`, `title`, `body`, `published`, `created`, `modified`) VALUES
(1, 'John\'s Post 1', 'Body for John\'s Post 1', 1, NOW(), NOW()),
(1, 'John\'s Post 2', 'Body for John\'s Post 2', 1, NOW(), NOW()),
(1, 'John\'s Post 3', 'Body for John\'s Post 3', 0, NOW(), NOW()),
(1, 'John\'s Post 4', 'Body for John\'s Post 4', 1, NOW(), NOW()),
(2, 'Jane\'s Post 1', 'Body for Jane\'s Post 1', 1, NOW(), NOW());
</pre></div></li><li class="listitem">Add the<code class="literal"> Containable</code> behavior to all your models by following the recipe<span class="emphasis"><em> Adding Containable to all models</em></span>.<a id="id52" class="indexterm"/></li><li class="listitem">Now we need to create the main model. Create a file named<code class="literal"> user.php</code> and place it in your<code class="literal"> app/models</code> folder with the following contents:<div class="informalexample"><pre class="programlisting">&lt;?php
class User extends AppModel {
public $hasOne = array('Profile');
public $hasMany = array('Article');
}
?&gt;
</pre></div></li></ol></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec09"/>How to do it...</h3></div></div></div><p>If we want to obtain the first<code class="literal"> User</code> record together with the<code class="literal"> Article</code> records that the<code class="literal"> User</code> owns, but ordered by latest articles first, we use the<code class="literal"> order</code> binding setting (we also use the<code class="literal"> fields</code> setting to limit the fields returned for each<code class="literal"> Article</code>):
</p><div class="informalexample"><pre class="programlisting">$user = $this-&gt;User-&gt;find('first', array(
'contain' =&gt; array(
'Article' =&gt; array(
'fields' =&gt; array('Article.title'),
<span class="strong"><strong>'order' =&gt; array(
'Article.created' =&gt; 'desc',
'Article.id' =&gt; 'desc'
)</strong></span>
)
)
));
</pre></div><p>Using our sample data, the above query will result in the following array structure:</p><div class="informalexample"><pre class="programlisting">array(
'User' =&gt; array(
'id' =&gt; '1',
'name' =&gt; 'John Doe',
'email' =&gt; 'john.doe@example.com',
),
'Article' =&gt; array(
array(
'title' =&gt; 'John\'s Post 4',
'user_id' =&gt; '1'
),
array(
'title' =&gt; 'John\'s Post 3',
'user_id' =&gt; '1'
),
array(
'title' =&gt; 'John\'s Post 2',
'user_id' =&gt; '1'
),
array(
'title' =&gt; 'John\'s Post 1',
'user_id' =&gt; '1'
)
)
)
</pre></div><p>If we want to get the same data, but make sure we only obtain the latest<code class="literal"> Article</code> a<code class="literal"> User</code> has written, we use the<code class="literal"> limit</code> binding setting:<a id="id53" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">$user = $this-&gt;User-&gt;find('first', array(
'contain' =&gt; array(
'Article' =&gt; array(
'fields' =&gt; array('Article.title'),
'order' =&gt; array(
'Article.created' =&gt; 'desc',
'Article.id' =&gt; 'desc'
),
<span class="strong"><strong>'limit' =&gt; 1</strong></span>
)
)
));
</pre></div><p>Using our sample data, the above query will result in the following array structure:</p><div class="informalexample"><pre class="programlisting">array(
'User' =&gt; array(
'id' =&gt; '1',
'name' =&gt; 'John Doe',
'email' =&gt; 'john.doe@example.com',
),
'Article' =&gt; array(
array(
'title' =&gt; 'John\'s Post 4',
'user_id' =&gt; '1'
)
)
)
</pre></div><p>Another option that is useful on some scenarios is<code class="literal"> offset</code>, applicable to the<code class="literal"> hasMany</code> and<code class="literal"> hasAndBelongsToMany</code> bindings. Using the example above, we now want to obtain the two most recent articles a<code class="literal"> User</code> created, after the latest<code class="literal"> Article</code>.<a id="id54" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">$user = $this-&gt;User-&gt;find('first', array(
'contain' =&gt; array(
'Article' =&gt; array(
'fields' =&gt; array('Article.title'),
'order' =&gt; array(
'Article.created' =&gt; 'desc',
'Article.id' =&gt; 'desc'
),
<span class="strong"><strong>'limit' =&gt; 2,
'offset' =&gt; 1</strong></span>
)
)
));
</pre></div><p>The returned data structure now looks like this:</p><div class="informalexample"><pre class="programlisting">array(
'User' =&gt; array(
'id' =&gt; '1',
'name' =&gt; 'John Doe',
'email' =&gt; 'john.doe@example.com',
),
'Article' =&gt; array(
array(
'title' =&gt; 'John\'s Post 3',
'user_id' =&gt; '1'
),
array(
'title' =&gt; 'John\'s Post 2',
'user_id' =&gt; '1'
)
)
)
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec10"/>How it works...</h3></div></div></div><p>The<code class="literal"> Containable</code> behavior uses the built-in<code class="literal"> bindModel()</code> method defined in CakePHP's<code class="literal"> Model</code> class to alter the binding settings defined in the<code class="literal"> contain</code> find setting.<a id="id55" class="indexterm"/>
</p><p>It goes through the defined bindings and checks to see whether there are defined binding settings. If there are, it passes them to the<code class="literal"> bindModel()</code> method for each of the specified bindings.</p><p>Some binding settings make sense only on some relationship types. For example, the<code class="literal"> limit</code> setting used previously would not be useful on<code class="literal"> belongsTo</code> or<code class="literal"> hasOne</code> relationships.</p><p>The following list includes which settings can be specified for each relationship type:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">belongsTo: className, conditions, foreignKey, order</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">hasOne: className, conditions, foreignKey, order</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">hasMany: className, conditions, finderQuery, foreignKey, limit, offset, order</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">hasAndBelongsToMany: associationForeignKey, className, conditions, deleteQuery, finderQuery, foreignKey, insertQuery, joinTable, limit, offset, order, unique, with</code>.</li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec11"/>See also</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Modifying binding conditions for a find</em></span></li></ul></div></div></div></div>
<div class="section" title="Modifying binding conditions for a find"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec05"/>Modifying binding conditions for a find</h1></div></div></div><p>This recipe shows how to use<code class="literal"> Containable</code> to change the conditions used to fetch data related to a model through a binding.<a id="id56" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Getting ready</h2></div></div></div><p>We need to have<code class="literal"> Containable</code> added to our models, and we also need some sample models and data to work with. Follow the recipe,<span class="emphasis"><em> Adding Containable to all models</em></span>, and the<span class="emphasis"><em> Getting ready</em></span> section of the recipe,<span class="emphasis"><em> Modifying binding parameters for a find</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>How to do it...</h2></div></div></div><p>If we want to obtain the first<code class="literal"> User</code> record together with the published<code class="literal"> Article</code> records that user owns, but ordered by latest articles first, and limiting some of the returned fields, we use the<code class="literal"> conditions</code> binding setting:</p><div class="informalexample"><pre class="programlisting">$user = $this-&gt;User-&gt;find('first', array(
'contain' =&gt; array(
'Article' =&gt; array(
'fields' =&gt; array('Article.title'),
<span class="strong"><strong>'conditions' =&gt; array(
'Article.published' =&gt; 1
)</strong></span>
)
)
));
</pre></div><p>Using our sample data, the preceding query will result in the following array structure:<a id="id57" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">array(
'User' =&gt; array(
'id' =&gt; '1',
'name' =&gt; 'John Doe',
'email' =&gt; 'john.doe@example.com',
),
'Article' =&gt; array(
array(
'title' =&gt; 'John\'s Post 1',
'user_id' =&gt; '1'
),
array(
'title' =&gt; 'John\'s Post 2',
'user_id' =&gt; '1'
),
array(
'title' =&gt; 'John\'s Post 4',
'user_id' =&gt; '1'
)
)
)
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>How it works...</h2></div></div></div><p>The conditions binding setting is another binding parameter, such as those shown in the recipe,<span class="emphasis"><em> Modifying binding parameters for a find</em></span>. As such, the<code class="literal"> Containable</code> behavior uses the built-in<code class="literal"> bindModel()</code> method defined in CakePHP's<code class="literal"> Model</code> class to alter the binding conditions defined in the<code class="literal"> contain</code> find operation.<a id="id58" class="indexterm"/>
</p></div></div>
<div class="section" title="Changing the JOIN type of one-to-one associations"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec07"/>Changing the JOIN type of one-to-one associations</h1></div></div></div><p>When we are querying a model that has other associated models, CakePHP will issue a new query to fetch the associated data, or use a<code class="literal"> LEFT JOIN</code> SQL statement if the associated model has a one-to-one relationship with the main model (through a binding defined with<code class="literal"> belongsTo</code> or<code class="literal"> hasOne</code>.)
<a id="id59" class="indexterm"/>
</p><p>However there are times where we need to change the join type for one-to-one associations, to use either a<code class="literal"> RIGHT JOIN</code> or an<code class="literal"> INNER JOIN</code>. This recipe shows us how to change the join type for<code class="literal"> belongsTo</code> and<code class="literal"> hasOne</code> associations.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Getting ready</h2></div></div></div><p>Follow the<span class="emphasis"><em> Getting ready</em></span> section of the recipe,<span class="emphasis"><em> Limiting the bindings returned in a find</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Edit the<code class="literal"> Person</code> model, and change the binding definitions for<code class="literal"> belongsTo</code> and<code class="literal"> hasOne</code> associations, as shown below:<div class="informalexample"><pre class="programlisting">&lt;?php
class Person extends AppModel {
public $belongsTo = array('Family' =&gt; array('type' =&gt; 'INNER'));
public $hasOne = array('Profile' =&gt; array('type' =&gt; 'RIGHT'));
public $hasMany = array('Post');
}
?&gt;
</pre></div></li></ol></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec17"/>How it works...</h3></div></div></div><p>When we add bindings to a model, we can pass an array of settings to the binding definition to configure different aspects of the binding. One of those settings is<code class="literal"> type</code>, only applicable to<code class="literal"> belongsTo</code> and<code class="literal"> hasOne</code> bindings.</p><p>The<code class="literal"> type</code> setting allows us to define what type of<code class="literal"> JOIN</code> CakePHP will use when fetching the associated model (only when querying the main model.) The available<code class="literal"> JOIN</code> types are:<a id="id60" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">INNER JOIN</code>: Joins and only returns records from associated models that match the default join condition. When a binding is set to use this join type, only records that have a record for the binding will be returned. In the example above, only<code class="literal"> Person</code> records that belong to a<code class="literal"> Family</code> will be returned.<a id="id61" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">LEFT JOIN</code>: This is the default join type used by CakePHP. All records are returned even if there is no record for the binding. In the example above, if the<code class="literal"> Family</code> binding type is set to<code class="literal"> LEFT</code>, then<code class="literal"> Person</code> records will be returned even if they don't belong to a<code class="literal"> Family</code>.<a id="id62" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">RIGHT JOIN</code>: The opposite of<code class="literal"> LEFT JOIN</code>, shows all records from the related model even if they are not related to the main model, and shows only records in the main model that are linked to the related model.<a id="id63" class="indexterm"/></li></ul></div></div></div></div>
<div class="section" title="Defining multiple associations to the same model"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec09"/>Defining multiple associations to the same model</h1></div></div></div><p>This recipe shows how to set up more than one association from one model to the same model, a need that normally arises on most applications.<a id="id64" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Getting ready</h2></div></div></div><p>To go through this recipe we need some sample tables to work with.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a table named<code class="literal"> addresses</code>, using the following SQL statement:<div class="informalexample"><pre class="programlisting">CREATE TABLE `addresses`(
`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,
`address` TEXT NOT NULL,
`city` VARCHAR(255) default NULL,
`state` VARCHAR(255) NOT NULL,
`zip` VARCHAR(10) NOT NULL,
`country` CHAR(3) NOT NULL,
PRIMARY KEY(`id`)
);
</pre></div></li><li class="listitem">Create a table named<code class="literal"> users</code>, using the following SQL statement:<div class="informalexample"><pre class="programlisting">CREATE TABLE `users`(
`id` INT UNSIGNED AUTO_INCREMENT NOT NULL,
`billing_address_id` INT UNSIGNED default NULL,
`home_address_id` INT UNSIGNED default NULL,
`name` VARCHAR(255) NOT NULL,
`email` VARCHAR(255) NOT NULL,
PRIMARY KEY(`id`),
KEY `billing_address_id`(`billing_address_id`),
KEY `home_address_id`(`home_address_id`),
CONSTRAINT `addresses__billing_address_id` FOREIGN KEY(`billing_address_id`) REFERENCES `addresses`(`id`),
CONSTRAINT `addresses__home_address_id` FOREIGN KEY(`home_address_id`) REFERENCES `addresses`(`id`)
);
</pre></div></li><li class="listitem">Add some sample data, using the following SQL statements:<div class="informalexample"><pre class="programlisting">INSERT INTO `addresses`(`id`, `address`, `city`, `state`, `zip`, `country`) VALUES
(1, '123 Street', 'Palo Alto', 'CA', '94310', 'USA'),
(2, '123 Street', 'London', 'London', 'SE10AA', 'GBR');
INSERT INTO `users`(`billing_address_id`, `home_address_id`, `name`, `email`) VALUES
(1, 2, 'John Doe', 'john.doe@example.com');
</pre></div></li><li class="listitem">Now we need to create the main model. Create a file named<code class="literal"> user.php</code> and place it in your<code class="literal"> app/models</code> folder with the following contents:<div class="informalexample"><pre class="programlisting">&lt;?php
class User extends AppModel {
}
?&gt;
</pre></div></li></ol></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec19"/>How to do it...</h3></div></div></div><p>Edit the<code class="literal"> User</code> model, and add the binding definitions to include both references to the<code class="literal"> Address</code> model:<a id="id65" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
class User extends AppModel {
public $belongsTo = array(
'BillingAddress' =&gt; array(
'className' =&gt; 'Address'
),
'HomeAddress' =&gt; array(
'className' =&gt; 'Address'
)
);
}
?&gt;
</pre></div><p>If we issue a find operation to fetch the<code class="literal"> User</code>, we would obtain the following data structure:</p><div class="informalexample"><pre class="programlisting">array(
'User' =&gt; array(
'id' =&gt; '1',
'billing_address_id' =&gt; '1',
'home_address_id' =&gt; '2',
'name' =&gt; 'John Doe',
'email' =&gt; 'john.doe@example.com',
),
'BillingAddress' =&gt; array(
'id' =&gt; '1',
'address' =&gt; '123 Street',
'city' =&gt; 'Palo Alto',
'state' =&gt; 'CA',
'zip' =&gt; '94310',
'country' =&gt; 'USA'
),
'HomeAddress' =&gt; array(
'id' =&gt; '2',
'address' =&gt; '123 Street',
'city' =&gt; 'London',
'state' =&gt; 'London',
'zip' =&gt; 'SE10AA',
'country' =&gt; 'GBR'
)
)
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl2sec20"/>There's more...</h3></div></div></div><p>In this example, the naming convention we used for the bindings is the standard CakePHP uses for field names, where each uppercase letter is prefixed by an underscore sign, everything is converted to lowercase, and the suffix<code class="literal"> _id</code> is added. Thus, the standard field name the binding named<code class="literal"> BillingAddress</code> is<code class="literal"> billing_address_id</code>.<a id="id66" class="indexterm"/>
</p><p>However there are times where we need to use a field name that does not comply with this standard. In that case, we can use the<code class="literal"> foreignKey</code> binding setting to specify the field name. For example, we could change the<code class="literal"> User</code> model definition so the name of the<code class="literal"> HomeAddress</code> becomes<code class="literal"> Address</code>, which would make the<code class="literal"> User</code> model look like this:</p><div class="informalexample"><pre class="programlisting">&lt;?php
class User extends AppModel {
public $belongsTo = array(
'BillingAddress' =&gt; array(
'className' =&gt; 'Address'
),
<span class="strong"><strong>'Address' =&gt; array(</strong></span>
'className' =&gt; 'Address',
<span class="strong"><strong>'foreignKey' =&gt; 'home_address_id'</strong></span>
)
);
}
?&gt;
</pre></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note09"/>Note</h3><p>When we use different aliases to refer to the same model, certain model callback implementations, such as<code class="literal"> beforeSave</code>, will need to be changed to avoid using the name of the model directly, and instead use the property<code class="literal"> alias</code>, available in all models. More information about this can be obtained from Nick Baker's article available at <a class="ulink" href="http://www.webtechnick.com/blogs/view/230/The_Power_of_CakePHP_aliases">http://www.webtechnick.com/blogs/view/230/The_Power_of_CakePHP_aliases</a>.</p></div></div></div></div>
<div class="section" title="Adding bindings on the fly"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec10"/>Adding bindings on the fly</h1></div></div></div><p>This recipe shows how to set up new bindings right before a find operation, including bindings that are automatically removed after the operation is executed, and bindings that are permanently added.<a id="id67" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Getting ready</h2></div></div></div><p>We need some sample models and data to work with. Follow the<span class="emphasis"><em> Getting ready</em></span> section of the recipe,<span class="emphasis"><em> Modifying binding parameters for a find</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>How to do it...</h2></div></div></div><p>If we want to obtain the latest published<code class="literal"> Article</code> when we are fetching a<code class="literal"> User</code>, we could add a permanent binding to the<code class="literal"> User</code> model. However, if we want to do this on a need-by-need basis, it is smarter to add the binding before the find operation that needs it, thus avoiding the unneeded overhead for other operations.</p><p>We can add the needed binding and then issue the<code class="literal"> find</code> operation:</p><div class="informalexample"><pre class="programlisting">$this-&gt;User-&gt;bindModel(array(
'hasOne' =&gt; array(
'LastArticle' =&gt; array(
'className' =&gt; 'Article',
'conditions' =&gt; array(
'LastArticle.published' =&gt; 1
),
'order' =&gt; array(
'LastArticle.created' =&gt; 'desc',
'LastArticle.id' =&gt; 'desc'
)
)
)
));
$user = $this-&gt;User-&gt;find('first', array(
'conditions' =&gt; array(
'User.id' =&gt; 1
),
'contain' =&gt; array(
'LastArticle' =&gt; array('fields' =&gt; array('title'))
)
));
</pre></div><p>The preceding code would give us the following data structure:</p><div class="informalexample"><pre class="programlisting">array(
'User' =&gt; array(
'id' =&gt; '1',
'name' =&gt; 'John Doe',
'email' =&gt; 'john.doe@example.com',
),
'LastArticle' =&gt; array(
'title' =&gt; 'John\'s Post 4'
)
)
</pre></div><p>If we want to make the binding permanent until the request ends, but without adding the binding to the<code class="literal"> User</code> model, we simply add the value<code class="literal"> false</code> as a second parameter to the<code class="literal"> bindModel()</code> call (this is needed if the operation is a<code class="literal"> paginate ()</code> call, as this call will issue two<code class="literal"> find</code> operations):<a id="id68" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">$this-&gt;User-&gt;bindModel(array(
'hasOne' =&gt; array(
'LastArticle' =&gt; array(
'className' =&gt; 'Article',
'conditions' =&gt; array(
'LastArticle.published' =&gt; 1
),
'order' =&gt; array(
'LastArticle.created' =&gt; 'desc',
'LastArticle.id' =&gt; 'desc'
)
)
)
<span class="strong"><strong>), false);</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>How it works...</h2></div></div></div><p>When you issue a<code class="literal"> bindModel()</code> call, CakePHP will add the binding as if you specified it on the model itself. If you did not set the second parameter to the method as<code class="literal"> false</code>, that binding will be automatically removed after the<code class="literal"> find</code> operation is completed. If you did set it in order to avoid the reset, then it will be kept until the script instance of your application is finished.</p><p>The format to specify bindings through<code class="literal"> bindModel()</code> is an array, indexed by the binding type (one of<code class="literal"> belongsTo, hasOne, hasMany</code>, and<code class="literal"> hasAndBelongsToMany</code>), whose value for each binding type is an array of associations.</p><p>You define each association (as you would normally do) in the model, indexing it by association name (if it is different than the model's name it is pointing to or if you have binding parameters to define), or, optionally, simply referring to the related model.<a id="id69" class="indexterm"/>
</p></div></div></body></html>