<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer096">
			</div>
		</div>
		<div class="Content" id="_idContainer097">
			<h1 id="_idParaDest-166"><a id="_idTextAnchor172"/>5. Object-Oriented Programming</h1>
		</div>
		<div class="Content" id="_idContainer127">
			<p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to declare classes with constants, attributes, and methods; instantiate a class; work with constructors and destructors; implement class inheritance, access modifiers, static fields, and methods; use class type hinting as dependency injection; use attribute and method overriding; apply attribute and method overloading via magic methods; use final classes and methods; autoload classes; and use traits and apply namespacing.</p>
			<p class="callout">To summarize, we will have a look at <strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>) concepts that can be leveraged to write modular code.</p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor173"/>Introduction</h1>
			<p>In order to understand the <strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>) approach, we should start by discussing the procedural-oriented programming approach first. The procedural approach is the conventional way of writing code in high-level languages where a problem is considered a sequence of things to be performed, such as walking, eating, reading, and so on. A number of functions can be written to accomplish such tasks. The procedural approach organizes a set of computer instructions into groups called procedures – also known as functions. Therefore, functions are first-class citizens in your code. When we focus that much on functions, consequently, the data gets less attention.</p>
			<p>In a multi-function program, despite the fact that functions can house local data, a lot of important data is defined as global data. Several functions might operate on such global data and, therefore, the data might become vulnerable. Also, such an approach might not establish a secure way of interacting with data using functions.</p>
			<p>The following figure shows you how functions operate on global data and how they interact with each other:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer098">
					<img alt="Figure 5.1: Data and functions in the procedural-oriented approach&#13;&#10;" src="image/C14196_05_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1: Data and functions in the procedural-oriented approach</p>
			<p>Now, the object-oriented approach comes with a number of different ways to secure your data by tying the data more closely to the functions so that accidental modifications to the data from external functions can be prevented. The approach, by nature, allows us to decompose a large problem into smaller entities called objects and bundles the data and functions into such objects. The following figure shows how data and functions are organized into objects:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer099">
					<img alt="Figure 5.2: Data and functions in the object-oriented approach&#13;&#10;" src="image/C14196_05_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2: Data and functions in the object-oriented approach</p>
			<p>A programming approach should address major concerns, such as how we represent real-life problem entities in a program, how to design a program with standard interfaces to interact with functions, how to organize a program into a number of modules so that we can reuse and extend them later, how to add new features to such modules, and much more. The object-oriented approach was developed to address such issues.</p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor174"/>The Object-Oriented Approach</h1>
			<p>In programming, a thing that is describable and has a certain set of actions can be referred to as an object. An object might represent a real-life entity with a certain number of actions to perform. A dog can be described by using certain states, such as color, breed, age, and so on, and performs certain actions, such as barking, running, wagging its tail, and so on. A table fan can be described by color, speed, direction, and so on, and perform actions such as changing speed, changing direction, rotating, and so on.</p>
			<p>In OOP, data and code are bundled together into an entity, which is known as an object. Objects interact with each other. Consider a teacher object and a student object. The teacher might have certain subjects to offer and the student might enroll in these subjects. Hence, if we consider enrolling as an action of the student, then the student object might need to interact with the teacher object regarding the available subjects and register for one or more subjects. Simply put, an object is data that performs actions.</p>
			<p>Bundling code into objects has its own benefits, such as your code base becoming modular, which means you can maintain, reuse, and debug your code individually against objects. The implementation of an object (code) remains hidden from the outside world, which means we can hide our data and internal complexities and can interact with the object via a standard set of procedures. For example, in order to use a table fan, you don't need to learn about AC motors or electronic circuitry; rather, you can use the table fan via the provided actions, such as the speed control buttons or rotation control. Hence, hiding such information is another important aspect of OOP.</p>
			<p>Such code bundling also differentiates OOP from procedural programming. An object simply contains attributes, also known as data, and a bunch of methods to communicate with that object. These methods are the functions of procedural programming. In OOP, some of these methods can be used to interact with that object, and these methods therefore make up its interface.</p>
			<p>There are a good number of famous programming languages, such as C++, Java, PHP, Python, C#, JavaScript, Ruby, Dart, Swift, Objective-C, and so on, that support OOP. Since the introduction of PHP to its most recent version, PHP supports the complete set of object-oriented models. PHP supports class-based object initiation, constructors and destructors, inheritance, property visibility, polymorphism, abstract and final classes, static fields and methods, anonymous classes, interfaces, namespaces, magic methods, object cloning, object comparisons, type hinting, traits, and much more interesting OOP techniques and tools. We will be discussing them in this chapter and will practice the concepts of OOP using different examples. </p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor175"/>OOP Concepts</h2>
			<p>The object-oriented approach addresses programming problems using the generalized concepts given in the following list. In this chapter, we are going to discuss these concepts in detail and practice them using a number of exercises so that, by the end of the chapter, we'll be used to working with these concepts:</p>
			<ul>
				<li>Objects are entities with data and interfaces. They may represent a person, a vehicle, a table fan, or maybe a bank account that plays a role in our program. Data and functions (or methods) live together inside an object.</li>
				<li>Classes are templates for object creation. Data is the description of an object, while functions are the behaviors of that object, so such definitions of data and methods can be written using a class. Classes can be referred to as custom data types.</li>
				<li>Data encapsulation is the wrapping up of data and functions into a single unit – that is, a class. Imagine an unbreachable capsule with data and functions encapsulated inside so that the outside world cannot access the data as long as we don't expose methods for them. Such insulation of the data from direct access by the program is called data hiding. In short, declaring a class is the encapsulation of data.</li>
				<li>Data abstraction is the act of representing essential properties and features without giving details. So, the entire entity description remains abstract and the responsibility of detailing the entity can be done via the entity creation process or inheritance. Such abstraction enables everyone to "follow the guidelines and do it your way."</li>
				<li>Inheritance is the process of acquiring properties and behaviors of another class so that common properties and behaviors can be reused in a hierarchical manner.</li>
				<li>Polymorphism is the concept of using the same definition for multiple purposes. For example, flying is a polymorphic behavior, as birds and airplanes have their own different ways of flying.</li>
				<li>Dynamic binding is the linking of a function call to the code that will be executed in response to the function call. With this concept, the code associated with the given function is unknown until the call is made at runtime. Say that multiple objects implemented the same function differently and at runtime, the code matching the object being referenced would be called.</li>
				<li>Message passing is the way that objects interact with each other. It involves specifying the object name, the name of the methods, and the information to be sent. For example, if a car is an object, changing speed is a method on it, and speed in kilometers per hour is the speed parameter to be passed. The outside world will use the car object to send the "change speed" message to that parameter.</li>
			</ul>
			<p><em class="italic">Figure 5.3</em> depicts the preceding concepts using a vehicle analogy:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer100">
					<img alt="Figure 5.3: Vehicle property inheritance diagram&#13;&#10;" src="image/C14196_05_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3: Vehicle property inheritance diagram</p>
			<p>There are many different types of vehicles, such as cars, buses, motorcycles, airplanes, and many more. Vehicles have general properties such as make, model, color, wheels, engine size, and so on. These are the common properties found in vehicle subtypes or classes too. Since cars, buses, motorcycles, and so on share a common list of properties, those common properties and behaviors come from the parent class, and each subclass adds its very own properties and behaviors. For example, cars have four wheels and motorcycles are two-wheelers, cars have more passenger capacity than a motorcycle, and so on. Therefore, such deviations of vehicle types should be placed into their own vehicle subclasses. Thus, we can inherit common properties and gradually add our own properties using object-oriented concepts.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor176"/>Classes </h2>
			<p>A class is a blueprint of an object. What data an object should contain and what methods are needed to access that data can be described using a class. A class acts as a template for object creation. Consider a car designed using a blueprint as a guide. Vehicle type, make, model, engine size, color, and so on are defined in the <strong class="source-inline">Car</strong> class along with the methods to retrieve this information, such as get the model name, start the engine, and so on.</p>
			<p>A class begins with the <strong class="source-inline">class</strong> keyword followed by the given name and the body enclosed in a pair of curly braces. The body of the class houses class members and they are variables, constants, functions, class variables (also known as class properties or class attributes), and the functions that belong to the class, known as class methods.</p>
			<p>Check out the following class declaration:</p>
			<p class="source-code">class ClassName </p>
			<p class="source-code">{</p>
			<p class="source-code">    // Class body</p>
			<p class="source-code">}</p>
			<p class="source-code">//or </p>
			<p class="source-code">class ClassName </p>
			<p class="source-code">{</p>
			<p class="source-code">    // Class variables declarations</p>
			<p class="source-code">    // Class methods declarations</p>
			<p class="source-code">}</p>
			<p>A class name starts with letters or underscores followed by any number of alphanumeric characters and underscores. PHP's predefined class names, constants, and reserved keywords – for example, <strong class="source-inline">break</strong>, <strong class="source-inline">else</strong>, <strong class="source-inline">function</strong>, <strong class="source-inline">for</strong>, <strong class="source-inline">new</strong>, and so on – cannot be used as a class name.</p>
			<p>The list of reserved words in PHP can be found at <a href="https://packt.live/2M3QL1d">https://packt.live/2M3QL1d</a>.</p>
			<p>In the PHP Standards Recommendations, PSR-1 recommends that a class name is declared in <strong class="source-inline">CamelizedClassName</strong> and class methods are declared in <strong class="source-inline">camelizedMethodName</strong>. Note the camel case of <em class="italic">class name</em> and the use of lowercase at the start of the method names. </p>
			<p>To learn more about PSR-1: Basic Coding Standard, visit <a href="https://packt.live/2IBLprS">https://packt.live/2IBLprS</a>.</p>
			<p>Let's check out the following simple <strong class="source-inline">Person</strong> class:</p>
			<p class="source-code">class Person </p>
			<p class="source-code">{</p>
			<p class="source-code">    public $name = 'John Doe';</p>
			<p class="source-code">    function sayHello() </p>
			<p class="source-code">    {</p>
			<p class="source-code">        echo 'Hello!';</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, <strong class="source-inline">class Person {…}</strong> is the <strong class="source-inline">Person</strong> class declaration. A single attribute has been added with the line <strong class="source-inline">public $name = 'John Doe';</strong>, and the body also contains the <strong class="source-inline">sayHello()</strong> member method, which prints a simple string. </p>
			<p>In the next section, we will be discussing how we should instantiate a class and what happens in memory when we perform such an instantiation. </p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor177"/>Instantiating a Class </h2>
			<p>An object is an instance of a class, so instantiating a class means creating a new object using the class. We can instantiate a class using the <strong class="source-inline">new</strong> keyword, as follows:</p>
			<p class="source-code">$object = new MySimpleClass();</p>
			<p>With the instantiation, an object is created in memory with copies of its own attributes. Here, the <strong class="source-inline">$object</strong> variable doesn't hold the actual object; rather, it points to the object. Just to be clear here, the <strong class="source-inline">$object</strong> variable is a pointer to the object and doesn't hold a reference to the object.</p>
			<p>The <strong class="source-inline">$object</strong> variable should be of the <strong class="source-inline">MySimpleClass</strong> type as classes are often called as custom data types. Then, the constructor method gets called automatically if one is declared. A class constructor and destructor are two special kinds of methods; for example, <strong class="source-inline">__construct()</strong> and <strong class="source-inline">__destruct()</strong>, which are called automatically with object creation and deletion, respectively.</p>
			<p>To access an object's properties and methods, we can use the <strong class="source-inline">-&gt;</strong> object operator, as in the following:</p>
			<p class="source-code">$object-&gt;propertyName;</p>
			<p class="source-code">$object-&gt;methodName();</p>
			<p>So, object creation involves memory allocation followed by the constructor method being called automatically. We are going to discuss constructor and destructor methods in later sections.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor178"/>Class Attributes</h2>
			<p>As we have already seen, class attributes and variables hold data. To write a class attribute in PHP, we need to start with the <strong class="source-inline">public</strong>, <strong class="source-inline">private</strong>, or <strong class="source-inline">protected</strong> keyword, then the rest is the general PHP variable assignment statement. In the previous example, in the <strong class="source-inline">Person</strong> class, the <strong class="source-inline">public $name = 'John Doe';</strong> line was used to assign a person's name; here, the <strong class="source-inline">public</strong> keyword is an access modifier or class member visibility keyword and it has been used so that the attribute can be accessed outside of the class. We will be discussing access modifiers in detail in later sections.</p>
			<p>Note that the class structure is compiled before the PHP file execution. Regarding value assignment in class attributes, the value should be static, meaning the value must not be dependent on the runtime. For example, the following class attributes won't work:</p>
			<p class="source-code">public $date = getdate();</p>
			<p class="source-code">public $sum = $a + $b;</p>
			<p>Here, the attributes are dependent on the <strong class="source-inline">getdate()</strong> function's return and an arithmetic expression evaluation, respectively, as function calling and the arithmetic expression evaluation won't be performed during the class' compile time and can be evaluated at runtime, so such variable initialization won't work in the case of class attributes. </p>
			<p>So, class attributes that do not involve in runtime information should be considered a good attribute, such as the following:</p>
			<p class="source-code">public $num = 10;</p>
			<p class="source-code">public $str = 'I am a String';</p>
			<p class="source-code">public $arr = array('Apple', 'Mango', 'Banana');</p>
			<p>Here, the preceding variables can be evaluated at compile time rather than at runtime.</p>
			<p>Non-static class attributes—for example, the <strong class="source-inline">public</strong>, <strong class="source-inline">private</strong>, and <strong class="source-inline">protected</strong> attributes—can be accessed by using the <strong class="source-inline">$this</strong> object context referrer variable with the <strong class="source-inline">-&gt;</strong> object operator, as in the following:</p>
			<p class="source-code">class Person </p>
			<p class="source-code">{</p>
			<p class="source-code">    public $name = 'John Doe';</p>
			<p class="source-code">    function printName() </p>
			<p class="source-code">    {</p>
			<p class="source-code">        echo $this-&gt;name;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Also, static properties can be written with the <strong class="source-inline">static</strong> keyword at the start of the variable declaration and can be accessed using the <strong class="source-inline">self</strong> keyword followed by the <strong class="source-inline">::</strong> (double colon) operator. The double colon is also called the scope operator:</p>
			<p class="source-code">class Person </p>
			<p class="source-code">{</p>
			<p class="source-code">    public static $name = 'John Doe';</p>
			<p class="source-code">    function printName() </p>
			<p class="source-code">    {</p>
			<p class="source-code">        echo self::$name;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>More on access modifiers and static properties can be found in later sections.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor179"/>Class Constants</h2>
			<p>Class-specific constants (fixed values that do not change throughout the program) can be written inside a class, as in the following examples:</p>
			<p class="source-code">class SampleClass </p>
			<p class="source-code">{</p>
			<p class="source-code">    const ONE = 1;</p>
			<p class="source-code">    const NAME = 'John Doe';</p>
			<p class="source-code">}</p>
			<p class="source-code">echo SampleClass::ONE; //1</p>
			<p class="source-code">echo SampleClass::NAME; //John Doe</p>
			<p>Note that class constants do not use <strong class="source-inline">$</strong> as it is used in variable declaration and are all the letters are in uppercase. The default visibility of the constant is <strong class="source-inline">public</strong> and they can be accessed with the <strong class="source-inline">::</strong> scope operator from outside of the class.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">According to the PHP Standards Recommendations, PSR-1, "Class constants MUST be declared in all upper case with underscore separators." You can read more at <a href="https://packt.live/2IBLprS">https://packt.live/2IBLprS</a>. </p>
			<p>Class constants are allocated memory for a single class and not for every class instance. </p>
			<p>Also, you can use such constants using <strong class="source-inline">self::</strong> inside a class, as in the following:</p>
			<p class="source-code">class SampleClass </p>
			<p class="source-code">{</p>
			<p class="source-code">    const ONE = 1;</p>
			<p class="source-code">    const NAME = 'John Doe';</p>
			<p class="source-code">    function printName()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        echo self::NAME;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">echo SampleClass::NAME; //John Doe</p>
			<p>The <strong class="source-inline">self::</strong> operator can be used only inside a class. Since PHP 5.6.0, the constant expression has been added as in the following:</p>
			<p class="source-code">class SampleClass </p>
			<p class="source-code">{</p>
			<p class="source-code">    const ONE = 1;</p>
			<p class="source-code">    const SUM = self::ONE + 2;</p>
			<p class="source-code">}</p>
			<p class="source-code">echo SampleClass::SUM;//3</p>
			<p>Class constants also support access modifiers; for example, <strong class="source-inline">public</strong>, <strong class="source-inline">private</strong>, and so on, which will be demonstrated in the <em class="italic">Access Modifiers</em> section.</p>
			<p>You can use such constants in PHP interfaces, which are another OOP tool to establish a common interface or the standards that classes should implement.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor180"/>The $this Variable</h2>
			<p><strong class="source-inline">$this</strong> is the pseudo variable that is available when class member variables or methods are called within an object context. <strong class="source-inline">$this</strong> works when we have instantiated a class and can be used to access the corresponding object's members. So, to access an attribute in an object context, we use <strong class="source-inline">$this-&gt;attribute_name</strong>, and to access a method, we use <strong class="source-inline">$this-&gt;methodName()</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For example, a <strong class="source-inline">$name</strong> attribute declared in the class should be accessed with <strong class="source-inline">$this-&gt;name</strong>, not with <strong class="source-inline">$this-&gt;$name</strong>. Mind the <strong class="source-inline">$</strong> here.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor181"/>Class Methods</h2>
			<p>Class methods are just functions and act like wrappers on the class data assigned to attributes. Getter and setter are the two most common ways of fetching and assigning data, respectively. Both of these methods simply return and assign data from and to member variables. We might want to prefix the getter and setter methods with <strong class="source-inline">get</strong> and <strong class="source-inline">set</strong> followed by a quick descriptive method name of our choice; for example, <strong class="source-inline">getMyValue()</strong> or <strong class="source-inline">setMyValue()</strong>. Although this is not necessary, this practice improves code readability.</p>
			<p>Check out the following getter and setter methods example:</p>
			<p class="source-code">class Person </p>
			<p class="source-code">{</p>
			<p class="source-code">    public $name;</p>
			<p class="source-code">    function getName()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return $this-&gt;name;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    function setName()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        $this-&gt;name = 'John Doe';</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, the key concept of such member methods is to provide a wrapper around the data available in an object.</p>
			<p>Along with these, another type of method can often be used that performs certain actions or executions based on the available data within the object:</p>
			<p class="source-code-heading">Person.php</p>
			<p class="source-code">17     function sayGreetings()</p>
			<p class="source-code">18     {</p>
			<p class="source-code">19         if (date('G') &lt; 12)</p>
			<p class="source-code">20         {</p>
			<p class="source-code">21             $greetings = 'Good Morning';</p>
			<p class="source-code">22         } </p>
			<p class="source-code">23         elseif (date('G') &lt; 17) </p>
			<p class="source-code">24         {</p>
			<p class="source-code">25             $greetings = 'Good Afternoon';</p>
			<p class="source-code">26         } </p>
			<p class="source-code">27         else </p>
			<p class="source-code">28         {</p>
			<p class="source-code">29             $greetings = 'Good Evening';</p>
			<p class="source-code">30         }</p>
			<p class="source-code-link"><a href="https://packt.live/2IDp7G4">https://packt.live/2IDp7G4</a></p>
			<p>Here, the <strong class="source-inline">sayGreetings()</strong> method could be an example of a member method that implements an algorithm to identify the current hour and load a greetings string into a local variable, and later on prints the greetings string with the given attribute value assigned at <strong class="source-inline">$name</strong>. The method works for printing greetings – for example, '<strong class="source-inline">Good Morning John Doe</strong>', '<strong class="source-inline">Good Afternoon John Doe</strong>', and '<strong class="source-inline">Good Evening John Doe</strong>' – based on the current hour in 24-hour format, returned by the <strong class="source-inline">date('G')</strong> function.</p>
			<p>We also have some manager methods, such as constructor and destructor, to initiate properties of an object and clean up the memory utilized by an object, respectively. In later sections, we will be discussing them in detail.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor182"/>Exercise 5.1: Using the Getter and Setter Methods</h2>
			<p>In the following exercise, you will declare a <strong class="source-inline">Vehicle</strong> class with attributes such as make, model, color, and number of wheels. Also, to access and work on those given attributes, we will be declaring some methods, such as to get the model name, get the engine number, get the number of the wheels, and so on: </p>
			<ol>
				<li>Create a PHP file named <strong class="source-inline">Vehicle.php</strong> and declare the <strong class="source-inline">Vehicle</strong> class with the following attributes:<p class="source-code">&lt;?php</p><p class="source-code">class Vehicle </p><p class="source-code">{</p><p class="source-code">    public $make = 'DefaultMake';</p><p class="source-code">    public $model = 'DefaultModel';</p><p class="source-code">    public $color = 'DefaultColor';</p><p class="source-code">    public $noOfWheels = 0; </p><p class="source-code">    public $engineNumber = 'XXXXXXXX';</p><p class="source-code">}</p><p>A <strong class="source-inline">Vehicle</strong> object is described using a make, model, color, number of wheels, and engine number. Here, we have added this data about the vehicle in terms of class attributes. As different types of data can be bundled together inside a class, our <strong class="source-inline">Vehicle</strong> class can act as a custom data type. Just like the preceding class, we can enclose a lot of metadata about an object, as per OOP concepts.</p><p>Note that the values that have been assigned to the class attributes do not depend on runtime; they can easily be assigned at compile time. All of them are clearly different types of data and are accessible or visible from outside the class as they use a public access modifier.</p></li>
				<li>Now it is time to add member methods to the class. As per our exercise goal, we need to know information such as the number of wheels the vehicle has, the engine number, and the make, model, and color. In order to obtain that information, we are going to add the following five methods after the attributes section:<p class="source-code-heading">Vehicle.php</p><p class="source-code">9      function getMake()</p><p class="source-code">10     {</p><p class="source-code">11         return $this-&gt;make;</p><p class="source-code">12     }</p><p class="source-code">13     function getModel()</p><p class="source-code">14     {</p><p class="source-code">15         return $this-&gt;model;</p><p class="source-code">16     }</p><p class="source-code">17     function getColor()</p><p class="source-code">18     {</p><p class="source-code">19         return $this-&gt;color;</p><p class="source-code">20     }</p><p class="source-code-link"><a href="https://packt.live/2VwyVHi">https://packt.live/2VwyVHi</a></p><p>Here, we have added five getter methods: <strong class="source-inline">getMake()</strong> returns the company name/make, <strong class="source-inline">getModel()</strong> returns the model name, <strong class="source-inline">getColor()</strong> returns the color name, <strong class="source-inline">getNoOfWheels()</strong> returns the number of wheels the vehicle has, and <strong class="source-inline">getEngineNumber()</strong> returns the engine number. All of these methods are pretty straightforward to execute, and they access the attributes using <strong class="source-inline">$this</strong> to return the values.</p></li>
				<li>To set the vehicle make, model, color, number of wheels, and engine number, we need setter methods. Now, let's add the corresponding setter methods after the preceding five getters:<p class="source-code-heading">Vehicle.php</p><p class="source-code">29     function setMake($make)</p><p class="source-code">30     {</p><p class="source-code">31         $this-&gt;make = $make;</p><p class="source-code">32     }</p><p class="source-code">33     function setModel($model)</p><p class="source-code">34     {</p><p class="source-code">35         $this-&gt;model = $model;</p><p class="source-code">36     }</p><p class="source-code">37     function setColor($color)</p><p class="source-code">38     {</p><p class="source-code">39         $this-&gt;color = $color;</p><p class="source-code">40     }</p><p class="source-code">41     function setNoOfWheels($wheels)</p><p class="source-code">42     {</p><p class="source-code">43         $this-&gt;noOfWheels = $wheels;</p><p class="source-code">44     }</p><p class="source-code-link"><a href="https://packt.live/33dTLO2">https://packt.live/33dTLO2</a></p><p>Here, we have added the five setter methods to set our appropriate class attributes. The <strong class="source-inline">setMake($make)</strong> method accesses the class attribute for <strong class="source-inline">$make</strong> using <strong class="source-inline">$this-&gt;make</strong> and assigns the <strong class="source-inline">$make</strong> argument to it. The same goes for <strong class="source-inline">setModel($model)</strong>, <strong class="source-inline">setColor($color)</strong>, <strong class="source-inline">setNoOfWheels($wheels)</strong>, and <strong class="source-inline">setEngineNumber($engineNo)</strong>. All of them access the corresponding class attributes to assign the passed parameter to them. Hence, we can set class attributes using setter methods.</p><p>Finally, our class looks like the following:</p><p class="source-code-heading">Vehicle.php</p><p class="source-code">1  &lt;?php</p><p class="source-code">2  class Vehicle </p><p class="source-code">3  {</p><p class="source-code">4      public $make = 'DefaultMake';</p><p class="source-code">5      public $model = 'DefaultModel';</p><p class="source-code">6      public $color = 'DefaultColor';</p><p class="source-code">7      public $noOfWheels = 0; </p><p class="source-code">8      public $engineNumber = 'XXXXXXXX';</p><p class="source-code">9      function getMake()</p><p class="source-code">10     {</p><p class="source-code">11             return $this-&gt;make;</p><p class="source-code">12     }</p><p class="source-code-link"><a href="https://packt.live/2p52XFU">https://packt.live/2p52XFU</a></p></li>
				<li>Now, let's instantiate the class as follows:<p class="source-code">$object = new Vehicle();</p><p>Here, the class has been instantiated to create an object of the <strong class="source-inline">Vehicle</strong> class.</p></li>
				<li>Set the class attributes using the setter methods, as follows:<p class="source-code">$object-&gt;setMake('Honda');</p><p class="source-code">$object-&gt;setModel('Civic');</p><p class="source-code">$object-&gt;setColor('Red');</p><p class="source-code">$object-&gt;setNoOfWheels(4);</p><p class="source-code">$object-&gt;setEngineNumber('ABC123456');</p><p>Here, we have assigned the make, model, color, number of wheels, and engine number class attributes via the class member methods; that is, setter methods. </p></li>
				<li>To access the data stored in the <strong class="source-inline">Vehicle</strong> object handler, <strong class="source-inline">$object</strong>, we need to use getter methods, as in the following:<p class="source-code">echo "Make : " . $object-&gt;getMake() . PHP_EOL;</p><p class="source-code">echo "Model : " . $object-&gt;getModel() . PHP_EOL;</p><p class="source-code">echo "Color : " . $object-&gt;getColor() . PHP_EOL;</p><p class="source-code">echo "No. of wheels : " . $object-&gt;getNoOfWheels() . PHP_EOL;</p><p class="source-code">echo "Engine no. : " . $object-&gt;getEngineNumber() . PHP_EOL;</p></li>
				<li>Run the <strong class="source-inline">Vehicle.php</strong> file using the <strong class="source-inline">Vehicle.php</strong> PHP command. The preceding code should output the following:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer101">
					<img alt="Figure 5.4: Vehicle object's setter and getter methods&#13;&#10;" src="image/C14196_05_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4: Vehicle object's setter and getter methods</p>
			<p>So, we have a <strong class="source-inline">Vehicle</strong> class that describes a particular type of vehicle with different attributes associated to vehicle, and the getter and setter methods to work on the attributes. From now on, we will be working with this <strong class="source-inline">Vehicle</strong> class to exercise our OOP understanding. </p>
			<p>Just to summarize, the exercise we walked through is all about defining a class, so the key learning here is that we have to add class attributes that sufficiently describe the particular type of object and write methods to set and fetch data from those attributes.</p>
			<p>In the next section, we will discuss how constructor and destructor methods fit a role in a class structure and walk through an exercise on how to instantiate the <strong class="source-inline">Vehicle</strong> class. </p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor183"/>Constructor</h2>
			<p>A constructor, such as <strong class="source-inline">__construct()</strong>, is a special kind of method that is invoked automatically when instantiating a class. </p>
			<p>The syntax of a class constructor is as follows:</p>
			<p class="source-code">class ClassName</p>
			<p class="source-code">{</p>
			<p class="source-code">    function __construct() </p>
			<p class="source-code">    {</p>
			<p class="source-code">        //function body</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Let's add a <strong class="source-inline">__construct()</strong> method in our previously discussed <strong class="source-inline">Person</strong> class as follows:</p>
			<p class="source-code">class MySimpleClass </p>
			<p class="source-code">{</p>
			<p class="source-code">    public $name;</p>
			<p class="source-code">    function __construct($username)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        $this-&gt;name = $username;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The key idea behind using a <strong class="source-inline">__construct()</strong> method is to perform the initial set of executions that need to be done immediately upon object creation. In the preceding simple approach, a <strong class="source-inline">__construct()</strong> method performs attribute assignment(s). </p>
			<p>Hence, we can create instances of the <strong class="source-inline">Person</strong> class like the following:</p>
			<p class="source-code">$person1 = new Person('John Doe');</p>
			<p class="source-code">$person2 = new Person('Jane Doe');</p>
			<p class="source-code">echo $person1-&gt;name; //prints John Doe</p>
			<p class="source-code">echo $person2-&gt;name; //prints Jane Doe</p>
			<p>Here, the <strong class="source-inline">MySimpleClass</strong> constructor, <strong class="source-inline">__construct()</strong>, takes an argument, <strong class="source-inline">$username</strong>, and assigns it to the <strong class="source-inline">$name</strong> attribute by accessing it with <strong class="source-inline">$this-&gt;name</strong>. </p>
			<p>Apart from the initial value assignment, a constructor method might hold a database connection, set cookies, hold an HTTP client, accept dependencies as arguments, and much more.</p>
			<p>A constructor method must not have a return statement, it can accept arguments, and the name should always be <strong class="source-inline">__construct()</strong>.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor184"/>Destructor</h2>
			<p>The destructor method, <strong class="source-inline">__destruct()</strong>, is invoked automatically when an object is destroyed. When we remove an object or perhaps a PHP script ends its execution and releases the memory utilized by the variables, then <strong class="source-inline">__destruct()</strong> gets called. </p>
			<p>The syntax of a class destructor is as follows:</p>
			<p class="source-code">class ClassName</p>
			<p class="source-code">{</p>
			<p class="source-code">     function __destruct() </p>
			<p class="source-code">    {</p>
			<p class="source-code">        //function body</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Let's add a <strong class="source-inline">__destruct()</strong> method to our previously discussed <strong class="source-inline">Person</strong> class, as follows:</p>
			<p class="source-code">class Person </p>
			<p class="source-code">{</p>
			<p class="source-code">    //attributes and methods</p>
			<p class="source-code">    function __destruct()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        echo 'The object has been removed.';</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, as an example, the <strong class="source-inline">__destruct()</strong> method can be added for log-keeping purposes.</p>
			<p>If we <strong class="source-inline">unset()</strong> the object handler variable to destroy the object instance, as follows, the destructor should be called automatically:</p>
			<p class="source-code">$person = new Person();</p>
			<p class="source-code">unset($person); //output: The object has been removed.</p>
			<p>Also, the destructor method is invoked automatically if no object is found in the memory, as follows:</p>
			<p class="source-code">$object = new Person();</p>
			<p class="source-code">$object = NULL; //output: The object has been removed. </p>
			<p>Apart from the preceding manual object destruction, when the script execution ends, all the <strong class="source-inline">__destruct()</strong> methods within different objects are invoked automatically and PHP will start to release the memory.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A destructor method does not take arguments.</p>
			<p>Just to summarize, so far, we have learned about class declaration with attributes and methods, the instantiation of a class, and constructor and destructor methods. Hence, we should walk through the next exercise to apply these concepts.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor185"/>Exercise 5.2: Instantiating the Class and Printing the Details</h2>
			<p>In the following exercise, you will learn how to instantiate the <strong class="source-inline">Vehicle</strong> class that we created in the previous exercise. We will introduce a constructor to it so that we can assign attributes via the constructor's parameters instead of assigning the values during the class declaration. We should be able to print that information using the corresponding getters:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">Vehicle</strong> class file, <strong class="source-inline">Vehicle.php</strong>, and you should see the attributes as follows:<p class="source-code-heading">Vehicle.php</p><p class="source-code">1  &lt;?php</p><p class="source-code">2  class Vehicle </p><p class="source-code">3  {</p><p class="source-code">4      public $make = 'DefaultMake';</p><p class="source-code">5      public $model = 'DefaultModel';</p><p class="source-code">6      public $color = 'DefaultColor';</p><p class="source-code">7      public $noOfWheels = 0; </p><p class="source-code">8      public $engineNumber = 'XXXXXXXX';</p><p class="source-code">9      function getMake()</p><p class="source-code">10     {</p><p class="source-code">11         return $this-&gt;make;</p><p class="source-code">12     }</p><p class="source-code-link"><a href="https://packt.live/2IFUlfA">https://packt.live/2IFUlfA</a></p><p>We have a better way of assigning the values of these attributes using a constructor method.</p></li>
				<li>Modify the attributes as follows:<p class="source-code">    public $make;</p><p class="source-code">    public $model;</p><p class="source-code">    public $color;</p><p class="source-code">    public $noOfWheels; </p><p class="source-code">    public $engineNumber;</p><p>Here, we have taken out the default values assigned to the attributes.</p></li>
				<li>Add the <strong class="source-inline">__construct</strong> method after the attributes section as follows:<p class="source-code">    function __construct($make = 'DefaultMake', $model = 'DefaultModel',       $color = 'DefaultColor', $wheels = 4, $engineNo = 'XXXXXXXX')</p><p class="source-code">    {</p><p class="source-code">        //function body</p><p class="source-code">    }</p><p>Here, we have added the default values of the constructor's parameters as the default values for the attributes if no values were passed.</p><p>The constructor method will be invoked automatically with the instantiation of the <strong class="source-inline">Vehicle</strong> class. If we can pass parameters with the new object creation, they are received inside the constructor.</p></li>
				<li>Within the <strong class="source-inline">__construct()</strong> method, assign the parameters to the corresponding attributes, as follows:<p class="source-code">    function __construct($make = 'DefaultMake', $model = 'DefaultModel',       $color = 'DefaultColor', $wheels = 4, $engineNo = 'XXXXXXXX')</p><p class="source-code">    {</p><p class="source-code">        $this-&gt;make = $make;</p><p class="source-code">        $this-&gt;model = $model;</p><p class="source-code">        $this-&gt;color = $color;</p><p class="source-code">        $this-&gt;noOfWheels = $wheels;</p><p class="source-code">        $this-&gt;engineNumber = $engineNo;</p><p class="source-code">    }</p><p>Here, we have assigned the attributes obtained from the constructor arguments. </p></li>
				<li>Erase or comment out the following lines for the <strong class="source-inline">Vehicle</strong> class initialization and the use of setters and getters from <strong class="source-inline">Vehicle.php</strong>:<p class="source-code">$object = new Vehicle();</p><p class="source-code">$object-&gt;setMake('Honda');</p><p class="source-code">$object-&gt;setModel('Civic');</p><p class="source-code">$object-&gt;setColor('Red');</p><p class="source-code">$object-&gt;setNoOfWheels(4);</p><p class="source-code">$object-&gt;setEngineNumber('ABC123456');</p><p class="source-code">echo "Make : " . $object-&gt;getMake() . PHP_EOL;</p><p class="source-code">echo "Model : " . $object-&gt;getModel() . PHP_EOL;</p><p class="source-code">echo "Color : " . $object-&gt;getColor() . PHP_EOL;</p><p class="source-code">echo "No. of wheels : " . $object-&gt;getNoOfWheels() . PHP_EOL;</p><p class="source-code">echo "Engine no. : " . $object-&gt;getEngineNumber() . PHP_EOL;</p><p>We have erased these lines as we are going to include the <strong class="source-inline">Vehicle.php</strong> file in another file that will take care of the <strong class="source-inline">Vehicle</strong> initialization. So far, we have the <strong class="source-inline">Vehicle</strong> class ready to use in the next steps.</p></li>
				<li>Create a new PHP file called <strong class="source-inline">vehicle-objects.php</strong> in the same directory and add the following lines to require the <strong class="source-inline">Vehicle</strong> class:<p class="source-code">&lt;?php</p><p class="source-code">require_once 'Vehicle.php';</p><p>In the <strong class="source-inline">vehicle-objects.php</strong> script, we have added the <strong class="source-inline">Vehicle</strong> class using the <strong class="source-inline">require_once</strong> command, which will add the file if it's not already added or produce a fatal error in the event that the file is not found. For the next steps, we will be working on this file.</p></li>
				<li>Now, it's time to instantiate the class. Create an object without passing any arguments to the constructor as follows, after requiring the <strong class="source-inline">Vehicle</strong> class:<p class="source-code">$vehicle = new Vehicle();</p><p>Here, we have created an object of the <strong class="source-inline">Vehicle</strong> type with the <strong class="source-inline">new</strong> keyword and the constructor should be called after the memory allocation for the copy of the object's own attributes. </p><p>As we have getter methods written already to access the preceding attributes, we should try to print the attribute information.</p></li>
				<li>Print the attribute information with the following:<p class="source-code">$vehicle = new Vehicle();</p><p class="source-code">echo "Make: " . $vehicle-&gt;getMake() . PHP_EOL;</p><p class="source-code">echo "Model: " . $vehicle-&gt;getModel() . PHP_EOL;</p><p class="source-code">echo "Color: " . $vehicle-&gt;getColor() . PHP_EOL;</p><p class="source-code">echo "No of wheels: " . $vehicle-&gt;getNoOfWheels() . PHP_EOL;</p><p class="source-code">echo "Engine No: " . $vehicle-&gt;getEngineNumber() . PHP_EOL;</p><p>As all of the <strong class="source-inline">Vehicle</strong> member methods are public, we can access the vehicle data via the interface of the instantiated <strong class="source-inline">$vehicle</strong> object. </p><p>Also, all of the <strong class="source-inline">Vehicle</strong> attributes are public, so we can access the attributes using the <strong class="source-inline">$vehicle</strong> object handler outside of the class. So, the following code should output the same as the preceding:</p><p class="source-code">$vehicle = new Vehicle();</p><p class="source-code">echo "Make: " . $vehicle-&gt;make . PHP_EOL;</p><p class="source-code">echo "Model: " . $vehicle-&gt;model . PHP_EOL;</p><p class="source-code">echo "Color: " . $vehicle-&gt;color . PHP_EOL;</p><p class="source-code">echo "No of wheels: " . $vehicle-&gt;noOfWheels . PHP_EOL;</p><p class="source-code">echo "Engine No: " . $vehicle-&gt;getEngineNumber() . PHP_EOL;</p><p class="callout-heading">Note</p><p class="callout">The standard way to access object attributes is via the object's member methods. When we apply restrictions on object attributes, accessing them should be performed via object interfaces or methods only.</p></li>
				<li>From the terminal or console, run <strong class="source-inline">vehicle-objects.php</strong> using the <strong class="source-inline">php vehicle-objects.php</strong> command. The preceding code outputs the following:<div class="IMG---Figure" id="_idContainer102"><img alt="Figure 5.5: Vehicle object's default attributes &#13;&#10;" src="image/C14196_05_05.jpg"/></div><p class="figure-caption">Figure 5.5: Vehicle object's default attributes </p><p>Here, we haven't passed arguments to the class constructor, so the default parameter values have been assigned to the attributes.</p></li>
				<li>Now, we will create another object with parameters passed to the constructor after the lines in <em class="italic">step 7</em>, like the following:<p class="source-code">$vehicle1 = new Vehicle('Honda', 'Civic', 'Red', 4, '23CJ4567');</p><p class="source-code">echo "Make: " . $vehicle1-&gt;getMake() . PHP_EOL;</p><p class="source-code">echo "Model: " . $vehicle1-&gt;getModel() . PHP_EOL;</p><p class="source-code">echo "Color: " . $vehicle1-&gt;getColor() . PHP_EOL;</p><p class="source-code">echo "No of wheels: " . $vehicle1-&gt;getNoOfWheels() . PHP_EOL;</p><p class="source-code">echo "Engine No: " . $vehicle1-&gt;getEngineNumber() . PHP_EOL;</p></li>
				<li>Rerun <strong class="source-inline">Vehicle.php</strong> using the <strong class="source-inline">php vehicle-objects.php</strong> command. The portion of code in <em class="italic">step 9</em> outputs the following:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer103">
					<img alt="Figure 5.6: Printing the details on the terminal&#13;&#10;" src="image/C14196_05_06.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6: Printing the details on the terminal</p>
			<p>So, the attributes' initial values can be settled via the constructor parameters. Regardless of the constructor parameters, attributes can be assigned using setter methods when you want to prevent direct access to your attributes.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor186"/>Inheritance</h2>
			<p>To implement the idea of reusability, we need to learn the process of acquiring the properties of objects of one class (the parent class) using the objects of another class (the child class). Hence, inheritance is the process of deriving one class from a base class (the parent class) and the derived class (a child class or subclass).</p>
			<p>Inheritance supports the flow of information in a hierarchical way to the derived objects so that, along with the inherited properties, the derived class can add its own properties. Again, such a derived class can be inherited by another and so on. Bundled data and actions can be reused in an organized manner to add additional features to derived classes.</p>
			<p>Inheritance allows us to implement the idea of hierarchical classification as follows:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer104">
					<img alt="Figure 5.7: Inheritance diagram&#13;&#10;" src="image/C14196_05_07.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7: Inheritance diagram</p>
			<p>As the preceding diagram shows, the <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong> classes can be derived from the base <strong class="source-inline">Vehicle</strong> class to reuse the attributes, constructors, and methods. Hence, the derived classes inherit the members from the base class and are allowed to add their own members for example, <strong class="source-inline">Car</strong> adds four doors — or modify inherited members — motorcycle modifies the number of wheels to two, and so on.</p>
			<p>With the derived classes, you can keep and reuse the members of the parent class. Also, you can override the parent's properties and methods to tailor your demands in the derived classes. Modifying inherited members in derived classes is called overriding, which is another OOP paradigm. We will look at a detailed example of method overriding in later sections. </p>
			<p>In short, inheritance allows us to share common characteristics and behaviors through generations of classes. </p>
			<p>PHP uses the <strong class="source-inline">extends</strong> keyword to inherit from a parent class. The syntax of PHP class inheritance is as follows:</p>
			<p class="source-code">class MyNewClass extends MySimpleClass </p>
			<p class="source-code">{</p>
			<p class="source-code">    //class body</p>
			<p class="source-code">}</p>
			<p>PHP supports single inheritance, meaning a class can inherit from a single class; not like Java, where you can inherit from multiple classes at a time.</p>
			<p>In order to access a parent class' member attributes and methods, write the following:</p>
			<p class="source-code">class MySimpleClass </p>
			<p class="source-code">{</p>
			<p class="source-code">    public $propertyName = 'base property';</p>
			<p class="source-code">    function methodName()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        echo 'I am a base method. ';</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">class MyNewClass extends MySimpleClass </p>
			<p class="source-code">{</p>
			<p class="source-code">    //class body</p>
			<p class="source-code">}</p>
			<p class="source-code">$object = new MyNewClass();</p>
			<p class="source-code">$object-&gt;propertyName; //holds, 'base property'</p>
			<p class="source-code">$object-&gt;methodName(); //prints, 'I am a base method. ' </p>
			<p>So, the properties from the parent class can be reused in the derived object. Normally, in order to share common properties and behaviors, we establish a base class so that the subclasses don't need to add the same properties and behaviors repetitively. Thus, the data and the code operating on that data can be reused and the size of the code base remains minimal.</p>
			<p>Again, while deriving, you can add your additional members and use the parent members as follows:</p>
			<p class="source-code">class MyNewClass extends MySimpleClass </p>
			<p class="source-code">{</p>
			<p class="source-code">    public $addedProperty = 'added property';</p>
			<p class="source-code">    function addedMethodName()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        parent::methodName();</p>
			<p class="source-code">        echo 'I am an added method. ';</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">$object = new MyNewClass();</p>
			<p class="source-code">$object-&gt;propertyName; //holds 'base property'</p>
			<p class="source-code">$object-&gt;addedProperty; //holds 'added property'</p>
			<p class="source-code">$object-&gt;addedMethodName(); //prints 'I am a base method. I am an added method.'</p>
			<p>Here, <strong class="source-inline">MyNewClass</strong> adds its own <strong class="source-inline">$addedProperty</strong> attribute and the <strong class="source-inline">addedMethodName()</strong> method.</p>
			<p>You can access and work with the parent's members using the <strong class="source-inline">parent</strong> keyword followed by the scope operator, <strong class="source-inline">::</strong>; for example, <strong class="source-inline">parent::</strong>. In the preceding example, the <strong class="source-inline">MyNewClass</strong> child class adds its own <strong class="source-inline">addedMethodName()</strong> member method, which accesses the parent's <strong class="source-inline">methodName()</strong> method in it by using <strong class="source-inline">parent::methodName()</strong> and prints the '<strong class="source-inline">I am an added method</strong>' string. Hence, <strong class="source-inline">$object-&gt;addedMethodName()</strong> prints '<strong class="source-inline">I am a base method. I am an added method.</strong>'.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A child class can't access or inherit the private properties or members of a parent class since something that's private is meant to remain private.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor187"/>Exercise 5.3: Implementing Inheritance</h2>
			<p>Now is the time to classify different vehicle types and leverage the <strong class="source-inline">Vehicle</strong> class to derive new types of vehicles, such as car, bus, truck, motorcycle, and so on. In order to produce new types of vehicle objects, we will extend the <strong class="source-inline">Vehicle</strong> class to derive newer classes such as <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong>.</p>
			<p>In this exercise, you will learn how to derive classes from the <strong class="source-inline">Vehicle</strong> class. We will create <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong> subclasses and add new attributes in them, and print the <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong> attributes by instantiating corresponding objects:</p>
			<ol>
				<li value="1">Create a new <strong class="source-inline">Car</strong> class file, <strong class="source-inline">Car.php</strong>, in the same directory and add the following lines to include the <strong class="source-inline">Vehicle</strong> class:<p class="source-code">&lt;?php</p><p class="source-code">require_once 'Vehicle.php';</p></li>
				<li>The <strong class="source-inline">Car</strong> class extends the <strong class="source-inline">Vehicle</strong> class. Add the following content after the <strong class="source-inline">require</strong> command:<p class="source-code">class Car extends Vehicle </p><p class="source-code">{</p><p class="source-code">    //class body</p><p class="source-code">}</p><p>The <strong class="source-inline">Car</strong> class inherits all the attributes and methods from the parent class. Now it's time to add new attributes or properties into the <strong class="source-inline">Car</strong> class so that a car object can be distinguished among other types of vehicles.</p></li>
				<li>A car should have doors, passenger capacity, a steering wheel, transmission, and so on and inherit the default four wheels along with other properties. Add the following attributes into the <strong class="source-inline">Car</strong> class:<p class="source-code">class Car extends Vehicle </p><p class="source-code">{</p><p class="source-code">    public $doors = 4; </p><p class="source-code">    public $passengerCapacity = 5;</p><p class="source-code">    public $steeringWheel = true;</p><p class="source-code">    public $transmission = 'Manual';</p><p class="source-code">    //class body</p><p class="source-code">}</p><p>Hence, the <strong class="source-inline">Car</strong> class itself is a vehicle so it possesses all the given characteristics of a vehicle and adds its own set of characteristics. </p></li>
				<li>Now, it's time to leverage the beauty of inheritance. We will be using the inherited constructor from the <strong class="source-inline">Vehicle</strong> class. We can set the car's attributes by passing them as constructor parameters. We can instantiate the <strong class="source-inline">Car</strong> class and access the <strong class="source-inline">Vehicle</strong> class' members using the object of the <strong class="source-inline">Car</strong> class, as follows:<p class="source-code">$car = new Car('Honda', 'Civic', 'Red', 4, '23CJ4567');</p><p class="source-code">echo "Vehicle Type: " . get_class($car) . PHP_EOL;</p><p class="source-code">echo " Make: " . $car-&gt;getMake() . PHP_EOL;</p><p class="source-code">echo " Model: " . $car-&gt;getModel() . PHP_EOL;</p><p class="source-code">echo " Color: " . $car-&gt;getColor() . PHP_EOL;</p><p class="source-code">echo " No of wheels: " . $car-&gt;getNoOfWheels() . PHP_EOL;</p><p class="source-code">echo " No of Doors: " . $car-&gt;doors . PHP_EOL;</p><p class="source-code">echo " Transmission: " . $car-&gt;transmission . PHP_EOL;</p><p class="source-code">echo " Passenger capacity: " . $car-&gt;passengerCapacity . PHP_EOL;</p><p>Here, alongside additional car properties, we can access the inherited features of the base class. The <strong class="source-inline">get_class()</strong> returns the class name that we have used to obtain the <strong class="source-inline">Vehicle</strong> type as a class name. Note that we are accessing the inherited methods using the child object's handler. </p></li>
				<li>Run <strong class="source-inline">Car.php</strong> from the terminal with the <strong class="source-inline">php Car.php</strong> command. The preceding code outputs the following:<div class="IMG---Figure" id="_idContainer105"><img alt="Figure 5.8: Printing the details of the car&#13;&#10;" src="image/C14196_05_08.jpg"/></div><p class="figure-caption">Figure 5.8: Printing the details of the car</p></li>
				<li>Similarly, let's create another type of vehicle type here. Create a <strong class="source-inline">Motorcycle</strong> class by extending the <strong class="source-inline">Vehicle</strong> class. Create a <strong class="source-inline">Motorcycle.php</strong> file in the same directory with the following content:<p class="source-code">&lt;?php</p><p class="source-code">require_once 'Vehicle.php';</p><p class="source-code">class Motorcycle extends Vehicle </p><p class="source-code">{</p><p class="source-code">    public $noOfWheels = 2;</p><p class="source-code">    public $stroke = 4;</p><p class="source-code">    //class body</p><p class="source-code">}</p><p>Again, this specific type of vehicle adds its new attributes. This is how inheritance enables your object to move forward with the newer characteristics while reusing the existing features. Note that <strong class="source-inline">$noOfWheels</strong> and <strong class="source-inline">$stroke</strong> can also be set in the constructor, but we also override these values here, in case the <strong class="source-inline">Motorcycle</strong> class is instantiated with the default empty constructor.</p></li>
				<li>Now, let's instantiate the derived <strong class="source-inline">Motorcycle</strong> class, and access the inherited and added properties as follows:<p class="source-code">&lt;?php</p><p class="source-code">require_once 'Vehicle.php';</p><p class="source-code">class Motorcycle extends Vehicle </p><p class="source-code">{</p><p class="source-code">    public $noOfWheels = 2;</p><p class="source-code">    public $stroke = 4;</p><p class="source-code">}</p><p class="source-code">$motorcycle = new Motorcycle('Kawasaki', 'Ninja', 'Orange', 2,   '53WVC14598');</p><p class="source-code">echo "Vehicle Type: " . get_class($motorcycle) . PHP_EOL;</p><p class="source-code">echo " Make: " . $motorcycle-&gt;make . PHP_EOL;</p><p class="source-code">echo " Model: " . $motorcycle-&gt;model . PHP_EOL;</p><p class="source-code">echo " Color: " . $motorcycle-&gt;color . PHP_EOL;</p><p class="source-code">echo " No of wheels: " . $motorcycle-&gt;noOfWheels . PHP_EOL;</p><p class="source-code">echo " No of strokes: " . $motorcycle-&gt;stroke . PHP_EOL;</p><p>So, a two-wheeler type of vehicle should have the <strong class="source-inline">$noOfWheels</strong> attribute as a value of <strong class="source-inline">2</strong>. Note that <strong class="source-inline">$noOfWheels</strong> has been overridden here with <strong class="source-inline">2</strong> and an additional <strong class="source-inline">$stroke</strong> attribute, which is the stroke type of <strong class="source-inline">Motorcyle</strong>. The default is <strong class="source-inline">4</strong>. </p></li>
				<li>Run the <strong class="source-inline">Motorcycle.php</strong> file from the terminal with the <strong class="source-inline">php Motorcycle.php</strong> command. The preceding code outputs the following:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer106">
					<img alt="" src="image/C14196_05_09.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9: Inherited and added attributes of the motorcycle object</p>
			<p>So far, we have derived <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong> by extending the <strong class="source-inline">Vehicle</strong> class, added new properties into derived classes, and accessed parent attributes and methods in a straightforward manner since all of them are publicly accessible. Inheritance lets you implement your objects in a hierarchical way. You might be adding new features or reusing existing ones throughout the system to keep your code modular. In the exercise, we noticed that accessing parent members is easy and there are no restrictions to prevent you from accessing their data.</p>
			<p>In order to enforce a specific data access policy on the class attributes, we will need the Access Modifiers before the class attributes and method declaration.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor188"/>Access Modifiers </h2>
			<p>Two core concepts sitting at the heart of OOP are modularity (which allows for reusability) and encapsulation (which bundles data and methods, in order to hide information). It is important to establish access guidelines for data and interfacing among objects so that who can access what and to what extent is defined. Access modifiers provide access protection for object constants, attributes, and methods. The concept is to secure the object's members so that we can declare public, protected, and private member constants, attributes, and methods for the object. The <strong class="source-inline">public</strong>, <strong class="source-inline">protected</strong>, and <strong class="source-inline">private</strong> keywords are also known as visibility keywords in PHP. The <strong class="source-inline">public</strong> keyword can be used before a member to access the member from outside via the object. The <strong class="source-inline">protected</strong> keyword can be used to access a member from the derived class but not from outside. The <strong class="source-inline">private</strong> keyword can be used to restrict the access of a member to its own class only and for it to not be accessible via derivation or from outside.</p>
			<p>Let's look at an example of the <strong class="source-inline">public</strong>, <strong class="source-inline">protected</strong>, and <strong class="source-inline">private</strong> keywords applied to class members:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">class MySimpleClass</p>
			<p class="source-code">{</p>
			<p class="source-code">    public PUBLIC_CONSTANT = 'Public';</p>
			<p class="source-code">    protected PROTECTED_CONSTANT = 'Protected';</p>
			<p class="source-code">    private PRIVATE_CONSTANT = 'Private';</p>
			<p class="source-code">    public $publicAttribute = 'Public Member';</p>
			<p class="source-code">    protected $protectedAttribute = 'Protected Member';</p>
			<p class="source-code">    private $privateAttribute = 'Private Member';</p>
			<p class="source-code">    public function publicMethod()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        //function body</p>
			<p class="source-code">    }</p>
			<p class="source-code">    protected function protectedMethod()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        //function body</p>
			<p class="source-code">    }</p>
			<p class="source-code">    private function privateMethod()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        //function body</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">$object = new MySimpleClass();</p>
			<p class="source-code">$object-&gt;publicAttribute;//ok</p>
			<p class="source-code">$object-&gt;protectedMember;//fatal error</p>
			<p class="source-code">$object-&gt;privateAttribute;//fatal error</p>
			<p>To elaborate on the class members with the new access modifiers prefixed, check out the following table for the <strong class="source-inline">public</strong>, <strong class="source-inline">protected</strong>, and <strong class="source-inline">private</strong> access modifiers:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer107">
					<img alt="Figure 5.10: Scope of the access modifiers&#13;&#10;" src="image/C14196_05_10.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10: Scope of the access modifiers</p>
			<p>All public members can be accessed from outside of their own object or derived object using an object handler such as <strong class="source-inline">$object-&gt;publicAttribute</strong> or <strong class="source-inline">$object-&gt;publicMethod()</strong>, and to access them from inside their own object or derived object we need to use the special <strong class="source-inline">$this</strong> variable.</p>
			<p>All protected members can be accessed only from inside their own object or derived object using <strong class="source-inline">$this-&gt; protectedAttribute</strong> or <strong class="source-inline">$this-&gt;protectedMethod()</strong>. Accessing them using the <strong class="source-inline">$object-&gt;protectedAttribute</strong> object handler will produce a <strong class="source-inline">FATAL</strong> error. Hence, an access modifier can be used when we allow data and behaviors to be reused via derivation only. </p>
			<p>Private members are exclusively private to their own objects and are non-accessible via inheritance. The whole idea with this access modifier is that class-specific data and behaviors cannot be reused:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer108">
					<img alt="Figure 5.11: Access modifiers diagra&#13;&#10;" src="image/C14196_05_11.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11: Access modifiers diagram</p>
			<p>The diagram shows who can access what data and which methods. Outsiders can access an object's public data and methods only via the object's handler. An outsider's access is restricted to protected and private areas. Access is allowed to protected areas only by means of derivation and private areas are meant to be private for the class. Therefore, the restricted areas of a class can be accessed by its own methods and the world is set to access those restricted areas indirectly if and only if the class declares those methods that access their own restricted areas as public.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If no access modifiers are mentioned before a method, then it will be considered public by default.</p>
			<p>It's now time to apply access modifiers to the <strong class="source-inline">Vehicle</strong> class. Let's walk through an exercise. In the <strong class="source-inline">Vehicle</strong> class, the number of wheels should be available for the different types of vehicles to be implemented, the engine number should be confidential, and the other information should not be confidential.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor189"/>Exercise 5.4: Applying Access Modifiers</h2>
			<p>In this exercise, we need to apply access modifiers before the <strong class="source-inline">Vehicle</strong> class attributes so that we can ensure the hiding of the data for the engine number variable, <strong class="source-inline">$engineNumber</strong>. The engine number can be obtained only via the getter <strong class="source-inline">getEngineNumber()</strong> member method. Also, the number of wheels should not be available outside the class; rather, it should be available to derived classes to implement their own number of wheels and the rest of the attributes can be accessed outside the class:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">Vehicle.php</strong> file and update the access modifiers of the <strong class="source-inline">$noOfWheels</strong> attribute as follows:<p class="source-code">&lt;?php</p><p class="source-code">class Vehicle </p><p class="source-code">{</p><p class="source-code">    public $make;</p><p class="source-code">    public $model;</p><p class="source-code">    public $color;</p><p class="source-code">    protected $noOfWheels; </p><p class="source-code">    public $engineNumber;</p><p class="source-code">    //methods</p><p>Here, we have protected the <strong class="source-inline">$noOfWheels</strong> data as this needs to be available to the child classes to implement their own number of wheels and should not be available outside of the class. We have modified the <strong class="source-inline">$noOfWheels</strong> attribute from <strong class="source-inline">public</strong> to <strong class="source-inline">protected</strong>.</p></li>
				<li>Also, the engine number should be private to different vehicle types. Update the <strong class="source-inline">$engineNumber</strong> visibility from <strong class="source-inline">public</strong> to <strong class="source-inline">private</strong> as follows:<p class="source-code">class Vehicle </p><p class="source-code">{</p><p class="source-code">    public $make;</p><p class="source-code">    public $model;</p><p class="source-code">    public $color;</p><p class="source-code">    protected $noOfWheels; </p><p class="source-code">    private $engineNumber;</p><p class="source-code">    //methods</p><p>Here, due to a visibility change for the <strong class="source-inline">$engineNumber</strong> attribute, the attribute should remain private to its own class and should not be available to the derived classes or outside of the class. One way to access such private attributes is to write a public getter method for outsiders or a protected getter method for derived classes only.</p><p>Some vehicle types might need to modify the number of wheels and we won't be allowing outsiders to make that modification; hence, we declare the <strong class="source-inline">$noOfWheels</strong> attribute as <strong class="source-inline">protected</strong>. What if the number of wheels is set as <strong class="source-inline">public</strong>? It might get modified directly (read: bizarrely): a car might have two wheels, or a motorcycle might be modified to have 100 wheels. That's why we wanted the attribute to be modified only in subclasses and not by outsiders.</p><p>Here, the first three attributes are publicly visible, meaning these are the common attributes of any vehicle types and such information can be accessed directly via the object if anyone wants to do that.</p><p>So, we are able to deliver restrictions on class attributes using the <strong class="source-inline">visibility</strong> keyword. Let's try accessing the attributes with updated visibility by instantiating the class.</p></li>
				<li>Create a new <strong class="source-inline">vehicle-visibility.php</strong> file and instantiate the <strong class="source-inline">Vehicle</strong> class as follows:<p class="source-code">&lt;?php</p><p class="source-code">require_once 'Vehicle.php';</p><p class="source-code">$vehicle = new Vehicle();</p></li>
				<li>Try to access the member attributes outside of the class using the object handler, just the same as earlier:<p class="source-code">$vehicle = new Vehicle();</p><p class="source-code">echo "Make: " . $vehicle-&gt;make . PHP_EOL;</p><p class="source-code">echo "Model: " . $vehicle-&gt;model . PHP_EOL;</p><p class="source-code">echo "Color: " . $vehicle-&gt;color . PHP_EOL;</p><p class="source-code">echo "No of wheels: " . $vehicle-&gt;noOfWheels . PHP_EOL;</p><p class="source-code">echo "Engine No: " . $vehicle-&gt;engineNumber . PHP_EOL;</p><p>Note that we are trying to access <strong class="source-inline">$noOfWheels</strong> and <strong class="source-inline">$engineNumber</strong> outside the class using the <strong class="source-inline">$vehicle</strong> object handler with an object operator. Both should produce a <strong class="source-inline">FATAL</strong> error.</p></li>
				<li>From the terminal or console, run <strong class="source-inline">vehicle-visibility.php</strong> using the <strong class="source-inline">php -d display_errors=on vehicle-visibility.php</strong> command. Using the <strong class="source-inline">–d</strong> flag with <strong class="source-inline">display_errors=on</strong> should override the default <strong class="source-inline">display_erros=off</strong> from <strong class="source-inline">php-cli</strong>: <p>The preceding command outputs the following:</p><div class="IMG---Figure" id="_idContainer109"><img alt="Figure 5.12: Accessing a protected property of the vehicle object&#13;&#10;" src="image/C14196_05_12.jpg"/></div><p class="figure-caption">Figure 5.12: Accessing a protected property of the vehicle object</p></li>
				<li>Let's take out the line with <strong class="source-inline">$vehicle-&gt;noOfWheels</strong> and try to rerun the previous command:<p class="source-code">Make: DefaultMake</p><p class="source-code">Model: DefaultModel</p><p class="source-code">Color: DefaultColor</p><p class="source-code">Fatal error: Cannot access private property Vehicle::$engineNumber ...</p></li>
				<li>We need to alter our approach for accessing such restricted attributes. We need to use the <strong class="source-inline">getNoOfWheels()</strong> and <strong class="source-inline">getEngineNumber()</strong> object interface, as follows:<p class="source-code">$vehicle = new Vehicle();</p><p class="source-code">echo "Make: " . $vehicle-&gt;make . PHP_EOL;</p><p class="source-code">echo "Model: " . $vehicle-&gt;model . PHP_EOL;</p><p class="source-code">echo "Color: " . $vehicle-&gt;color . PHP_EOL;</p><p class="source-code">echo "No of wheels: " . $vehicle-&gt;getNoOfWheels() . PHP_EOL;</p><p class="source-code">echo "Engine No: " . $vehicle-&gt;getEngineNumber() . PHP_EOL;</p></li>
				<li>So, if we rerun the script, we should see that all the expected values have been printed as follows:<div class="IMG---Figure" id="_idContainer110"><img alt="Figure 5.13: Accessing private and protected properties via methods of the vehicle object&#13;&#10;" src="image/C14196_05_13.jpg"/></div><p class="figure-caption">Figure 5.13: Accessing private and protected properties via methods of the vehicle object</p><p>Now, we should try accessing the modified visibility attributes from the child class to see the differences.</p></li>
				<li>Let's try accessing the modified visibility attributes from the child class. Open <strong class="source-inline">Car.php</strong> and locate the line with <strong class="source-inline">$car-&gt;getNoOfWheels()</strong>. The protected <strong class="source-inline">$noOfWheels</strong> attribute is inherited by the <strong class="source-inline">$car</strong> object and is available only via the <strong class="source-inline">getNoOfWheels()</strong> standard interface. <p>Try to run <strong class="source-inline">Car.php</strong> using the <strong class="source-inline">php -d display_errors=on Car.php</strong> command. The command prints the following:</p><div class="IMG---Figure" id="_idContainer111"><img alt="Figure 5.14: Accessing the parent's attributes via inheritance&#13;&#10;" src="image/C14196_05_14.jpg"/></div><p class="figure-caption">Figure 5.14: Accessing the parent's attributes via inheritance</p><p>This is how access modifiers ensure data protection throughout child classes. If we try accessing the protected attribute using <strong class="source-inline">$car-&gt;noOfWheels</strong>, it will produce a fatal error.</p></li>
				<li>Now, let's try to access the private property of the parent class of <strong class="source-inline">Car.php</strong> and add the following line:<p class="source-code">echo " Engine number: " . $car-&gt;engineNumber . PHP_EOL;</p><p>Remember, although a car is a vehicle and is inherited from the <strong class="source-inline">Vehicle</strong> class, the attribute should remain private to the <strong class="source-inline">Vehicle</strong> class and is unknown to the <strong class="source-inline">Car</strong> object.</p></li>
				<li>Try to rerun the previous command and it will raise a <strong class="source-inline">Notice</strong> message (a PHP interpreter's message) as the property is unknown to the <strong class="source-inline">$car</strong> object:<p class="source-code">Vehicle Type: Car</p><p class="source-code"> Make: Honda</p><p class="source-code"> Model: Civic</p><p class="source-code"> Color: Red</p><p class="source-code"> No of wheels: 4</p><p class="source-code"> No of Doors: 4</p><p class="source-code"> Transmission: Manual</p><p class="source-code"> Passenger capacity: 5</p><p class="source-code">Notice: Undefined property: Car::$engineNumber ...</p><p class="source-code"> Engine number:</p><p>PHP will raise a <strong class="source-inline">Notice</strong> message only because the property is completely unknown to the object. So, this is how visibility keywords can be applied before class members in order to ensure the hiding of data and protection through inheritance. Note that a <strong class="source-inline">Notice</strong> message is information about wrongdoing by the interpreter and would not halt the program execution, while an error should halt the program execution and must be resolved in order to execute the program.</p></li>
			</ol>
			<p>In summary, access modifiers allow us to establish control over our data and behaviors and provide guidelines for how data should be communicated via standard methods. Hence, we have learned how to protect, privatize, and publicize data when we need to establish secure data communication between objects. </p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor190"/>Static Fields and Methods</h2>
			<p>When class instances or objects want to have the same data among them, the class needs to have such data declared as static. Each instance might have its own copy of data, but we use static members to have a certain portion of data and behavior that should be the same instance-wide. </p>
			<p>Static fields or attributes and methods are just attributes and methods declared with the <strong class="source-inline">static</strong> keyword after the access modifiers and serve the special purpose that you can access static attributes, constants, and methods without instantiating the class. So far, we have accessed members that are declared inside a class from the object context. In the case of accessing class members without an object, we declare them as static members and access them with the <strong class="source-inline">::</strong> scope operator (double colon).</p>
			<p>The syntax looks like the following:</p>
			<p class="source-code">class MySimpleClass</p>
			<p class="source-code">{</p>
			<p class="source-code">    public static $myStaticProperty = 'I am a static property. ';</p>
			<p class="source-code">    public static function myStaticMethod()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return 'I am a static method. ';</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">echo MySimpleClass::$myStaticProperty; //prints 'I am a static property.'</p>
			<p class="source-code">echo MySimpleClass::myStaticMethod(); //prints 'I am a static method.'</p>
			<p>To access static properties or methods from their own class, check out the following example:</p>
			<p class="source-code">class MySimpleClass</p>
			<p class="source-code">{</p>
			<p class="source-code">    public static $myStaticProperty = 'I am a static property. ';</p>
			<p class="source-code">    public static function myStaticMethod()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return self::$myStaticProperty . 'I am a static method. ';</p>
			<p class="source-code">    }    </p>
			<p class="source-code">    public static function myAnotherStaticMethod()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        echo self::myStaticMethod();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">echo MySimpleClass::myAnotherStaticMethod(); </p>
			<p class="source-code">//prints 'I am a static property. I am a static method.'</p>
			<p>So, static members can be accessed outside of the class using the class name and the <strong class="source-inline">::</strong> scope operator. Also, to access the static members inside the class, we can use the <strong class="source-inline">self</strong> keyword followed by the <strong class="source-inline">::</strong> scope operator. </p>
			<p>To access static properties or methods from subclasses, we use the <strong class="source-inline">parent</strong> keyword followed by the <strong class="source-inline">::</strong> scope operator. Check out the following example:</p>
			<p class="source-code">class MySimpleClass{</p>
			<p class="source-code">    public static $myStaticProperty = 'parent static property. ';</p>
			<p class="source-code">    public static function myStaticMethod()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return self::$myStaticProperty . 'parent static method. ';</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">class MySubClass extends MySimpleClass{</p>
			<p class="source-code">    public static function printSomething()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        echo parent::myStaticMethod();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">echo MySubClass::printSomething(); </p>
			<p class="source-code">//prints, parent static property. parent static method.</p>
			<p>Also, static methods are available in the object context:</p>
			<p class="source-code">$object = new MySubClass();</p>
			<p class="source-code">echo $object-&gt;printSomething();</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Static attributes and members are global variables and functions, except they live inside a class that is accessible from anywhere via the class name. Static members should be public; otherwise, accessing them from outside using the class name would produce a fatal error.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor191"/>parent:: and self::</h2>
			<p><strong class="source-inline">self::</strong> refers to the current class and can be used to access static attributes, constants, and methods.</p>
			<p>Similarly, <strong class="source-inline">parent::</strong> refers to the parent class and can be used inside subclasses in order to access parent's member attributes, constants, and methods.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor192"/>Exercise 5.5: Applying a Static Member</h2>
			<p>In this exercise, we will walk through an interesting use case for static members. We will be adding a static attribute to the <strong class="source-inline">Vehicle</strong> class and will increment the attribute inside the constructor so that the static member gets increased with each object creation:</p>
			<ol>
				<li value="1">Open <strong class="source-inline">Vehicle.php</strong> and add a static property in the class, as follows:<p class="source-code">&lt;?php</p><p class="source-code">class Vehicle </p><p class="source-code">{</p><p class="source-code">    public $make;</p><p class="source-code">    public $model;</p><p class="source-code">    public $color;</p><p class="source-code">    protected $noOfWheels; </p><p class="source-code">    private $engineNumber;</p><p class="source-code">    public static $counter = 0;</p><p>Here, we have added a <strong class="source-inline">$counter</strong> static property and initiated the counter with <strong class="source-inline">0</strong>.</p></li>
				<li>Now, just add a line in the constructor to increment <strong class="source-inline">$counter</strong> by using <strong class="source-inline">self::$counter++</strong> as follows:<p class="source-code">    function __construct($make = 'DefaultMake', $model = 'DefaultModel', $color = 'DefaultColor', $wheels = 4, $engineNo = 'XXXXXXXX')</p><p class="source-code">    {</p><p class="source-code">        $this-&gt;make = $make;</p><p class="source-code">        $this-&gt;model = $model;</p><p class="source-code">        $this-&gt;color = $color;</p><p class="source-code">        $this-&gt;noOfWheels = $wheels;</p><p class="source-code">        $this-&gt;engineNumber = $engineNo;</p><p class="source-code">        self::$counter++;</p><p class="source-code">    }</p><p>Here, the counter gets incremented with each object creation as we know the constructor method gets called while instantiating the class. In our case, the <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong> subclasses don't have a <strong class="source-inline">__construct()</strong> method declared in them so they should be using the parent class' constructor via inheritance.</p></li>
				<li>Now, open <strong class="source-inline">Car.php</strong> and create <strong class="source-inline">Car</strong> objects multiple times, as follows. Print the <strong class="source-inline">$counter</strong> static variable using <strong class="source-inline">Car::$counter</strong>:<p class="source-code">$car1 = new Car('Honda', 'Civic', 'Red', 4, '23CJ4567');</p><p class="source-code">$car2 = new Car('Toyota', 'Allion', 'White', 4, '24CJ4568');</p><p class="source-code">$car3 = new Car('Hyundai', 'Elantra', 'Black', 4, '24CJ1234');</p><p class="source-code">$car4 = new Car('Chevrolet', 'Camaro', 'Yellow', 4, '23CJ9397');</p><p class="source-code">echo "Available cars are " . Car::$counter . PHP_EOL;</p><p>Here, the static attribute inherited by the derived <strong class="source-inline">Car</strong> class contains the number of the objects created at any particular point in time. So, we get to know the number of cars available in the application. The preceding should print <strong class="source-inline">Available cars are 4</strong>. Note that we are reusing the static counter in the constructor of the parent <strong class="source-inline">Vehicle</strong> class, meaning the derived <strong class="source-inline">Car</strong> objects share the same counter.</p></li>
				<li>Now, to count <strong class="source-inline">Motorcycle</strong> objects, just create some objects and print the <strong class="source-inline">$counter</strong> static variable using <strong class="source-inline">Motorcycle::$counter</strong>:<p class="source-code">$motorcycle1 = new Motorcycle('Kawasaki', 'Ninja', 'Orange', 2,   '53WVC14598');</p><p class="source-code">$motorcycle2 = new Motorcycle('Suzuki', 'Gixxer SF', 'Blue', 2,   '53WVC14599');</p><p class="source-code">$motorcycle2 = new Motorcycle('Harley Davidson', 'Street 750', 'Black', 2,   '53WVC14234');</p><p class="source-code">echo "Available motorcycles are " . Motorcycle::$counter. PHP_EOL;</p><p>The preceding should print <strong class="source-inline">Available motorcycles are 3</strong>. So, we have declared a static counter in the parent class and created objects and accessed the <strong class="source-inline">static</strong> attribute using child class names to get the number of objects created. This is how we can implement so many interesting features with the <strong class="source-inline">static</strong> property and methods.</p></li>
			</ol>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor193"/>Class Abstraction</h2>
			<p>In OOP, class abstraction is the way to define the common behaviors of objects so that derived classes can implement those behaviors in their own way to achieve different purposes. Just take the vehicle analogy: both cars and motorcycles have engines in common, but you know the engines are completely different for each type of vehicle. So, the class abstraction should provide an abstract engine for both types of vehicles. To match an exact common definition of an engine, the engine should start, the engine should stop, and we might want to know the status of the engine — whether it is running or not. </p>
			<p>Each type of vehicle should implement its way to start the engine. For example, we could start a car engine by using a key in the ignition, whereas a motorcycle might need us to kick-start the engine:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer112">
					<img alt="Figure 5.15: A simple abstract engine diagram&#13;&#10;" src="image/C14196_05_15.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15: A simple abstract engine diagram</p>
			<p>PHP supports abstract classes and methods and they can be written with the <strong class="source-inline">abstract</strong> keyword at the start. An abstract class cannot be instantiated; rather, it can be inherited to achieve common behaviors among objects. A class must contain at least an abstract method to be an abstract class. Using such a class, we deliver common methods to subclasses. In an abstract class, the common methods could be abstract because they only have the signatures and the subclasses implement those methods in their own way. A method declared as an abstract method must not have the implementation written in it.</p>
			<p>Check out the following syntax:</p>
			<p class="source-code">abstract class ClassName{</p>
			<p class="source-code">    abstract function methodName(param1);</p>
			<p class="source-code">    // more abstract method declarations</p>
			<p class="source-code">    function anotherMethod()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        //function body</p>
			<p class="source-code">    }</p>
			<p class="source-code">    //more implemented functions</p>
			<p class="source-code">}</p>
			<p class="source-code">class MyChildClass extends ClassName{</p>
			<p class="source-code">    function methodName(param1, param2)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        //the implementation goes here</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>An abstract class can have some implemented methods in it, along with abstract methods. Generally, we leave those methods as abstract, which should have a different implementation in different child classes.</p>
			<p>As well as the abstract method implementation, the child class must add all the arguments given in the abstract method and optionally can add extra arguments. Say the abstract method comes with two parameters, then the child class must add both of the given parameters and can optionally add its own parameters.</p>
			<p>In the following exercise, we will be adding basic engine functionality to cars and motorcycles so that the engine can be turned on and off.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor194"/>Exercise 5.6: Implementing an Abstract Class</h2>
			<p>In this exercise, we will be converting the <strong class="source-inline">Vehicle</strong> class into an abstract class so that we can deliver the engine-start action in an abstract manner and each subclass can implement its own way of starting the engine. We can add an abstract engine start method so that <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong> can inherit the engine action to implement it and start the vehicle in their own way. The whole idea of this exercise is to practice and understand how abstraction helps us to achieve certain scenarios. In order to provide an abstract engine start to each vehicle type, we will declare the <strong class="source-inline">Vehicle</strong> class as abstract by simply adding the <strong class="source-inline">abstract</strong> keyword in front of it and adding an abstract engine-start method. Since <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong> extended the <strong class="source-inline">Vehicle</strong> class, they will be forced to implement the <strong class="source-inline">abstract</strong> method. </p>
			<p class="callout-heading">PSR Naming Conventions</p>
			<p class="callout">An abstract class name must be prefixed by <strong class="source-inline">abstract</strong>; for example, <strong class="source-inline">AbstractTest</strong>. You can take a look at <a href="https://packt.live/2IEkR9k">https://packt.live/2IEkR9k</a>.</p>
			<p>Let us take a look at the steps:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">Vehicle.php</strong> class and add the <strong class="source-inline">abstract</strong> keyword before the <strong class="source-inline">class</strong> keyword, as follows:<p class="source-code">abstract class Vehicle</p><p class="source-code">{</p><p class="source-code">    //code goes here</p><p class="source-code">}</p><p>So, the <strong class="source-inline">Vehicle</strong> class became an abstract class, as discussed.</p></li>
				<li>Also, prefix the class name with <strong class="source-inline">Abstract</strong>:<p class="source-code">abstract class AbstractVehicle </p><p class="source-code">{</p><p class="source-code">    //code goes here</p><p class="source-code">}</p><p>Rename the <strong class="source-inline">Vehicle.php</strong> file to <strong class="source-inline">AbstractVehicle.php</strong>.</p></li>
				<li>Update the <strong class="source-inline">Car.php</strong> file with the abstract <strong class="source-inline">AbstractVehicle</strong> class name and the <strong class="source-inline">AbstractVehicle.php</strong> filename, as follows:<p class="source-code">&lt;?php</p><p class="source-code">require_once 'AbstractVehicle.php';</p><p class="source-code">class Car extends AbstractVehicle </p><p class="source-code">{</p><p class="source-code">    //code goes here</p><p class="source-code">}</p><p>And for <strong class="source-inline">Motorcycle.php</strong>, add the following:</p><p class="source-code">&lt;?php</p><p class="source-code">require_once 'AbstractVehicle.php';</p><p class="source-code">class Motorcycle extends AbstractVehicle </p><p class="source-code">{</p><p class="source-code">    //code goes here</p><p class="source-code">}</p></li>
				<li>We need to add an attribute to the <strong class="source-inline">AbstractVehicle</strong> class to store the engine status – whether it is started or stopped, so let's add a protected <strong class="source-inline">$engineStatus</strong> attribute as a Boolean type so that it holds the status of the running engine as <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>:<p class="source-code">&lt;?php</p><p class="source-code">abstract class AbstractVehicle </p><p class="source-code">{</p><p class="source-code">    public $make;</p><p class="source-code">    public $model;</p><p class="source-code">    public $color;</p><p class="source-code">    protected $noOfWheels; </p><p class="source-code">    private $engineNumber;</p><p class="source-code">    public static $counter = 0;</p><p class="source-code">    protected $engineStatus = false;</p><p>Here, we have added an <strong class="source-inline">$engineStatus</strong> attribute that is false by default, so we can confirm that the engine is not running.</p><p>According to our abstract class concept, we will add some implemented methods that will be the same in each vehicle type and some non-implemented abstract methods that will be implemented differently in each vehicle type. The engine starting is different in a car and a motorcycle so this method should be abstract, but stopping the engine or getting the engine's status should be the same for both.</p></li>
				<li>Add the following abstract method signature in the abstract <strong class="source-inline">Vehicle</strong> class, which should be implemented differently (read: behave differently) in <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong>:<p class="source-code">    abstract function start();</p><p>Now, both vehicle subclasses will be enforced to add an implementation of this method in their own classes. </p></li>
				<li>Also, we will be delivering common functionalities in terms of the implemented method so that the subclasses can avail them. Add the following two methods in the <strong class="source-inline">AbstractVehicle</strong> class:<p class="source-code">    function stop()</p><p class="source-code">    {</p><p class="source-code">        $this-&gt;engineStatus = false;</p><p class="source-code">    }</p><p class="source-code">    function getEngineStatus()</p><p class="source-code">    {</p><p class="source-code">        return $this-&gt;engineStatus;</p><p class="source-code">    }</p><p>Here, in order to stop the engine and get the engine's status, we have added the <strong class="source-inline">stop()</strong> and <strong class="source-inline">getEngineStatus()</strong> methods. So, these two should be the same in <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong>.</p><p>Finally, the abstract <strong class="source-inline">AbstractVehicle</strong> class with a single abstract method looks like the following:</p><p class="source-code-heading">AbstractVehicle.php</p><p class="source-code">1  &lt;?php</p><p class="source-code">2  abstract class AbstractVehicle</p><p class="source-code">3  {</p><p class="source-code">4      public $make;</p><p class="source-code">5      public $model;</p><p class="source-code">6      public $color;</p><p class="source-code">7      protected $noOfWheels;</p><p class="source-code">8      private $engineNumber;</p><p class="source-code">9      public static $counter = 0;</p><p class="source-code">10     protected $engineStatus = false;</p><p class="source-code-link"><a href="https://packt.live/2AVSSh0">https://packt.live/2AVSSh0</a></p></li>
				<li>Now, it's time to implement the abstract <strong class="source-inline">start()</strong> method in the subclasses. A car has its own way of starting its engine — you need to place the key in the ignition. In <strong class="source-inline">Car.php</strong>, add a private property, <strong class="source-inline">$hasKeyinIgnition</strong>, along with the <strong class="source-inline">start()</strong> implementation, as follows:<p class="source-code-heading">Car.php</p><p class="source-code">1  &lt;?php</p><p class="source-code">2  require_once 'AbstractVehicle.php';</p><p class="source-code">3  class Car extends AbstractVehicle </p><p class="source-code">4  {</p><p class="source-code">5      public $doors = 4; </p><p class="source-code">6      public $passengerCapacity = 5;</p><p class="source-code">7      public $steeringWheel = true;</p><p class="source-code">8      public $transmission = 'Manual';</p><p class="source-code">9      private $hasKeyinIgnition = true;</p><p class="source-code">10     public function start()</p><p class="source-code">11     {</p><p class="source-code">12         if($this-&gt;hasKeyinIgnition) </p><p class="source-code">13         {</p><p class="source-code">14             $this-&gt;engineStatus = true;</p><p class="source-code">15         }</p><p class="source-code-link"><a href="https://packt.live/2pHdFmh">https://packt.live/2pHdFmh</a></p><p>So, a car implements the engine start with the key in the ignition. <strong class="source-inline">$this-&gt;hasKeyinIgnition</strong> should be <strong class="source-inline">true</strong> to set the <strong class="source-inline">$engineStatus</strong> variable to <strong class="source-inline">start</strong> or <strong class="source-inline">true</strong>. </p></li>
				<li>We can create a <strong class="source-inline">Car</strong> object and start/stop the engine as follows:<p class="source-code">$car = new Car('Honda', 'Civic', 'Red', 4, '23CJ4567');</p><p class="source-code">$car-&gt;start();</p><p class="source-code">echo "The car is " . ($car-&gt;getEngineStatus()?'running':'stopped') .   PHP_EOL;</p><p class="source-code">$car-&gt;stop();</p><p class="source-code">echo "The car is " . ($car-&gt;getEngineStatus()?'running':'stopped') .   PHP_EOL;</p></li>
				<li>Run <strong class="source-inline">Car.php</strong> with the <strong class="source-inline">php Car.php</strong> command. The preceding code should output the following:<div class="IMG---Figure" id="_idContainer113"><img alt="Figure 5.16: Abstract method implementation on the car objec&#13;&#10;" src="image/C14196_05_16.jpg"/></div><p class="figure-caption">Figure 5.16: Abstract method implementation on the car objec</p></li>
				<li>A motorcycle needs a key to unlock the vehicle and a kick on the corresponding lever to start the engine. The term "kickstart" was coined from this particular type of vehicle. Open <strong class="source-inline">Motorcycle.php</strong> to simulate the key being in place and a kickstart taking place. Let's add two private attributes, <strong class="source-inline">$hasKey</strong> and <strong class="source-inline">$hasKicked</strong>, and implement the <strong class="source-inline">start()</strong> method as follows:<p class="source-code">class Motorcycle extends AbstractVehicle </p><p class="source-code">{</p><p class="source-code">    public $noOfWheels = 2;</p><p class="source-code">    public $stroke = 4;</p><p class="source-code">    private $hasKey = true;</p><p class="source-code">    private $hasKicked = true;</p><p class="source-code">    public function start()</p><p class="source-code">    {</p><p class="source-code">        if($this-&gt;hasKey &amp;&amp; $this-&gt;hasKicked) </p><p class="source-code">        {</p><p class="source-code">            $this-&gt;engineStatus = true;</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p><p>Here, in the <strong class="source-inline">start()</strong> method, we have checked that both elements for starting a motorcycle engine are present and started the engine by setting <strong class="source-inline">$engineStatus</strong> to <strong class="source-inline">true</strong>.</p></li>
				<li>Similarly, we can create a <strong class="source-inline">Motorcycle</strong> object and start/stop the engine as follows:<p class="source-code">$motorcycle = new Motorcycle('Kawasaki', 'Ninja', 'Orange', 2,   '53WVC14598');</p><p class="source-code">$motorcycle-&gt;start();</p><p class="source-code">echo "The motorcycle is " . ($motorcycle-&gt;getEngineStatus()?'running':  'stopped') . PHP_EOL;</p><p class="source-code">$motorcycle-&gt;stop();</p><p class="source-code">echo "The motorcycle is " . ($motorcycle-&gt;getEngineStatus()?'running':  'stopped') . PHP_EOL;</p></li>
				<li>Run <strong class="source-inline">Motorcycle.php</strong> with the <strong class="source-inline">php Motorcycle.php</strong> command. The preceding code should output the following:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer114">
					<img alt="Figure 5.17: Abstract method implementation on the motorcycle object&#13;&#10;" src="image/C14196_05_17.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.17: Abstract method implementation on the motorcycle object</p>
			<p>So, different behaviors of the same action among the children should come from the parent in an abstract way.</p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor195"/>Interfaces</h1>
			<p>We have discussed how an abstract class can come up with common and abstract methods. In an abstract class, we keep the methods abstract that should be different in derived classes. What if we want a full set of abstract functionalities? Or, what if we want to settle a standard of functionality? Maybe we want to establish a standard set of methods to communicate with the object? This is why we need an interface. An interface groups similar abstract methods so that it can express an abstract feature and different classes that need that feature can implement the interface. For example, the <strong class="source-inline">Flight</strong> feature is implemented by <strong class="source-inline">Birds</strong> and <strong class="source-inline">Aeroplanes</strong>. Hence, the <strong class="source-inline">Flight</strong> interface has to be fully abstract so that <strong class="source-inline">Birds</strong> and <strong class="source-inline">Aeroplanes</strong> can implement completely different flight techniques.</p>
			<p>An interface can be similar to a class without the <strong class="source-inline">class</strong> keyword and without all the method's body. Therefore, an interface is a collection of method signatures to be implemented like the following syntax:</p>
			<p class="source-code">interface MyInterface{</p>
			<p class="source-code">    function methodName1();</p>
			<p class="source-code">    function methodName2();</p>
			<p class="source-code">    //so on</p>
			<p class="source-code">}</p>
			<p class="source-code">class MyClass implements MyInterface{</p>
			<p class="source-code">    function methodName1() </p>
			<p class="source-code">    {</p>
			<p class="source-code">        //method body</p>
			<p class="source-code">    }</p>
			<p class="source-code">    function methodName2() </p>
			<p class="source-code">    {</p>
			<p class="source-code">        //method body</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>An interface cannot be extended but rather implemented; classes use the <strong class="source-inline">implements</strong> keyword to inherit the given interfaces so that they can implement them. PHP supports constants in interfaces so that implementing classes have those constants automatically defined. A class that implements an interface should implement every method and if any method remains unimplemented, then it will produce a fatal error.</p>
			<p>A class can implement multiple interfaces:</p>
			<p class="source-code">class A implements B, C </p>
			<p class="source-code">{</p>
			<p class="source-code">    // class body</p>
			<p class="source-code">}</p>
			<p>And an interface can extend multiple interfaces:</p>
			<p class="source-code-heading">interface.php</p>
			<p class="source-code">1  interface A </p>
			<p class="source-code">2  {</p>
			<p class="source-code">3      function a();</p>
			<p class="source-code">4  }</p>
			<p class="source-code">5       </p>
			<p class="source-code">6  interface B </p>
			<p class="source-code">7  {</p>
			<p class="source-code">8      function b();</p>
			<p class="source-code">9  }</p>
			<p class="source-code">10 interface C extends A, B </p>
			<p class="source-code">11 {</p>
			<p class="source-code">12     function c();</p>
			<p class="source-code">13 }</p>
			<p class="source-code-link"><a href="https://packt.live/2IFanX7">https://packt.live/2IFanX7</a></p>
			<p>So, a class can extend a single class and can implement multiple interfaces, and an interface can extend multiple interfaces. But implementing/extending interfaces should not have methods with the same name, which creates interface clashing.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Interfacing methods are always public and you can't declare access modifiers for method prototypes in their declaration. </p>
			<p class="callout">Interface constants can be accessed similarly to class constants but they cannot be overridden through inheritance by classes or interfaces. </p>
			<p>Here is a representation of the <strong class="source-inline">Drive</strong> interface:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer115">
					<img alt="Figure 5.18: Drive interface diagram&#13;&#10;" src="image/C14196_05_18.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.18: Drive interface diagram</p>
			<p>Referring to the preceding diagram, consider the vehicle analogy again. Cars and Motorcycles both can be driven so they need their own drive interfaces. While driving, they should change their speed, change gear, apply breaks, and so on. We can see that driving behavior is common and the necessary actions are the same in both types of vehicles. The thing is, despite the same actions, their way of dealing with those actions is different. This is where we need an interface. We might want to declare a <strong class="source-inline">Drive</strong> interface with the <strong class="source-inline">changeGear()</strong>, <strong class="source-inline">changeSpeed()</strong>, and <strong class="source-inline">applyBreak()</strong> abstract methods. </p>
			<p>Therefore, an interface focuses on functionality, rather than being a template (of an abstract class) for an object. And this is the main difference between the interface and class abstraction.</p>
			<p>We can add a simple drive interface for <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong> so that the vehicle can change speed, change gear, and apply the brake. If the vehicle hasn't implemented the brake, then a fatal error will be displayed. </p>
			<p>Let's add the driving feature as an interface in the following exercise.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor196"/>Exercise 5.7: Implementing an Interface</h2>
			<p>In this exercise, we will practice working with the object interfaces and learn how an interface can settle a standard way of implementing behaviors for objects. We will create an interface with the necessary driving guidelines, such as the ability to change speed and gear, or the ability to apply the brakes when needed:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As per PSR naming conventions, an interface name must be suffixed by <strong class="source-inline">interface</strong>; for example, <strong class="source-inline">TestInterface</strong> (<a href="https://packt.live/2IEkR9k">https://packt.live/2IEkR9k</a>).</p>
			<ol>
				<li value="1">Create the following Drive interface and save the file as <strong class="source-inline">DriveInterface.php</strong>:<p class="source-code">&lt;?php</p><p class="source-code">interface DriveInterface</p><p class="source-code">{</p><p class="source-code">    public function changeSpeed($speed);</p><p class="source-code">    public function changeGear($gear);</p><p class="source-code">    public function applyBreak();</p><p class="source-code">}</p><p>Here, we have declared the <strong class="source-inline">Drive</strong> interface with a minimal set of method signatures. Remember, no implementation should be available here; rather, the implementation should be shifted to objects that implement such an interface.</p><p>To change the speed, we have added the <strong class="source-inline">changeSpeed($speed)</strong> method signature, which accepts an argument for the speed to achieve. To change the gear, we have added the <strong class="source-inline">changeGear($gear)</strong> method signature, which accepts an argument for the gear number to be shifted to. To apply the brakes, we have added the <strong class="source-inline">applyBreak()</strong> method so that we can just simulate the "break" behavior whenever required. </p></li>
				<li>Add the interface to both the <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong> classes as follows:<p class="source-code">&lt;?php</p><p class="source-code">require_once 'AbstractVehicle.php';</p><p class="source-code">require_once 'DriveInterface.php';</p></li>
				<li>Now, the <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong> class should implement the interface as follows and add their own implementations for <strong class="source-inline">changeSpeed()</strong>, <strong class="source-inline">changeGear()</strong>, and <strong class="source-inline">applyBreak()</strong>:<p class="source-code">class Car extends AbstractVehicle implements DriveInterface </p><p class="source-code">{</p><p class="source-code">    </p><p class="source-code">}</p><p class="source-code">class Motorcycle extends AbstractVehicle implements DriveInterface </p><p class="source-code">{</p><p class="source-code">    </p><p class="source-code">}</p><p>If we try to run <strong class="source-inline">Car.php</strong> or <strong class="source-inline">Motorcycle.php</strong>, it will produce a fatal error that the classes must contain three abstract methods and, therefore, be declared abstract or implement the remaining methods. Therefore, we need to add the implementation of those three interfaces or methods.</p></li>
				<li>Add the implementation of those three methods in the <strong class="source-inline">Car</strong> class as follows:<p class="source-code">    public function changeSpeed($speed)</p><p class="source-code">    {</p><p class="source-code">        echo "The car has been accelerated to ". $speed. " kph. ".          PHP_EOL;</p><p class="source-code">    }</p><p class="source-code">    public function changeGear($gear)</p><p class="source-code">    {</p><p class="source-code">        echo "Shifted to gear number ". $gear. ". ". PHP_EOL;</p><p class="source-code">    }</p><p class="source-code">    public function applyBreak()</p><p class="source-code">    {</p><p class="source-code">        echo "All the 4 breaks in the wheels applied. ". PHP_EOL;</p><p class="source-code">    }</p><p>Here, <strong class="source-inline">Car</strong> has implemented the three methods from the <strong class="source-inline">DriveInterface</strong> interface. We can put the relevant implementation in them but, for the sake of learning, we have just printed a simple line in them. </p></li>
				<li>Now, instantiate the <strong class="source-inline">Car</strong> class as follows and start driving:<p class="source-code">$car = new Car('Honda', 'Civic', 'Red', 4, '23CJ4567');</p><p class="source-code">$car-&gt;changeSpeed(65);</p><p class="source-code">$car-&gt;applyBreak();</p><p class="source-code">$car-&gt;changeGear(4);</p><p class="source-code">$car-&gt;changeSpeed(75);</p><p class="source-code">$car-&gt;applyBreak();</p><p>Here, we have accessed the driving methods to execute the operations implemented by <strong class="source-inline">Car</strong>.</p></li>
				<li>If we try to run the <strong class="source-inline">Car</strong> script, with <strong class="source-inline">php Car.php</strong>, the preceding code should print the following:<div class="IMG---Figure" id="_idContainer116"><img alt="Figure 5.19: The DriveInterface interface implemented by car&#13;&#10;" src="image/C14196_05_19.jpg"/></div><p class="figure-caption">Figure 5.19: The DriveInterface interface implemented by car</p></li>
				<li>Also, add the implementation of those three methods in the <strong class="source-inline">Motorcycle</strong> class, as follows:<p class="source-code">    public function changeSpeed($speed)</p><p class="source-code">    {</p><p class="source-code">        echo "The motorcycle has been accelerated to ". $speed. " kph. " .           PHP_EOL;</p><p class="source-code">    }</p><p class="source-code">    public function changeGear($gear)</p><p class="source-code">    {</p><p class="source-code">        echo "Gear shifted to ". $gear. ". " . PHP_EOL;</p><p class="source-code">    }</p><p class="source-code">    public function applyBreak()</p><p class="source-code">    {</p><p class="source-code">        echo "The break applied. " . PHP_EOL;</p><p class="source-code">    }</p><p>Here, we have implemented the <strong class="source-inline">DriveInterface</strong> interface in the <strong class="source-inline">Motorcycle</strong> class. Just like that, you can come up with your own implementation and, here, for the sake of learning, we have printed different information in this <strong class="source-inline">DriveInterface</strong> implementation.</p></li>
				<li>Now, instantiate the <strong class="source-inline">Motorcycle</strong> class as follows and start driving:<p class="source-code">$motorcycle = new Motorcycle('Kawasaki', 'Ninja', 'Orange', 2,   '53WVC14598');</p><p class="source-code">$motorcycle-&gt;changeSpeed(45);</p><p class="source-code">$motorcycle-&gt;changeGear(3);</p><p class="source-code">$motorcycle-&gt;applyBreak();</p><p>Here, we have accessed the driving methods to execute the operations implemented by <strong class="source-inline">Motorcycle</strong>.</p></li>
				<li>If we try to run the <strong class="source-inline">Motorcycle</strong> script with <strong class="source-inline">php Motorcycle.php</strong>, the preceding code should print the following:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer117">
					<img alt="" src="image/C14196_05_20.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.20: The DriveInterface interface implemented by Motorcycle</p>
			<p>Hence, the vehicles can shift gears, change speed, and brake while driving. The <strong class="source-inline">DriveInterface</strong> interface described what should be the standard behaviors for vehicles for driving and their derived objects obeyed the formula of the standard feature. Moreover, the interface can add more functionalities so that the derived objects are forced to implement them.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The declaration of implemented methods and interface methods must be compatible with each other; for example, the number of arguments or the signature should be exactly the same.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor197"/>Abstract Classes versus Interfaces</h2>
			<p>We have learned how the concepts of class abstraction and object interfaces work nicely as added dimensions of inheritance to deliver common behaviors and standards for derived objects. There are frequent debates about when to use abstract classes and when to use interfaces. Although we have gone through the practical use cases of both via our exercises, the topic still needs discussion.</p>
			<p>Abstract classes are meant to deliver common behaviors or actions via methods to extended objects while keeping vital room for common methods to be implemented differently by derived objects. In contrast, interfaces are for setting standard ways of interacting with objects. An abstract class must have at least one abstract method, whereas all the methods in an interface are abstract. Remember, this is not a concept of having one or more abstract methods versus all abstract methods. Both have their own use cases when it comes to inheritance: the abstract class delivers the common functionalities and allows us to implement our own functionalities, whereas the interface is not about sharing functionalities at all; rather, the interface is all about setting standards for certain actions.</p>
			<p>Simple abstract classes can have implemented methods and attributes, whereas interfaces cannot as they contain constants and method signatures without bodies. Therefore, it is not possible to share code via interfaces.</p>
			<p>In previous exercises, the abstract class provided us with common engine functionalities and allowed us to deal with specific features of the engine in our own way. The interface showed us the standards to drive the car and we followed the guidelines accordingly to achieve our own goal of driving actions.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor198"/>Class Type Hinting Plays a Role in Dependency Injection</h2>
			<p>Type hinting allows us to define the type of data to be passed as arguments into a function. PHP supports class type hints, which means that, in function arguments, you can mention which class type the passed argument object belongs to. For example, a <strong class="source-inline">User</strong> class might want to use a <strong class="source-inline">Mailer</strong> service to deliver email. The <strong class="source-inline">Mailer</strong> object can be passed to the <strong class="source-inline">User</strong> class and the <strong class="source-inline">User</strong> needs to make sure that nothing except a <strong class="source-inline">Mailer</strong> object is passed to it.</p>
			<p>Check out the following example where the function argument was expected to be an instance of a specific class:</p>
			<p class="source-code">function myMethod($object)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if(!($obj instanceof ClassName)) </p>
			<p class="source-code">    {</p>
			<p class="source-code">        throw new Exception('Only Objects of ClassName can be sent to this           function.');</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>If the object is not an instance of the expected class, then an exception is thrown with the message '<strong class="source-inline">Only Objects of ClassName can be sent to this function.</strong>'.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">An exception is a class that is throwable and catchable with an error message so that the catch block can catch the exception and work accordingly. <em class="italic">Chapter 8, Error Handling,</em> discusses exceptions in detail.</p>
			<p>The preceding snippet is equivalent to the following class type hinting syntax:</p>
			<p class="source-code">function myMethod(ClassName $object)</p>
			<p class="source-code">{</p>
			<p class="source-code">}</p>
			<p>So, with class type hinting, we can enforce the function or method caller to pass the appropriate type of object. When class type hinting is applied, PHP automatically performs <strong class="source-inline">instanceof</strong> checking and produces an error if the object doesn't satisfy the class relationship.</p>
			<p><strong class="bold">Dependency injection</strong> is the technique of supplying an object to another object that is dependent on the first object. For example, a <strong class="source-inline">user</strong> object might need to send out emails and perform certain database operations; therefore, the user is dependent on the <strong class="source-inline">mailer</strong> object and the <strong class="source-inline">database</strong> object. We could supply such <strong class="source-inline">mailer</strong> and <strong class="source-inline">database</strong> objects to the <strong class="source-inline">user</strong> object as follows:</p>
			<p class="source-code-heading">User.php</p>
			<p class="source-code">1  &lt;?php</p>
			<p class="source-code">2  class User </p>
			<p class="source-code">3  {</p>
			<p class="source-code">4      public $name;</p>
			<p class="source-code">5      private $mailer;</p>
			<p class="source-code">6      private $database;</p>
			<p class="source-code">7      </p>
			<p class="source-code">8      function __construct(string $name, Mailer $mailer, Database $db)</p>
			<p class="source-code">9      {</p>
			<p class="source-code">10         $this-&gt;name = $name;</p>
			<p class="source-code">11         $this-&gt;mailer = $mailer;</p>
			<p class="source-code">12         $this-&gt;database = $db;</p>
			<p class="source-code">13     }</p>
			<p class="source-code">14 }</p>
			<p class="source-code-link"><a href="https://packt.live/2M2Kl23">https://packt.live/2M2Kl23</a></p>
			<p>Here, while instantiating the <strong class="source-inline">User</strong> class, we have passed the name of the user, a <strong class="source-inline">mailer</strong> object, and a <strong class="source-inline">database</strong> object as arguments. The <strong class="source-inline">Mailer</strong> <strong class="source-inline">$mailer</strong> class type hint ensures that the only instance of the <strong class="source-inline">Mailer</strong> class can be supplied and the other class type hint at <strong class="source-inline">Database $database</strong> ensures that the only instance of the <strong class="source-inline">Database</strong> class can be supplied. We have added these two object dependencies in the user's constructor so that the object gets loaded with certain dependencies and any failure upon injecting dependencies will prevent object creation.</p>
			<p>The preceding technique is called <strong class="bold">constructor injection</strong>. You can inject dependencies using a setter method or you can use a dependency injection container. You could search for books or online resources to extend your learning about dependency injection even further.</p>
			<p>In the next section, we are going to discuss two important aspects of polymorphism that serve the same purpose for different conditions.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor199"/>Overriding </h1>
			<p>Overriding is the process of updating an existing implementation (an inherited implementation) with a new one; it can be redeclaring a class attribute in derived objects or it can be taking an inherited member method to update with a whole new function body. Overriding keeps the external interface the same while the internal </p>
			<p>functionalities might be fully changed to suit your own objectives. In PHP, you can do both attribute and method overriding. Note that this overriding happens in new classes derived by inheritance.</p>
			<p>For example, an animal class might provide a common behavior; for example, eat. Such behavior is shared among the animal subclasses via inheritance. But the fact is, each animal subclass has its own way of eating. Like dogs and birds, they have redefined the behavior of eating in their own class. The idea of adding your own way of doing something is conceptualized as overriding.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor200"/>Attribute Overriding</h2>
			<p>Attribute overriding is the process of replacing the parent's class' data in the subclass. We have already seen that the <strong class="source-inline">Motorcycle</strong> class overrides the inherited number of wheels from the parent <strong class="source-inline">Vehicle</strong> class to two as motorcycles are two-wheelers. So, in order to suit the derived class' requirement, we have overridden the attribute:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">require_once 'AbstractVehicle.php';</p>
			<p class="source-code">class Motorcycle extends AbstractVehicle </p>
			<p class="source-code">{</p>
			<p class="source-code">    public $noOfWheels = 2;</p>
			<p class="source-code">    public $stroke = 4;</p>
			<p class="source-code">}</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor201"/>Method Overriding</h2>
			<p>Method overriding is necessary when we need to rewrite an inherited method. For example, to get the price of a vehicle, the class provides a getter method and the vehicle subclasses can avail the getter via inheritance. What if we want to tweak the returned price for a particular type of vehicle; for example, a discounted motorcycle price, and keep the getter intact for <strong class="source-inline">Car</strong>? We need to tweak the desired subclass price getter by overriding it. </p>
			<p>Check out the following example of method overriding:</p>
			<p class="source-code">class MySimpleClass{</p>
			<p class="source-code">    public $propertyName = 'base property';</p>
			<p class="source-code">    function methodName()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        echo 'I am a base method. ';</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">class MyNewClass extends MySimpleClass{</p>
			<p class="source-code">    function methodName()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        echo 'I am an overridden method. ';</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">$object = new MyNewClass();</p>
			<p class="source-code">$object-&gt;propertyName; //holds 'base property'</p>
			<p class="source-code">$object-&gt;methodName(); //prints 'I am an overridden method.'</p>
			<p>So, we can override the inherited method and update the method with the new implementation. </p>
			<p>Let's have some fun and sell our vehicles. So far, we have been adding technical features to our vehicles with the help of OOP. Now, let's add some commerce-related features to our vehicle types. In the following exercise, the price for the car and motorcycle should be returned using a common method. The price of a motorcycle should be returned after applying a 5% discount, and no discount is applicable to the car price.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor202"/>Exercise 5.8: Overriding an Inherited Method</h2>
			<p>In this exercise, we will practice method overriding by adding a simple <strong class="source-inline">getPrice()</strong> getter method to the parent <strong class="source-inline">Vehicle</strong> class and override the method from our child classes. If we add a getter method with the implementation of the method into the parent <strong class="source-inline">Vehicle</strong> class, then it should be available for all the subclasses to use. We are going to override the <strong class="source-inline">getPrice()</strong> method in the <strong class="source-inline">Motorcycle</strong> class since we need to handle the pricing in a different way in that subclass:</p>
			<ol>
				<li value="1">Open <strong class="source-inline">AbstractVehicle.php</strong> and add the following protected attribute in the attributes section:<p class="source-code">    protected $price;</p></li>
				<li>Also, add the <strong class="source-inline">getPrice()</strong> and <strong class="source-inline">setPrice()</strong> price getter and setter methods in the methods section as follows:<p class="source-code">    function getPrice()</p><p class="source-code">    {</p><p class="source-code">        return $this-&gt;price;</p><p class="source-code">    }</p><p class="source-code">    function setPrice($price)</p><p class="source-code">    {</p><p class="source-code">        $this-&gt;price = $price;</p><p class="source-code">    }</p><p>Here, the <strong class="source-inline">getPrice()</strong> simply returns the price and <strong class="source-inline">setPrice()</strong> takes <strong class="source-inline">$price</strong> as an argument, assigns it to the <strong class="source-inline">price</strong> attribute of the vehicle, and both these methods should be available to the <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong> objects so that we can set and get the prices of a car and a motorcycle, respectively.</p></li>
				<li>Imagine there is a discount of 5% on all kinds of motorcycles for a special occasion. Now, we need to apply the discount to the price of this particular vehicle type.<p>In order to handle prices differently, we need to override the <strong class="source-inline">getPrice()</strong> method in the <strong class="source-inline">Motorcycle.php</strong> class and add the <strong class="source-inline">getPrice()</strong> method into the class, as follows, and modify the price calculation:</p><p class="source-code">    function getPrice()</p><p class="source-code">    {</p><p class="source-code">        return $this-&gt;price - $this-&gt;price * 0.05;</p><p class="source-code">    }</p><p>Here, we have deducted the discounted value from the original price. So, the motorcycle objects will return the discounted price and the car objects will return the original price.</p></li>
				<li>In order to test the discounted price, we should instantiate the <strong class="source-inline">Motorcycle</strong> class, set the price, and get the price to see whether a discount has been applied or not. Let's do the following in <strong class="source-inline">Motorcycle.php</strong>:<p class="source-code">$motorcycle = new Motorcycle('Kawasaki', 'Ninja', 'Orange', 2,   '53WVC14598');</p><p class="source-code">$motorcycle-&gt;setPrice(5000);</p><p class="source-code">echo "The price is ". $motorcycle-&gt;getPrice() . PHP_EOL;</p><p>Here, we have settled the original price as <strong class="source-inline">5000</strong> and tried to get the price using the <strong class="source-inline">getPrice()</strong> method. </p></li>
				<li>Now, if we run <strong class="source-inline">Motorcycle.php</strong> with the <strong class="source-inline">php Motorcycle.php</strong> command, the preceding code outputs the following:<p class="source-code">The price is 4750</p></li>
			</ol>
			<p>So, the discount mentioned has been applied to the motorcycle price and if we apply the getter and setter methods for the cars, we should get the car price equal to the original price that we set. This is why, when we need something to be delivered in a different manner by the child classes, we need an override.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor203"/>Overloading</h2>
			<p>Another important aspect of using the polymorphism concept of overloading relates to the use of the same thing defined differently or the same thing behaving differently on different occasions. </p>
			<p>Generally, among programming languages such as C++ and Java, method overloading or function polymorphism is just declaring the same function with different parameters; for example, <strong class="source-inline">int add(int a, int b)</strong>, <strong class="source-inline">int add(int a, int b, int c)</strong>, <strong class="source-inline">double add( double a, double b, double c)</strong>, and so on. These might have different implementations inside. In such a traditional way, the function name remains the same while the return type and the number of arguments and their types might be different. This also happens in statically typed programming languages (C++/Java) where type checking happens at compile time and function binding depends on the type of each parameter. Hence, for statically typed languages, each such function is different.</p>
			<p>In PHP, you could try to declare a function or method with the same name as the following:</p>
			<p class="source-code">function add($a, $b)</p>
			<p class="source-code">{</p>
			<p class="source-code">    //function body</p>
			<p class="source-code">}</p>
			<p class="source-code">function add($a, $b, $c)</p>
			<p class="source-code">{</p>
			<p class="source-code">    //function body</p>
			<p class="source-code">}</p>
			<p>This would produce a fatal error that you cannot redeclare a function or method with the same name.</p>
			<p>PHP doesn't support declaring same function multiple times. Still, you can achieve classical function overloading using the built-in <strong class="source-inline">func_get_args()</strong> function in order to enable the same function, taking a multiple number of arguments since PHP isn't bothered about parameter types. Here's an example for the sake of discussion here. Let's use the following approach:</p>
			<p class="source-code">function add() </p>
			<p class="source-code">{</p>
			<p class="source-code">    $sum = 0;</p>
			<p class="source-code">    $args = func_get_args();</p>
			<p class="source-code">    foreach ($args as $arg)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        $sum += $arg;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return $sum;</p>
			<p class="source-code">}</p>
			<p class="source-code">echo add(1, 2); //outputs '3'</p>
			<p class="source-code">echo add(10.5, 2.5); //outputs '13'</p>
			<p class="source-code">echo add(10.5, 2.5, 9.6, 55.2); //outputs '77.8'</p>
			<p><strong class="source-inline">func_get_args()</strong> can really turn your functions on to support multiple arguments. Also, if you are worried about parameter types, you can deal with type checking inside the function. </p>
			<p>So the preceding approach is not the approach we are going to talk about in this section on method overloading in OOP. PHP has a lot to offer flexibility-wise when it comes to overloading in OOP. Still, the approach is different from other languages and that might be why there is some controversy about the way it serves overloading compared to traditional overloading. </p>
			<p>The interpretation of overloading in PHP is different than most of the other object-oriented languages. Overloading allows you to have multiple methods with the same name but different signatures.</p>
			<p>PHP allows the overloading of attribute and method calls by implementing certain magic methods. These magic methods are invoked when trying to access the attributes and methods that are not declared or are not accessible in the current scope. Such special proxy methods are to create attributes and methods during runtime (dynamic attributes and methods), and we can implement magic methods easily in our class for numerous functionalities. </p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor204"/>Attribute Overloading</h2>
			<p>We might need to add data to our objects at runtime; for example, in our <strong class="source-inline">Car</strong> subclass, we haven't declared attributes such as model, year, owner name, and so on. But while running the program, we might want to welcome such attributes to be stored in our objects. PHP allows you to achieve such dynamic attribute addition at runtime in terms of attribute overloading. Hence, with such dynamic declaration, attributes become polymorphic enough in use and can be overloaded easily.</p>
			<p>For attribute or property overloading, PHP supports the following two magic methods:</p>
			<ul>
				<li><strong class="source-inline">public __get(string $attribute) : mixed</strong></li>
				<li><strong class="source-inline">public __set(string $attribute, mixed $value)</strong></li>
			</ul>
			<p><strong class="source-inline">__get()</strong> is invoked when accessing or reading data from not declared or not accessible (protected or private) attributes and <strong class="source-inline">__set()</strong> is invoked when trying to write data to not declared or not accessible (protected or private) attributes. All we need to do is implement these two special methods in our class to avail the dynamic (created at runtime) attributes. <strong class="source-inline">__set()</strong> accepts any types (mixed) of data in the second parameter; <strong class="source-inline">__get()</strong> returns that type of data. Here, the <strong class="source-inline">mixed</strong> keyword has been used to explain that the method returns or accepts a type of data, such as integer, string, array, object, and so on.</p>
			<p>Let's look at the class here, which has these two method implementations:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">class MyMagicClass </p>
			<p class="source-code">{</p>
			<p class="source-code">    private $arr = array();</p>
			<p class="source-code">    public function __set($attribute, $value)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        $this-&gt;arr[$attribute] = $value;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public function __get($attribute)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if (array_key_exists($attribute, $this-&gt;arr)) </p>
			<p class="source-code">        {</p>
			<p class="source-code">            return $this-&gt;arr[$attribute];</p>
			<p class="source-code">        }</p>
			<p class="source-code">        else </p>
			<p class="source-code">        {</p>
			<p class="source-code">            echo 'Error: undefined attribute.';</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">$object = new MyMagicClass();</p>
			<p class="source-code">$object-&gt;dynamicAttribute = 'I am magic';</p>
			<p class="source-code">echo $object-&gt;dynamicAttribute . PHP_EOL; //outputs, I am magic </p>
			<p>Here, the private declared property, <strong class="source-inline">$arr</strong> , holds the dynamic attributes coming from the <strong class="source-inline">__set()</strong> setter magic method. The attribute has been used as an array key to store the passed value with the <strong class="source-inline">$this-&gt;arr[$attribute] = $value</strong> line.</p>
			<p>Also, to return the settled attribute via the implemented getter magic method, <strong class="source-inline">__get()</strong>, we have checked that the attribute exists in the array using the <strong class="source-inline">array_key_exists()</strong> function. If it exists, then return the attribute value by accessing <strong class="source-inline">$arr</strong> with the attribute name as a key. Otherwise, print an error message.</p>
			<p>At the <strong class="source-inline">$object-&gt;dynamicAttribute = 'I am magic';</strong> line, we have accessed an attribute that is not declared anywhere within the <strong class="source-inline">MyMagicClass</strong> class. So, behind the scene, the magic method invoked <strong class="source-inline">__set('dynamicAttribute', 'I am magic')</strong> to store the attribute. The <strong class="source-inline">__get('dynamicAttribute')</strong> is invoked with the line <strong class="source-inline">echo $object-&gt;dynamicAttribute . PHP_EOL;</strong>. </p>
			<p>Thus, implementing such magic methods gives you a lot of flexibility to define your own attributes. Remember that attribute overloading works in object context and not in a static context. </p>
			<p>Now, the questions are, are we going to allow many attribute creation on the fly or should we apply some restrictions? Or is there any predefined set of attributes that we accept as overloaded. The answer is yes, we should predefine the set of attributes that we are going to overload. In the previous example, we should add a predefined list of overloadable attributes into an array and in <strong class="source-inline">__set()</strong>, the given dynamic attribute should be cross-checked with our predefined array to check whether it is allowed or not.</p>
			<p>Let's check out the following example:</p>
			<p class="source-code-heading">MyMagicClass.php</p>
			<p class="source-code">1  &lt;?php</p>
			<p class="source-code">2  class MyMagicClass</p>
			<p class="source-code">3  {</p>
			<p class="source-code">4      private $arr = array('dynamicAttribute' =&gt; NULL,'anotherAttribute' =&gt; NULL);</p>
			<p class="source-code">5      public function __set($attribute, $value)</p>
			<p class="source-code">6      {</p>
			<p class="source-code">7          if (array_key_exists($attribute, $this-&gt;arr))</p>
			<p class="source-code">8          {</p>
			<p class="source-code">9              $this-&gt;arr[$attribute] = $value;</p>
			<p class="source-code">10         } </p>
			<p class="source-code">11         else </p>
			<p class="source-code">12         {</p>
			<p class="source-code">13             echo 'Error: the attribute is not allowed. ';</p>
			<p class="source-code">14         }</p>
			<p class="source-code">15     }</p>
			<p class="source-code-link"><a href="https://packt.live/2B1RAkO">https://packt.live/2B1RAkO</a></p>
			<p>Here, we have added an associative array in the <strong class="source-inline">$arr</strong> private property and when the <strong class="source-inline">__set()</strong> method triggers, we cross-check that the attribute is allowed in <strong class="source-inline">$arr</strong> using the <strong class="source-inline">array_key_exists()</strong> function; otherwise, we print an error message.</p>
			<p>We are flexible enough to come up with innovative implementations and restrictions of such special proxy methods. After the magical setter and getter implementations, we can implement the following two magic methods:</p>
			<ul>
				<li><strong class="source-inline">public __isset(string $attribute) : bool</strong></li>
				<li><strong class="source-inline">public __unset(string $attribute): void</strong></li>
			</ul>
			<p>The <strong class="source-inline">__isset()</strong> one should be implemented if we want to check the attribute with <strong class="source-inline">isset($attribute)</strong> or the <strong class="source-inline">empty($attribute)</strong> function. Similarly, we should implement <strong class="source-inline">__unset()</strong> if we want to implement and unset the attribute with the <strong class="source-inline">unset($attribute)</strong> function. Without <strong class="source-inline">__isset()</strong> and <strong class="source-inline">__unset()</strong>, we won't be able to use native <strong class="source-inline">isset()</strong> and <strong class="source-inline">unset()</strong>. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">PHP's magic methods should not be declared as static since they trigger only in object context. The implemented magic methods must be declared as public. Also, pass by reference cannot be used as parameters in magic methods. The <strong class="source-inline">__</strong> notation is reserved for magic methods. </p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor205"/>Method Overloading</h2>
			<p>Method overloading is all about doing extra work with the same method. For example, in our <strong class="source-inline">Car</strong> subclass, we haven't declared the <strong class="source-inline">honking</strong> behavior. What if we can avail the <strong class="source-inline">honk()</strong> method dynamically (at runtime) and can overload the normal <strong class="source-inline">honking</strong> behavior with honking loud? PHP supports such dynamic method declaration and we are allowed to overload those methods.</p>
			<p>For method overloading, PHP supports the following two magic methods:</p>
			<ul>
				<li><strong class="source-inline">public __call(string $method, array $arguments): mixed</strong></li>
				<li><strong class="source-inline">public static __callStatic(string $method, array $arguments): mixed</strong></li>
			</ul>
			<p>These are the <strong class="source-inline">__call()</strong> invoked when the inaccessible method has been called in the object context and the <strong class="source-inline">__callStatic()</strong> invoked when the inaccessible method has been called in the static context. The second argument of these methods is <strong class="source-inline">$arguments</strong>, which is a numerically indexed array. The index 0 contains the first argument and so on.</p>
			<p>Let's check out the following implementations of these magic methods:</p>
			<p class="source-code-heading">MyMagicMethodClass.php</p>
			<p class="source-code">1  &lt;?php</p>
			<p class="source-code">2  class MyMagicMethodClass </p>
			<p class="source-code">3  {</p>
			<p class="source-code">4      public function __call($method, $arguments)</p>
			<p class="source-code">5      {</p>
			<p class="source-code">6          var_dump($arguments);</p>
			<p class="source-code">7      }</p>
			<p class="source-code">8      public static function __callStatic($method, $arguments)</p>
			<p class="source-code">9      {</p>
			<p class="source-code">10         var_dump($arguments);</p>
			<p class="source-code">11     }</p>
			<p class="source-code">12 }</p>
			<p class="source-code-link"><a href="https://packt.live/2ou8JRm">https://packt.live/2ou8JRm</a></p>
			<p>Here, with the <strong class="source-inline">$object-&gt;showMagic('object context', 'second argument');</strong> line, <strong class="source-inline">showMagic()</strong> is declared nowhere or is a non-accessible method to the object handler, so behind the scenes the <strong class="source-inline">__call()</strong> is invoked like <strong class="source-inline">__call('showMagic', array('object context', 'second argument'))</strong>. Also, you can see that the <strong class="source-inline">showMagic()</strong> method can interact with a different number of arguments.</p>
			<p>Similarly, <strong class="source-inline">__callStatic('showMagic', array(static context'))</strong> works in the static context when <strong class="source-inline">MyMagicMethodClass::showMagic('static context')</strong> gets called.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor206"/>Exercise 5.9: Implementing Attribute and Method Overloading</h2>
			<p>In this exercise, let's implement the overloading magic methods in <strong class="source-inline">AbstractVehicle</strong> so that both vehicle types should have the facility to define their dynamic attributes and methods at runtime. All we need to do is, go through our previously discussed implementation of the <strong class="source-inline">__set()</strong>,<strong class="source-inline">__get()</strong>, and <strong class="source-inline">__call()</strong> magic methods into the <strong class="source-inline">AbstractVehicle</strong> class. This will help the <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong> objects avail such runtime properties and method creation:</p>
			<ol>
				<li value="1">Open <strong class="source-inline">AbstractVehicle.php</strong> and add the following private attribute, which holds dynamic time attributes:<p class="source-code">        private $runtimeAttributes = array();</p><p>Here, <strong class="source-inline">$runtimeAttributes</strong> should act as an associative array to store the runtime key-value pairs of the dynamic attributes. The attribute or property name should be the key with the associated value. </p></li>
				<li>Now, we should add the magic setter, <strong class="source-inline">__set()</strong>, in the <strong class="source-inline">AbstractVehicle</strong> class, as follows:<p class="source-code">        function __set($attribute, $value)</p><p class="source-code">        {</p><p class="source-code">            $this-&gt;runtimeAttributes[$attribute] = $value;</p><p class="source-code">        }</p><p>Here, the <strong class="source-inline">$attribute</strong> name and <strong class="source-inline">$value</strong> are passed to the magic method via the <strong class="source-inline">$attribute</strong> and <strong class="source-inline">$value</strong> arguments. The <strong class="source-inline">$value</strong> runtime attribute has been stored in the associative array using the <strong class="source-inline">$attribute</strong> attribute name argument as key, so that, later, we can access the runtime attribute with <strong class="source-inline">$this-&gt;runtimeAttributes[$attribute]</strong>.</p></li>
				<li>Let's add the magic getter, <strong class="source-inline">__get()</strong>, as well:<p class="source-code">        function __get($attribute)</p><p class="source-code">        {</p><p class="source-code">            if (array_key_exists($attribute, $this-&gt;runtimeAttributes)) </p><p class="source-code">            {</p><p class="source-code">                return $this-&gt;runtimeAttributes[$attribute];</p><p class="source-code">            } </p><p class="source-code">            else </p><p class="source-code">            {</p><p class="source-code">                echo "Error: undefined attribute. " . PHP_EOL;</p><p class="source-code">            }</p><p class="source-code">        }</p><p>Here, the magic method asks to return the runtime attribute value by passing the attribute name as an argument. The method checks whether the attribute name is available as a key in <strong class="source-inline">$this-&gt;runtimeAttributes</strong> using PHP's <strong class="source-inline">array_key_exists()</strong> function. If the attribute was set previously, then it should return it, else it will print the preceding error message.</p></li>
				<li>Now, try such attribute creation at runtime in the <strong class="source-inline">Car.php</strong> class. For example, we can add car properties such as <strong class="source-inline">ownerName</strong>, <strong class="source-inline">make</strong>, <strong class="source-inline">year</strong>, and so on, as follows:<p class="source-code">$car = new Car('Honda', 'Civic', 'Red', 4, '23CJ4567');</p><p class="source-code">$car-&gt;ownerName = 'John Doe';</p><p class="source-code">echo " Owner: ". $car-&gt;ownerName . PHP_EOL;</p><p class="source-code">$car-&gt;year = 2015;</p><p class="source-code">echo " Year: ". $car-&gt;year . PHP_EOL; </p><p class="source-code">$car-&gt;wipers;</p><p>Here, we haven't declared <strong class="source-inline">$ownerName</strong> and <strong class="source-inline">$year</strong> in the <strong class="source-inline">Car</strong> class. When an attribute is accessed via a <strong class="source-inline">Car</strong> object handler that is not declared or not accessible to the object, then PHP invokes magic methods in order to deliver you that attribute. Note that without assigning a value to such a runtime attribute, it won't be available or registered. </p><p>Since the <strong class="source-inline">Car</strong> class inherited the implemented magic methods and we have settled values on both the attributes using <strong class="source-inline">$car-&gt;ownerName</strong> and <strong class="source-inline">$car-&gt;year</strong>, they have been added into the <strong class="source-inline">$runtimeAttributes</strong> array, which is private to the parent <strong class="source-inline">Vehicle</strong> class.</p></li>
				<li>If we try to run <strong class="source-inline">Car.php</strong> with the <strong class="source-inline">php Car.php</strong> command, the preceding code should be printed as follows:<div class="IMG---Figure" id="_idContainer118"><img alt="Figure 5.21: Attribute overloading and non-existing attribute access of the car object&#13;&#10;" src="image/C14196_05_21.jpg"/></div><p class="figure-caption">Figure 5.21: Attribute overloading and non-existing attribute access of the car object</p><p>Here, we tried to access the car wipers using <strong class="source-inline">$car-&gt;wipers</strong>, which weren't assigned earlier. As a result, an attempt to access such attributes will print the message <strong class="source-inline">Error: undefined attribute.</strong>. Now, it's time to add a magic method <strong class="source-inline">__call()</strong> implementation into the <strong class="source-inline">AbstractVehicle</strong> class, so that the <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong> objects can avail the dynamic method interfaces in them. Add the <strong class="source-inline">__call</strong> implementation into the <strong class="source-inline">Vehicle</strong> class as follows:</p><p class="source-code">        function __call($method, $arguments)</p><p class="source-code">        {</p><p class="source-code">            echo "The method $method() called. " . PHP_EOL;</p><p class="source-code">        }</p></li>
				<li>Here, we have added the implementation of the magic method with two arguments. The first argument, <strong class="source-inline">$method</strong>, is for the method name, and the latter one, <strong class="source-inline">$arguments</strong>, is a numerically indexed array of arguments to be passed when we invoke the given method.<p>So, we can add our own styles or patterns as implementation, but now, for the sake of simplicity, we have just printed the method name inside the function.</p></li>
				<li>Add the following line at the bottom of <strong class="source-inline">Car.php</strong>:<p class="source-code">$car-&gt;honk();</p><p>Here, we have called the <strong class="source-inline">honk()</strong> method to dynamically add the honking behavior to our <strong class="source-inline">Car</strong> objects.</p></li>
				<li>If we run <strong class="source-inline">Car.php</strong> using the <strong class="source-inline">php Car.php</strong> command, it will output the following:<div class="IMG---Figure" id="_idContainer119"><img alt="Figure 5.22: Method overloading of car &#13;&#10;" src="image/C14196_05_22.jpg"/></div><p class="figure-caption">Figure 5.22: Method overloading of car </p></li>
				<li>We can now overload the <strong class="source-inline">honk()</strong> method easily by updating the <strong class="source-inline">__call()</strong> method at <strong class="source-inline">AbstractVehicle.php</strong> with the following content:<p class="source-code-heading">AbstractVehicle.php</p><p class="source-code">111     function __call($method, $arguments) </p><p class="source-code">112     { </p><p class="source-code">113         switch ($method) { </p><p class="source-code">114             case 'honk': </p><p class="source-code">115                 if (isset($arguments[0])) { </p><p class="source-code">116                     echo "Honking $arguments[0]... " . PHP_EOL; </p><p class="source-code">117                 } else { </p><p class="source-code">118                     echo "Honking... " . PHP_EOL; </p><p class="source-code">119                 } </p><p class="source-code">120                 if (isset($arguments[1])) { </p><p class="source-code">121                     echo "$arguments[1] enabled... " . PHP_EOL; </p><p class="source-code">122                 } </p><p class="source-code">123                 break; </p><p class="source-code">124             default: </p><p class="source-code">125                 echo "The method $method() called. " . PHP_EOL; </p><p class="source-code">126                 break; </p><p class="source-code">127         } </p><p class="source-code">128     } </p><p class="source-code-link"><a href="https://packt.live/2pbDEC8">https://packt.live/2pbDEC8</a></p><p>Here, we have added a switch case to accommodate different dynamic methods. We have added a case for the <strong class="source-inline">honk()</strong> method so that we can respond to it and perform steps for the <strong class="source-inline">honk()</strong> method. In the <strong class="source-inline">honk()</strong> case, for demo purposes, we have checked for supplied arguments, we have printed a message based on the first argument, and printed another message based on the second argument and so on. We can also handle the arguments differently. </p></li>
				<li>At the bottom of <strong class="source-inline">Car.php</strong>, after the previous <strong class="source-inline">$car-&gt;honk()</strong> line, add the following two lines:<p class="source-code">$car-&gt;honk('gently');</p><p class="source-code">$car-&gt;honk('louder', 'siren');</p><p>Here, we have overloaded the <strong class="source-inline">honk()</strong> method and the method became polymorphic. We can honk (default), we can honk gently, we can honk louder, and we can enable the siren in the event of an emergency. The whole idea of the honk analogy is to summarize how we can overload methods in PHP.</p></li>
				<li>If we run <strong class="source-inline">Car.php</strong> using the <strong class="source-inline">php Car.php</strong> command, it will output the following:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer120">
					<img alt="Figure 5.23: The honk method overloaded&#13;&#10;" src="image/C14196_05_23.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.23: The honk method overloaded</p>
			<p>This is how we can add dynamic properties and behaviors to our objects, and, yes, of course we can add attribute/method restrictions and cross-check them with a prebuilt checklist, implement patterns, and so on in such magic methods.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor207"/>Final Classes and Methods</h2>
			<p>When we finalize our class declaration by providing a standard set of attributes and methods to describe an object and we neither want the class to be modified nor an extension of that class, we need to declare it with the <strong class="source-inline">final</strong> keyword. For example, in a simple login process, we match the given password with the stored password to grant access to the user. We don't want this password matchmaker method to be modified so we need to declare the method as final or our user authentication class might have a standard set of methods that we don't want to be modified or extended so we need to declare the class as final.</p>
			<p>Final classes are written to not be inherited and final methods cannot be overridden. PHP uses the <strong class="source-inline">final</strong> keyword before the final class and final methods.</p>
			<p>Check out the following example of the final class:</p>
			<p class="source-code">final class MyClass</p>
			<p class="source-code">{</p>
			<p class="source-code">    public function myFunction()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        echo "Base class method called.";</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">class MyChildClass extends MyClass </p>
			<p class="source-code">{</p>
			<p class="source-code">}</p>
			<p>Here, if we try to extend the final class, <strong class="source-inline">MyClass</strong>, it will produce a fatal error that the <strong class="source-inline">MyChildClass</strong> class may not inherit from the final <strong class="source-inline">MyClass</strong> class.</p>
			<p>Also, let's have an example for the final methods:</p>
			<p class="source-code">class MySimpleClass</p>
			<p class="source-code">{</p>
			<p class="source-code">    final public function mySimpleMethod()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        echo "Base class method mySimpleMethod() called.";</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">class MyChildClass extends MySimpleClass</p>
			<p class="source-code">{</p>
			<p class="source-code">    public function mySimpleMethod()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        echo "Child class method mySimpleMethod() called.";</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The preceding will produce a fatal error as you cannot override a final method. </p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor208"/>Exercise 5.10: Implementing a Final Class and Methods</h2>
			<p>In this exercise, we are going to practice implementing a final class and methods to understand what the consequences of finalizing methods and classes are. We will be applying a member method as final in the <strong class="source-inline">Car</strong> subclass and then we will be applying the <strong class="source-inline">Car</strong> class as final so that we can block any derivation (inheritance) from the <strong class="source-inline">Car</strong> class:</p>
			<ol>
				<li value="1">Open <strong class="source-inline">Car.php</strong> and locate the <strong class="source-inline">start()</strong> method as follows:<p class="source-code">&lt;?php</p><p class="source-code">    public function start()</p><p class="source-code">    {</p><p class="source-code">        if($this-&gt;hasKeyinIgnition) </p><p class="source-code">        {</p><p class="source-code">            $this-&gt;engineStatus = true;</p><p class="source-code">        }</p><p class="source-code">    }</p><p>As you can see, <strong class="source-inline">Car</strong> checks that the key is in the ignition to turn on the engine. We need to make sure that the engine start involves checking for the key. In other words, we won't allow the overriding of this engine start procedure. Hence, we need to lock any possible overriding via derivation by using the <strong class="source-inline">final</strong> keyword before the access modifier of the <strong class="source-inline">start()</strong> method.</p></li>
				<li>Add the <strong class="source-inline">final</strong> keyword before the <strong class="source-inline">start()</strong> method as follows:<p class="source-code">    final public function start()</p><p class="source-code">    {</p><p class="source-code">        if($this-&gt;hasKeyinIgnition) </p><p class="source-code">        {</p><p class="source-code">            $this-&gt;engineStatus = true;</p><p class="source-code">        }</p><p class="source-code">    }</p><p>Here, the <strong class="source-inline">start()</strong> method has been finalized and no override should be allowed.</p></li>
				<li>Create a new <strong class="source-inline">Car</strong> subclass, <strong class="source-inline">Van</strong>, in a PHP file, <strong class="source-inline">Van.php</strong>, with the following content:<p class="source-code">&lt;?php</p><p class="source-code">require_once 'Car.php';</p><p class="source-code">class Van extends Car </p><p class="source-code">{</p><p class="source-code">}</p><p>Here, <strong class="source-inline">Van</strong> is an offspring of the <strong class="source-inline">Car</strong> class and is ready to override any methods acquired from the parent.</p></li>
				<li>Let's try overriding the final method, <strong class="source-inline">start()</strong>, declared by the <strong class="source-inline">Car</strong> class:<p class="source-code">class Van extends Car </p><p class="source-code">{</p><p class="source-code">    public function start()</p><p class="source-code">    {</p><p class="source-code">        $this-&gt;engineStatus = true;</p><p class="source-code">    }</p><p class="source-code">}</p><p>Here, the <strong class="source-inline">Van</strong> class overrides the <strong class="source-inline">Car</strong> class' engine <strong class="source-inline">start()</strong> method, which is not permissible from the <strong class="source-inline">Car</strong> class.</p></li>
				<li>If we run <strong class="source-inline">Van.php</strong> using the <strong class="source-inline">php –d display_errors=on Van.php</strong> command, we should see the following fatal error:<div class="IMG---Figure" id="_idContainer121"><img alt="Figure 5.24: The Van subclass attempts to override the Car engine start method&#13;&#10;" src="image/C14196_05_24.jpg"/></div><p class="figure-caption">Figure 5.24: The Van subclass attempts to override the Car engine start method</p><p>The override failed at the <strong class="source-inline">Van</strong> subclass. When we need to secure our methods from communicating with an object, we need to finalize those methods. </p></li>
				<li>Now, let's say we don't need further derivation of the <strong class="source-inline">Car</strong> class and we have finalized the <strong class="source-inline">Car</strong> class, as follows, by adding the <strong class="source-inline">final</strong> keyword before the <strong class="source-inline">Car</strong> class keyword:<p class="source-code">final class Car extends AbstractVehicle implements DriveInterface </p><p class="source-code">{</p><p class="source-code">}</p></li>
				<li>Again, if we run <strong class="source-inline">Van.php</strong> using the <strong class="source-inline">php –d display_errors=on Van.php</strong> command, we should see the following fatal error:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer122">
					<img alt="Figure 5.25: The Van subclass attempts to extend the Car class&#13;&#10;" src="image/C14196_05_25.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.25: The Van subclass attempts to extend the Car class</p>
			<p>This is how the <strong class="source-inline">final</strong> keyword can be used to prevent method overriding and class extending. In practice, methods that should not be overridden anyhow should be finalized and classes that should not be extendable should be finalized. </p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor209"/>Traits</h1>
			<p>In a single inheritance language such as PHP, we often feel that we could have extended another class to inherit some functionalities. For example, in our <strong class="source-inline">Car</strong> class, we have inherited all the generic vehicle functionalities and now we might be in need of adding some e-commerce functionalities. Again, the <strong class="source-inline">Motorcycle</strong> class might want to have such e-commerce functionalities. As e-commerce related methods do not belong to the <strong class="source-inline">Vehicle</strong> class, we need to think of an alternative approach to reuse such e-commerce behavior. Hence, when we need to add a group of behaviors to our objects, we group the behaviors in terms of methods with a <strong class="source-inline">trait</strong> and use the <strong class="source-inline">trait</strong> inside our classes. A trait is similar to a class but you can't instantiate it; rather, you can use traits inside classes. A trait can be used in a class context with the <strong class="source-inline">use</strong> keyword; for example, <strong class="source-inline">use TraitName</strong>. </p>
			<p>Check out the following <strong class="source-inline">trait</strong> syntax:</p>
			<p class="source-code">trait MyTraitName{</p>
			<p class="source-code">    function one()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        …</p>
			<p class="source-code">    }</p>
			<p class="source-code">    function two()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        …</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">class MyClass extends B{</p>
			<p class="source-code">    use MyTraitName;</p>
			<p class="source-code">}</p>
			<p class="source-code">$object = new MyClass();</p>
			<p class="source-code">$object-&gt;one();</p>
			<p class="source-code">$object-&gt;two();</p>
			<p>Here, the <strong class="source-inline">MyTraitName</strong> trait helps to group multiple methods, <strong class="source-inline">one()</strong> and <strong class="source-inline">two()</strong>, and to reuse these methods, we can use the trait using <strong class="source-inline">MyTraitName;</strong>. Hence, the trait methods become available to <strong class="source-inline">MyClass{…}</strong> and can be called using the <strong class="source-inline">MyClass{…}</strong> object handler, as in the preceding code.</p>
			<p>You can use multiple traits as follows:</p>
			<p class="source-code">class MyClass extends B</p>
			<p class="source-code">{</p>
			<p class="source-code">    use Trait1, Trait2;</p>
			<p class="source-code">}</p>
			<p>Again, the member inserted by a trait overrides an inherited member. Let's check out the following example:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">class A{</p>
			<p class="source-code">    public function say()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        echo 'Base ';</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">trait T{</p>
			<p class="source-code">    public function say() </p>
			<p class="source-code">    {</p>
			<p class="source-code">        parent::say();</p>
			<p class="source-code">        echo 'Trait ';</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">class MyClass extends A{</p>
			<p class="source-code">    use T;</p>
			<p class="source-code">}</p>
			<p class="source-code">$object = new MyClass();</p>
			<p class="source-code">$object-&gt;say(); //outputs, Base Trait</p>
			<p>Here, <strong class="source-inline">MyClass</strong> extends class <strong class="source-inline">A</strong>, which has a method named <strong class="source-inline">say()</strong>, since <strong class="source-inline">MyClass</strong> avails the trait method <strong class="source-inline">say()</strong>. Then, we can consider the <strong class="source-inline">MyClass</strong> member <strong class="source-inline">say()</strong> as overriding the <strong class="source-inline">say()</strong> parent. In order to call the original parent method, <strong class="source-inline">say()</strong>, the trait supports <strong class="source-inline">parent::</strong> to access the parent's methods. Trait is all about delivering methods to your class that are assumed to be a useful part of your class. </p>
			<p>Current class members can override the members added by traits. Again, if we extend the preceding example, we can derive the following example:</p>
			<p class="source-code-heading">MyClass.php</p>
			<p class="source-code">1  &lt;?php</p>
			<p class="source-code">2  class A </p>
			<p class="source-code">3  {</p>
			<p class="source-code">4      public function say() </p>
			<p class="source-code">5      {</p>
			<p class="source-code">6          echo 'Base ';</p>
			<p class="source-code">7      }</p>
			<p class="source-code">8  }</p>
			<p class="source-code">9  trait T  </p>
			<p class="source-code">10 {</p>
			<p class="source-code">11     public function say() </p>
			<p class="source-code">12     {</p>
			<p class="source-code">13         parent::say();</p>
			<p class="source-code">14         echo 'Trait ';</p>
			<p class="source-code">15     }</p>
			<p class="source-code-link"><a href="https://packt.live/2M56lcA">https://packt.live/2M56lcA</a></p>
			<p>Notice that the <strong class="source-inline">say()</strong> method gets overridden according to the sequence. Trait methods override inherited methods and class members override trait methods. Hence, <strong class="source-inline">say()</strong> from parent class <strong class="source-inline">A</strong> gets overridden by the <strong class="source-inline">say()</strong> method of trait <strong class="source-inline">T</strong>, and then, finally, <strong class="source-inline">say()</strong> in <strong class="source-inline">MyClass</strong> overrides the trait's <strong class="source-inline">say()</strong> method.</p>
			<p>A trait is a way of adding functionalities and additions to inheritance. A trait enables you to add more features horizontally without the need to inherit another class. </p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor210"/>Exercise 5.11: Implementing Trait</h2>
			<p>In this exercise, we will create a new trait named <strong class="source-inline">PriceTrait</strong> and shift the price setter and getter methods from the <strong class="source-inline">AbstractVehicle</strong> class to this trait. Since price-related methods should not belong to core vehicle features but to e-commerce features, we will add all sorts of price methods into the new price-related trait. The whole idea of shifting price-related methods into <strong class="source-inline">PriceTrait</strong> is to conceptualize how traits should come into the scenario and group logically related methods under a name. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">As per the PSR naming conventions, the Trait name must be suffixed by Trait; for example, <strong class="source-inline">TestTrait</strong> (<a href="https://packt.live/2IEkR9k">https://packt.live/2IEkR9k</a>).</p>
			<ol>
				<li value="1">Open <strong class="source-inline">AbstractVehicle.php</strong> and locate the <strong class="source-inline">getPrice()</strong> and <strong class="source-inline">setPrice()</strong> methods.</li>
				<li>Create a new PHP file called <strong class="source-inline">PriceTrait.php</strong> with the following trait:<p class="source-code">&lt;?php</p><p class="source-code">trait PriceTrait</p><p class="source-code">{</p><p class="source-code">}</p></li>
				<li>Cut the <strong class="source-inline">getPrice()</strong> and <strong class="source-inline">setPrice()</strong> methods from the <strong class="source-inline">Vehicle</strong> class and paste them into the <strong class="source-inline">PriceTrait</strong> trait as follows:<p class="source-code">&lt;?php</p><p class="source-code">trait PriceTrait  </p><p class="source-code">{</p><p class="source-code">    public function getPrice()</p><p class="source-code">    {</p><p class="source-code">        return $this-&gt;price;</p><p class="source-code">    }</p><p class="source-code">    public function setPrice($price)</p><p class="source-code">    {</p><p class="source-code">        $this-&gt;price = $price;</p><p class="source-code">    }</p><p class="source-code">}</p><p>Here, we have added the <strong class="source-inline">PriceTrait</strong> body with the <strong class="source-inline">getPrice()</strong> and <strong class="source-inline">setPrice()</strong> methods shifted from the <strong class="source-inline">AbstractVehicle</strong> class. Note that the methods still contain the original lines that use <strong class="source-inline">$this</strong> (the object instance variable), though, traits cannot be instantiated, meaning that these methods are intended to be accessed by the objects of classes that are going to use <strong class="source-inline">PriceTrait</strong>.</p></li>
				<li>Now we need to require the <strong class="source-inline">PriceTrait.php</strong> file in the <strong class="source-inline">AbstractVehicle</strong> class, as follows, so that the <strong class="source-inline">AbstractVehicle</strong> class can use the trait:<p class="source-code">&lt;?php</p><p class="source-code">require_once 'PriceTrait.php';</p><p class="source-code">    abstract class AbstractVehicle </p><p class="source-code">    {</p><p class="source-code">        //code goes here</p><p class="source-code">    }</p></li>
				<li>Use <strong class="source-inline">PriceTrait</strong> from the <strong class="source-inline">Vehicle</strong> class, as follows:<p class="source-code">&lt;?php</p><p class="source-code">require_once 'PriceTrait.php';</p><p class="source-code">abstract class AbstractVehicle </p><p class="source-code">{</p><p class="source-code">        use PriceTrait;</p><p class="source-code">        public $make;</p><p class="source-code">        public $model;</p><p class="source-code">        public $color;</p><p class="source-code">        protected $noOfWheels; </p><p class="source-code">        private $engineNumber;</p><p class="source-code">        public static $counter = 0;</p><p class="source-code">        protected $engineStatus = false;</p><p class="source-code">        protected $price;</p><p class="source-code">        ...</p><p>Here, in the line <strong class="source-inline">use PriceTrait</strong>, the <strong class="source-inline">AbstractVehicle</strong> class acquired the <strong class="source-inline">PriceTrait</strong> trait that comes with two methods for price set and get. Hence, the <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong> classes inherited these two methods, which was our intention, to add features horizontally like this. Note that we have kept the <strong class="source-inline">$price</strong> attribute intact at the <strong class="source-inline">AbstractVehicle</strong> class to access it via the setter and getter of the derived vehicles. </p></li>
				<li>There are no changes in the <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong> subclasses as they should avail the trait methods automatically. As the parent <strong class="source-inline">Vehicle</strong> class uses <strong class="source-inline">PriceTrait</strong>, the trait methods become members of the <strong class="source-inline">Vehicle</strong> class and the subclasses can override such inherited methods. The <strong class="source-inline">Car</strong> class doesn't override price methods but the <strong class="source-inline">Motorcycle</strong> class overrides the <strong class="source-inline">getPrice()</strong> method to apply a 5% discount to the given price. Locate the <strong class="source-inline">getPrice()</strong> method in the <strong class="source-inline">Motorcycle</strong> class:<p class="source-code">    function getPrice()</p><p class="source-code">    {</p><p class="source-code">        return $this-&gt;price - $this-&gt;price * 0.05;</p><p class="source-code">    }</p><p>Here, after trait, such an override works for the subclass and no change should be required here.</p></li>
				<li>In order to test the discounted price, we should instantiate the <strong class="source-inline">Motorcycle</strong> class, set the price, and get the price to see whether a discount has been applied or not, which was previously done in <strong class="source-inline">Motorcycle.php</strong>. Locate the following content in the <strong class="source-inline">Motorcycle.php</strong> file:<p class="source-code">$motorcycle = new Motorcycle('Kawasaki', 'Ninja', 'Orange', 2,   '53WVC14598');</p><p class="source-code">$motorcycle-&gt;setPrice(5000);</p><p class="source-code">echo "The price is  ". $motorcycle-&gt;getPrice() . PHP_EOL;</p></li>
				<li>Now, if we run <strong class="source-inline">Motorcycle.php</strong> with the <strong class="source-inline">php Motorcycle.php</strong> command, the preceding code outputs the following:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer123">
					<img alt="Figure 5.26: The trait method overridden by Motorcycle&#13;&#10;" src="image/C14196_05_26.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.26: The trait method overridden by Motorcycle</p>
			<p>Therefore, traits can be used to add member methods of a class, can override any existing member methods of the same name, and can be overridden via inheritance. Alternatively, we could have used <strong class="source-inline">PriceTrait</strong> in the <strong class="source-inline">Car</strong> and <strong class="source-inline">Motorcycle</strong> classes directly instead of the <strong class="source-inline">Vehicle</strong> class by adding the trait in them. Our intention is to share the common characteristics of vehicles via the parent <strong class="source-inline">Vehicle</strong> class, that's why we have used the trait in the mother class.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor211"/>Class Autoloading</h2>
			<p>You may skip this section if you choose to use Composer. Consider class auto loading for legacy PHP projects who can't use Composer. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">With the addition of PHP's package manager, Composer, you can leverage Composer's autoloader to load classes, libraries, and so on. See <a href="https://packt.live/2MrJG9u">https://packt.live/2MrJG9u</a> for more details. <em class="italic">Chapter 9</em>, <em class="italic">Composer</em> is dedicated to discussing <strong class="bold">Composer</strong> and <strong class="bold">Autoloading</strong> in detail.</p>
			<p>To use a class inside a file that is located in another file, we have to include the corresponding file that contains the class in the current file. This approach ends up including a good number of files in any PHP script. Hence, we need something that automatically includes our required class files.</p>
			<p>In order to load your class automatically, PHP comes with the <strong class="source-inline">spl_autoload_register()</strong> function. With that function, we can register any number of autoloaders so that we can load classes and interfaces on demand. Yes – on-demand. That means the autoloading is lazy – it loads the classes or interfaces only when they are called.</p>
			<p>Check out the following simple code snippet:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">spl_autoload_register(function ($className) </p>
			<p class="source-code">{</p>
			<p class="source-code">    require_once $className. '.php';</p>
			<p class="source-code">});</p>
			<p class="source-code">$obj1= new ClassName1();</p>
			<p class="source-code">$obj2 = new ClassName2(); </p>
			<p>Preceding snippet is equivalent to the following:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">require_once 'ClassName1.php';</p>
			<p class="source-code">require_once 'ClassName2.php';</p>
			<p class="source-code">     </p>
			<p class="source-code">$obj1  = new ClassName1();</p>
			<p class="source-code">$obj2 = new ClassName2(); </p>
			<p>So, in the preceding code snippet, you can see that we have passed an anonymous PHP function to the <strong class="source-inline">spl_autoload_register()</strong> function. This anonymous function accepts the class or interface name and tries to include/require the corresponding file. With the <strong class="source-inline">spl_autoload_register</strong> function, we can register our own such autoloader functions and we can do all sorts of operations to load the file, such as setting the file path/directory, checking whether the file exists or not, throwing an exception, and so on. Hence, we can avoid a larger list of file inclusion statements.</p>
			<p>Say, for <strong class="source-inline">Car.php</strong> and <strong class="source-inline">Motorcycle.php</strong>, we can just replace the following two lines with the <strong class="source-inline">spl_autoload_register()</strong> function:</p>
			<p class="source-code">require_once 'AbstractVehicle.php';</p>
			<p class="source-code">require_once 'DriveInterface.php';</p>
			<p>The preceding snippet can be replaced with the following:</p>
			<p class="source-code">spl_autoload_register(function ($className) </p>
			<p class="source-code">{</p>
			<p class="source-code">    require_once $className. '.php';</p>
			<p class="source-code">});</p>
			<p>So, like the following, when the <strong class="source-inline">Car</strong> class extends the <strong class="source-inline">AbstractVehicle</strong> class and implements the <strong class="source-inline">DriveInterface</strong> interface, the autoloader is invoked to load the corresponding class file and interface file:</p>
			<p class="source-code">class Car extends AbstractVehicle implements DriveInterface </p>
			<p class="source-code">{</p>
			<p class="source-code">...</p>
			<p class="source-code">}</p>
			<p>Here, the registered autoloader is invoked to load the file when the class or interface has been used. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">To autoload PSR-4 classes, follow the guidelines at <a href="https://packt.live/314fBCj">https://packt.live/314fBCj</a>.</p>
			<p>The <strong class="source-inline">spl_autoload_register()</strong> function specification can be found at <a href="https://packt.live/2B1PLEu">https://packt.live/2B1PLEu</a>.</p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor212"/>Namespaces</h1>
			<p>As the name suggests, a namespace provides naming and scoping, therefore, a namespace is another way of encapsulating items. We can call a named scope, a namespace can house related constants, functions, classes, abstract classes, traits, and interfaces in a group with a name, and they can be accessed using the name. </p>
			<p>As an analogy, consider the naming of people. People are given unique names in a family in order to identify them and call them by. Beyond family, what if there are two people with the same name? There could be one John Doe in the computer science department and another John Doe in the electrical department. Coincidentally, they end up in the varsity's football team, so they can be called John Doe of computer science and John Doe of the electrical department. Surely, the team doesn't want to pass the football to the wrong John Doe.</p>
			<p>The same goes for computer filesystems: there are directories and subdirectories. Inside a directory, there could be other directories and there can't be two directories with the same name. Again, files with the same name can exist in two different directories; for example, <strong class="source-inline">/usr/home/readme.md</strong> and <strong class="source-inline">/var/projects/readme.md</strong>. </p>
			<p>In programming, a namespace solves problems such as name collisions where classes or libraries have the same name so that they can be utilized under a different name. Surely, we don't want to write a class that pollutes the global scope by conflicting with another class's name. Also, the namespace provides aliasing – we can shorten a long name, so that code readability improves.</p>
			<p>PHP supports the namespace with the <strong class="source-inline">namespace</strong> keyword, as follows:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace MyNamespace;</p>
			<p class="source-code">const MYCONST = 'constant';</p>
			<p class="source-code">function myFunction()</p>
			<p class="source-code">{</p>
			<p class="source-code">...</p>
			<p class="source-code">}</p>
			<p class="source-code">class MyClass</p>
			<p class="source-code">{</p>
			<p class="source-code">...</p>
			<p class="source-code">}</p>
			<p class="source-code">echo MyNamespace\MYCONST;</p>
			<p class="source-code">echo myFunction(); //resolves to MyNamespace\myFunction</p>
			<p class="source-code">echo MyNamespace\myFunction();//explicitly resolves to MyNamespace\myFunction    </p>
			<p class="source-code">$object = new MyNamespace\MyClass();</p>
			<p>The namespace should be the first statement you declare in your script. Although, you can write code without using a namespace. </p>
			<p>If we don't define a namespace, our code stays in the global namespace. That's why the global namespace can be easily polluted by producing name collisions.</p>
			<p>Alternative syntax for declaring a namespace is as follows:</p>
			<p class="source-code">namespace MyNamespace</p>
			<p class="source-code">{</p>
			<p class="source-code">    ...</p>
			<p class="source-code">}</p>
			<p>We can declare multiple namespaces within a single file as follows:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace MyNamespaceA;</p>
			<p class="source-code">class MyClass</p>
			<p class="source-code">{</p>
			<p class="source-code">...</p>
			<p class="source-code">}</p>
			<p class="source-code">namespace MyNamespaceB;</p>
			<p class="source-code">class MyClass</p>
			<p class="source-code">{</p>
			<p class="source-code">...</p>
			<p class="source-code">}</p>
			<p class="source-code">$object1 = new MyNamespaceA\MyClass();</p>
			<p class="source-code">$object2 = new MyNamespaceB\MyClass();</p>
			<p>It is strongly discouraged to put multiple namespaces into the same file in order to promote good coding practices. A general use case for an example of having multiple namespaces in the same file is including multiple PHP files in the same file.</p>
			<p>You can also declare subnamespaces to achieve a hierarchy of namespaces, as follows:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace MyNamespace\SubNamespace;</p>
			<p class="source-code">const MYCONST = 'constant';</p>
			<p class="source-code">function myFunction()</p>
			<p class="source-code">{</p>
			<p class="source-code">...</p>
			<p class="source-code">}</p>
			<p class="source-code">class MyClass</p>
			<p class="source-code">{</p>
			<p class="source-code">...</p>
			<p class="source-code">}</p>
			<p class="source-code">echo \MyNamespace\SubNamespace\MYCONST;</p>
			<p class="source-code">echo \MyNamespace\SubNamespace\myFunction();</p>
			<p class="source-code">$object = new \MyNamespace\SubNamespace\MyClass();</p>
			<p>We can import a namespace using the <strong class="source-inline">use</strong> keyword and, optionally, we can alias the namespace with the <strong class="source-inline">as</strong> keyword as follows:</p>
			<p class="source-code">//file1.php</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace MyNamespaceA;</p>
			<p class="source-code">const MYCONST = 'constant';</p>
			<p class="source-code">function myFunction()</p>
			<p class="source-code">{</p>
			<p class="source-code">...</p>
			<p class="source-code">}</p>
			<p class="source-code">class MyClass</p>
			<p class="source-code">{</p>
			<p class="source-code">...</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">file2.php</strong> will be as follows:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace MyNamespaceB;</p>
			<p class="source-code">require_once 'file1.php';</p>
			<p class="source-code">use MyNamespaceA\MyClass as A; //imports the class name</p>
			<p class="source-code">$object = new A();//instantiates the object of class MyNamespaceA\MyClass</p>
			<p class="source-code">use function MyNamespaceA\myFunction;//importing a function</p>
			<p class="source-code">myFunction();//calls MyNamespaceA\myFunction</p>
			<p class="source-code">use function MyNamespaceA\myFunction as func;//aliasing a function</p>
			<p class="source-code">func();//calls MyNamespaceA\myFunction</p>
			<p class="source-code">use const MyNamespaceA\MYCONST; //imports a constant</p>
			<p class="source-code">echo MYCONST;//prints the value of MyNamespaceA\MYCONST</p>
			<p>Here, at the <strong class="source-inline">use MyNamespaceA\MyClass as A;</strong> line, <strong class="source-inline">MyClass</strong> and <strong class="source-inline">MyNamespaceA</strong> are imported inside <strong class="source-inline">MyNamespaceB</strong> and, while importing, we aliased the class name to <strong class="source-inline">A</strong> so that we can instantiate the <strong class="source-inline">MyClass</strong> class as class <strong class="source-inline">A</strong> with <strong class="source-inline">$object = new A();</strong>. </p>
			<p>The same goes for other imports. We can import a function from another namespace, such as using the <strong class="source-inline">MyNamespaceA\myFunction;</strong> function and alias it by using the <strong class="source-inline">MyNamespaceA\myFunction as func;</strong> function.</p>
			<p>That way, we can call the function using the <strong class="source-inline">func()</strong> alias name. Also, we can do the same while importing constants. With the <strong class="source-inline">use const MyNamespaceA\MYCONST;</strong> line, we have imported the constant.</p>
			<p>Combining multiple importing is also possible:</p>
			<p class="source-code">//file2.php</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace MyNamespaceB;</p>
			<p class="source-code">require_once 'file1.php';</p>
			<p class="source-code">use MyNamespaceA\MyClass as A, MyNamespaceA\myFunction; </p>
			<p class="source-code">$object = new A();//instantiates the object of class MyNamespaceA\MyClass</p>
			<p class="source-code">myFunction();//calls MyNamespaceA\myFunction</p>
			<p>Here, we have imported a class and a method together in the <strong class="source-inline">use MyNamespaceA\MyClass as A, MyNamespaceA\myFunction;</strong> line and aliased the class name as <strong class="source-inline">A</strong>. Normally, bringing in the necessary classes or functions from a namespace is the purpose of such importing instead of importing the whole namespace.</p>
			<p>PHP namespaces have so much to offer and there are more use cases and aspects that can be learned at <a href="https://packt.live/2AYilqj">https://packt.live/2AYilqj</a>.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor213"/>Exercise 5.12: Implementing Namespaces</h2>
			<p>In this exercise, we will apply namespaces to our vehicle-related classes, traits, and interfaces. We will apply a common namespace to the <strong class="source-inline">AbstractVehicle</strong> class, <strong class="source-inline">DriveInterface</strong>, <strong class="source-inline">Car</strong>, and <strong class="source-inline">Motorcycle</strong> classes. Also, for the traits, we will apply a different namespace so that we can keep the traits out of the common namespace:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">Vehicle</strong> directory to relocate <strong class="source-inline">AbstractVehicle.php</strong> and <strong class="source-inline">DriveInterface.php</strong> in it.</li>
				<li>Relocate <strong class="source-inline">AbstractVehicle.php</strong> and <strong class="source-inline">DriveInterface.php</strong> in the vehicle subdirectory, under your current working directory.</li>
				<li>Create another directory, <strong class="source-inline">Traits</strong>, for relocating the <strong class="source-inline">PriceTrait.php</strong> file and future traits.<p>The directory structure looks like the following:</p><div class="IMG---Figure" id="_idContainer124"><img alt="Fig 5.27: Namespaced directory structure&#13;&#10;" src="image/C14196_05_27.jpg"/></div><p class="figure-caption">Fig 5.27: Namespaced directory structure</p></li>
				<li>Now it's time to apply namespaces to our classes and traits. Open the <strong class="source-inline">PriceTrait.php</strong> file and add the <strong class="source-inline">Traits</strong> namespace at the beginning, as follows:<p class="source-code">&lt;?php</p><p class="source-code">namespace Traits;</p><p class="source-code">trait PriceTrait  </p><p class="source-code">{</p><p class="source-code">    …<a id="_idTextAnchor214"/> </p><p class="source-code">}</p><p>Here, we have declared the <strong class="source-inline">Traits</strong> namespace at the beginning of <strong class="source-inline">PriceTrait</strong>. Our intention is to add different trait files in future, under the same namespace; for example, <strong class="source-inline">namespace Traits</strong> (at the beginning of any new trait files). The whole idea is to apply the <strong class="source-inline">Traits</strong> namespace across multiple trait files so that we can pick the right trait via the namespace. Hence, we can use <strong class="source-inline">PriceTrait</strong> like we use <strong class="source-inline">\Traits\PriceTrait</strong> in different classes.</p></li>
				<li>Open the <strong class="source-inline">AbstractVehicle.php</strong> file and remove the following line:<p class="source-code">require_once 'PriceTrait.php'; </p><p>Since we are going to autoload the classes and trait files, we don't need to manually require files.</p></li>
				<li>Add the following namespace before the <strong class="source-inline">AbstractVehicle</strong> class:<p class="source-code">namespace Vehicle;</p><p>Here, the <strong class="source-inline">Vehicle</strong> namespace will be our common namespace to share across vehicle subclasses and interfaces.</p></li>
				<li>Update the <strong class="source-inline">use PriceTrait</strong> using the namespace, as follows:<p class="source-code">&lt;?php</p><p class="source-code">namespace Vehicle;</p><p class="source-code">    abstract class AbstractVehicle </p><p class="source-code">    {</p><p class="source-code">        use \Traits\PriceTrait;</p><p class="source-code">        …</p><p class="source-code">    }</p><p>Here, the <strong class="source-inline">use \Traits\PriceTrait;</strong> line tells the autoloader to load <strong class="source-inline">PriceTrait</strong> from the <strong class="source-inline">Traits</strong> directory located in your code base root.</p></li>
				<li>Add the <strong class="source-inline">Vehicle</strong> namespace before the <strong class="source-inline">DriveInterface</strong> interface, as follows:<p class="source-code">&lt;?php</p><p class="source-code">namespace Vehicle;</p><p class="source-code">interface DriveInterface </p><p class="source-code">{</p><p class="source-code">    …</p><p class="source-code">}</p><p>Here, <strong class="source-inline">DriveInterface</strong> shares the <strong class="source-inline">Vehicle</strong> namespace, so the interface is accessible via the same namespace.</p></li>
				<li>Open the <strong class="source-inline">Car.php</strong> file to eliminate the following manual file inclusion:<p class="source-code">require_once 'AbstractVehicle.php'; </p><p class="source-code">require_once 'DriveInterface.php';</p><p>Replace the <strong class="source-inline">Vehicle</strong> namespace with the following:</p><p class="source-code">&lt;?php</p><p class="source-code">namespace Vehicle;</p><p class="source-code">class Car extends AbstractVehicle implements DriveInterface </p><p class="source-code">{</p><p class="source-code">    …</p><p class="source-code">}</p><p>Here, <strong class="source-inline">Car</strong> shares the same namespace, <strong class="source-inline">Vehicle</strong>. So, in the class line, <strong class="source-inline">Car</strong> extends <strong class="source-inline">AbstractVehicle</strong> and implements <strong class="source-inline">DriveInterface</strong>, <strong class="source-inline">AbstractVehicle</strong>, and <strong class="source-inline">DriveInterface</strong> to resolve the current namespace, which is <strong class="source-inline">Vehicle</strong>. This is similar to the <strong class="source-inline">Car</strong> class extending to <strong class="source-inline">Vehicle\AbstractVehicle</strong> and implementing <strong class="source-inline">Vehicle\DriveInterface</strong>. </p></li>
				<li>Now, add the <strong class="source-inline">spl_autoload_register()</strong> function before the <strong class="source-inline">Car</strong> class as follows:<p class="source-code">&lt;?php</p><p class="source-code">namespace Vehicle;</p><p class="source-code">spl_autoload_register();</p><p class="source-code">class Car extends AbstractVehicle implements DriveInterface </p><p class="source-code">{</p><p class="source-code">    …</p><p class="source-code">}</p><p>Hence, the autoloader function should load the <strong class="source-inline">AbstractVehicle</strong> class and the <strong class="source-inline">DriveInterface</strong> interface from the <strong class="source-inline">Vehicle</strong> directory as it supports class loading from a namespaced directory.</p></li>
				<li>Do the same for the <strong class="source-inline">Motorcycle.php</strong>, as follows:<p class="source-code">&lt;?php</p><p class="source-code">namespace Vehicle;</p><p class="source-code">spl_autoload_register();</p><p class="source-code">class Motorcycle extends AbstractVehicle implements DriveInterface </p><p class="source-code">{</p><p class="source-code">    …</p><p class="source-code">}</p><p>Here, the <strong class="source-inline">Motorcycle</strong> class also shares the same namespace, <strong class="source-inline">Vehicle</strong>, to avail <strong class="source-inline">AbstractVehicle</strong> and <strong class="source-inline">DriveInterface</strong>.</p></li>
				<li>At <strong class="source-inline">Car.php</strong>, add the following <strong class="source-inline">Car</strong> instance to test the <strong class="source-inline">AbstractVehicle</strong> and <strong class="source-inline">DriveInterface</strong> implementation:<p class="source-code">$car = new Car('Honda', 'Civic', 'Red', 4, '23CJ4567');</p><p class="source-code">$car-&gt;start();</p><p class="source-code">echo "The car is " . ($car-&gt;getEngineStatus()?'running':'stopped') .   PHP_EOL;</p><p class="source-code">$car-&gt;changeGear(1);</p><p class="source-code">$car-&gt;changeSpeed(15);</p><p class="source-code">$car-&gt;changeGear(2);</p><p class="source-code">$car-&gt;changeSpeed(35);</p><p class="source-code">$car-&gt;applyBreak();</p><p class="source-code">$car-&gt;stop();</p><p class="source-code">echo "The car is " . ($car-&gt;getEngineStatus()?'running':'stopped')  .   PHP_EOL;</p><p>Here, just to test the extended class and the implemented interface, we have instantiated the <strong class="source-inline">Car</strong> class and accessed different member methods using the object handler. </p></li>
				<li>The preceding code will produce the following output if we run the <strong class="source-inline">Car.php</strong> script with the <strong class="source-inline">php Car.php</strong> command:<div class="IMG---Figure" id="_idContainer125"><img alt="Fig 5.28: Namespace applied to Car&#13;&#10;" src="image/C14196_05_28.jpg"/></div><p class="figure-caption">Fig 5.28: Namespace applied to Car</p><p>We can see that the <strong class="source-inline">Car</strong> class can access the namespace applied to the abstract class and the interface.</p></li>
				<li>Now, to <strong class="source-inline">Motorcycle.php</strong>, add the following <strong class="source-inline">Motorcycle</strong> instance to test the <strong class="source-inline">AbstractVehicle</strong> and <strong class="source-inline">DriveInterface</strong> implementation:<p class="source-code">$motorcycle = new Motorcycle('Kawasaki', 'Ninja', 'Orange', 2,   '53WVC14598');</p><p class="source-code">$motorcycle-&gt;start();</p><p class="source-code">echo "The motorcycle is " . ($motorcycle-&gt;getEngineStatus()?'running':  'stopped') . PHP_EOL;</p><p class="source-code">$motorcycle-&gt;changeGear(3);</p><p class="source-code">$motorcycle-&gt;changeSpeed(35);</p><p class="source-code">$motorcycle-&gt;applyBreak();</p><p class="source-code">$motorcycle-&gt;stop();</p><p class="source-code">echo "The motorcycle is " . ($motorcycle-&gt;getEngineStatus()?'running':'stopped') . PHP_EOL;</p><p class="source-code">$motorcycle-&gt;setPrice(5000);</p><p class="source-code">echo "The price is ". $motorcycle-&gt;getPrice() . PHP_EOL;</p></li>
				<li>The preceding code will produce the following output if we run the <strong class="source-inline">Motorcycle.php</strong> script with the <strong class="source-inline">php Motorcycle.php</strong> command:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer126">
					<img alt="Fig 5.29: Namespace applied to Motorcycle&#13;&#10;" src="image/C14196_05_29.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Fig 5.29: Namespace applied to Motorcycle</p>
			<p>In the preceding exercise, we saw that the <strong class="source-inline">Vehicle</strong> namespace encapsulated all the relevant items, such as the abstract class, the interface, and the subclasses. Thus, a namespace can be shared across multiple files among relevant code components. Also, we can subnamespace internal libraries, plugins, utility files, and so on. The idea of the namespace is to assemble your project under a unique and relevant name so that none of your code components conflict when you integrate third-party code components.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor215"/>Activity 5.1: Building a Student and Professor Object Relationship</h2>
			<p>In this activity, we will implement OOP concepts to create <strong class="source-inline">Student</strong> and <strong class="source-inline">Professor</strong> classes with parameterized constructors, attributes, and member methods. We will instantiate both classes and establish a relationship between the objects. A professor might have a certain number of students enrolled in their class. The list of students should be printed using a member method of the <strong class="source-inline">Professor</strong> object.</p>
			<p>The steps to be performed are as follows:</p>
			<ol>
				<li value="1">Create a directory named <strong class="source-inline">activity1</strong> to put all our activity content in it. This should be our working directory (you can <strong class="source-inline">cd</strong> to the directory). </li>
				<li>Create a script file called <strong class="source-inline">activity-classes.php</strong>.</li>
				<li>Create <strong class="source-inline">Professor</strong> and <strong class="source-inline">Student</strong> classes in separate directories with the following functionalities.<p>Both use their own namespacing to load the classes automatically.</p><p>Both take the name as the first argument in the constructor; the <strong class="source-inline">Professor</strong> class accepts the second argument as a list of students – the list will be filtered for instances of <strong class="source-inline">Student</strong> only.</p><p>Both will have the title property, which, by default, for the <strong class="source-inline">Professor</strong> class is <strong class="source-inline">Prof.</strong> and for the <strong class="source-inline">Student</strong> class is <strong class="source-inline">student</strong>. </p></li>
				<li>Create a function that will print the Professor's title, name, the student count, and the list of students.</li>
				<li>Create a <strong class="source-inline">Professor</strong> instance, providing a name and a list of students – instances of <strong class="source-inline">Student</strong> with a name in the constructor.</li>
				<li>Add a random amount of <strong class="source-inline">Student</strong> instances to the <strong class="source-inline">Professor</strong> instance.</li>
				<li>Change the title of the professor to <strong class="source-inline">Dr.</strong>.</li>
				<li>Print the output by invoking the function with the <strong class="source-inline">Professor</strong> instance.</li>
			</ol>
			<p>The output should look like the following:</p>
			<p class="source-code">Dr. Charles Kingsfield's students (4):</p>
			<p class="source-code">  1. Elwin Ransom</p>
			<p class="source-code">  2. Maurice Phipps</p>
			<p class="source-code">  3. James Dunworthy</p>
			<p class="source-code">  4. Alecto Carrow</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 515.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor216"/>Summary </h1>
			<p>In this chapter, we worked with object-oriented concepts and took note of how each of those concepts fitted into different scenarios. Encapsulation, inheritance, polymorphism, data abstraction, dynamic binding, and message passing all added new dimensions to our program. Note that these concepts can be adopted when they fit your particular scenario; until then, there's no need to complicate the program. We have seen that the misuse of OOP principles is common, and, down the road, that adds a burden of complexity. </p>
			<p>Dependencies should be injected from outside rather than being hardcoded inside. Abstractions should not depend on details; hide your data appropriately, hide your complexities, and expose simplicity when message passing. Overall, the mapping of the objects in your program with the problem domain should be taken care of. Remember this simple statement: "If you can't reuse it, then it doesn't possess value."</p>
			<p>In the next chapter, we will describe request handling, storing local data, and file uploads.</p>
		</div>
	</body></html>