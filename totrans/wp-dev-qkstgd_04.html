<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Building Custom Modules with Plugin Development</h1>
                </header>
            
            <article>
                
<p>Enormous free plugin base and plugin-based architecture are the keys to success of WordPress as a CMS. Plugins allow developers to build independent features as well as connect with the modules developed by other developers. We can use plugins to build quality sites with the code written by the top WordPress developers in the world, without spending a single dollar. From the developer's perspective, plugins allow you to reach and help thousands of users while being able to promote your skills as a developer. Anyone who has basic programming knowledge can create plugins to meet application-specific requirements. However, it takes considerable effort to develop quality plugins that can be reused across a wide range of projects.</p>
<p>In this chapter, you will learn about the concept of plugins and how they are different from your theme. You will also go through the life cycle events of a proper plugin while creating a post attachments plugin to illustrate the use of these events. The primary concepts in plugin development such as data validation, sanitization, and nonce will be introduced. Understanding how to leverage existing WordPress features to build plugins that can be added or removed without affecting the other parts is the highlight of this chapter.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding the role of plugins in development</li>
<li>Creating a basic plugin from scratch</li>
<li>Exploring the life cycle of a plugin</li>
<li>Developing a post attachment plugin</li>
<li>Identifying the advantages of custom plugin development</li>
<li>Guidelines for building quality plugins</li>
</ul>
<p>By the end of this chapter, you should be able to understand the role of plugins and have the necessary knowledge to build a basic plugin from scratch using the recommended practices.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You will be required to have WordPress 4.9.8 installed to follow this procedure. Even if you<br/>
have a later version of WordPress, the described examples should work with no significant problems.</p>
<p class="mce-root">The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter04">https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter04</a></p>
<p class="mce-root">Check out the following video to see the code in action:<br/>
<a href="http://bit.ly/2Py2szO" target="_blank">http://bit.ly/2Py2szO</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the role of plugins</h1>
                </header>
            
            <article>
                
<p>A plugin is a set of functions dedicated to work as an independent solution, while extending or adding new features to WordPress. In WordPress, plugins are similar to the Apps we use in iOS and Android. We have the ability to use or remove any plugin without affecting WordPress's core features. Also, plugins allow us to separate independent features into their own plugins, making them easier to maintain. The <a href="http://wordpress.org" target="_blank">wordpress.org</a> plugin base has over 50,000 free plugins, and sometimes you don't have to develop anything for WordPress websites. You can just use a number of plugins and integrate them properly to build advanced features.</p>
<p>The role of plugins is vital for the development of a site. In <a href="94db5df8-bbb4-4e75-ae88-fa38a9aabe05.xhtml" target="_blank">Chapter 3</a>, <em>Designing Flexible Frontends with Theme Development</em>, we discussed the role of a theme, and the features beyond the scope of a theme. Basically, any feature beyond the scope of a theme should be developed with plugins. However, there are scenarios where we will also use plugins to develop theme-specific things like templates and styles so that they are compatible with multiple themes. In most scenarios, plugins should either use their own styles and designs or default to the styles of the theme. It's not ideal to develop plugins focusing on a specific theme as it's almost impossible to switch to another theme at later stages.</p>
<p>In development, building plugins can range from just a few lines of code with filter implementations to advanced modules with thousands of lines of code. Let's take a look at some of the common types of development tasks with plugins:</p>
<p class="mce-root"/>
<ul>
<li><strong>Building reusable blocks</strong>: WordPress sites are mostly built by non-technical site owners and hence building the blocks of simple features is a common task. These blocks allow the client to add the feature anywhere in the site without needing a developer. We can use shortcodes or widgets to provide features as reusable blocks. In modern sites, page builders are used frequently to build the page's design. Therefore, we can also develop components for page builders that are to be used as reusable blocks.</li>
<li><strong>Modifying built-in features</strong>: This is a must for many sites, especially for extending the backend features and customizing the backend display. Since these are built-in features, we can't modify the WordPress file to customize them. Therefore, we need to choose actions and filters of built-in features and implement them with the use of plugins.</li>
<li><strong>Data capturing and displaying</strong>: This is another common type of requirement, especially for sites that go beyond basic blogs. In these kinds of tasks, we need to create custom forms in the frontend, and either use backend features to store the data or create our own data storage. Built-in custom post types and custom build forms are used to handle such requirements.</li>
<li><strong>Integrating UI components</strong>: Modern websites are filled with interactive user interface components that are designed to display substantial data in a limited space. These components are mostly powered by open source JavaScript libraries. So, integrating these libraries and letting administrators add data to these components is another common requirement.</li>
</ul>
<p>These are some of the challenges you face when working on a specific WordPress site. The process of building plugins to handle these types of requirements is essential for WordPress developers and hence we will be covering them in upcoming chapters. However, if you are planning to develop your own plugin, the challenges and possibilities are enormous. We can explore the WordPress plugin directory to understand what a plugin can do and the scope involved.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WordPress plugin types based on features</h1>
                </header>
            
            <article>
                
<p>As you explore, you will understand that the roles of plugins may vary from one another. So, it's important to identify these different types of plugins in order to face the challenges in extending different WordPress modules. Here, we are going to choose some of the popular plugins of different plugin types and discuss how they interact with WordPress's frontend and backend. This is purely a personal preference and hence you may want to categorize them differently after exploring the plugin directory:</p>
<ul>
<li><strong>Yoast SEO</strong> (<a href="https://wordpress.org/plugins/wordpress-seo/">https://wordpress.org/plugins/wordpress-seo/</a>): This plugin is used to improve the SEO of the site by adding necessary content to pages. This type of plugin has interfaces in the backend, where we can add content or settings. However, these plugins work under the hood in the frontend as we can't see any content. The examples for this type includes plugins from caching, analytics, and translation categories.</li>
<li><strong>WordPress Importer</strong> (<a href="https://wordpress.org/plugins/wordpress-importer/">https://wordpress.org/plugins/wordpress-importer/</a>): This plugin imports data into the WordPress database from files. These types of plugins don't have any features in the frontend or backend interfaces. Instead, these plugins are used to provide functionality by changing database values. The examples for these types of plugins include Duplicate Post and All-in-One WP Migration.</li>
<li><strong>WooCommerce</strong> (<a href="https://wordpress.org/plugins/woocommerce/">https://wordpress.org/plugins/woocommerce/</a>): This plugin is used to simplify the online shopping process by creating and selling products. These types of plugins have interfaces in the backend to add content as well as interfaces in the frontend to display the content. Apart from that, these plugins contain extensive data processing. This is the most common type of plugin you will get for development tasks. The examples for this type of plugin include BuddyPress and bbPress.</li>
<li><strong>Meta Slider</strong> (<a href="https://wordpress.org/plugins/ml-slider/">https://wordpress.org/plugins/ml-slider/</a>): This plugin adds elegant image sliders to the frontend of the site. These types of plugins have backend interfaces for adding content and frontend interfaces for displaying the content inside modern UI elements. However, no data processing is involved. The examples for this type of plugin include Easy FancyBox and Max Mega Menu.</li>
<li><strong>Admin Menu Editor</strong> (<a href="https://wordpress.org/plugins/admin-menu-editor/">https://wordpress.org/plugins/admin-menu-editor/</a>): This plugin allows you to change the menus and the related settings. These types of plugins allow you to add, change, and remove built-in backend features to suit your needs. There is no interaction with the frontend or data in such plugins. The examples for this type of plugin include Admin Columns and Simple Page Ordering.</li>
</ul>
<ul>
<li><strong>Easy Google Fonts</strong> (<a href="https://wordpress.org/plugins/easy-google-fonts/">https://wordpress.org/plugins/easy-google-fonts/</a>): This plugin allows you to use Google Fonts for the content of the site. These types of plugins often don't have functionality related to the backend or frontend. Instead, they connect third-party services with WordPress. The examples for this type of plugin include AddToAny Share Buttons and Google Doc Embedder.</li>
<li><strong>Advanced Custom Fields</strong> (<a href="https://wordpress.org/plugins/advanced-custom-fields/">https://wordpress.org/plugins/advanced-custom-fields/</a> ): This plugin acts as a framework, letting developers and clients build forms using existing components. These types of plugins interacts with both the backend and the frontend. However, these plugins don't provide site-specific features. Instead, the administrator decides which elements are displayed to the user and how the data is processed. Examples of such plugins include Elementor Page Builder and Pods Custom Content Types and Fields.</li>
</ul>
<p>The types of plugins we can build is enormous and can't be covered here, even if we were to have a complete chapter dedicated to them. Therefore, we have chosen a few plugins that contain the most popular types of development tasks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating your first plugin</h1>
                </header>
            
            <article>
                
<p>The process of developing a simple plugin is not complex. It follows the same process we used for themes, where we used PHP header comments. First, you have to create a new directory inside <kbd>wp-content/plugins</kbd>, with a preferred name. In this example, we are going to name it <kbd>wpquick-after-post-content</kbd>. Once the plugin directory has been created, we can create the main plugin file, which is <kbd>wpquick-after-post-content.php</kbd>. You can use the preferred name for the main plugin file. Now, we have to add the following header comments section to define it as a plugin:</p>
<pre>&lt;?php<br/>/*<br/>Plugin Name: WPQAPC After Post Content<br/>Plugin URI: <a href="http://www.wpexpertdeveloper.com/wpquick-after-post">http://www.wpexpertdeveloper.com/wpquick-after-post</a><br/>Description: Add dynamic content after the post<br/>Version: 1.0<br/>Author: Rakhitha Nimesh<br/>Author URI: <a href="http://www.wpexpertdeveloper.com">http://www.wpexpertdeveloper.com</a><br/>*/</pre>
<p>The plugin definition comment is similar to the theme definition, where Theme Name and Theme URI are being replaced by Plugin Name and Plugin URI. Once the comment has been added, this directory becomes a plugin and you can refresh the backend plugins list to reflect the plugin's details. Now, you can add any PHP code within the main plugin file or sub-files to begin development with WordPress. The only thing that differs from usual PHP development is the use of WordPress hooks. We will be introducing the necessary hooks throughout this chapter.</p>
<p>Let's add some functionality to the plugin. We have named this plugin After Post Content. The functionality is to add dynamic content after each post in the site. In <a href="94db5df8-bbb4-4e75-ae88-fa38a9aabe05.xhtml" target="_blank"/><a href="94db5df8-bbb4-4e75-ae88-fa38a9aabe05.xhtml" target="_blank">Chapter 3</a>, <em>Designing Flexible Frontends with Theme Development</em>,we added a dynamic advertisement bar to the header section. Here, we will be displaying the same advertisement, after the post content. Consider the following code for the implementation of this feature:</p>
<pre>add_filter( 'the_content', 'wpqapc_file_attachment_display' );<br/>function wpqapc_file_attachment_display( $content ){<br/>  global $post;<br/>  if( is_singular( 'post' ) ){<br/>    $after_content = '&lt;div id="wpquick-article-ads" style="padding:20px;text-align:center;font-size:20px;background:red;color:#FFF;"&gt;GET MEMBERSHIP WITH 30% DISCOUNT&lt;/div&gt;';<br/>    return $content . $after_content;<br/>  }<br/>  return $content;<br/>}</pre>
<p>This code is added to the main plugin file, just after the header comments section. Usually, we have to modify the post template to add such content in pure PHP development. In WordPress, everything is hooked into an action or a filter, and hence we can use them without modifying the template files. Here, we have used the <kbd>the_content</kbd> filter with a callback function. We already discussed the use of filters in <a href="94db5df8-bbb4-4e75-ae88-fa38a9aabe05.xhtml" target="_blank">Chapter 3</a>, <em>Designing Flexible Frontends with Theme Development</em>. This filter is used to modify the post/page content and is included in all of the properly coded themes. The default post content is passed to this filter and plugins can alter this content by implementing this hook.</p>
<p>In this scenario, we have used the <kbd>is_singular</kbd> function for the conditional check. This function is used to check if we are viewing the single page of any given post type. Once the condition is matched, we add the dynamic advertisement bar after the existing post content. Now, you can create and view a new post in the frontend. The content we added will be displayed in a similar fashion as to what's shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-320 image-border" src="assets/381ff567-4078-42ad-bfa8-2ee4118b5ef5.png" style="width:79.25em;height:37.83em;"/></p>
<p class="CDPAlignLeft CDPAlign">We have created a simple plugin in a very short time span. WordPress plugins can range from a few lines of code like this one, to advanced systems with thousands of lines of code. So, as we can see, developing WordPress plugins is not hard. It's always a good option to separate even a few lines of codes into a separate plugin, assuming that the functionality can be useful for many sites. In this example, we only added a fixed bar to each and every post. In real world implementations, we will have to change these advertisements as well as have the ability to add them to each post from the backend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring the life cycle of a plugin</h1>
                </header>
            
            <article>
                
<p>A product life cycle is a series of events or stages that occur from the start to the completion of the product or process. WordPress plugins contain life cycle events, from initial activation to uninstallation. It's important to understand all of these events to keep the plugin working and make the data consistent, even after exiting the plugin. Many developers are aware of only a few of these events, leading to low quality plugins.</p>
<p>In this section, we are going to look at the life cycle of a plugin and how we can manage each of the events in the cycle. Consider the following diagram for a basic illustration of events in a plugin:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-321 image-border" src="assets/af75db8e-1305-4d44-a83b-6c02c55ba834.png" style="width:25.25em;height:16.67em;"/></p>
<p>As you can see, the life cycle of a plugin has five events, apart from its functionality. A plugin starts the cycle via an activation event. The cycle is completed with either deactivate or uninstall events, until it starts the cycle again with activation. Let's understand these five events:</p>
<ul>
<li><strong>Activation</strong>: This is a built-in event that's fired by clicking the Activate button from the WordPress plugin list or installation screen. This can be used for executing certain actions upon activation as well as to initialize the plugin data and settings. Ideally, the initialization tasks should be done through a separate installation process since plugin activation is not a one-time event. However, a limited number of plugins offer a separate installation process, as it's a plugin-specific event. Therefore, most developers will use WordPress's built-in activation process to initialize the plugins with necessary condition checks. Adding rewrite rules, creating/modifying database tables, adding default settings. and creating demo data are some of practical functions that are executed in the activation process.</li>
<li><strong>Installation</strong>: This is not a built-in event, and most WordPress plugins use the activation event for installation. However, we may need a step by step installation process like WordPress for complex plugins. With this, we can implement our own installation process by using custom code after the activation. You can install WooCommerce to check how the plugin-specific installation process is handled with custom screens.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<ul>
<li><strong>Upgrading</strong>: This is a built-in event for plugins in the WordPress plugin repository and is used just after the version upgrade has completed. However, this event is not available for other plugins unless we build a custom upgrade process to get the files from our own server. Therefore, we need to handle this by combining existing WordPress hooks and conditional checks in scenarios where we don't have a custom automatic upgrade process. This event can be used for adding default values for additional settings in new versions, altering database tables, converting existing data to a new format, and so on.</li>
<li><strong>Deactivation</strong>: This is a built-in event that's fired by clicking the Deactivate link from the WordPress plugin list. This action should be used to execute certain tasks before the plugin is deactivated. Often, developers misunderstand the use of this action and tend to use it as an uninstallation process. Deactivation is a temporary event and hence you should not delete plugin data within this hook. Ideally, this event should be used for functions such as removing rewrite rules, clearing the cache, and temporary database values.</li>
<li><strong>Uninstallation</strong>: This is also a built-in event that's fired by clicking the Delete link from the WordPress plugins list. This is the proper event to handle uninstallation and must be used to clear plugin-specific data. Many plugins don't have an uninstallation process, leaving the plugin data in the database. Once a plugin is deactivated, the plugin data doesn't affect the site's features. However, this data affects the site's performance, and also makes it prone to conflicts with plugins that will be used in the future. Therefore, it's important to implement the uninstall event for a plugin as well as instruct the user on what happens upon uninstallation.</li>
</ul>
<p>In the next section, we will be developing a plugin while using the most important and mandatory life cycle events of a plugin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing a post attachments plugin</h1>
                </header>
            
            <article>
                
<p>In the two preceding sections, we discussed the steps for building a basic plugin and the life cycle events. In this section, we will be developing a plugin, while covering the implementation of life cycle events and critical features in plugin development. Let's summarize the requirement of the plugin.</p>
<p class="mce-root"/>
<div class="packt_quote">The use of blog posts and displaying dynamic content after the post is common in most WordPress sites. We already looked at the process of adding content after the post, in the first plugin we developed. Now, we are going to extend the feature to allow attachment downloads after the post. In some sites, it's essential to allow users to download files related to the post. This plugin will allow the administrator to add files to a post from the backend and let users download these files by displaying them after the post's content.</div>
<p>Let's start the development of our plugin by creating a new directory called <kbd>wpquick-post-attachments</kbd> inside the <kbd>wp-content/plugins</kbd> directory. Then, we need to create the main plugin file inside the new directory as <kbd>wpquick-post-attachments.php</kbd>. As usual, we need to add the plugin header comments section to this file in order to let WordPress list it as a plugin. You can use the plugin header comments from the previous plugin with a modified name and description.</p>
<p>Now, we have to identify the tasks involved in the development process of this plugin:</p>
<ul>
<li>Creating a custom table to store attachment details of each post</li>
<li>Adding a file field in the post creation screen to upload attachments</li>
<li>Uploading and saving the attachments in a custom table</li>
<li>Displaying attachments after post content with a download feature</li>
</ul>
<p>Let's start the development process by adding these features within the plugin life cycle events we discussed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating settings upon plugin activation</h1>
                </header>
            
            <article>
                
<p>The activation process of a plugin is handled by the built-in <kbd>register_activation_hook</kbd> function. In this scenario, we are developing a simple plugin to illustrate the importance of concepts in plugin development. Here, we will be using the built-in activation event to initialize the settings and data for this plugin, instead of creating separate installation process. Add the following code to the <kbd>wpquick-post-attachments.php</kbd> file, after the header comments section:</p>
<pre>register_activation_hook( __FILE__, 'wpqpa_activate' );<br/>function wpqpa_activate(){<br/>  global $wpdb;<br/>  $table_attachments = $wpdb-&gt;prefix . 'wpqpa_post_attachments';<br/>  $sql_attachments = "CREATE TABLE IF NOT EXISTS $table_attachments (<br/>                 id int(11) NOT NULL AUTO_INCREMENT,<br/>                 file_name varchar(255) NOT NULL,<br/>                 user_id int(11) NOT NULL,<br/>                 post_id int(11) NOT NULL,<br/>                 file_path longtext NOT NULL,<br/>                 updated_at datetime NOT NULL,<br/>                 uploaded_file_name varchar(255) NOT NULL,<br/>                 PRIMARY KEY (id)<br/>                 );";<br/><br/>  require_once( ABSPATH . 'wp-admin/includes/upgrade.php' );<br/>  dbDelta( $sql_attachments );<br/>  $default_headers = array('Version' =&gt; 'Version');<br/>  $plugin_data = get_file_data(__FILE__, $default_headers, 'plugin');<br/>  update_option( 'wpqpa_version',$plugin_data['Version'] );<br/>}</pre>
<p>We use the <kbd>register_activation_hook</kbd> function to register a custom function to be executed upon the activation process. The first parameter takes the path of the main plugin file, while the second parameter is used to define the function name. Here, we have used a function called <kbd>wpqpa_activate</kbd>.</p>
<p>We start the plugin activation process by creating a custom table to store the post attachment path and other necessary details. We already discussed the process of creating custom tables and the use of the <kbd>dbDelta</kbd> function in <a href="3e88326a-c8fe-4943-ae81-4ff69e8b865e.xhtml" target="_blank">Chapter 2</a>, <em>Managing Database Structure, Storage, and Retrieval</em>, and hence the explanations will not be repeated in this section. Apart from table creation, we can also save initial data or the settings required to run the plugin. In this scenario, we are capturing the plugin version from the header comments section by using the <kbd>get_file_data</kbd> function and saving it to <kbd>wp_options</kbd> table with a plugin-specific key called <kbd>wpqpa_version</kbd>.</p>
<p>We used the activation process to generate the necessary configurations in the database. Before moving into the development of these features, we need to specify the necessary paths to access the other files in the plugin. So, let's add some constants to the main plugin file by using the following code:</p>
<pre>if ( ! defined( 'WPQPA_PLUGIN_DIR' ) ) {<br/>  define( 'WPQPA_PLUGIN_DIR', plugin_dir_path( __FILE__ ) );<br/>}<br/>if ( ! defined( 'WPQPA_PLUGIN_URL' ) ) {<br/>  define( 'WPQPA_PLUGIN_URL', plugin_dir_url( __FILE__ ) );<br/>}</pre>
<p>First, we have to use the <kbd>defined</kbd> function to check whether a constant with a given name is already defined in order to prevent errors. Here, we have added two constants to define the URL to the plugin file inside the plugin directory and the full directory path. These two constants are used in upcoming sections to load scripts, styles, and PHP files for the plugin. Now, we can move into the process of building the features of the plugin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing post attachment uploads</h1>
                </header>
            
            <article>
                
<p>The post creation screen is designed to let developers extend features by using custom meta boxes. In this scenario, we need a way to let the administrator upload files to a post. So, we need to define a custom meta box for displaying the input elements, as shown in the following code:</p>
<pre>add_action( 'add_meta_boxes_post', 'wpqpa_post_attachments_meta_box' );<br/>function wpqpa_post_attachments_meta_box( $post ){<br/>  add_meta_box( 'wpqpa-post-attachments', __( 'Post attachments', 'wpqpa' ),<br/>'display_post_attachments_meta_box', 'post', 'normal', 'high' );<br/>}</pre>
<p>The <kbd>add_meta_boxes_post</kbd> action is used to register a new meta box for normal posts. Inside this action, we can create a new meta box by using the <kbd>add_meta_box</kbd> function.</p>
<div class="packt_tip">If you are registering a meta box for a specific post type, it's recommended that you use the <kbd>add_meta_boxes_{post_type}</kbd> action. In scenarios where the meta box is registered for multiple post types, you can use the generic <kbd>add_meta_boxes</kbd> action.</div>
<p>The first three parameters of this function are required and used for unique meta box ID, meta box title, and callback function, respectively. In this scenario, we are calling a function in the main plugin file and hence we can just use the function name. However, if the callback function resides within a PHP class, you need to use the following syntax to call the function on an object of the class:</p>
<pre>$wpqpa = new WPQPA();<br/>add_meta_box( 'wpqpa-post-attachments', __( 'Post attachments', 'wpqpa' ),<br/>array($wpqpa, 'display_post_attachments_meta_box') , 'post', 'normal', 'high' );</pre>
<p>The remaining three parameters in the preceding code are used for screen, context, and priority, respectively. Let's take a look at the use of those three parameters:</p>
<ul>
<li><strong>Screen</strong>: This parameter specifies the WordPress screen ID or IDs as an array to display the metabox. Each screen in WordPress has a specific ID to let developers build features for specific screens. Here, we have used <span class="packt_screen">post</span> as the screen since we are only displaying the metabox for normal posts. You can check the available screen IDs of the admin screens by going to <a href="https://codex.wordpress.org/Plugin_API/Admin_Screen_Reference">https://codex.wordpress.org/Plugin_API/Admin_Screen_Reference</a>.</li>
</ul>
<ul>
<li><strong>Context</strong>: This parameter defines the location within the screen. We have three options for the post screen: normal, advanced, and side. The default value is <span class="packt_screen">advanced</span> and displays a metabox under the post editor. However, if a <em>normal</em> metabox is created, it will display before the metaboxes with <span class="packt_screen">advanced</span> context. The <span class="packt_screen">side</span> option moves the metabox to the side column, along with the <span class="packt_screen">Publish</span> buttons.</li>
<li><strong>Priority</strong>: This parameter defines the location of the metabox within a context. We have four values called high, core, default, and low. The <span class="packt_screen">high</span> value places the metabox on top within the context while the priority will get lower as we move to the <span class="packt_screen">low</span> option.</li>
</ul>
<p>Next, we need to complete the implementation of the callback function before we can check the new metabox on the post screen. Let's consider the following code for the implementation of the <kbd>display_post_attachments_meta_box</kbd> function:</p>
<pre>function display_post_attachments_meta_box( $post, $metabox ){<br/>  global $wpdb;<br/>  $display = '&lt;div class="wpqpa-files-panel" &gt;<br/>   &lt;div class="wpqpa-files-add-form" &gt;<br/>     &lt;div class="wpqpa-files-msg" style="display:none" &gt;&lt;/div&gt;<br/>     &lt;div class="wpqpa-files-add-form-row"&gt;<br/>     &lt;div class="wpqpa-files-add-form-label"&gt;'.__("File Title","wpqpa").'&lt;/div&gt;<br/>     &lt;div class="wpqpa-files-add-form-field"&gt;<br/>     &lt;input type="text" class="wpqpa-file-name" name="wpqpa_file_name" /&gt;<br/>     &lt;/div&gt;<br/>     &lt;/div&gt;<br/>     &lt;div class="wpqpa-files-add-form-row"&gt;<br/>     &lt;div class="wpqpa-files-add-form-label"&gt;'.__("File","wpqpa").'&lt;/div&gt;<br/>     &lt;div class="wpqpa-files-add-form-field"&gt;<br/>     &lt;input type="file" class="wpqpa-file" name="wpqpa_file" /&gt;<br/>     &lt;/div&gt;<br/>     &lt;/div&gt;<br/>    &lt;div class="wpqpa-clear"&gt;&lt;/div&gt;<br/>  &lt;/div&gt;';<br/>  $display .= wp_nonce_field( "wpqpa_attachment", "wpqpa_nonce", true, false );<br/>  echo $display;<br/>}</pre>
<p>This function automatically receives post object and metabox details as parameters. Most of the code is self-explanatory as it contains the container elements and the necessary HTML fields. However, the last line is very important as a developer. WordPress uses a technique called <strong>nonce</strong> to increase the security of your code. Let's take a look at the definition of nonce, which has been extracted from the official codex:</p>
<div class="packt_quote">"A nonce is a "number used once" to help protect URLs and forms from certain types of misuse, malicious or otherwise. WordPress nonces aren't numbers, but are hashes made up of numbers and letters. Nor are they used only once, but have a limited "lifetime" after which they expire. During that time period, the same nonce will be generated for a given user in a given context. The nonce for that action will remain the same for that user until that nonce life cycle has completed."</div>
<p>In short, nonces are used to validate the user's request and keep the integrity of the submitted data. It's a must to use nonce validations in plugin development, especially when you are developing plugins for public use. The <kbd>wp_nonce_field</kbd> function is used to add a hidden field with a nonce value. The first parameter to this function is an action name that will be used in the verification process, and the second parameter is the name of the HTML hidden field. We can use the <kbd>wp_nonce_field</kbd> function without any of these parameters, but it's strongly recommended to use both options. The following is a sample output that's been generated from the use of the <kbd>wp_nonce_field</kbd> function:</p>
<pre>&lt;input type="hidden" id="wpqpa_nonce" name="wpqpa_nonce" value="bff32cce02"&gt;<br/>&lt;input type="hidden" name="_wp_http_referer" value="/wp-admin/post.php?post=9&amp;action=edit"&gt;</pre>
<p>This nonce value will be used later in the data saving process for verification. So far, we have added the necessary HTML for displaying file upload input fields. However, these elements might display all over the place without the necessary styles. Therefore, we need to create a directory called <kbd>css</kbd> inside our plugin directory and add a CSS file as <kbd>wpqpa.css</kbd>. Then, we need to include the CSS in the file by using recommended WordPress actions. Consider the following code for including the CSS file:</p>
<pre>add_action( 'admin_enqueue_scripts', 'wpqpa_load_scripts',9 );<br/>add_action( 'wp_enqueue_scripts', 'wpqpa_load_scripts',9 );<br/>function wpqpa_load_scripts(){<br/>  wp_register_style( 'wpqpa_css', WPQPA_PLUGIN_URL . 'css/wpqpa.css' );<br/>  wp_enqueue_style( 'wpqpa_css' );<br/>}</pre>
<p>In WordPress, we need to use <kbd>admin_enqueue_scripts</kbd> action for adding script and style files to the backend, and use the <kbd>wp_enqueue_scripts</kbd> action for the frontend. In this scenario, we are displaying the same files list in both the frontend and the backend. Therefore, we use both actions to load the CSS file we created. First, we have to register style files by using the <kbd>wp_register_style</kbd> function with a unique key and path. Then, we use the <kbd>wp_enqueue_style</kbd> function to add the styles file to the page. More details and advanced uses of script and style loading will be discussed in upcoming chapters. The CSS styles for this plugin are not discussed in this chapter. You can use the source files for this chapter to understand and modify them.</p>
<p>Now, we can take a look at the modified post creation screen with our metabox, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cea5b65e-92ad-476c-bd40-5d447a993401.png"/></p>
<p class="CDPAlignLeft CDPAlign">The custom metabox is displayed under the post editor. However, in a single site, we could be using many plugins with custom metaboxes. Therefore, you can't get the metabox to the exact location we need unless you are willing to change the code of such plugins.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uploading attachments and saving attachment data</h1>
                </header>
            
            <article>
                
<p>The next step in the process is uploading and saving the file that's been selected by the administrator. In this scenario, we add the <span class="packt_screen">File</span> and <span class="packt_screen">File Title</span> inside the metabox by using the defined fields. Then, the administrator needs to hit the post's <span class="packt_screen">Publish</span> or <span class="packt_screen">Update</span> button to save the attachment along with the post.</p>
<div class="packt_tip">Ideally, the attachment details should be uploaded and saved using AJAX in order to support multiple files without needing to update the post. In this scenario, we have used a normal form submit as we have not introduced AJAX yet and we need to understand the process of handling normal POST requests.</div>
<p>Let's take a look at the attachment saving process using the following code, which has been added to the main file of our plugin:</p>
<pre>add_action( 'init', 'wpqpa_save_private_attachment_files' );<br/>function wpqpa_save_private_attachment_files(){<br/>  global $wpdb;<br/>  if( ! isset( $_POST['wpqpa_file_name'] ) ){<br/>    return;<br/>  }<br/>  $file_name = isset($_POST['wpqpa_file_name']) ?        sanitize_text_field($_POST['wpqpa_file_name']) : '';<br/>  $file_nonce = isset( $_POST['file_nonce'] ) ? ( $_POST['file_nonce'] ) : '';<br/>  $post_id = isset( $_POST['post_ID'] ) ? (int) ( $_POST['post_ID'] ) : 0;<br/>  $user_id = get_current_user_id();<br/>  // Remaining code<br/>}</pre>
<p>Usually, developers can access POST request data directly within any file of the site. However, WordPress uses an event-based architecture and hence we need to implement proper hooks to access this data. Accessing the request data outside a proper WordPress event can lead to conflicting or the unavailability of data. Therefore, we use the <kbd>init</kbd> action to access the POST data, as the user request is fully loaded by the time it reaches the <kbd>init</kbd> action. More about action execution process will be discussed in <a href="40208ac9-c023-42b1-b48e-a368761b37a6.xhtml" target="_blank">Chapter 5</a>, <em>Extending Plugins with Addons, Filters, and Actions</em>.</p>
<p>The <kbd>init</kbd> action will be executed for each and every request and hence we need to make sure that we use our custom code only when necessary. Therefore, we check the availability of the <kbd>wpqpa_file_name</kbd> field in the user request and return without executing the custom code when it's not available. Then, we have to grab the necessary data from the POST request. Here, we need three values for the file name, nonce, and post ID.</p>
<p>You may have noticed the use of a function called <kbd>sanitize_text_field</kbd>. This function is used to remove unnecessary tags, spaces, line breaks, and characters from text field submissions. <span>You should never trust incoming data; that's why you should use <kbd>sanitize_text_field</kbd> before recording it.</span> We should always validate and restrict user input values to improve the security of the code and prevent conflicts in the database. WordPress uses a three step process to secure data by validating, sanitizing, and escaping:</p>
<ul>
<li><strong>Sanitizing</strong>: At this stage, we have to grab the user submitted data and make sure that it contains the accepted values. WordPress provides a set of functions for cleaning the user input and making it secure. The <kbd>sanitize_text_field</kbd> is one of the functions among thirteen sanitizing functions. The available functions and their use are explained at <a href="https://codex.wordpress.org/Validating_Sanitizing_and_Escaping_User_Data#Sanitizing:_Cleaning_User_Input">https://codex.wordpress.org/Validating_Sanitizing_and_Escaping_User_Data#Sanitizing:_Cleaning_User_Input</a>.</li>
<li><strong>Validating</strong>: At this stage, we validate the cleaned input values from the previous stage. The intention of this step is to check whether user submitted data matches with the accepted values. Unlike sanitization, there are no specific functions for validation. We can use our own conditions with both PHP and WordPress functions for validation. Validating data types, string lengths, data formats, and empty values are some of the common uses of this step.</li>
<li><strong>Escaping</strong>: This step is used when displaying data to the user. The intention of this step is to secure the data to be displayed. WordPress provides a set of built-in escaping functions based on different data. We will be discussing the use of escaping in upcoming chapters. The available escaping functions and their use is explained at <a href="https://codex.wordpress.org/Data_Validation#Output_Sanitation">https://codex.wordpress.org/Data_Validation#Output_Sanitation</a>.</li>
</ul>
<p>You should choose the necessary functions from these three sections for validating the user data, depending on the type of fields used in a form and the accepted values.</p>
<p>The next step in the process is validating input data and uploading the attachment. Consider the following code, which is placed after the input data capturing code:</p>
<pre>if ( ! isset( $_POST['wpqpa_nonce'] ) || ! wp_verify_nonce( $_POST['wpqpa_nonce'], 'wpqpa_attachment' ) ) {<br/>  $result_upload = wpqpa_process_file_upload();<br/>  // Upload code section 1<br/>}else{<br/>  // Handle error for invalid data submission<br/>}</pre>
<p>First, we need to validate the user request by using the nonce value that we added in the custom meta box. We start by checking the existence of the nonce value by using the <kbd>isset( $_POST['wpqpa_nonce'] )</kbd> condition. Then, we can use the <kbd>wp_verify_nonce</kbd> function to verify the submitted nonce value. The first parameter to this function takes the value of the nonce field and the second parameter takes the action name of the nonce field. Once nonce is successfully verified, we can upload the attachment.</p>
<p>Here, we use a function called <kbd>wpqpa_process_file_upload</kbd> for handling attachment uploads. The majority of the code in the <kbd>wpqpa_process_file_upload</kbd> function is not WordPress-specific and hence self-explanatory. You can use the source code files for this chapter to understand the implementation of this function.</p>
<p>Now, we have to revert back to the <kbd>wpqpa_save_private_attachment_files</kbd> function, where we added the comment <em>Upload code section 1</em>. The data generated from the upload file's function is stored in the <kbd>$result_upload</kbd> variable. Let's continue the implementation to save the attachment details to the custom database table:</p>
<pre>if( isset( $result_upload['status'] ) &amp;&amp; $result_upload['status'] == 'success' ){<br/>  $file_date = date("Y-m-d H:i:s");<br/>  $uploaded_file_name = $result_upload['base_name'];<br/>  $wpqpa_post_attachments_table = "{$wpdb-&gt;prefix}wpqpa_post_attachments";<br/>  $wpdb-&gt;insert(<br/>    $wpqpa_post_attachments_table,<br/>    array(<br/>      'file_name' =&gt; $file_name,<br/>      'user_id' =&gt; $user_id,<br/>      'post_id' =&gt; $post_id,<br/>      'file_path' =&gt; $result_upload['relative_file_path'],<br/>      'updated_at' =&gt; $file_date,<br/>      'uploaded_file_name' =&gt; $uploaded_file_name,<br/>    ),<br/>    array( '%s', '%d', '%d', '%s', '%s', '%s' ) );<br/>}else{<br/>  // Handle file upload errors<br/>}</pre>
<p class="mce-root"/>
<p>First, we check whether the attachment upload has completed by using the status option of the <kbd>$result_upload</kbd> variable. Once the condition is matched, we get the file name from the <kbd>$result_upload</kbd> variable and define the custom table name in a variable. Next, we use the <kbd>insert</kbd> function of the global <kbd>$wpdb</kbd> object to save the data to the <kbd>wpqpa_post_attachments</kbd> table that was created in the activation event of the plugin. We already discussed the use of the <kbd>insert</kbd> function in <a href="3e88326a-c8fe-4943-ae81-4ff69e8b865e.xhtml" target="_blank">Chapter 2</a>, <em>Managing Database Structure, Storage, and Retrieval</em>, and hence I am not going to explain it in this section.</p>
<p>Now, the code for the attachment upload process is completed. However, you won't be able to upload attachments at this stage. In order to upload files, you need to change the <kbd>enctype</kbd> of HTML forms to <kbd>multipart/form-data</kbd>. By default, WordPress won't add the <kbd>enctype</kbd> attribute to the post submission form. Also it's not possible to manually add it, as the form code is generated within WordPress. So, we need to use the built-in <kbd>post_edit_form_tag</kbd> action to add the necessary <kbd>enctype</kbd>, as shown in the following code:</p>
<pre>add_action( 'post_edit_form_tag' , 'wpqpa_post_edit_form_tag' );<br/>function wpqpa_post_edit_form_tag( ) {<br/>  echo ' enctype="multipart/form-data" ';<br/>}</pre>
<p>Now, the entire process is completed and you should be able to test it by uploading a file with the use of post <span class="packt_screen">Publish</span> or <span class="packt_screen">Update</span> buttons. The uploaded attachment data should be reflected in the custom table.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying uploaded attachments</h1>
                </header>
            
            <article>
                
<p>We need a way to display the uploaded files within the post edit screen as well as on the frontend, after the post content. For this, we are going to use a common function called <kbd>wpqpa_file_attachment_list</kbd> to generate an attachments list, as shown in the following code:</p>
<pre>function wpqpa_file_attachment_list( $post ){<br/>  global $wpdb;<br/>  $display = '&lt;div class="wpqpa-files-list" &gt;';<br/>  $sql = $wpdb-&gt;prepare( "SELECT * FROM {$wpdb-&gt;prefix}wpqpa_post_attachments WHERE post_id = %d order by updated_at desc ", $post-&gt;ID );<br/><br/>  $files_list = $wpdb-&gt;get_results( $sql );<br/>  foreach( $files_list as $file_row ){<br/>    $url = get_permalink( $file_row-&gt;post_id );<br/>    $url = wpqpa_add_query_string( $url, "wpqpa_file_download=yes&amp;wpqpa_private_file_id =". $file_row-&gt;id."&amp;wpqpa_post_id=".$file_row-&gt;post_id );<br/><br/>    $display .= '<br/>      &lt;div class="wpqpa-file-item" id="PF'.$file_row-&gt;id.'" data-file-id="'.$file_row-&gt;id.'" &gt;<br/>      &lt;div class="wpqpa-file-item-row" &gt;<br/>      &lt;div class="wpqpa-file-item-name wpqpa-files-list-name" &gt;'.$file_row-&gt;file_name.'&lt;/div&gt;<br/>      &lt;div class="wpqpa-file-item-download" &gt;&lt;a href="'.$url.'" &gt;'.__("Download","wpqpa").'&lt;/a&gt;&lt;/div&gt;<br/>      &lt;div class="wpqpa-clear"&gt;&lt;/div&gt;<br/>      &lt;/div&gt;<br/>      &lt;div class="wpqpa-clear"&gt;&lt;/div&gt;<br/>      &lt;/div&gt;';<br/>  }<br/>  $display .= '&lt;/div&gt;';<br/>  return $display;<br/>}</pre>
<p>This function is placed inside the main plugin file and accepts a post object as a parameter. First, we use the <kbd>prepare</kbd> function of the <kbd>$wpdb</kbd> object to securely prepare the SQL query for execution. In this function, we need to assign placeholders to all of the user input data and pass the values as parameters. Once the query has been prepared, we can use the <kbd>get_results</kbd> function to execute the query and get a list of files that are attached to the specific post.</p>
<p>Next, we use a <kbd>foreach</kbd> statement to loop through the resulting attachments. Inside the loop, we get the URL of the post by using the built-in <kbd>get_permalink</kbd> function. Then, we add file-specific query parameters to the URL by using the custom <kbd>wpqpa_add_query_string</kbd> function. You can check the implementation of this function inside the main plugin file in the source code directory for this chapter. This URL is used to identify the attachment and provides download features in later stages of the implementation. Finally, we add the necessary HTML elements and containers with the attachment information and the download link. The prepared HTML will be returned from this function.</p>
<p class="mce-root"/>
<p>Now, we need to call this function within the <kbd>display_post_attachments_meta_box</kbd> function and display the attachments list after the file upload fields. After uploading a few files, your screen will look similar to what's shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/79e4f4d8-2e00-4e5c-8f88-8306b1613785.png"/></p>
<p class="CDPAlignLeft CDPAlign">Here, we have only used <span class="packt_screen"><strong>Download</strong></span> as an action button to keep the implementation simple and useful for this book. Usually, you will need other actions such as edit and delete for attachments.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying attachments in posts</h1>
                </header>
            
            <article>
                
<p>The main requirement of this plugin was to attach files to posts and let users download them from the post page. So far, we have created the background to save and display the attachments. Now, it's time to implement the main requirements by displaying them after the content of each post.</p>
<p>At the start of this chapter, we created a plugin to use the <kbd>the_content</kbd> filter and add dynamic content after the post. The same technique will be used in this scenario. Let's consider the following code for the implementation of the <kbd>the_content</kbd> filter:</p>
<pre>add_filter( 'the_content', 'wpqpa_file_attachment_display' );<br/>function wpqpa_file_attachment_display( $content ){<br/>  global $post;<br/>  if( is_singular( 'post' ) ){<br/>    return $content . wpqpa_file_attachment_list( $post );<br/>  }<br/>  return $content;<br/>}</pre>
<p>As usual, we add the <kbd>the_content</kbd> filter and the callback function to handle the display of attachments. First, we check whether we are actually viewing an individual post by using the <kbd>is_singular</kbd> conditional function. If the condition is not matched, we return the content, as attachments are only intended for normal posts. Once the condition is matched, we call the reusable function we created earlier to display the list of attachments for the post. The following screenshot previews how attachments are displayed in a single post page:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-322 image-border" src="assets/05cdbcf7-cf10-4f2c-ac32-f8656ebeb48f.png" style="width:79.25em;height:34.42em;"/></p>
<p class="CDPAlignLeft CDPAlign">Now, we have come to the final stage, where we need to implement a file download link to complete the plugin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the post attachments download</h1>
                </header>
            
            <article>
                
<p>This section is straightforward for developers who have already implemented file downloads with pure PHP. In the preceding section, we created a download link with a few custom parameters. Here, we have to use these parameters to identify attachments. Let's start this implementation by adding a custom download function on the <kbd>init</kbd> action:</p>
<pre>add_action( 'init', 'wpqpa_file_attachment_download' );<br/>function wpqpa_file_attachment_download(){<br/>  global $wpdb;<br/>  if( isset( $_GET['wpqpa_file_download'] ) &amp;&amp; sanitize_text_field($_GET['wpqpa_file_download']) =='yes' &amp;&amp; isset( $_GET['wpqpa_private_file_id'] ) ){<br/><br/>    $wpqpa_file_download = $_GET['wpqpa_file_download'];<br/>    $wpqpa_file_id = isset( $_GET['wpqpa_private_file_id'] ) ? (int) $_GET['wpqpa_private_file_id'] : '';<br/>    $wpqpa_post_id = isset( $_GET['wpqpa_post_id'] ) ? (int) $_GET['wpqpa_post_id'] : '';<br/><br/>    if( $wpqpa_file_id != '' &amp;&amp; $wpqpa_post_id != '' ){<br/>      $sql = $wpdb-&gt;prepare( "SELECT * FROM {$wpdb-&gt;prefix}wpqpa_post_attachments WHERE id = %d AND post_id = %d order by updated_at desc ", $wpqpa_file_id, $wpqpa_post_id );<br/>      $attachments = $wpdb-&gt;get_results( $sql,ARRAY_A );<br/>      if( ! isset( $attachments[0] ) ){<br/>        return;<br/>      }<br/>      $file_link = site_url() . $attachments[0]['file_path'];<br/>      $upload_dir = wp_upload_dir();<br/>      $file_dir = $upload_dir['basedir'] . $attachments[0]['file_path'];<br/>      // Remaining code for file downloads<br/>    }<br/>  }<br/>}</pre>
<p>As we have already discussed, it's very important to hook every custom function into a suitable WordPress action. In this scenario, we chose the <kbd>init</kbd> action since WordPress has finished loading and we need to access data from GET requests. We begin this function by checking the GET parameters in the URL to make sure that it's a request to download post attachments. You should note the use of <kbd>sanitize_text_field</kbd>, even for GET parameters, which is intended only for verification. Then, we access the attachment ID and post ID by using URL parameters with the necessary validation. Next, we execute a SQL select query to find the attachment details by using the database functions that were discussed in the previous sections. However, there is a slight difference in the <kbd>get_results</kbd> function, and that is that we have used an additional parameter called <kbd>ARRAY_A</kbd>. This is used to define the format of the result set. In the previous section, we didn't use this parameter and hence we got a set of objects as a result set. Once we use this option, the results will be provided in an associative array. Next, we check the availability of a matching attachment and use the result set to define the attachment URL and directory path.</p>
<p>Here's one way to write the file download code:</p>
<pre>$file_mime_type = mime_content_type( $file_dir );<br/>if( $file_mime_type != '' ){<br/>  header( 'Cache-Control: public' );<br/>  header( 'Content-Description: File Transfer' );<br/><br/>  if( isset( $attachments[0]['uploaded_file_name'] ) &amp;&amp; $attachments[0]['uploaded_file_name'] != '' ){<br/>    header( 'Content-disposition: attachment;filename='.$attachments[0]['uploaded_file_name'] );<br/>  }else{<br/>    header( 'Content-disposition: attachment;filename='.basename( $file_dir ) );<br/>  }<br/>  header( 'Content-Type: '. $file_mime_type );<br/>  header( 'Content-Transfer-Encoding: binary' );<br/>  header( 'Content-Length: '. filesize( $file_dir ) );<br/>  readfile( $file_dir);<br/>  exit;<br/>}</pre>
<p>First, we use the file directory path to get the mime type of the file as it's important to keep the integrity of the downloaded file. When the mime type is not empty, we use the necessary PHP headers for file downloading. We uploaded the files with a dynamic name containing a number value based on time. It's not ideal to let users download a file with such a name. Therefore, we use the conditional check to add the original file name stored in our custom table. We revert to using the base name of the file when the original file name is not available in the database. The rest of the code contain the usual PHP headers for file downloads and the <kbd>readfile</kbd> function to output the file content. Now, we have completed the functionality of the plugin. You should be able to download the attachments from the list that's displayed after the post content.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling plugin version upgrades</h1>
                </header>
            
            <article>
                
<p>The version upgrade process is handled by the built-in <kbd>upgrader_process_complete</kbd> hook. We can implement this hook to add whatever data changes are required for the upgrade. We don't have a built-in upgrading event that can handle both plugins from the WordPress directory as well as custom plugins. Therefore, we have to build a custom upgrade process by using one of the existing hooks and conditional checks.</p>
<p class="mce-root"/>
<div class="packt_infobox">As we have already discussed, the WordPress plugin directory offers an automatic upgrade process. The custom plugins won't have such features by default. Therefore, we need to build an automatic upgrade process for the custom plugin. Many custom plugins don't have such features and hence we have considered such an implementation beyond the scope of this chapter. In such a scenario, users will have to either deactivate the current version and upload the new version or replace the current version files with a new version. So, the upgrade process needs to happen in the initial request after the file's replacement.</div>
<p>Consider the following code, where we used the <kbd>wp_loaded</kbd> action to handle the upgrade process of this plugin:</p>
<pre>add_action( 'wp_loaded', 'wpqpa_upgrade_process' );<br/>function wpqpa_upgrade_process(){<br/>  $default_headers = array('Version' =&gt; 'Version');<br/>  $plugin_data = get_file_data( __FILE__, $default_headers, 'plugin' );<br/>  $stored_version = get_option('wpqpa_version');<br/>  $current_version = $plugin_data['Version'];<br/>  if ( !$stored_version &amp;&amp; $current_version ) {<br/>    update_option( 'wpqpa_version', $plugin_data['Version'] );<br/>  }<br/>  if ( version_compare($current_version, $stored_version ) &gt;= 0 ) {<br/>    update_option( 'wpqpa_max_upload_limit',20 );<br/>  }<br/>  update_option( 'wpqpa_version', $plugin_data['Version'] );<br/>}</pre>
<p>First, we use the <kbd>wp_loaded</kbd> hook with a callback function since all of the plugins are loaded when executing this hook. Then, we need to compare whether we are using the old version or the new version of the plugin. So, we grab the current version from the plugin header comments and the stored version from the database. Next, we check if the version is already stored in the database. The unavailability of the version in the database means that we are installing the plugin for the first time and hence we update the version.</p>
<p>The next step is comparing the two versions and seeing if the current version is higher than the installed version. In such a case, we can execute the tasks of the upgrade process. If these values are he same, the version hasn't changed and there is no need for the upgrade process. In this example, we are adding a default value for a new setting. In real world implementations, we can execute tasks such as changing existing data, adding new settings data, and adding database tables or columns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling plugin deactivation</h1>
                </header>
            
            <article>
                
<p>This event is handled by the built-in <kbd>register_deactivation_hook</kbd> function. The use of this function is similar to the activation hook. This plugin contains basic features and hence we can't find a suitable practical use of the deactivation hook. Therefore, we will not be implementing this event for this plugin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uninstalling the plugin to clean the resources</h1>
                </header>
            
            <article>
                
<p>There's a big difference between deactivating and uninstalling a plugin. Cleaning resources should only be done upon deactivation. WordPress provides two methods for implementing the uninstallation process. The first method is using a built-in function called <kbd>register_uninstall_hook</kbd> to handle the uninstall process. This works similar to the technique we used in activation, through a callback function. The second method is using a file called <kbd>uninstall.php</kbd> inside the root folder of the plugin. In this plugin, we are going to use the latter technique with the <kbd>uninstall.php</kbd> file.</p>
<div class="packt_infobox">You can view more details about the other technique at <a href="https://developer.wordpress.org/reference/functions/register_uninstall_hook/">https://developer.wordpress.org/reference/functions/register_uninstall_hook/</a>.</div>
<p>First, we have to create a file called <kbd>uninstall.php</kbd> inside the <kbd>wpquick-post-attachments</kbd> plugin directory. This file runs automatically when deleting the plugin from the plugins section. We can include the code for the uninstallation process directly inside the plugin. This is a basic plugin and hence we only need to delete the plugin-specific settings and custom tables that were created for the plugin. Let's take a look at the implementation of the <kbd>uninstall.php</kbd> file inside the plugin:</p>
<pre>&lt;?php<br/>global $wpdb;<br/>if (!defined('WP_UNINSTALL_PLUGIN')) {<br/>  die;<br/>}<br/>delete_option('wpqpa_version');<br/>$wpdb-&gt;query("DROP TABLE IF EXISTS {$wpdb-&gt;prefix}wpqpa_post_attachments");</pre>
<p>First, we need to check the availability of the <kbd>WP_UNINSTALL_PLUGIN</kbd> constant. This constant is set by WordPress in the process of uninstalling the plugin. If the constant is not available, the request could be an invalid one trying to delete the plugin data. Once the constant is set, we can implement the resource cleaning process. In this scenario, we have deleted the plugin version from the <kbd>wp_options</kbd> table and the whole <kbd>wp_wpqpa_post_attachments</kbd> table.</p>
<p>We have completed the simple plugin planned for this chapter by covering the functionality in each life cycle event. Usually, developers often consider the functionality and activation events of a plugin. However, upgrading and uninstalling events are critical in plugin development and hence you must use them with extra caution. Unless these events are handled properly, upgrading can break the entire site's functionality while uninstalling can leave a substantial amount of unused data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Identifying the advantages of custom plugin development as a developer</h1>
                </header>
            
            <article>
                
<p>WordPress has captured over 35% of sites and the enormous plugin base is continuing to grow at a rapid pace. So, site owners can find existing plugins to build whatever they want. Developers might consider this a risk, since WordPress sites can be built without a developer. This is partially true as the need for basic level developers are declining. On the other hand, the need for quality WordPress developers are emerging more than ever. In this section, we are going to focus on how custom plugin development is important for you as a developer. Let's take a look at the advantages of developing custom plugins:</p>
<ul>
<li><strong>Reusability in many projects</strong>: Among WordPress developers, a higher percentage of development is done for individual clients for site-specific requirements. Therefore, you may feel that you can add features anywhere you want, as it's not going to change over time. However, you can separate non-project-specific features into separate plugins and use them for multiple clients to build rapid and cost-effective solutions.</li>
<li><strong>Performance and security</strong>: There are some tools and techniques to measure the performance and security of WordPress plugins. However, the process is not perfect and we won't have time to check each and every piece of code in existing plugins. So, we have no choice other than use existing plugins without knowing the risks. In sites where performance and security is a top priority, custom plugin development is the best solution as you are aware of the security and performance concerns and could improve upon them.</li>
<li><strong>Build a community for your profile and work</strong>: In my personal experience, developing a plugin and releasing it to the public for free is the ideal method for exposing you as a developer to the world. There are millions of websites that require developers. However, there are also thousands of developers who are capable of building WordPress solutions. So, this is the ideal way to reach thousands of people that require developers and find potential clients on the way. You will also get other benefits as a substantial amount of people will be discussing your work and help you fix these issues.</li>
<li><strong>Generating a consistent income source</strong>: Premium plugin development has become a major business with the evolution of WordPress in recent years. There are developers who have made millions of dollars developing plugins in their spare time and selling them on their own. So, developing plugins could be an ideal solution for making a living without depending on a few clients or needing to find new clients every day.</li>
<li><strong>Eliminate the concern of version updates</strong>: This is a major concern for most site owners as they use the services of freelance developers and hence the developer is not available at the stage of upgrading. No matter whether it's free or premium, existing plugins will always release updated versions with more features and fixes. On one hand, upgrading without the proper knowledge is a risk as it could break the existing features. On the other hand, not upgrading could be a security risk. We don't have this concern in custom development, where you build site-specific plugins. Once the site is completed, you don't need to release a new version of the plugin, that is unless you want to add more features or find an incompatibility with WordPress versions.</li>
<li><strong>Provides flexibility and consistency in design</strong>: Most basic to intermediate level WordPress sites are built by using existing plugins. The issue with using existing plugins is the flexibility and inconsistency in design. Most plugins are developed for common purposes. Therefore, the design is either very basic to suit any site or fixed without much flexibility. So, using any number of plugins means that the elements generated from plugins will be completely different to the design of the theme. This leads to the tedious process of plugin customization to make the design consistent. On the other hand, custom plugins can be designed to match the theme of the site and keep the consistency of design. Therefore, you can develop custom plugins when it's cost-effective compared to the customization of existing plugins.</li>
</ul>
<p>These advantages are only a few among the dozens of direct and indirect benefits. You should read WordPress-related blogs and explore the work of popular developers to understand the capacity and potential of plugin development.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Guidelines for building quality plugins</h1>
                </header>
            
            <article>
                
<p>Up until this point, we have looked at the process of building simple plugins with the recommended practices. Most of you will be developing WordPress sites for individual clients and hence the plugins you develop will not have to go through a verification process for quality. However, it's important to build extendable and maintainable plugins that are to be compatible with WordPress version upgrades as well as other third-party plugins. On the other hand, if you are developing plugins for the WordPress plugin directory or premium plugin marketplace, you will have to go through an extensive verification and review process for both the code and features. So, the quality of the plugin needs to match the minimum quality standards.</p>
<p>Let's take a look at some of the common guidelines for building quality WordPress plugins, apart from the need to follow WordPress coding standards:</p>
<ul>
<li><strong>Using built-in WordPress functions</strong>: This is a common problem in WordPress development where developers tend to create their own functions due to a lack of knowledge in WordPress. The power of WordPress comes from its existing modules and hence we should always use the existing functions rather than create our own functions. Also, the existing functions are optimized and coded by expert WordPress developers and hence there is less chance of generating bugs or compatibility issues.</li>
<li><strong>Using the necessary hooks in existing features</strong>: Certain hooks are used in core features to let developers customize and extend their functionality. If you are implementing or modifying a core feature, you should include the necessary hooks so that solutions created by other developers are compatible with your solution.</li>
<li><strong>Always load built-in libraries</strong>: There can be dozens of plugins inside a single site and often some of these plugins require the same libraries, such as jQuery. So, one developer may build the solution for a specific jQuery version and another one could build for a different version. Including multiple versions of the same library often leads to conflicts. Therefore, you should always check if the library is available within the WordPress core and load the built-in version by using the recommended hooks.</li>
<li><strong>Use plugin-specific prefixes</strong>: When working with plugins that come from multiple developers, there is a high chance of generating conflicts in both code as well as data. So, we should always add a unique prefix to our plugin. We should use this prefix on function names, class names, constants, database tables, and even plugin-specific data in common tables such as <kbd>wp_options</kbd>, <kbd>wp_postmeta</kbd>, and <kbd>wp_usermeta</kbd>. However, most of the modern plugins follow the object-oriented style, and hence you may not need to use the prefix for function names.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<ul>
<li><strong>Use hooks for extendable features</strong>: You might be developing a plugin with common solutions after complete research of the requirements. But, more often than not, clients will ask for customization's in all parts in your code. So, it's better to keep your code as open as possible for future changes. Therefore, you should always use filters for values which might change and use actions for places where the process or template can be extended.</li>
</ul>
<p>These are some of the well-known and recommended guidelines. As you gain experience with plugin development, you can add a lot more guidelines to the preceding list based on user feedback and how other plugins work. Make sure that you use these guidelines as much as possible and release the plugin to the public whenever possible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Plugins can be considered the most important aspect of WordPress when it comes to custom development. If we discard the existing plugin base, WordPress will be a just another CMS without major attention from users or developers. As a developer, it's important to know the ins and outs of plugin development to survive in the growing WordPress community. Due to this, in this chapter, we looked at the role of plugins in development by discussing common plugin-related tasks. We chose popular plugins to explain different types of plugins and how they interact with WordPress sites. Next, we looked at the process of creating a basic plugin for WordPress. Most beginner developers are capable of building solutions with PHP and integrating the solution as a WordPress plugin. However, plugins created without the knowledge of complete life cycle events can turn into a nightmare at later stages of the project. Therefore, we looked at the life cycle events of a WordPress plugin and the functionality of each event. Next, we built a WordPress plugin to attach files to posts and let users download them from the frontend. In the process, we covered life cycle events, data validation, sanitization, use of metaboxes, and the concept of nonces. Finally, we looked at the common guidelines for building quality plugins and how plugin development can benefit you as a WordPress developer.</p>
<p>In <a href="40208ac9-c023-42b1-b48e-a368761b37a6.xhtml" target="_blank">Chapter 5</a>, <em>Extending Plugins with Addons, Filters, and Actions</em>, we will be looking at advanced plugin concepts as well as customizing existing popular plugins.</p>


            </article>

            
        </section>
    </body></html>