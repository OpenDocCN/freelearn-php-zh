- en: Developing Plugins, Widgets, and an Introduction to REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Plugins are a way to add to or extend WordPress' built-in functionalities. In
    [Chapter 5](1f05677b-dcae-4511-9add-b4cf68718507.xhtml)*, Plugins – What They
    Are and Why You Need Them,* you learned how to install them. There are thousands
    of useful plugins (at the time of writing, the official counter at [https://wordpress.org/plugins/](https://wordpress.org/plugins/)
    shows over 55,000 plugins) available from the online WordPress community, and
    they all perform different kinds of functions. In the earlier chapters, we installed
    plugins that catch spam, back up your website, and give you basic SEO features.
    You can also get plugins that manage your podcasts, track your stats, translate
    your content into other languages, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, however, you'll find yourself in a situation where the plugin you
    need just doesn't exist. Luckily, it's quite easy to write a plugin for WordPress
    that you can use on your own website and share with the larger community if you
    want to. All you need is some basic **Hypertext Preprocessor** (**PHP**) knowledge,
    and you can write any plugin you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is divided into four major parts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first part, we'll create two plugins using an easy-to-follow, step-by-step
    process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second part, we'll create a widget using the built-in WordPress widget
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the third part, you will learn what shortcodes are and how to use them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the fourth part, we'll discuss the topic of the REST API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll create a plugin via a simple step-by-step process. We'll
    first see what the essential requirements are, then try out and test the plugin,
    and then briefly discuss the PHP code involved. That said, you should already
    have a basic background in PHP before going into this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Building plugins from scratch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, we're here to learn about WordPress, so in this particular case,
    we will indeed build things from scratch. This is always the best approach to
    get an in-depth look into how a particular technology works.
  prefs: []
  type: TYPE_NORMAL
- en: However, later on, once you're working with WordPress on a regular basis, and
    managing your own or other people's websites, I advise you to always look for
    an already existing plugin before deciding to write a new one yourself. As I mentioned
    earlier, there are around 55,000 plugins in the official directory alone, not
    to mention all the premium plugins available all over the web. In short, if you
    need some functionality, most likely, there's a plugin for it, so you can just
    go out and get it.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this the recommended approach? If I'm correct, you've chosen to use WordPress
    because you wanted to make your website as functional as possible, with the least
    amount of effort possible. Following this line of thought, using an existing plugin
    simply requires much less effort than building one. Also, many existing plugins
    are already used by thousands of other people and have large communities supporting
    them. Choosing a high-quality plugin is, therefore, a safer path to take.
  prefs: []
  type: TYPE_NORMAL
- en: I feel that I should emphasize this clearly because experience tells me that
    many young WordPress developers tend to press their peers to create things from
    scratch just for the heck of it, despite the fact that there are other, better
    solutions available.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, remember that everything that's a derivative work based on WordPress
    is available under the **GNU General Public License **(**GPL**). So, there's nothing
    stopping you from taking an existing plugin, building upon it, making it better,
    and then re-sharing your version with the world. That way, we all win and there's
    no redundant work.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we can do that, we indeed must learn the craft by constructing
    something of our own from start to finish. Onward, then!
  prefs: []
  type: TYPE_NORMAL
- en: Plugin code requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as there were requirements for a theme, there are requirements for a plugin.
    At the very least, your plugin must satisfy the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It must be placed in the `wp-content/plugins` directory (inside the root directory
    of WordPress)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must have a PHP file with a unique name (that is, a name not used by any
    other plugin in the main `wp-content/plugins` directory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must have a specially structured comment at the top of the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (see [https://codex.wordpress.org/File_Header](https://codex.wordpress.org/File_Header) for
    more information)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, of course, you must have some functions or processing code; but WordPress
    will recognize any file that meets these requirements as a plugin.
  prefs: []
  type: TYPE_NORMAL
- en: If your plugin is a simple one, then you can just place a unique PHP file straight
    in your `wp-content/plugins` directory, so it can sit next to the default Hello
    Dolly plugin that WordPress comes with. However, a much better practice is to
    create a subdirectory (again, with a unique name) and place your PHP file there.
    It makes the `wp-content/plugins` directory seem much more organized. Plus, you
    never know when your plugin is going to need some additional files (it's always
    easier to simply add new files to a previously existing `plugin` directory, than
    to restructure the plugin from scratch).
  prefs: []
  type: TYPE_NORMAL
- en: A basic plugin – adding link icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a demonstration, we will create a simple plugin that adds icons to document
    links within WordPress. For example, if you create a new post and add a link to
    an MP3 file in it, it''ll look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fad653c5-7c77-4970-8f30-0000c54ed13f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once this plugin is complete, the link will look like the following screenshot
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91e7d9e1-59f8-4301-b6b2-dccde7f9d85c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To accomplish this, we have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide images of the icons that will be used
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have a PHP function that identifies the links to documents and adds a special
    CSS class to them
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have a style sheet that creates the CSS classes for displaying the icons
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tell WordPress that whenever it prints the content of a post (that is, using
    the `the_content()` function), it has to run the PHP function first
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tell WordPress to include the new styles in the `<head>` tag
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep this list in mind as we move forward. Once all of these five requirements
    are met, the plugin will be done. So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Naming and organizing the plugin files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every plugin should have a unique name, so that it does not come into conflict
    with any other plugin in the WordPress universe. When choosing a name for your
    plugin and the PHP file, be sure to choose something unique. You may even want
    to do a Google search for the name you choose in order to be sure that someone
    else isn't already using it.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the main plugin file itself, your plugin can contain any number of
    other files and subdirectories. If the situation calls for it, you can even use
    media files, such as audio and video, to go along with your plugin. Of course,
    additional CSS or JS files (or even full libraries) are allowed as well.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, as my plugin will be composed of multiple files (a PHP file, a
    style sheet, and some image files), I'm going to create a directory to house my
    plugin. I'll name the plugin Add Document Type Styles New, and place it in a directory
    called `add_doctype_styles_new`. The PHP file, `doctype_styles_new.php`, will
    live in this directory. I've also collected a number of document type icons (provided
    by [https://www.freepik.com/](https://www.freepik.com/) via [https://www.flaticon.com/](https://www.flaticon.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The directory I created for my plugin now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/facb5b34-df88-47ff-af14-058815d1f693.png)'
  prefs: []
  type: TYPE_IMG
- en: It is best practice to also create directories, such as `images`, `css`, and
    `js` inside your plugin's directory if what you're building will consist of more
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Now that I've got the images in my directory, I've taken care of the *first*
    requirement in the list of requirements my plugin has to meet.
  prefs: []
  type: TYPE_NORMAL
- en: If your plugin has any unusual installation or configuration options, you may
    also want to include a `readme.txt` file in its directory that explains this.
    This `README` file will be useful, both as a reminder to you, and as an instructional
    document to others who may use your plugin in the future. If you plan to submit
    your plugin to the WordPress plugin directory, you will be required to create
    a `README` file. To get the template for such a file, visit [https://wordpress.org/plugins/developers/](https://wordpress.org/plugins/developers/).
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, your plugin has to start with a special comment that
    tells WordPress how to describe the plugin to users on the plugins page. Now that
    I''ve got my directory and a blank PHP file created, I''ll insert the special
    comment. It has to be structured like the following (this really is fundamental
    and is explained in more detail at [https://codex.wordpress.org/File_Header](https://codex.wordpress.org/File_Header)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Another good piece of information to have in your plugin is about licensing.
    Most plugins use GPL. This license essentially means that anyone can use, copy,
    and enhance your code, and that they are not allowed to prevent anyone else from
    redistributing it. I've also added a note about the GPL to my plugin's PHP file.
    Remember that all PHP code you encounter in any WordPress plugin is GPL by default.
    However, graphic files, CSS, JavaScript, and other elements might have a different
    license, so be careful when copying other people's work and making it part of
    your own. You can read more about the license at [https://www.gnu.org/copyleft/gpl.html](https://www.gnu.org/copyleft/gpl.html).
  prefs: []
  type: TYPE_NORMAL
- en: That's all about the introductory code. Now, we can add the *meat!*
  prefs: []
  type: TYPE_NORMAL
- en: Writing the plugin's core functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core of any plugin is the unique PHP code that you bring to the table. This
    is the part of the plugin that makes it what it is. Since this plugin is so simple,
    it only has a few lines of code in the middle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *second* requirement the plugin has to meet is to have a PHP function that
    identifies links to documents and adds a special class to them. The following
    function does just that. Note that in keeping with my efforts to ensure that my
    code is unique, I''ve prefixed both of my functions with `doctype_styles_new`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When the function is given some `$text`, it will perform a search for any HTML
    anchor tag linking to a PDF, DOC, MP3, or ZIP file, and replace it with a class
    to that anchor. Then, the function returns the altered `$text`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *third* requirement the plugin has to meet is to have a style sheet that
    creates classes for displaying the icons. The following function fetches our style
    sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this function uses the same enqueue mechanism that we used
    in [Chapter 9](eb8f8110-a317-4b1f-afd4-b2bf72714b39.xhtml)*, Developing Your Own
    Theme,* when registering the style sheets for our custom theme. Here''s the CSS
    file that the preceding function fetches (inside `doctype_styles_new.css`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, a very simple file, containing just a handful of styles and icons to
    distinguish our document links!
  prefs: []
  type: TYPE_NORMAL
- en: Adding hooks to the plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We get our code to actually run when it is supposed to by making use of WordPress
    **hooks**. The way in which plugin hooks work is as follows: at various times
    while WordPress is running, they check to see whether any plugins have registered
    functions to run at that time. If there are, the functions are executed. These
    functions modify the default behavior of WordPress.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of hooks, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Actions**: Actions are the hooks that the WordPress core launches at specific
    points during execution, or when specific events occur. Your plugin can specify
    that one or more of its PHP functions are executed at these points, using the
    `Action` API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filters**: Filters are the hooks that WordPress launches to modify the text
    of various types before adding it to the database or sending it to the browser
    screen. Your plugin can specify that one or more of its PHP functions is executed
    to modify specific types of text at these times, using the `Filter` API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that you can tell WordPress to run your plugin's functions at the
    same time, when it runs any of its built-in functions. In our case, we want our
    plugin's first function, `doctype_styles_new_regex()`, to run as a filter along
    with WordPress' `the_content()` function (this is the *fourth* requirement a plugin
    has to meet).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following code to the bottom of the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This uses the `add_filter` hook that tells WordPress to register a function
    named `doctype_styles_new_regex()` when it is running the function called `the_content()`.
    By the way, if you have more than one function that you want to add as a filter
    to the content, you can add a third argument to the `add_filter()` function. This
    third argument will be a number representing the load priority (the default value
    is 10, the highest priority is 1, and there are no particular limits for the lowest
    priority—you can even assign values such as 100 or 999), and WordPress will run
    your functions in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that''s left in our list of requirements that a plugin has to meet is the
    *fifth* requirement—that is, to tell WordPress to include the new styles in the
    `<head>` tag. This is actually done the same way that it''s done for themes, which
    is through the following hook using `add_action()` with the `wp_enqueue_scripts`
    handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the complete plugin PHP file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that there are no blank spaces before `<?php`. If there are any spaces,
    the PHP code will break, complaining that headers have already been sent. This
    is quite a common mistake that developers stumble into during their initial attempts
    with WordPress plugins. It's also a generally good idea to not use the PHP closing
    tags (`?>`) at the end of your PHP files. It saves you from some of the most unfortunate
    execution errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you save and close this PHP file. You can now do one of two things,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using your FTP client, upload `add_doctype_styles_new/` to your
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wp-content/plugins/` directory'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Zip up your directory into `add_doctype_styles_new.zip`, and use the plugin
    uploader in `wp-admin` to add this plugin to your WordPress installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This version of the plugin is available in the code bundle for this chapter,
    inside a subdirectory called `phase 1`. Our plugin files will go through a couple
    of phases before we have the final version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the plugin is installed, it will show up on the plugins page, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc94a249-6e72-4b00-8719-f0e5b32c61c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, you can activate it and test it out.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you go to view the same post that we created at the beginning of this chapter,
    you''ll see the plugin in action. Here''s the same screenshot again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd37702b-594e-4fad-acb9-662044337a2d.png)'
  prefs: []
  type: TYPE_IMG
- en: You can also try adding a new post with links to PDF, ZIP, or DOC files. Then,
    when you view the post, you'll see that even more icons have been added to it
    by our plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've learned about a basic plugin that uses hooks to piggyback on
    the existing WordPress functionality, let's enhance this plugin by giving the
    user some controls.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an admin page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some plugins add a page to `wp-admin` where you or the user can edit plugin
    options. We''ve seen this with W3 Total Cache, Yoast SEO, and more. Now, let''s
    modify our plugin to give the user some control over which document types are
    supported. The following screenshot shows what the new management page will look
    like when we are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef4fb56c-f296-4bae-9943-8cd93dbd944e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'First, deactivate the plugin we just wrote. We''ll make changes to it and then
    reactivate it. The following list details the steps we''ll carry out to modify
    the plugin in order to make this new page possible:'
  prefs: []
  type: TYPE_NORMAL
- en: Add functions that create an admin page and save the user's input in a new option
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `doctype_styles_new_regex()` function so that it retrieves the user's
    input
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add hooks for the admin page functions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Adding management page functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The management page that we will create is going to add an option to `wp-admin`.
    This uses the existing space in the WordPress `options` table in the database,
    so no database modifications are required. The name of this new option must be
    unique. I'm going to call the new option `doctype_styles_new_supportedtypes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are six functions we need to add to the plugin, so that an admin page
    can be added to `wp-admin`. Let''s take a look at the functions, one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *first* function adds the new `doctype_styles_new_supportedtypes` option
    when the plugin is activated, and sets the default value as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The *second* function removes the new option when the plugin is deactivated,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the new *third* function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This function adds a new item to the Settings menu in `wp-admin` using the
    `add_submenu_page()` function call. This takes six arguments, namely: where the
    options page should be placed, page title, menu link text, the user at the maximum
    level who can access the link, what file to open (none, in this case), and the
    function to call, `supportedtypes_options()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `supportedtypes_options()` function is, in fact, the *fourth* new function
    we are adding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This function actually displays our new page. It prints a title and checks to
    see whether someone has clicked on the `submit` button; if the `submit` button
    has been clicked on, the `supportedtypes_options()` function updates the options
    and then prints the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new *fifth* function we have to add is responsible for updating options
    if the `submit` button has been clicked on, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The last function we need to add, which is the new *sixth* function, prints
    the form that the users will see. Make sure there are no spaces before or after
    the closing tag (`EOF;`), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These six functions together take care of adding a link in the menu, adding
    the management page for this link, and updating the new option.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the doctype_styles_new_regex() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the users are able to edit the list of supported document types by
    appending the document types they want, we should have a way of telling the `doctype_styles_new_regex()`
    function to use the user''s list instead of the built-in list. To do so, we need
    to use `get_option(''doctype_styles_new_supportedtypes'')` in our `doctype_styles_new_regex()`
    function. The `get_option()` function will retrieve the value that the user has
    saved in the new option we just created. Modify your `doctype_styles_new_regex()`
    function so that it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Adding hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have added our management page functions, but now we have to tell WordPress
    to use them. To do so, we just need to add the following three new hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first hook tells WordPress to add our link to the menu when it creates the
    menu with `admin_menu()`. The next two hooks tell WordPress to call the activation
    and deactivation functions when the plugin is activated or deactivated.
  prefs: []
  type: TYPE_NORMAL
- en: This version of the plugin is available in the code bundle for this chapter,
    inside a subdirectory called `final`. It is the final version of our plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have added all of the new functions. Now it''s time to save the file and
    see what happens. You can go ahead and reactivate the plugin. Now, when you look
    at the Settings menu, you will see that a new link has been added, as demonstrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69249065-f872-4ec0-b8e6-3453a9231dcd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the new link to see the management page, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/223ee559-51fa-42a8-b09b-af44ad3ee3c6.png)'
  prefs: []
  type: TYPE_IMG
- en: If you follow the three steps shown in the preceding screenshot on the management
    page (upload the file icon, add a new style to the style sheet, and add the extension
    to the option), then the new document type will be supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are already a number of ways in which this plugin could be improved.
    Some of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of forcing the user to upload their new icons using FTP, the plugin
    could allow the user to upload icons directly via the Settings page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The plugin could display the icons for the supported document types on the Settings
    page so that the users see what they look like.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The plugin could check to make sure that for every document type in the option
    field there is an existing icon, otherwise, it will display an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perhaps you'd like to try to make these changes yourself!
  prefs: []
  type: TYPE_NORMAL
- en: Testing your plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've tried out our new plugin, so it's probably a good moment to say a word
    or two about testing your plugins and making sure that they don't cause any problems
    for regular users in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our particular plugin is a very simple one; the only thing it does is process
    each link it finds inside any post or page''s content, and adds a custom icon
    next to it. However, even such a simple plugin can be a possible security breach
    point. For example, the only place where the user can input anything is the plugins
    section in `wp-admin` (the field handling the supported file types). Now, there
    is a possibility that someone might use this field to input a piece of specific
    PHP code instead of a standard file type; for instance, code that is meant to
    perform a specific action on the server side, and which could result in a serious
    security breach. That is why our `update_supportedtypes_options()` function has
    the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to them, everything that the user inputs will have all of the PHP and
    HTML tags stripped by `strip_tags()`, and then every character that needs to be
    quoted in database queries will be handled by `addslashes()`. Using such functions
    is a just-in-case practice, but it tends to be something that eventually pays
    off.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from testing our work against some of the common hacking practices, such
    as code injection or SQL injection, we also need to handle all kinds of unconventional
    uses we can think of. For instance, would anything bad happen if someone put a
    value that's not a standard file type? Or, what if the CSS file goes missing all
    of a sudden? These are just some of the questions a good testing session should
    answer.
  prefs: []
  type: TYPE_NORMAL
- en: Another good way of testing plugins is to hand them over to a few trusted users
    and ask for feedback. Someone who's entirely new to your plugin will usually do
    a way better job of testing it than you, the author.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this short section here only scratches the surface of plugin testing
    and code testing in general, so I encourage you to give it a closer look on your
    own. There are many great resources on the web and in your nearest bookstore.
  prefs: []
  type: TYPE_NORMAL
- en: A plugin with database access – capturing searched words
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to leave the document types plugin behind now, and create a new
    one, featuring active use of a database. Let's create a simple plugin that stores
    all the words that visitors search for (when using the blog's search feature).
  prefs: []
  type: TYPE_NORMAL
- en: Overall, this plugin is very basic, and doesn't require its own directory like
    the previous plugin that we worked on. That's why this whole plugin will be done
    inside one file: `capture_searches_new.php`. I'm calling the plugin `Capture Searched
    Words New`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The database table structure for this plugin will be as follows. The table
    name is `wp_searchedwords`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field** | **Type** | **Null** | **Key** | **Default** | **Extra** |'
  prefs: []
  type: TYPE_TB
- en: '| `Id` | `INT` | NOT NULL | PRI | - | `auto_increment` |'
  prefs: []
  type: TYPE_TB
- en: '| `Word` | `VARCHAR(255)` | - | - | NULL | - |'
  prefs: []
  type: TYPE_TB
- en: '| `created` | `DATETIME` | NOT NULL | - | Today 00:00:01 | - |'
  prefs: []
  type: TYPE_TB
- en: Now, let's write the plugin code.
  prefs: []
  type: TYPE_NORMAL
- en: Even though I say that the table is named `wp_searchedwords`, it won't always
    be the case. It's all based on the table prefix that's set for your website (the
    default one is indeed `wp_`). Here, I'm going to refer to the table as `wp_searchedwords`
    anyway, for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the plugin to talk to the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first part of this plugin should only be run when the plugin is activated.
    This will be the initialization function. One of its tasks is to create or update
    the database table (the table will only be created if it hasn''t been created
    before):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This function connects to the database using various function calls, such as `dbDelta()`,
    `$wpdb->query()`, and `$wpdb->prepare()`. The `dbDelta()` function takes care
    of creating the table or updating it (it does whatever is needed at the time;
    you can find out more at [https://codex.wordpress.org/Creating_Tables_with_Plugins](https://codex.wordpress.org/Creating_Tables_with_Plugins)).
    Apart from this, when dealing with the WordPress database, you can utilize any
    database-related PHP function in existence. Or, you can use WordPress' class member
    function: `$wpdb->get_results()`. The function we're using here also stores the
    searched word in the database table if a search has just been performed. This
    is done through the `$wpdb->query()` and `$wpdb->prepare()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Adding management page functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now need a familiar-looking function that adds a management page to `wp-admin`.
    In this case, we use `add_management_page()` instead of `add_submenu_page()`,
    because this plugin is more of a tool than something that requires settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For this plugin, we''re not going to load any custom styling or CSS files.
    The purpose here is to just showcase how database connection can be done, so we''re
    going to keep everything else ultra-simple and minimal. Therefore, the only thing
    we have to do at this point is to write a function that retrieves the information
    from the database and displays it on the new management page (again, everything
    is done through the `$wpdb` object—it''s a class defined by WordPress that contains
    a set of functions that you can use to interact with the database):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That's it. The previous plugin had more functions because data was being captured
    from the user and then saved. Here, that's not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we just need to add two hooks, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first hook tells WordPress to run the initialization function when the plugin
    is activated, or when a search is performed. The second hook modifies the `admin_menu`
    to add a link to the new management page.
  prefs: []
  type: TYPE_NORMAL
- en: This version of the plugin is available in the code bundle for this chapter, inside
    a subdirectory called `final`. It is the first and final version of the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with the last plugin, you can now either upload your plugin using FTP to
    `wp-content/plugins`, or turn it into a ZIP file and add it using the uploader
    to `wp-admin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve installed it, activate it. Then, look at the menu under Tools
    and you''ll see a link to the new management page, as demonstrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/077b2777-d056-4de2-b5de-317b13d32a64.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click on Capture Searched Words, you''ll see a new page that the plugin
    has created, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51b38be7-1b93-4377-8edc-c76fa8e99408.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, I did perform some searches beforehand just to have something
    to show on this new page. You can do the same by placing a search field widget
    in your sidebar (as shown in the following screenshot), and then experimenting
    with different search words and phrases. The plugin will pick them all up and
    display the most searched ones in its section in `wp-admin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78b4a7c6-e0cb-427d-bc8e-4a19bf67a823.png)'
  prefs: []
  type: TYPE_IMG
- en: Building a plugin for the block-based editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know by now, there's a new content editor in WordPress that's been introduced
    in the 5.0 version of the platform. Essentially, it does away with the previous
    single editing window and instead, allows the user to work with individual content
    blocks, placing them one after another. When put together, all those blocks construct
    the final blog post. That's all fine and dandy for the user, but what does it
    mean for the plugin developer? A handful of things!
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, building a plugin for a block-based editor is very different from building
    standard plugins like we've been doing in this chapter. While you can build those
    classic plugins with just a basic knowledge of PHP and HTML, building for the
    block-based editor is a bit more complex. It involves setting up and mastering
    additional web technologies. You need things such as **npm**, **Node.js**, and **webpack**,
    not to mention that you also need to be comfortable working with JavaScript in
    general. Teaching all of this is a large-enough topic for its own book. So, instead
    of doing that, I'm going to point you to some external sources where you can begin
    your adventure with the block-based editor. However, before I do that, let's summarize
    briefly what the general idea of building for the editor is and what is possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new editor accepts two main types of elements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sidebar sections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, as a plugin developer, you can either create new blocks to be
    included in the editor, or new sidebar entries to customize the fine details about
    your plugin's functionality, or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m sure you know what a block is at this point, so let me show you an example
    of a good sidebar use in the new editor. It comes from the Yoast SEO plugin ([https://wordpress.org/plugins/wordpress-seo/](https://wordpress.org/plugins/wordpress-seo/);
    we discussed this in [Chapter 5](1f05677b-dcae-4511-9add-b4cf68718507.xhtml),
    *Plugins - What They Are and Why You Need Them*). If the user has the plugin enabled
    on their site, and they proceed to work on a new blog post, they''ll see this
    new sidebar section in the top-right corner of the editor, as demonstrated in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cba766ff-fb2a-4f64-877e-acb598e89bc4.png)'
  prefs: []
  type: TYPE_IMG
- en: It allows the user to tune up the SEO parameters of their post. The thing worth
    noticing is how well the plugin's block integrates with the rest of the editor's
    user interface. This seamless integration is the whole goal of building plugins
    with the block-based editor in mind.
  prefs: []
  type: TYPE_NORMAL
- en: The same thing goes if you want to build a plugin that enables new blocks. They
    also need to use the same interface conventions as the default blocks that come
    with WordPress built in. Here's an example of a plugin that does exactly that.
    It's called Otter blocks ([https://wordpress.org/plugins/otter-blocks/](https://wordpress.org/plugins/otter-blocks/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you install and activate it, you''ll get a whole set of new blocks, and
    the best part is that they blend in with the default blocks perfectly. For example,
    one of the blocks included is the **Sharing Icons** block. The following screenshot
    shows what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cc96bbb-a45e-47f2-9791-7d9286174b9d.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it has the same controls and similar options to all of the other
    blocks. Of course, this plugin is a fairly complex creation, built by a team of
    developers, and you surely don't have to make your first block plugin similarly
    impressive.
  prefs: []
  type: TYPE_NORMAL
- en: That said, you might be notice one thing in particular as it relates to the
    block-based editor; that is, what if your plugin doesn't require creating any
    new blocks or sidebar elements? In such a case, you don't need to trouble yourself
    with the editor at all. The two plugins we've created in this chapter so far don't
    use the editor in any way, so making your plugin compatible with the editor certainly
    isn't a must.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin your adventure with the block-based editor, read this two-part guide
    on how to adapt your plugin for the block editor: part 1 can be found at [https://www.codeinwp.com/blog/adapt-your-plugin-for-gutenberg-block-api/](https://www.codeinwp.com/blog/adapt-your-plugin-for-gutenberg-block-api/) and
    part 2 is available at [https://www.codeinwp.com/blog/make-plugin-compatible-with-gutenberg-sidebar-api/](https://www.codeinwp.com/blog/make-plugin-compatible-with-gutenberg-sidebar-api/).'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you can experiment with the free Gutenberg Boilerplate plugin
    ([https://github.com/HardeepAsrani/gutenberg-boilerplate](https://github.com/HardeepAsrani/gutenberg-boilerplate)),
    which delivers the minimal block editor development setup and examples inside
    a single package. There's one example block, and one example sidebar included.
    You can build upon these elements when creating your own block-ready plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Learning more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are hundreds of hooks available in WordPress—way too many to cover in
    this book. You can learn more about them by going online. Start out at these online
    reference sites:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Plugin API* article contains very thorough information about writing plugins
    and using hooks, at: [https://codex.wordpress.org/Plugin_API](https://codex.wordpress.org/Plugin_API).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a complete list of action hooks, visit [https://codex.wordpress.org/Plugin_API/Action_Reference](https://codex.wordpress.org/Plugin_API/Action_Reference).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a complete list of filter hooks, visit [https://codex.wordpress.org/Plugin_API/Filter_Reference](https://codex.wordpress.org/Plugin_API/Filter_Reference).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may also want to take a step back and look at the general *Plugin Resources*
    page in the WordPress Codex at [https://codex.wordpress.org/Plugin_Resources](https://codex.wordpress.org/Plugin_Resources).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another page that you might find very helpful is the new *Code Reference* for
    developers: [https://developer.wordpress.org/reference/](https://developer.wordpress.org/reference/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key resource to bookmark if you want to build plugins for the new block-based
    editor is the *Gutenberg Handbook*, available at [https://wordpress.org/gutenberg/handbook/](https://wordpress.org/gutenberg/handbook/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to submit your plugin to the WordPress plugin repository, you'll
    need to take steps similar to those that you took when preparing a theme, and
    you'll also need to get hooked up to the WordPress SVN repository. Learn more
    about how to submit a plugin to the WordPress plugin repository at [https://developer.wordpress.org/plugins/wordpress-org/](https://developer.wordpress.org/plugins/wordpress-org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a widget bears some similarities to writing a plugin. In some ways,
    it's even easier because there is a widget class that you can leverage for some
    of the functionalities. In other ways, it's also a bit more time-consuming as
    there's a lot of mandatory code that every widget has to feature.
  prefs: []
  type: TYPE_NORMAL
- en: Custom tag cloud widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll see how to write a widget that displays a custom tag
    cloud that we can then place in the sidebar. There will also be the possibility
    to change the title of the widget, and although this is a tag cloud widget, we''ll
    be able to switch tags to categories and display them using a tag-cloud-like style
    as well. In its final form, the widget will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3366b609-14b4-4e08-a259-1e061861bc6a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Just as a comparison, here''s what the standard tag cloud widget (the native
    one in WordPress) looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e000c58b-eae6-4900-96c3-e9be9680a925.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Naming our widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this case, we're going to create the widget as a standalone plugin. So, just
    like any other plugin, it needs a unique name and a unique appearance in the `wp-content/plugins`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to search the web whenever you're creating a new widget or plugin,
    just to make sure that there's nothing out there going by the same name. On top
    of that, use a namespace as a prefix with every filename (and function name) that
    you're creating. For example, mine is `kk_`.
  prefs: []
  type: TYPE_NORMAL
- en: I'll name the new plugin file (which holds the widget) `kk_tag_cloud_widget.php`,
    and put it in its own `kk_tag_cloud_widget` directory inside `wp-content/plugins`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This main PHP file starts just like any other plugin, with the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The widget structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are building a widget using the widget class, your widget needs to
    have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: My unique widget name for this project is `KK_Widget_Tag_Cloud`. Now, let's
    go over each of the preceding functions one by one and understand what's going
    on.
  prefs: []
  type: TYPE_NORMAL
- en: The widget initiation function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the widget initiation function. Before we add anything to
    it, it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this function, which is the constructor of the class, we initialize various
    things that the `WP_Widget` class is expecting. The first two variables, to which
    you can give any name you want, are just a handy way to set the two array variables
    expected by the third line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at these three lines of code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `$widget_ops` variable is where you can set the class name, which is given
    to the `div` widget itself, and the description, which is shown in `wp-admin`
    on the widgets page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `$control_ops` variable is where you can set options for the control box
    in `wp-admin` on the widgets page, such as the width and height of the widget,
    and the ID prefix used for the names and IDs of the items inside. For my basic
    widget, I'm not going to use this variable (as it's optional).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you call the parent class's constructor, `WP_Widget()`, you'll tell it
    the widget's unique ID, the widget's display title, and pass along the two arrays
    you created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this widget, my code now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The widget form function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The widget form function has to be named `form()`. You may not rename it if
    you want the widget class to know what its purpose is. You also need to have an
    argument in there, which I''m calling `$instance`, which the class also expects.
    This is where the current widget settings are stored. This function needs to have
    all of the functionalities to create the form that users will see when adding
    the widget to a sidebar. Let''s look at some abbreviated code and then explore
    what it''s doing, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'First, you use a WordPress function named `wp_parse_args()`, which creates
    an `$instance` array that your form will use. What''s in it depends on what defaults
    you''ve set and what settings the user has already saved. Then, you create form
    fields. Note that for each form field, I make use of the built-in functions that
    will create unique names and IDs and input the existing values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$this->get-field_id()` creates a unique ID based on the widget instance (remember,
    you can create more than one instance of this widget).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$this->get_field_name()` creates a unique name based on the widget instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `$instance` array is where you will find the current values for the widget,
    whether they are defaults or user-saved data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the other code in there is just regular PHP and HTML. Note that if you
    give the user the ability to set a title, name that field `title`, and WordPress
    will show it on the widget form when it''s minimized. The widget form this will
    create will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc70ea47-8e76-40b5-b93f-84b45576ba91.png)'
  prefs: []
  type: TYPE_IMG
- en: The widget save function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a user clicks on the Save button on the widget form, WordPress uses AJAX
    to run your save function. You need to be sure to save whatever the user types
    in, which is all we''re doing in this case, but you can put other functionalities
    here if it''s appropriate for your widget (for example, database interactions,
    conversions, calculations, and so on). The final code for this function is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Be sure this function is named `update()` and is prepared to accept two instances,
    one with the old data and one with the just-submitted data. You can write your
    code to check `$new_instance` for problems, and thus, return `$old_instance` if
    the new one isn't valid. The `$instance` data you return will be what's shown
    in the update widget form.
  prefs: []
  type: TYPE_NORMAL
- en: The widget print function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The third main function in your widget class is the one that is called by the
    sidebar when it''s time to actually show the widget to people visiting the website.
    It needs to retrieve any relevant saved user data and print out information for
    the website visitor. In this case, our final print function looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function calls one more helper function responsible for fetching
    the current taxonomy. It is a very simple one, though, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first thing I do in the main function is to extract the data in the instance,
    which contains the information the website administrator had saved when filling
    out the widget form. Then, the widget takes a look into the selected taxonomy
    (tags or categories) and displays all of the individual items as a simple one-line
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Custom widget styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our small widget has its own style sheet that needs to be included in the current
    theme's `head` section, like any other style sheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file is named `kk_tag_cloud_widget.css` and contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing fancy, just a set of classes that will make sure that the widget looks
    great. The only thing we have to do with this style sheet is enqueue it through
    a standard WordPress hook. Place the following code in your plugin''s main file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Initiating and hooking up the widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'That''s it for widget functionality! Now, you just need to add a little piece
    of code that will hook the widget up to the rest of WordPress, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This tells WordPress that when it initiates widgets, it should be sure to register
    our new widget.
  prefs: []
  type: TYPE_NORMAL
- en: This version of the widget is available in the code bundle for this chapter,
    inside a subdirectory called `phase 1`. We'll still be adding one more feature
    before we can call it the final version.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your widget is ready to go! Let''s try this widget we have created now:'
  prefs: []
  type: TYPE_NORMAL
- en: Save all your changes, and upload your widget to the `wp-content/plugins` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the Plugins section and you'll see your widget waiting to be activated,
    as usual.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After you click on the Activate button, you can navigate to Appearance | Widgets.
    You''ll see the widget waiting to be added to a sidebar, as demonstrated in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7e8acbb5-f51c-4da8-92b3-65b9d4c5c802.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Drag the widget to a sidebar, and then click on the little downward arrow to
    edit it. You''ll see the options slide down, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b1c90895-c431-43fa-a432-0b3a95e31911.png)'
  prefs: []
  type: TYPE_IMG
- en: You can enter a Title or leave it blank for the default, and choose the Taxonomy that
    you want to display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on Save as you would with any widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you return to the frontend of the site and reload, the new tag cloud will
    be right there, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a1b31e41-abea-4bc0-8aaf-0133e5ff42f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Learning more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can browse the following online reference sites to learn more about widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: The WordPress *Widgets API* is located at [https://codex.wordpress.org/Widgets_API](https://codex.wordpress.org/Widgets_API).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WordPress lists a number of widgets at [https://codex.wordpress.org/WordPress_Widgets](https://codex.wordpress.org/WordPress_Widgets).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to find more widgets to install on your website, visit the widgets
    section of the plugin repository at [https://wordpress.org/plugins/tags/widget](https://wordpress.org/plugins/tags/widget).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundling a widget with an existing plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're writing a plugin and you'd like to make a widget available with it,
    you don't have to create a separate widget plugin. Just include all of the widget
    code—similar to what we created in the preceding section—in with your plugin's
    PHP file. When the user activates the plugin, the widget will automatically show
    up on the widgets page in `wp-admin`. There's no need for a separate file!
  prefs: []
  type: TYPE_NORMAL
- en: Shortcodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shortcodes are a handy way to let a non-technical person, such as an editor
    of a website, include dynamic content within pages and posts, without having to
    actually use any PHP, complex HTML structures, or custom JavaScript. In other
    words, shortcodes are handy reusable pieces of code, yet they don't require any
    actual coding experience or knowledge on the end user's part.
  prefs: []
  type: TYPE_NORMAL
- en: Shortcodes and the way they work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way a shortcode works is that you tell WordPress to look at the text within
    square brackets (`[]`) and evaluate it by running a PHP function. That PHP function
    can live in the `functions.php` file of your theme, or in a plugin file, or in
    a widget file. Let's create a simple shortcode and include it with our most recent
    widget plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Types of shortcodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Shortcodes are a pretty simple concept by definition, but we can still distinguish
    three main types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single-tag shortcodes**: These shortcodes are executed with just a single
    tag, for example, `[my_first_shortcode/]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Double-tag shortcodes**: These shortcodes are executed with opening and closing
    tags, for example, `[my_2nd_shortcode]some text here[/my_2nd_shortcode]` (notice
    that the closing tag has an additional `/`). As you can see, there''s also some
    content within the tags. This content can be processed by the shortcode function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shortcodes with attributes**: These shortcodes can have one or two tags and
    also a number of attributes we can use to customize the output, for example, `[my_3rd_shortcode
    name="Karol" twitter="carlosinho"]some text here[/my_3rd_shortcode]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple shortcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a simple shortcode that will make it possible to use our widget''s
    output inside any given post or page. This is going to be a double-tag shortcode
    with one additional attribute, which we''ll use to indicate whether the output
    should be formatted using our custom CSS or WordPress'' native styling:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new function at the bottom of our `kk_tag_cloud_widget.php`
    file, and then we''ll go through each individual line, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: First of all, note that this function does not *echo* or *print* anything. It
    just returns a string. If you let your function print, it won't look correct on
    the website.
  prefs: []
  type: TYPE_NORMAL
- en: Inside our function, the first line handles the custom attributes that the shortcode
    receives (in this case, just the `use_css` parameter for indicating whether the
    styles should be used or not, and the `taxonomy` parameter to indicate the taxonomy
    that should be shown in the shortcode). WordPress will hand off the `$atts` argument
    automatically, and we only have to use the `extract()` function to turn the attributes
    the user submits into variables available in the function. The values in the array
    passed to the `extract()` functions set the defaults, in case the user chooses
    no options. In general, there is no limit to the number of options that you can
    make available to the shortcode users.
  prefs: []
  type: TYPE_NORMAL
- en: The next line extracts the taxonomy identifier and tries to turn it into a valid
    taxonomy. In case the user's input is not valid, the default `post_tag` taxonomy
    will be used. The final part of the function handles the display based on the
    state of the `use_css` attribute. It's pretty basic at this point! There's also
    a possibility to include custom text as the main content of the shortcode. This
    can be useful in some situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we have to do now is tell WordPress that this function is a shortcode,
    and we do so using a hook. Be sure to choose something unique. I''ve chosen `kk_tag_cloud`
    as the name for this shortcode, so the hook looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this shortcode in our content, all we have to do is edit any given post
    or page and insert a line such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Such usage will have the following effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aeb6fc4a-78cc-407c-afc5-2c7fe994a00b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also use the shortcode such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will disable the custom styles and produce the following effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7224dcee-e5c2-4aa3-9138-24fa5938a658.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To display the tag cloud in its default form (showing the tags and using the
    custom style sheet), all we have to do is execute the shortcode, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The effect is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bce37ea4-0e90-4a50-9081-ddef2ef3c2d1.png)'
  prefs: []
  type: TYPE_IMG
- en: There are very few limitations regarding what you *can* and *cannot* do with
    shortcodes.
  prefs: []
  type: TYPE_NORMAL
- en: This version of the widget is available in the code bundle for this chapter, inside
    a subdirectory called `final`. It is the final version of our widget.
  prefs: []
  type: TYPE_NORMAL
- en: The WordPress REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The WordPress REST API is a relatively new addition to the WordPress platform.
    Before it was added to core, the REST API was available as a standalone mechanism
    via a separate plugin. You could get everything and also learn how to work with
    the package from the project's official website at [http://v2.wp-api.org/](http://v2.wp-api.org/).
  prefs: []
  type: TYPE_NORMAL
- en: However, the REST API was included in the WordPress core package in WordPress
    version 4.7\. This means that you no longer need any additional plugins or tools
    to make it work. Basically, as long as you're on the most recent version of WordPress,
    you have the REST API installed and enabled by default. Which is great news! But
    let's get a bit deeper.
  prefs: []
  type: TYPE_NORMAL
- en: What is the REST API?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Under the hood, the REST API—officially called the WordPress REST API—is just
    another layer of technology that allows you to interact with your WordPress site,
    as well as the sites of other people. Chiefly, the REST API allows you to separate
    the presentation layer of a WordPress site from the mechanism of how WordPress
    operates in the background. In other words, with specific REST API calls, you
    can perform actions on the contents of a WordPress site without having to enter
    the `wp-admin` of the site, or even visit it via a web browser at all.
  prefs: []
  type: TYPE_NORMAL
- en: Why use WordPress REST API?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The introduction of the REST API opens up a lot of new possibilities as to *what
    you can do* with a WordPress site and *what you can use it for*. For instance,
    via the REST API, you can interact with WordPress content remotely, add new content,
    erase content, or perform any other operation. Just to name one major possibility,
    this makes it easy to create a mobile app for your website, and have the app communicate
    with the website via the REST API. In other words, if you want to communicate
    with a WordPress site via any other way than by visiting the site directly, then
    you can do that with the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: How to get started with the REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're only scratching the surface here, and the description provided in this
    chapter is by no means exhaustive. The REST API is a rather advanced piece of
    technology that lets you do a multitude of things—sometimes via rather complex
    code structures. So, the only thing we want to achieve here is to help you get
    started by giving you a foundation that you can then explore further as you're
    learning about the REST API elsewhere. A great place to get started if you want
    to truly master the REST API is the official developer manual at [https://developer.wordpress.org/rest-api/](https://developer.wordpress.org/rest-api/).
    With that said, what follows are the basics of how to begin with the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The REST API allows you to interact with any WordPress site via the means of
    sending *requests* and receiving *responses* through the WordPress HTTP API. To
    make a valid request, you need to reference the following: the *base URL path*
    of the REST API, the *route*, and the *endpoint.*'
  prefs: []
  type: TYPE_NORMAL
- en: The base URL path is similar for all WordPress websites: `http://YOURWEBSITE.com
    /wp-json/wp/v2/`.
  prefs: []
  type: TYPE_NORMAL
- en: The route defines the exact part of the website's content that you want to communicate
    with. For example, you can use `posts/` in order to communicate with the site's
    posts. In that case, the full URL would be `http://YOURWEBSITE.com/wp-json/wp/v2/posts/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Endpoints are specific functions available through the REST API. For example,
    if you expand the route to target a specific post by ID, such as `http://YOURWEBSITE.com
    /wp-json/wp/v2/posts/123`, then this allows you to call one of three endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` returns the post data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` updates the post data and returns that updated post data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` deletes the post and returns the now-deleted post data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from the default endpoints, you can also create your own, depending on
    what you want to be able to do with your content through the REST API. This, however,
    is perhaps a topic for a more in-depth REST API manual. For the purpose of this
    book, let's just do a simple demonstration and create a plugin that will communicate
    with an external WordPress website via the REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a plugin that uses the REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've already learned how to create basic WordPress plugins in this very chapter,
    so now, let's combine this knowledge with the new addition of the REST API. The
    plugin we're building is going to simply display a list of posts from another
    blog based on a shortcode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the full code of this plugin—all contained within a single
    file named `kk_rest_demo.php`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The first function call, `extract()`, is something we know from the previous
    shortcode plugin/widget. It extracts the attributes given to the shortcode. In
    our case, the shortcode works with two optional attributes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`website_domain`: This indicates the domain name of the WordPress site that
    the plugin should communicate with (defaults to `newinternetorder.com`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`how_many`: This indicates how many posts should be fetched (defaults to `3`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next function call is where the main REST API communication happens. This
    call references a given route and fetches blog posts using the GET endpoint (by
    default), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we just need to check there weren''t any errors, and if so, halt
    the function. The next function call decodes the response and allows us to reference
    individual posts one by one later on, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The final `foreach` loop and `if` clause go through each post and retrieve
    their title and URL, which then get added to a standard HTML-unordered list and
    returned by the shortcode. At this point, and once I activate this plugin on my
    test site, I can create a new post and add the following shortcode to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells the plugin to communicate with `newinternetorder.com` and fetch
    the two most recent posts. The following screenshot shows the result of this as
    visible on the frontend:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/394d515e-fc5b-4ee4-8d16-3b7cbbd8acda.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, the plugin we've built here is very simple, and it does not do anything
    in terms of making sure that the domain provided is valid, or anything else security-related.
    However, the purpose of this demo is only to show you the simplest way of working
    with the REST API, and nothing else. Once again, I strongly encourage you to review
    some of the official resources, such as the *REST API Handbook* at [https://developer.wordpress.org/rest-api/](https://developer.wordpress.org/rest-api/).
  prefs: []
  type: TYPE_NORMAL
- en: This version of the plugin is available in the code bundle for this chapter, inside
    a subdirectory called `final`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned everything you need to know about creating basic
    plugins and widgets. Now you know how to structure the plugin's PHP files, where
    to put your functions, and how to use hooks. You also learned about adding management
    pages, enabling plugins and widgets to have database access, and how to create
    shortcodes.
  prefs: []
  type: TYPE_NORMAL
- en: On top of all of this, you learned how to work with the REST API and perform
    basic communication with other WordPress websites. With your existing knowledge
    of PHP and HTML, you have the tools to get started writing any plugin and/or widget
    your heart may desire.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll walk you through the process of creating a complete
    non-blog website from scratch.
  prefs: []
  type: TYPE_NORMAL
