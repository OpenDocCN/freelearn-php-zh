<html><head></head><body>
		<div id="_idContainer051">
			<h1 id="_idParaDest-173" class="chapter-number"><a id="_idTextAnchor174"/>12</h1>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor175"/>Working in a Team</h1>
			<p>The main goal of this book is to enable you to write code that can be understood, maintained, and extended by you and others. Most of the time, being a PHP developer means that you do not work alone on a project or a tool. And even if you started writing code alone, chances are high that at some point, another developer will join you – be it on a commercial product, or your open source package where other developers start adding new features or bug fixes.</p>
			<p>There will always be multiple ways to carry out a task in software development. This is what makes working in a team more challenging when you want to write <em class="italic">clean code</em> together. In this chapter, you will find several tips and best practices on how to set up <em class="italic">coding standards</em> and <em class="italic">coding guidelines</em>. We will also talk about how <em class="italic">code reviews</em> will improve the code and ensure the guidelines are kept.</p>
			<p>We will also explore the topic of <em class="italic">design patterns</em> in more detail at the end of this chapter. These patterns can help your team solve typical software development problems because they offer well-tested solutions.</p>
			<p>This chapter will include the following sections: </p>
			<ul>
				<li>Coding standards</li>
				<li>Coding guidelines</li>
				<li>Code reviews</li>
				<li>Design patterns</li>
			</ul>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor176"/>Technical requirements</h1>
			<p>If you followed along with the previous chapters, you do not require any additional setup.</p>
			<p>The code samples for this chapter can be found in our GitHub repository: <a href="https://github.com/PacktPublishing/Clean-Code-in-PHP">https://github.com/PacktPublishing/Clean-Code-in-PHP</a>.</p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor177"/>Coding standards</h1>
			<p>In the <a id="_idIndexMarker606"/>previous chapters, you learned a lot about writing high-quality code. Yet, it is not enough if you do it by yourself only. When you work in a team, you will most likely have the problem that other developers have a different understanding of quality and are on a different skill level than you are. </p>
			<p>This is harmful to your code because it might lead to lazy compromises, where the involved parties agree on a way, just to have their peace. Therefore, if you want to work effectively in a team, you want to standardize your work as much as possible.</p>
			<p>It makes sense to start with the low-hanging fruit: code formatting. This goes down to the very basics, such as agreeing on how many spaces should be used to indent lines, or where braces should be placed. But why is this even important? </p>
			<p>We already shortly addressed this topic in <a href="B19050_05.xhtml#_idTextAnchor055"><em class="italic">Chapter 5</em></a><em class="italic">, Optimizing Your Time and Separating Responsibilities</em>. However, we want to expand on it at this point. The main advantage of having a common <strong class="bold">coding standard</strong> (also called <em class="italic">coding style</em>) is to reduce <em class="italic">cognitive friction</em> when reading code. </p>
			<p class="callout-heading">Cognitive friction</p>
			<p class="callout">Cognitive friction basically<a id="_idIndexMarker607"/> describes the required mental effort for our brain to process information. Imagine, for example, you read a book, where every other paragraph was written in a different font, size, or line spacing. You would still be able to read it, but it would become annoying or tiring soon. The same applies to reading code. </p>
			<p>Introducing a coding standard to a project is relatively easy, thanks to the tools we already presented to you earlier in this book. Agreeing with others on a common standard, on the other hand, requires more work. That is why, in this section, we want to show you how to easily align on a common coding standard. </p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor178"/>Going with existing standards</h2>
			<p>Setting up standards together with others can be a long and painful process. However, nowadays, you do not argue about the size of a sheet of paper anymore. In European countries, the <em class="italic">DIN A4</em> standard<a id="_idIndexMarker608"/> is widely accepted, while in other countries, such as the US, you would use the <em class="italic">US Letter Size</em> without <a id="_idIndexMarker609"/>asking why. Most people accept these measures, and following these standards makes life a bit easier – one thing less to care about.</p>
			<p>The same applies to coding standards, which define how you format your code. Of course, you could argue for hours with your teammates about whether <em class="italic">tabs</em> or <em class="italic">spaces</em> should be used for the indentation. Both sides will come up with valid arguments, and you will never find the right answer, as there simply is no right and wrong here. And once you got the question about indentation sorted, the next topic to discuss could be the placement of brackets. Should they appear in the same line, or in the next?</p>
			<p>We do not <a id="_idIndexMarker610"/>necessarily need to agree with every detail of a standard, but undoubtedly, it saves time and nerves to use existing norms. In the PHP ecosystem, there are <em class="italic">Coding Standards</em> that already exist that you could utilize. A huge additional benefit of doing so is that the code sniffers have built-in rule sets for these standards. In the next section, we will talk about probably the best-known <em class="italic">Coding Standard</em> for PHP. </p>
			<h3>PHP-FIG and PSR</h3>
			<p>PHP itself has no official <em class="italic">Coding Standard</em>. Historically, each major PHP framework that existed, or still exists today, introduced some sort of standards because the developers quickly realized that using them has its benefits.</p>
			<p>However, since every project used its own standards, the PHP world ended up with a mixture of different formatting standards. Back in 2009, when the <strong class="bold">PHP-FIG</strong> (<strong class="bold">PHP Framework Interoperability</strong> <strong class="bold">Group </strong>(<strong class="bold">PHP-FIG</strong>) was formed, which <a id="_idIndexMarker611"/>consisted of members from all the important PHP projects and frameworks of that time, they wanted to solve exactly these kinds of problems. </p>
			<p>At that time, Composer was becoming more and more important, and packages were introduced that could easily be used across different frameworks. To keep the code somewhat consistent, a mutual way to write code was agreed upon: the <strong class="bold">PHP Standard Recommendations</strong> (<strong class="bold">PSRs</strong>) were<a id="_idIndexMarker612"/> born. </p>
			<p>To make the autoloader of Composer work, it was necessary to agree on how to name classes and <a id="_idIndexMarker613"/>directories. This was done with the very first standard recommendation, <em class="italic">PSR-0</em> (yes, nerds start counting at 0), which was <a id="_idIndexMarker614"/>eventually replaced by <em class="italic">PSR-4</em>.</p>
			<p>The first <em class="italic">Coding Standard</em> recommendation <a id="_idIndexMarker615"/>was introduced with <em class="italic">PSR-1</em> and <em class="italic">PSR-2</em>. <em class="italic">PSR-2</em> was <a id="_idIndexMarker616"/>later replaced by <em class="italic">PSR-12</em>, which <a id="_idIndexMarker617"/>contained rules for language features of newer PHP versions.</p>
			<p>Although <em class="italic">PSR-12</em> addresses the code style, it does not cover naming conventions or how to structure the code. This is often still predefined by the framework you use. The <em class="italic">Symfony</em> framework, for example, has its own set of <em class="italic">Coding Standards</em> that are based on the aforementioned <em class="italic">PSR-4</em> and <em class="italic">PSR-12</em>, but add further guidelines, for example, conventions on naming or documentation. Even if you do not use a framework at all and just pick single components to build an application, you could consider using these guidelines, which you will<a id="_idIndexMarker618"/> find on the <em class="italic">Symfony</em> website: <a href="https://symfony.com/doc/current/contributing/code/standards.html">https://symfony.com/doc/current/contributing/code/standards.html</a>.</p>
			<p class="callout-heading">PER coding style</p>
			<p class="callout"><em class="italic">PSR-12</em> was <a id="_idIndexMarker619"/>released in 2019 and thus does not cover the latest PHP features anymore. Therefore, at the time of writing this book, PHP-FIG released the <em class="italic">PER Coding Style 1.0.0</em> (<strong class="bold">PER</strong> is short for <strong class="bold">PHP Extended Recommendation</strong>). It is based on <em class="italic">PSR-12</em> and contains some additions to it. In the future, the PHP-FIG no longer plans to release any new <em class="italic">Coding Standards</em> related to PSRs, but new versions of this PER, if it is required. It is very likely that the <strong class="bold">code quality</strong> tools we featured in this book will pick up the new PER soon. You will find more information about it <a id="_idIndexMarker620"/>here: <a href="https://www.php-fig.org/per/coding-style">https://www.php-fig.org/per/coding-style</a>.</p>
			<p>Over time, the <a id="_idIndexMarker621"/>PHP-FIG has introduced over a dozen recommendations, and more are in the making. They cover topics such as how to integrate logging, caching, and HTTP clients, to just name a few. You will find a complete list on the official website: <a href="https://www.php-fig.org">https://www.php-fig.org</a>.</p>
			<p class="callout-heading">Problems with PHP-FIG and PSR</p>
			<p class="callout">The PHP-FIG should <a id="_idIndexMarker622"/>not be <a id="_idIndexMarker623"/>considered the official PHP authority, and neither should any PSR be taken as indisputable. In fact, many important frameworks such as <em class="italic">Symfony</em> or <em class="italic">Laravel</em> are not part of the PHP-FIG anymore, since the recommended standards have interfered too much with their internals. Looking at all the PSRs that are available today, you could even regard them as their own meta-framework. This is not to diminish the relevance of many recommendations though – we just want you to not blindly accept them as granted.</p>
			<h3>Enforcing coding standards in your IDE</h3>
			<p>There are<a id="_idIndexMarker624"/> several ways to enforce coding standards. In the previous chapter, <a href="B19050_11.xhtml#_idTextAnchor145"><em class="italic">Chapter 11</em></a><em class="italic">, Continuous Integration</em>, we explained how to make sure that no wrongly formatted code can spoil the code base. This worked fine, yet it requires an additional step, even if we let our tools fix the code formatting automatically because we need to commit those changed files again. So, would it not actually be useful if our code editor, or IDE, would help us with formatting the code while we write it?</p>
			<p>Modern code editors usually have built-in functionality that assists you with adhering to your preferred coding standards, if you configure them. If not built-in, this functionality can at least be provided with plugins.</p>
			<p>There are two basic ways your editor could support you:</p>
			<ul>
				<li><strong class="bold">Highlighting the coding standard violations</strong>: The IDE marks those parts of the source code that need to be corrected. It will not change the code actively though.</li>
				<li><strong class="bold">Reformatting the code</strong>: Either the IDE or an additional plugin takes care of formatting the code, for example, by running a code style fixer such as <strong class="source-inline">PHP_CS_Fixer</strong>. This can be done upon manual request, or every time a file is saved. </li>
			</ul>
			<p>Reformatting the code on file save is a very convenient way to ensure that your code meets the coding standards. How to set this up depends on which IDE you are using, so we will not elaborate on this further in this book.</p>
			<p>We would still recommend<a id="_idIndexMarker625"/> using <strong class="bold">Git hooks</strong> and <strong class="bold">continuous integration</strong> as the <a id="_idIndexMarker626"/>second layer of checks to make sure no badly formatted code gets pushed to the project repository. You can never be sure whether a team member accidentally or willingly disabled the automated reformatting or did not care about the highlighted parts of the code. </p>
			<p><em class="italic">Coding Standards</em> are all <a id="_idIndexMarker627"/>about how to format code consistently. But that is not all you should agree on when working in a team – in the next section, we will show you what other aspects are worth agreeing upon.</p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor179"/>Coding guidelines</h1>
			<p>In the previous section, we talked about why you should introduce <em class="italic">Coding Standards</em>. Once this is<a id="_idIndexMarker628"/> accomplished, you should consider setting up <strong class="bold">coding guidelines</strong>. Both topics sound very familiar, and indeed, they are. Yet while <em class="italic">Coding Standards</em> usually focus on how to format code, coding guidelines define how to write code. This, of course, includes defining which <em class="italic">Coding Standard</em> to use, but covers a lot more, as you will learn in this section.</p>
			<p>What does <em class="italic">how to write code</em> exactly mean? Usually, there is more than one way to achieve things when writing software. Take the widely known <strong class="bold">model-view-controller</strong> (<strong class="bold">MVC</strong>) pattern, for example. It is used to <a id="_idIndexMarker629"/>divide the application logic into three types of interconnected elements – the models, the views, and the controllers. It does not explicitly define where to place the <strong class="bold">business logic</strong>, though. Should <a id="_idIndexMarker630"/>it be located inside the controllers, or rather inside the models?</p>
			<p>There is no clear right or wrong answer to this question. Our recommendation, however, would be the <em class="italic">fat models, skinny controllers</em> approach: business logic should <em class="italic">not</em> be written within the controllers, as they are the binding element between the views and your problem-specific code. Also, the controllers usually contain a lot of framework-specific code, and it is good practice to keep that out of your business logic as much as possible.</p>
			<p>Regardless of our recommendation, it should be defined in the coding guidelines of your project how you think your team should handle this question. Otherwise, you will most likely end up having both approaches in your code base. </p>
			<p>Usually, coding guidelines cover questions such as how to name methods, functions, and properties. As you might know from the famous quote “<em class="italic">There are only two hard things in computer science: cache invalidation and naming things</em>,” finding the right names is indeed not a trivial problem. So, having conventions on this topic at least reduces the time of developers trying to come up with a proper name. Furthermore, the same as <em class="italic">Coding Standards</em>, they help reduce cognitive friction. </p>
			<p>Coding guidelines<a id="_idIndexMarker631"/> help the lesser-experienced developers in your team, or those who just started, to have a solution at hand that they otherwise needed to search for in the code or on the internet. It also helps write maintainable code by avoiding bad practices, as we already discussed in <a href="B19050_03.xhtml#_idTextAnchor031"><em class="italic">Chapter 3</em></a><em class="italic">, Code, Don’t Do Stunts</em>. To help you get started with setting up the first set of rules, we will give you some examples in the next section.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor180"/>Examples of coding guidelines</h2>
			<p>Starting with a blank <a id="_idIndexMarker632"/>sheet of (virtual) paper is hard, so in this section, we collected a list of real-world examples of what could be part of your coding guidelines. Please note that this collection of rules, although they are based on best practices, is not meant to be perfect or the only truth. We rather want to give you a good starting point for discussions and examples on what topics should be clarified using coding guidelines. </p>
			<h3>Naming conventions</h3>
			<p>By using <strong class="bold">naming conventions</strong>, we<a id="_idIndexMarker633"/> make sure that certain elements of our code are being named in a uniform and comprehensible way. This reduces cognitive friction and makes the onboarding of new team members easier.</p>
			<h4>Services, repositories, and models</h4>
			<p>Written<a id="_idIndexMarker634"/> in <em class="italic">UpperCamelCase</em>. Use <a id="_idIndexMarker635"/>the type <a id="_idIndexMarker636"/>as the suffix.</p>
			<p>Here are some examples:</p>
			<ul>
				<li><strong class="source-inline">UserService</strong></li>
				<li><strong class="source-inline">ProductRepository</strong></li>
				<li><strong class="source-inline">OrderModel</strong></li>
			</ul>
			<h4>Events</h4>
			<p>Written in <em class="italic">UpperCamelCase</em>. Use the <a id="_idIndexMarker637"/>correct tense to indicate whether the event is fired before or after the actual event.</p>
			<p>Here are some examples:</p>
			<ul>
				<li><strong class="source-inline">DeletingUser</strong> is the event before the deletion</li>
				<li><strong class="source-inline">DeleteUser</strong> is the actual event</li>
				<li><strong class="source-inline">UserDeleted</strong> is the event after the deletion</li>
			</ul>
			<h4>Properties, variables, and methods</h4>
			<p>Written<a id="_idIndexMarker638"/> in <em class="italic">lowerCamelCase</em>.</p>
			<p>Here <a id="_idIndexMarker639"/>are<a id="_idIndexMarker640"/> some examples:</p>
			<ul>
				<li><strong class="source-inline">$someProperty</strong></li>
				<li><strong class="source-inline">$longerVariableName</strong></li>
				<li><strong class="source-inline">$myMethod</strong></li>
			</ul>
			<h4>Tests</h4>
			<p>Written in <em class="italic">lowerCamelCase</em>. Use<a id="_idIndexMarker641"/> the word <em class="italic">test</em> as a prefix.</p>
			<p>Here are some examples:</p>
			<ul>
				<li><strong class="source-inline">testClassCanDoSomething()</strong></li>
			</ul>
			<h4>Traits</h4>
			<p>Written<a id="_idIndexMarker642"/> in <em class="italic">UpperCamelCase</em>. Use the adjective to describe what the trait is used for.</p>
			<p>Here are some examples:</p>
			<ul>
				<li><strong class="source-inline">Loggable</strong></li>
				<li><strong class="source-inline">Injectable</strong></li>
			</ul>
			<h4>Interfaces</h4>
			<p>Written in <em class="italic">UpperCamelCase</em>. Use<a id="_idIndexMarker643"/> the word <em class="italic">Interface</em> as the suffix.</p>
			<p>Herer are some examples:</p>
			<ul>
				<li><strong class="source-inline">WriterInterface</strong></li>
				<li><strong class="source-inline">LoggerInterface</strong></li>
			</ul>
			<h3>General PHP conventions</h3>
			<p>Even if you already use <em class="italic">Coding Standards</em> such as <em class="italic">PSR-12</em>, there are certain aspects that they do not cover. We <a id="_idIndexMarker644"/>will pick up some of them in this section.</p>
			<h4>Comments and DocBlocks</h4>
			<p>Avoid comments<a id="_idIndexMarker645"/> if possible, as they tend to get outdated and thus confuse more than they help. Only keep comments that cannot be replaced by self-explanatory names or by simplifying code, so it is easier to understand and does not require the comment anymore. </p>
			<p>Only add <strong class="bold">DocBlocks</strong> if they <a id="_idIndexMarker646"/>add information, such as annotations for the code quality tools. Particularly since PHP 8, most DocBlocks can be replaced by type hints, which all modern IDEs will understand. If you use type hints, most DocBlocks can be removed:</p>
			<pre class="source-code">
// Redundant DocBlock
/**
 * @param <strong class="bold">int $property</strong>
 * @return <strong class="bold">void</strong> 
 */
public function setProperty(<strong class="bold">int $property</strong>): <strong class="bold">void</strong> { 
    // ... 
}</pre>
			<p>Often, DocBlocks are <a id="_idIndexMarker647"/>automatically generated by the IDE. If they are not updated, they are at best useless, or can even be plainly wrong:</p>
			<pre class="source-code">
// Useless DocBlock
/**
 * @param $property
 */
public function setProperty(int $property): void { 
    // ... 
}
// Wrong DocBlock
/**
 * @param <strong class="bold">string</strong> $property
 */
public function setProperty(<strong class="bold">int</strong> $property): void { 
    // ... 
}</pre>
			<p>DocBlocks should<a id="_idIndexMarker648"/> still be used for information that cannot be provided by PHP language features until now, such as specifying the content of an array, or marking a function as deprecated:</p>
			<pre class="source-code">
// Useful DocBlock
/**
 * @return <strong class="bold">string[]</strong>
 */
public function getList(): array { 
    return [
       ‘foo’,
       ‘bar’,
    ]; 
}
/**
 * <strong class="bold">@deprecated</strong> use function fooBar() instead
 */
public function foo(): bool { 
    // ... 
}</pre>
			<p class="callout-heading">About DocBlocks</p>
			<p class="callout">DocBlocks were <a id="_idIndexMarker649"/>introduced to, among other things, partially compensate for the shortcomings of weak typing in earlier versions of PHP. The de facto standard was introduced by<a id="_idIndexMarker650"/> the <strong class="source-inline">phpDocumentor</strong> project (<a href="https://www.phpdoc.org/">https://www.phpdoc.org/</a>) and as such is supported by many tools such as IDEs and static code analyzers. Using strict typing, it is often not necessary to use DocBlocks anymore though, unless you want to use <strong class="source-inline">phpDocumentor</strong> in your project.</p>
			<h4>Ternary operators</h4>
			<p>Every part should be written in <a id="_idIndexMarker651"/>a single line to increase readability. Exceptions can be made for very short statements:</p>
			<pre class="source-code">
// Example for short statement
$isFoo ? ‘foo’ : ‘bar’;
// Usual notation
$isLongerVariable
    ? ‘longerFoo’
    : ‘longerBar’;</pre>
			<p>Do not use nested ternary operators, as they are hard to read and debug:</p>
			<pre class="source-code">
// Example for nested operators
$number &gt; 0 ? ‘Positive’ : ($number &lt; 0 ? ‘Negative’ :
‘Zero’);</pre>
			<h4>Constructor</h4>
			<p>Use <strong class="bold">constructor property promotion</strong> for shorter classes, if working with PHP 8+. Keep the trailing comma after the last<a id="_idIndexMarker652"/> property, as this will make it easier to add or comment out lines: </p>
			<pre class="source-code">
// Before PHP 8+
class ExampleDTO
{
    public string $name;
    public function __construct(
        string $name
    ) {
        $this-&gt;name = $name;
    }
}
// Since PHP 8+
class ExampleDTO
{
    public function __construct(
        public string $name, 
    ) {}
}</pre>
			<h4>Arrays</h4>
			<p>Always use the short <a id="_idIndexMarker653"/>array notation and keep the comma after the last entry (see the previous section, <em class="italic">Constructor</em>, for an explanation):</p>
			<pre class="source-code">
// Old notation
$myArray = array(
    ‘first entry’,
    ‘second entry’
);
// Short array notation
$myArray = [
    ‘first entry’,
    ‘second entry’,
];</pre>
			<h4>Control structures</h4>
			<p>Always use<a id="_idIndexMarker654"/> brackets, even for one-liners. This reduces cognitive friction and makes it easier to add more lines of code later:</p>
			<pre class="source-code">
// Bad
if ($statement === true)
    do_something();
// Good
if ($statement === true) {
    do_something();
}</pre>
			<p>Avoid <strong class="source-inline">else</strong> statements and return early, as this is easier to read and reduces the complexity of your code: </p>
			<pre class="source-code">
// Bad
if ($statement) {
    // Statement was successful
    return;
} else {
    // Statement was not successful
    return;
}
// Good
if (!$statement) {
    // Statement was not successful
    return;
}
// Statement was successful
return;</pre>
			<h4>Exception handling</h4>
			<p>Empty <strong class="source-inline">catch</strong> blocks should <a id="_idIndexMarker655"/>be avoided, as they silently swallow error messages and thus can make it difficult to find bugs. Instead, log the error message or at least write a comment that explains why the exception can be ignored:</p>
			<pre class="source-code">
// Bad
try {
    $this-&gt;someUnstableCode();
} catch (Exception $exception) {}
// Good
try {
    someUnstableCode();
} catch (Exception $exception) {
    $this-&gt;logError($exception-&gt;getMessage());
}</pre>
			<h3>Architectural patterns</h3>
			<p>Coding guidelines are not limited to how to <a id="_idIndexMarker656"/>format code or name elements. They can also help you to control how the code is written in an architectural sense.</p>
			<h4>Fat models, skinny controllers</h4>
			<p>If the MVC pattern <a id="_idIndexMarker657"/>is used, the business logic should be located inside <strong class="bold">models</strong> or similar classes, such as <strong class="bold">services</strong> or <strong class="bold">repositories</strong>. <strong class="bold">Controllers</strong> should contain as little code as possible as is required to receive or transfer data between the <strong class="bold">views</strong> and the <strong class="bold">models</strong>.</p>
			<p class="callout-heading">Framework-agnostic code</p>
			<p class="callout">In the context of the <em class="italic">fat models, skinny controllers</em> approach, you will probably come across the term <em class="italic">framework-agnostic business logic</em>. It means that the code that contains your business rules should use as few features of the underlying framework as possible. This makes framework updates or even migrations to other frameworks much easier.</p>
			<h4>Single responsibility principle</h4>
			<p>Classes and methods should only <a id="_idIndexMarker658"/>have one responsibility. See <a href="B19050_02.xhtml#_idTextAnchor021"><em class="italic">Chapter 2</em></a><em class="italic">, Who Gets to Decide What “Good Practices” Are?,</em> for more information about this principle.</p>
			<h3>Framework guidelines</h3>
			<p>In this book, we<a id="_idIndexMarker659"/> want to focus on writing <a id="_idIndexMarker660"/>clean code in PHP. Often, though, you will be working with frameworks, and although it is essential to include them in the guidelines as well, we do not want to go into much more detail here.</p>
			<p>However, next, you will find a list of questions that should give you a good idea about which framework-related topics to include in your guidelines:</p>
			<ul>
				<li>How to access the database</li>
				<li>How to configure routes</li>
				<li>How to register new services</li>
				<li>How is authentication handled within your project?</li>
				<li>How should errors or other debug information be logged?</li>
				<li>How to create and organize view files</li>
				<li>How to<a id="_idIndexMarker661"/> handle <a id="_idIndexMarker662"/>translations</li>
			</ul>
			<p>Since the answers to these questions highly depend on the used framework, we cannot give you recommendations here. You will need to set the guidelines up together with your team. In the next section, we will give you some ideas on how to do that.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor181"/>Setting up guidelines</h2>
			<p>The process of setting up coding guidelines<a id="_idIndexMarker663"/> takes time and often requires several workshops in which the rules are discussed. This requires moderation, for example, by a technical lead; otherwise, you might get stuck in endless discussions. </p>
			<p>Do not worry if you cannot immediately reach an agreement on all topics though. Remind yourself that the people in your team have different backgrounds, experiences, and skill levels – and no one will directly ditch their personal ways of coding just because there are suddenly rules that they do not understand or accept.</p>
			<p>Make sure to set up a process that checks from time to time whether the guidelines need to be updated. Maybe some rules get outdated over time, or new language features must be included. An action point in a regularly occurring team meeting would be a good opportunity for this.</p>
			<p>The guidelines should be easily accessible in written form, such as in a wiki or the company’s internal knowledge base, which should be able to track the version history. Every team member should be able to write comments on it so that questions or issues can be handled as soon as they appear. Lastly, all team members should be automatically informed about new changes.</p>
			<p>Once your team agrees on a set of rules, make sure to utilize the code quality tools you learned about in earlier chapters to automatically check whether the rules are respected. You can, for example, use <em class="italic">PHPStan</em> to detect <a id="_idIndexMarker664"/>empty <strong class="source-inline">catch</strong> blocks, or <em class="italic">PHPMD</em> to <a id="_idIndexMarker665"/>enforce <strong class="source-inline">if</strong> without using <strong class="source-inline">else</strong>. </p>
			<p>How can we ensure that our coding guidelines are applied? Obviously, we should use our code quality tools wherever possible. But what if these tools do not include the rules we would like to enforce? With a bit of internet research, you might be able to find a third-party implementation for them. Or, if you cannot find anything, you could even write custom rules yourself, since all static code analyzers are extendable.</p>
			<p>For rules that are too complicated to check automatically, we have to manually check whether they are used correctly. This can happen in code reviews, and we think they are so important that they deserve their own section in this chapter.</p>
			<p>Setting up coding <a id="_idIndexMarker666"/>guidelines alone will just be a waste of time if you do not make sure that they are kept. We can automate checking all the coding style-related rules and also a fair number of coding guidelines. But at the moment, for those rules that are addressing the framework guidelines or architectural aspects, automation is no longer possible, and we humans must jump in, taking over the checks. At this point, code reviews come into play. Let us have a closer look in the next section.</p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor182"/>Code reviews</h1>
			<p>The <a id="_idIndexMarker667"/>process of manually checking the code of other developers is called a <strong class="bold">code review</strong>. This includes all changes, that is, not only new functionality but also bug fixes or even simple configuration changes.</p>
			<p>A review is always done by at least one fellow developer, and it usually happens in the context of a <strong class="bold">pull request</strong>, shortly before the code of a feature or bug fix branch gets merged into the <strong class="source-inline">main</strong> branch; only if the reviewer approves the changes will they become part of the actual application.</p>
			<p>In this section, we will discuss what you should look for in code reviews, why they are so important, and how they should be done to make them a successful tool in your toolkit.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor183"/>Why you should do code reviews</h2>
			<p>It might sound a bit <a id="_idIndexMarker668"/>obvious because that is what this whole book is about. Yet, it cannot be stressed enough – code reviews will improve the quality of your code. Let us examine more closely why:</p>
			<ul>
				<li><strong class="bold">Easy to introduce</strong>: Introducing code reviews usually comes with no additional costs (except for the required time). All major Git repository services such as <strong class="bold">Bitbucket</strong>, <strong class="bold">GitLab</strong>, or <strong class="bold">GitHub</strong> have a built-in review functionality that you can use immediately.</li>
				<li><strong class="bold">Quick impact</strong>: Code reviews are not only easy to introduce but they will show their usefulness very soon after they have been introduced.</li>
				<li><strong class="bold">Knowledge sharing</strong>: Because code reviews often lead to discussions between the developers, they are a great tool to spread knowledge about best practices in the team. Of course, junior developers especially will massively benefit from the mentoring, but also the most seasoned developers will learn something new from time to time.</li>
				<li><strong class="bold">Constant improvement</strong>: The regular discussions will result in improved coding guidelines, as they are constantly challenged and updated, if necessary.</li>
				<li><strong class="bold">Avoid problems early</strong>: Code<a id="_idIndexMarker669"/> reviews take place very early in the process (see <a href="B19050_11.xhtml#_idTextAnchor145"><em class="italic">Chapter 11</em></a>, <em class="italic">Continuous Integration</em>), so chances are good that bugs, security issues, or architectural problems are found before they even reach the test environment.</li>
			</ul>
			<p>If you are not yet convinced of the benefits of code reviews, check out the next section, in which we will talk more about what code reviews should cover – and what not.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor184"/>What code reviews should cover</h2>
			<p>What aspects should we check when doing code reviews?</p>
			<ul>
				<li><strong class="bold">Code design</strong>: Is the <a id="_idIndexMarker670"/>code well designed and consistent with the rest of the application? Does it follow general best practices, such as reusability, design patterns (see the next section), or <strong class="bold">SOLID</strong> design principles (see <a href="B19050_02.xhtml#_idTextAnchor021"><em class="italic">Chapter 2</em></a><em class="italic">, Who Gets to Decide What "Good Practices" Are?</em>)?</li>
				<li><strong class="bold">Functionality</strong>: Does the code do what it should or does it have any side effects? </li>
				<li><strong class="bold">Readability</strong>: Is the code easy to understand or too complex? Are the comments necessary? Could the readability be improved by renaming a function or a variable, or by extracting code into a function with a meaningful name? </li>
				<li><strong class="bold">Security</strong>: Does the code introduce potential attack vectors? Is all output escaped to prevent XSS attacks? Are database inputs sanitized to avoid SQL injections?</li>
				<li><strong class="bold">Test coverage</strong>: Is the new code covered with automated tests? Do they test the right things? Are more test cases needed?</li>
				<li><strong class="bold">Coding standards and guidelines</strong>: Does the code follow the <em class="italic">Coding Standards</em> and coding guidelines the team <a id="_idIndexMarker671"/>agreed upon?</li>
			</ul>
			<p>Your team should also consider whether testing the code in their local development environment should be part of the review process or not. There is no clear recommendation on this though.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor185"/>Best practices for code reviews</h2>
			<p>Although code <a id="_idIndexMarker672"/>reviews have many benefits and can be implemented fairly easily, there are a few pitfalls that you should be aware of, and established best practices that will make the reviews even more successful.</p>
			<h3>Who should review the code?</h3>
			<p>First and foremost, who should ideally be doing the <em class="italic">code reviews</em>? Of course, this also depends on your setup. If you work in a team together with another PHP developer, then this should surely be the first person to ask. This way, you build up shared domain knowledge; although your colleague has not worked on your ticket directly, they at least get an idea of what you have worked on. </p>
			<p>Yet, reaching out to members of other teams (if there are any) from time to time avoids being stuck in a bubble and fosters knowledge sharing. If you are unsure about certain topics, ask the domain experts for their assistance. Often, this includes performance, architecture, or security-related changes.</p>
			<h3>Automatize</h3>
			<p>One thing that code reviews should not cover is whether the <em class="italic">Coding Standards</em> are kept. In <a href="B19050_07.xhtml#_idTextAnchor084"><em class="italic">Chapter 7</em></a><em class="italic">,Code Quality Tools</em> we introduced the necessary tools to do this automatically, and in <a href="B19050_11.xhtml#_idTextAnchor145"><em class="italic">Chapter 11</em></a>, <em class="italic">Continuous Integration</em>, we integrated them into a <strong class="bold">CI pipeline</strong>. </p>
			<p>Make sure that only those pull requests get reviewed where all the checks (such as <em class="italic">code sniffers, code analyzers, and automated tests</em>) have passed. Otherwise, you will spend a lot of time on topics that should not even be discussed.</p>
			<h3>Avoid long code reviews</h3>
			<p>How many lines should the code change that needs to be reviewed have? Studies suggest that 200 to 400 lines should be the maximum, as the concentration of the reviewer decreases over time. So, try to keep the individual changes relatively small. It is also much more likely for the reviewer to find time to review smaller changes, as for a long tapestry of diffs.</p>
			<p>Code reviews, even <a id="_idIndexMarker673"/>smaller ones, will require time in which the reviewer will not be able to write code. But how much time should be spent? Again, this depends on your setup. A good ballpark number is a maximum of 60 minutes to avoid the fatigue of the reviewer. Allow enough space for the reviewer to review the code line by line. Reviews should be accepted as part of your daily work or they will quickly become a burden, so nobody should rush through them.</p>
			<h3>Stay human</h3>
			<p>How to formulate feedback is crucial to make reviews successful. Watch your tone and try to avoid accusations such as “<em class="italic">This is wrong</em>!” or an absolute no-go, “<em class="italic">This is stupid</em>.” Developers, especially the lesser experienced ones, should not be anxious to let their code be reviewed. </p>
			<p>Remember that a human being will read your comments. It often works well if you write them from the “I” perspective, for example, “<em class="italic">I do not understand this line, can you please explain?</em>” or “<em class="italic">I think we could also do it like this..."</em>  </p>
			<p>Do not forget to use the reviews to give praise for parts that are well done. A quick “<em class="italic">Great idea!</em>” or “<em class="italic">I really like your approach</em>” or “<em class="italic">Thanks for the code cleanup</em>” shows your appreciation of the other developer’s work and increases their motivation.</p>
			<p>Usually, code reviews are done by writing comments on the Git platform you use. But of course, you can also do them face to face. Some developers appreciate direct feedback more than just comments because written text lacks a lot of meta information, such as the tone of voice or the facial expression.</p>
			<h3>Don’t overdo it, but don’t be careless either</h3>
			<p>Remember <a id="_idIndexMarker674"/>the <strong class="bold">Pareto principle</strong> and do not overdo things. Maybe there are still small parts in the code that you would change but that are not explicitly wrong, as they adhere to all the team standards. Programming is still a matter of personal style, and having endless discussions in a code review will lead to frustration without further benefit.</p>
			<p>Do not accept changes that degrade the overall system health though. If you are convinced that a change is harmful or violates the coding guidelines, you must not approve the changes. If in doubt, get another developer involved.</p>
			<h3>Embrace changes</h3>
			<p>Lastly, if you feel an issue that you discussed in a review should be part of the guidelines, note it down and address it in the next team meeting, without mentioning the other developer directly. Maybe you were right and the guidelines will be amended to avoid the issue in the future. </p>
			<p>But you could also<a id="_idIndexMarker675"/> be wrong, and the rest of the team does not see it as a problem. If you cannot come up with convincing arguments and examples, you have to accept those decisions as well.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor186"/>Ensuring code reviews are done</h2>
			<p>During stressful daily <a id="_idIndexMarker676"/>work, with high-priority bug fixes and tight deadlines, it is easy to forget about doing code reviews. Fortunately, all the Git service providers offer functionality to assist you here:</p>
			<ul>
				<li><strong class="bold">Make reviews mandatory</strong>: Most Git repository services can be configured to allow changes only to be merged into the <strong class="source-inline">main</strong> branch if they got at least one approval. You should definitely enable this feature.</li>
				<li><strong class="bold">Rotate reviews</strong>: If your team is larger, try to request the review not always from the same person. Some tools even allow selecting a reviewer randomly for you.</li>
				<li><strong class="bold">Use a checklist</strong>: Checklists have proven to be useful, so you should use them too. Set up a checklist for all the aspects you need to look for in code reviews. In the next section, we <a id="_idIndexMarker677"/>will show you how to make sure it gets used.</li>
			</ul>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor187"/>Definition of done</h2>
			<p>If you work using <strong class="bold">agile methodologies</strong>, you probably heard the term <em class="italic">definition of done</em> already. Here, the <a id="_idIndexMarker678"/>team agrees on a list of actions that should be done before a task is completed.</p>
			<p>A typical <em class="italic">definition of done</em> contains checks <a id="_idIndexMarker679"/>such as whether the test has been written or the documentation updated. You can utilize this for the code reviews as well.</p>
			<p>Again, our Git tools help us by providing templates for pull requests (also called <strong class="bold">merge requests</strong>). These are <a id="_idIndexMarker680"/>texts that will be used to automatically prefill the description of the pull request. </p>
			<p>How that works depends on the software you use, so we cannot give you exact instructions here. The following text, however, shows you an example of what it could look like:</p>
			<pre class="source-code">
# Definition of Done
## Reviewer 
[ ] Code changes reviewed
    1. Coding Guidelines kept
    2. Functionality considered
    3. Code is well-designed
    4. Readability and Complexity considered
    5. No Security issues found
    6. Coding standard and guidelines kept
[ ] Change tested manually
## Developer 
[ ] Acceptance Criteria met
[ ] Automated Tests written or updated
[ ] Documentation written or updated</pre>
			<p>What gets included in the checklist is up to you and your team. If used as a template, these items will always appear in the pull request description by default. It is meant to be used by both the reviewer and the developer to not forget what needs to be done before approving the pull request and merging it into the <strong class="source-inline">main</strong> branch.</p>
			<p>Some tools, such as GitHub, use a <strong class="bold">Markdown</strong>-style markup language<a id="_idIndexMarker681"/> for these templates. They will display the checkboxes (the two square brackets before every item) as clickable checkboxes in the browser and keep track of whether they were clicked or not. Voilà! Without much work, you have set up an easy-to-use and helpful checklist!</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor188"/>Code reviews conclusion</h2>
			<p>We hope this<a id="_idIndexMarker682"/> section gave you good insights into how beneficial code reviews can be for your team and yourself. Since they can be introduced effortlessly, it is worth trying them out. The best practices in this section will help you avoid some of the problems that code reviews could have. </p>
			<p>But, as always, they also have some downsides: reviews take a lot of time and they can lead to conflicts between team members. We are convinced that the time spent pays off well though because the positive aspects outweigh the negative ones by far. The conflicts would most likely happen anyway, and the reviews are just the gauge to vent off steam. This cannot be fully avoided if you work in a team but should be addressed early with your <a id="_idIndexMarker683"/>manager. It is their job to deal with these kinds of problems.</p>
			<p>In the last part of this chapter, we will look at design patterns in more detail. They can act as guidelines on how to solve general problems in software development.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor189"/>Design patterns</h1>
			<p><strong class="bold">Design patterns</strong> are <a id="_idIndexMarker684"/>commonly used solutions to problems that occur regularly in software development. As a developer, you will sooner or later come across this term, if you have not done so already – and not without a reason, as these patterns are based on best practices and have proven their usefulness.</p>
			<p>In this section, we will tell you more about the different types of design patterns and why they are so important that they became part of this book. Furthermore, we will introduce you to some common design patterns that are widely used in PHP.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor190"/>Understanding design patterns</h2>
			<p>Let us have a closer look at<a id="_idIndexMarker685"/> design patterns now. They can be considered templates to solve particular problems and are named according to the solution they provide. For example, in this chapter, you will learn about the <strong class="bold">Observer</strong> pattern, which can<a id="_idIndexMarker686"/> help you to implement a way to observe changes in objects. This is very useful when you write code, but also when you design software with other developers. It is much easier to use a short name to name a concept rather than having to explain it every time. </p>
			<p>Do not mistake design patterns with algorithms though. Algorithms define clear steps that need to be followed to solve a problem, while design patterns describe how to implement the solution on a higher level. They are not bound to any programming language.</p>
			<p>You also cannot add design patterns to your code like you would add a Composer package, for example. You have to implement the pattern on your own, and you have certain degrees of freedom in how you do that.</p>
			<p>However, design patterns<a id="_idIndexMarker687"/> are not the single solution to every problem, nor do they claim to offer the most efficient solutions. Always take these patterns with a grain of salt – often, developers want to implement a certain pattern just because they know it. Or, as the saying goes: "<em class="italic">If all you have is a hammer, everything looks like a nail."</em></p>
			<p>Usually, design patterns are divided into three categories:</p>
			<ul>
				<li><strong class="bold">Creational patterns</strong> deal<a id="_idIndexMarker688"/> with how to efficiently create objects and <a id="_idIndexMarker689"/>at the same time offer solutions to reduce code duplication</li>
				<li><strong class="bold">Structural patterns</strong> help <a id="_idIndexMarker690"/>you organize<a id="_idIndexMarker691"/> relationships between entities (i.e., classes and objects) in flexible and efficient structures</li>
				<li><strong class="bold">Behavioral patterns</strong> arrange<a id="_idIndexMarker692"/> communication <a id="_idIndexMarker693"/>between entities while maintaining a high degree of flexibility</li>
			</ul>
			<p>In the following pages, we will have a look at some example implementations to explain the idea behind <em class="italic">design patterns</em>.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor191"/>Common design patterns in PHP</h2>
			<p>We now want to <a id="_idIndexMarker694"/>introduce some of the most widely used design patterns in the PHP world. We chose one pattern each from the three categories <strong class="bold">Creational</strong>, <strong class="bold">Structural</strong>,<em class="italic"> </em>and <strong class="bold">Behavioral</strong>, which we discussed in the previous section.</p>
			<h3>Factory Method</h3>
			<p>Imagine the <a id="_idIndexMarker695"/>following problem: you need to write an application <a id="_idIndexMarker696"/>that should be able to write data into files using different formats. In our example, we want to support <strong class="bold">CSV</strong> and <strong class="bold">JSON</strong>, but potentially, other formats in the future as well. Before the data is written, we would like to apply some filtering, which should always happen, regardless of which output format is chosen.</p>
			<p>An applicable <a id="_idIndexMarker697"/>pattern to solve this problem would be the <strong class="bold">Factory Method</strong>. It is a Creational pattern, as it deals with the creation of objects.</p>
			<p>The main idea of this <a id="_idIndexMarker698"/>pattern is that subclasses can implement different ways to achieve the goal. It is important to note that we do not use the <strong class="source-inline">new</strong> operator in the parent class to instantiate any subclasses, as you can see in the following class:</p>
			<pre class="source-code">
abstract class AbstractWriter
{
    public function write(array $data): void
    {
        $encoder = $this-&gt;createEncoder();
        // Apply some filtering which should always happen, 
        // regardless of the output format.
        array_walk(
            $data,
            function (&amp;$value) {
                $value = str_replace(‘data’, ‘’, $value);
            }
        );
        // For demonstration purposes, we echo the result
        // here, instead of writing it into a file
        echo $encoder-&gt;encode($data);
    }
    abstract protected function <strong class="bold">createEncoder</strong>(): Encoder;
}</pre>
			<p>Note the <strong class="source-inline">createEncoder</strong> method – this is the factory method that gave the pattern the name, since it acts, in a sense, as a factory for new instances. It is defined as an abstract function, so it needs to be implemented by one or more subclasses.</p>
			<p>To be flexible <a id="_idIndexMarker699"/>enough for future formats, we intend to use separate <strong class="source-inline">Encoder</strong> classes<a id="_idIndexMarker700"/> for each format. But first, we define an interface for these classes so that they are easily exchangeable:</p>
			<pre class="source-code">
interface Encoder
{
    public function encode(array $data): string;
}</pre>
			<p>Then, we create an <strong class="source-inline">Encoder</strong> class for each format that implements the <strong class="source-inline">Encoder</strong> interface; first, we create <strong class="source-inline">JsonEncoder</strong>:</p>
			<pre class="source-code">
class JsonEncoder implements Encoder
{
    public function encode(array $data): string
    {
        // the actual encoding happens here
        // ...
        return $encodedString;
    }
}</pre>
			<p>Then we create <strong class="source-inline">CsvEncoder</strong>:</p>
			<pre class="source-code">
class CsvEncoder implements Encoder
{
    public function encode(array $data): string
    {
        // the actual encoding happens here
        // ...
        return $encodedString;
    }
}</pre>
			<p>Now, we need to <a id="_idIndexMarker701"/>create one subclass of the <strong class="source-inline">AbstractWriter</strong> class for each format we want to support. In <a id="_idIndexMarker702"/>our case, that is <strong class="source-inline">CsvWriter</strong> first: </p>
			<pre class="source-code">
class CsvWriter extends AbstractWriter
{
    public function createEncoder(): Encoder
    {
        $encoder = new CsvEncoder();
        // here, more configuration work would take place
        // e.g. setting the delimiter
        return $encoder;
    }
}</pre>
			<p>And second, it is <strong class="source-inline">JsonWriter</strong>:</p>
			<pre class="source-code">
class JsonWriter extends AbstractWriter
{
    public function createEncoder(): Encoder
    {
        return new JsonEncoder();
    }
}</pre>
			<p>Please note that both subclasses only overwrite the Factory Method <strong class="source-inline">createEncoder</strong>. Also, the <strong class="source-inline">new</strong> operators occur only in the subclasses. The <strong class="source-inline">write</strong> method remains unchanged, as it gets inherited from <strong class="source-inline">AbstractWriter</strong>.</p>
			<p>Finally, let us put<a id="_idIndexMarker703"/> this all <a id="_idIndexMarker704"/>together in an example script:</p>
			<pre class="source-code">
function factoryMethodExample(AbstractWriter $writer)
{
    $exampleData = [
        ‘set1’ =&gt; [‘data1’, ‘data2’],
        ‘set2’ =&gt; [‘data3’, ‘data4’],
    ];
    $writer-&gt;write($exampleData);
}
echo "Output using the CsvWriter: ";
factoryMethodExample(new CsvWriter());
echo "Output using the JsonWriter: ";
factoryMethodExample(new JsonWriter());</pre>
			<p>The <strong class="source-inline">factoryMethodExample</strong> function first receives <strong class="source-inline">CsvWriter</strong> and, for the second run, <strong class="source-inline">JsonWriter</strong> as parameters. The output will look like this:</p>
			<pre class="source-code">
Output using the CsvWriter:
3,4
1,2
 
Output using the JsonWriter:
[["3","4"],["1","2"]]</pre>
			<p>The <a id="_idIndexMarker705"/>Factory Method pattern enables us to move the instantiation of the <strong class="source-inline">Encoder</strong> class away from the <strong class="source-inline">AbstractWriter</strong> parent class into the subclasses. By doing this, we<a id="_idIndexMarker706"/> avoid tight coupling between <strong class="source-inline">Writer</strong> and <strong class="source-inline">Encoder</strong>, gaining much more flexibility. As a downside, the code becomes more complex, as we have to introduce interfaces and subclasses to implement this pattern.</p>
			<h3>Dependency injection</h3>
			<p>The next pattern we want to <a id="_idIndexMarker707"/>introduce is a Structural pattern called <strong class="bold">Dependency Injection</strong> (<strong class="bold">DI</strong>). It helps us to <a id="_idIndexMarker708"/>implement a loosely coupled architecture by inserting dependencies into classes already at construction time, instead of instantiating them inside the class.</p>
			<p>The following code shows you how a dependency, in this example, a classic <strong class="bold">Logger</strong>, gets instantiated within the constructor:</p>
			<pre class="source-code">
class InstantiationExample
{
    private Logger $logger;
    public function __construct()
    {
        $this-&gt;logger = new FileLogger();
    }
}</pre>
			<p>The code itself works perfectly fine, yet the problems start when you want to replace <strong class="source-inline">FileLogger</strong> with a different class. Although we already use the <strong class="source-inline">Logger</strong> interface for the <strong class="source-inline">$logger</strong> property, which<a id="_idIndexMarker709"/> theoretically makes it easy to exchange it with another implementation, we have hardcoded <strong class="source-inline">FileLogger</strong> in the constructor. Now, imagine you used that<a id="_idIndexMarker710"/> logger in almost every class; replacing it with a different <strong class="source-inline">Logger</strong> implementation causes some effort, as you would have to touch every single file that uses it.</p>
			<p>Not being able to replace <strong class="source-inline">FileLogger</strong> also makes writing <strong class="bold">unit tests</strong> for the class more difficult. You cannot replace it with a mock, but you also do not want to write information to your actual logs during test runs. If you want to test that the logging works correctly, you have to build quite some workarounds into your code that is also used in production.</p>
			<p>DI forces us to think about which, and how many, dependencies should be used in a class. It is considered a <strong class="bold">code smell</strong> (i.e., an indicator for badly structured code) when the constructor takes considerably<a id="_idIndexMarker711"/> more than three or four dependencies as a<a id="_idIndexMarker712"/> parameter because it indicates that the class violates the <strong class="bold">single responsibility principle</strong> (the “<strong class="bold">S</strong>” in <strong class="bold">SOLID</strong>). This is also known as <strong class="bold">scope creep</strong>: the <a id="_idIndexMarker713"/>scope of a class slowly but steadily gets bigger over time.</p>
			<p>Let us now see how DI would solve the previously mentioned problems:</p>
			<pre class="source-code">
class ConstructorInjection
{
    private Logger $logger;
    public function __construct(Logger $logger)
    {
        $this-&gt;logger = $logger;
    }
}</pre>
			<p class="callout-heading">Constructor property promotion</p>
			<p class="callout">Please note that we did not use constructor property promotion purposely here for better visualization.</p>
			<p>The difference to the previous code does not seem to be that big. All we did was pass over the <strong class="source-inline">Logger</strong> instance as a parameter to the constructor instead of instantiating it there directly. The benefit is huge though: we can now change the instance that gets injected (if it implements the <strong class="source-inline">Logger</strong> interface) without touching the actual class. </p>
			<p>Imagine you no longer want the class to log into the filesystem, but rather into a <strong class="bold">log management system</strong> such as <strong class="bold">Graylog</strong>, which <a id="_idIndexMarker714"/>manages all the logs from <a id="_idIndexMarker715"/>your different applications in one place. All you need to do is to create <strong class="source-inline">GraylogLogger</strong>, which implements the <strong class="source-inline">Logger</strong> interface as well but writes the logs to this system instead of into files. Then, you simply inject <strong class="source-inline">GraylogLogger</strong> instead of <strong class="source-inline">FileLogger</strong> into all classes that should use it – congratulations, you just changed the way your applications log information without touching the actual classes. </p>
			<p>Likewise, we can easily exchange a dependency with a mock object in our unit tests. This is a massive improvement regarding testability.</p>
			<p>The instantiation of <strong class="source-inline">Logger</strong>, however, no matter which implementation you chose, still has to happen somewhere else. We just moved it out of the <strong class="source-inline">InjectionExample</strong> class. The dependency gets injected when the class gets instantiated:</p>
			<pre class="source-code">
$constructorInjection = new ConstructorInjection(
     new FileLogger()
);</pre>
			<p>Usually, you would find this kind of instantiation within a <strong class="source-inline">Factory</strong> class. This is a class that implements, for example, the <strong class="bold">Simple Factory</strong> pattern and whose only job is to create instances of a certain class, with<a id="_idIndexMarker716"/> all the necessary dependencies.</p>
			<p class="callout-heading">Simple Factory pattern</p>
			<p class="callout">We do not discuss this pattern in more detail in this book because it is, well, really simple. You can find more<a id="_idIndexMarker717"/> information about it here: <a href="https://designpatternsphp.readthedocs.io/en/latest/Creational/SimpleFactory/README.html">https://designpatternsphp.readthedocs.io/en/latest/Creational/SimpleFactory/README.html</a>.</p>
			<p>The injection does not necessarily need to happen through the constructor. Another possible approach is the <a id="_idIndexMarker718"/>so-called <strong class="bold">setter injection</strong>:</p>
			<pre class="source-code">
class SetterInjection
{
    private Logger $logger;
    public function __construct()
    {
        // ....
    }
    public function setLogger(Logger $logger): void
    {
        $this-&gt;logger = $logger;
    }
}</pre>
			<p>The injection of the dependency would then happen using the <strong class="source-inline">setLogger</strong> method. The same as for the <strong class="bold">constructor injection</strong>, this<a id="_idIndexMarker719"/> would most likely happen within the <strong class="source-inline">Factory</strong> class. </p>
			<p>The following is an example of what such a <strong class="bold">factory</strong> could look like:</p>
			<pre class="source-code">
class SetterInjectionFactory
{
    public function createInstance(): SetterInjection
    {
        $setterInjection = new SetterInjection();
        $setterInjection-&gt;setLogger(new FileLogger());
        return $setterInjection;
    }
}</pre>
			<h4>Dependency injection container</h4>
			<p>You probably already <a id="_idIndexMarker720"/>wondered how to manage all the factories that are necessary, especially in a larger project. For this, the <strong class="bold">DI container</strong> has been invented. It is not part of the DI pattern, yet closely related, so we want to introduce it here.</p>
			<p>The DI container acts as central storage for all objects that are brought into their target classes using DI patterns. It also contains all the necessary information to instantiate the objects.</p>
			<p>It also can store created instances so it does not have to instantiate them twice. For example, you would not create a <strong class="source-inline">FileLogger</strong> instance for each class that uses it, as this would end up in plenty of identical instances. You rather want to create it once and then pass it over by reference to its destination classes.</p>
			<p class="callout-heading">DI container</p>
			<p class="callout">Showing all the functionality of a modern DI container would exceed this book. If you are interested in learning more <a id="_idIndexMarker721"/>about this concept, we recommend you to check out the <strong class="source-inline">phpleague/container</strong> package: <a href="https://container.thephpleague.com">https://container.thephpleague.com</a>. It is small yet feature-rich and has great documentation that can introduce you to more exciting concepts such as service providers or inflectors.</p>
			<p>The concept of the <a id="_idIndexMarker722"/>DI container has been adopted in all major PHP frameworks nowadays, so you have most likely used such a container already. You probably did not notice it though, because it is usually hidden deep in the back of your application and is<a id="_idIndexMarker723"/> sometimes also referred to as a <strong class="bold">service container</strong>.</p>
			<p class="callout-heading">PSR-11 – Container interface</p>
			<p class="callout">The DI container is so important to the PHP ecosystem that it got its own PSR: <a href="https://www.php-fig.org/psr/psr-11">https://www.php-fig.org/psr/psr-11</a>.</p>
			<h3>Observer</h3>
			<p>The last pattern we want to introduce in this <a id="_idIndexMarker724"/>book is the <strong class="bold">Observer</strong> pattern. As a <em class="italic">Behavioral pattern</em>, its main purpose is to allow efficient communication <a id="_idIndexMarker725"/>between objects. A common task to implement is to trigger a certain action on one object when the state of another object changes. A state change could be something as simple as a value change of a class property.</p>
			<p>Let us start with another example: you have to send out an email to the sales team every time a customer cancels their subscription so that they get informed and can do countermeasures to keep the customer. </p>
			<p>How do you best do that? You could, for example, set up a recurring job that checks within a certain time interval (e.g., every 5 minutes) whether there had been any cancellations since the check. This would work, but depending on the size of your customer base, the job would probably not return any results most of the time. If the interval between two checks, on the other hand, is too long, you might lose valuable time until the next check.  </p>
			<p>Now, sales might not be the most time-critical thing in the world (salespeople usually disagree here), but you surely get the idea. Wouldn’t it be great if we could just send out the email as soon as the customer cancels the subscription? So, instead of regularly checking for changes, we <a id="_idIndexMarker726"/>only get informed at the moment when the <a id="_idIndexMarker727"/>change happens?</p>
			<p>The code could look like this simplified example:</p>
			<pre class="source-code">
class CustomerAccount
{
    public function __construct(
        private MailService $mailService
    ) {}
    public function cancelSubscription(): void
    {
        // Required code for the actual cancellation
        // ...
        $this-&gt;mailService-&gt;sendEmail(
            ‘sales@example.com’,
            ‘Account xy has cancelled the subscription’
        );
    }
}</pre>
			<p class="callout-heading">Simplified example</p>
			<p class="callout">The example has been simplified. You should, for example, not hardcode the email address. </p>
			<p>That approach would surely work, but it has a drawback: the call of <strong class="source-inline">MailService</strong> is directly coded into the class and hence is tightly coupled to it. And now, the <strong class="source-inline">CustomerAccount</strong> class has to care about another dependency, which increases the maintenance effort, as the tests have to be extended, for example. If we later do not want to send this email anymore or even send an additional email to another department, <strong class="source-inline">CustomerAccount</strong> has to be changed again.</p>
			<p>Using a loosely coupled approach, the <strong class="source-inline">CustomerAccount</strong> object would only store a list of other objects that it should notify in case of a change. The list is not hardcoded, and the objects that need to get notified have to be attached to that list during the bootstrap phase. </p>
			<p>The object that we <a id="_idIndexMarker728"/>want to be observed (in the preceding example, <strong class="source-inline">CustomerAccount</strong>), is called the <strong class="bold">subject</strong>. The subject is responsible for informing<a id="_idIndexMarker729"/> the <strong class="bold">observers</strong>. No code change would be necessary on the subject to add or remove observers, so this approach is very flexible.</p>
			<p>The following code shows an example of how the <strong class="source-inline">CustomerAccount</strong> class could implement the <strong class="bold">Observer</strong> pattern:</p>
			<pre class="source-code">
use SplSubject;
use SplObjectStorage;
use SplObserver;
class CustomerAccount implements SplSubject
{
    private SplObjectStorage $observers;
    public function __construct()
    {
        $this-&gt;observers = new SplObjectStorage();
    }
    public function attach(SplObserver $observer): void
    {
        $this-&gt;observers-&gt;attach($observer);
    }
    public function detach(SplObserver $observer): void
    {
        $this-&gt;observers-&gt;detach($observer);
    }
    public function notify(): void
    {
        foreach ($this-&gt;observers as $observer) {
            $observer-&gt;update($this);
        }
    }
    public function cancelSubscription(): void
    {
        // Required code for the actual cancellation
        // ...
        $this-&gt;notify();
    }
}</pre>
			<p>A lot has happened here, so let us go through it bit by bit. The first thing notable is that the class makes use of the <strong class="source-inline">SplSubject</strong> and <strong class="source-inline">SplObserver</strong> interfaces, as well as the <strong class="source-inline">SplObjectStorage</strong> class. Since the <strong class="source-inline">CustomerAccount</strong> class implements the <strong class="source-inline">SplSubject</strong> interface, it has to provide the <strong class="source-inline">attach</strong>, <strong class="source-inline">detach</strong>, and <strong class="source-inline">notify</strong> methods.</p>
			<p>We also use the constructor to initialize the <strong class="source-inline">$observers</strong> property as <strong class="source-inline">SplObjectStorage</strong>, which will store all observers of the <strong class="source-inline">CustomerAccount</strong> class. Luckily, the SPL provides the<a id="_idIndexMarker730"/> implementation of this storage already, so we do not need to do it.</p>
			<p class="callout-heading">Standard PHP Library</p>
			<p class="callout">We talked about the <strong class="bold">Standard PHP L</strong><strong class="bold">ibrary</strong> (<strong class="bold">SPL</strong>) in <a href="B19050_03.xhtml#_idTextAnchor031"><em class="italic">Chapter 3</em></a><em class="italic">, Code Quality Metrics</em> already. The fact that the SPL includes these entities shows the importance of the Observer pattern as well as the usefulness of this library.</p>
			<p>The <strong class="source-inline">attach</strong> and <strong class="source-inline">detach</strong> methods <a id="_idIndexMarker731"/>are required by the <strong class="source-inline">SplSubject</strong> interface. They are used for adding or removing observers. Their implementation is easy – we just need to forward the <strong class="source-inline">SplObserver</strong> object to <strong class="source-inline">SplObjectStorage</strong> in both cases, which takes over the necessary work for us.</p>
			<p>The <strong class="source-inline">notify</strong> method has to call the <strong class="source-inline">update</strong> method on all <strong class="source-inline">SplObserver</strong> objects that are stored in <strong class="source-inline">SplObjectStorage</strong>. This is as simple as using a <strong class="source-inline">foreach</strong> loop to iterate over all <strong class="source-inline">SplObserver</strong> entries and call their <strong class="source-inline">update</strong> method, passing over a reference to the subject using <strong class="source-inline">$this</strong>.</p>
			<p>The following code shows what such an observer could look like:</p>
			<pre class="source-code">
class CustomerAccountObserver implements SplObserver
{
    public function __construct(
        private MailService $mailService
    ) {}
    public function update(CustomerAccount|SplSubject
      $splSubject): void
    {
        $this-&gt;mailService-&gt;sendEmail(
            ‘sales@example.com’,
            ‘Account ‘ . $splSubject-&gt;id . ‘ has cancelled
              the subscription’
        );
    }
}</pre>
			<p>The observer, not surprisingly, implements the <strong class="source-inline">SplObserver</strong> interface. The only required method is <strong class="source-inline">update</strong>, which gets called from the subject in the <strong class="source-inline">notify</strong> method. Since the interface requires the <strong class="source-inline">$splSubject</strong> parameter to implement the <strong class="source-inline">SplSubject</strong> interface, we have to use that parameter type hint. It would lead to a PHP error otherwise.</p>
			<p>Since we know that, in this <a id="_idIndexMarker732"/>case, the object is actually a <strong class="source-inline">CustomerAccount</strong> object, we <a id="_idIndexMarker733"/>can add this type hint as well. This will enable our IDE to help us with the proper code completion; it is not required to add it though.</p>
			<p>As you can see, all the logic regarding the email sending has now moved into <strong class="source-inline">CustomerAccountObserver</strong>. In other words, we successfully eliminated the tight coupling between <strong class="source-inline">CustomerAccount</strong> and <strong class="source-inline">MailService</strong>. </p>
			<p>The last thing we need to do is to attach <strong class="source-inline">CustomerAccountObserver</strong>:</p>
			<pre class="source-code">
$mailService = new MailService();
$observer = new CustomerAccountObserver($mailService);
$customerAccount = new CustomerAccount();
$customerAccount-&gt;attach($observer);</pre>
			<p>Again, this code example is simplified. In a real-world application, all three objects would be instantiated in dedicated factories and brought together by a DI container.</p>
			<p>The Observer<a id="_idIndexMarker734"/> pattern helps you to decouple objects with a relatively<a id="_idIndexMarker735"/> low amount of work. It has a few drawbacks though. The order in which the observers are updated cannot be controlled; thus, you cannot use it to implement functionality where the order is crucial. Second, by decoupling the classes, it is no longer obvious just by looking at the code which observers are attached to it. </p>
			<p>To sum up the topic of <em class="italic">design patterns</em>, we will have a look at those patterns that are still quite common today but have proven to have too significant drawbacks to be recommended. Curtain up for the Anti-patterns!   </p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor192"/>Anti-patterns</h2>
			<p>Not every <em class="italic">design pattern</em> stood the test of time. Everything evolves, and so do software development and PHP. Some <a id="_idIndexMarker736"/>patterns that have been successful in the past have been replaced by newer and/or better versions. </p>
			<p>What was once the standard approach to solving a problem a couple of years ago might not be the right solution anymore. The PHP community keeps learning and improving, but this knowledge is not yet evenly distributed. Thus, to make it more obvious which patterns should be avoided, they are often referred to as Anti-patterns – this clearly sounds like something you would not like to have in your code, right?</p>
			<p>What does such an <strong class="bold">Anti-Pattern</strong> look like? Let us have a look at the first example.</p>
			<h3>Singleton</h3>
			<p>Before DI became<a id="_idIndexMarker737"/> increasingly popular in the PHP world, we already had to deal with the problem of how to effectively create instances and how to make them available in the scopes of other classes. The <strong class="bold">Singleton</strong> pattern<a id="_idIndexMarker738"/> offered a quick and easy solution that usually looked something like this:</p>
			<p class="source-code">$instance = Singleton::getInstance();</p>
			<p>The static <strong class="source-inline">getInstance</strong> method is surprisingly simple:</p>
			<pre class="source-code">
class Singleton
{
    private static ?Singleton $instance = null;
    public static function getInstance(): Singleton
    {
        if (self::$instance === null) {
            self::$instance = new self();
        }
        return self::$instance;
    }
}</pre>
			<p>If the method gets <a id="_idIndexMarker739"/>executed, it is checked whether an instance of the class has<a id="_idIndexMarker740"/> already been created. If yes, it will be returned; if not, it will be created beforehand. This approach is also <a id="_idIndexMarker741"/>called <strong class="bold">lazy initialization</strong>. Being lazy is a good thing here because it only gets initialized when it is required, so it saves resources.</p>
			<p>The method furthermore stores the new instance in the static <strong class="source-inline">$instance</strong> property. This is remarkable as the approach is only possible because static properties can have a value without requiring a class instance. In other words, we can store the instance of a class in its own class definition. Also, in PHP, all objects are passed as a reference, that is, as a pointer to the object in memory. Both peculiarities help us to make sure that the same instance is always returned. </p>
			<p>The Singleton actually is quite elegant; as it also uses a static method, it needs no instance of the <strong class="source-inline">Singleton</strong> class as well. This way, it can literally be executed everywhere in your code, without any further preparation. </p>
			<p>The ease of use is one of the main reasons why Singleton eventually became an Anti-Pattern, since it leads <a id="_idIndexMarker742"/>to <strong class="bold">scope creep</strong>. We explained this problem in the section about DI.</p>
			<p>Another problem is testability: it is very hard to replace the instance with a mock object, so writing unit tests for code that uses the Singleton pattern became much more complex.</p>
			<p>Nowadays, you should use DI together with a DI container. It is not as easy to use as the Singleton, but that in turn helps us to think twice before we use another dependency in a class. </p>
			<p>However, it does<a id="_idIndexMarker743"/> not mean that the Singleton pattern must not be used at all. There <a id="_idIndexMarker744"/>might be valid reasons to implement it, or at least to keep it in a legacy project. Just be aware of the risks.</p>
			<h3>Service locator</h3>
			<p>The<a id="_idIndexMarker745"/> second pattern <a id="_idIndexMarker746"/>that could be considered problematic is <strong class="bold">Service Locator</strong>: </p>
			<pre class="source-code">
class ServiceLocatorExample
{
    public function __construct(
        private ServiceLocator $serviceLocator
    ) {}
    public function fooBar(): void
    {
        $someService = $this-&gt;serviceLocator
          -&gt;get(SomeService::class);
        $someService-&gt;doSomething();
    }
}</pre>
			<p>In this example class, we inject <strong class="source-inline">ServiceLocator</strong> during the construction time of the object. It is then used throughout the class to fetch the required dependencies. In these regards, DI and the Service Locator are both implementations of <a id="_idIndexMarker747"/>the <strong class="bold">dependency inversion</strong> principle (the “<strong class="bold">D</strong>” in <strong class="bold">SOLID</strong>): they move the control about their dependencies out of the class scope, helping us to achieve a loosely coupled architecture.</p>
			<p>But, if we only need to inject one dependency instead of many, is that not a great idea? Well, the drawback of the Service Locator pattern is that it hides the dependencies of the class behind the <strong class="source-inline">ServiceLocator</strong> instance. While with DI you can clearly see which dependencies are used by looking at the constructor, you cannot do that when injecting only <strong class="source-inline">ServiceLocator</strong>.</p>
			<p>Unlike DI, it does not force us to question which dependencies should be used in a class as, for larger classes, you can quickly lose the overview of which dependencies are used in a class. This is<a id="_idIndexMarker748"/> basically one of the main drawbacks we identified for <a id="_idIndexMarker749"/>the Singleton pattern. </p>
			<p>Yet again, we do not want to be dogmatic when it comes to the use of the <em class="italic">Service Locator</em> pattern. There might be situations where it is appropriate to use it – just handle it with care.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor193"/>Summary</h1>
			<p>In this chapter, we discussed the importance of standards and guidelines. Coding standards help you to align with fellow developers on how the code should be formatted, and you learned about existing standards worth adopting. </p>
			<p>Coding guidelines help your team to align on how to write software. Although these guidelines are highly individual for each team, we provided you with a good set of examples and best practices to build your team’s guidelines. With code reviews, you also know how to keep the quality up.</p>
			<p>Finally, we introduced you to the world of design patterns. We are confident that knowing at least a good part of these patterns will help you to design and write high-quality code together with your team members. There is much more to explore on this topic, and you will find links to some great sources at the end of this chapter.</p>
			<p>This almost ends our exciting journey through the many aspects of clean code in PHP. We are sure you now want to use all your new knowledge in your daily work as soon as possible. Yet, before you do, bear with us for the last chapter, when we talk about the importance of documentation.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor194"/>Further reading</h1>
			<ul>
				<li><a href="https://google.github.io/eng-practices/review">https://google.github.io/eng-practices/review</a> provides you with more information about the <em class="italic">code review</em> process at Google</li>
				<li>Useful sources about <em class="italic">design patterns</em> in PHP:<ul><li><a href="https://refactoring.guru/design-patterns/adapter/php/example">https://refactoring.guru/design-patterns/adapter/php/example</a></li><li><a href="https://sourcemaking.com/design_patterns/adapter/php">https://sourcemaking.com/design_patterns/adapter/php</a></li><li><a href="https://designpatternsphp.readthedocs.io/en/latest/README.html">https://designpatternsphp.readthedocs.io/en/latest/README.html</a></li></ul></li>
			</ul>
		</div>
	</body></html>