<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Standard PHP Library"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Standard PHP Library</h1></div></div></div><p>PHP5 made a developer's life a lot easier than before by introducing a number of built-in objects. These objects simplify tasks and saves countless sleepless nights for a lot of coders like me. <span class="strong"><strong>Standard PHP Library</strong></span> (<span class="strong"><strong>SPL</strong></span>) is a set of objects for PHP developers introduced in PHP5. They come with a lot of interfaces and objects to simplify your coding. In this chapter we will go through some of them and show you their use. </p><div class="section" title="Available Objects in SPL"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec59"/>Available Objects in SPL</h1></div></div></div><a id="id245" class="indexterm"/><a id="id246" class="indexterm"/><p>You can find out the available objects in SPL by executing the following code.</p><div class="informalexample"><pre class="programlisting">&lt;?php
// a simple foreach() to traverse the SPL class names
foreach(spl_classes() as $key=&gt;$value)
  {
    echo $value."\n";
  }
?&gt;</pre></div><p>The result will show you all the available classes in your current PHP install:</p><div class="informalexample"><pre class="programlisting">AppendIterator
ArrayIterator
ArrayObject
BadFunctionCallException
BadMethodCallException
CachingIterator
Countable
DirectoryIterator
DomainException
EmptyIterator
FilterIterator
InfiniteIterator
InvalidArgumentException
IteratorIterator
LengthException
LimitIterator
LogicException
NoRewindIterator
OuterIterator
OutOfBoundsException
OutOfRangeException
OverflowException
ParentIterator
RangeException
RecursiveArrayIterator
RecursiveCachingIterator
RecursiveDirectoryIterator
RecursiveFilterIterator
RecursiveIterator
RecursiveIteratorIterator
RuntimeException
SeekableIterator
SimpleXMLIterator
SplFileObject
SplObjectStorage
SplObserver
SplSubject
UnderflowException
UnexpectedValueException</pre></div></div></div>
<div class="section" title="ArrayObject"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec60"/>ArrayObject</h1></div></div></div><a id="id247" class="indexterm"/><a id="id248" class="indexterm"/><p>This is a fantastic object introduced in SPL to simplify array operation and to enrich the normal PHP array. You can use <code class="literal">ArrayObject</code> as a simple array however internally you can enhance it and add new functionalities gradually. In this section we will see the properties and methods supported by this object. Also, we will design an enhanced <code class="literal">ArrayObject</code> for easier array access. </p><p>Here are the public members of this class:<a id="id249" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">__construct</code> <code class="literal">($array,</code> <code class="literal">$flags=0,</code> <code class="literal">$iterator_class="ArrayIterator")</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">append</code> <code class="literal">($value)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">asort</code> <code class="literal">()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">count</code> <code class="literal">()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">exchangeArray</code> <code class="literal">($array)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">getArrayCopy</code> <code class="literal">()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">getFlags</code> <code class="literal">()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">getIterator</code> <code class="literal">()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">getIteratorClass</code> <code class="literal">()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ksort</code> <code class="literal">()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">natcasesort</code> <code class="literal">()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">natsort</code> <code class="literal">()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">offsetExists</code> <code class="literal">($index)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">offsetGet</code> <code class="literal">($index)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">offsetSet</code> <code class="literal">($index,</code> <code class="literal">$newval)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">offsetUnset</code> <code class="literal">($index)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">setFlags</code> <code class="literal">($flags)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">setIteratorClass</code> <code class="literal">($itertor_class)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">uasort</code> <code class="literal">(mixed</code> <code class="literal">cmp_function)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">uksort</code> <code class="literal">(mixed</code> <code class="literal">cmp_function)</code><a id="id250" class="indexterm"/></li></ul></div><p>Many of these functions are also available for array operation. Here is a brief introduction about some functions, which are differentl to those from array functions: <a id="id251" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Function</p>
</th><th style="text-align: left" valign="bottom">
<p>Feature</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">exchangeArray($array)</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This function replaces the internal array of an <code class="literal">ArrayObject</code> with the new one and returns the old one.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">getArrayCopy()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This function returns a copy of the internal array from inside this <code class="literal">ArrayObject</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">getIteratorClass()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This function returns the name of the <code class="literal">Iterator</code> class. If you don't explicitly set any other <code class="literal">Iterator</code> class for this object, you will always get <code class="literal">ArrayIterator</code> as the result.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">setIteratorClass()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Using this function you can set any <code class="literal">Iterator</code> class as the Iterator for array object. However there is one limitation; is one limitation; this <code class="literal">Iterator</code> class must extend the <code class="literal">arrayIterator</code> class.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">setFlags()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This function sets some bitwise flags to <code class="literal">ArrayObject</code>. Flags are <code class="literal">0</code> or <code class="literal">1</code>. <code class="literal">0</code>, which means properties of the object have their normal functionality when accessed as list (<code class="literal">var_dump</code>, <code class="literal">foreach</code>, etc.) and <code class="literal">1</code> means array indices can be accessed as properties in read/write.</p>
</td></tr></tbody></table></div><p>In the interesting example shown below, we are extending <code class="literal">ArrayObject</code> and creating a more flexible <code class="literal">ExtendedArrayObject</code> for prototype like functionality. The extended array provides easier traversing through the collection. Let's have a look: <a id="id252" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?
class ExtendedArrayObject extends ArrayObject {

  private $_array;
  public function __construct()
  {
    if (is_array(func_get_arg(0)))
    $this-&gt;_array = func_get_arg(0);
    else
    $this-&gt;_array = func_get_args();
    parent::__construct($this-&gt;_array);
  }

  public function each($callback)
  {
    $iterator = $this-&gt;getIterator();

    while($iterator-&gt;valid()) 
    {
      $callback($iterator-&gt;current());
      $iterator-&gt;next();
    }

  }

  public function without()
  {
    $args = func_get_args();
    return array_values(array_diff($this-&gt;_array,$args));
  }

  public function first()
  {
    return $this-&gt;_array[0];
  }

  public function indexOf($value)
  {
    return array_search($value,$this-&gt;_array);
  }

  public function inspect()
  {
    echo "&lt;pre&gt;".print_r($this-&gt;_array, true)."&lt;/pre&gt;";
  }

  public function last()
  {
    return $this-&gt;_array[count($this-&gt;_array)-1];
  }

  public function reverse($applyToSelf=false)
  {
    if (!$applyToSelf)
    return array_reverse($this-&gt;_array);
    else 
    {
      $_array = array_reverse($this-&gt;_array);
      $this-&gt;_array = $_array;
      parent::__construct($this-&gt;_array);
      return $this-&gt;_array;
    }
  }

  public function shift()
  {
    $_element = array_shift($this-&gt;_array);
    parent::__construct($this-&gt;_array);
    return $_element;
  }

  public function pop()
  {
    $_element = array_pop($this-&gt;_array);
    parent::__construct($this-&gt;_array);
    return $_element;
  }
}
?&gt;</pre></div><p>If you want to see how to use it, here it goes:</p><div class="informalexample"><pre class="programlisting">&lt;?
include_once("ExtendedArrayObject.class.php");

function speak($value)
{
  echo $value;

}

$newArray = new ExtendedArrayObject(array(1,2,3,4,5,6));

/* or you can use this */

$newArray = new ExtendedArrayObject(1,2,3,4,5,6);

$newArray-&gt;each(speak); //pass callback for loop
print_r($newArray-&gt;without(2,3,4)); //subtract
$newArray-&gt;inspect(); //display the array in a nice manner
echo $newArray-&gt;indexOf(5); //position by value
print_r($newArray-&gt;reverse()); //reverse the array
print_r($newArray-&gt;reverse(true)); /*for changing array itself*/

echo $newArray-&gt;shift();//shifts the first value of the array 
                       //and returns it
echo $newArray-&gt;pop();// pops out the last value of array
echo $newArray-&gt;last();
echo $newArray-&gt;first(); //the first element
?&gt;</pre></div><p>The result looks like this:<a id="id253" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">123456
Array
(
    [0] =&gt; 1
    [1] =&gt; 5
    [2] =&gt; 6
)
Array
(
    [0] =&gt; 1
    [1] =&gt; 2
    [2] =&gt; 3
    [3] =&gt; 4
    [4] =&gt; 5
    [5] =&gt; 6
)
4
Array
(
    [0] =&gt; 6
    [1] =&gt; 5
    [2] =&gt; 4
    [3] =&gt; 3
    [4] =&gt; 2
    [5] =&gt; 1
)
Array
(
    [0] =&gt; 6
    [1] =&gt; 5
    [2] =&gt; 4
    [3] =&gt; 3
    [4] =&gt; 2
    [5] =&gt; 1
)
6125<a id="id254" class="indexterm"/>
</pre></div></div>
<div class="section" title="ArrayIterator"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec61"/>ArrayIterator</h1></div></div></div><a id="id255" class="indexterm"/><a id="id256" class="indexterm"/><p>
<code class="literal">ArrayIterator</code> is used to iterate over the elements of an array. In SPL, <code class="literal">ArrayObject</code> has a built-in Iterator, which you can access using <code class="literal">getIterator</code> function. You can use this object to iterate over any collection. Let's take a look at the example here: <a id="id257" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
$fruits = array(  
    "apple" =&gt; "yummy",
    "orange" =&gt; "ah ya, nice",
    "grape" =&gt; "wow, I love it!",
    "plum" =&gt; "nah, not me"
);

$obj = new ArrayObject( $fruits );

$it = $obj-&gt;getIterator();

// How many items are we iterating over?
echo "Iterating over: " . $obj-&gt;count() . " values\n";

// Iterate over the values in the ArrayObject:
while( $it-&gt;valid() )
{
    echo $it-&gt;key() . "=" . $it-&gt;current() . "\n"; 
    $it-&gt;next();
}

?&gt; </pre></div><p>This will output the following: </p><div class="informalexample"><pre class="programlisting">Iterating over: 4 values
apple=yummy
orange=ah ya, nice
grape=wow, I love it!
plum=nah, not me</pre></div><p>However, an Iterator also implements the <code class="literal">IteratorAggregator</code> interface so you can even use them in the <code class="literal">foreach()</code> loop. <a id="id258" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php

$fruits = array(  
    "apple" =&gt; "yummy",
    "orange" =&gt; "ah ya, nice",
    "grape" =&gt; "wow, I love it!",
    "plum" =&gt; "nah, not me"
);

$obj = new ArrayObject( $fruits );
$it = $obj-&gt;getIterator();

// How many items are we iterating over?
echo "Iterating over: " . $obj-&gt;count() . " values\n";

// Iterate over the values in the ArrayObject:
foreach ($it as $key=&gt;$val)
echo $key.":".$val."\n";
?&gt; </pre></div><p>You will get the same output as the previous one. </p><p>If you want to implement Iterator to your own collection, collection, I recommend you take a look at Chapter 3. If you want to know how to implement <code class="literal">IteratorAggregator</code>, here is an example for you:</p><div class="informalexample"><pre class="programlisting">&lt;?php
class MyArray implements IteratorAggregate
{

  private $arr;
  public function __construct()
  {
    $this-&gt;arr = array();   
  }

  public function add( $key, $value )
  {
    if( $this-&gt;check( $key, $value ) )
      {
        $this-&gt;arr[$key] = $value;
      }
    }

  private function check( $key, $value )
    {
      if( $key == $value )
        {
          return false;
        }
       return true;
    }
        
  public function getIterator()
  {
    return new ArrayIterator( $this-&gt;arr );
  }       
}
?&gt;</pre></div><a id="id259" class="indexterm"/><p>Please note that if key and value are the same, it will not return that value while iterating. You can use it like this:</p><div class="informalexample"><pre class="programlisting">&lt;?php

$obj = new MyArray();
$obj-&gt;add( "redhat","www.redhat.com" );

$obj-&gt;add( "php", "php" );
$it = $obj-&gt;getIterator();
while( $it-&gt;valid() )
{
  echo $it-&gt;key() . "=" . $it-&gt;current() . "\n";
  $it-&gt;next();
}
?&gt;</pre></div><p>The output is: </p><div class="informalexample"><pre class="programlisting">redhat=www.redhat.com</pre></div></div>
<div class="section" title="DirectoryIterator"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec62"/>DirectoryIterator</h1></div></div></div><a id="id260" class="indexterm"/><a id="id261" class="indexterm"/><p>Another very interesting class introduced in PHP5 is <code class="literal">DirectoryIterator</code>. This object can iterate through the items present in a directory (well, those nothing but files) and you can retrieve different attributes of that file using this object. </p><p>In the PHP Manual this object is not well documented. So if you want to know the structure of this object and supported methods and properties, you can use <code class="literal">ReflectionClass</code> for that. Remember the <code class="literal">ReflectionClass</code> we used in the previous chapter? Let's take a look at the following example: <a id="id262" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
ReflectionClass::export(DirectoryIterator);
?&gt;</pre></div><p>The result is: </p><div class="informalexample"><pre class="programlisting">Class [ &lt;internal:SPL&gt; &lt;iterateable&gt; class DirectoryIterator 
                      implements Iterator, Traversable ] 
{

  - Constants [0] { }
  - Static properties [0] {  }
  - Static methods [0] {  }
  - Properties [0] {  }
  - Methods [27] 
{
    Method [ &lt;internal&gt; &lt;ctor&gt; public method __construct ] 
{

      - Parameters [1] 
{
        Parameter #0 [ &lt;required&gt; $path ]
      }
    }
    Method [ &lt;internal&gt; public method rewind ] {    }
    Method [ &lt;internal&gt; public method valid ] {    }
    Method [ &lt;internal&gt; public method key ] {    }
    Method [ &lt;internal&gt; public method current ] {    }
    Method [ &lt;internal&gt; public method next ] {    }
    Method [ &lt;internal&gt; public method getPath ] {    }
    Method [ &lt;internal&gt; public method getFilename ] {    }
    Method [ &lt;internal&gt; public method getPathname ] {    }
    Method [ &lt;internal&gt; public method getPerms ] {    }
    Method [ &lt;internal&gt; public method getInode ] {    }
    Method [ &lt;internal&gt; public method getSize ] {    }
    Method [ &lt;internal&gt; public method getOwner ] {    }
    Method [ &lt;internal&gt; public method getGroup ] {    }
    Method [ &lt;internal&gt; public method getATime ] {    }
    Method [ &lt;internal&gt; public method getMTime ] {    }
    Method [ &lt;internal&gt; public method getCTime ] {    }
    Method [ &lt;internal&gt; public method getType ] {    }
    Method [ &lt;internal&gt; public method isWritable ] {    }
    Method [ &lt;internal&gt; public method isReadable ] {    }
    Method [ &lt;internal&gt; public method isExecutable ] {    }
    Method [ &lt;internal&gt; public method isFile ] {    }
    Method [ &lt;internal&gt; public method isDir ] {    }
    Method [ &lt;internal&gt; public method isLink ] {    }
    Method [ &lt;internal&gt; public method isDot ] {    }
    Method [ &lt;internal&gt; public method openFile ] 
        {
      - Parameters [3] {
        Parameter #0 [ &lt;optional&gt; $open_mode ]
        Parameter #1 [ &lt;optional&gt; $use_include_path ]
        Parameter #2 [ &lt;optional&gt; $context ]
        }
      }
    Method [ &lt;internal&gt; public method __toString ] {    }
  }
}</pre></div><a id="id263" class="indexterm"/><p>We have a handful of useful methods here. Let's make use of them. In the following example we will just create a directory crawler, which will display all files and directories in a specific drive. Take a look at one of my directories on the C drive called <code class="literal">spket</code>:</p><div class="mediaobject"><img src="graphics/2561_06_01.jpg" alt="DirectoryIterator"/></div><p>Now, if you run the following code, you will get the list of files and directories inside it:</p><div class="informalexample"><pre class="programlisting">&lt;?
$DI = new DirectoryIterator("c:/spket");
foreach ($DI as $file) {
  echo $file."\n";
}
?&gt;</pre></div><p>T<a id="id264" class="indexterm"/>he output is:</p><div class="informalexample"><pre class="programlisting">.
..
plugins
features
readme
.eclipseproduct
epl-v10.html
notice.html
startup.jar
configuration
spket.exe
spket.ini</pre></div><p>But the output doesn't make any sense. Can you detect which are the directories and which are the files? It's very difficult, so let's make the result useful for us. </p><div class="informalexample"><pre class="programlisting">&lt;?
$DI = new DirectoryIterator("c:/spket");
$directories = array();
$files = array();
foreach ($DI as $file) {
  $filename = $file-&gt;getFilename();
  if ($file-&gt;isDir()){
    if(strpos($filename,".")===false) 
    $directories[] = $filename;
  }
  else
  $files[] = $filename;
}
echo "Directories\n";
print_r($directories);
echo "\nFiles\n";
print_r($files);
?&gt;</pre></div><p>T<a id="id265" class="indexterm"/>he output is: </p><div class="informalexample"><pre class="programlisting">Directories
Array
(
    [1] =&gt; plugins
    [2] =&gt; features
    [3] =&gt; readme
    [4] =&gt; configuration
)

Files
Array
(
    [0] =&gt; .eclipseproduct
    [1] =&gt; epl-v10.html
    [2] =&gt; notice.html
    [3] =&gt; startup.jar
    [4] =&gt; spket.exe
    [5] =&gt; spket.ini
)</pre></div><p>You may ask at this point, if there is a shortcut link, how you can detect it. Simple, just use the <code class="literal">$file-&gt;isLink()</code> function to detect if that file is a shortcut. </p><p>Let's take a look at other useful methods of the <code class="literal">DirectoryIterator</code> object:</p><a id="id266" class="indexterm"/><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Methods</p>
</th><th style="text-align: left" valign="bottom">
<p>Feature</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">getPathname()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the absolute path name (with file name) of this file.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">getSize()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns size of file in number of bytes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">getOwner()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the owner ID.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">getATime()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the last access time in timestamp.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">getMTime()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the modification time in timestamp.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">getCTime()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the creation time in timestamp.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">getType()</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns either "file", "dir", or "link".</p>
</td></tr></tbody></table></div><p>Other methods are quite self explanatory, so we are not covering them here. One more thing to remember however, is <code class="literal">getInode()</code>, <code class="literal">getOwner()</code>, and <code class="literal">getGroup()</code> will return <code class="literal">0</code> in win32 machines. </p></div>
<div class="section" title="RecursiveDirectoryIterator"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec63"/>RecursiveDirectoryIterator</h1></div></div></div><a id="id267" class="indexterm"/><a id="id268" class="indexterm"/><p>So what is this object? Remember our previous example? We got a list of directories and files only. However, what if we want to get a list of all directories inside that directory without implementing the recursion? Then <code class="literal">RecursiveDirectoryIterator</code> is here to save your life. </p><p>The recursive directory Iterator can be used to great effect with <code class="literal">RecursiveIeratorIterator</code> to implement the recursion. Let's take a look at the following example, it traverses through all the directories under a directory (no matter how nested it is):<a id="id269" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
// Create the new iterator:
$it = new RecursiveIteratorIterator(new RecursiveDirectoryIterator( 
                                                    'c:/spket' ));
foreach( $it as $key=&gt;$file ) 
{
    echo $key."=&gt;".$file."\n";
}

?&gt;</pre></div><p>The output is like this one:</p><div class="informalexample"><pre class="programlisting">c:/spket/epl-v10.html=&gt;epl-v10.html
c:/spket/notice.html=&gt;notice.html
c:/spket/startup.jar=&gt;startup.jar
c:/spket/configuration/config.ini=&gt;config.ini
c:/spket/configuration/org.eclipse.osgi/.manager/
                                .fileTableLock=&gt;.fileTableLock
c:/spket/configuration/org.eclipse.osgi/.manager/
                                .fileTable.4=&gt;.fileTable.4
c:/spket/configuration/org.eclipse.osgi/.manager/
                                .fileTable.5=&gt;.fileTable.5
c:/spket/configuration/org.eclipse.osgi/bundles/4/1/.cp/
                    swt-win32-3236.dll=&gt;swt-win32-3236.dll
c:/spket/configuration/org.eclipse.osgi/bundles/4/1/.cp/
                    swt-gdip-win32-3236.dll=&gt;swt-gdip-win32-3236.dll
c:/spket/configuration/org.eclipse.osgi/bundles/48/1/.cp/os/win32/
                    x86/localfile_1_0_0.dll=&gt;localfile_1_0_0.dll
c:/spket/configuration/org.eclipse.osgi/bundles/69/1/.cp/os/win32/
                    x86/monitor.dll=&gt;monitor.dll
c:/spket/spket.exe=&gt;spket.exe
c:/spket/spket.ini=&gt;spket.ini
………</pre></div><a id="id270" class="indexterm"/><p>I can hear you asking yourself: 'why are these useless files printed here?' Just take a look at directory structure and see how it retrieves the entire file name with their path as key. </p></div>
<div class="section" title="RecursiveIteratorIterator"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec64"/>RecursiveIteratorIterator</h1></div></div></div><a id="id271" class="indexterm"/><a id="id272" class="indexterm"/><p>To recursively iterate over a collection, you can make take advantage of this object introduced in SPL. Let's take a look at the following example to understand how effectively it can be used in your everyday programming. In the previous sections and also in the coming sections we see many examples using <code class="literal">RecursiveIteratorIterator</code>; so we are not giving any more examples in this section. </p></div>
<div class="section" title="AppendIterator"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec65"/>AppendIterator</h1></div></div></div><a id="id273" class="indexterm"/><a id="id274" class="indexterm"/><p>If you want to use a collection of Iterators to iterate through, then this could be your life saver. This object saves all the Iterators in a collection and iterates through all of them at once. </p><a id="id275" class="indexterm"/><p>Let's take a look at the following example of <code class="literal">append</code> Iterator, where we traverse through a collection of Iterators and then minimize the code: </p><div class="informalexample"><pre class="programlisting">&lt;?
class Post
{
  public $id;
  public $title;

  function __construct($title, $id)
  {
    $this-&gt;title = $title;
    $this-&gt;id = $id;
  }
}

class Comment{
  public $content;
  public $post_id;

  function __construct($content, $post_id)
  {
    $this-&gt;content = $content;
    $this-&gt;post_id = $post_id;
  }
}

$posts = new ArrayObject();
$comments = new ArrayObject();


$posts-&gt;append(new post("Post 1",1));
$posts-&gt;append(new post("Post 2",2));

$comments-&gt;append(new Comment("comment 1",1));
$comments-&gt;append(new Comment("comment 2",1));
$comments-&gt;append(new Comment("comment 3",2));
$comments-&gt;append(new Comment("comment 4",2));

$a = new AppendIterator();
$a-&gt;append($posts-&gt;getIterator());
$a-&gt;append($comments-&gt;getIterator());

//print_r($a-&gt;getInnerIterator());

foreach ($a as $key=&gt;$val)
{
  if ($val instanceof post)
  echo "title = {$val-&gt;title}\n";
  else if ($val instanceof Comment )
  echo "content = {$val-&gt;content}\n";

}
?&gt;</pre></div><a id="id276" class="indexterm"/><p>And here comes the output:</p><div class="informalexample"><pre class="programlisting">title = Post 1
title = Post 2
content = comment 1
content = comment 2
content = comment 3
content = comment 4</pre></div></div>
<div class="section" title="FilterIterator"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec66"/>FilterIterator</h1></div></div></div><a id="id277" class="indexterm"/><a id="id278" class="indexterm"/><p>As its name suggests, this Iterator helps you to filter out the result through iteration so that you get only the results you require. This Iterator is very useful for iteration with filtering, </p><p>
<code class="literal">FilterIterator</code> exposes two extra methods over a regular Iterator. One is <code class="literal">accept()</code> which is called every time in internal iteration and is your key point to perform the filter. The second one is <code class="literal">getInnerIterator()</code>, which returns the current Iterator inside this <code class="literal">FilterIterator</code>. </p><p>In this example we use <code class="literal">FilterIterator</code> to filter out data while traversing through a collection.<a id="id279" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
class GenderFilter extends FilterIterator
{
  private $GenderFilter;

  public function __construct( Iterator $it, $gender="F" )
  {
    parent::__construct( $it );
    $this-&gt;GenderFilter = $gender;
  }

  //your key point to implement filter
  public function accept()
  {
    $person = $this-&gt;getInnerIterator()-&gt;current();

    if( $person['sex'] == $this-&gt;GenderFilter ) 
    {    
      return TRUE;
    }       
    return FALSE;
  }
}

$arr = array(  
  array("name"=&gt;"John Abraham", "sex"=&gt;"M", "age"=&gt;27),
  array("name"=&gt;"Lily Bernard", "sex"=&gt;"F", "age"=&gt;37),
  array("name"=&gt;"Ayesha Siddika", "sex"=&gt;"F", "age"=&gt;26),
  array("name"=&gt;"Afif", "sex"=&gt;"M", "age"=&gt;2)
);
<a id="id280" class="indexterm"/>
$persons = new ArrayObject( $arr ); 

$iterator = new GenderFilter( $persons-&gt;getIterator() );
foreach( $iterator as $person ) 
{
  echo $person['name'] . "\n"; 
}

echo str_repeat("-",30)."\n";

$persons = new ArrayObject( $arr ); 

$iterator = new GenderFilter( $persons-&gt;getIterator() ,"M");
foreach( $iterator as $person ) 
{
    echo $person['name'] . "\n"; 
}

?&gt;</pre></div><p>If you run the code, you will get the following result:</p><div class="informalexample"><pre class="programlisting">Lily Bernard
Ayesha Siddika
------------------------------
John Abraham
Afif</pre></div><p>I'm sure you will agree that this is quite interesting, however did you get the catch? This is filtered by the following entry point: </p><div class="informalexample"><pre class="programlisting">public function accept()
  {
    $person = $this-&gt;getInnerIterator()-&gt;current();
    if( $person['sex'] == $this-&gt;GenderFilter ) 
    {    
      return TRUE;
    }       
      return FALSE;
  }
}<a id="id281" class="indexterm"/>
</pre></div></div>
<div class="section" title="LimitIterator"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec67"/>LimitIterator</h1></div></div></div><a id="id282" class="indexterm"/><a id="id283" class="indexterm"/><p>What if you want to define the start point from where your iteration will start and also define the times you want to iterate? This is made possible using <code class="literal">LimitIterator</code>. </p><p>
<code class="literal">LimitIterator</code> takes three parameters while constructing. The first one is a regular Iterator, the second one is the starting offset, and the third one is the number of times that it will iterate. Take a look at the following example:<a id="id284" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?
$arr = array(  
  array("name"=&gt;"John Abraham", "sex"=&gt;"M", "age"=&gt;27),
  array("name"=&gt;"Lily Bernard", "sex"=&gt;"F", "age"=&gt;37),
  array("name"=&gt;"Ayesha Siddika", "sex"=&gt;"F", "age"=&gt;26),
  array("name"=&gt;"Afif", "sex"=&gt;"M", "age"=&gt;2)
);

$persons = new ArrayObject($arr);

$LI = new LimitIterator($persons-&gt;getIterator(),1,2);
foreach ($LI as $person) {
  echo $person['name']."\n";
}
?&gt;</pre></div><p>And the output is: </p><div class="informalexample"><pre class="programlisting">Lily Bernard
Ayesha Siddika</pre></div></div>
<div class="section" title="NoRewindIterator"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec68"/>NoRewindIterator</h1></div></div></div><a id="id285" class="indexterm"/><a id="id286" class="indexterm"/><p>This is another Iterator in which you can't invoke the <code class="literal">rewind</code> method. That means it is a forward-only Iterator, which can read a collection only once. Take a look at the structure; if you execute the following code you will get the methods supported by this Iterator:</p><div class="informalexample"><pre class="programlisting">&lt;?
print_r(get_class_methods(NoRewindIterator));
  //you can also use refelection API as before to see the methods. 
?&gt;</pre></div><p>The output would be the methods, as seen below:</p><div class="informalexample"><pre class="programlisting">Array
(
  [0] =&gt; __construct
  [1] =&gt; rewind
  [2] =&gt; valid
  [3] =&gt; key
  [4] =&gt; current
  [5] =&gt; next
  [6] =&gt; getInnerIterator
)</pre></div><p>Surprisingly, it has no rewind method, but you can see it, can't you? Well, that method has no implementation, it is empty. It is there as it implements the Iterator interface, but there is no implementation of that function, so you can't rewind. <a id="id287" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?
$arr = array(  
  array("name"=&gt;"John Abraham", "sex"=&gt;"M", "age"=&gt;27),
  array("name"=&gt;"Lily Bernard", "sex"=&gt;"F", "age"=&gt;37),
  array("name"=&gt;"Ayesha Siddika", "sex"=&gt;"F", "age"=&gt;26),
  array("name"=&gt;"Afif", "sex"=&gt;"M", "age"=&gt;2)
);

$persons = new ArrayObject($arr);

$LI = new NoRewindIterator($persons-&gt;getIterator());
foreach ($LI as $person) {
  echo $person['name']."\n";

  $LI-&gt;rewind();
}
?&gt;</pre></div><p>If the <code class="literal">rewind()</code> method works, this code will be an endless loop. But in practical, it displays the output as shown below:</p><div class="informalexample"><pre class="programlisting">John Abraham
Lily Bernard
Ayesha Siddika
Afif<a id="id288" class="indexterm"/>
</pre></div></div>
<div class="section" title="SeekableIterator"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec69"/>SeekableIterator</h1></div></div></div><a id="id289" class="indexterm"/><a id="id290" class="indexterm"/><p>This is an interface introduced in SPL, which many Iterator classes actually implement internally. If this interface is implemented, you can perform <code class="literal">seek()</code> operation inside this array. </p><p>Let's take a look at the following example where we implement <code class="literal">SeekableIterator</code> to provide a searching facility over a collection:<a id="id291" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?
$arr = array(  
    array("name"=&gt;"John Abraham", "sex"=&gt;"M", "age"=&gt;27),
    array("name"=&gt;"Lily Bernard", "sex"=&gt;"F", "age"=&gt;37),
    array("name"=&gt;"Ayesha Siddika", "sex"=&gt;"F", "age"=&gt;26),
    array("name"=&gt;"Afif", "sex"=&gt;"M", "age"=&gt;2)
);

$persons = new ArrayObject($arr);

$it = $persons-&gt;getIterator();
$it-&gt;seek(2);

while ($it-&gt;valid())
{
  print_r($it-&gt;current());
  $it-&gt;next();
}
?&gt;</pre></div><p>The output is: </p><div class="informalexample"><pre class="programlisting">Array
(
  [name] =&gt; Ayesha Siddika
  [sex] =&gt; F
  [age] =&gt; 26
)
Array
(
  [name] =&gt; Afif
  [sex] =&gt; M
  [age] =&gt; 2
)<a id="id292" class="indexterm"/>
</pre></div></div>
<div class="section" title="RecursiveIterator"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec70"/>RecursiveIterator</h1></div></div></div><a id="id293" class="indexterm"/><a id="id294" class="indexterm"/><p>This is another interface introduced by SPL for easy recursion over nested collections. By implementing this interface and using it with <code class="literal">RecursiveIteratorIterator</code>, you can easily traverse through nested collections. </p><p>If you implement <code class="literal">RecursiveIterator</code>, you have to apply two methods, one is <code class="literal">hasChildren()</code>, which must determine whether the current object is an array or not (and that means if it has children or not) and the second one is <code class="literal">getChildren()</code>, which must return an instance of the same class over the collection. That's it. To understand the bigger picture, take a look at the following example:<a id="id295" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?
$arr = array(  
  "john"=&gt;array("name"=&gt;"John Abraham", "sex"=&gt;"M", "age"=&gt;27),
  "lily"=&gt;array("name"=&gt;"Lily Bernard", "sex"=&gt;"F", "age"=&gt;37),
  "ayesha"=&gt;array("name"=&gt;"Ayesha Siddika", "sex"=&gt;"F", "age"=&gt;26),
  "afif"=&gt;array("name"=&gt;"Afif", "sex"=&gt;"M", "age"=&gt;2)
);

class MyRecursiveIterator extends ArrayIterator implements 
                                           RecursiveIterator 
{
  public function hasChildren()
  {
    return is_array($this-&gt;current());
  }

  public function getChildren()
  {
    return new MyRecursiveIterator($this-&gt;current());
  }
}

$persons = new ArrayObject($arr);
$MRI = new RecursiveIteratorIterator(new MyRecursiveIterator($persons));
foreach ($MRI as $key=&gt;$person)
echo $key." : ".$person."\n";
?&gt;</pre></div><p>The output is: </p><div class="informalexample"><pre class="programlisting">name : John Abraham
sex : M
age : 27
name : Lily Bernard
sex : F
age : 37
name : Ayesha Siddika
sex : F
age : 26
name : Afif
sex : M
age : 2<a id="id296" class="indexterm"/>
</pre></div></div>
<div class="section" title="SPLFileObject"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec71"/>SPLFileObject</h1></div></div></div><a id="id297" class="indexterm"/><a id="id298" class="indexterm"/><p>This is another fantastic object introduced in SPL for basic file operations. You can iterate through the content of the file in a more elegant way using this object. In <code class="literal">SPLFileObject</code>, the following methods are supported:<a id="id299" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">Array
(
    [0] =&gt; __construct
    [1] =&gt; getFilename
    [2] =&gt; rewind
    [3] =&gt; eof
    [4] =&gt; valid
    [5] =&gt; fgets
    [6] =&gt; fgetcsv
    [7] =&gt; flock
    [8] =&gt; fflush
    [9] =&gt; ftell
    [10] =&gt; fseek
    [11] =&gt; fgetc
    [12] =&gt; fpassthru
    [13] =&gt; fgetss
    [14] =&gt; fscanf
    [15] =&gt; fwrite
    [16] =&gt; fstat
    [17] =&gt; ftruncate
    [18] =&gt; current
    [19] =&gt; key
    [20] =&gt; next
    [21] =&gt; setFlags
    [22] =&gt; getFlags
    [23] =&gt; setMaxLineLen
    [24] =&gt; getMaxLineLen
    [25] =&gt; hasChildren
    [26] =&gt; getChildren
    [27] =&gt; seek
    [28] =&gt; getCurrentLine
    [29] =&gt; __toString
)</pre></div><a id="id300" class="indexterm"/><p>If you carefully look into it, you will find that general file functions in PHP are implemented in this object, which gives you more flexibility to work with. </p><a id="id301" class="indexterm"/><p>In the following example we will discuss how to use <code class="literal">SPLFileObject:</code>
</p><div class="informalexample"><pre class="programlisting">&lt;?
$file = new SplFileObject("c:\\lines.txt");

foreach( $file as $line ) {
    echo $line;
}

?&gt;</pre></div><p>Therefore, it works in the same was as an Iterator, you can rewind, seek, and perform other general tasks. There are also some interesting functions like <code class="literal">getMaxLineLen</code>, <code class="literal">fstat</code>, <code class="literal">hasChildren</code>, <code class="literal">getChildren</code> etc. </p><p>Using <code class="literal">SPLFileObject</code> you can retrieve remote files too. </p></div>
<div class="section" title="SPLFileInfo"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec72"/>SPLFileInfo</h1></div></div></div><a id="id302" class="indexterm"/><a id="id303" class="indexterm"/><p>This is another object introduced by SPL, which helps you to retrieve file information of any specific file. Let's have a look at the structure first: <a id="id304" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">Array
(
    [0] =&gt; __construct
    [1] =&gt; getPath
    [2] =&gt; getFilename
    [3] =&gt; getPathname
    [4] =&gt; getPerms
    [5] =&gt; getInode
    [6] =&gt; getSize
    [7] =&gt; getOwner
    [8] =&gt; getGroup
    [9] =&gt; getATime
    [10] =&gt; getMTime
    [11] =&gt; getCTime
    [12] =&gt; getType
    [13] =&gt; isWritable
    [14] =&gt; isReadable
    [15] =&gt; isExecutable
    [16] =&gt; isFile
    [17] =&gt; isDir
    [18] =&gt; isLink
    [19] =&gt; getFileInfo
    [20] =&gt; getPathInfo
    [21] =&gt; openFile
    [22] =&gt; setFileClass
    [23] =&gt; setInfoClass
    [24] =&gt; __toString
)<a id="id305" class="indexterm"/>
</pre></div><p>You can use <code class="literal">SPLFileInfo</code> to open any file. However, what is more interesting is that it supports overloading the opening of a file. You can supply your open file manager class to it and it will be invoked while opening a file. </p><p>Let's take a look at the following example. <a id="id306" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php

class CustomFO extends SplFileObject
{
  private $i=1;
  public function current() 
  {

    return $this-&gt;i++ . ":   " . 
             htmlspecialchars($this-&gt;getCurrentLine())."";
  }
}
$SFI= new SplFileInfo( "splfileinfo2.php" );

$SFI-&gt;setFileClass( "CustomFO" );
$file = $SFI-&gt;openFile(  );
echo "&lt;pre&gt;";
foreach( $file as $line ) 
{
  echo $line;
}

?&gt;</pre></div><p>This example will output the following:</p><div class="informalexample"><pre class="programlisting">1:   
2:   &lt;?php
3:   
4:   class CustomFO extends SplFileObject
     {
5:     private $i=1;
6:     public function current() 
     {
7:   
8:       return $this-&gt;i++ . ":   " . 
                htmlspecialchars($this-&gt;getCurrentLine())."";
9:     }
10:   }
11:   $SFI= new SplFileInfo( "splfileinfo2.php" );
12:   
13:   $SFI-&gt;setFileClass( "CustomFO" );
14:   $file = $SFI-&gt;openFile(  );
15:   echo "&lt;pre&gt;";
16:   foreach( $file as $line ) 
      {
17:   	echo $line;
18:   }
19:   
20:   ?&gt;
21:   
22:   <a id="id307" class="indexterm"/>
</pre></div></div>
<div class="section" title="SPLObjectStorage"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec73"/>SPLObjectStorage</h1></div></div></div><a id="id308" class="indexterm"/><a id="id309" class="indexterm"/><p>Beside Directory, File Objects and Iterators, SPL also introduced another cool object which can store any object inside it with special facilities. This object is called <code class="literal">SPLObjectStorage</code>. We will understand this using the example later on in this chapter. </p><p>
<code class="literal">SPLObjectStorage</code> can store any object in it. When you change the main object, the object that is stored inside the <code class="literal">SPLObjectStorage</code> will also be changed. If you try to add a specific object more than once, it won't add actually. You can also delete the object from the storage any time. </p><p>Besides this, <code class="literal">SPLObjectStorage</code> provides the facility to iterate through a collection of stored objects. Let's take a look at the following example, which demonstrates the use of <code class="literal">SPLObjectStorage</code>: <a id="id310" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?
$os = new SplObjectStorage();

$person = new stdClass();// a standard object
$person-&gt;name = "Its not a name";
$person-&gt;age = "100";

$os-&gt;attach($person); //attached in the storage

foreach ($os as $object)
{
  print_r($object);
  echo "\n";
}

$person-&gt;name = "New Name"; //change the name

echo str_repeat("-",30)."\n"; //just a format code

foreach ($os as $object)
{
  print_r($object); //you see that it changes the original object
  echo "\n";
}

$person2 = new stdClass();
$person2-&gt;name = "Another Person";
$person2-&gt;age = "80";

$os-&gt;attach($person2);

echo str_repeat("-",30)."\n";

foreach ($os as $object)
{
  print_r($object);
  echo "\n";
}<a id="id311" class="indexterm"/>

echo "\n".$os-&gt;contains($person);//seek

$os-&gt;rewind();
echo "\n".$os-&gt;current()-&gt;name;

$os-&gt;detach($person); //remove the object from collection

echo "\n".str_repeat("-",30)."\n";

foreach ($os as $object)
{
  print_r($object);
  echo "\n";
}

?&gt;</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">stdClass Object
(
  [name] =&gt; It's not a name
  [age] =&gt; 100
)

------------------------------
stdClass Object
(
  [name] =&gt; New Name
  [age] =&gt; 100
)

------------------------------
stdClass Object
(
  [name] =&gt; New Name
  [age] =&gt; 100
)

stdClass Object
(
  [name] =&gt; Another Person
  [age] =&gt; 80<a id="id312" class="indexterm"/>
)

1
New Name
------------------------------
stdClass Object
(
  [name] =&gt; Another Person
  [age] =&gt; 80
) </pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec74"/>Summary</h1></div></div></div><p>After introducing PHP5 to the world, the PHP team introduced the strong object oriented programming in PHP to PHP developers. PHP5 comes with a lot of handy built-in objects amongst which SPL is a fantastic one. It eases programming for many tasks, which were once quite tough. So SPL introduced many objects that we have just discussed and learned how to use. As the PHP manual doesn't have updated and detailed information on all of these classes, you can count this chapter as a good reference for programming with SPL objects. </p></div></body></html>