- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Unit Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Imagine working on a project without any automated tests with a few other developers,
    and everything seems to be working fine in production. Then, a bug has been discovered,
    and one of the developers fixes this bug. The QA department approves the fix and
    then is pushed to production. A few days later, another bug is reported in production.
    After investigation, the developers found out that the new bug was introduced
    by the fix for the other bug. Does that sound familiar?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在没有自动化测试的情况下与几位其他开发者一起工作在一个项目上，一切似乎在生产中都运行得很好。然后，发现了一个错误，其中一位开发者修复了这个错误。质量保证部门批准了修复，然后推送到生产。几天后，生产中报告了另一个错误。经过调查，开发者发现新的错误是由修复其他错误的修复引起的。这听起来熟悉吗？
- en: One small change in the code base can easily change the behavior of software.
    A single decimal point change can cause millions of dollars worth of incorrect
    computations. Imagine handballing all these computation checks to the QA department
    for manual testing – they would have to run these checks every time something
    had been updated in the code base. It’s simply inefficient, stressful, and not
    sustainable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库中的一个小改动可以轻易地改变软件的行为。一个小数点的改动可能导致数百万美元的错误计算。想象一下，将这些计算检查全部推给质量保证部门进行手动测试——他们每次代码库更新时都必须运行这些检查。这太低效、太有压力，而且不可持续。
- en: One of the solutions to this recurring issue is unit testing. Writing unit test
    programs will help us developers verify whether our own programs are correct or
    not. By repeatedly running unit tests, we will also be able to catch problems
    very early during development if we break other existing tests. If we accidentally
    change the expected behavior of a function, and if we’ve written unit tests properly
    for this function before, then we can be confident that we will break those tests.
    This, to me, is amazing. I want to know that if I break something, I won’t push
    my code for final verification to the QA or testing department until I am confident
    that I have not compromised any existing sets of unit tests. For large products,
    this will save the QA or testing department a lot of man-hours, even if there
    are automated end-to-end and user interface-to-backend tests.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个反复出现的问题的一种方法是单元测试。编写单元测试程序将帮助我们开发者验证我们的程序是否正确。通过反复运行单元测试，如果我们破坏了其他现有的测试，我们也能在开发早期就捕捉到问题。如果我们意外地改变了函数的预期行为，并且如果我们在这个函数上已经正确地编写了单元测试，那么我们可以有信心这些测试会被破坏。对我来说，这真是太神奇了。我想知道，如果我破坏了什么，我不会在确信我没有破坏任何现有的单元测试集之前，将我的代码推送到最终验证给质量保证或测试部门。对于大型产品，这将节省质量保证或测试部门大量的工时，即使有自动化端到端和用户界面到后端测试。
- en: There are different types of tests that we will be discussing in this chapter
    as well, but the unit tests are the foundations of those other automated test
    types.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将讨论不同类型的测试，但单元测试是其他自动化测试类型的基础。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining unit tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义单元测试
- en: Writing and running unit tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和运行单元测试
- en: Setting up test coverage monitoring
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置测试覆盖率监控
- en: What are the different types of tests?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有哪些不同类型的测试？
- en: Utilizing dependency injection and mocking on integration tests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在集成测试中利用依赖注入和模拟
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires you to have all the containers we have previously built,
    and PHPStorm IDE configurations that were defined in [*Chapter 3*](B18318_03.xhtml#_idTextAnchor039),
    *Setting Up Our Development Environment Using Docker Containers*. You can simply
    download the development environment setup from GitHub and follow the instructions
    mentioned in [*Chapter 3*](B18318_03.xhtml#_idTextAnchor039), *Setting Up Our
    Development Environment Using Docker* *Containers*: [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%203](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%203).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求您拥有我们之前构建的所有容器，以及[*第3章*](B18318_03.xhtml#_idTextAnchor039)中定义的PHPStorm IDE配置，*使用Docker容器设置我们的开发环境*。您可以简单地从GitHub下载开发环境设置，并遵循[*第3章*](B18318_03.xhtml#_idTextAnchor039)中提到的说明，*使用Docker容器设置我们的开发环境*：[https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%203](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%203)。
- en: In this chapter, it’s also required that you understand how to use **Object
    Relational Mappers** (**ORMs**), and the author assumes that you have experience
    working with MySQL databases.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: It is also required for you to be familiar with PSR-11, and the use of service
    containers. More information about PSR-11 can be found at [https://www.php-fig.org/psr/psr-11/](https://www.php-fig.org/psr/psr-11/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: All the code files related to this chapter can be found at [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%203](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%203).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the development environment for the chapter
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, get the base code for [*Chapter 5*](B18318_05.xhtml#_idTextAnchor070),
    found at [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%203](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%203)
    or simply run the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To run the containers, and execute the commands in this chapter, the reader
    should be inside the
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To run the containers and execute the commands in this chapter, you should be
    inside the `docker-server-web-1` container.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to confirm the container name for our web server:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To run the containers, run the following command from the `/phptdd/docker`
    directory from the repository in your host machine:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once inside the container, run the following commands to install the libraries
    required through `composer`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Defining unit tests
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A unit test is a program that specifically tests a unit of your solution code.
    Just think of it as a program that tests a function and does not depend on other
    objects in your project.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have a function called `calculateTotal($a, $b, $c)`, then
    you can write a unit test function for it called `testCanCalculateTotal()`. This
    unit test’s job is to verify whether the `calculateTotal($a, $b, $c)` function
    is returning the expected result based on the business rules defined by your project’s
    specification.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: In this example, let’s assume that the expected behavior of the `calculateTotal`
    function is to get the summation of the three parameters, `$a`, `$b`, and `$c`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an example unit test and solution codes. Create the following
    file inside our development container:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: codebase/symfony/tests/Unit/CalculationTest.php
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The test class name needs to be suffixed with `Test`, and it extends the `PHPUnit\Framework\TestCase`
    class. By doing so, we are now using the PHPUnit library.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s try to run this unit test and see what happens. Run the following
    command while inside the container. The instructions on how to do all this are
    in [*Chapter 3*](B18318_03.xhtml#_idTextAnchor039), *Setting Up Our Development
    Environment Using* *Docker Containers*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result will be an error:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Fail 1 (class not found)](img/Figure_5.01_B18318.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Fail 1 (class not found)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Our unit test has failed as expected – this is good! You’ll notice that we tried
    to instantiate a class that does not exist, so let’s now create that class and
    write the function to do the calculation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试正如预期那样失败了——这是好事！你会注意到我们尝试实例化一个不存在的类，所以现在让我们创建那个类并编写执行计算的函数。
- en: 'Create the following solution class inside `codebase/symfony/src/Example/`
    directory that we previously created:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前创建的`codebase/symfony/src/Example/`目录内创建以下解决方案类：
- en: codebase/symfony/src/Example/Calculator.php
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Example/Calculator.php
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After creating the solution class with the `calculateTotal` function, let’s
    try to run the test again by running the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建带有`calculateTotal`函数的解决方案类后，让我们再次尝试运行测试，通过运行以下命令：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will get the following failing result:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下失败的结果：
- en: '![Figure 5.2 – Fail 2 (incorrect result)](img/Figure_5.02_B18318.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 失败2（结果不正确）](img/Figure_5.02_B18318.jpg)'
- en: Figure 5.2 – Fail 2 (incorrect result)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 失败2（结果不正确）
- en: 'PHPUnit will tell us why the test has failed. You’ll notice that it says: **Failed
    asserting that 0 matches expected 6.**. Why is that? Well, this is what happened.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit会告诉我们测试失败的原因。你会注意到它说：**断言失败：预期0个匹配，但找到6个**。为什么是这样呢？好吧，这就是发生了什么。
- en: 'In the `testCanCalculateTotal` unit test, we have declared `$expectedTotal`
    to be `6`. We then called the `calculateTotal` function and sent the following
    arguments: `$a = 1`, `$b = 2`, and `$c = 3`. If the specification you receive
    instructs you to get the summation of the three parameters within the `calculateTotal`
    function, then the expected result is `6`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`testCanCalculateTotal`单元测试中，我们声明`$expectedTotal`为`6`。然后我们调用`calculateTotal`函数并传递以下参数：`$a
    = 1`，`$b = 2`，和`$c = 3`。如果你收到的规范指示你在`calculateTotal`函数内对三个参数求和，那么预期的结果是`6`。
- en: 'We then used the `assertEquals` PHPUnit function, where we told PHPUnit that
    we were expecting that the expected value would be equal to the calculated value
    with the following line:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用了`assertEquals` PHPUnit函数，其中我们告诉PHPUnit我们期望的值应该等于以下行中的计算值：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Assertions are methods or functions that assert or check whether a condition
    within a test has been satisfied or not. Like in our example, we used the `assertEquals`
    method where we tried to compare `$expectedTotal` to the actual `$total` we received
    from the solution code. There are a lot of different types of PHPUnit assertions,
    and the documentation can be found here: [https://phpunit.readthedocs.io/en/9.5/assertions.html](https://phpunit.readthedocs.io/en/9.5/assertions.html).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是方法或函数，用于断言或检查测试中的条件是否得到满足。就像在我们的例子中，我们使用了`assertEquals`方法，尝试比较`$expectedTotal`与从解决方案代码中实际收到的`$total`。有很多不同类型的PHPUnit断言，文档可以在这里找到：[https://phpunit.readthedocs.io/en/9.5/assertions.html](https://phpunit.readthedocs.io/en/9.5/assertions.html)。
- en: 'The unit test correctly expects the expected result to be `6` – the problem
    is that in the solution function, we did not follow the expected behavior. We
    subtracted `$c` instead of adding it to the summation of `$a` and `$b`. If we
    fix the function to the following, our test should finally pass:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试正确地期望预期结果为`6`——问题是我们在解决方案函数中没有遵循预期的行为。我们没有将`$c`加到`$a`和`$b`的总和中，而是减去了它。如果我们把函数修正如下，我们的测试最终应该通过：
- en: codebase/symfony/src/Example/Calculator.php
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Example/Calculator.php
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To get the total, we just need to get the sum of the three parameters. Once
    you update the `Calculator.php` file, run the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到总数，我们只需要得到三个参数的总和。一旦你更新了`Calculator.php`文件，运行以下命令：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We should now see the following result:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该看到以下结果：
- en: '![Figure 5.3 – Correct result](img/Figure_5.03_B18318.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 正确结果](img/Figure_5.03_B18318.jpg)'
- en: Figure 5.3 – Correct result
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 正确结果
- en: Nice! We have finally passed the unit test! The `assertEquals` function has
    confirmed that `$expectedTotal` is now equal to the `$total` amount returned by
    the solution codes!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们终于通过了单元测试！`assertEquals`函数已确认`$expectedTotal`现在等于解决方案代码返回的`$total`金额！
- en: Now, imagine having thousands of these tests. One unintended change in the behavior
    of the solution codes will cause one or more unit tests to fail. This is very
    valuable. This will help developers verify the stability of any code change that
    they implement.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下有成千上万的这些测试。解决方案代码行为的一个意外更改将导致一个或多个单元测试失败。这是非常有价值的。这将帮助开发者验证他们实施的任何代码更改的稳定性。
- en: To learn more about PHPUnit, you can visit their documentation page at [https://phpunit.readthedocs.io/](https://phpunit.readthedocs.io/).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于PHPUnit的信息，您可以访问他们的文档页面[https://phpunit.readthedocs.io/](https://phpunit.readthedocs.io/)。
- en: This is one of the most basic examples of the use of a unit test, but we’ll
    be writing more unit tests and utilizing more PHPUnit features as we continue
    with the project.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是使用单元测试的最基本示例之一，但我们将随着项目的继续编写更多的单元测试并利用更多的PHPUnit功能。
- en: The more tests we have for our solution codes, the better it is for the stability
    of the solution. Therefore, next, we will look into PHPUnit’s code coverage analysis
    solution. This will help us get some metrics about how much test coverage we have
    for our solution.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为解决方案代码编写的测试越多，对解决方案的稳定性就越好。因此，接下来，我们将探讨PHPUnit的代码覆盖率分析解决方案。这将帮助我们获取一些关于我们解决方案测试覆盖率的指标。
- en: Test coverage
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试覆盖率
- en: It’s great having unit tests, but if we only test a few parts of the solution,
    then there’s more chance of breaking the code base unintentionally. Still, having
    a few unit tests is better than having no unit tests. I’m not aware of a solid
    industry standard number or percentage of ideal test code coverage. Some say 80%
    to 95% test coverage is good, but that depends on the project. I still believe
    that 50% test coverage is better than 0% test coverage, and every project can
    be very different. The test coverage can be configured to exclude some parts of
    the code base as well, so having 100% test coverage does not literally mean 100%
    of all code in the code base is covered by automated tests. Nonetheless, it’s
    still good to know how much test coverage we have for our solution. For developers
    who are just getting started with unit testing, it’s important to point out that
    having a few tests is better than not writing unit tests at all. Don’t be scared
    or demotivated if your code coverage report gives you a low number; knowing this
    will at least give you the data or truth about your test coverage.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有单元测试是很好的，但如果我们只测试解决方案的几个部分，那么无意中破坏代码库的机会就更大。尽管如此，有一些单元测试比没有单元测试要好。我不了解一个明确的行业标准数字或理想的测试代码覆盖率百分比。有人说80%到95%的测试覆盖率是好的，但这取决于项目。我仍然认为50%的测试覆盖率比0%的测试覆盖率要好，每个项目都可以非常不同。测试覆盖率还可以配置为排除代码库的一些部分，所以100%的测试覆盖率并不字面意义上意味着代码库中所有代码的100%都由自动化测试覆盖。尽管如此，了解我们解决方案的测试覆盖率仍然是有益的。对于刚开始进行单元测试的开发者来说，指出有一些测试比完全不写单元测试要好是很重要的。如果你的代码覆盖率报告给你一个低数字，不要害怕或失去动力；了解这一点至少会给你关于测试覆盖率的数据或真相。
- en: To let PHPUnit know that a certain test function tests for a specific solution
    code, we will be using the `@covers` annotation. Annotations in PHP are a type
    of metadata that is added to classes, functions, properties, and so on. In PHP,
    we declare annotations within documentation blocks.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让PHPUnit知道某个测试函数测试了特定的解决方案代码，我们将使用`@covers`注解。PHP中的注解是一种添加到类、函数、属性等处的元数据类型。在PHP中，我们在文档块中声明注解。
- en: Declaring annotations
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明注解
- en: PHP annotations are just like comments – they are used by PHP libraries to get
    metadata from a function, property, or class in PHP.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: PHP注解就像注释一样——它们被PHP库用来从PHP中的函数、属性或类中获取元数据。
- en: 'Open the `CalculationTest.php` file and add the following `@covers` annotation
    right above the `testCanCalculateTotal` function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`CalculationTest.php`文件，在`testCanCalculateTotal`函数上方添加以下`@covers`注解：
- en: codebase/symfony/tests/Unit/CalculationTest.php
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/Unit/CalculationTest.php
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You’ll notice that we have declared the `\App\Example\Calculator::calculateTotal`
    class and the `calculateTotal` method after the `@covers` annotation. We are basically
    telling PHPUnit that this specific `testCanCalculateTotal` test function will
    *cover* the method or function inside the `\App\Example\Calculator` class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，我们在`@covers`注解之后声明了`\App\Example\Calculator`类和`calculateTotal`方法。我们基本上是在告诉PHPUnit，这个特定的`testCanCalculateTotal`测试函数将*覆盖*`\App\Example\Calculator`类内部的该方法或函数。
- en: 'Now, run the following CLI commands to run PHPUnit with test coverage:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下CLI命令以运行带有测试覆盖率的PHPUnit：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This time around, we added the `--coverage-text` option. We are telling PHPUnit
    to output the coverage analysis report back to the terminal window. You will now
    receive the following result:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们添加了`--coverage-text`选项。我们正在告诉PHPUnit将覆盖率分析报告输出到终端窗口。你现在将收到以下结果：
- en: '![Figure 5.4 – First test coverage](img/Figure_5.04_B18318.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 第一次测试覆盖率](img/Figure_5.04_B18318.jpg)'
- en: Figure 5.4 – First test coverage
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 第一次测试覆盖率
- en: Congratulations! You just received your first test coverage report! This means
    that the `calculate` method of the `Calculation.php` class is covered by a unit
    test. However, in real life, we end up having more functions inside a class. What
    will happen if we start adding functions to the `Calculation.php` class? Well,
    let’s find out.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您刚刚收到了您的第一个测试覆盖率报告！这意味着 `Calculation.php` 类的 `calculate` 方法被一个单元测试覆盖了。然而，在现实生活中，我们会在一个类中添加更多函数。如果我们开始向
    `Calculation.php` 类添加函数会发生什么？让我们来看看。
- en: Adding more functions to the solution class
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向解决方案类添加更多函数
- en: The `CalculationTest` class we previously created has a test that covers the
    `calculateTotal` function. When we ran the coverage test, we received a 100% test
    coverage result. If we add more functions to the solution class, we will no longer
    get a 100% coverage test result. What does that mean though? In practice, that
    means that some parts of our solution class are not covered by our automated test.
    It’s not the end of the world, but this will help the developers in a company
    to identify how much of the system is covered by automated tests. This will affect
    the business’s confidence level with the updates in the code base, and thus also
    affect the amount of manual testing that needs to be done, or how confident the
    business is about releasing new code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建的 `CalculationTest` 类有一个测试覆盖了 `calculateTotal` 函数。当我们运行覆盖率测试时，我们得到了 100%
    的测试覆盖率结果。如果我们向解决方案类添加更多函数，我们就不会再得到 100% 的覆盖率测试结果。那么这意味着什么呢？在实践中，这意味着我们的解决方案类的一些部分没有被我们的自动化测试覆盖。这并不是世界末日，但这将帮助公司的开发者识别系统中有多少部分被自动化测试覆盖。这将影响公司对代码库更新的信心水平，从而也会影响需要进行的手动测试的数量，或者公司对发布新代码的信心程度。
- en: 'Open the `Calculation.php` class and add the following method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Calculation.php` 类并添加以下方法：
- en: codebase/symfony/src/Example/Calculator.php
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Example/Calculator.php
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see in the preceding code block, we have added a new function called
    `add`. This function simply returns the summation of `$a` and `$b`. Since we have
    no unit test for this new function, let’s see what will happen when we run our
    test again. Run the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码块中所见，我们添加了一个名为 `add` 的新函数。这个函数简单地返回 `$a` 和 `$b` 的和。由于我们没有为这个新函数编写单元测试，让我们看看再次运行测试会发生什么。运行以下命令：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After running the preceding command, we’ll notice that something has changed
    in our test coverage result:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前面的命令之后，我们会注意到我们的测试覆盖率结果中有些变化：
- en: "![Figure 5.5 \uFEFF– Test coverage has decreased](img/Figure_5.05_B18318.jpg)"
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 测试覆盖率已降低](img/Figure_5.05_B18318.jpg)'
- en: Figure 5.5 – Test coverage has decreased
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 测试覆盖率已降低
- en: 'You will notice that before adding the `add` function inside the `Calculator.php`
    class, we had 100% test coverage. Now, we only have 50% test coverage. Obviously,
    it’s because we don’t have a unit test responsible for testing the `add` function.
    To improve our test coverage, let’s add a unit test for the `add` function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，在将 `add` 函数添加到 `Calculator.php` 类之前，我们有 100% 的测试覆盖率。现在，我们只有 50% 的测试覆盖率。显然，这是因为我们没有为
    `add` 函数编写单元测试。为了提高我们的测试覆盖率，让我们为 `add` 函数添加一个单元测试：
- en: codebase/symfony/tests/Unit/CalculationTest.php
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/Unit/CalculationTest.php
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code block, we’ve added the `testCanAddIntegers` test function.
    By using the `@covers` annotation, we have also declared that this function tests
    for the `add` function in the `Calculation.php` class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们添加了 `testCanAddIntegers` 测试函数。通过使用 `@covers` 注解，我们还声明了这个函数测试了 `Calculation.php`
    类中的 `add` 函数。
- en: 'Let’s run the test again and see whether we have improved our test coverage
    result. Run the following command again:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行测试，看看我们是否提高了测试覆盖率结果。再次运行以下命令：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we should see the following result:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该看到以下结果：
- en: '![Figure 5.6 – Back to 100% test coverage](img/Figure_5.06_B18318.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 回到 100% 测试覆盖率](img/Figure_5.06_B18318.jpg)'
- en: Figure 5.6 – Back to 100% test coverage
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 回到 100% 测试覆盖率
- en: Nice! Now, we have 100% test coverage again. We have two functions inside the
    `Calculation.php` class, and we also have two unit tests that test for each of
    these functions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，我们又有了 100% 的测试覆盖率。在 `Calculation.php` 类中，我们有两个函数，并且我们也有两个单元测试，分别测试这些函数。
- en: Now, imagine that you’re working with other developers on a project, which is
    very common. If other developers start refactoring a unit-tested class and start
    adding functions to that class without adding tests to cover them, when your team
    runs the coverage test, your team will easily and quickly identify that there
    are new functions or features in that class not covered by the automated tests.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下你正在与其他开发者合作一个项目，这是非常常见的。如果其他开发者开始重构一个单元测试过的类，并开始向该类添加函数而不添加测试来覆盖它们，当你的团队运行覆盖率测试时，你的团队将很容易且迅速地识别出该类中有新的函数或功能没有被自动化测试覆盖。
- en: What if you created a `private` function inside the `Calculation.php` class?
    If you need to test a `private` method, then you can either indirectly test the
    `private` method by testing the method that calls it or use PHP’s reflection feature.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个`Calculation.php`类中创建了一个`private`函数？如果你需要测试一个`private`方法，那么你可以通过测试调用它的方法间接测试`private`方法，或者使用PHP的反射功能。
- en: Using PHP’s reflection feature to directly test for private methods
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PHP的反射功能直接测试私有方法
- en: 'Private methods are not supposed to be accessible to external objects, but
    they can be tested indirectly as will be explained in the next section. If you
    really want to try testing for a `private` method directly, you can use this method.
    Open the `Calculator.php` class and add the `private` `getDifference` method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 私有方法不应该被外部对象访问，但它们可以间接地被测试，如下一节所述。如果你真的想尝试直接测试`private`方法，你可以使用这个方法。打开`Calculator.php`类并添加`private`的`getDifference`方法：
- en: codebase/symfony/src/Example/Calculator.php
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Example/Calculator.php
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you run the test again, you’ll see that your test coverage has decreased
    again, even if you just added a `private` method:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次运行测试，你会看到你的测试覆盖率再次降低，即使你只是添加了一个`private`方法：
- en: '![Figure 5.7 – No test for private method](img/Figure_5.07_B18318.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7 - 未测试私有方法](img/Figure_5.07_B18318.jpg)'
- en: Figure 5.7 – No test for private method
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 - 未测试私有方法
- en: 'Now, we have untested code, which is also going to be tricky to test as it’s
    a `private` method. To test this, open the `CalculationTest.php` test class and
    add the `testCanGetDifference` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有未测试的代码，这也是一个棘手的问题，因为它是一个`private`方法。为了测试这个，打开`CalculationTest.php`测试类并添加`testCanGetDifference`方法：
- en: codebase/symfony/tests/Unit/CalculationTest.php
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/Unit/CalculationTest.php
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As with the earlier test methods, we have also annotated this test to signify
    that it tests for the `getDifference` method inside the `Calculator.php` class.
    Since we are trying to test for a `private` method that is obviously not accessible
    if we just instantiate a `Calculator` object, we need to use PHP’s `ReflectionClass`.
    We have manually specified the visibility of the `getDifference` class and indirectly
    called the `private` `getDifference` method. If we run the test again, we’ll now
    see the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与早期的测试方法一样，我们也将这个测试进行了注释，以表明它测试的是`Calculator.php`类内部的`getDifference`方法。由于我们试图测试一个`private`方法，而这个方法显然在仅实例化一个`Calculator`对象时是不可访问的，因此我们需要使用PHP的`ReflectionClass`。我们已经手动指定了`getDifference`类的可见性，并间接调用了`private`的`getDifference`方法。如果我们再次运行测试，现在我们会看到以下内容：
- en: '![Figure 5.8 – Private method tested](img/Figure_5.08_B18318.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 - 测试了私有方法](img/Figure_5.08_B18318.jpg)'
- en: Figure 5.8 – Private method tested
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 - 测试了私有方法
- en: Now, we are back to 100% test coverage, having tested two `public` methods and
    one `private` method – but is this necessary or practical? I personally think
    that this is not very practical. If I have a `private` method, I’ll obviously
    use that private method inside another publicly accessible method. What I’d do
    is test for that publicly accessible method instead. If the instructions inside
    a `private` method are very complex, I don’t think it should be a `private` method
    inside a class anyway. It might need its own class, or it might need to be broken
    down more. I’ve seen a lot of good classes (classes that can do everything) with
    very complex `private` methods, and it’s a headache to maintain these types of
    classes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经回到了100%的测试覆盖率，测试了两个`public`方法和一个`private`方法——但这有必要或实用吗？我个人认为这并不太实用。如果我有一个`private`方法，我显然会在另一个公开可访问的方法中使用那个`private`方法。我会做的是测试那个公开可访问的方法。如果`private`方法内部的指令非常复杂，我认为它根本不应该是一个类内部的`private`方法。它可能需要一个自己的类，或者可能需要被进一步分解。我见过很多很好的类（可以做一切事情的类）具有非常复杂的`private`方法，维护这些类型的类是个头疼的问题。
- en: Indirectly testing for private methods
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 间接测试私有方法
- en: If I have a `private` method, I’d test the public method that uses the `private`
    method instead of going through the reflection route. If it gets too complex,
    I will think of moving this test away from the unit test suite altogether. You
    can read about integration testing later in this chapter to learn more.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我有一个 `private` 方法，我会测试使用 `private` 方法的公共方法，而不是通过反射路径。如果变得过于复杂，我会考虑将这个测试完全从单元测试套件中移除。你可以在本章后面阅读有关集成测试的内容，以了解更多信息。
- en: 'Open the `Calculator.php` class and replace the content with the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Calculator.php` 类，将内容替换为以下内容：
- en: codebase/symfony/src/Example/Calculator.php
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/src/Example/Calculator.php
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have retained the private `getDifference` method, but we have also added
    a new publicly accessible method called `subtract`, which, in turn, uses the `getDifference`
    method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留了私有的 `getDifference` 方法，但同时也添加了一个新的公开可访问的方法 `subtract`，它反过来又使用了 `getDifference`
    方法。
- en: 'Open the `CalculationTest.php` file and replace the reflection test with the
    following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `CalculationTest.php` 文件，将反射测试替换为以下内容：
- en: codebase/symfony/tests/Unit/CalculationTest.php
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/tests/Unit/CalculationTest.php
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code block, we have deleted the `testCanGetDifference` test
    that uses PHP’s `ReflectionClass` method. It’s up to you whether you want to test
    manually and individually for your private or protected methods using `reflection`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们删除了使用 PHP 的 `ReflectionClass` 方法的 `testCanGetDifference` 测试。是否手动和单独测试你的私有或受保护方法使用
    `reflection` 取决于你。
- en: In this new `testCanSubtractIntegers` method, you will notice that there are
    now two `@covers` annotations. We are explicitly declaring that this specific
    test method will cover both the public `subtract` method and the private `getDifference`
    method.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的 `testCanSubtractIntegers` 方法中，你会注意到现在有两个 `@covers` 注解。我们明确声明这个特定的测试方法将覆盖公共的
    `subtract` 方法和私有的 `getDifference` 方法。
- en: 'Run the following command to execute the coverage test again and let’s see
    whether we still pass the tests:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令再次执行覆盖率测试，看看我们是否仍然通过测试：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should see the following 100% coverage result:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下 100% 的覆盖率结果：
- en: '![Figure 5.9 – Two methods covered by one test](img/Figure_5.09_B18318.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 一个测试覆盖的两个方法](img/Figure_5.09_B18318.jpg)'
- en: Figure 5.9 – Two methods covered by one test
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 一个测试覆盖的两个方法
- en: 'You’ll notice that the coverage report states that we have tested four methods.
    Technically speaking, we only have three tests inside our `CalculationTest.php`
    test class that are reported by the test result:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到覆盖率报告指出我们已测试了四个方法。从技术上讲，我们只在 `CalculationTest.php` 测试类中有三个测试被测试结果所报告：
- en: '**OK (3 tests, 3 assertions)**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**OK (3 tests, 3 assertions)**'
- en: 'Since we have declared that the `testCanSubtractIntegers` test will be covering
    both the `subtract` and `getDifference` methods, we are able to get full test
    coverage for the `Calculator.php` class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经声明 `testCanSubtractIntegers` 测试将覆盖 `subtract` 和 `getDifference` 方法，因此我们能够为
    `Calculator.php` 类获得完整的测试覆盖率：
- en: '**Methods:** **100.00% (4/4)**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法：** **100.00% (4/4)**'
- en: We were now able to go through running unit tests, using Xdebug to debug with
    breakpoints and get test coverage results. Next, we will build our own small tools
    to run tests a little bit easier so that we don’t have to write long commands
    all the time.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够运行单元测试，使用 Xdebug 通过断点进行调试并获得测试覆盖率结果。接下来，我们将构建自己的小工具来简化测试的运行，这样我们就不必总是编写长命令。
- en: Using shell scripts to run tests
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 shell 脚本运行测试
- en: We can use shell scripts to run our tests for us, and by doing so, we can add
    extra configurations to each script. There are different configurations and commands
    to run when running PHPUnit tests, and there are different goals or intentions
    in mind when running unit tests. In this chapter so far, we ran tests to trigger
    Xdebug and go through codes, and we also used PHPUnit to get a report for our
    test coverage. To simplify the execution of these tests a bit better, we can build
    some shell scripts to help us encapsulate the commands and configurations to run
    the tests.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 shell 脚本来运行我们的测试，通过这样做，我们可以为每个脚本添加额外的配置。在运行 PHPUnit 测试时，有不同的配置和命令，在运行单元测试时，有不同的目标或意图。到目前为止，我们运行测试以触发
    Xdebug 并遍历代码，我们还使用了 PHPUnit 来获取测试覆盖率报告。为了更好地简化这些测试的执行，我们可以构建一些 shell 脚本来帮助我们封装运行测试的命令和配置。
- en: 'If you go back to your terminal and try to use Xdebug with a breakpoint, you’ll
    probably be disappointed. In PHPStorm, put a breakpoint like so in one of the
    tests:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到你的终端并尝试使用带有断点的 Xdebug，你可能会感到失望。在 PHPStorm 中，在某个测试中设置断点如下：
- en: '![Figure 5.10 – Adding a breakpoint](img/Figure_5.10_B18318.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 添加断点](img/Figure_5.10_B18318.jpg)'
- en: Figure 5.10 – Adding a breakpoint
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 添加断点
- en: 'After putting a breakpoint inside the `CalculationTest.php` class on line 16,
    run the following command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CalculationTest.php` 类的第 16 行内设置断点后，运行以下命令：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Did you notice anything? Well, the breakpoint did not get called at all. This
    is because earlier, we specified that we wanted to use Xdebug in coverage mode
    by running `export XDEBUG_MODE=coverage`. On the other hand, if we are running
    the test in debug mode and we want to get the coverage report, then we’ll have
    to run different commands again. There’s really nothing wrong with this, but if
    we are going to be developing a lot of codes and running tests repeatedly with
    different configurations, it can be helpful to use shell scripts instead.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到什么了吗？嗯，断点根本没有被调用。这是因为之前，我们指定了我们要通过运行 `export XDEBUG_MODE=coverage` 来使用 Xdebug
    的覆盖率模式。另一方面，如果我们以调试模式运行测试并希望获取覆盖率报告，那么我们可能需要再次运行不同的命令。这实际上并没有什么问题，但如果我们要开发大量代码并重复使用不同的配置来运行测试，使用
    shell 脚本可能会有所帮助。
- en: 'We will create two scripts to trigger PHPUnit and configure our environment:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个脚本以触发 PHPUnit 并配置我们的环境：
- en: '`runDebug.sh` – We’ll use this for debugging'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runDebug.sh` – 我们将使用这个来调试'
- en: '`runCoverage.sh` – We’ll use this for test coverage reports'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runCoverage.sh` – 我们将使用这个来生成测试覆盖率报告'
- en: 'In symfony’s root `dir`, create the following file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 symfony 的根目录中创建以下文件：
- en: codebase/symfony/runDebug.sh
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/runDebug.sh
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding script, we are configuring our environment to run a test with
    Xdebug. This is important during development as it will let us use breakpoints
    without having to always think about the configurations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的脚本中，我们正在配置我们的环境以使用 Xdebug 运行测试。在开发过程中这很重要，因为它将允许我们使用断点而无需总是考虑配置。
- en: 'Make sure that the file you created is executable; run the following command
    to do so:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你创建的文件是可执行的；运行以下命令来执行此操作：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we can try using this script to execute our `CalculationTest.php` class,
    and see whether our breakpoint in line 16 gets called:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试使用这个脚本执行我们的 `CalculationTest.php` 类，并查看第 16 行的断点是否被调用：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After running the preceding command, go back to PHPStorm and make sure that
    the breakpoint works:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前面的命令后，回到 PHPStorm 并确保断点可以工作：
- en: '![Figure 5.11 – Using runDebug.sh with Xdebug](img/Figure_5.11_B18318.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – 使用 runDebug.sh 与 Xdebug](img/Figure_5.11_B18318.jpg)'
- en: Figure 5.11 – Using runDebug.sh with Xdebug
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 使用 runDebug.sh 与 Xdebug
- en: Great! By using the `./runDebug.sh` script, we can configure our container dynamically
    and trigger the breakpoint in PHPStorm with Xdebug. Now, if we want to get the
    test coverage report, we’ll need to run a different script to make things easier.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！通过使用 `./runDebug.sh` 脚本，我们可以动态地配置我们的容器并触发 PHPStorm 中的 Xdebug 断点。现在，如果我们想获取测试覆盖率报告，我们需要运行不同的脚本以简化操作。
- en: 'Create a new file called `runCoverage.sh`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `runCoverage.sh` 的新文件：
- en: codebase/symfony/runCoverage.sh
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: codebase/symfony/runCoverage.sh
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding script will configure our environment and attach the `--coverage-text`
    option so that we can easily get a test coverage report when running this script.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本将配置我们的环境并附加 `--coverage-text` 选项，这样我们就可以在运行此脚本时轻松地获取测试覆盖率报告。
- en: 'Run the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Running the `./runCoverage` script should now generate the respective **Code**
    **Coverage Report**:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `./runCoverage` 脚本现在应该生成相应的 **代码覆盖率报告**：
- en: '![Figure 5.12 – Using the runCoverage.sh script](img/Figure_5.12_B18318.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – 使用 runCoverage.sh 脚本](img/Figure_5.12_B18318.jpg)'
- en: Figure 5.12 – Using the runCoverage.sh script
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 使用 runCoverage.sh 脚本
- en: Great! Now, we can run PHPUnit with different configurations. The last test
    execution returned a failure because of our previously created `ExampleTest.php`
    test class, which we deliberately failed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，我们可以使用不同的配置来运行 PHPUnit。上一次的测试执行失败是因为我们之前创建的 `ExampleTest.php` 测试类，我们故意让它失败的。
- en: You can add your own scripts depending on your needs – after all, we are software
    developers. We can build tools to make things a little bit easier for ourselves.
    When running **Continuous Integration** (**CI**), we won’t need the ability to
    debug nor run code coverage reports all the time, so we can also create a script
    further down the project for CI usage. CI will be discussed in more detail in
    [*Chapter 9*](B18318_09.xhtml#_idTextAnchor138), *Continuous Integration*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now learned how to write unit tests, and these tests are focused on testing
    small programs in our solution codes – but what if we need to test a more complex
    functionality that uses multiple classes? It would be nice if we could segregate
    those complex tests that depend on external objects or resources. In the next
    section, we’ll quickly go through the different types of automated tests.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Types of tests
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running PHPUnit tests can be very quick. In my experience, even with tens of
    thousands of unit tests, it can only take a few minutes to run them completely.
    This is because they only test small parts or units of the solution.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: We can also add tests that will call programs that will interact with external
    web service APIs or databases. Now, imagine how complex those tests are and how
    long it would take to execute them. If we combine all the complex tests that use
    multiple object and unit tests into a single group, it will take a lot of time
    to run the entire group of tests. I’ve experienced working with a company where
    there are thousands of tests that are all grouped into a single suite – you run
    the suite and wait an hour, only to find out there’s one broken unit test. That’s
    very time-consuming and impractical.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Grouping tests](img/Figure_5.13_B18318.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Grouping tests
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Identifying what a test does and putting it in the right group or basket of
    tests can help with organizing the tests. There are different types of tests that
    we can use as “baskets” or groups for our tests. We can simplify these baskets
    and divide them into two main types. In PHPUnit, these baskets are called test
    suites.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Basket 1 – unit tests
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve written unit tests earlier in this chapter. If you remember, we created
    a directory inside the `codebase/symfony/tests` directory called `Unit`. This
    will be our unit test basket. Every test that specifically tests small parts or
    units of the solution will be put into this directory, and in turn, the namespace
    is the following: `App\Tests\Unit`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `codebase/symfony/phpunit.xml` and you’ll notice that we have declared
    a `testsuite` named `Unit` in the `tests/Unit/` directory. We will use test suites
    to help group and segregate our tests. This will come in handy when we want to
    isolate the group of tests we want to run:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This means that if we want to run the `Unit` test suite, PHPUnit will find all
    of the tests inside the `tests/Unit/` directory.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'To run all the tests inside that unit basket or test suite, run the following
    command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You’ll get the following result:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Unit test suite](img/Figure_5.14_B18318.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Unit test suite
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: By adding the `--testsuite` unit option, we ensure that we only run tests inside
    the `App\Tests\Unit` namespace. This will help us focus our test execution on
    a specific basket or test suite.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: We have covered the first group or basket of tests. We have created a directory
    called `Unit`, and this is where we will put all the future unit, or simple, tests.
    Next, we’ll need to create a separate group or basket to put the more complex
    tests.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Basket 2 – integration tests
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integration testing aims to test a bigger part of the solution. Instead of testing
    a small unit of the application, integration tests aim to cover different parts
    of the solution in a single test.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Imagine testing an object’s method that uses other objects. The success of the
    test can depend on external factors such as a database connection, an API call,
    or dependence on other classes that also depend on other classes. It’s like a
    unit test on a slightly bigger scale.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have a class that computes some total and then persists
    it in the database, you’d want to have a test that checks the computation result
    that is persisted in the database. This is where integration tests can be very
    useful.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: We previously created a directory for our unit tests – now, let’s create a directory
    to contain our integration tests.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `Integration` directory inside the `tests` directory:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After creating the `Integration` directory, we need to let PHPUnit know about
    this directory. We need to add an `Integration` test suite and declare the directory
    path. Open `codebase/symfony/phpunit.xml` and use the following configuration:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, the `Integration` test suite has been registered. With this, we can still
    safely run our unit tests by passing the `Unit` argument to the `--testsuite`
    option when running our tests. To run integration tests, we simply use `--testsuite`
    `Integration` instead:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since we have no tests, running the preceding command will return the following
    result:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Integration test suite](img/Figure_5.15_B18318.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – Integration test suite
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basket to put all our integration tests into, let’s start
    writing our first integration test!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: We already have a unit-tested class, the `Calculate.php` class. Now, it would
    be great if we could use this as a part of our integration test example.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Integration test example
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will try to do some calculations and then try to store the
    result in the database. We will create a database called `coffee` and try to create
    a program that simply calculates the sum of how many coffee cups we had in a day,
    and then persist it. After persisting, we need to be able to verify whether the
    persisted sum is correct.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Installing Doctrine with Symfony 6
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we are using the Symfony framework, which works well with Doctrine, let’s
    just use Doctrine to persist and retrieve data from our database. There are a
    lot of ways to persist and retrieve data from a database, but for this project,
    we’ll just focus on using Doctrine to simplify our examples so that we can focus
    on testing rather than reinventing the wheel. Doctrine is an ORM. You can read
    more about Doctrine at [https://www.doctrine-project.org](https://www.doctrine-project.org).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s install Doctrine by running the following commands:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After running the preceding commands, which can take a few minutes, create
    a local environment file, and save it with the following content:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: codebase/symfony/.env.local
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding line, we are telling Symfony that in our local environment,
    we’d like to use our MySQL container that we created in [*Chapter 3*](B18318_03.xhtml#_idTextAnchor039),
    *Setting Up Our Development Environment Using Docker Containers*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: You can open up the `docker-compose.yml` file to review the MySQL container
    details. You can make any further configuration changes there to suit your needs.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – MySQL container settings for Doctrine](img/Figure_5.16_B18318.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – MySQL container settings for Doctrine
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: You can change the database password here, or even change the MySQL version
    to whichever you need. In the `.env.local` file, we have specified that we want
    to use MySQL8, and we also specified that we want to use the `server-mysql` container,
    instead of using the IP address of the database server. We also used `coffee`
    as our database name.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will use the Doctrine ORM to create a MySQL database for us. We will
    then be using this new database for our example integration test.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Doctrine and database
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have configured our environment so that it can connect to the MySQL server
    container we created, and we have specified the database name we want to use for
    our example. Now, at this stage, we are ready to create a database for our integration
    test example. Run the following command:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: By running the preceding command, Doctrine will create a database named `coffee`
    for us, using the parameters we provided in the `.``env.local` file.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Creating a new database](img/Figure_5.17_B18318.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – Creating a new database
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have our own database to play with. If you have a desktop MySQL client,
    you can connect to the `server-mysql` container to view the database we just created.
    If not, to make things look a bit prettier than the unending terminal windows
    for our automated tests, we have added a `PHPMyAdmin` container for quick and
    easy DB access back in [*Chapter 3*](B18318_03.xhtml#_idTextAnchor039), *Setting
    Up Our Development Environment Using Docker Containers*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your web browser and go to the following URL: `http://127.0.0.1:3333/index.php`.
    You will see the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – coffee database](img/Figure_5.18_B18318.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – coffee database
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Before we write any codes that will utilize the database we just created, first,
    we need to understand what we want to do with it and create an integration test
    for it. Next, we’ll create our first failing integration test.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Failing our first integration test
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have a solution to persist information, which is Doctrine and MySQL. We also
    have a way to calculate the sum of some random integers. Now, let’s put them to
    use. We want to be able to pass a string name and three integers to represent
    the number of cups of coffee we consumed, get the sum, and persist it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following integration test file:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: codebase/symfony/tests/Integration/ConsumptionTest.php
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We created our first integration test inside the `App\Tests\Integration` namespace,
    which, in turn, will be a part of our integration test suite. Run the following
    command to make sure everything works, and that our test fails as expected:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You should see the failed test, caused by the `$this->fail("--- RED --");`
    line we have created:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – First failing integration test](img/Figure_5.19_B18318.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – First failing integration test
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Great! We now have a failing `Integration` test suite test. Now, all we must
    do is make it pass.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to break down exactly what we want to do, and what we want to test
    for:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: We want to be able to track how many cups of coffee a person drinks in a day
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to have the number of coffee cups consumed in the morning, afternoon,
    and night
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to get the sum and then persist the total, along with the name of the
    person
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to be able to retrieve the persisted record and check whether it’s correct.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on the preceding list, we can then update our test with the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: codebase/symfony/tests/Integration/Service/ConsumptionTest.php
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, we have an incomplete test – but for me, this is good. I write
    a failing test and make sure it fails, but I also try to start writing exactly
    what I want to test for.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to see what happens:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The test tries to instantiate the `ConsumptionService.php` class that does
    not exist. Therefore, you’ll get the following result:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – ConsumptionService not found](img/Figure_5.20_B18318.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20 – ConsumptionService not found
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: We deliberately tried to instantiate an object from a class that does not exist,
    therefore resulting in a test failure. What does this tell us? Remember `ConsumptionService.php`
    class and the other program it needs to use. We should always fail our test first.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: However, before we write the `ConsumptionService.php` class, let’s create the
    Doctrine entity needed by the `ConsumptionService.php` class for our example.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Doctrine entity
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s create an entity class to represent our data. A Doctrine entity is just
    a simple **Plain Old PHP Object** (**POPO**) with some Doctrine-specific annotations
    that can be mapped to a database table in its most basic usage.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create a `Consumption.php` class:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After running the preceding command, enter the fields you want to create. For
    our example, use the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'After the command prompts, you should now see a new entity class file in `codebase/symfony/src/Entity/Consumption.php`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – Consumption entity](img/Figure_5.21_B18318.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: Figure 5.21 – Consumption entity
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the file, you’ll see the automatically generated Doctrine entity
    codes:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In summary, we only have two fields to play with, the name and total fields.
    That’s going to be perfect for our integration test example.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll need the actual database table that our Doctrine entity is going
    to represent. We will use Doctrine ORM to run the migration tool so that we can
    generate the database tables we need.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Doctrine table for the entity
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have an entity, let’s also create the database table that the `Consumption`
    entity represents.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After running the preceding commands, a new database table should be created
    for you. If you go back to the `Consumption.php` entity class:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22 – consumption database table](img/Figure_5.22_B18318.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: Figure 5.22 – consumption database table
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: We now have a database table that will be represented by our `Consumption.php`
    entity class. This table will be used to persist our coffee drinkers’ coffee consumption
    records!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: However, when working on a real project, we don’t want to use the main database
    for running our tests; otherwise, our tests will end up inserting test data into
    the production database. Next, we’ll create the test database. This database will
    be specifically used by our integration tests and will mirror the structure of
    the main database.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test database
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like in the previous set of instructions, we’ll also create a database
    based on some environment configuration – but this time, this is specifically
    intended to be used by our tests.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `.env.test` file and add the following line at the end of the file:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You’ll notice that it’s identical to the value we used for the `.env.local`
    file. Notice that we reused `coffee` as the database name.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following command to create the test database:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: A new database named `coffee_test` will be created. `_test` is suffixed to the
    `coffee` database name we have specified. Every integration test we run that uses
    the database will use the `coffee_test` database to persist and read data.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, run the following command so that we can also migrate the `Consumption`
    table into our new `coffee_test` database:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: At this stage, we’ll have two almost identical databases. The `coffee` database
    that’s to be used for the solution, and the `coffee_test` database that’s to be
    used for our tests.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23 – Coffee databases](img/Figure_5.23_B18318.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: Figure 5.23 – Coffee databases
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created our databases, and we also have the Doctrine ORM, which
    will serve as the main tool for communicating with our database from the PHP code
    base, we will now start building the solution codes to pass our failing integration
    test.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Putting things together
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this stage, we’re now ready to start building the missing solution code that
    our `ComputationServiceTest.php` integration test keeps on complaining about.
    Remember this message from our failing test?
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '`Error: Class "App\Tests\Integration\Service\ConsumptionService"` `not found`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start fixing that error by following these steps:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open the `services.yaml` file and update it with the following content:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/config/services.yaml
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Since we are using Symfony for this example, we will use its PSR-11-compliant
    service container to create instances of the objects we need. Instead of using
    the *new* PHP keyword to create an instance of the `ConsumptionService.php` class
    that we are about to write, we’ll use the service container instead.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following class with the following content:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/src/Service/ConsumptionService.php
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Let’s quickly go through the things we did in this class before we move back
    to our integration test class. The `ConsumptionService` class depends on two objects,
    `ManagerRegistry` and `CalculationService`. The `calculateAndSave` method will
    then use these two objects to achieve its goal.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s go back to the `ConsumptionServiceTest.php` class, and replace its
    content with the following:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/symfony/tests/Integration/Service/ConsumptionTest.php
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'I have left comments in the code to explain clearly what we did in the test.
    Let us understand it in more detail:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '`KernelTestCase` class, we can use the `static::getContainer()` method to get
    an instance of Symfony’s service container. We will use this to create an instance
    of our `ConsumptionService` instead of manually using the `new` PHP keyword to
    instantiate it.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConsumptionService` class expects two objects in its constructor. With the
    service container being configured for auto wiring, the container will automatically
    instantiate the dependencies declared in the constructor of `ConsumptionService`.
    The auto wiring configuration is declared in `codebase/symfony/config/services.yaml`
    we have modified earlier in this chapter.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateAndSave` method. We expect that in this step, the summation of the
    three integers we provided will be summed up, and then persisted into the database.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateAndSave` method succeeded in doing its job, then we can test it for
    real. We will retrieve a hydrated `Consumption` entity by using the entity manager
    object inside `ConsumptionService`. We will read the data stored in the database
    and compare it to the `$expectedTotal` and `$name` values we have declared in
    the test by using the `assertEquals` method. If all goes well, then we should
    now be able to pass the test.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, execute the integration test again by running the following command:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This time around, we should now be able to pass the test!
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Great! We finally passed our first integration test! To see the record that
    we just created in the database, run the following command:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You should get the following result:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24 – Database result](img/Figure_5.24_B18318.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: Figure 5.24 – Database result
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Success! We were able to create an integration test, create the solution class,
    and finally pass the integration test!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Why did we use an integration test in the first place?
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the `ConsumptionService.php` class and check the `constructor` method.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, we have specified two required parameters. We require a
    `ManagerRegistry` instance and a `Calculator` instance that we ourselves developed
    earlier in the chapter. These are two objects that our `ComputationService.php`
    class depends on. Now, this is exactly why we need an integration test and not
    a unit test.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: When we execute the `calculateAndSave` method, we will be using business logic
    that our `ConsumptionService` does not have. Rather, it depends on other objects
    to achieve its goal. In contrast with the methods we build unit tests for, those
    methods do not rely on other objects to do their jobs. That’s the main difference
    between a unit test and an integration test.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we defined what unit testing is by writing our own examples.
    We have gone through building and passing unit tests, as well as writing our own
    shell scripts to help us execute different automated test configurations to make
    it easier for us to debug or run test coverages. We’ve gone through what a test
    coverage report is, and how we can use it.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: We’ve written our first integration test and configured our development environment
    so that we can also use a MySQL database. We’ve created a solution class that
    will perform the business logic that we need to pass the test, and we are also
    able to verify that what we persist in the database is what we have intended.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we tried to clearly define what a unit test and an integration
    test are, how they differ, and why we must separate them into their baskets or
    test suites.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be talking about **Behaviour-Driven Development**
    (**BDD**). We will understand what it is used for, why we need it, and how it
    is related to TDD.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
