- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Libraries and Class Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve only worked with Ruby and its core components without the advantage
    of other libraries that are available in Ruby. Additionally, we’ve only taken
    a partial peek at Ruby objects and classes. In this chapter, we will take a test
    drive with you to learn about Ruby libraries (gems) and how we can take advantage
    of the Gemfile to do so. Lastly, we’ll also learn the basics of class syntax to
    help us move toward more advanced tools, such as Ruby on Rails.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get ready to bundle!!!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gemfile versus `composer.json`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating libraries into your code in Ruby
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring classes in Ruby
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects in Ruby
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance in Ruby
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along this chapter, we will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Any IDE to view/edit code (e.g., SublimeText, Visual Studio Code, Notepad++,
    Vim, Emacs, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For macOS users, you will also need to have Xcode Command Line Tools installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby version 2.6 or later installed and ready to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code presented in this chapter is available at [https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get ready to bundle!!!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming languages by themselves, while useful, can’t take into account every
    single use case that a programmer might encounter. The core of the language includes
    many useful libraries, so out of the box, the language is quite useful. This is
    true for most programming languages. However, there comes a time when we need
    to go beyond the core library and use other libraries to solve our issues at hand.
    In Ruby, the community has created a number of libraries, fondly named *gems*.
    To keep track of these gems, the Ruby community has come up with a tool called
    *bundler*. To season PHP developers, the PHP counterpart for the bundler is Composer
    ([https://getcomposer.org/](https://getcomposer.org/)). The two work for the same
    purpose (managing libraries), but bundler works slightly differently in that it
    installs the libraries in the computer, while Composer merely makes them available
    for your project. But wait – we haven’t even installed a library yet. Let’s take
    a step back and install a Ruby gem.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a gem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before letting bundler take over, we should understand what and how to install
    gems on our system. Ruby has the ability to parse JSON objects, but there is a
    gem called `oj` that is more efficient in handling JSON strings and converting
    them to Ruby hashes. Let’s first install the `oj` gem. In a shell, let’s type
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the following output after running the preceding command and
    pressing the *Enter* key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations! We have installed our first gem and are now ready to use it
    within our code. Let’s put this gem to the test by creating a file called `reading_json.rb`
    and adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s go back to our shell and try to execute the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Why is our script failing? Well, we installed our gem and did not get any errors
    while doing so. As it turns out, we not only need to install our gem but also
    need to import it within our code. Let’s do that at the beginning of our file,
    so our code will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let’s execute our script again with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will get the correct output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we’ve converted a JSON string into a Ruby hash, and it is now
    ready to be used within our script. This is useful when loading configuration
    from a JSON file or when processing an API call that returns a JSON response.
    However, there is one issue that we have not dealt with yet. How can we make sure
    that other people who use our script will have the same results? Well, this is
    the cue for both bundler and the Gemfile to enter our scene.
  prefs: []
  type: TYPE_NORMAL
- en: Gemfile versus composer.json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I mentioned before, bundler helps us handle all our program’s dependencies
    – that is, everything we need to install in order for our program to run correctly.
    To accomplish this, bundler uses a text file, which we will call a `Gemfile`.
    Composer works in a very similar way by having us create a file called `composer.json`,
    but while Composer downloads the required libraries into a folder, bundler installs
    them on our system. If bundler determines that a dependency is missing, it will
    automatically try to install it. Ruby’s way is a bit more magical (or automatic).
    Let’s take bundler for a test drive to understand the process a little further.
    We will start by uninstalling our previously installed `oj` gem with the following
    command in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will confirm when the gem is removed from our system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we try to run our `reading_json.rb` again, we will get the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We are back to where we started, but now we will solve our library (or gem)
    installation with a Gemfile. Let’s create a file called `Gemfile` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we tell bundler where to download the dependencies and what our
    dependencies are. We could tell bundler other things, such as the gem version
    or even what Ruby version (or equivalent) to use, but for now, we’ll keep it simple.
    Now, let’s try it. On a shell, let’s type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the operating system that you’re using, you may need to type your
    root or administrator password, but once you do, the output of the command should
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our gem is installed, we can safely run our script again with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the exact same output as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'However, now we will notice something slightly different. If we look at the
    contents of the folder where we have our script and the Gemfile, we also have
    a new file called `Gemfile.lock`. Also, if we look at the contents, there should
    be something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `Gemfile.lock` file serves as a map of dependencies. If there is no map,
    bundler has to build it from scratch, and this process sometimes takes a while.
    However, if there is a lock file, even if the dependencies have not been installed,
    the process of installing them is much more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve come a long way from just installing a gem to now creating the ideal scenario
    for our script to run. In the next section, we’ll look at additional options (such
    as using a specific version of a gem) that we can set with our Gemfile to add
    further specificity to our Ruby environment.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating libraries into your code in Ruby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most useful skills you should acquire in your path to becoming a
    seasoned Ruby developer is integrating other gems into your code. As we’ve seen
    before, this is accomplished by using the Gemfile, but we’ll look at some additional
    options we can add to it and integrate them into our own scripts. Let’s write
    a script that takes the GitHub public API and lists all of the public repos for
    the user `@PacktPublishing`. There are several ways we could do this, but for
    this example, I’ve chosen a gem called **Faraday**. You can take a look at the
    source code here: [https://github.com/lostisland/faraday](https://github.com/lostisland/faraday).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Faraday is a client library that can help us make `Net::HTTP` library that
    comes with Ruby. Let’s create a folder called `integrating_gems` and navigate
    to that folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create a file called `Gemfile` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Before installing these gems, I’d like to use more options available in the
    Gemfile syntax. We’re going to lock the Faraday version at 2.5, which simply means
    that we install a specific version. So, let’s change the Faraday line to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Locking to a version has, of course, its advantages and its disadvantages.
    Among the advantages is that you can be sure that the script will work the same
    way, with usually the same syntax, in several environments. The downside is that
    you probably would be locked to a Ruby version, and you could end up in a scenario
    where you won’t be able to upgrade Ruby until you upgrade the gem. For the `oj`
    gem, we will use the `~` operator and set it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `~` operator is used to delimit ranges of versions. In this specific case,
    we tell bundler to get the highest released version between 3.13.0 and 3.14, excluding
    3.14 – in other words, we require a version larger or equal to 3.13 but less than
    3.14\. So, why use this operator? Well, in short, the `~` operator is used to
    increase stability within our dependencies. I won’t go into depth as to why we
    would use this syntax. Just know that you will encounter it sooner or later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you want to dig deeper into this topic, please refer to the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://thoughtbot.com/blog/rubys-pessimistic-operator](https://thoughtbot.com/blog/rubys-pessimistic-operator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://guides.rubygems.org/patterns/#declaring_dependencies](https://guides.rubygems.org/patterns/#declaring_dependencies)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our Gemfile will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s install our dependencies again with bundler. On a shell, type in
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll get output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with our gems ready, we can use them in our script. Let’s create a script
    called `faraday_example.rb` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a step back and see what we are doing. We’re importing the `faraday`
    and `oj` gems. Then, we’re creating a client that will connect to the GitHub API.
    The client object requires a URL and some headers, which we provided. So far,
    we have not called the API yet. Let’s do that. At the end of the file, add the
    call to the API and output the response with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s try to execute this script with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output a lot of text, so I’m going to include only an excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With that output, we can confirm that we have successfully connected to the
    GitHub API. For the last part of the exercise, let’s use the `oj` gem to convert
    the JSON text to a Ruby hash and output the names of all of the responses that
    the API returned. So, let’s remove the `puts` command and replace it with an `oj`
    object. Our code will look like this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we’ve taken the response from the GitHub API service and converted it to
    a Ruby hash. Lastly, let’s output the names of the repos by adding the following
    to the end of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the script one last time, an excerpt from the output will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we’ve successfully connected to an API with the Faraday gem and
    processed the output with the `oj` gem. For reference, this is what the code should
    ultimately look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is the starting point for how to share code to be run in other environments.
    Should we want others to be able to run our script, we should include both the
    script and the Gemfile with our shared code so that others know what needs to
    be installed before running the scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Also, just so you know, this was merely an exercise to learn how to include
    and use gems within our code. The syntax on the Gemfile was only procured for
    learning purposes. You should always aspire to have the latest version of a gem.
    However, locking to a version is useful when you want to have control of when
    and where you do upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve established how gems work and their usage, we can now move on
    to object-oriented programming in Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring classes in Ruby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both PHP and Ruby are languages that use the **Object-Oriented Programming**
    (**OOP**) paradigm, Ruby by design and PHP by its own evolution. By now, serious
    developers should be very familiar with the paradigm. In PHP, all frameworks use
    OOP. While we are not going to go in depth into how this paradigm is implemented
    in Ruby, we will go through the basics of class syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class is basically an abstraction of a real-world entity. It is the blueprint
    of this abstraction. Let’s start by creating a simple class representing a person,
    some attributes for this person, and an action (or method) for them. Let’s create
    a file called `class_syntax.rb` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is as simple as it gets, but this by itself is not very useful. For this
    to be useful, we need to add attributes that represent the characteristics of
    a person. So, let’s add some attributes such as their first name and their last
    name. Our code will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have defined our attributes by prepending them with `@`. These
    are called instance variables and can only be accessed by a method. Now, let’s
    define a method to print out the full name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With the exception of the instance variable, note that we are not doing anything
    we have not learned before. We defined a method (or function), and we included
    the first and last name variables on the string to be printed by the method. One
    last thing we will do to this blueprint is add a constructor. In OOP, a constructor
    is a method that can be customized to add behaviors and attributes when we create
    an object with a class definition. In other words, when we take the blueprint,
    we define and use it to create a specific object, and we can control certain values
    at the time of creation of the object. In PHP, this method is implemented by simply
    naming the method `__constructor()`. Its equivalent in Ruby is naming the method
    `initialize()`. Let’s now include it in our class definition. Our class definition
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note that we no longer need the instance variable definition, as this is done
    on the constructor (initializer). Congratulations! Our first class is ready to
    be used. Let’s now move on to the next section to create our first object using
    this class definition.
  prefs: []
  type: TYPE_NORMAL
- en: Objects in Ruby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we defined what our abstraction of a person should
    look like. It is a person that will have a first name and a last name, and we
    will be able to print out their full name. In parallel to the construction business,
    since we now have a blueprint, we are now ready to erect our building with these
    specifications. This creation is what we call an instance or an object of a class.
    The class definition is generic and the instance is specific. Without going too
    deep into this relationship between a class definition and an object, we’ll take
    a look at what this relationship looks like in code and how this will help us
    make better and more readable code. Let’s take our previous code and create our
    first object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve now created a specific person based on our class, and we are now ready
    to call some of the methods for that person. We can now call the `full_name()`
    method. Let’s do that by adding the following line to the end of our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s run our script again from the shell with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And voilà! We’ve finally given our class a more practical use. We are now able
    to create as many objects (persons) as we want with the class definition. However,
    we still have an issue. Our class only lets us create persons that are named James
    Raynor. We wanted specificity, but this turned out to be too specific. We need
    to modify our class so that we can create more generic objects. So, let’s do that
    by adding parameters to our constructor. Our code will now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve added two parameters to our constructor method. The first name we pass
    to our class will be assigned to our instance variable, `@first_name`, so that
    it will be available to other methods. The same goes for the last name. An additional
    adjustment that we must make now is to pass the first and last names to our constructor.
    So, let’s do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create as many instances (or objects) as we want. Let’s add two
    more people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s run our script on our shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We’ve made our blueprint more generic, and we can now create different characters
    from that blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to our next topic inheritance, I want us to take a look at
    a class tool that you will encounter in the future and that you’ll find extremely
    useful – attribute accessors.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute accessors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our class definition, we have the `first_name` and `last_name` attributes,
    and we also have a `full_name()` method. However, what if we wanted to output
    the person’s first name? We might be tempted to try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this would fail miserably with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where Ruby deviates from how PHP would look or behave. Ruby can apparently
    have a method and an attribute with the same name. While this is not technically
    true, let’s for argument’s sake say that it is so that we can momentarily move
    forward with the exercise. Let’s create a method called `first_name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The method looks strange, but let’s remember that Ruby doesn’t need us to explicitly
    return a value as it does it automatically. So, the method is simply returning
    the value contained in `@first_name`. While useful, we would have to do this for
    every attribute we defined. Additionally, we only created the method to obtain
    the value. We would also need to create a method to set the value. However, I
    have some good news for you. Ruby has already solved this issue with attribute
    accessors. An attribute accessor automatically creates the methods to get and
    set the value. We only need to indicate which attribute we want this “magic” to
    have. Let’s define the attribute accessors and then exploit them. Our final code
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s run it again with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note how we did not have to define the `last_name` method, and yet it’s available.
    At some point in your path towards learning Ruby, I guarantee you will encounter
    the `attr_accessor` tool. Ruby also has `attr_reader` and `attr_writer`, which
    separate into two methods what `attr_accessor` does by itself. Should you want
    to go more in depth into attribute accessors, what they do exactly, and see other
    examples, you may want to visit [https://www.rubyguides.com/2018/11/attr_accessor/](https://www.rubyguides.com/2018/11/attr_accessor/).
  prefs: []
  type: TYPE_NORMAL
- en: Are you ready to make more powerful classes? Then, let’s hop to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance in Ruby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve looked at a few features that come with Ruby’s implementation
    of the OOP paradigm, but we have neglected to look at one of the core features
    that help us recycle code. Inheritance can be simplified as the practice of passing
    the features of a class to create a brand-new child class. With this new class,
    we can use any of the features from the parent class, create new features, or
    customize the features that come from the parent class. The syntax for inheritance
    can be quite different than in PHP, but the behavior is quite similar. With that
    in mind, let’s take a look at a few use cases and see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we wanted a class that would let us connect to a database. Instead
    of having to write all the functionality to connect to a database, we could get
    an already created database class, create a new one that inherited all the database
    functionality, and then focus on creating just the features that we need. This
    is one way to reuse code with inheritance, but let’s use a simpler example so
    that we can see inheritance in practice. Let’s say we wanted to make an abstraction
    of a user. The user must have first name, last name, age, and email details. We
    can take the `Person` class, defined in the previous section, inherit the features
    in our new `User` class, and just focus on the missing pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s take our `Person` class and create a file called `inheritance_example.rb`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create a new class below our original class called `User` and inherit
    from the `Person` class. We’ll do this with the `<` operator. Let’s add this to
    the end of our `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'With just two lines of code, we’ve made a brand-new class that behaves (for
    now) in the exact same way as the `Person` class. Let’s confirm that by creating
    a new `User` object. Let’s now add the following to the end of our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s try to run this script from our shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Our script failed, but why? As we read through the message, it states that
    the constructor expected two parameters, but none were given. From our previous
    execution example, we can infer that we have to give our constructor the parameters
    for the first name and last name. So, let’s add those parameters, and let’s also
    call the `full_name()` method. Our code will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s run this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The script will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have confirmed that, out of the box, this newly created class has inherited
    all of its functionality from the `Person` class. Nowhere did we have to define
    the `full_name()` method, as it’s already available. Additionally, the constructor
    automatically assigned the first and last name to our `@first_name` and `@last_name`
    instance variables, respectively. Again, we only had to have this class inherit
    from the `Person` class. However, using the example that we provided at the beginning
    of this section, we want to add an additional attribute called `email`. So first,
    we will add an attribute accessor for the `email` attribute. Our `User` class
    now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now assign the `em.ail` attribute from our object with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'However, what we want to do is include this assignment in the new `User` constructor.
    This is not as easy as it seems, but it’s not that difficult either. So, we first
    have to define a constructor for our new `User` class. Let’s do just that. Our
    `User` class will look like this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'However, by doing this, we’ve overwritten the original constructor method (initializer).
    But do not despair, as the original constructor is still available via the `super()`
    method. The `super()` method calls the original constructor, but you must provide
    the original number of arguments. So, to finish this example, let’s again add
    the first name, last name, and email to our constructor and, finally, call the
    `super()` method. Our final code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We’ve successfully used inheritance to reuse our `Person` class functionality
    and built a new class called `User`. When talking about classes using inheritance,
    you’ll hear the term hierarchy. When talking about hierarchy, we’re referring
    to the position on an imaginary structure of our classes where on the top, we
    will have the most generic class and on the bottom the most specific class. For
    this example, the hierarchical relationship between the `Person` class and the
    `User` class may start to make sense, with the `Person` class being the most generic
    class and thus the one on top. In other words, a user is a person; thus, the person
    must have the attributes of a user and a person. The opposite is not true. A person
    may no necessarily be a user. A person could be a client and have a different
    use case where we don’t need the email attribute. While designing your Ruby classes,
    if you take into account this hierarchy, it will be easier for you to determine
    what functionality should go where to write less code and not have issues with
    repeating unnecessary code. While this example is extremely simplified, it showed
    us how easy it is to build reusable classes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how Ruby libraries are installed, used, and named
    (gems). We also learned to use the bundler tool to install gems, creating environments
    for our scripts and programs to function correctly. Lastly, we learned the most
    basic OOP syntax to both create, instantiate, and inherit classes. Now, we are
    ready to start debugging.
  prefs: []
  type: TYPE_NORMAL
