- en: Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序
- en: 'The Application layer is the area that separates the Domain Model from the
    clients that query or change its state. Application Services are the building
    blocks for such a layer. As Vaughn Vernon [says](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577):
    "Application Services are the direct clients of the domain model." You could think
    about an Application Service as a point of contact between the outside world (HTML
    forms, API clients, the command line, frameworks, UI, and so on.) and the Domain
    Model itself. It might help by thinking about the top-level use cases that your
    system exposes to the world, example: "as guest, I want to register," "as a logged
    user, I want to purchase a product," and so on.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序层是分隔领域模型（Domain Model）和查询或更改其状态的客户端的区域。应用程序服务是构建此类层的基本块。正如Vaughn Vernon[所说](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577)：“应用程序服务是领域模型的直接客户端。”你可以将应用程序服务视为外部世界（HTML表单、API客户端、命令行、框架、UI等）与领域模型本身的接触点。通过考虑系统向世界公开的最高级用例可能会有所帮助，例如：“作为访客，我想注册”，“作为已登录用户，我想购买产品”，等等。
- en: In this chapter, we'll explore how to implement Application Services, understand
    the role of the Command pattern, and establish the responsibilities of an Application
    Service. To do this, let's consider the use case of *signing up a new user*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何实现应用程序服务，了解命令模式的作用，并确定应用程序服务的责任。为此，让我们考虑*注册新用户*的用例。
- en: 'Conceptually, in order to register a new user, we need to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，为了注册新用户，我们需要：
- en: Get an email and password from the client
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从客户端获取email和密码
- en: Check if the email is already in use
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查email是否已被使用
- en: Create a new user
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新用户
- en: Add this new user to the existing user set
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此新用户添加到现有用户集
- en: Return the user we've just created
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回我们刚刚创建的用户
- en: Let's go for it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Requests
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求
- en: We need to send the `email` and `password` to the Application Service. There
    are many ways of doing such a thing from the client (HTML form, API client, or
    even the command line). We could just send standard parameters (email and password)
    through the method signature or build and send a data structure with this information.
    The latter approach, sending a [DTO](http://martinfowler.com/eaaCatalog/dataTransferObject.html),
    brings some interesting features to the table. By sending an object, it'll be
    possible to serialize and queue it over a Command Bus. It'll also be possible
    to add type safety and some IDE help, too.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将`email`和`password`发送到应用程序服务。从客户端（HTML表单、API客户端，甚至是命令行）有多种方法可以这样做。我们可以直接通过方法签名发送标准参数（email和password），或者构建并发送包含这些信息的数据结构。后一种方法，发送[DTO](http://martinfowler.com/eaaCatalog/dataTransferObject.html)，在桌面上带来了一些有趣的功能。通过发送对象，它将被序列化并排队在命令总线（Command
    Bus）上。它还可能添加类型安全和一些IDE帮助。
- en: Data Transfer Object
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数据传输对象
- en: A DTO is a data structure that carries information between processes. Don't
    mistake it for a full-featured object. A DTO doesn't have any behavior except
    for storage and retrieval of its own data (accessors and mutators). DTOs are simple
    objects that shouldn't contain any business logic that would require testing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: DTO（数据传输对象）是一种在进程之间携带信息的数据结构。不要将其误认为是具有完整功能的对象。DTO除了存储和检索自己的数据（访问器和修改器）之外，没有任何行为。DTO是简单的对象，不应包含任何需要测试的业务逻辑。
- en: 'As Vaughn Vernon [says](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '如Vaughn Vernon[所说](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577):'
- en: Application Service method signatures use only primitive types (`int`, `strings`,
    and so on.), and possibly DTOs. As an alternative to these approaches, however,
    a better approach may be to design Command objects instead. There is not necessarily
    a right or wrong way. It mostly depends on your tastes and goals.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序服务方法签名仅使用原始类型（`int`、`strings`等），以及可能的DTO。然而，作为这些方法的替代方案，更好的方法可能是设计命令对象。这并不一定有对或错。这主要取决于你的品味和目标。
- en: 'The implementation for a DTO that holds the data required for the Application
    Service could be something like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 用于存储应用程序服务所需数据的DTO实现可能如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you see, `SignUpUserRequest` has no behavior, only data. This could have
    come from an HTML form or an API endpoint, though we don't care which.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`SignUpUserRequest`没有行为，只有数据。这可以来自HTML表单或API端点，尽管我们不在乎它是哪一个。
- en: Building Application Service Requests
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建应用程序服务请求
- en: 'Creating a request from the delivery mechanism, your favorite framework, should
    be pretty straightforward. On the web, you could pick up parameters from the controller
    request and pass them down to the Service inside a DTO. The same principle applies
    for a CLI command: read input parameters and send them down again.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从交付机制、你最喜欢的框架中创建请求应该相当直接。在网络上，你可以从控制器请求中提取参数，并将它们传递到DTO中的服务内部。同样的原则也适用于CLI命令：读取输入参数，然后再发送下去。
- en: 'With Symfony, we can extract the data we need from Request object from the
    `HttpFoundation` component:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Symfony，我们可以从`HttpFoundation`组件中提取我们需要的请求对象数据：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On a more elaborate Silex application that uses the `Form` component to capture
    and validate parameters, it would look like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个更复杂的Silex应用程序中，它使用`Form`组件来捕获和验证参数，看起来会是这样：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Request Design
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求设计
- en: 'When designing your request objects, you should always follow these principles:
    use primitives, design for serialization, and don''t include business logic inside.
    This way, you''ll be able to save unit testing dollars.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计你的请求对象时，你应该始终遵循以下原则：使用原始数据类型，设计为可序列化，并且不要在内部包含业务逻辑。这样，你将能够节省单元测试的成本。
- en: Use Primitives
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原始数据类型
- en: We recommend using basic types to build up your request objects — that means
    strings, integers, booleans, and so on. We're just abstracting away input parameters.
    You should be able to consume Application Services independently from the delivery
    mechanism. Even pretty complicated HTML forms get translated into basic types
    all the time at the controller level. You don't want to mix up your framework
    and your business logic.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用基本类型来构建你的请求对象——这意味着字符串、整数、布尔值等等。我们只是在抽象化输入参数。你应该能够独立于交付机制来消费应用程序服务。即使是相当复杂的HTML表单，在控制器级别也总是被转换成基本类型。你不希望混淆你的框架和业务逻辑。
- en: With certain scenarios, it's tempting to use Value Objects directly. Don't do
    it. Updates on the Value Object definition will affect all clients, and you'll
    be coupling clients with your Domain logic.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景下，直接使用值对象可能很有诱惑力。不要这样做。值对象定义的更新将影响所有客户端，并且你将客户端与你的领域逻辑耦合起来。
- en: Serializable
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可序列化
- en: A cool side effect of using basic types is that any request object can easily
    be serialized into a string, sent through the wire, and stored in a messaging
    system or database.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基本类型的一个酷炫副作用是，任何请求对象都可以轻松地序列化为字符串，通过网络发送，并存储在消息系统或数据库中。
- en: No Business Logic
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有业务逻辑
- en: Avoid putting any business logic — even validation — inside your request objects.
    Validation should take place inside your Domain — this is inside your Entities,
    Value Objects, Domain Services, etc. Validation is a way of enforcing business
    invariants and Domain constraints.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在请求对象中放置任何业务逻辑——甚至验证。验证应该在领域内部进行——这是在实体、值对象、领域服务等内部。验证是强制执行业务不变性和领域约束的一种方式。
- en: No Tests
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有测试
- en: Application requests are data structures, not objects. Unit testing data structures
    is like testing getters and setters. There's no behavior to test, so there isn't
    much value in trying to unit test request objects and DTOs. These structures will
    be covered as a side effect of more elaborate tests, such as Integration or Acceptance
    tests.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序请求是数据结构，而不是对象。单元测试数据结构就像测试getter和setter一样。没有行为可以测试，所以尝试单元测试请求对象和DTOs的价值不大。这些结构将作为更复杂测试（如集成测试或验收测试）的副作用得到覆盖。
- en: Commands are an alternative to request objects. We could design a Service with
    multiple Application methods, and each one of them with the parameters you'd put
    inside the Request. This is OK for simple applications, but we'll worry about
    this topic later.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是请求对象的替代方案。我们可以设计一个具有多个应用程序方法的Service，每个方法都有你会在请求中放入的参数。这对于简单应用程序来说是可行的，但我们会稍后再讨论这个话题。
- en: Anatomy of an Application Service
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序服务的解剖结构
- en: 'Once we have the data encapsulated in a request, it''s time for the business
    logic. As Vaughn Vernon [says](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577):
    "Keep Application Services thin, using them only to coordinate tasks on the model."'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将数据封装在请求中，就是业务逻辑的时间了。正如Vaughn Vernon[所说](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577)：“保持应用程序服务瘦，只使用它们在模型上协调任务。”
- en: 'The first thing to do is to extract the necessary information from the request,
    That is, the `email` and `password`. At a high level, we need to check if there''s
    an existing user with a particular email. If this isn''t the case, then we create
    and add the user to the `UserRepository`. In the special case of finding a user
    with the same email, we raise an exception so the client can treat it their own
    way — by displaying an error, retrying, or just ignoring it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是从请求中提取必要的信息，即`email`和`password`。从高层次来看，我们需要检查是否存在具有特定电子邮件的现有用户。如果不是这种情况，那么我们创建并添加用户到`UserRepository`。在找到具有相同电子邮件的用户这一特殊情况下，我们抛出异常，以便客户端可以按自己的方式处理——通过显示错误、重试或简单地忽略它：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Nice! If you're wondering what this `UserRepository` thing is doing in the constructor,
    we'll show you that next.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！如果你想知道这个`UserRepository`在构造函数中做什么，我们将在下一部分向你展示。
- en: '**Handling Exceptions**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**异常处理**'
- en: Exceptions raised by Application Services are a way of communicating unusual
    cases and flows to the client. Exceptions on this layer are related to business
    logic (like not finding a user), and not implementation details (like `PDOException`,
    `PredisException`, or `DoctrineException`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序服务抛出的异常是向客户端传达异常情况和流程的一种方式。这一层的异常与业务逻辑（如找不到用户）有关，而不是与实现细节（如`PDOException`、`PredisException`或`DoctrineException`）有关。
- en: Dependency Inversion
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置
- en: 'Handling users is not the responsibility of the Service. As we saw in [Chapter
    10](c688814f-5b8c-49f2-9b2c-f292299c2fde.xhtml), *Repositories*, there''s a specialized
    class that deals with `User` collections: the `User` Repository. This is a dependency
    from the Application Service to the Repository. We don''t want to couple the Application
    Service with a concrete implementation of the Repository, as then we''d be coupling
    our Service with Infrastructure details. So we depend on the contract (interface)
    that concrete implementations depend on, the `UserRepository`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 处理用户不是服务的责任。正如我们在第10章[章节10](c688814f-5b8c-49f2-9b2c-f292299c2fde.xhtml)，“存储库”中看到的，有一个专门处理`User`集合的类：`User`存储库。这是应用程序服务对存储库的依赖。我们不希望应用程序服务与存储库的具体实现耦合，因为那样的话，我们的服务将与基础设施细节耦合。因此，我们依赖于具体实现所依赖的合同（接口），即`UserRepository`。
- en: A specific implementation of the `UserRepository` will be built and passed in
    at runtime — for example, with `DoctrineUserRepository`, a specific implementation
    that uses Doctrine. Passing a specific implementation will also work when testing.
    For example, `NotAvailableUserRepository` can be a specific implementation that
    will throw exceptions each time an operation is performed. This way, we can test
    all Application Service behaviors, including *sad* paths, which is when the application
    must behave properly, even if something goes wrong.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将`UserRepository`的具体实现构建并传递到运行时——例如，使用`DoctrineUserRepository`，这是一个使用Doctrine的具体实现。传递一个具体实现也可以在测试时工作。例如，`NotAvailableUserRepository`可以是一个具体实现，每次执行操作时都会抛出异常。这样，我们可以测试所有应用程序服务的所有行为，包括*悲伤*路径，即当应用程序必须正确行为，即使某些事情出错时。
- en: Application Services could depend on Domain Services like `GetBadgesByUser`
    too. At runtime, the implementation for such a Service could be quite elaborate.
    Imagine an `HttpGetBadgesByUser` for integrating a Bounded Context through HTTP
    protocol.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序服务也可以依赖于领域服务，如`GetBadgesByUser`。在运行时，此类服务的实现可能相当复杂。想象一下一个`HttpGetBadgesByUser`，它通过HTTP协议集成一个边界上下文。
- en: Depending on abstractions, we'll make our Application Service immune to low-level
    Infrastructure changes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 根据抽象，我们将使我们的应用程序服务免受底层基础设施更改的影响。
- en: Instantiating Application Services
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化应用程序服务
- en: 'Instantiating just your Application Service is easy, but building the dependency
    tree might be tricky, depending on how complicated the dependencies are to build.
    For such a purpose, most frameworks come with a Dependency Injection Container.
    Without one, you''ll end up with something like the following code somewhere in
    your controller:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化应用程序服务本身很容易，但构建依赖树可能很棘手，这取决于构建依赖的复杂性。为此目的，大多数框架都提供了一个依赖注入容器。如果没有，你最终会在你的控制器中的某个地方得到以下代码：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We decided to use the [Redis](http://redis.io/) implementation for the `UserRepository`.
    In the previous code example, we built all dependencies needed for building a
    Repository that uses Redis internally. Those dependencies are: a [Predis](https://github.com/nrk/predis) client,
    and all parameters to connect to our Redis server. This is not only inefficient,
    but it also spreads duplication across controllers.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定使用 [Redis](http://redis.io/) 实现来为 `UserRepository`。在之前的代码示例中，我们构建了构建使用 Redis
    内部实现的仓库所需的所有依赖项。这些依赖项包括：一个 [Predis](https://github.com/nrk/predis) 客户端，以及连接到我们的
    Redis 服务器的所有参数。这不仅效率低下，而且还在控制器中传播了重复代码。
- en: You could refactor the construction logic into a Factory, or you could use a
    Dependency Injection Container — most modern frameworks come with it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将构建逻辑重构为一个工厂，或者你可以使用依赖注入容器——大多数现代框架都自带这个功能。
- en: Is It Bad to Use a Dependency Injection Container?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖注入容器是不是坏事？
- en: Not at all. Dependency Injection Containers are just a tool. They help by abstracting
    away the complexities of building your dependencies. They come in handy for building
    Infrastructure artifacts. Symfony offers a complete solution.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 完全不是。依赖注入容器只是一个工具。它们通过抽象出构建依赖项的复杂性来帮助你。它们在构建基础设施工件时非常有用。Symfony 提供了一个完整的解决方案。
- en: Take into account the fact that passing the entire container as a whole to one
    of the Services is a bad practice. That would be like coupling the entire context
    of your application with the Domain. If a Service needs specific objects, build
    them from your framework and pass them as dependencies into the Service, but don't
    make that Service aware of the entire context.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将整个容器作为一个整体传递给某个服务是一种不良做法。这就像将应用程序的整个上下文与领域耦合在一起。如果一个服务需要特定的对象，从你的框架中构建它们，并将它们作为依赖项传递给服务，但不要让该服务了解整个上下文。
- en: 'Let''s see how would we build dependencies in Silex:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 Silex 中构建依赖项：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, `$app` is used as the Service Container. We register all the
    components needed, along with their dependencies. `sign_up_user_application_service`
    depends on the definitions made above. Changing the implementation for the `user_repository`
    is as easy as returning something else (MySQL, MongoDB, and so on.), so we don't
    need to change the Service code at all.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`$app` 被用作服务容器。我们注册所有需要的组件及其依赖项。`sign_up_user_application_service` 依赖于上面定义的内容。更改
    `user_repository` 的实现就像返回其他东西（MySQL、MongoDB 等）一样简单，所以我们根本不需要更改服务代码。
- en: 'The equivalent for a Symfony application looks like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Symfony 应用程序，其等效操作如下：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that you have the definition of your Application Service in the Symfony
    Service Container, getting it later is pretty straightforward. All delivery mechanisms
    — Web Controllers, REST Controllers, and even Console Commands — share the same
    definition. The Service is available on any class implementing the `ContainerAware`
    interface. Getting the Service is as easy as calling `$this->get('sign_up_user_application_service'`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在 Symfony 服务容器中定义了你的应用程序服务，稍后获取它就非常简单了。所有交付机制——Web 控制器、REST 控制器，甚至是控制台命令——都共享相同的定义。服务在实现
    `ContainerAware` 接口的任何类上都是可用的。获取服务就像调用 `$this->get('sign_up_user_application_service')`
    一样简单。
- en: To summarize, how you build your Services (adhoc, using Service Containers,
    using Factories, and so on.) doesn't matter. However, it's important to keep your
    Application Services setup out of the Infrastructure boundary.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，你如何构建你的服务（临时、使用服务容器、使用工厂等）并不重要。然而，保持你的应用程序服务设置在基础设施边界之外是很重要的。
- en: Customize an Application Service
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制应用程序服务
- en: The main way to customize your Application Service is by choosing which dependencies
    you're passing in. Depending on your Service Container capabilities, that could
    be a bit tricky, so you can also add a setter to change the dependency on the
    fly. For example, you may need to change an output dependency so that you can
    set up a default one and then change it afterward. If logic gets too complicated,
    you can create an Application Service Factory that will handle this situation
    for you.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 定制你的应用程序服务的主要方式是选择你传递的依赖项。根据你的服务容器功能，这可能会有些棘手，因此你还可以添加一个setter来动态更改依赖项。例如，你可能需要更改输出依赖项，以便你可以设置一个默认值，然后之后再更改它。如果逻辑变得过于复杂，你可以创建一个应用程序服务工厂来为你处理这种情况。
- en: Execution
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行
- en: 'There are two different approaches for invoking Application Services: a dedicated
    class per use case with a single execution method, and multiple Application Services
    and use cases inside the same class.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 调用应用服务有两种不同的方法：每个用例一个专用类，具有单个执行方法，以及同一类中的多个应用服务和用例。
- en: One Class Per Application Service
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个应用服务一个类
- en: 'This is our preferred approach, and probably the one that fits all scenarios:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们首选的方法，可能也是适合所有场景的方法：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using a dedicated class per Application Service makes the code more robust against
    external changes (Single Responsibility Principle). There are fewer reasons to
    change the class, as the Service does one and only one thing. The Application
    Service will be easier to test, seeing as it does less things. It's easier to
    implement a common Application Service contract, making class decoration easier
    (check out Sub section *Transactions* of[Chapter 10](c688814f-5b8c-49f2-9b2c-f292299c2fde.xhtml),
    * Repositories* ). This will also result in higher cohesion, as all dependencies
    are exclusively dedicated to a single use case.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用每个应用服务一个专用类可以使代码更健壮，抵御外部变化（单一职责原则）。由于服务只做一件事情，因此更改类的理由更少。由于应用服务做的事情较少，因此它将更容易进行测试。实现一个通用的应用服务合同更容易，这使得类装饰更容易（参见第10章的子节*事务*，*存储库*）。这还将导致更高的内聚性，因为所有依赖项都专门用于单个用例。
- en: The `execution` method could have a more expressive name, like `signUp`. However,
    the execute [Command pattern](http://martinfowler.com/bliki/DecoratedCommand.html) format
    standardizes a common contract across Application Services, thereby enabling easy
    decoration, which comes in handy for transactions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`execution`方法可以有一个更具表达力的名称，比如`signUp`。然而，执行[命令模式](http://martinfowler.com/bliki/DecoratedCommand.html)格式标准化了应用服务之间的通用合同，从而使得装饰变得容易，这在事务中很有用。'
- en: Multiple Application Service Methods per Class
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个类中多个应用服务方法
- en: 'Sometimes it might be a good idea to group cohesive Application Services under
    the same class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，将连贯的应用服务分组在同一类下可能是个好主意：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We don't recommend such an approach, as not all Application Services are 100
    percent cohesive. Some Services will require different dependencies, and you'll
    end up with Application Services depending on things they don't need. Another
    issue is that this kind of class grows fast. As it violates the Single Responsibility
    Principle, there will be multiple reasons to change and maybe even break it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不推荐这种方法，因为并非所有应用服务都是100%连贯的。一些服务将需要不同的依赖项，你最终会得到依赖它们不需要的东西的应用服务。另一个问题是这种类型的类会迅速增长。因为它违反了单一职责原则，所以会有多个理由去更改它，甚至可能破坏它。
- en: Returning Values
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回值
- en: 'After signing up, we might be thinking about redirecting the user to a profile
    page. The natural way of passing the required information back to the controller
    is to return the User Entity directly from the Service:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册后，我们可能会考虑将用户重定向到个人资料页面。将所需信息直接返回给控制器的自然方式是从服务中返回用户实体：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then, from the controller, we would pick up the `id` field and redirect to some
    other place. However, think twice about what we've just done. We returned a full-featured
    Entity to the controller, which will allow the delivery mechanism to bypass the
    Application Layer and interact directly with the Domain.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从控制器中，我们会获取`id`字段并重定向到其他地方。然而，仔细考虑我们刚才所做的事情。我们返回了一个功能齐全的实体给控制器，这将允许交付机制绕过应用层并直接与领域交互。
- en: 'Imagine the `User` Entity offers an `updateEmailAddress` method. You could
    try to prevent it, but at some point in the future, somebody might think about
    using it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`User`实体提供了一个`updateEmailAddress`方法。你可以尝试阻止它，但在未来的某个时刻，有人可能会考虑使用它：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Not only that, but the data that the presentation layer needs is not the same
    that the Domain manages. We don't want to evolve and couple the Domain layer around
    the presentation layer. Instead, we want them to evolve freely.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，表示层所需的数据与领域管理的数据并不相同。我们不希望领域层围绕表示层进行演变和耦合。相反，我们希望它们自由地演变。
- en: To do this, we need a flexible way of decoupling both layers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要一种灵活的方式来解耦这两层。
- en: DTO from Aggregate Instances
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从聚合实例中获取 DTO
- en: 'We could return sterile data structures with the information the presentation
    layer needs. As we''ve seen before, DTOs fit with this scenario. We just need
    to compose them in the Application Service and return them to the client:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以返回带有表示层所需信息的无状态数据结构。正如我们之前所看到的，DTOs（数据传输对象）适合这种场景。我们只需要在应用服务中组合它们，然后返回给客户端：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `UserDTO` will expose whatever read-only data we need from the `User` Entity
    on the presentation layer, thereby avoiding exposing behavior:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserDTO`将暴露我们在表示层从`User`实体中需要的所有只读数据，从而避免暴露行为：'
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Mission accomplished. Now we could pass parameters to the template engine and
    transform them into widgets, tags, or subtemplates, or do whatever we want with
    the data on the presentation side:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成。现在我们可以向模板引擎传递参数，并将它们转换为小部件、标签或子模板，或者对表示层上的数据进行任何我们想要的操作：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: However, letting the Application Service decide how to build the DTO reveals
    another limitation. As building the DTO depends exclusively on the Application
    Service, adapting the DTO to different clients will be very difficult. Consider
    the data needed for a redirect on a Web Controller and the data needed for a REST
    response for the same use case. Not the same data at all.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让应用服务决定如何构建DTO揭示了另一个限制。因为构建DTO完全取决于应用服务，所以适应不同客户端的DTO将非常困难。考虑Web控制器上的重定向所需的数据和同一用例的REST响应所需的数据。这根本不是相同的数据。
- en: 'Let''s allow the client to define how to build the DTO by passing a specific
    DTO Assembler:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让客户端通过传递特定的DTO组装器来定义如何构建DTO：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now the client can customize the response by passing a specific `UserDTOAssembler`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在客户端可以通过传递特定的`UserDTOAssembler`来自定义响应。
- en: Data Transformers
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据转换器
- en: There are some cases where generating intermediate DTOs for more complex responses
    like JSON, XML, CSV, and iCAL Contact could be seen as an unnecessary overhead.
    We could output the representation in a buffer and ask for it later on the delivery
    side.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，为更复杂的响应（如JSON、XML、CSV和iCAL联系人）生成中间DTO可能被视为不必要的开销。我们可以在缓冲区中输出表示，并在交付时再请求它。
- en: 'Transformers help reduce this overhead by transforming high-level Domain concepts
    into low-level client details. Let''s see an example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 转换器通过将高级领域概念转换为低级客户端细节来帮助减少这种开销。让我们看看一个例子：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Consider the case of generating different data representations for a given product.
    Usually, the product information is served through a web interface (HTML), but
    we might be interested in offering other formats, like XML, JSON, or CSV. This
    might enable integrations with other Services.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑为给定产品生成不同数据表示的情况。通常，产品信息通过Web界面（HTML）提供，但我们可能对提供其他格式（如XML、JSON或CSV）感兴趣。这可能使与其他服务的集成成为可能。
- en: Consider a similar case for a blog. We might expose our potential as writers
    in HTML to the world, but some people will be interested in consuming our articles
    through RSS. The use cases — Application Services — remain the same. The representation
    doesn't.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个类似的博客案例。我们可能将我们的写作潜力通过HTML展示给世界，但有些人可能对通过RSS消费我们的文章感兴趣。用例——应用服务——保持不变。表示则不同。
- en: DTOs are a clean and simple solution that could be passed to template engines
    for different representations, but this might complicate the logic of this last
    step of data transformation, as the logic for such templates could become a problem
    to maintain, test, and understand.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: DTOs（数据传输对象）是一个干净且简单的解决方案，可以传递给模板引擎以实现不同的表示，但这可能会使数据转换的最后一步的逻辑变得复杂，因为这样的模板的逻辑可能成为维护、测试和理解的问题。
- en: 'Data Transformers might be a better approach on specific cases. These are just
    black boxes with Domain concepts (Aggregates, Entities, and so on.) as inputs
    and read-only representations (XML, JSON, CSV, and so on.) as outputs. These transformers
    could be really easy to test:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定情况下，数据转换器可能是一个更好的方法。这些只是以领域概念（聚合、实体等）作为输入，以只读表示（XML、JSON、CSV等）作为输出的黑盒。这些转换器可能非常容易测试：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That was easy. Wondering how the XML or CSV one would look? Let''s see how
    to integrate the Data Transformer with our Application Service:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。想知道XML或CSV的样子吗？让我们看看如何将数据转换器集成到我们的应用服务中：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That's similar to the DTO Assembler approach, but this time without returning
    a concrete value. The Data Transformer is being used to hold and interact with
    the data.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这与DTO组装器方法类似，但这次没有返回具体值。数据转换器被用来持有和交互数据。
- en: The main issue with DTOs is the overhead of writing them. Most of the time,
    your Domain concepts and DTO representations will present the same structure.
    Most of the time, you'll feel it's not worth your time to make such a mapping.
    That said, the relationship between representations and Aggregates is not 1:1\.
    You can represent two Aggregates together in a single representation. You can
    also represent the same Aggregate in multiple ways. How you do it always depends
    on your use cases.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: DTO 的问题主要在于编写它们的开销。大多数时候，你的领域概念和 DTO 表示将呈现相同的结构。大多数时候，你可能会觉得花时间进行这种映射不值得。话虽如此，表示和聚合之间的关系不是
    1:1。你可以在单个表示中一起表示两个聚合。你也可以用多种方式表示相同的聚合。你如何做总是取决于你的用例。
- en: 'However, according to [Martin Fowler](http://www.martinfowler.com/books/eaa.html):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，根据 [马丁·福勒](http://www.martinfowler.com/books/eaa.html)：
- en: One case where it is useful to use something like a DTO is **when you have a
    significant mismatch between the model in your presentation layer and the underlying
    domain model**. In this case it makes sense to make presentation specific facade/gateway
    that maps from the domain model and presents an interface that's convenient for
    the presentation. It fits in nicely with Presentation Model. This is worth doing,
    but it is only worth doing for screens that have this mismatch (in this case it
    isn't extra work, since you'd have to do it in the screen anyway.)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种情况下使用类似 DTO 的东西是有用的，那就是**当你的表示层模型与底层领域模型之间存在显著不匹配时**。在这种情况下，创建一个针对表示层的特定外观/网关，它将领域模型映射到方便表示的接口是有意义的。它与表示模型很好地结合在一起。这样做是值得的，但只有在存在这种不匹配的屏幕上才值得（在这种情况下，这不是额外的工作，因为你本来也必须在屏幕上这样做。）
- en: We think the long-term vision will be worth the investment. On medium to big
    projects, interface representations and Domain concepts change at very different
    rhythms. You might want to decouple them from each other to lower the friction
    for updates. Using DTOs or Data Transformers allows you to evolve your model freely
    without having to think about breaking the layout all the time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为长期愿景将值得投资。在中到大型的项目中，界面表示和领域概念的变化节奏非常不同。你可能希望将它们彼此解耦，以降低更新的摩擦。使用 DTO 或数据转换器允许你自由地发展你的模型，而无需总是考虑破坏布局。
- en: Multiple Application Services on Compound Layouts
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合布局上的多个应用程序服务
- en: Most of the time, no layout is as simple as a single Application Service. Our
    projects have pretty complicated interfaces.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，没有布局像单个应用程序服务那样简单。我们的项目有相当复杂的界面。
- en: Consider the homepage of a specific project. How can we render so many pieces
    and use cases? There are a few options, so let's check them out.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个特定项目的首页。我们如何渲染这么多部分和用例？有几个选项，让我们来看看。
- en: AJAX Content Integration
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AJAX 内容集成
- en: You could let the browser ask for different endpoints directly and combine the
    data in the layout right after through AJAX or [Hijax](https://en.wikipedia.org/wiki/Hijax).
    This will avoid mixing a lot of Application Services in your controllers, but
    it might have a performance penalty, depending on the number of requests triggered.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以让浏览器直接请求不同的端点，并通过 AJAX 或 [Hijax](https://en.wikipedia.org/wiki/Hijax) 在布局中立即组合数据。这将避免在你的控制器中混合大量的应用程序服务，但可能会因为触发的请求数量而带来性能损失。
- en: ESI Content Integration
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ESI 内容集成
- en: '**Edge Side Includes** (**ESI**) is a tiny markup language similar to the previous
    approach, but on the server side. It requires additional effort configuring extra
    middleware, like NGINX or Varnish, to make it work. Includes (ESI) is a tiny markup
    language similar to the previous approach, but on the server side. It requires
    additional effort configuring extra middleware, like NGINX or [Varnish](https://en.wikipedia.org/wiki/Edge_Side_Includes),
    to make it work.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**边缘侧包含**（**ESI**）是一种类似于之前方法的微小标记语言，但它在服务器端。它需要额外的努力来配置额外的中间件，如 NGINX 或 Varnish，以使其工作。包含（ESI）是一种类似于之前方法的微小标记语言，但它在服务器端。它需要额外的努力来配置额外的中间件，如
    NGINX 或 [Varnish](https://en.wikipedia.org/wiki/Edge_Side_Includes)，以使其工作。'
- en: Symfony Sub Requests
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Symfony 子请求
- en: 'If you use Symfony, Sub Requests could be an interesting option. According
    to the [Symfony Documentation](http://symfony.com/doc/current/components/http_kernel/introduction.html#sub-requests):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Symfony，子请求可能是一个有趣的选择。根据 [Symfony 文档](http://symfony.com/doc/current/components/http_kernel/introduction.html#sub-requests)：
- en: In addition to the main request that's sent into `HttpKernel::handle`, you can
    also send so-called sub request. A sub request looks and acts like any other request,
    but typically serves to render just one small portion of a page instead of a full
    page. You'll most commonly make sub-requests from your controller (or perhaps
    from inside a template, that's being rendered by your controller). This creates
    another full request-response cycle where this new Request is transformed into
    a Response. The only difference internally is that some listeners (Example: security)
    may only act upon the master request. Each listener is passed some sub-class of
    `KernelEvent`, whose `isMasterRequest()` can be used to check if the current request
    is a master or sub request.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 除了发送到`HttpKernel::handle`的主要请求之外，你还可以发送所谓的子请求。子请求看起来和表现得像任何其他请求一样，但通常只用于渲染页面的一小部分而不是整个页面。你通常会在控制器（或可能是在控制器渲染的模板内部）中创建子请求。这创建了一个新的完整请求-响应周期，其中这个新的请求被转换为一个响应。唯一的内部区别是，一些监听器（例如：安全）可能只对主请求起作用。每个监听器都会传递一些`KernelEvent`的子类，其中`isMasterRequest()`可以用来检查当前请求是主请求还是子请求。
- en: This is great, as you'll get the benefits of invoking separate Application Services
    without AJAX penalties or complicated ESI configurations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，因为你可以获得调用单独应用程序服务的优势，而不受AJAX惩罚或复杂的ESI配置。
- en: One Controller, Multiple Application Services
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个控制器，多个应用程序服务
- en: One last option could be managing multiple Application Services within the same
    controller, though the controller logic could get a little bit dirty, as it'll
    handle and merge the responses to pass to the view.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项可能是管理同一控制器内的多个应用程序服务，尽管控制器逻辑可能会变得有些复杂，因为它将处理和合并响应以传递给视图。
- en: Testing Application Services
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试应用程序服务
- en: 'As you''re interested in testing the behavior of the Application Service itself,
    there''s no need to turn it into an integration test with complicated setups going
    against a real database. You''re not interested in testing the low-level details,
    so most of the time, a unit test will be enough:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你对测试应用程序服务本身的行为感兴趣，没有必要将其转换为与真实数据库进行复杂设置的集成测试。你不对测试低级细节感兴趣，所以大多数情况下，单元测试就足够了：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We''ve used an in-memory implementation for the `User` Repository. This is
    what is called a Fake: a fully functional implementation for the Repository that
    will make our test work as a unit. We don''t need to go to the database to test
    the behavior of this class. That would make our test slow and fragile.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为`User`存储库使用了一个内存实现。这被称为模拟：一个完全功能化的存储库实现，将使我们的单元测试工作正常。我们不需要访问数据库来测试这个类的行为。这会使我们的测试变慢且脆弱。
- en: 'Checking for a Domain Events submission might be interesting too. If creating
    a user fires a user registered event, ensuring it''s been triggered might be a
    good idea:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 检查域事件提交可能也有趣。如果创建用户触发了用户注册事件，确保它已被触发可能是个好主意：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Transactions
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务
- en: Transactions are an implementation detail related to the persistence mechanism.
    The Domain layer shouldn't be aware of this low-level implementation detail. Thinking
    about beginning, committing, or rolling back a transaction at this level is a
    big smell. This level of detail belongs to the Infrastructure layer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 事务是与持久化机制相关的实现细节。领域层不应该意识到这个低级实现细节。在这个级别考虑开始、提交或回滚事务是一个很大的问题。这个级别的细节属于基础设施层。
- en: The best way of handling transactions is to not handle them at all. We could
    wrap our Application Services with a Decorator implementation for handling the
    transaction session automatically.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 处理事务的最佳方式是根本不处理它们。我们可以用处理事务会话的装饰器实现来包装我们的应用程序服务。
- en: 'We''ve implemented a solution to this problem in one of our repositories, and
    you can check it out [here](https://github.com/dddinphp/ddd):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的存储库中实现了一个解决方案来解决这个问题，你可以在这里查看[它](https://github.com/dddinphp/ddd)：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This contract takes a piece of code and executes it atomically. Depending on
    your persistence mechanism, you'll end up with different implementations.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此合约接受一段代码并原子性地执行它。根据你的持久化机制，你将得到不同的实现。
- en: 'Let''s see how we could do it with Doctrine ORM:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用Doctrine ORM来实现它：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is how a client would use the previous code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是客户端如何使用之前代码的方式：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that we have the Doctrine implementation for transactional sessions, it
    would be great to create a Decorator for our Application Services. With this approach,
    we make transactional requests transparent to the Domain:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了事务性会话的Doctrine实现，创建一个用于我们的应用服务的装饰器将非常棒。采用这种方法，我们使事务性请求对领域透明：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A nice side effect of using Doctrine Session is that it automatically manages
    the flush method, so you don't need to add the flush inside your Domain or Infrastructure.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Doctrine会话的一个很好的副作用是它自动管理flush方法，因此你不需要在领域或基础设施中添加flush。
- en: Security
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: In case you're wondering how to manage and handle user credentials and security
    in general, unless it's the responsibility of your Domain, we recommend letting
    the framework handle it. The user session is a concern of the delivery mechanism.
    Polluting the Domain with such concepts will make it harder to develop.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道如何管理和处理用户凭证和一般安全，除非这是你的领域的责任，我们建议让框架来处理。用户会话是交付机制的关心点。将此类概念引入领域将使开发变得更加困难。
- en: Domain Events
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域事件
- en: 'Domain Event listeners have to be configured before the Application Service
    gets executed, or nobody will be noticed. There are situations where you''ll have
    to be explicit and configure the listener before executing the Application Service:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用服务执行之前必须配置领域事件监听器，否则没有人会注意到。在某些情况下，你必须在执行应用服务之前明确配置监听器：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Most of the time, this will be done by configuring the Dependency Injection
    Container.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这将通过配置依赖注入容器来完成。
- en: Command Handlers
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令处理器
- en: 'An interesting way of executing Application Services is through a Command Bus
    library. A good one is [Tactician](https://tactician.thephpleague.com/). From
    the Tactician website:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过命令总线库执行应用服务是一种有趣的方式。一个好的选择是[Tactician](https://tactician.thephpleague.com/)。从Tactician网站：
- en: What is a Command Bus? The term is mostly used when we combine the [Command
    pattern](https://en.wikipedia.org/wiki/Command_pattern) with a [service layer](http://martinfowler.com/eaaCatalog/serviceLayer.html).
    Its job is to take a Command object (which describes what the user wants to do)
    and match it to a Handler (which executes it). This can help structure your code
    neatly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 命令总线是什么？这个术语通常在我们将[命令模式](https://en.wikipedia.org/wiki/Command_pattern)与[服务层](http://martinfowler.com/eaaCatalog/serviceLayer.html)结合使用时使用。它的任务是取一个命令对象（描述用户想要做什么）并将其与处理器（执行它）匹配。这可以帮助你整洁地组织代码。
- en: — our Application Services are the Service Layer, and our Request objects look
    pretty much like Commands.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: — 我们的应用服务是服务层，我们的请求对象看起来几乎像是命令。
- en: Fair enough — our Application Services are the Service Layer, and our Request
    objects look pretty much like Commands. Wouldn't it be great if we had a mechanism
    to link all the Application Services, and then based on the Request, execute the
    correct one? Well, that's actually what a Command Bus is.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 没问题——我们的应用服务是服务层，我们的请求对象看起来几乎像是命令。如果我们有一个机制来链接所有应用服务，并根据请求执行正确的服务，那岂不是很好？实际上，这就是命令总线的作用。
- en: Tactician Library and Other Options
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 战术家库和其他选项
- en: Tactician is a Command Bus library, which allows you to use the Command pattern
    for your Application Services. It's especially convenient for Application Services,
    but you could use any kind of input.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Tactician是一个命令总线库，它允许你为你的应用服务使用命令模式。它特别方便用于应用服务，但你也可以使用任何类型的输入。
- en: 'Let''s see an example from the [Tactician](http://tactician.thephpleague.com/)website:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看[Tactician](http://tactician.thephpleague.com/)网站上的一个例子：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That's it. Tactician is the `$commandBus` Service. It does all the plumbing
    for finding the right handler and method, which can avoid a lot of boilerplate
    code. Here, Commands and Handlers are just normal classes, but you can configure
    whichever one fits your app better.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。Tactician是`$commandBus`服务。它负责找到正确的处理器和方法的所有管道工作，这可以避免大量的样板代码。在这里，命令和处理器只是普通类，但你可以根据你的应用更好地配置它们。
- en: In summary, we can conclude that Commands are just Request objects, and Command
    Handlers are just Application Services.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们可以得出结论，命令只是请求对象，命令处理器只是应用服务。
- en: A cool thing about Tactician (and Command Buses in general) is that they're
    really easy to extend. Tactician provides plug-ins for common tasks, like logging
    and database transactions. That way, you can forget about setting up the wiring
    on every handler.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Tactician（以及命令总线一般）的一个酷特点是它们非常容易扩展。Tactician 为常见任务提供了插件，如日志记录和数据库事务。这样，你就可以忘记在每个处理器上设置连接了。
- en: Another interesting plug-in for [Tactician is Bernard](http://bernard.readthedocs.org/) integration.
    Bernard is an asynchronous job queue that allows you to leave some tasks for later
    processing. Heavy processes block the response. Most of the time, we can branch
    and delay their execution for later. For the best experience, answer the customer
    as fast as possible and let them know once the branched processes are done.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[Tactician](http://bernard.readthedocs.org/) 的另一个有趣的插件是 Bernard 集成。Bernard
    是一个异步作业队列，允许你将一些任务留待稍后处理。重处理过程会阻塞响应。大多数时候，我们可以分支并延迟它们的执行。为了获得最佳体验，尽快回答客户的问题，并在分支过程完成后通知他们。'
- en: Matthias Noback has developed another similar project, called [SimpleBus](http://simplebus.github.io/MessageBus/),
    that can be used as an alternative to Tactician. The main difference is that `SimpleBus`
    Command Handlers don't have a return value.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Matthias Noback 开发了一个类似的项目，名为 [SimpleBus](http://simplebus.github.io/MessageBus/)，它可以作为
    Tactician 的替代品。主要区别在于 `SimpleBus` 命令处理器没有返回值。
- en: Wrap-Up
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Application Services represent the Application layer of your Bounded Context.
    These high-level use cases should be relatively simple and skinny, as their purpose
    evolves around Domain coordination. Application Services are the entry point for
    Domain logic interaction. We've seen that Requests and Commands keep things organized;
    that DTOs and Data Transformers allow us to decouple data representation from
    Domain conceptualization; that building Application Services is pretty straightforward
    with Dependency Injection Containers; and that we have plenty of options for combining
    Application Services in complex layouts.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务代表了你的边界上下文中的应用层。这些高级用例应该是相对简单和精简的，因为它们的目的主要围绕领域协调。应用服务是领域逻辑交互的入口点。我们注意到请求和命令有助于保持事物的组织性；DTOs（数据传输对象）和数据转换器使我们能够将数据表示与领域概念解耦；使用依赖注入容器构建应用服务相当直接；并且我们在复杂布局中组合应用服务有许多选择。
