- en: Chapter 4. Models and Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like most modern frameworks and platforms, these days Magento embraces an **Object
    Relational Mapping** (**ORM**) approach over raw SQL queries. Though the underlying
    mechanism still comes down to SQL, we are now dealing strictly with objects. This
    makes our application code more readable, manageable, and isolated from vendor-specific
    SQL differences. Model, resource, and collection are three types of classes working
    together to allow us full entity data management, from loading, saving, deleting,
    and listing entities. The majority of our data access and management will be done
    via PHP classes called Magento models. Models themselves don't contain any code
    for communicating with the database.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The database communication part is decoupled into its own PHP class called resource
    class. Each model is then assigned a resource class. Calling `load`, `save`, or
    `delete` methods on models get delegated to resource classes, as they are the
    ones to actually read, write, and delete data from the database. Theoretically,
    with enough knowledge, it is possible to write new resource classes for various
    database vendors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Next to the model and resource classes, we have collection classes. We can think
    of a collection as an array of individual model instances. On a base level, collections
    extend from the `\Magento\Framework\Data\Collection` class, which implements `\IteratorAggregate`
    and `\Countable` from **Standard PHP Library** (**SPL**) and a few other Magento-specific
    classes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: More often than not, we look at model and resource as a single unified thing,
    thus simply calling it a model. Magento deals with two types of models, which
    we might categorize as simple and EAV models.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Creating a miniature module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The EAV model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the flow of schema and data scripts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an install schema script (`InstallSchema.php`)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an upgrade schema script (`UpgradeSchema.php`)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an install data script (`InstallData.php`)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an upgrade data script (`UpgradeData.php`)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entity CRUD actions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing collections
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a miniature module
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the purpose of this chapter, we will create a miniature module called `Foggyline_Office`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'The module will have two entities defined as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '`Department`: a simple model with the following fields:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entity_id`: primary key'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: name of department, string value'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Employee`: an EAV model with the following fields and attributes:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fields:**'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entity_id`: primary key'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`department_id`: foreign key, pointing to `Department.entity_id`'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: unique e-mail of an employee, string value'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first_name`: first name of an employee, string value'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last_name`: last name of an employee, string value'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attributes:**'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`service_years`: employee''s years of service, integer value'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dob`: employee''s date of birth, date-time value'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`salary` – monthly salary, decimal value'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vat_number`: VAT number, (short) string value'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`note`: possible note on employee, (long) string value'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`note`：关于员工的可能注释，（长）字符串值'
- en: 'Every module starts with the `registration.php` and `module.xml` files. For
    the purpose of our chapter module, let''s create the `app/code/Foggyline/Office/registration.php`
    file with content as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都以 `registration.php` 和 `module.xml` 文件开始。为了我们本章模块的目的，让我们创建一个包含以下内容的 `app/code/Foggyline/Office/registration.php`
    文件：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `registration.php` file is sort of an entry point to our module.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`registration.php` 文件可以看作是我们模块的入口点。'
- en: 'Now let''s create the `app/code/Foggyline/Office/etc/module.xml` file with
    the following content:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个包含以下内容的 `app/code/Foggyline/Office/etc/module.xml` 文件：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will get into more details about the structure of the `module.xml` file in
    later chapters. Right now, we will only focus on the `setup_version` attribute
    and `module` element within `sequence`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中更详细地介绍 `module.xml` 文件的结构。现在，我们只关注 `sequence` 中的 `setup_version` 属性和
    `module` 元素。
- en: The value of `setup_version` is important because we might use it within our
    schema install script (`InstallSchema.php`) files, effectively turning the install
    script into an update script, as we will show soon.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup_version` 的值很重要，因为我们可能会在我们的模式安装脚本（`InstallSchema.php`）文件中使用它，有效地将安装脚本转换为更新脚本，正如我们很快将展示的那样。'
- en: The `sequence` element is Magento's way of setting dependencies for our module.
    Given that our module will make use of EAV entities, we list `Magento_Eav` as
    a dependency.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`sequence` 元素是 Magento 为我们的模块设置依赖关系的方式。鉴于我们的模块将使用 EAV 实体，我们列出 `Magento_Eav`
    作为依赖项。'
- en: Creating a simple model
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的模型
- en: The `Department` entity, as per requirements, is modeled as a simple model.
    We previously mentioned that whenever we talk about models, we implicitly think
    of `model` class, `resource` class, and `collection` class forming one unit.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 根据要求，`Department` 实体被建模为一个简单的模型。我们之前提到，每当谈到模型时，我们隐含地想到 `model` 类、`resource`
    类和 `collection` 类形成一个单元。
- en: 'Let''s start by first creating a `model` class, (partially) defined under the
    `app/code/Foggyline/Office/Model/Department.php` file as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从创建一个 `model` 类开始，部分定义在 `app/code/Foggyline/Office/Model/Department.php`
    文件中，如下所示：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All that is happening here is that we are extending from the `\Magento\Framework\Model\AbstractModel`
    class, and triggering the `$this->_init` method within `_construct` passing it
    our `resource` class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的一切就是，我们正在扩展 `\Magento\Framework\Model\AbstractModel` 类，并在 `_construct`
    方法中触发 `$this->_init` 方法，传递我们的 `resource` 类。
- en: 'The `AbstractModel` further extends `\Magento\Framework\Object`. The fact that
    our `model` class ultimately extends from `Object` means that we do not have to
    define a property name on our `model` class. What `Object` does for us is that
    it enables us to get, set, unset, and check for a value existence on properties
    magically. To give a more robust example than `name`, imagine our entity has a
    property called `employee_average_salary` in the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractModel` 进一步扩展了 `\Magento\Framework\Object`。我们的 `model` 类最终从 `Object`
    继承的事实意味着我们不需要在 `model` 类上定义属性名称。`Object` 为我们做的事情是，它使我们能够神奇地获取、设置、取消设置和检查属性上的值存在。为了给出一个比
    `name` 更健壮的例子，想象我们的实体在以下代码中有一个名为 `employee_average_salary` 的属性：'
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The reason why this works is due to `Object` implementing the `setData`, `unsetData`,
    `getData`, and magic `__call` methods. The beauty of the magic `__call` method
    implementation is that it understands method calls like `getEmployeeAverageSalary`,
    `setEmployeeAverageSalary`, `unsEmployeeAverageSalary`, and `hasEmployeeAverageSalary`
    even if they do not exist on the `Model` class. However, if we choose to implement
    some of these methods within our `Model` class, we are free to do so and Magento
    will pick it up when we call it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为 `Object` 实现了 `setData`、`unsetData`、`getData` 和魔法 `__call` 方法。魔法 `__call`
    方法实现的美丽之处在于，它理解 `getEmployeeAverageSalary`、`setEmployeeAverageSalary`、`unsEmployeeAverageSalary`
    和 `hasEmployeeAverageSalary` 这样的方法调用，即使它们不存在于 `Model` 类上。然而，如果我们选择在我们的 `Model`
    类中实现一些这些方法，我们可以自由地这样做，并且当调用它们时，Magento 会捕获它们。
- en: This is an important aspect of Magento, sometimes confusing to newcomers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Magento 的一个重要方面，有时对新来者来说可能有些令人困惑。
- en: 'Once we have a `model` class in place, we create a model `resource` class,
    (partially) defined under the `app/code/Foggyline/Office/Model/ResourceModel/Department.php`
    file as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个 `model` 类，我们创建一个模型 `resource` 类，部分定义在 `app/code/Foggyline/Office/Model/ResourceModel/Department.php`
    文件中，如下所示：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our resource class that extends from `\Magento\Framework\Model\ResourceModel\Db\AbstractDb`
    triggers the `$this->_init` method call within `_construct`. `$this->_init` accepts
    two parameters. The first parameter is the table name `foggyline_office_department`,
    where our model will persist its data. The second parameter is the primary column
    name `entity_id` within that table.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继承自`\Magento\Framework\Model\ResourceModel\Db\AbstractDb`的`resource`类在`_construct`方法中触发`$this->_init`方法的调用。`$this->_init`接受两个参数。第一个参数是表名`foggyline_office_department`，我们的模型将在此表中持久化其数据。第二个参数是表中的主键列名`entity_id`。
- en: '`AbstractDb` further extends `Magento\Framework\Model\ResourceModel\AbstractResource`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractDb`进一步扩展了`Magento\Framework\Model\ResourceModel\AbstractResource`。'
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resource class is the key to communicating to the database. All it takes
    is for us to name the table and its primary key and our models can save, delete,
    and update entities.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 资源类是向数据库通信的关键。我们只需要命名表及其主键，我们的模型就可以保存、删除和更新实体。
- en: 'Finally, we create our `collection` class, (partially) defined under the `app/code/Foggyline/Office/Model/ResourceModel/Department/Collection.php`
    file as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建我们的`collection`类，部分定义在`app/code/Foggyline/Office/Model/ResourceModel/Department/Collection.php`文件中，如下所示：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `collection` class extends from `\Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection`
    and, similar to the `model` and `resource` classes, does a `$this->_init` method
    call within `_construct`. This time, `_init` accepts two parameters. The first
    parameter is the full `model` class name `Foggyline\Office\Model\Department`,
    and the second parameter is the full resource class name `Foggyline\Office\Model\ResourceModel\Department`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`collection`类继承自`\Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection`，并且类似于`model`和`resource`类，在`_construct`方法中调用`$this->_init`方法。这次，`_init`接受两个参数。第一个参数是完整的`model`类名`Foggyline\Office\Model\Department`，第二个参数是完整的资源类名`Foggyline\Office\Model\ResourceModel\Department`。'
- en: '`AbstractCollection` implements `Magento\Framework\App\ResourceConnection\SourceProviderInterface`,
    and extends `\Magento\Framework\Data\Collection\AbstractDb`. `AbstractDb` further
    extends `\Magento\Framework\Data\Collection`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractCollection`实现了`Magento\Framework\App\ResourceConnection\SourceProviderInterface`，并扩展了`\Magento\Framework\Data\Collection\AbstractDb`。`AbstractDb`进一步扩展了`\Magento\Framework\Data\Collection`。'
- en: It is worth taking some time to study the inners of these `collection` classes,
    as this is our go-to place for whenever we need to deal with fetching a list of
    entities that match certain search criteria.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 值得花些时间研究这些`collection`类的内部结构，因为这是我们处理获取符合某些搜索标准实体列表时的首选地方。
- en: Creating an EAV model
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个EAV模型
- en: The `Employee` entity, as per requirements, is modeled as an EAV model.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据要求，`Employee`实体被建模为一个EAV模型。
- en: 'Let''s start by first creating an EAV `model` class, (partially) defined under
    the `app/code/Foggyline/Office/Model/Employee.php` file as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从创建一个EAV `model`类开始，部分定义在`app/code/Foggyline/Office/Model/Employee.php`文件中，如下所示：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we are extending from the `\Magento\Framework\Model\AbstractModel` class,
    which is the same as with the simple model previously described. The only difference
    here is that we have an `ENTITY` constant defined, but this is merely syntactical
    sugar for later on; it bears no meaning for the actual `model` class.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们继承自`\Magento\Framework\Model\AbstractModel`类，这与之前描述的简单模型相同。这里唯一的区别是我们定义了一个`ENTITY`常量，但这只是为了后面的语法糖；它对实际的`model`类没有实际意义。
- en: 'Next, we create an EAV model `resource` class, (partially) defined under the
    `app/code/Foggyline/Office/Model/ResourceModel/Employee.php` file as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个EAV模型`resource`类，部分定义在`app/code/Foggyline/Office/Model/ResourceModel/Employee.php`文件中，如下所示：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our `resource` class extends from `\Magento\Eav\Model\Entity\AbstractEntity`,
    and sets the `$this->_read`, `$this->_write` class properties through `_construct`.
    These are freely assigned to whatever value we want, preferably following the
    naming pattern of our module. The read and write connections need to be named
    or else Magento produces an error when using our entities.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`resource`类继承自`\Magento\Eav\Model\Entity\AbstractEntity`，并通过`_construct`方法设置`$this->_read`和`$this->_write`类属性。这些可以自由分配为我们想要的任何值，最好遵循我们模块的命名模式。读取和写入连接需要命名，否则当使用我们的实体时，Magento会产生错误。
- en: The `getEntityType` method internally sets the `_type` value to `\Foggyline\Office\Model\Employee::ENTITY`,
    which is the string `foggyline_office_employee`. This same value is what's stored
    in the `entity_type_code` column within the `eav_entity_type` table. At this point,
    there is no such entry in the `eav_entity_type` table. This is because the install
    schema script will be creating one, as we will be demonstrating soon.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`getEntityType` 方法内部将 `_type` 值设置为 `\Foggyline\Office\Model\Employee::ENTITY`，即字符串
    `foggyline_office_employee`。这个相同的值存储在 `eav_entity_type` 表的 `entity_type_code`
    列中。此时，`eav_entity_type` 表中没有这样的条目。这是因为安装模式脚本将会创建一个，正如我们很快将要演示的那样。'
- en: 'Finally, we create our `collection` class, (partially) defined under the `app/code/Foggyline/Office/Model/ResourceModel/Employee/Collection.php`
    file as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建我们的 `collection` 类，部分定义在 `app/code/Foggyline/Office/Model/ResourceModel/Employee/Collection.php`
    文件中，如下所示：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `collection` class extends from `\Magento\Eav\Model\Entity\Collection\AbstractCollection`
    and, similar to the model class, does a `$this->_init` method call within `_construct`.
    `_init` accepts two parameters: the full model class name `Foggyline\Office\Model\Employee`,
    and the full resource class name `Foggyline\Office\Model\ResourceModel\Employee`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`collection` 类继承自 `\Magento\Eav\Model\Entity\Collection\AbstractCollection`，并且与模型类类似，在
    `_construct` 中调用 `$this->_init` 方法。`_init` 接受两个参数：完整的模型类名 `Foggyline\Office\Model\Employee`
    和完整的资源类名 `Foggyline\Office\Model\ResourceModel\Employee`。'
- en: '`AbstractCollection` has the same parent tree as the simple model collection
    class, but on its own it implements a lot of EAV collection-specific methods like
    `addAttributeToFilter`, `addAttributeToSelect`, `addAttributeToSort`, and so on.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractCollection` 与简单模型集合类具有相同的父树，但自身实现了很多 EAV 集合特定的方法，如 `addAttributeToFilter`、`addAttributeToSelect`、`addAttributeToSort`
    等。'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As we can see, EAV models look a lot like simple models. The difference lies
    mostly in the `resource` class and `collection` class implementations and their
    first level parent classes. However, we need to keep in mind that the example
    given here is the simplest one possible. If we look at the `eav_entity_type` table
    in the database, we can see that other entity types make use of `attribute_model`,
    `entity_attribute_collection`, `increment_model`, and so on. These are all advanced
    properties we can define alongside our EAV model making it closer to the implementation
    of the `catalog_product` entity type, which is probably the most robust one in
    Magento. This type of advanced EAV usage is out of the scope of this book as it
    is probably worth a book on its own.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，EAV 模型看起来与简单模型非常相似。区别主要在于 `resource` 类和 `collection` 类的实现及其一级父类。然而，我们需要记住，这里给出的例子是最简单的一种。如果我们查看数据库中的
    `eav_entity_type` 表，我们可以看到其他实体类型使用了 `attribute_model`、`entity_attribute_collection`、`increment_model`
    等。这些都是我们可以定义在 EAV 模型旁边的先进属性，使其更接近 `catalog_product` 实体类型的实现，这可能是 Magento 中最健壮的一种。这种高级
    EAV 使用超出了本书的范围，因为它可能值得一本自己的书。
- en: Now that we have simple and EAV models in place, it is time to look into installing
    the necessary database schema and possibly pre-fill it with some data. This is
    done through schema and data scripts.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了简单和 EAV 模型，是时候考虑安装必要的数据库模式和可能预先填充一些数据了。这是通过模式和数据脚本完成的。
- en: Understanding the flow of schema and data scripts
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模式和数据脚本流程
- en: Simply put, the role of the schema scripts is to create a database structure
    supporting your module logic. For example, creating a table where our entities
    would persist their data. The role of the data scripts is to manage the data within
    existing tables, usually in the form of adding some sample data during module
    installation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，模式脚本的作用是创建支持您模块逻辑的数据库结构。例如，创建一个表，我们的实体将在此表中持久化其数据。数据脚本的作用是管理现有表中的数据，通常以在模块安装期间添加一些示例数据的形式。
- en: If we look a few steps back, we can notice how `schema_version` and `data_version`
    from the database match the `setup_version` number from our `module.xml` file.
    They all imply the same thing. If we were to now change the `setup_version` number
    in our `module.xml` file and run the `php bin/magento setup:upgrade` console command
    again, our database `schema_version` and `data_version` would get updated to this
    new version number.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾几步，我们可以注意到数据库中的 `schema_version` 和 `data_version` 与我们的 `module.xml` 文件中的
    `setup_version` 数字相匹配。它们都意味着相同的事情。如果我们现在更改 `module.xml` 文件中的 `setup_version` 数字并再次运行
    `php bin/magento setup:upgrade` 控制台命令，我们的数据库 `schema_version` 和 `data_version`
    将更新到这个新版本号。
- en: 'This is done through module''s `install` and `upgrade` scripts. If we take
    a quick look at the `setup/src/Magento/Setup/Model/Installer.php` file, we can
    see a function, `getSchemaDataHandler`, with content as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过模块的 `install` 和 `upgrade` 脚本来实现的。如果我们快速查看 `setup/src/Magento/Setup/Model/Installer.php`
    文件，我们可以看到一个名为 `getSchemaDataHandler` 的函数，其内容如下：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is what tells Magento which classes to pick up and run from the individual
    module `Setup` directory. We will ignore the Recurring case for the moment, as
    only the `Magento_Indexer` module uses it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Magento 从单个模块的 `Setup` 目录中挑选和运行哪些类。目前我们将忽略重复的情况，因为只有 `Magento_Indexer` 模块使用它。
- en: 'For the first time, we run `php bin/magento setup:upgrade` against our module;
    while it still has no entries under the `setup_module` table, Magento will execute
    the files within the module `Setup` folder in following order:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行 `php bin/magento setup:upgrade` 命令针对我们的模块；尽管它仍然在 `setup_module` 表下没有条目，但
    Magento 将按照以下顺序执行模块 `Setup` 文件夹中的文件：
- en: '`InstallSchema.php`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InstallSchema.php`'
- en: '`UpgradeSchema.php`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpgradeSchema.php`'
- en: '`InstallData.php`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InstallData.php`'
- en: '`UpgradeData.php`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpgradeData.php`'
- en: Notice that this is the same order, top to bottom, as in the `getSchemaDataHandler`
    method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这与 `getSchemaDataHandler` 方法中从上到下的顺序相同。
- en: 'Every subsequent upper module version number change, followed by the console
    `php bin/magento setup:upgrade` command, would result in the following files being
    run in the order as listed:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每次后续模块版本号的变化，随后是控制台命令 `php bin/magento setup:upgrade`，都会导致以下文件按照列表中的顺序运行：
- en: '`UpgradeSchema.php`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpgradeSchema.php`'
- en: '`UpgradeData.php`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpgradeData.php`'
- en: Additionally, Magento would record the upped version number under the `setup_module`
    database. Magento will only trigger install or upgrade scripts when the version
    number in the database is less than the version number in the `module.xml` file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Magento 还会在 `setup_module` 数据库下记录升级后的版本号。只有当数据库中的版本号小于 `module.xml` 文件中的版本号时，Magento
    才会触发安装或升级脚本。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We are not required to always provide these install or upgrade scripts, if ever.
    They are only needed when we need to add or edit existing tables or entries in
    a database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们不必总是提供这些安装或升级脚本。只有在需要添加或编辑数据库中的现有表或条目时才需要它们。
- en: If we look carefully at the implementation of the `install` and `update` methods
    within the appropriate scripts, we can see they both accept `ModuleContextInterface
    $context` as a second parameter. Since upgrade scripts are the ones triggering
    on every upped version number, we can use `$context->getVersion()` to target changes
    specific to the module version.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细查看适当脚本中 `install` 和 `update` 方法的实现，我们可以看到它们都接受 `ModuleContextInterface
    $context` 作为第二个参数。由于升级脚本是在每次升级版本号时触发的，我们可以使用 `$context->getVersion()` 来针对特定于模块版本的更改。
- en: Creating an install schema script (InstallSchema.php)
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建安装模式脚本（InstallSchema.php）
- en: 'Now that we understand the flow of schema and data scripts and their relation
    to the module version number, let us go ahead and start assembling our `InstallSchema`.
    We start by defining the `app/code/Foggyline/Office/Setup/InstallSchema.php` file
    with (partial) content as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了模式和数据脚本及其与模块版本号的关系，让我们继续组装我们的 `InstallSchema`。我们首先定义 `app/code/Foggyline/Office/Setup/InstallSchema.php`
    文件，其（部分）内容如下：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`InstallSchema` conforms to `InstallSchemaInterface`, which requires the implementation
    of the `install` method that accepts two parameters of type `SchemaSetupInterface`
    and `ModuleContextInterface`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`InstallSchema` 遵循 `InstallSchemaInterface`，这要求实现接受两个类型为 `SchemaSetupInterface`
    和 `ModuleContextInterface` 的参数的 `install` 方法。'
- en: The install method is all that is required here. Within this method, we would
    add any relevant code we might have to create the tables and columns we need.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里只需要安装方法。在这个方法中，我们会添加任何可能需要的代码来创建所需的表和列。
- en: Looking through the code base, we can see that `Magento\Setup\Module\Setup`
    is the one extending `\Magento\Framework\Module\Setup` and implementing `SchemaSetupInterface`.
    The two methods seen in the preceding code, `startSetup` and `endSetup`, are used
    to run additional environment setup before and after our code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码库中查看，我们可以看到 `Magento\Setup\Module\Setup` 是扩展 `\Magento\Framework\Module\Setup`
    并实现 `SchemaSetupInterface` 的一个。前面代码中看到的两个方法 `startSetup` 和 `endSetup` 用于在我们代码之前和之后运行额外的环境设置。
- en: 'Going further, let''s replace the `/* #snippet1 */` bit with code that will
    create our `Department` model entity table as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '进一步来说，让我们将 `/* #snippet1 */` 部分替换为创建我们的 `Department` 模型实体表的代码，如下所示：'
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we are instructing Magento to create a table named `foggyline_office_department`,
    add `entity_id` and `name` columns to it, and set the comment on the table. Assuming
    we are using the MySQL server, when code executes, the following SQL gets executed
    in the database:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指示Magento创建一个名为`foggyline_office_department`的表，向其中添加`entity_id`和`name`列，并设置表的注释。假设我们使用的是MySQL服务器，当代码执行时，以下SQL将在数据库中执行：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `addColumn` method is the most interesting one here. It takes five parameters,
    from column name, column data type, column length, array of additional options,
    and column description. However, only column name and column data type are mandatory!
    Accepted column data types can be found under the `Magento\Framework\DB\Ddl\Table`
    class, and go as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`addColumn`方法是这里最有趣的一个。它接受五个参数，从列名、列数据类型、列长度、附加选项数组到列描述。然而，只有列名和列数据类型是必须的！可接受的列数据类型可以在`Magento\Framework\DB\Ddl\Table`类下找到，如下所示：'
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'An additional options array might contain some of the following keys: `unsigned`,
    `precision`, `scale`, `unsigned`, `default`, `nullable`, `primary`, `identity`,
    `auto_increment`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 附加选项数组可能包含以下一些键：`unsigned`、`precision`、`scale`、`unsigned`、`default`、`nullable`、`primary`、`identity`、`auto_increment`。
- en: 'Having gained insight into the `addColumn` method, let''s go ahead and create
    the `foggyline_office_employee_entity` table for the `Employee` entity as well.
    We do so by replacing the `/* #snippet2 */` bit from the preceding code with the
    following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '在了解了`addColumn`方法之后，让我们继续创建`foggyline_office_employee_entity`表，用于`Employee`实体。我们通过替换前面代码中的`/*
    #snippet2 */`部分来实现这一点：'
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Following good database design practices, we might notice one thing here. If
    we agree that every employee can be assigned a single department, we should add
    a foreign key to this table's `department_id` column. For the moment, we will
    purposely skip this bit, as we want to demonstrate this through the update schema
    script later on.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 根据良好的数据库设计实践，我们可能会注意到这里的一个问题。如果我们同意每个员工可以分配一个单一的部门，我们应该向该表的`department_id`列添加一个外键。目前，我们将故意跳过这一部分，因为我们想通过稍后的更新模式脚本来演示这一点。
- en: EAV models scatter their data across several tables, three at a minimum. The
    table `foggyline_office_employee_entity` that we just created is one of them.
    The other one is the core Magento `eav_attribute` table. The third table is not
    a single table, rather a list of multiple tables; one for each EAV type. These
    tables are the result of our install script.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: EAV模型将数据分散在多个表中，至少有三个。我们刚刚创建的`foggyline_office_employee_entity`表就是其中之一。另一个是核心的Magento
    `eav_attribute`表。第三个表不是一个单独的表，而是一系列多个表；每个EAV类型一个表。这些表是我们安装脚本的结果。
- en: Information stored within the core Magento `eav_attribute` table is not the
    value of an attribute or anything like it; information stored there is an attribute's
    metadata. So how does Magento know about our `Employee` attributes (`service_years`,
    `dob`, `salary`, `vat_number`, `note`)? It does not; not yet. We need to add the
    attributes into that table ourselves. We will do so later on, as we demonstrate
    the `InstallData`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在核心Magento `eav_attribute`表中的信息不是属性值或类似的东西；存储在那里的信息是属性的元数据。那么，Magento是如何知道我们的`Employee`属性（`service_years`、`dob`、`salary`、`vat_number`、`note`）的呢？它不知道；还没有。我们需要自己将属性添加到该表中。我们将在稍后通过`InstallData`演示这样做。
- en: 'Depending on the EAV attribute data type, we need to create the following tables:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 根据EAV属性数据类型，我们需要创建以下表：
- en: '`foggyline_office_employee_entity_datetime`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foggyline_office_employee_entity_datetime`'
- en: '`foggyline_office_employee_entity_decimal`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foggyline_office_employee_entity_decimal`'
- en: '`foggyline_office_employee_entity_int`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foggyline_office_employee_entity_int`'
- en: '`foggyline_office_employee_entity_text`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foggyline_office_employee_entity_text`'
- en: '`foggyline_office_employee_entity_varchar`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foggyline_office_employee_entity_varchar`'
- en: The names of these attribute value tables come from a simple formula, which
    says *{name of the entity table}+{_}+{eav_attribute.backend_type value}*. If we
    look at the salary attribute, we need it to be a decimal value, thus it will get
    stored in `foggyline_office_employee_entity_decimal`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性值表的名字来自一个简单的公式，即*{实体表名称}+{_}+{eav_attribute.backend_type值}*。如果我们看`salary`属性，我们需要它是一个小数值，因此它将被存储在`foggyline_office_employee_entity_decimal`中。
- en: 'Given the chunkiness of code behind defining attribute value tables, we will
    focus only on a single, decimal type table. We define it by replacing `/* #snippet3
    */` from the preceding code with the following bit:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '由于定义属性值表背后的代码量很大，我们将只关注一个单一的小数类型表。我们通过替换前面代码中的`/* #snippet3 */`部分来实现这一点：'
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice the `//->addIndex` part within code above. Lets replace it with the following
    bit.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上述代码中的 `//->addIndex` 部分。让我们将其替换为以下内容。
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code adds three indexes on the `foggyline_office_employee_entity_decimal`
    table, resulting in a SQL as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在 `foggyline_office_employee_entity_decimal` 表上添加了三个索引，结果生成以下 SQL：
- en: '`UNIQUE KEY ''FOGGYLINE_OFFICE_EMPLOYEE_ENTT_DEC_ENTT_ID_ATTR_ID_STORE_ID''
    (''entity_id'',''attribute_id'',''store_id'')`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNIQUE KEY ''FOGGYLINE_OFFICE_EMPLOYEE_ENTT_DEC_ENTT_ID_ATTR_ID_STORE_ID''
    (''entity_id'',''attribute_id'',''store_id'')`'
- en: '`KEY ''FOGGYLINE_OFFICE_EMPLOYEE_ENTITY_DECIMAL_STORE_ID'' (''store_id'')`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEY ''FOGGYLINE_OFFICE_EMPLOYEE_ENTITY_DECIMAL_STORE_ID'' (''store_id'')`'
- en: '`KEY ''FOGGYLINE_OFFICE_EMPLOYEE_ENTITY_DECIMAL_ATTRIBUTE_ID'' (''attribute_id'')`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEY ''FOGGYLINE_OFFICE_EMPLOYEE_ENTITY_DECIMAL_ATTRIBUTE_ID'' (''attribute_id'')`'
- en: 'Similarly, we replace the `//->addForeignKey` part from the preceding code
    with the following bit:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将前面代码中的 `//->addForeignKey` 部分替换为以下内容：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code adds foreign key relations into the `foggyline_office_employee_entity_decimal`
    table, resulting in a SQL as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将外键关系添加到 `foggyline_office_employee_entity_decimal` 表中，结果生成以下 SQL：
- en: '`CONSTRAINT ''FK_D17982EDA1846BAA1F40E30694993801'' FOREIGN KEY (''entity_id'')
    REFERENCES ''foggyline_office_employee_entity'' (''entity_id'') ON DELETE CASCADE,`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONSTRAINT ''FK_D17982EDA1846BAA1F40E30694993801'' FOREIGN KEY (''entity_id'')
    REFERENCES ''foggyline_office_employee_entity'' (''entity_id'') ON DELETE CASCADE,`'
- en: '`CONSTRAINT ''FOGGYLINE_OFFICE_EMPLOYEE_ENTITY_DECIMAL_STORE_ID_STORE_STORE_ID''
    FOREIGN KEY (''store_id'') REFERENCES ''store'' (''store_id'') ON DELETE CASCADE,`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONSTRAINT ''FOGGYLINE_OFFICE_EMPLOYEE_ENTITY_DECIMAL_STORE_ID_STORE_STORE_ID''
    FOREIGN KEY (''store_id'') REFERENCES ''store'' (''store_id'') ON DELETE CASCADE,`'
- en: '`CONSTRAINT ''FOGGYLINE_OFFICE_EMPLOYEE_ENTT_DEC_ATTR_ID_EAV_ATTR_ATTR_ID''
    FOREIGN KEY (''attribute_id'') REFERENCES ''eav_attribute'' (''attribute_id'')
    ON DELETE CASCADE`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONSTRAINT ''FOGGYLINE_OFFICE_EMPLOYEE_ENTT_DEC_ATTR_ID_EAV_ATTR_ATTR_ID''
    FOREIGN KEY (''attribute_id'') REFERENCES ''eav_attribute'' (''attribute_id'')
    ON DELETE CASCADE`'
- en: Notice how we added the `store_id` column to our EAV attribute value tables.
    Though our examples won't find use of it, it is a good practice to use `store_id`
    with your EAV entities to scope the data for a possible multi-store setup. To
    clarify further, imagine we had a multi-store setup, and with EAV attribute tables
    set up like the preceding one, we would be able to store a different attribute
    value for each store, since the unique entry in the table is defined as a combination
    of `entity_id`, `attribute_id`, and `store_id` columns.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何将 `store_id` 列添加到我们的 EAV 属性值表中。尽管我们的示例不会使用它，但使用 `store_id` 与 EAV 实体一起定义数据范围是一个好习惯。为了进一步说明，想象我们有一个多店铺设置，并且像前面的
    EAV 属性表那样设置，我们就能为每个店铺存储不同的属性值，因为表中的唯一条目定义为 `entity_id`、`attribute_id` 和 `store_id`
    列的组合。
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For the reasons of performance and data integrity, it is important to define
    indexes and foreign key as per good database design practice. We can do so within
    `InstallSchema` when defining new tables.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了性能和数据完整性的原因，根据良好的数据库设计实践定义索引和外键非常重要。我们可以在定义新表时在 `InstallSchema` 中这样做。
- en: Creating an upgrade schema script (UpgradeSchema.php)
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建升级模式脚本（UpgradeSchema.php）
- en: 'During the first-time module install, an upgrade schema is what gets run immediately
    after an install schema. We define upgrade schema within the `app/code/Foggyline/Office/Setup/UpgradeSchema.php`
    file with (partial) content as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次模块安装期间，安装模式之后立即运行升级模式。我们在 `app/code/Foggyline/Office/Setup/UpgradeSchema.php`
    文件中定义升级模式，其部分内容如下：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`UpgradeSchema` conforms to `UpgradeSchemaInterface`, which requires the implementation
    of the `upgrade` method that accepts two parameters of type `SchemaSetupInterface`
    and `ModuleContextInterface`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpgradeSchema` 遵循 `UpgradeSchemaInterface`，这要求实现接受两个参数 `SchemaSetupInterface`
    和 `ModuleContextInterface` 的 `upgrade` 方法。'
- en: This is quite similar to `InstallSchemaInterface`, except the method name. The
    `update` method is run when this schema gets triggered. Within this method, we
    would add any relevant code we might want to execute.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `InstallSchemaInterface` 非常相似，除了方法名。当此模式被触发时，会运行 `update` 方法。在这个方法中，我们会添加任何我们可能想要执行的代码。
- en: 'Going further, let''s replace the `/* #snippet1 */` part from the preceding
    code with the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '进一步来说，让我们将前面代码中的 `/* #snippet1 */` 部分替换为以下代码：'
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we are instructing Magento to create a foreign key on the `foggyline_office_employee_entity`
    table, more precisely on its `department_id` column, pointing to the `foggyline_office_department`
    table and its `entity_id` column.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指示 Magento 在 `foggyline_office_employee_entity` 表上创建一个外键，更确切地说是在其 `department_id`
    列上，指向 `foggyline_office_department` 表及其 `entity_id` 列。
- en: Creating an install data script (InstallData.php)
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建安装数据脚本（InstallData.php）
- en: 'An install data script is what gets run immediately after upgrade schema. We
    define install data schema within the `app/code/Foggyline/Office/Setup/InstallData.php`
    file with (partial) content as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 安装数据脚本是在升级架构后立即运行的。我们在`app/code/Foggyline/Office/Setup/InstallData.php`文件中定义安装数据架构，其内容如下（部分）：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`InstallData` conforms to `InstallDataInterface`, which requires the implementation
    of the `install` method that accepts two parameters of type `ModuleDataSetupInterface`
    and `ModuleContextInterface`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`InstallData`符合`InstallDataInterface`，这要求实现接受两个类型为`ModuleDataSetupInterface`和`ModuleContextInterface`的参数的`install`方法。'
- en: The `install` method is run when this script gets triggered. Within this method,
    we would add any relevant code we might want to execute.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当此脚本被触发时，将运行`install`方法。在这个方法中，我们会添加任何可能想要执行的代码。
- en: 'Going further, let''s replace the `/* #snippet1 */` part from the preceding
    code with the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '进一步来说，让我们用以下代码替换前面代码中的`/* #snippet1 */`部分：'
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using the `addAttribute` method on the instance of `\Foggyline\Office\Setup\EmployeeSetupFactory`,
    we are instructing Magento to add a number of attributes (`service_years`, `dob`,
    `salary`, `vat_number`, `note`) to its entity.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`\Foggyline\Office\Setup\EmployeeSetupFactory`实例上的`addAttribute`方法，我们指示Magento向其实体添加多个属性（`service_years`、`dob`、`salary`、`vat_number`、`note`）。
- en: 'We will soon get to the inners of `EmployeeSetupFactory`, but right now notice
    the call to the `addAttribute` method. Within this method, there is a call to
    the `$this->attributeMapper->map($attr, $entityTypeId)` method. `attributeMapper`
    conforms to `Magento\Eav\Model\Entity\Setup\PropertyMapperInterface`, which looking
    at `vendor/magento/module-eav/etc/di.xml` has a preference for the `Magento\Eav\Model\Entity\Setup\PropertyMapper\Composite`
    class, which further initializes the following mapper classes:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会进入`EmployeeSetupFactory`的内部，但现在请注意对`addAttribute`方法的调用。在这个方法中，有一个对`$this->attributeMapper->map($attr,
    $entityTypeId)`方法的调用。`attributeMapper`符合`Magento\Eav\Model\Entity\Setup\PropertyMapperInterface`，查看`vendor/magento/module-eav/etc/di.xml`，它对`Magento\Eav\Model\Entity\Setup\PropertyMapper\Composite`类有优先权，该类进一步初始化以下映射类：
- en: '`Magento\Eav\Model\Entity\Setup\PropertyMapper`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Magento\Eav\Model\Entity\Setup\PropertyMapper`'
- en: '`Magento\Customer\Model\ResourceModel\Setup\PropertyMapper`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Magento\Customer\Model\ResourceModel\Setup\PropertyMapper`'
- en: '`Magento\Catalog\Model\ResourceModel\Setup\PropertyMapper`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Magento\Catalog\Model\ResourceModel\Setup\PropertyMapper`'
- en: '`Magento\ConfigurableProduct\Model\ResourceModel\Setup\PropertyMapper`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Magento\ConfigurableProduct\Model\ResourceModel\Setup\PropertyMapper`'
- en: 'Since we are defining our own entity types, the mapper class we are mostly
    interested in is `Magento\Eav\Model\Entity\Setup\PropertyMapper`. A quick look
    inside of it reveals the following mapping array in the `map` method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在定义自己的实体类型，我们主要感兴趣的映射类是`Magento\Eav\Model\Entity\Setup\PropertyMapper`。快速查看它，我们发现`map`方法中的以下映射数组：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Looking at the preceding array keys and value strings gives us a clue as to
    what is happening. The key strings match the column names in the `eav_attribute`
    table, while the value strings match the keys of our array passed to the `addAttribute`
    method within `InstallData.php`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看前面的数组键和值字符串，我们可以了解正在发生的事情。键字符串与`eav_attribute`表中的列名匹配，而值字符串与我们在`InstallData.php`中通过`addAttribute`方法传递给数组的键匹配。
- en: 'Let''s take a look at the `EmployeeSetupFactory` class within the `app/code/Foggyline/Office/Setup/EmployeeSetup.php`
    file, (partially) defined as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`app/code/Foggyline/Office/Setup/EmployeeSetup.php`文件中的`EmployeeSetupFactory`类，其定义如下（部分）：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'What''s happening here is that we are extending from the Magento\Eav\Setup\EavSetup
    class, thus effectively telling Magento we are about to create our own entity.
    We do so by overriding `getDefaultEntities`, replacing `/* #snippet1 */` with
    content as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '这里发生的事情是我们从`Magento\Eav\Setup\EavSetup`类扩展，从而有效地告诉Magento我们即将创建自己的实体。我们通过重写`getDefaultEntities`，用以下内容替换`/*
    #snippet1 */`来实现这一点：'
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `getDefaultEntities` method returns an array of entities we want to register
    with Magento. Within our `$entities` array, the key `$employeeEntity` becomes
    an entry in the `eav_entity_type` table. Given that our `$employeeEntity` has
    a value of `foggyline_office_employee`, running the following SQL query should
    yield a result:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDefaultEntities`方法返回一个我们想要与Magento注册的实体数组。在我们的`$entities`数组中，键`$employeeEntity`成为`eav_entity_type`表中的一个条目。鉴于我们的`$employeeEntity`的值为`foggyline_office_employee`，运行以下SQL查询应该会产生结果：'
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Only a handful of metadata values are required to make our new entity type functional.
    The `entity_model` value should point to our EAV model `resource` class, not the
    `model` class. The table value should equal the name of our EAV entity table in
    the database. Finally, the attributes array should list any attribute we want
    created on this entity. Attributes and their metadata get created in the `eav_attribute`
    table.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: If we look back at all those `foggyline_office_employee_entity_*` attribute
    value tables we created, they are not the ones that actually create attributes
    or register a new entity type in Magento. What creates attributes and a new entity
    type is the array we just defined under the `getDefaultEntities` method. Once
    Magento creates the attributes and registers a new entity type, it simply routes
    the entity save process to proper attribute value tables depending on the type
    of attribute.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Creating an upgrade data script (UpgradeData.php)
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The upgrade data script is the last one to execute. We will use it to demonstrate
    the example of creating the sample entries for our `Department` and `Employee`
    entities.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating the `app/code/Foggyline/Office/Setup/UpgradeData.php`
    file with (partial) content as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`UpgradeData` conforms to `UpgradeDataInterface`, which requires the implementation
    of the upgrade method that accepts two parameters of type `ModuleDataSetupInterface`
    and `ModuleContextInterface`. We are further adding our own `__construct` method
    to which we are passing `DepartmentFactory` and `EmployeeFactory`, as we will
    be using them within the upgrade method as shown next, by replacing `/* #snippet1
    */` with the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code creates an instance of the department entity and then saves
    it. An instance of employee is then created and saved, passing it the newly created
    department ID and other attributes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A more convenient and professional-looking approach for saving an entity could
    be given as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we are utilizing the fact that each of the entity setter methods returns
    `$this` (an instance of the entity object itself), so we can chain the method
    calls.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Entity CRUD actions
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have learned how to create a simple model, an EAV model,
    and install and upgrade types of schema and data script. Now, let us see how we
    can create, read, update and delete our entities, operations that are commonly
    referred to as CRUD.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Though this chapter is about models, collections, and related things, for the
    purpose of demonstration, let's make a tiny detour into routes and controllers.
    The idea is to create a simple `Test` controller with the `Crud` action we can
    trigger in the browser via a URL. Within this `Crud` action, we will then dump
    our CRUD-related code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'To make Magento respond to the URL we punch into the browser, we need to define
    the route. We do so by creating the `app/code/Foggyline/Office/etc/frontend/routes.xml`
    file with the following content:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Route definition requires a unique ID and `frontName` attribute values, which
    in our case both equal `foggyline_office`. The `frontName` attribute value becomes
    the part of our URL structure. Simply put, the URL formula for hitting the `Crud`
    action goes like *{magento-base-url}/index.php/{route frontName}/{controller name}/{action
    name}*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For example, if our base URL were `http://shop.loc/`, the full URL would be
    `http://shop.loc/index.php/foggyline_office/test/crud/`. If we have URL rewrites
    turned on, we could omit the `index.php` part.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the route has been defined, we can go ahead and create the `Test` controller,
    defined in the `app/code/Foggyline/Office/Controller/Test.php` file with (partial)
    code as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This really is the simplest controller we could have defined. The only thing
    worth noting here is that the controller class needs to be defined as abstract
    and extend the `\Magento\Framework\App\Action\Action` class. Controller actions
    live outside of the controller itself and can be found under the subdirectory
    on the same level and named as controller. Since our controller is called `Test`,
    we place our `Crud` action under the `app/code/Foggyline/Office/Controller/Test/Crud.php`
    file with content as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `Controller` action class is basically just an extension of the controller
    defining the `execute` method. Code within the execute method is what gets run
    when we hit the URL in the browser. Additionally, we have a `__construct` method
    to which we are passing the `EmployeeFactory` and `DepartmentFactory` classes,
    which we will soon use for our CRUD examples. Note that `EmployeeFactory` and
    `DepartmentFactory` are not classes created by us. Magento will autogenerate them
    under the `DepartmentFactory.php` and `EmployeeFactory.php` files within the `var/generation/Foggyline/Office/Model`
    folder. These are factory classes for our `Employee` and `Department` model classes,
    generated when requested.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: With this, we finish our little detour and focus back on our entities.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Creating new entities
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three different flavors, if we might call them that, by which we
    can set property (field and attribute) values on our entity. They all lead to
    the same result. The following few code snippets can be copied and pasted into
    our `Crud` class `execute` method for testing, simply by replacing `/* CRUD Code
    Here */` with one of the following code snippets:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `flavour #1` approach from the preceding code is probably the preferred
    way of setting properties, as it is using the magic method approach we mentioned
    previously. Both `flavour #2` and `flavour #3` use the `setData` method, just
    in a slightly different manner. All three examples should yield the same result
    once the `save` method is called on an `object` instance.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to save the simple model, let''s take a quick look at
    doing the same with the EAV model. The following are analogous code snippets:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As we can see, the EAV code for persisting the data is identical to the simple
    model. There is one thing here worth noting. The `Employee` entity has a relation
    defined toward department. Forgetting to specify `department_id` on a new `employee`
    entity save would result in an error message similar to the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Magento saves these types of errors under its `var/report` directory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Reading existing entities
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Reading an entity based on a provided entity ID value comes down to instantiating
    the entity and using the load method to which we pass the entity ID as shown next:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There is no real difference between loading the simple model or EAV model,
    as shown in the following EAV model example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice how the EAV entity loads all of its field and attribute values, which
    is not always the case when we obtain the entity through EAV collection, as we
    will show later on.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Updating existing entities
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Updating entities comes down to using the `load` method to read an existing
    entity, reset its value, and calling the `save` method in the end, like shown
    in the following example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Regardless of the entity being the simple model or an EAV, the code is the same.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Deleting existing entities
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Calling the `delete` method on a loaded entity will delete the entity from
    the database or throw `Exception` if it fails. Code to delete the entity looks
    as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There is no difference in deleting the simple and EAV entities. We should always
    use try/catch blocks when deleting or saving our entities.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Managing collections
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with EAV model collections. We can instantiate the collection
    either through the entity `factory` class like follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Or we can use object manager to instantiate the collection as shown next:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There is also a third way, which might be the preferred one, but it requires
    us to define APIs so we will skip that one for the moment.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we instantiate the collection object, we can loop through it and do some
    variable dumps to see the content on individual `$employee` entities, like shown
    next:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding would yield results like the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice how the individual `$employee` only has fields on it, not the attributes.
    Let''s see what happens when we want to extend our collection by using `addAttributeToSelect`
    to specify the individual attributes to add to it, like shown next:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding would yield results like the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Though we are making progress, imagine if we had tens of attributes, and we
    want each and every one to be included into collection. Using `addAttributeToSelect`
    numerous times would make for cluttered code. What we can do is pass `''*''` as
    a parameter to `addAttributeToSelect` and have collection pick up every attribute,
    as shown next:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This would yield results like the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Though the PHP part of the code looks seemingly simple, what''s happening in
    the background on the SQL layer is relatively complex. Though Magento executes
    several SQL queries prior to fetching the final collection result, let''s focus
    on the last three queries as shown next:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we proceed any further, it is important to know that these queries are
    not copy and paste applicable. The reason is that the `attribute_id` values will
    for sure differ from installation to installation. Queries given here are for
    us to gain a high-level understanding of what is happening in the backend on the
    SQL layer when we use Magento collections on the PHP application level.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'The first query select simply counts the number of entries in the entity table,
    and then passes that info to the application layer. The second select fetches
    all entries from `foggyline_office_employee_entity`, then passes that info to
    the application layer to use it to pass entity IDs in the third query as part
    of `entity_id IN (24, 25, 26)`. Second and third queries here can be pretty resource
    intense if we have a large amount of entries in our entity and EAV tables. To
    prevent possible performance bottlenecks, we should always use the `setPageSize`
    and `setCurPage` methods on collection, like shown next:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This would result in the first `COUNT` query still being the same, but the
    second query would now look like the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This makes for a much smaller, thus performance-lighter dataset if we have thousands
    or tens of thousands of entries. The point here is to always use `setPageSize`
    and `setCurPage`. If we need to work with a really large set, then we need to
    page through it, or walk through it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Now we know how to limit the size of the result set and fetch the proper page,
    let's see how we can further filter the set to avoid overusing PHP loops for the
    same purpose. Thus effectively passing the filtering to the database and not the
    application layer. To filter the EAV collection, we use its `addAttributeToFilter`
    method.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s instantiate a clean new collection like shown next:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notice that we are now using the `addAttributeToSelect` and `addAttributeToFilter`
    methods on collection. We have already seen the database impact of `addAttributeToSelect`
    on a SQL query. What `addAttributeToFilter` does is something completely different.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `addAttributeToFilter` method, the count query now gets transformed
    into the following SQL query:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can see that this is much more complex than the previous count query, now
    we have `INNER JOIN` stepping in. Notice how we have four `addAttributeToFilter`
    method calls but only three `INNER JOIN`. This is because one of those four calls
    is for e-mail, which is not an attribute but a field within the `foggyline_office_employee_entity`
    table. That is why there is no need for `INNER JOIN` as the field is already there.
    The three `INNER JOIN` then simply merge the required info into the query in order
    to get the select.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'The second query also becomes more robust, as shown next:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we also see the usage of `INNER JOIN`. We also have three and not four
    `INNER JOIN`, because one of the conditions is done against `email`, which is
    a field. The result of the query is a flattened piece of rows where the attributes
    `vat_number`, `salary`, and `service_years` are present. We can imagine the performance
    impact if we haven't used `setPageSize` to limit the result set.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the third query is also affected and now looks similar to the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice here how `UNION ALL` has been reduced to a single occurrence now, thus
    effectively making for two selects. This is because we have a total of five attributes
    (`service_years`, `dob`, `salary`, `vat_number`, `note`), and three of them have
    been pulled in through second query. Out of the preceding three queries demonstrated,
    Magento basically pulls the collection data from second and third query. This
    seems like a pretty optimized and scalable solution, though we should really give
    it some thought on the proper use of `setPageSize`, `addAttributeToSelect`, and
    `addAttributeToFilter` methods when creating collection.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: During development, if working with collections that have lot of attributes,
    filters, and possibly a future large dataset, we might want to use SQL logging
    to record actual SQL queries hitting the database server. This might help us spot
    possible performance bottlenecks and react on time, either by adding more limiting
    values to `setPageSize` or `addAttributeToSelect`, or both.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding examples, the use of `addAttributeToSelect` results in `AND`
    conditions on the SQL layer. What if we want to filter collection using `OR` conditions?
    `addAttributeToSelect` can also result in SQL `OR` conditions if the `$attribute`
    parameter is used in the following way:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Without going into the details of actual SQL queries this time, it is suffice
    to say that they are near identical to the previous example with the `AND` condition
    use of `addAttributeToFilter`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Using collection methods like `addExpressionAttributeToSelect`, `groupByAttribute`,
    and `addAttributeToSort`, collections offer further gradient filtering and even
    shift some calculations from the PHP application layer to the SQL layer. Getting
    into the ins and outs of those and other collection methods is beyond the scope
    of this chapter, and would probably require a book on its own.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Collection filters
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Looking back at the preceding `addAttributeToFilter` method call examples,
    questions pop out as to where can we see the list of all available collection
    filters. If we take a quick look inside the `vendor/magento/framework/DB/Adapter/Pdo/Mysql.php`
    file, we can see the method called `prepareSqlCondition` (partially) defined as
    follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This method is what eventually gets called at some point during SQL query construction.
    The `$condition` parameter is expected to have one of the following (partially
    listed) forms:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '`array("from" => $fromValue, "to" => $toValue)`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array("eq" => $equalValue)`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array("neq" => $notEqualValue)`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array("like" => $likeValue)`'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array("in" => array($inValues))`'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array("nin" => array($notInValues))`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array("notnull" => $valueIsNotNull)`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array("null" => $valueIsNull)`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array("gt" => $greaterValue)`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array("lt" => $lessValue)`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array("gteq" => $greaterOrEqualValue)`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array("lteq" => $lessOrEqualValue)`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array("finset" => $valueInSet)`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array("regexp" => $regularExpression)`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array("seq" => $stringValue)`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array("sneq" => $stringValue)`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `$condition` is passed as an integer or string, then the exact value will
    be filtered (`'eq'` condition). If none of the conditions is matched, then a sequential
    array is expected as a parameter and `OR` conditions will be built using the preceding
    structure.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The preceding examples covered EAV model collections, as they are slightly more
    complex. Though the approach to filtering more or less applies to simple model
    collections as well, the most notable difference is that there are no `addAttributeToFilter`,
    `addAttributeToSelect`, and `addExpressionAttributeToSelect` methods. The simple
    model collections make use of `addFieldToFilter`, `addFieldToSelect`, and `addExpressionFieldToSelect`,
    among other subtle differences.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first learned how to create simple model, its resource,
    and collection class. Then we did the same for an EAV model. Once we had the required
    model, resource, and collection classes in place, we took a detailed look at the
    type and flow of schema and data scripts. Going hands-on, we covered `InstallSchema`,
    `UpgradeSchema`, `InstallData`, and `UpgradeData` scripts. Once the scripts were
    run, the database ended up having the required tables and sample data upon which
    we based our entity CRUD examples. Finally, we took a quick but focused look at
    collection management, mostly comprising filtering collection to get the desired
    result set.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: The full module code can be downloaded from [https://github.com/ajzele/B05032-Foggyline_Office](https://github.com/ajzele/B05032-Foggyline_Office).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
