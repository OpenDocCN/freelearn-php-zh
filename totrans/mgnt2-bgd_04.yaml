- en: Chapter 4. Models and Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。模型和集合
- en: Like most modern frameworks and platforms, these days Magento embraces an **Object
    Relational Mapping** (**ORM**) approach over raw SQL queries. Though the underlying
    mechanism still comes down to SQL, we are now dealing strictly with objects. This
    makes our application code more readable, manageable, and isolated from vendor-specific
    SQL differences. Model, resource, and collection are three types of classes working
    together to allow us full entity data management, from loading, saving, deleting,
    and listing entities. The majority of our data access and management will be done
    via PHP classes called Magento models. Models themselves don't contain any code
    for communicating with the database.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如同大多数现代框架和平台，如今 Magento 采用 **对象关系映射**（**ORM**）方法而非原始 SQL 查询。尽管底层机制仍然归结为 SQL，我们现在严格处理对象。这使得我们的应用程序代码更易读、更易于管理，并从供应商特定的
    SQL 差异中隔离出来。模型、资源和集合是三种类型的类协同工作，使我们能够全面管理实体数据，从加载、保存、删除和列出实体。我们的大部分数据访问和管理将通过名为
    Magento 模型的 PHP 类来完成。模型本身不包含与数据库通信的任何代码。
- en: The database communication part is decoupled into its own PHP class called resource
    class. Each model is then assigned a resource class. Calling `load`, `save`, or
    `delete` methods on models get delegated to resource classes, as they are the
    ones to actually read, write, and delete data from the database. Theoretically,
    with enough knowledge, it is possible to write new resource classes for various
    database vendors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库通信部分被解耦成其自身的 PHP 类，称为资源类。然后每个模型都被分配一个资源类。在模型上调用 `load`、`save` 或 `delete`
    方法会被委托给资源类，因为它们是实际从数据库读取、写入和删除数据的地方。理论上，有了足够的知识，可以编写针对各种数据库供应商的新资源类。
- en: Next to the model and resource classes, we have collection classes. We can think
    of a collection as an array of individual model instances. On a base level, collections
    extend from the `\Magento\Framework\Data\Collection` class, which implements `\IteratorAggregate`
    and `\Countable` from **Standard PHP Library** (**SPL**) and a few other Magento-specific
    classes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了模型和资源类之外，我们还有集合类。我们可以将集合视为单个模型实例的数组。在基本层面上，集合扩展自 `\Magento\Framework\Data\Collection`
    类，该类实现了来自 **标准 PHP 库**（**SPL**）的 `\IteratorAggregate` 和 `\Countable` 以及一些其他 Magento
    特定的类。
- en: More often than not, we look at model and resource as a single unified thing,
    thus simply calling it a model. Magento deals with two types of models, which
    we might categorize as simple and EAV models.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的时候，我们将模型和资源视为一个单一统一的事物，因此简单地称之为模型。Magento 处理两种类型的模型，我们可以将它们分类为简单和 EAV 模型。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a miniature module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个微型模块
- en: Creating a simple model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单模型
- en: The EAV model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EAV 模型
- en: Understanding the flow of schema and data scripts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模式和数据脚本流程
- en: Creating an install schema script (`InstallSchema.php`)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建安装模式脚本（`InstallSchema.php`）
- en: Creating an upgrade schema script (`UpgradeSchema.php`)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建升级模式脚本（`UpgradeSchema.php`）
- en: Creating an install data script (`InstallData.php`)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建安装数据脚本（`InstallData.php`）
- en: Creating an upgrade data script (`UpgradeData.php`)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建升级数据脚本（`UpgradeData.php`）
- en: Entity CRUD actions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体 CRUD 操作
- en: Managing collections
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理集合
- en: Creating a miniature module
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个微型模块
- en: For the purpose of this chapter, we will create a miniature module called `Foggyline_Office`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，我们将创建一个名为 `Foggyline_Office` 的小型模块。
- en: 'The module will have two entities defined as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块将定义两个实体，如下所示：
- en: '`Department`: a simple model with the following fields:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Department`：一个具有以下字段的简单模型：'
- en: '`entity_id`: primary key'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entity_id`：主键'
- en: '`name`: name of department, string value'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：部门的名称，字符串值'
- en: '`Employee`: an EAV model with the following fields and attributes:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Employee`：一个具有以下字段和属性的 EAV 模型：'
- en: '**Fields:**'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字段：**'
- en: '`entity_id`: primary key'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entity_id`：主键'
- en: '`department_id`: foreign key, pointing to `Department.entity_id`'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`department_id`：外键，指向 `Department.entity_id`'
- en: '`email`: unique e-mail of an employee, string value'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`：员工的唯一电子邮件，字符串值'
- en: '`first_name`: first name of an employee, string value'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first_name`：员工的姓名，字符串值'
- en: '`last_name`: last name of an employee, string value'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`last_name`：员工的姓氏，字符串值'
- en: '**Attributes:**'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性：**'
- en: '`service_years`: employee''s years of service, integer value'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service_years`：员工的工龄，整数值'
- en: '`dob`: employee''s date of birth, date-time value'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dob`：员工的出生日期，日期时间值'
- en: '`salary` – monthly salary, decimal value'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`salary` – 月薪，十进制值'
- en: '`vat_number`: VAT number, (short) string value'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vat_number`：增值税号，（短）字符串值'
- en: '`note`: possible note on employee, (long) string value'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`note`：关于员工的可能注释，（长）字符串值'
- en: 'Every module starts with the `registration.php` and `module.xml` files. For
    the purpose of our chapter module, let''s create the `app/code/Foggyline/Office/registration.php`
    file with content as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都以 `registration.php` 和 `module.xml` 文件开始。为了我们本章模块的目的，让我们创建一个包含以下内容的 `app/code/Foggyline/Office/registration.php`
    文件：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `registration.php` file is sort of an entry point to our module.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`registration.php` 文件可以看作是我们模块的入口点。'
- en: 'Now let''s create the `app/code/Foggyline/Office/etc/module.xml` file with
    the following content:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个包含以下内容的 `app/code/Foggyline/Office/etc/module.xml` 文件：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will get into more details about the structure of the `module.xml` file in
    later chapters. Right now, we will only focus on the `setup_version` attribute
    and `module` element within `sequence`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中更详细地介绍 `module.xml` 文件的结构。现在，我们只关注 `sequence` 中的 `setup_version` 属性和
    `module` 元素。
- en: The value of `setup_version` is important because we might use it within our
    schema install script (`InstallSchema.php`) files, effectively turning the install
    script into an update script, as we will show soon.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup_version` 的值很重要，因为我们可能会在我们的模式安装脚本（`InstallSchema.php`）文件中使用它，有效地将安装脚本转换为更新脚本，正如我们很快将展示的那样。'
- en: The `sequence` element is Magento's way of setting dependencies for our module.
    Given that our module will make use of EAV entities, we list `Magento_Eav` as
    a dependency.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`sequence` 元素是 Magento 为我们的模块设置依赖关系的方式。鉴于我们的模块将使用 EAV 实体，我们列出 `Magento_Eav`
    作为依赖项。'
- en: Creating a simple model
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的模型
- en: The `Department` entity, as per requirements, is modeled as a simple model.
    We previously mentioned that whenever we talk about models, we implicitly think
    of `model` class, `resource` class, and `collection` class forming one unit.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 根据要求，`Department` 实体被建模为一个简单的模型。我们之前提到，每当谈到模型时，我们隐含地想到 `model` 类、`resource`
    类和 `collection` 类形成一个单元。
- en: 'Let''s start by first creating a `model` class, (partially) defined under the
    `app/code/Foggyline/Office/Model/Department.php` file as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从创建一个 `model` 类开始，部分定义在 `app/code/Foggyline/Office/Model/Department.php`
    文件中，如下所示：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All that is happening here is that we are extending from the `\Magento\Framework\Model\AbstractModel`
    class, and triggering the `$this->_init` method within `_construct` passing it
    our `resource` class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的一切就是，我们正在扩展 `\Magento\Framework\Model\AbstractModel` 类，并在 `_construct`
    方法中触发 `$this->_init` 方法，传递我们的 `resource` 类。
- en: 'The `AbstractModel` further extends `\Magento\Framework\Object`. The fact that
    our `model` class ultimately extends from `Object` means that we do not have to
    define a property name on our `model` class. What `Object` does for us is that
    it enables us to get, set, unset, and check for a value existence on properties
    magically. To give a more robust example than `name`, imagine our entity has a
    property called `employee_average_salary` in the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractModel` 进一步扩展了 `\Magento\Framework\Object`。我们的 `model` 类最终从 `Object`
    继承的事实意味着我们不需要在 `model` 类上定义属性名称。`Object` 为我们做的事情是，它使我们能够神奇地获取、设置、取消设置和检查属性上的值存在。为了给出一个比
    `name` 更健壮的例子，想象我们的实体在以下代码中有一个名为 `employee_average_salary` 的属性：'
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The reason why this works is due to `Object` implementing the `setData`, `unsetData`,
    `getData`, and magic `__call` methods. The beauty of the magic `__call` method
    implementation is that it understands method calls like `getEmployeeAverageSalary`,
    `setEmployeeAverageSalary`, `unsEmployeeAverageSalary`, and `hasEmployeeAverageSalary`
    even if they do not exist on the `Model` class. However, if we choose to implement
    some of these methods within our `Model` class, we are free to do so and Magento
    will pick it up when we call it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为 `Object` 实现了 `setData`、`unsetData`、`getData` 和魔法 `__call` 方法。魔法 `__call`
    方法实现的美丽之处在于，它理解 `getEmployeeAverageSalary`、`setEmployeeAverageSalary`、`unsEmployeeAverageSalary`
    和 `hasEmployeeAverageSalary` 这样的方法调用，即使它们不存在于 `Model` 类上。然而，如果我们选择在我们的 `Model`
    类中实现一些这些方法，我们可以自由地这样做，并且当调用它们时，Magento 会捕获它们。
- en: This is an important aspect of Magento, sometimes confusing to newcomers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Magento 的一个重要方面，有时对新来者来说可能有些令人困惑。
- en: 'Once we have a `model` class in place, we create a model `resource` class,
    (partially) defined under the `app/code/Foggyline/Office/Model/ResourceModel/Department.php`
    file as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个 `model` 类，我们创建一个模型 `resource` 类，部分定义在 `app/code/Foggyline/Office/Model/ResourceModel/Department.php`
    文件中，如下所示：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our resource class that extends from `\Magento\Framework\Model\ResourceModel\Db\AbstractDb`
    triggers the `$this->_init` method call within `_construct`. `$this->_init` accepts
    two parameters. The first parameter is the table name `foggyline_office_department`,
    where our model will persist its data. The second parameter is the primary column
    name `entity_id` within that table.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继承自`\Magento\Framework\Model\ResourceModel\Db\AbstractDb`的`resource`类在`_construct`方法中触发`$this->_init`方法的调用。`$this->_init`接受两个参数。第一个参数是表名`foggyline_office_department`，我们的模型将在此表中持久化其数据。第二个参数是表中的主键列名`entity_id`。
- en: '`AbstractDb` further extends `Magento\Framework\Model\ResourceModel\AbstractResource`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractDb`进一步扩展了`Magento\Framework\Model\ResourceModel\AbstractResource`。'
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resource class is the key to communicating to the database. All it takes
    is for us to name the table and its primary key and our models can save, delete,
    and update entities.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 资源类是向数据库通信的关键。我们只需要命名表及其主键，我们的模型就可以保存、删除和更新实体。
- en: 'Finally, we create our `collection` class, (partially) defined under the `app/code/Foggyline/Office/Model/ResourceModel/Department/Collection.php`
    file as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建我们的`collection`类，部分定义在`app/code/Foggyline/Office/Model/ResourceModel/Department/Collection.php`文件中，如下所示：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `collection` class extends from `\Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection`
    and, similar to the `model` and `resource` classes, does a `$this->_init` method
    call within `_construct`. This time, `_init` accepts two parameters. The first
    parameter is the full `model` class name `Foggyline\Office\Model\Department`,
    and the second parameter is the full resource class name `Foggyline\Office\Model\ResourceModel\Department`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`collection`类继承自`\Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection`，并且类似于`model`和`resource`类，在`_construct`方法中调用`$this->_init`方法。这次，`_init`接受两个参数。第一个参数是完整的`model`类名`Foggyline\Office\Model\Department`，第二个参数是完整的资源类名`Foggyline\Office\Model\ResourceModel\Department`。'
- en: '`AbstractCollection` implements `Magento\Framework\App\ResourceConnection\SourceProviderInterface`,
    and extends `\Magento\Framework\Data\Collection\AbstractDb`. `AbstractDb` further
    extends `\Magento\Framework\Data\Collection`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractCollection`实现了`Magento\Framework\App\ResourceConnection\SourceProviderInterface`，并扩展了`\Magento\Framework\Data\Collection\AbstractDb`。`AbstractDb`进一步扩展了`\Magento\Framework\Data\Collection`。'
- en: It is worth taking some time to study the inners of these `collection` classes,
    as this is our go-to place for whenever we need to deal with fetching a list of
    entities that match certain search criteria.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 值得花些时间研究这些`collection`类的内部结构，因为这是我们处理获取符合某些搜索标准实体列表时的首选地方。
- en: Creating an EAV model
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个EAV模型
- en: The `Employee` entity, as per requirements, is modeled as an EAV model.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据要求，`Employee`实体被建模为一个EAV模型。
- en: 'Let''s start by first creating an EAV `model` class, (partially) defined under
    the `app/code/Foggyline/Office/Model/Employee.php` file as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从创建一个EAV `model`类开始，部分定义在`app/code/Foggyline/Office/Model/Employee.php`文件中，如下所示：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we are extending from the `\Magento\Framework\Model\AbstractModel` class,
    which is the same as with the simple model previously described. The only difference
    here is that we have an `ENTITY` constant defined, but this is merely syntactical
    sugar for later on; it bears no meaning for the actual `model` class.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们继承自`\Magento\Framework\Model\AbstractModel`类，这与之前描述的简单模型相同。这里唯一的区别是我们定义了一个`ENTITY`常量，但这只是为了后面的语法糖；它对实际的`model`类没有实际意义。
- en: 'Next, we create an EAV model `resource` class, (partially) defined under the
    `app/code/Foggyline/Office/Model/ResourceModel/Employee.php` file as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个EAV模型`resource`类，部分定义在`app/code/Foggyline/Office/Model/ResourceModel/Employee.php`文件中，如下所示：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our `resource` class extends from `\Magento\Eav\Model\Entity\AbstractEntity`,
    and sets the `$this->_read`, `$this->_write` class properties through `_construct`.
    These are freely assigned to whatever value we want, preferably following the
    naming pattern of our module. The read and write connections need to be named
    or else Magento produces an error when using our entities.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`resource`类继承自`\Magento\Eav\Model\Entity\AbstractEntity`，并通过`_construct`方法设置`$this->_read`和`$this->_write`类属性。这些可以自由分配为我们想要的任何值，最好遵循我们模块的命名模式。读取和写入连接需要命名，否则当使用我们的实体时，Magento会产生错误。
- en: The `getEntityType` method internally sets the `_type` value to `\Foggyline\Office\Model\Employee::ENTITY`,
    which is the string `foggyline_office_employee`. This same value is what's stored
    in the `entity_type_code` column within the `eav_entity_type` table. At this point,
    there is no such entry in the `eav_entity_type` table. This is because the install
    schema script will be creating one, as we will be demonstrating soon.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`getEntityType` 方法内部将 `_type` 值设置为 `\Foggyline\Office\Model\Employee::ENTITY`，即字符串
    `foggyline_office_employee`。这个相同的值存储在 `eav_entity_type` 表的 `entity_type_code`
    列中。此时，`eav_entity_type` 表中没有这样的条目。这是因为安装模式脚本将会创建一个，正如我们很快将要演示的那样。'
- en: 'Finally, we create our `collection` class, (partially) defined under the `app/code/Foggyline/Office/Model/ResourceModel/Employee/Collection.php`
    file as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建我们的 `collection` 类，部分定义在 `app/code/Foggyline/Office/Model/ResourceModel/Employee/Collection.php`
    文件中，如下所示：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `collection` class extends from `\Magento\Eav\Model\Entity\Collection\AbstractCollection`
    and, similar to the model class, does a `$this->_init` method call within `_construct`.
    `_init` accepts two parameters: the full model class name `Foggyline\Office\Model\Employee`,
    and the full resource class name `Foggyline\Office\Model\ResourceModel\Employee`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`collection` 类继承自 `\Magento\Eav\Model\Entity\Collection\AbstractCollection`，并且与模型类类似，在
    `_construct` 中调用 `$this->_init` 方法。`_init` 接受两个参数：完整的模型类名 `Foggyline\Office\Model\Employee`
    和完整的资源类名 `Foggyline\Office\Model\ResourceModel\Employee`。'
- en: '`AbstractCollection` has the same parent tree as the simple model collection
    class, but on its own it implements a lot of EAV collection-specific methods like
    `addAttributeToFilter`, `addAttributeToSelect`, `addAttributeToSort`, and so on.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractCollection` 与简单模型集合类具有相同的父树，但自身实现了很多 EAV 集合特定的方法，如 `addAttributeToFilter`、`addAttributeToSelect`、`addAttributeToSort`
    等。'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As we can see, EAV models look a lot like simple models. The difference lies
    mostly in the `resource` class and `collection` class implementations and their
    first level parent classes. However, we need to keep in mind that the example
    given here is the simplest one possible. If we look at the `eav_entity_type` table
    in the database, we can see that other entity types make use of `attribute_model`,
    `entity_attribute_collection`, `increment_model`, and so on. These are all advanced
    properties we can define alongside our EAV model making it closer to the implementation
    of the `catalog_product` entity type, which is probably the most robust one in
    Magento. This type of advanced EAV usage is out of the scope of this book as it
    is probably worth a book on its own.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，EAV 模型看起来与简单模型非常相似。区别主要在于 `resource` 类和 `collection` 类的实现及其一级父类。然而，我们需要记住，这里给出的例子是最简单的一种。如果我们查看数据库中的
    `eav_entity_type` 表，我们可以看到其他实体类型使用了 `attribute_model`、`entity_attribute_collection`、`increment_model`
    等。这些都是我们可以定义在 EAV 模型旁边的先进属性，使其更接近 `catalog_product` 实体类型的实现，这可能是 Magento 中最健壮的一种。这种高级
    EAV 使用超出了本书的范围，因为它可能值得一本自己的书。
- en: Now that we have simple and EAV models in place, it is time to look into installing
    the necessary database schema and possibly pre-fill it with some data. This is
    done through schema and data scripts.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了简单和 EAV 模型，是时候考虑安装必要的数据库模式和可能预先填充一些数据了。这是通过模式和数据脚本完成的。
- en: Understanding the flow of schema and data scripts
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模式和数据脚本流程
- en: Simply put, the role of the schema scripts is to create a database structure
    supporting your module logic. For example, creating a table where our entities
    would persist their data. The role of the data scripts is to manage the data within
    existing tables, usually in the form of adding some sample data during module
    installation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，模式脚本的作用是创建支持您模块逻辑的数据库结构。例如，创建一个表，我们的实体将在此表中持久化其数据。数据脚本的作用是管理现有表中的数据，通常以在模块安装期间添加一些示例数据的形式。
- en: If we look a few steps back, we can notice how `schema_version` and `data_version`
    from the database match the `setup_version` number from our `module.xml` file.
    They all imply the same thing. If we were to now change the `setup_version` number
    in our `module.xml` file and run the `php bin/magento setup:upgrade` console command
    again, our database `schema_version` and `data_version` would get updated to this
    new version number.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾几步，我们可以注意到数据库中的 `schema_version` 和 `data_version` 与我们的 `module.xml` 文件中的
    `setup_version` 数字相匹配。它们都意味着相同的事情。如果我们现在更改 `module.xml` 文件中的 `setup_version` 数字并再次运行
    `php bin/magento setup:upgrade` 控制台命令，我们的数据库 `schema_version` 和 `data_version`
    将更新到这个新版本号。
- en: 'This is done through module''s `install` and `upgrade` scripts. If we take
    a quick look at the `setup/src/Magento/Setup/Model/Installer.php` file, we can
    see a function, `getSchemaDataHandler`, with content as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过模块的 `install` 和 `upgrade` 脚本来实现的。如果我们快速查看 `setup/src/Magento/Setup/Model/Installer.php`
    文件，我们可以看到一个名为 `getSchemaDataHandler` 的函数，其内容如下：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is what tells Magento which classes to pick up and run from the individual
    module `Setup` directory. We will ignore the Recurring case for the moment, as
    only the `Magento_Indexer` module uses it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Magento 从单个模块的 `Setup` 目录中挑选和运行哪些类。目前我们将忽略重复的情况，因为只有 `Magento_Indexer` 模块使用它。
- en: 'For the first time, we run `php bin/magento setup:upgrade` against our module;
    while it still has no entries under the `setup_module` table, Magento will execute
    the files within the module `Setup` folder in following order:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行 `php bin/magento setup:upgrade` 命令针对我们的模块；尽管它仍然在 `setup_module` 表下没有条目，但
    Magento 将按照以下顺序执行模块 `Setup` 文件夹中的文件：
- en: '`InstallSchema.php`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InstallSchema.php`'
- en: '`UpgradeSchema.php`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpgradeSchema.php`'
- en: '`InstallData.php`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InstallData.php`'
- en: '`UpgradeData.php`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpgradeData.php`'
- en: Notice that this is the same order, top to bottom, as in the `getSchemaDataHandler`
    method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这与 `getSchemaDataHandler` 方法中从上到下的顺序相同。
- en: 'Every subsequent upper module version number change, followed by the console
    `php bin/magento setup:upgrade` command, would result in the following files being
    run in the order as listed:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每次后续模块版本号的变化，随后是控制台命令 `php bin/magento setup:upgrade`，都会导致以下文件按照列表中的顺序运行：
- en: '`UpgradeSchema.php`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpgradeSchema.php`'
- en: '`UpgradeData.php`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpgradeData.php`'
- en: Additionally, Magento would record the upped version number under the `setup_module`
    database. Magento will only trigger install or upgrade scripts when the version
    number in the database is less than the version number in the `module.xml` file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Magento 还会在 `setup_module` 数据库下记录升级后的版本号。只有当数据库中的版本号小于 `module.xml` 文件中的版本号时，Magento
    才会触发安装或升级脚本。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We are not required to always provide these install or upgrade scripts, if ever.
    They are only needed when we need to add or edit existing tables or entries in
    a database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们不必总是提供这些安装或升级脚本。只有在需要添加或编辑数据库中的现有表或条目时才需要它们。
- en: If we look carefully at the implementation of the `install` and `update` methods
    within the appropriate scripts, we can see they both accept `ModuleContextInterface
    $context` as a second parameter. Since upgrade scripts are the ones triggering
    on every upped version number, we can use `$context->getVersion()` to target changes
    specific to the module version.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细查看适当脚本中 `install` 和 `update` 方法的实现，我们可以看到它们都接受 `ModuleContextInterface
    $context` 作为第二个参数。由于升级脚本是在每次升级版本号时触发的，我们可以使用 `$context->getVersion()` 来针对特定于模块版本的更改。
- en: Creating an install schema script (InstallSchema.php)
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建安装模式脚本（InstallSchema.php）
- en: 'Now that we understand the flow of schema and data scripts and their relation
    to the module version number, let us go ahead and start assembling our `InstallSchema`.
    We start by defining the `app/code/Foggyline/Office/Setup/InstallSchema.php` file
    with (partial) content as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了模式和数据脚本及其与模块版本号的关系，让我们继续组装我们的 `InstallSchema`。我们首先定义 `app/code/Foggyline/Office/Setup/InstallSchema.php`
    文件，其（部分）内容如下：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`InstallSchema` conforms to `InstallSchemaInterface`, which requires the implementation
    of the `install` method that accepts two parameters of type `SchemaSetupInterface`
    and `ModuleContextInterface`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`InstallSchema` 遵循 `InstallSchemaInterface`，这要求实现接受两个类型为 `SchemaSetupInterface`
    和 `ModuleContextInterface` 的参数的 `install` 方法。'
- en: The install method is all that is required here. Within this method, we would
    add any relevant code we might have to create the tables and columns we need.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里只需要安装方法。在这个方法中，我们会添加任何可能需要的代码来创建所需的表和列。
- en: Looking through the code base, we can see that `Magento\Setup\Module\Setup`
    is the one extending `\Magento\Framework\Module\Setup` and implementing `SchemaSetupInterface`.
    The two methods seen in the preceding code, `startSetup` and `endSetup`, are used
    to run additional environment setup before and after our code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码库中查看，我们可以看到 `Magento\Setup\Module\Setup` 是扩展 `\Magento\Framework\Module\Setup`
    并实现 `SchemaSetupInterface` 的一个。前面代码中看到的两个方法 `startSetup` 和 `endSetup` 用于在我们代码之前和之后运行额外的环境设置。
- en: 'Going further, let''s replace the `/* #snippet1 */` bit with code that will
    create our `Department` model entity table as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '进一步来说，让我们将 `/* #snippet1 */` 部分替换为创建我们的 `Department` 模型实体表的代码，如下所示：'
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we are instructing Magento to create a table named `foggyline_office_department`,
    add `entity_id` and `name` columns to it, and set the comment on the table. Assuming
    we are using the MySQL server, when code executes, the following SQL gets executed
    in the database:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指示Magento创建一个名为`foggyline_office_department`的表，向其中添加`entity_id`和`name`列，并设置表的注释。假设我们使用的是MySQL服务器，当代码执行时，以下SQL将在数据库中执行：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `addColumn` method is the most interesting one here. It takes five parameters,
    from column name, column data type, column length, array of additional options,
    and column description. However, only column name and column data type are mandatory!
    Accepted column data types can be found under the `Magento\Framework\DB\Ddl\Table`
    class, and go as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`addColumn`方法是这里最有趣的一个。它接受五个参数，从列名、列数据类型、列长度、附加选项数组到列描述。然而，只有列名和列数据类型是必须的！可接受的列数据类型可以在`Magento\Framework\DB\Ddl\Table`类下找到，如下所示：'
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'An additional options array might contain some of the following keys: `unsigned`,
    `precision`, `scale`, `unsigned`, `default`, `nullable`, `primary`, `identity`,
    `auto_increment`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 附加选项数组可能包含以下一些键：`unsigned`、`precision`、`scale`、`unsigned`、`default`、`nullable`、`primary`、`identity`、`auto_increment`。
- en: 'Having gained insight into the `addColumn` method, let''s go ahead and create
    the `foggyline_office_employee_entity` table for the `Employee` entity as well.
    We do so by replacing the `/* #snippet2 */` bit from the preceding code with the
    following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '在了解了`addColumn`方法之后，让我们继续创建`foggyline_office_employee_entity`表，用于`Employee`实体。我们通过替换前面代码中的`/*
    #snippet2 */`部分来实现这一点：'
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Following good database design practices, we might notice one thing here. If
    we agree that every employee can be assigned a single department, we should add
    a foreign key to this table's `department_id` column. For the moment, we will
    purposely skip this bit, as we want to demonstrate this through the update schema
    script later on.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 根据良好的数据库设计实践，我们可能会注意到这里的一个问题。如果我们同意每个员工可以分配一个单一的部门，我们应该向该表的`department_id`列添加一个外键。目前，我们将故意跳过这一部分，因为我们想通过稍后的更新模式脚本来演示这一点。
- en: EAV models scatter their data across several tables, three at a minimum. The
    table `foggyline_office_employee_entity` that we just created is one of them.
    The other one is the core Magento `eav_attribute` table. The third table is not
    a single table, rather a list of multiple tables; one for each EAV type. These
    tables are the result of our install script.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: EAV模型将数据分散在多个表中，至少有三个。我们刚刚创建的`foggyline_office_employee_entity`表就是其中之一。另一个是核心的Magento
    `eav_attribute`表。第三个表不是一个单独的表，而是一系列多个表；每个EAV类型一个表。这些表是我们安装脚本的结果。
- en: Information stored within the core Magento `eav_attribute` table is not the
    value of an attribute or anything like it; information stored there is an attribute's
    metadata. So how does Magento know about our `Employee` attributes (`service_years`,
    `dob`, `salary`, `vat_number`, `note`)? It does not; not yet. We need to add the
    attributes into that table ourselves. We will do so later on, as we demonstrate
    the `InstallData`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在核心Magento `eav_attribute`表中的信息不是属性值或类似的东西；存储在那里的信息是属性的元数据。那么，Magento是如何知道我们的`Employee`属性（`service_years`、`dob`、`salary`、`vat_number`、`note`）的呢？它不知道；还没有。我们需要自己将属性添加到该表中。我们将在稍后通过`InstallData`演示这样做。
- en: 'Depending on the EAV attribute data type, we need to create the following tables:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 根据EAV属性数据类型，我们需要创建以下表：
- en: '`foggyline_office_employee_entity_datetime`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foggyline_office_employee_entity_datetime`'
- en: '`foggyline_office_employee_entity_decimal`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foggyline_office_employee_entity_decimal`'
- en: '`foggyline_office_employee_entity_int`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foggyline_office_employee_entity_int`'
- en: '`foggyline_office_employee_entity_text`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foggyline_office_employee_entity_text`'
- en: '`foggyline_office_employee_entity_varchar`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foggyline_office_employee_entity_varchar`'
- en: The names of these attribute value tables come from a simple formula, which
    says *{name of the entity table}+{_}+{eav_attribute.backend_type value}*. If we
    look at the salary attribute, we need it to be a decimal value, thus it will get
    stored in `foggyline_office_employee_entity_decimal`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性值表的名字来自一个简单的公式，即*{实体表名称}+{_}+{eav_attribute.backend_type值}*。如果我们看`salary`属性，我们需要它是一个小数值，因此它将被存储在`foggyline_office_employee_entity_decimal`中。
- en: 'Given the chunkiness of code behind defining attribute value tables, we will
    focus only on a single, decimal type table. We define it by replacing `/* #snippet3
    */` from the preceding code with the following bit:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '由于定义属性值表背后的代码量很大，我们将只关注一个单一的小数类型表。我们通过替换前面代码中的`/* #snippet3 */`部分来实现这一点：'
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice the `//->addIndex` part within code above. Lets replace it with the following
    bit.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上述代码中的 `//->addIndex` 部分。让我们将其替换为以下内容。
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code adds three indexes on the `foggyline_office_employee_entity_decimal`
    table, resulting in a SQL as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在 `foggyline_office_employee_entity_decimal` 表上添加了三个索引，结果生成以下 SQL：
- en: '`UNIQUE KEY ''FOGGYLINE_OFFICE_EMPLOYEE_ENTT_DEC_ENTT_ID_ATTR_ID_STORE_ID''
    (''entity_id'',''attribute_id'',''store_id'')`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNIQUE KEY ''FOGGYLINE_OFFICE_EMPLOYEE_ENTT_DEC_ENTT_ID_ATTR_ID_STORE_ID''
    (''entity_id'',''attribute_id'',''store_id'')`'
- en: '`KEY ''FOGGYLINE_OFFICE_EMPLOYEE_ENTITY_DECIMAL_STORE_ID'' (''store_id'')`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEY ''FOGGYLINE_OFFICE_EMPLOYEE_ENTITY_DECIMAL_STORE_ID'' (''store_id'')`'
- en: '`KEY ''FOGGYLINE_OFFICE_EMPLOYEE_ENTITY_DECIMAL_ATTRIBUTE_ID'' (''attribute_id'')`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEY ''FOGGYLINE_OFFICE_EMPLOYEE_ENTITY_DECIMAL_ATTRIBUTE_ID'' (''attribute_id'')`'
- en: 'Similarly, we replace the `//->addForeignKey` part from the preceding code
    with the following bit:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将前面代码中的 `//->addForeignKey` 部分替换为以下内容：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code adds foreign key relations into the `foggyline_office_employee_entity_decimal`
    table, resulting in a SQL as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将外键关系添加到 `foggyline_office_employee_entity_decimal` 表中，结果生成以下 SQL：
- en: '`CONSTRAINT ''FK_D17982EDA1846BAA1F40E30694993801'' FOREIGN KEY (''entity_id'')
    REFERENCES ''foggyline_office_employee_entity'' (''entity_id'') ON DELETE CASCADE,`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONSTRAINT ''FK_D17982EDA1846BAA1F40E30694993801'' FOREIGN KEY (''entity_id'')
    REFERENCES ''foggyline_office_employee_entity'' (''entity_id'') ON DELETE CASCADE,`'
- en: '`CONSTRAINT ''FOGGYLINE_OFFICE_EMPLOYEE_ENTITY_DECIMAL_STORE_ID_STORE_STORE_ID''
    FOREIGN KEY (''store_id'') REFERENCES ''store'' (''store_id'') ON DELETE CASCADE,`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONSTRAINT ''FOGGYLINE_OFFICE_EMPLOYEE_ENTITY_DECIMAL_STORE_ID_STORE_STORE_ID''
    FOREIGN KEY (''store_id'') REFERENCES ''store'' (''store_id'') ON DELETE CASCADE,`'
- en: '`CONSTRAINT ''FOGGYLINE_OFFICE_EMPLOYEE_ENTT_DEC_ATTR_ID_EAV_ATTR_ATTR_ID''
    FOREIGN KEY (''attribute_id'') REFERENCES ''eav_attribute'' (''attribute_id'')
    ON DELETE CASCADE`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONSTRAINT ''FOGGYLINE_OFFICE_EMPLOYEE_ENTT_DEC_ATTR_ID_EAV_ATTR_ATTR_ID''
    FOREIGN KEY (''attribute_id'') REFERENCES ''eav_attribute'' (''attribute_id'')
    ON DELETE CASCADE`'
- en: Notice how we added the `store_id` column to our EAV attribute value tables.
    Though our examples won't find use of it, it is a good practice to use `store_id`
    with your EAV entities to scope the data for a possible multi-store setup. To
    clarify further, imagine we had a multi-store setup, and with EAV attribute tables
    set up like the preceding one, we would be able to store a different attribute
    value for each store, since the unique entry in the table is defined as a combination
    of `entity_id`, `attribute_id`, and `store_id` columns.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何将 `store_id` 列添加到我们的 EAV 属性值表中。尽管我们的示例不会使用它，但使用 `store_id` 与 EAV 实体一起定义数据范围是一个好习惯。为了进一步说明，想象我们有一个多店铺设置，并且像前面的
    EAV 属性表那样设置，我们就能为每个店铺存储不同的属性值，因为表中的唯一条目定义为 `entity_id`、`attribute_id` 和 `store_id`
    列的组合。
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For the reasons of performance and data integrity, it is important to define
    indexes and foreign key as per good database design practice. We can do so within
    `InstallSchema` when defining new tables.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了性能和数据完整性的原因，根据良好的数据库设计实践定义索引和外键非常重要。我们可以在定义新表时在 `InstallSchema` 中这样做。
- en: Creating an upgrade schema script (UpgradeSchema.php)
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建升级模式脚本（UpgradeSchema.php）
- en: 'During the first-time module install, an upgrade schema is what gets run immediately
    after an install schema. We define upgrade schema within the `app/code/Foggyline/Office/Setup/UpgradeSchema.php`
    file with (partial) content as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次模块安装期间，安装模式之后立即运行升级模式。我们在 `app/code/Foggyline/Office/Setup/UpgradeSchema.php`
    文件中定义升级模式，其部分内容如下：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`UpgradeSchema` conforms to `UpgradeSchemaInterface`, which requires the implementation
    of the `upgrade` method that accepts two parameters of type `SchemaSetupInterface`
    and `ModuleContextInterface`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpgradeSchema` 遵循 `UpgradeSchemaInterface`，这要求实现接受两个参数 `SchemaSetupInterface`
    和 `ModuleContextInterface` 的 `upgrade` 方法。'
- en: This is quite similar to `InstallSchemaInterface`, except the method name. The
    `update` method is run when this schema gets triggered. Within this method, we
    would add any relevant code we might want to execute.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `InstallSchemaInterface` 非常相似，除了方法名。当此模式被触发时，会运行 `update` 方法。在这个方法中，我们会添加任何我们可能想要执行的代码。
- en: 'Going further, let''s replace the `/* #snippet1 */` part from the preceding
    code with the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '进一步来说，让我们将前面代码中的 `/* #snippet1 */` 部分替换为以下代码：'
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we are instructing Magento to create a foreign key on the `foggyline_office_employee_entity`
    table, more precisely on its `department_id` column, pointing to the `foggyline_office_department`
    table and its `entity_id` column.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指示 Magento 在 `foggyline_office_employee_entity` 表上创建一个外键，更确切地说是在其 `department_id`
    列上，指向 `foggyline_office_department` 表及其 `entity_id` 列。
- en: Creating an install data script (InstallData.php)
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建安装数据脚本（InstallData.php）
- en: 'An install data script is what gets run immediately after upgrade schema. We
    define install data schema within the `app/code/Foggyline/Office/Setup/InstallData.php`
    file with (partial) content as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 安装数据脚本是在升级架构后立即运行的。我们在`app/code/Foggyline/Office/Setup/InstallData.php`文件中定义安装数据架构，其内容如下（部分）：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`InstallData` conforms to `InstallDataInterface`, which requires the implementation
    of the `install` method that accepts two parameters of type `ModuleDataSetupInterface`
    and `ModuleContextInterface`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`InstallData`符合`InstallDataInterface`，这要求实现接受两个类型为`ModuleDataSetupInterface`和`ModuleContextInterface`的参数的`install`方法。'
- en: The `install` method is run when this script gets triggered. Within this method,
    we would add any relevant code we might want to execute.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当此脚本被触发时，将运行`install`方法。在这个方法中，我们会添加任何可能想要执行的代码。
- en: 'Going further, let''s replace the `/* #snippet1 */` part from the preceding
    code with the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '进一步来说，让我们用以下代码替换前面代码中的`/* #snippet1 */`部分：'
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using the `addAttribute` method on the instance of `\Foggyline\Office\Setup\EmployeeSetupFactory`,
    we are instructing Magento to add a number of attributes (`service_years`, `dob`,
    `salary`, `vat_number`, `note`) to its entity.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`\Foggyline\Office\Setup\EmployeeSetupFactory`实例上的`addAttribute`方法，我们指示Magento向其实体添加多个属性（`service_years`、`dob`、`salary`、`vat_number`、`note`）。
- en: 'We will soon get to the inners of `EmployeeSetupFactory`, but right now notice
    the call to the `addAttribute` method. Within this method, there is a call to
    the `$this->attributeMapper->map($attr, $entityTypeId)` method. `attributeMapper`
    conforms to `Magento\Eav\Model\Entity\Setup\PropertyMapperInterface`, which looking
    at `vendor/magento/module-eav/etc/di.xml` has a preference for the `Magento\Eav\Model\Entity\Setup\PropertyMapper\Composite`
    class, which further initializes the following mapper classes:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会进入`EmployeeSetupFactory`的内部，但现在请注意对`addAttribute`方法的调用。在这个方法中，有一个对`$this->attributeMapper->map($attr,
    $entityTypeId)`方法的调用。`attributeMapper`符合`Magento\Eav\Model\Entity\Setup\PropertyMapperInterface`，查看`vendor/magento/module-eav/etc/di.xml`，它对`Magento\Eav\Model\Entity\Setup\PropertyMapper\Composite`类有优先权，该类进一步初始化以下映射类：
- en: '`Magento\Eav\Model\Entity\Setup\PropertyMapper`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Magento\Eav\Model\Entity\Setup\PropertyMapper`'
- en: '`Magento\Customer\Model\ResourceModel\Setup\PropertyMapper`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Magento\Customer\Model\ResourceModel\Setup\PropertyMapper`'
- en: '`Magento\Catalog\Model\ResourceModel\Setup\PropertyMapper`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Magento\Catalog\Model\ResourceModel\Setup\PropertyMapper`'
- en: '`Magento\ConfigurableProduct\Model\ResourceModel\Setup\PropertyMapper`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Magento\ConfigurableProduct\Model\ResourceModel\Setup\PropertyMapper`'
- en: 'Since we are defining our own entity types, the mapper class we are mostly
    interested in is `Magento\Eav\Model\Entity\Setup\PropertyMapper`. A quick look
    inside of it reveals the following mapping array in the `map` method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在定义自己的实体类型，我们主要感兴趣的映射类是`Magento\Eav\Model\Entity\Setup\PropertyMapper`。快速查看它，我们发现`map`方法中的以下映射数组：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Looking at the preceding array keys and value strings gives us a clue as to
    what is happening. The key strings match the column names in the `eav_attribute`
    table, while the value strings match the keys of our array passed to the `addAttribute`
    method within `InstallData.php`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看前面的数组键和值字符串，我们可以了解正在发生的事情。键字符串与`eav_attribute`表中的列名匹配，而值字符串与我们在`InstallData.php`中通过`addAttribute`方法传递给数组的键匹配。
- en: 'Let''s take a look at the `EmployeeSetupFactory` class within the `app/code/Foggyline/Office/Setup/EmployeeSetup.php`
    file, (partially) defined as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`app/code/Foggyline/Office/Setup/EmployeeSetup.php`文件中的`EmployeeSetupFactory`类，其定义如下（部分）：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'What''s happening here is that we are extending from the Magento\Eav\Setup\EavSetup
    class, thus effectively telling Magento we are about to create our own entity.
    We do so by overriding `getDefaultEntities`, replacing `/* #snippet1 */` with
    content as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '这里发生的事情是我们从`Magento\Eav\Setup\EavSetup`类扩展，从而有效地告诉Magento我们即将创建自己的实体。我们通过重写`getDefaultEntities`，用以下内容替换`/*
    #snippet1 */`来实现这一点：'
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `getDefaultEntities` method returns an array of entities we want to register
    with Magento. Within our `$entities` array, the key `$employeeEntity` becomes
    an entry in the `eav_entity_type` table. Given that our `$employeeEntity` has
    a value of `foggyline_office_employee`, running the following SQL query should
    yield a result:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDefaultEntities`方法返回一个我们想要与Magento注册的实体数组。在我们的`$entities`数组中，键`$employeeEntity`成为`eav_entity_type`表中的一个条目。鉴于我们的`$employeeEntity`的值为`foggyline_office_employee`，运行以下SQL查询应该会产生结果：'
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Only a handful of metadata values are required to make our new entity type functional.
    The `entity_model` value should point to our EAV model `resource` class, not the
    `model` class. The table value should equal the name of our EAV entity table in
    the database. Finally, the attributes array should list any attribute we want
    created on this entity. Attributes and their metadata get created in the `eav_attribute`
    table.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的新实体类型能够正常工作，只需要少量元数据值。`entity_model` 值应指向我们的 EAV 模型 `resource` 类，而不是 `model`
    类。表值应等于数据库中我们的 EAV 实体表名称。最后，属性数组应列出我们想要在此实体上创建的任何属性。属性及其元数据在 `eav_attribute` 表中创建。
- en: If we look back at all those `foggyline_office_employee_entity_*` attribute
    value tables we created, they are not the ones that actually create attributes
    or register a new entity type in Magento. What creates attributes and a new entity
    type is the array we just defined under the `getDefaultEntities` method. Once
    Magento creates the attributes and registers a new entity type, it simply routes
    the entity save process to proper attribute value tables depending on the type
    of attribute.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下我们创建的所有那些 `foggyline_office_employee_entity_*` 属性值表，它们并不是真正创建属性或注册新实体类型的。创建属性和新实体类型的是我们在
    `getDefaultEntities` 方法下定义的数组。一旦 Magento 创建了属性并注册了新实体类型，它就会将实体保存过程路由到适当的属性值表，具体取决于属性类型。
- en: Creating an upgrade data script (UpgradeData.php)
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建升级数据脚本（UpgradeData.php）
- en: The upgrade data script is the last one to execute. We will use it to demonstrate
    the example of creating the sample entries for our `Department` and `Employee`
    entities.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 升级数据脚本是在最后执行的。我们将使用它来演示为我们的 `Department` 和 `Employee` 实体创建示例条目的示例。
- en: 'We start by creating the `app/code/Foggyline/Office/Setup/UpgradeData.php`
    file with (partial) content as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建 `app/code/Foggyline/Office/Setup/UpgradeData.php` 文件，其（部分）内容如下：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`UpgradeData` conforms to `UpgradeDataInterface`, which requires the implementation
    of the upgrade method that accepts two parameters of type `ModuleDataSetupInterface`
    and `ModuleContextInterface`. We are further adding our own `__construct` method
    to which we are passing `DepartmentFactory` and `EmployeeFactory`, as we will
    be using them within the upgrade method as shown next, by replacing `/* #snippet1
    */` with the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpgradeData` 遵循 `UpgradeDataInterface`，该接口要求实现接受两个参数（类型为 `ModuleDataSetupInterface`
    和 `ModuleContextInterface`）的升级方法。我们进一步添加了自己的 `__construct` 方法，将 `DepartmentFactory`
    和 `EmployeeFactory` 传递给它，因为我们将在下一个示例中在升级方法中使用它们，通过将 `/* #snippet1 */` 替换为以下代码：'
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code creates an instance of the department entity and then saves
    it. An instance of employee is then created and saved, passing it the newly created
    department ID and other attributes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个部门实体的实例并将其保存。然后创建了一个员工实例并保存，传递给它新创建的部门 ID 和其他属性。
- en: Tip
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'A more convenient and professional-looking approach for saving an entity could
    be given as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 保存实体的一种更方便、更专业的做法可以是以下这样：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we are utilizing the fact that each of the entity setter methods returns
    `$this` (an instance of the entity object itself), so we can chain the method
    calls.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用了每个实体设置方法都返回 `$this`（实体对象本身的实例）的事实，因此我们可以链式调用方法。
- en: Entity CRUD actions
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体 CRUD 操作
- en: Up to this point, we have learned how to create a simple model, an EAV model,
    and install and upgrade types of schema and data script. Now, let us see how we
    can create, read, update and delete our entities, operations that are commonly
    referred to as CRUD.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何创建一个简单的模型、一个 EAV 模型，以及安装和升级类型的数据脚本。现在，让我们看看我们如何创建、读取、更新和删除我们的实体，这些操作通常被称为
    CRUD。
- en: Though this chapter is about models, collections, and related things, for the
    purpose of demonstration, let's make a tiny detour into routes and controllers.
    The idea is to create a simple `Test` controller with the `Crud` action we can
    trigger in the browser via a URL. Within this `Crud` action, we will then dump
    our CRUD-related code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这一章是关于模型、集合和相关内容的，但为了演示的目的，让我们稍微偏离一下路由和控制器。想法是创建一个简单的 `Test` 控制器，我们可以通过 URL
    触发其 `Crud` 动作。然后，在 `Crud` 动作中，我们将输出我们的 CRUD 相关代码。
- en: 'To make Magento respond to the URL we punch into the browser, we need to define
    the route. We do so by creating the `app/code/Foggyline/Office/etc/frontend/routes.xml`
    file with the following content:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 Magento 对应于我们在浏览器中输入的 URL，我们需要定义路由。我们通过创建包含以下内容的 `app/code/Foggyline/Office/etc/frontend/routes.xml`
    文件来实现：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Route definition requires a unique ID and `frontName` attribute values, which
    in our case both equal `foggyline_office`. The `frontName` attribute value becomes
    the part of our URL structure. Simply put, the URL formula for hitting the `Crud`
    action goes like *{magento-base-url}/index.php/{route frontName}/{controller name}/{action
    name}*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 路由定义需要唯一的ID和`frontName`属性值，在我们的案例中这两个都等于`foggyline_office`。`frontName`属性值成为我们URL结构的一部分。简单来说，访问`Crud`操作的URL公式如下：*{magento-base-url}/index.php/{route
    frontName}/{controller name}/{action name}*
- en: Note
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For example, if our base URL were `http://shop.loc/`, the full URL would be
    `http://shop.loc/index.php/foggyline_office/test/crud/`. If we have URL rewrites
    turned on, we could omit the `index.php` part.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的基础URL是`http://shop.loc/`，完整的URL将是`http://shop.loc/index.php/foggyline_office/test/crud/`。如果我们启用了URL重写，我们可以省略`index.php`部分。
- en: 'Once the route has been defined, we can go ahead and create the `Test` controller,
    defined in the `app/code/Foggyline/Office/Controller/Test.php` file with (partial)
    code as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了路由，我们就可以继续创建`Test`控制器，它在`app/code/Foggyline/Office/Controller/Test.php`文件中定义（部分）代码如下：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This really is the simplest controller we could have defined. The only thing
    worth noting here is that the controller class needs to be defined as abstract
    and extend the `\Magento\Framework\App\Action\Action` class. Controller actions
    live outside of the controller itself and can be found under the subdirectory
    on the same level and named as controller. Since our controller is called `Test`,
    we place our `Crud` action under the `app/code/Foggyline/Office/Controller/Test/Crud.php`
    file with content as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的是我们能够定义的最简单的控制器。这里唯一值得注意的事情是，控制器类需要定义为抽象类，并扩展`\Magento\Framework\App\Action\Action`类。控制器动作位于控制器外部，可以在同一级别的子目录下找到，命名为控制器。由于我们的控制器名为`Test`，我们将我们的`Crud`动作放在`app/code/Foggyline/Office/Controller/Test/Crud.php`文件中，内容如下：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `Controller` action class is basically just an extension of the controller
    defining the `execute` method. Code within the execute method is what gets run
    when we hit the URL in the browser. Additionally, we have a `__construct` method
    to which we are passing the `EmployeeFactory` and `DepartmentFactory` classes,
    which we will soon use for our CRUD examples. Note that `EmployeeFactory` and
    `DepartmentFactory` are not classes created by us. Magento will autogenerate them
    under the `DepartmentFactory.php` and `EmployeeFactory.php` files within the `var/generation/Foggyline/Office/Model`
    folder. These are factory classes for our `Employee` and `Department` model classes,
    generated when requested.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Controller`动作类基本上是控制器定义`execute`方法的扩展。当我们在浏览器中点击URL时，会运行`execute`方法中的代码。此外，我们还有一个`__construct`方法，我们将`EmployeeFactory`和`DepartmentFactory`类传递给它，我们将在我们的CRUD示例中使用这些类。请注意，`EmployeeFactory`和`DepartmentFactory`不是我们创建的类。Magento将在`var/generation/Foggyline/Office/Model`文件夹中的`DepartmentFactory.php`和`EmployeeFactory.php`文件下自动生成它们。这些是我们`Employee`和`Department`模型类的工厂类，在请求时生成。'
- en: With this, we finish our little detour and focus back on our entities.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就结束了这个小插曲，重新关注我们的实体。
- en: Creating new entities
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新实体
- en: 'There are three different flavors, if we might call them that, by which we
    can set property (field and attribute) values on our entity. They all lead to
    the same result. The following few code snippets can be copied and pasted into
    our `Crud` class `execute` method for testing, simply by replacing `/* CRUD Code
    Here */` with one of the following code snippets:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以称它们为不同的风味，我们有三种方式可以设置实体（字段和属性）的属性值。它们都会产生相同的结果。以下几个代码片段可以复制粘贴到我们的`Crud`类的`execute`方法中进行测试，只需将`/*
    CRUD Code Here */`替换为以下代码片段之一：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `flavour #1` approach from the preceding code is probably the preferred
    way of setting properties, as it is using the magic method approach we mentioned
    previously. Both `flavour #2` and `flavour #3` use the `setData` method, just
    in a slightly different manner. All three examples should yield the same result
    once the `save` method is called on an `object` instance.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '前面代码中的`flavour #1`方法可能是设置属性的首选方式，因为它使用了我们之前提到的魔术方法方法。`flavour #2`和`flavour
    #3`都使用了`setData`方法，只是方式略有不同。一旦在`object`实例上调用`save`方法，这三个示例都应该产生相同的结果。'
- en: 'Now that we know how to save the simple model, let''s take a quick look at
    doing the same with the EAV model. The following are analogous code snippets:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何保存简单的模型，让我们快速看一下如何使用EAV模型做同样的事情。以下是对应的代码片段：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As we can see, the EAV code for persisting the data is identical to the simple
    model. There is one thing here worth noting. The `Employee` entity has a relation
    defined toward department. Forgetting to specify `department_id` on a new `employee`
    entity save would result in an error message similar to the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，用于持久化数据的EAV代码与简单模型相同。这里有一件事值得注意。`Employee`实体定义了一个指向部门的关联。忘记在新的`employee`实体保存时指定`department_id`会导致类似于以下错误信息的错误：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Magento saves these types of errors under its `var/report` directory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Magento将其中的这些类型错误保存在其`var/report`目录下。
- en: Reading existing entities
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取现有实体
- en: 'Reading an entity based on a provided entity ID value comes down to instantiating
    the entity and using the load method to which we pass the entity ID as shown next:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 根据提供的实体ID值读取实体归结为实例化实体，并使用传递实体ID的`load`方法，如下所示：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There is no real difference between loading the simple model or EAV model,
    as shown in the following EAV model example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，加载简单模型或EAV模型之间实际上没有真正的区别：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice how the EAV entity loads all of its field and attribute values, which
    is not always the case when we obtain the entity through EAV collection, as we
    will show later on.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到EAV实体加载了所有的字段和属性值，这在我们通过EAV集合获取实体时并不总是如此，我们将在稍后展示。
- en: Updating existing entities
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新现有实体
- en: 'Updating entities comes down to using the `load` method to read an existing
    entity, reset its value, and calling the `save` method in the end, like shown
    in the following example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 更新实体归结为使用`load`方法读取现有实体，重置其值，并在最后调用`save`方法，如下例所示：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Regardless of the entity being the simple model or an EAV, the code is the same.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 无论实体是简单模型还是EAV，代码都是相同的。
- en: Deleting existing entities
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除现有实体
- en: 'Calling the `delete` method on a loaded entity will delete the entity from
    the database or throw `Exception` if it fails. Code to delete the entity looks
    as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在已加载的实体上调用`delete`方法将删除该实体从数据库中，或者在失败时抛出`Exception`。删除实体的代码如下所示：
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There is no difference in deleting the simple and EAV entities. We should always
    use try/catch blocks when deleting or saving our entities.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 删除简单实体和EAV实体之间没有区别。我们在删除或保存实体时应该始终使用try/catch块。
- en: Managing collections
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理集合
- en: 'Let''s start with EAV model collections. We can instantiate the collection
    either through the entity `factory` class like follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从EAV模型集合开始。我们可以通过以下方式通过实体`factory`类实例化集合：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Or we can use object manager to instantiate the collection as shown next:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用对象管理器来实例化集合，如下所示：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There is also a third way, which might be the preferred one, but it requires
    us to define APIs so we will skip that one for the moment.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第三种方法，这可能是一个更受欢迎的方法，但它要求我们定义API，所以我们暂时跳过这个方法。
- en: 'Once we instantiate the collection object, we can loop through it and do some
    variable dumps to see the content on individual `$employee` entities, like shown
    next:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们实例化了集合对象，我们就可以遍历它并对单个`$employee`实体进行一些变量转储，以查看其内容，如下所示：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding would yield results like the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的操作会产生如下结果：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice how the individual `$employee` only has fields on it, not the attributes.
    Let''s see what happens when we want to extend our collection by using `addAttributeToSelect`
    to specify the individual attributes to add to it, like shown next:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到单个`$employee`只有字段，没有属性。让我们看看当我们想要通过使用`addAttributeToSelect`来指定要添加到集合中的单个属性时会发生什么，如下所示：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding would yield results like the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的操作会产生如下结果：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Though we are making progress, imagine if we had tens of attributes, and we
    want each and every one to be included into collection. Using `addAttributeToSelect`
    numerous times would make for cluttered code. What we can do is pass `''*''` as
    a parameter to `addAttributeToSelect` and have collection pick up every attribute,
    as shown next:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在取得进步，但想象一下如果我们有数十个属性，并且我们希望每个属性都包含在集合中。多次使用`addAttributeToSelect`会导致代码杂乱。我们可以通过将`'*'`作为参数传递给`addAttributeToSelect`，让集合获取每个属性，如下所示：
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This would yield results like the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生如下结果：
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Though the PHP part of the code looks seemingly simple, what''s happening in
    the background on the SQL layer is relatively complex. Though Magento executes
    several SQL queries prior to fetching the final collection result, let''s focus
    on the last three queries as shown next:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码的 PHP 部分看起来似乎很简单，但在 SQL 层面上发生的事情相对复杂。虽然 Magento 在获取最终集合结果之前执行了几个 SQL 查询，但让我们关注下面显示的最后三个查询：
- en: '[PRE47]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before we proceed any further, it is important to know that these queries are
    not copy and paste applicable. The reason is that the `attribute_id` values will
    for sure differ from installation to installation. Queries given here are for
    us to gain a high-level understanding of what is happening in the backend on the
    SQL layer when we use Magento collections on the PHP application level.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，了解这些查询不能直接复制粘贴是很重要的。原因是 `attribute_id` 值肯定会在不同的安装中有所不同。这里给出的查询是为了让我们在
    PHP 应用程序级别使用 Magento 集合时，在 SQL 层面上获得对后台发生的事情的高级理解。
- en: 'The first query select simply counts the number of entries in the entity table,
    and then passes that info to the application layer. The second select fetches
    all entries from `foggyline_office_employee_entity`, then passes that info to
    the application layer to use it to pass entity IDs in the third query as part
    of `entity_id IN (24, 25, 26)`. Second and third queries here can be pretty resource
    intense if we have a large amount of entries in our entity and EAV tables. To
    prevent possible performance bottlenecks, we should always use the `setPageSize`
    and `setCurPage` methods on collection, like shown next:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个查询只是简单地计算实体表中的条目数量，然后将这个信息传递到应用层。第二个查询从 `foggyline_office_employee_entity`
    中检索所有条目，然后将这些信息传递到应用层，以便在第三个查询中将实体 ID 作为 `entity_id IN (24, 25, 26)` 的一部分传递。如果我们的实体和
    EAV 表中有大量条目，这里的第二个和第三个查询可能会非常消耗资源。为了防止可能出现的性能瓶颈，我们应该始终在集合上使用 `setPageSize` 和 `setCurPage`
    方法，如下所示：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This would result in the first `COUNT` query still being the same, but the
    second query would now look like the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致第一个 `COUNT` 查询仍然保持不变，但第二个查询现在看起来如下所示：
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This makes for a much smaller, thus performance-lighter dataset if we have thousands
    or tens of thousands of entries. The point here is to always use `setPageSize`
    and `setCurPage`. If we need to work with a really large set, then we need to
    page through it, or walk through it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有成千上万或数万条条目，这将使得数据集更小，从而性能更轻。这里的要点是始终使用 `setPageSize` 和 `setCurPage`。如果我们需要处理一个非常大的集合，那么我们需要分页浏览它，或者逐个遍历它。
- en: Now we know how to limit the size of the result set and fetch the proper page,
    let's see how we can further filter the set to avoid overusing PHP loops for the
    same purpose. Thus effectively passing the filtering to the database and not the
    application layer. To filter the EAV collection, we use its `addAttributeToFilter`
    method.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何限制结果集的大小并获取正确的页面，让我们看看我们如何进一步过滤集合以避免过度使用 PHP 循环来完成同样的目的。因此，有效地将过滤传递到数据库而不是应用层。为了过滤
    EAV 集合，我们使用它的 `addAttributeToFilter` 方法。
- en: 'Let''s instantiate a clean new collection like shown next:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实例化一个干净的新集合，如下所示：
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notice that we are now using the `addAttributeToSelect` and `addAttributeToFilter`
    methods on collection. We have already seen the database impact of `addAttributeToSelect`
    on a SQL query. What `addAttributeToFilter` does is something completely different.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们现在正在集合上使用 `addAttributeToSelect` 和 `addAttributeToFilter` 方法。我们已经看到了 `addAttributeToSelect`
    对 SQL 查询的数据库影响。`addAttributeToFilter` 做的事情则完全不同。
- en: 'With the `addAttributeToFilter` method, the count query now gets transformed
    into the following SQL query:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `addAttributeToFilter` 方法，计数查询现在被转换成以下 SQL 查询：
- en: '[PRE51]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can see that this is much more complex than the previous count query, now
    we have `INNER JOIN` stepping in. Notice how we have four `addAttributeToFilter`
    method calls but only three `INNER JOIN`. This is because one of those four calls
    is for e-mail, which is not an attribute but a field within the `foggyline_office_employee_entity`
    table. That is why there is no need for `INNER JOIN` as the field is already there.
    The three `INNER JOIN` then simply merge the required info into the query in order
    to get the select.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这比之前的计数查询要复杂得多，现在有 `INNER JOIN` 介入。注意我们如何有四个 `addAttributeToFilter` 方法调用，但只有三个
    `INNER JOIN`。这是因为其中四个调用之一是用于电子邮件的，它不是一个属性，而是 `foggyline_office_employee_entity`
    表中的一个字段。这就是为什么不需要 `INNER JOIN`，因为该字段已经存在。然后三个 `INNER JOIN` 简单地将所需信息合并到查询中，以获取选择。
- en: 'The second query also becomes more robust, as shown next:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个查询也变得更加健壮，如下所示：
- en: '[PRE52]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we also see the usage of `INNER JOIN`. We also have three and not four
    `INNER JOIN`, because one of the conditions is done against `email`, which is
    a field. The result of the query is a flattened piece of rows where the attributes
    `vat_number`, `salary`, and `service_years` are present. We can imagine the performance
    impact if we haven't used `setPageSize` to limit the result set.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们还可以看到 `INNER JOIN` 的使用。我们也有三个而不是四个 `INNER JOIN`，因为其中一个条件是对 `email` 字段的。查询的结果是一个扁平化的行块，其中包含
    `vat_number`、`salary` 和 `service_years` 等属性。我们可以想象如果没有使用 `setPageSize` 限制结果集，性能会受到怎样的影响。
- en: 'Finally, the third query is also affected and now looks similar to the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第三个查询也受到影响，现在看起来类似于以下内容：
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice here how `UNION ALL` has been reduced to a single occurrence now, thus
    effectively making for two selects. This is because we have a total of five attributes
    (`service_years`, `dob`, `salary`, `vat_number`, `note`), and three of them have
    been pulled in through second query. Out of the preceding three queries demonstrated,
    Magento basically pulls the collection data from second and third query. This
    seems like a pretty optimized and scalable solution, though we should really give
    it some thought on the proper use of `setPageSize`, `addAttributeToSelect`, and
    `addAttributeToFilter` methods when creating collection.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里 `UNION ALL` 已经减少到单个出现，从而有效地形成了两个选择。这是因为我们总共有五个属性（`service_years`、`dob`、`salary`、`vat_number`、`note`），其中三个是通过第二个查询获取的。在前面的三个查询示例中，Magento
    主要从第二个和第三个查询中提取集合数据。这看起来像是一个相当优化和可扩展的解决方案，尽管我们真的应该仔细思考在创建集合时正确使用 `setPageSize`、`addAttributeToSelect`
    和 `addAttributeToFilter` 方法。
- en: During development, if working with collections that have lot of attributes,
    filters, and possibly a future large dataset, we might want to use SQL logging
    to record actual SQL queries hitting the database server. This might help us spot
    possible performance bottlenecks and react on time, either by adding more limiting
    values to `setPageSize` or `addAttributeToSelect`, or both.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，如果正在处理具有大量属性、过滤器和可能的大型数据集的集合，我们可能希望使用 SQL 日志记录实际击中数据库服务器的 SQL 查询。这可能会帮助我们及时发现可能的性能瓶颈并及时做出反应，无论是通过向
    `setPageSize` 或 `addAttributeToSelect` 添加更多限制值，还是两者都添加。
- en: 'In the preceding examples, the use of `addAttributeToSelect` results in `AND`
    conditions on the SQL layer. What if we want to filter collection using `OR` conditions?
    `addAttributeToSelect` can also result in SQL `OR` conditions if the `$attribute`
    parameter is used in the following way:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，使用 `addAttributeToSelect` 导致 SQL 层上的 `AND` 条件。如果我们想使用 `OR` 条件来过滤集合怎么办？如果
    `$attribute` 参数以以下方式使用，`addAttributeToSelect` 也可以导致 SQL `OR` 条件：
- en: '[PRE54]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Without going into the details of actual SQL queries this time, it is suffice
    to say that they are near identical to the previous example with the `AND` condition
    use of `addAttributeToFilter`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这次不深入实际 SQL 查询的细节，只需说它们几乎与之前的示例相同，使用了 `addAttributeToFilter` 的 `AND` 条件。
- en: Using collection methods like `addExpressionAttributeToSelect`, `groupByAttribute`,
    and `addAttributeToSort`, collections offer further gradient filtering and even
    shift some calculations from the PHP application layer to the SQL layer. Getting
    into the ins and outs of those and other collection methods is beyond the scope
    of this chapter, and would probably require a book on its own.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `addExpressionAttributeToSelect`、`groupByAttribute` 和 `addAttributeToSort`
    等集合方法，集合提供了进一步的梯度过滤，甚至可以将一些计算从 PHP 应用层转移到 SQL 层。深入了解这些和其他集合方法超出了本章的范围，可能需要一本单独的书籍。
- en: Collection filters
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合过滤器
- en: 'Looking back at the preceding `addAttributeToFilter` method call examples,
    questions pop out as to where can we see the list of all available collection
    filters. If we take a quick look inside the `vendor/magento/framework/DB/Adapter/Pdo/Mysql.php`
    file, we can see the method called `prepareSqlCondition` (partially) defined as
    follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾前面的 `addAttributeToFilter` 方法调用示例，人们可能会问在哪里可以看到所有可用的集合过滤器的列表。如果我们快速查看 `vendor/magento/framework/DB/Adapter/Pdo/Mysql.php`
    文件，我们可以看到名为 `prepareSqlCondition` 的方法（部分）定义如下：
- en: '[PRE55]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This method is what eventually gets called at some point during SQL query construction.
    The `$condition` parameter is expected to have one of the following (partially
    listed) forms:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是在 SQL 查询构建过程中的某个时刻最终被调用的。期望 `$condition` 参数具有以下（部分列出）形式之一：
- en: '`array("from" => $fromValue, "to" => $toValue)`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array("from" => $fromValue, "to" => $toValue)`'
- en: '`array("eq" => $equalValue)`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array("eq" => $equalValue)`'
- en: '`array("neq" => $notEqualValue)`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array("neq" => $notEqualValue)`'
- en: '`array("like" => $likeValue)`'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array("like" => $likeValue)`'
- en: '`array("in" => array($inValues))`'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array("in" => array($inValues))`'
- en: '`array("nin" => array($notInValues))`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array("nin" => array($notInValues))`'
- en: '`array("notnull" => $valueIsNotNull)`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array("notnull" => $valueIsNotNull)`'
- en: '`array("null" => $valueIsNull)`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array("null" => $valueIsNull)`'
- en: '`array("gt" => $greaterValue)`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array("gt" => $greaterValue)`'
- en: '`array("lt" => $lessValue)`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array("lt" => $lessValue)`'
- en: '`array("gteq" => $greaterOrEqualValue)`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array("gteq" => $greaterOrEqualValue)`'
- en: '`array("lteq" => $lessOrEqualValue)`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array("lteq" => $lessOrEqualValue)`'
- en: '`array("finset" => $valueInSet)`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array("finset" => $valueInSet)`'
- en: '`array("regexp" => $regularExpression)`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array("regexp" => $regularExpression)`'
- en: '`array("seq" => $stringValue)`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array("seq" => $stringValue)`'
- en: '`array("sneq" => $stringValue)`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array("sneq" => $stringValue)`'
- en: If `$condition` is passed as an integer or string, then the exact value will
    be filtered (`'eq'` condition). If none of the conditions is matched, then a sequential
    array is expected as a parameter and `OR` conditions will be built using the preceding
    structure.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`$condition`作为整数或字符串传递，则将过滤确切值（`'eq'`条件）。如果没有匹配任何条件，则期望参数为一个顺序数组，并将使用前面的结构构建`OR`条件。
- en: The preceding examples covered EAV model collections, as they are slightly more
    complex. Though the approach to filtering more or less applies to simple model
    collections as well, the most notable difference is that there are no `addAttributeToFilter`,
    `addAttributeToSelect`, and `addExpressionAttributeToSelect` methods. The simple
    model collections make use of `addFieldToFilter`, `addFieldToSelect`, and `addExpressionFieldToSelect`,
    among other subtle differences.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例涵盖了EAV模型集合，因为它们稍微复杂一些。尽管过滤的方法在简单模型集合中也大致适用，但最显著的区别是没有`addAttributeToFilter`、`addAttributeToSelect`和`addExpressionAttributeToSelect`方法。简单模型集合使用`addFieldToFilter`、`addFieldToSelect`和`addExpressionFieldToSelect`等方法，以及其他细微的区别。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first learned how to create simple model, its resource,
    and collection class. Then we did the same for an EAV model. Once we had the required
    model, resource, and collection classes in place, we took a detailed look at the
    type and flow of schema and data scripts. Going hands-on, we covered `InstallSchema`,
    `UpgradeSchema`, `InstallData`, and `UpgradeData` scripts. Once the scripts were
    run, the database ended up having the required tables and sample data upon which
    we based our entity CRUD examples. Finally, we took a quick but focused look at
    collection management, mostly comprising filtering collection to get the desired
    result set.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了如何创建简单的模型、其资源以及集合类。然后我们对EAV模型也进行了同样的操作。一旦我们有了所需的模型、资源和集合类，我们就详细地研究了模式和数据脚本的类型和流程。动手实践，我们涵盖了`InstallSchema`、`UpgradeSchema`、`InstallData`和`UpgradeData`脚本。一旦脚本运行，数据库最终拥有了所需的表和样本数据，这些数据是我们基于实体CRUD示例的。最后，我们快速但专注地查看集合管理，这主要涉及过滤集合以获取所需的结果集。
- en: The full module code can be downloaded from [https://github.com/ajzele/B05032-Foggyline_Office](https://github.com/ajzele/B05032-Foggyline_Office).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的模块代码可以从[https://github.com/ajzele/B05032-Foggyline_Office](https://github.com/ajzele/B05032-Foggyline_Office)下载。
