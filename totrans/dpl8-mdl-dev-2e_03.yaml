- en: Logging and Mailing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录和邮件
- en: In the previous chapter, we learned about some of the more common things most
    Drupal 8 module developers will have to know, starting with the basics, that is,
    creating a Drupal module.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了大多数 Drupal 8 模块开发者必须了解的一些更常见的事情，从基础知识开始，即创建一个 Drupal 模块。
- en: 'In this chapter, we will take things further and cover some other important
    tasks a developer will have to perform:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步探讨一些开发者必须执行的其他重要任务：
- en: We will take a look at how logging works in Drupal 8\. In doing so, we will
    cover some examples by expanding on our *Hello World* module.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将探讨 Drupal 8 中记录的工作原理。为此，我们将通过扩展我们的 *Hello World* 模块来涵盖一些示例。
- en: We will look at the Mail API in Drupal 8, namely, how we can send emails with
    the default setup (PHP mail). However, more than that, I will show you how to
    create your own email system to integrate with your (perhaps external) mail service;
    remember plugins? This will be yet another good example of using a plugin to extend
    existing capabilities.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将探讨 Drupal 8 中的邮件 API，即如何使用默认设置（PHP 邮件）发送电子邮件。然而，不仅如此，我还会向你展示如何创建自己的电子邮件系统，以便与你的（可能是外部的）邮件服务集成；还记得插件吗？这将是使用插件扩展现有功能的另一个好例子。
- en: At the end of the chapter, we will also look at the Drupal 8 token system. We'll
    do so in the context of us replacing certain *tokens* with contextual data so
    that the emails we send out are a bit more dynamic.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章末尾，我们还将探讨 Drupal 8 的令牌系统。我们将在此背景下，用上下文数据替换某些 *令牌*，以便我们发送的电子邮件更具动态性。
- en: By the end of this chapter, you should be able to add logging to your Drupal
    8 module and feel comfortable sending emails programmatically. Additionally, you'll
    understand how tokens work, and as a bonus, see how you can define your own tokens.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够向你的 Drupal 8 模块添加记录，并能够舒适地以编程方式发送电子邮件。此外，你将了解令牌的工作原理，并且作为额外奖励，将了解如何定义你自己的令牌。
- en: Logging
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录
- en: 'The main logging mechanism in Drupal is a database log by which client code
    can use an API to save messages into the `watchdog` table. The messages in there
    are cleared after they reach a certain number, but meanwhile they can be viewed
    in the browser via a handy interface (at `admin/reports/dblog`):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 中的主要记录机制是通过数据库记录，客户端代码可以使用 API 将消息保存到 `watchdog` 表中。当消息达到一定数量后，这些消息会被清除，但与此同时，可以通过一个方便的界面（在
    `admin/reports/dblog`）在浏览器中查看：
- en: '![](img/41268aad-d89f-4f11-9970-7c5f2698a59a.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/41268aad-d89f-4f11-9970-7c5f2698a59a.png)'
- en: Alternatively, a core module that is disabled by default, Syslog, can be used
    to complement/replace this logging mechanism with the Syslog of the server the
    site is running on. For the purpose of this book, we will focus on how logging
    works with any mechanism, but we will also take a look at how we can implement
    our own logging system in Drupal 8.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，一个默认禁用的核心模块，Syslog，可以用来补充/替换此记录机制，使用运行该网站的服务器的 Syslog。为了本书的目的，我们将关注任何机制下的记录工作原理，但也会探讨如何在
    Drupal 8 中实现我们自己的记录系统。
- en: 'Drupal 7 developers are very familiar with the `watchdog()` function they use
    for logging their messages. This is a procedural API for logging that exposes
    a simple function that takes some parameters: `$type` (the category of the message),
    `$message`, `$variables` (an array of values to replace placeholders found in
    the message), `$severity` (a constant), and `$link` (a link to where the message
    should link to from the UI). It''s pretty obvious that this solution is a very
    Drupal-specific one and not really common to the wider PHP community.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 7 开发者非常熟悉他们用于记录消息的 `watchdog()` 函数。这是一个用于记录的进程式 API，它暴露了一个简单的函数，该函数接受一些参数：`$type`（消息的类别）、`$message`、`$variables`（一个值数组，用于替换消息中找到的占位符）、`$severity`（一个常量）和
    `$link`（一个链接，从 UI 中链接到消息）。很明显，这个解决方案非常特定于 Drupal，并不真正适用于更广泛的 PHP 社区。
- en: In Drupal 8, this has changed. The Database Logging module remains, the table
    for storing the messages is still called `watchdog`, but this logging destination
    is just one possible implementation that can be done. This is because the logging
    framework in Drupal 8 has been refactored to be object-oriented and PSR-3 compliant.
    And in this context, database logging is just the default implementation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Drupal 8 中，这已经改变。数据库记录模块仍然存在，存储消息的表仍然称为 `watchdog`，但这个记录目的地只是可以完成的一种可能实现。这是因为
    Drupal 8 的记录框架已经被重构为面向对象和 PSR-3 兼容。在这种情况下，数据库记录只是默认实现。
- en: The Drupal 8 logging theory
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Drupal 8 记录理论
- en: Before going ahead with our example, let's cover some theoretical notions regarding
    the logging framework in Drupal 8\. In doing so, we'll try to understand the key
    *players* we will need to interact with.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续我们的例子之前，让我们先了解一下Drupal 8中日志框架的一些理论概念。这样做时，我们将尝试理解我们需要与之交互的关键*参与者*。
- en: First, we have `LoggerChannel`, which represents a category of logged messages.
    They resemble the former `$type` argument to the Drupal 7 `watchdog()` function.
    A key difference, however, is that they are objects through which we do the actual
    logging via the logger plugins themselves. In this respect, they are used by our
    second main *player*, `LoggerChannelFactory`, a service that is normally our main
    *contact* with the logging framework as a client code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有`LoggerChannel`，它代表一组日志消息。它们类似于Drupal 7的`watchdog()`函数之前的`$type`参数。然而，一个关键的区别是，它们是通过日志插件本身进行实际日志记录的对象。在这方面，它们被我们的第二个主要参与者`LoggerChannelFactory`使用，这是一个服务，通常作为客户端代码，我们与日志框架的主要接触点。
- en: 'To understand these things better, let''s consider the following example of
    a simple usage:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些内容，让我们考虑以下简单使用的例子：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That''s it. We just used the available registered loggers to log an error message
    through the `hello_world` channel. This is our own custom channel that we just
    came up with on the fly and that simply categorizes this message as belonging
    to the `hello_world` category (the module we started in the preceding chapter).
    Moreover, you''ll see that I used the static call. Under the hood, the logger
    factory service is loaded, a channel is requested from it, and the `error()` method
    is called on that channel:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。我们只是使用了可用的已注册的日志记录器通过`hello_world`通道记录了一个错误消息。这是我们刚刚即兴想出的自定义通道，它只是将这条消息分类为属于`hello_world`类别（我们在上一章中开始的模块）。此外，您会看到我使用了静态调用。在底层，加载了日志工厂服务，从它那里请求了一个通道，并在该通道上调用`error()`方法：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you request a channel from `LoggerChannelFactory`, you give it a name,
    and based on that name, it creates a new instance of `LoggerChannel`, which is
    the default channel class. It will then pass to that channel all the available
    loggers so that when we call any of the `RfcLoggerTrait` logging methods on it,
    it will delegate to them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从`LoggerChannelFactory`请求一个通道时，您给它一个名字，然后根据这个名字，它创建一个`LoggerChannel`的新实例，这是默认的通道类。然后它会将所有可用的日志记录器传递给这个通道，这样当我们调用它上面的任何`RfcLoggerTrait`日志方法时，它就会委托给它们。
- en: We also have the option of creating our own channel. An advantage of doing this
    is that we can inject it directly into our classes instead of the entire factory
    from where we can request the channel. Also, we can do it in a way in which we
    don't even require the creation of a new class, but will inherit from the default
    one. We'll see how to do that in the next section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也有创建我们自己的通道的选项。这样做的一个优点是我们可以直接将其注入到我们的类中，而不是整个工厂，我们可以从那里请求通道。此外，我们可以以一种甚至不需要创建新类的方式来做这件事，而是从默认的一个继承。我们将在下一节中看到如何做到这一点。
- en: The third main player is the `LoggerInterface` implementation, which follows
    the PSR-3 standard. If we look at the `DbLog` class, which is the database logging
    implementation we mentioned earlier, we note that it also uses the `RfcLoggerTrait`
    which takes care of all the necessary methods so that the actual `LoggerInterface`
    implementation only has to handle the main `log()` method. This class is then
    registered as a service with the `logger` tag, which in turn registers it with
    `LoggerChannelFactory` (which also acts as a service collector).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第三大主要参与者是`LoggerInterface`的实现，它遵循PSR-3标准。如果我们看看我们之前提到的数据库日志实现`DbLog`类，我们会注意到它也使用了`RfcLoggerTrait`，这个特质负责所有必要的函数，使得实际的`LoggerInterface`实现只需处理主要的`log()`方法。然后这个类被注册为一个带有`logger`标签的服务，它反过来又注册到`LoggerChannelFactory`（它也充当服务收集器）。
- en: As we saw in [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml), *Creating
    Your First Module*, tags can be used to categorize service definitions and we
    can have them collected by another service for a specific purpose. In this case,
    all services tagged with `logger` have a purpose, and they are gathered and used
    by `LoggerChannelFactory`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第二章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)中看到的，*创建您的第一个模块*，标签可以用来对服务定义进行分类，并且我们可以让它们被另一个服务为了特定目的收集。在这种情况下，所有带有`logger`标签的服务都有一个目的，并且它们被`LoggerChannelFactory`收集和使用。
- en: I know it's been quite a lot of theory, but these are some important concepts
    to understand. However, don't worry; as usual, we will go through some examples.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道已经讲了很多理论，但这些都是需要理解的重要概念。然而，不用担心；像往常一样，我们将通过一些示例来讲解。
- en: Our own logger channel
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们自己的日志通道
- en: I mentioned earlier how we can define our own logger channel so that we don't
    have to always inject the entire factory. So, let's take a look at how to create
    one for the *Hello World* module we're now writing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，我们可以定义自己的日志通道，这样我们就不必总是注入整个工厂。那么，让我们看看如何为现在正在编写的 *Hello World* 模块创建一个。
- en: 'Most of the time, all we have to do is add such a definition to the services
    definition file:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们只需要在服务定义文件中添加这样的定义：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Before talking about the actual logger channel, let's see what this weird service
    definition actually means, because this is not something we've seen before. I
    mean, where's the class?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论实际的日志通道之前，让我们看看这个奇怪的服务定义实际上意味着什么，因为这不是我们之前见过的。我的意思是，类在哪里？
- en: The `parent` key means that our service will inherit the definition from another
    service. In our case, the parent key is `logger.channel_base`, and this means
    that the class used will be `Drupal\Core\Logger\LoggerChannel` (the default).
    If we look closely at the `logger.channel_base` service definition in `core.services.yml`,
    we also see a `factory` key. This means that this service class is not being instantiated
    by the service container but by another service, namely the `logger.factory` service's
    `get()` method.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`parent` 键表示我们的服务将继承另一个服务的定义。在我们的例子中，`parent` 键是 `logger.channel_base`，这意味着使用的类将是
    `Drupal\Core\Logger\LoggerChannel`（默认）。如果我们仔细查看 `core.services.yml` 中的 `logger.channel_base`
    服务定义，我们也会看到一个 `factory` 键。这意味着这个服务类不是由服务容器实例化，而是由另一个服务，即 `logger.factory` 服务的
    `get()` 方法实例化。'
- en: The `arguments` key is also slightly different. First of all, we don't have
    the `@` sign. That is because this sign is used to denote a service name, whereas
    our argument is a simple string. As a bonus tidbit, if the string is preceded
    and followed by a `%`, it denotes a parameter that can be defined in any `*.services.yml`
    file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments` 键也有所不同。首先，我们没有 `@` 符号。这是因为这个符号用来表示服务名称，而我们的参数是一个简单的字符串。作为额外的小贴士，如果字符串前后有
    `%` 符号，它表示可以在任何 `*.services.yml` 文件中定义的参数。'
- en: 'Getting back to our example then, if you remember the logger theory, this service
    definition will mean that requesting this service will perform, under the hood,
    the following task:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，如果你还记得日志理论，这个服务定义意味着请求这个服务将执行以下任务：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It uses the logger factory to load a channel with a certain argument. So, now
    we can inject our `hello_world.logger.channel.hello_world` service and call any
    of the `LoggerInterface` methods on it directly in our client code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用日志工厂加载一个带有特定参数的通道。因此，现在我们可以注入我们的 `hello_world.logger.channel.hello_world`
    服务，并在客户端代码中直接调用任何 `LoggerInterface` 方法。
- en: Our own logger
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们自己的日志记录器
- en: Now that we have a channel for our module, let's assume that we also want to
    log messages elsewhere. They are fine to be stored in the database, but let's
    also send an email whenever we encounter an error log. In this section, we will
    only cover the logging architecture needed for this and defer the actual mailing
    implementation to the second part of this chapter when we discuss mailing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了模块的通道，假设我们还想在其他地方记录消息。它们可以存储在数据库中，但每当遇到错误日志时，我们还想发送电子邮件。在本节中，我们将只涵盖为此所需的日志架构，并将实际的邮件实现推迟到本章的第二部分，当我们讨论邮件时再进行。
- en: 'The first thing that we will need to create is the `LoggerInterface` implementation,
    which typically goes in the `Logger` folder of our namespace. So, let''s call
    ours `MailLogger`. And it can look like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要创建的是 `LoggerInterface` 实现，这通常放在我们命名空间的 `Logger` 文件夹中。所以，让我们称它为 `MailLogger`。它可以看起来像这样：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first thing to note is that we are implementing the PSR-3 `LoggerInterface`.
    This will require a bunch of methods, but we will take care of most of them via
    `RfcLoggerTrait`. The only one left to implement is the `log()` method, which
    will be responsible for doing the actual logging. For now, we will keep it empty.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们正在实现 PSR-3 `LoggerInterface`。这将需要很多方法，但我们将通过 `RfcLoggerTrait` 处理大部分方法。唯一剩下要实现的是
    `log()` 方法，它将负责实际的日志记录。目前，我们将保持它为空。
- en: 'By itself, having this class does nothing. We will need to register it as a
    tagged service so that `LoggingChannelFactory` picks it up and passes it to the
    logging channel when something needs to be logged. Let''s take a look at what
    that definition looks like:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 仅凭这个类本身并没有什么作用。我们需要将其注册为一个标记服务，以便 `LoggingChannelFactory` 能够捕获它，并在需要记录日志时将其传递给日志通道。让我们看看这个定义是什么样的：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As it stands, our logger doesn't need any dependencies. However, note the property
    called `tags` with which we tag this service with the `logger` tag. This will
    register it as a specific service that another service (called a collector) looks
    for. Just like we discussed in the previous chapter. In this case, the collector
    is `LoggingChannelFactory`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，我们的日志记录器不需要任何依赖项。然而，请注意名为 `tags` 的属性，我们使用 `logger` 标签标记这个服务。这将使其成为一个特定的服务，另一个服务（称为收集器）会寻找这个服务。就像我们在上一章讨论的那样。在这种情况下，收集器是
    `LoggingChannelFactory`。
- en: Clearing the cache should enable our logger. This means that when a message
    is being logged, via any channel, our logger is also used, together with any other
    enabled loggers (by default, the database one). So, if we want our logger to be
    the only one, we will need to disable the DB Log module from Drupal core.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 清除缓存应该能够启用我们的日志记录器。这意味着当通过任何通道记录消息时，我们的日志记录器也会被使用，连同任何其他启用的日志记录器（默认情况下是数据库日志记录器）。所以，如果我们想让我们的日志记录器是唯一的，我们需要从
    Drupal 核心中禁用 DB Log 模块。
- en: We will continue working on this class later in this chapter when we will cover
    sending out emails programmatically.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面继续对这个类进行工作，那时我们将介绍如何以编程方式发送电子邮件。
- en: Logging for Hello World
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World 的日志记录
- en: Now that we have all the tools at our disposal, and more importantly, understand
    how logging works in Drupal 8, let's add some logging to our module.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有工具，更重要的是，我们理解了 Drupal 8 中的日志记录工作原理，让我们在我们的模块中添加一些日志记录。
- en: There is one place where we can log an action that may prove helpful. Let's
    log an info message when an administrator changes the greeting message via the
    form we wrote. This should naturally happen in the submit handler of `SalutationConfigurationForm`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个地方我们可以记录一个可能有用的操作。当管理员通过我们编写的表单更改问候消息时，让我们记录一条信息消息。这应该在 `SalutationConfigurationForm`
    的提交处理程序中自然发生。
- en: If you remember my rant in the previous chapter, there is no way we should use
    a service statically if we can instead inject it, and we can easily inject services
    into our form. So, let's do this now.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得我在上一章中的抱怨，如果我们能够注入服务而不是静态使用服务，我们就应该避免使用静态服务，并且我们可以轻松地将服务注入到我们的表单中。所以，让我们现在就做这个。
- en: 'First of all, `FormBase` already implements `ContainerInjectionInterface`,
    so we don''t need to implement it in our class, as we are extending from it somewhere
    down the line. Second of all, the `ConfigFormBase` class we are directly extending
    already has `config.factory` injected, so this complicates things for us a bit—well,
    not really. All we need to do is copy over the constructor and `create()` method,
    add our own service, store it in a property, and pass the services the parent
    needs to the parent constructor call. It will look like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`FormBase` 已经实现了 `ContainerInjectionInterface`，因此我们不需要在我们的类中实现它，因为我们从它那里继承。其次，我们直接继承的
    `ConfigFormBase` 类已经注入了 `config.factory`，这使得事情对我们来说有点复杂——好吧，其实并不复杂。我们只需要复制构造函数和
    `create()` 方法，添加我们自己的服务，将其存储在一个属性中，并将父类所需的服务传递给父构造函数调用。它看起来是这样的：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And the relevant *use* statements at the top:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在顶部相关的 *使用* 声明：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we get all the services that any of the parents need, plus the
    one we want (the logger channel) via the `create()` method. Also, in our constructor,
    we store the channel as a property and then pass the parent arguments to the parent
    constructor. Now, we have our `hello_world` logger channel available in our configuration
    form class. So, let's use it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们通过 `create()` 方法获取了所有父类需要的所有服务，以及我们想要的（日志通道）。此外，在我们的构造函数中，我们将通道存储为一个属性，然后将父参数传递给父构造函数。现在，我们在配置表单类中有了
    `hello_world` 日志通道。所以，让我们使用它。
- en: 'At the end of the `submitForm()` method, let''s add the following line:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `submitForm()` 方法的末尾，让我们添加以下行：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are logging a regular information message. However, since we also want to
    log the message that has been set, we use the second argument, which represents
    an array of context values. Under the hood, the database logger will extract the
    context variables that start with `@`, `!`, or `%` with the values from the entire
    context array. This is done using the `LogMessageParser` service but we'll see
    more of this in a later chapter when we discuss internationalization. If you implement
    your own logger plugin, you will have to handle this yourself as well—but we'll
    see that in action soon.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在记录一条常规信息消息。然而，由于我们还想记录已经设置的消息，我们使用了第二个参数，它代表一个上下文值数组。在底层，数据库日志记录器将提取以 `@`、`!`
    或 `%` 开头的上下文变量，并从整个上下文数组中获取其值。这是通过使用 `LogMessageParser` 服务来完成的，但我们将在讨论国际化时看到更多关于它的内容。如果你实现自己的日志插件，你也将必须自己处理这一点——但我们很快就会看到这一点。
- en: And now we are done with logging a message when the salutation configuration
    form is saved.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了在问候配置表单保存时记录消息的工作。
- en: Logging summary
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志总结
- en: In this first section, we saw how logging works in Drupal 8\. Specifically,
    we covered a bit of theory so that you understand how things play together and
    you don't just mindlessly use the logger factory without actually having a clue
    what goes on under the hood.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第一部分，我们看到了 Drupal 8 中日志记录是如何工作的。具体来说，我们介绍了一些理论，以便你理解事物是如何相互作用的，并且你不会无意识地使用日志工厂，而不真正了解底层发生了什么。
- en: As examples, we created our own logging channel, which allows us to inject it
    wherever we need without always having to go through the factory. We will use
    this channel going forward for the *Hello World* module. Additionally, we created
    our own logger implementation. It won't do much at the moment, except getting
    registered, but we will use it in the next section to send emails when errors
    get logged to the site.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，我们创建了自己的日志通道，这使得我们可以在需要的地方注入它，而不必总是通过工厂。我们将从现在开始使用这个通道来处理 *Hello World*
    模块。此外，我们还创建了自己的日志实现。目前它不会做很多事情，除了注册之外，但我们在下一节中会使用它来在错误被记录到网站上时发送电子邮件。
- en: Finally, we used the logging framework (and our channel) in the salutation configuration
    form to log a message whenever the form is submitted. In doing so, we also passed
    the message that was saved so that it also gets included in the log. This should
    already work with the database log so go ahead and save the configuration form
    and then check the logging UI for that information message.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在问候配置表单中使用了日志框架（以及我们的通道）来记录消息，每当表单被提交时都会记录消息。在这个过程中，我们还传递了保存的消息，以便它也被包含在日志中。这应该已经与数据库日志一起工作，所以请继续保存配置表单，然后检查日志用户界面以获取该信息消息。
- en: Mail API
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邮件 API
- en: Now that we know how to log things in our application, let's turn our attention
    to the Drupal 8 Mail API. Our goal for this section is to see how we can send
    emails programmatically in Drupal 8\. In achieving this goal, we will explore
    the default mail system that comes with the core installation (which uses PHP
    mail), and also create our own system that can theoretically use an external API
    to send mails. We won't go all the way with the latter because it's beyond the
    scope of this book. We will stop after covering what needs to be done from a Drupal
    point of view.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何在我们的应用程序中记录事物，让我们将注意力转向 Drupal 8 的邮件 API。本节的目标是了解我们如何在 Drupal 8 中以编程方式发送电子邮件。为了实现这一目标，我们将探索核心安装中附带的标准邮件系统（它使用
    PHP 邮件），并创建我们自己的系统，理论上可以使用外部 API 来发送邮件。我们不会深入探讨后者，因为它超出了本书的范围。我们将停止在从 Drupal 视角介绍需要完成的事情之后。
- en: In the next and final section, we will look at tokens so that we can make our
    mailings a bit more dynamic. However, before we do that, let's get into the Mail
    API in Drupal 8.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节和最后一节中，我们将研究令牌，以便我们可以使我们的邮件发送更加动态。然而，在我们这样做之前，让我们先深入了解 Drupal 8 的邮件 API。
- en: The theory of the Mail API
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邮件 API 的理论
- en: Like before, let's first cover this API from a theoretical point of view. It's
    important to understand the architecture before diving into examples.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，让我们首先从理论角度介绍这个 API。在深入研究示例之前，了解架构是很重要的。
- en: Sending emails programmatically in Drupal is a two-part job. The first thing
    we need to do is define something of a *template* for the email in our module.
    This is not a template in the traditional sense, but rather a procedural data
    wrapper for the email you want to send. It's referred to in code as the *key*
    or *message ID*, but I believe that *template* is a better word to describe it.
    And you guessed it, it works by implementing a hook.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在Drupal中程序化发送电子邮件是一个两步的工作。我们首先需要做的是在我们的模块中定义电子邮件的某种*模板*。这并不是传统意义上的模板，而是一个用于你想要发送的电子邮件的过程性数据包装器。在代码中，它被称为*键*或*消息ID*，但我认为*模板*是一个更好的词来描述它。而且，不出所料，它是通过实现钩子来工作的。
- en: The second thing that we will need to do is use the Drupal mail manager to send
    the email using one of the defined *templates* and specifying the module that
    defines it. If this sounds confusing, don't worry, it will become clear with the
    example that follows its explanation later on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要做的是使用Drupal邮件管理器，通过定义的其中一个*模板*发送电子邮件，并指定定义它的模块。如果你觉得这很困惑，不要担心，随着后面解释的例子，它将会变得清晰。
- en: The *template* is created by implementing `hook_mail()`. This hook is a special
    one, as it does not work like most others. It gets called by the mail manager
    when a client (some code) is trying to send an email for the module that implements
    it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*模板*是通过实现`hook_mail()`创建的。这个钩子是一个特殊的钩子，因为它不像大多数其他钩子那样工作。它是由邮件管理器在客户端（一些代码）尝试为实现它的模块发送电子邮件时被调用的。'
- en: The `MailManager` is actually a plugin manager that is also responsible for
    sending the emails using a mail system (plugin). The default mail system is `PhpMail`,
    which uses PHP's native `mail()` function to send out emails. If we create our
    own mail system, that will mean creating a new plugin. Also, the plugin itself
    is the one actually delivering the emails, the manager simply deferring to it.
    As you can see, we can't go even a chapter ahead without creating plugins.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`MailManager`实际上是一个插件管理器，它还负责使用邮件系统（插件）发送电子邮件。默认的邮件系统是`PhpMail`，它使用PHP的本地`mail()`函数发送电子邮件。如果我们创建自己的邮件系统，那就意味着创建一个新的插件。此外，插件本身是实际发送电子邮件的，管理器只是简单地委托给它。正如你所见，我们甚至不能不创建插件就前进到下一章。'
- en: Each mail plugin needs to implement `MailInterface`, which exposes two methods—`format()`
    and `mail()`. The first one does the initial preparation of the mail content (message
    concatenation and so on), whereas the latter finalizes and does the sending.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个邮件插件都需要实现`MailInterface`，它公开了两个方法——`format()`和`mail()`。第一个方法负责邮件内容的初始准备（消息连接等），而后者负责最终化和发送。
- en: However, how does the mail manager know which plugin to use? It checks a configuration
    object called `system.mail` which stores the default plugin (`PhpMail`) and can
    also store overrides for each individual module and any module and *template*
    ID combination. So, we can have multiple mail plugins each used for different
    things. A quirky thing about this configuration object is that there is no admin
    form where you can specify which plugin does what. You have to adjust this configuration
    object programmatically as needed. One way you can manipulate this is via `hook_install()`
    and `hook_uninstall()` hooks. These hooks are used to perform some tasks whenever
    a module is installed/uninstalled. So, this is where we will change the configuration
    object to add our own mail plugin a bit later.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，邮件管理器是如何知道使用哪个插件的？它检查一个名为`system.mail`的配置对象，该对象存储默认插件（`PhpMail`），还可以存储每个单独模块以及任何模块和*模板*
    ID组合的覆盖。因此，我们可以有多个邮件插件，每个插件用于不同的事情。这个配置对象的一个奇特之处在于，没有管理员表单可以指定哪个插件做什么。你需要根据需要程序化地调整这个配置对象。你可以通过`hook_install()`和`hook_uninstall()`钩子来操作这个。这些钩子用于在模块安装/卸载时执行一些任务。所以，这就是我们稍后更改配置对象以添加我们自己的邮件插件的地方。
- en: However, now that we have looked at a few bits of theory, let's take a look
    at how we can use the default mail system to send out an email programmatically.
    You remember our unfinished logger from the preceding section? That is where we
    will send our email whenever the logged message is an error.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在我们已经看了一些理论知识，让我们看看我们如何使用默认的邮件系统来程序化地发送电子邮件。你还记得上一节中未完成的记录器吗？这就是我们将在记录的消息是错误时发送电子邮件的地方。
- en: Implementing hook_mail()
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`hook_mail()`
- en: 'As I mentioned earlier, the first step for sending mails in Drupal 8 is implementing
    `hook_mail()`. In our case, it can look something like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，在Drupal 8中发送邮件的第一步是实现`hook_mail()`。在我们的例子中，它可以看起来像这样：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This hook receives three parameters:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此钩子接收三个参数：
- en: the message key (template) that is used to send the mail
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于发送邮件的消息键（模板）
- en: the message of the email that needs to be filled in
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要填写在内的电子邮件消息
- en: an array of parameters passed from the client code
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从客户端代码传递的参数数组
- en: As you can see, we are defining a key (or *template*) named `hello_world_log`,
    which has a simple static subject, and as a body, it will have whatever comes
    from the `$parameters` array in its message key. Since the email *From* is always
    the same, we will use the site-wide email address that can be found in the `system.site`
    configuration object. You'll note that we are not in a context where we can inject
    the configuration factory as we did when we built the form. Instead, we can use
    the static helper to load it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在定义一个名为`hello_world_log`的键（或*模板*），它有一个简单的静态主题，正文将包含来自`$parameters`数组中的消息键中的任何内容。由于电子邮件*From*始终相同，我们将使用可在`system.site`配置对象中找到的全局电子邮件地址。您会注意到，我们不在可以像构建表单时那样注入配置工厂的上下文中。相反，我们可以使用静态辅助函数来加载它。
- en: Additionally, you'll note that the body is itself an array. This is because
    we can build (if we want) multiple items in that array that can be later imploded
    as paragraphs in the mail plugin's `format()` method. This is in any case what
    the default mail plugin does, so here we need to build an array.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您会注意到正文本身也是一个数组。这是因为我们可以构建（如果我们想的话）该数组中的多个项目，这些项目可以在邮件插件的`format()`方法中作为段落imploded。无论如何，这是默认邮件插件所做的事情，所以在这里我们需要构建一个数组。
- en: Another useful key in the `$message` array is the `header` key, which you can
    use to add some custom headers to the mail. In this case, we don't need to because
    the default `PhpMail` plugin adds all the necessary headers. So if we write our
    own mail plugin, we can then add our headers in there as well—and all other keys
    of the `$message` array for that matter. This is because the latter is passed
    around as a reference, so it keeps getting built up in the process from the client
    call to the `hook_mail()` implementation to the plugin.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`$message`数组中另一个有用的键是`header`键，您可以使用它向邮件添加一些自定义头。在这种情况下，我们不需要这样做，因为默认的`PhpMail`插件已经添加了所有必要的头。所以如果我们编写自己的邮件插件，我们也可以在那里添加我们的头——以及`$message`数组中的所有其他键。这是因为后者作为引用传递，所以它从客户端调用到`hook_mail()`实现再到插件的过程中不断构建。'
- en: That is about all we need to do with `hook_mail()`. Let's now see how to use
    this in order to send out an email.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要对`hook_mail()`做的所有事情。现在让我们看看如何使用它来发送电子邮件。
- en: Sending emails
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: We wanted to use our `MailLogger` to send out an email whenever we are logging
    an error. So let's go back to our class and add this logic.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用我们的`MailLogger`在记录错误时发送电子邮件。所以让我们回到我们的类中并添加这个逻辑。
- en: 'This is what our `log()` method can look like now:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`log()`方法现在可能的样子：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First of all, we said that we only want to send mails for errors, so in the
    first lines, we check whether the attempted log is of that level and return early
    otherwise. In other words, we don't do anything if we're not dealing with an error
    and rely on other registered loggers for those.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们说我们只想发送错误邮件，所以在前几行中，我们检查尝试记录的级别是否为该级别，如果不是则提前返回。换句话说，如果我们不处理错误，则不执行任何操作，并依赖其他已注册的记录器来处理这些错误。
- en: Next, we determine who we want the email to be sent to and the langcode to send
    it in (both are mandatory arguments to the mail manager's `mail()` method). We
    opt to use the site-wide email address (just as we did for the *From* value).
    We also use the same configuration object as we used earlier in the `hook_mail()`
    implementation. Don't worry we will shortly take care of injecting the config
    factory into the class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们确定要发送电子邮件的对象以及发送的语言代码（这两个都是邮件管理器`mail()`方法的必填参数）。我们选择使用全局电子邮件地址（正如我们在*From*值中所做的那样）。我们还使用与之前在`hook_mail()`实现中使用的相同配置对象。不用担心，我们很快就会将配置工厂注入到类中。
- en: When we talk about langcode, we refer to the machine name of a language object.
    In this case, that is what is being stored for the site-wide default language.
    Also, we'll default to that for our emails. In a later chapter, we will cover
    more aspects regarding internationalization in Drupal 8.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到langcode时，我们指的是语言对象的机器名。在这种情况下，这就是为网站默认语言存储的内容。此外，我们将默认使用它来发送电子邮件。在后面的章节中，我们将介绍有关Drupal
    8国际化的更多方面。
- en: Then, we prepare the message that is being sent out. For this, we use the `FormattableMarkup`
    helper class to which we pass the message string and an array of variable values
    that can be used to replace the placeholders in our message. We can retrieve these
    values using the `LogMessageParser` service the same way as the `DbLog` logger
    does. So with this, we are basically extracting the placeholder variables from
    the entire context array of the logged message.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们准备要发送的消息。为此，我们使用`FormattableMarkup`辅助类，我们传递消息字符串和一个可以用来替换我们消息中占位符的变量值数组。我们可以像`DbLog`记录器一样使用`LogMessageParser`服务来检索这些值。所以，我们基本上是从记录消息的整个上下文字符数组中提取占位符变量。
- en: Lastly, we use the mail manager plugin to send the email. The first parameter
    to its `mail()` method is the module we want to use for the mailing. The second
    is the key (or *template*) we want to use for it (which we defined in `hook_mail()`).
    The third and fourth are self-explanatory, while the fifth is the `$params` array
    we encountered in `hook_mail()`. If you look back at that, you'll note that we
    used the `message` key as the body. Here, we populate that key with our markup
    object, which has a `_toString()` method that renders it with all the placeholders
    replaced.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用邮件管理器插件来发送邮件。它的`mail()`方法的第一个参数是我们想要用于邮件的模块。第二个是我们想要使用的密钥（或*模板*），我们已经在`hook_mail()`中定义了它。第三个和第四个是显而易见的，而第五个是我们在`hook_mail()`中遇到的`$params`数组。如果你回顾一下，你会注意到我们使用了`message`键作为正文。在这里，我们用我们的标记对象填充这个键，这个对象有一个`_toString()`方法，它会用所有占位符替换后渲染它。
- en: You may wonder why I did not inject the Drupal mail manager as I did the rest
    of the dependencies. Unfortunately, the core mail manager uses the logger channel
    factory itself, which in turn depends on our `MailLogger` service. So if we make
    the mail manager a dependency of the latter, we find ourselves in a circular loop.
    So when the container gets rebuilt, a big fat error is thrown. It might still
    work, but it's not alright. So, I opted to use it statically, because, in any
    case, this method is very small and would be difficult to test due to its expected
    result being difficult to assert (it sends an email). Sometimes, you have to make
    these choices, as the alternative would have been to inject the entire service
    container just to trick it. However, that is a code smell and would not have helped
    anyway had I wanted to write a test for this class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我没有像对其他依赖项那样注入Drupal邮件管理器。不幸的是，核心邮件管理器本身使用记录器通道工厂，这反过来又依赖于我们的`MailLogger`服务。所以如果我们让邮件管理器成为后者的依赖项，我们会发现自己陷入了一个循环。所以当容器重建时，会抛出一个大错误。它可能仍然可以工作，但这并不好。所以我选择静态地使用它，因为无论如何，这种方法非常小，并且由于其预期的结果很难断言（发送电子邮件）而难以测试。有时，你必须做出这些选择，因为替代方案是注入整个服务容器来欺骗它。然而，这是一个代码味道，而且即使我想为这个类编写测试，也不会有帮助。
- en: 'Even if I did not inject the mail manager, I did inject the rest. So, let''s
    take a look at what we need now at the top of the class:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我没有注入邮件管理器，我也注入了其余的部分。所以，让我们看看我们现在在类顶部需要什么：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And finally, all the relevant *use* statements that we were missing:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有我们缺失的相关*use*语句：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, let''s quickly also adjust the service definition of our mail logger:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们快速调整我们的邮件记录器服务定义：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We simply have two new arguments—nothing new to you by now.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是有两个新的参数——对你来说现在没有什么新鲜的。
- en: Clearing the caches and logging an error should send the logged message (with
    the placeholders replaced) to the site email address (and from the same address)
    using the PHP native `mail()` function. Congratulations! You just sent out your
    first email programmatically in Drupal 8.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 清除缓存并记录错误应该会将带有替换占位符的记录消息发送到网站电子邮件地址（并从同一地址发送）使用PHP原生的`mail()`函数。恭喜！你刚刚在Drupal
    8中程序化地发送了第一封电子邮件。
- en: Altering someone else's emails
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改他人的电子邮件
- en: 'Drupal is powerful not only because it allows us to add our own functionality
    but also because it allows us to alter existing functionality. An important vector
    for doing this is the *alter* hooks system. Remember these from [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml),
    *Creating Your First Module*? These are hooks that are used to change the value
    of an array or object before it is used for whatever purpose it was going to be
    used for. When it comes to sending mails, we have an alter hook that allows us
    to change things on the mail definition before it goes out: `hook_mail_alter()`.
    For our module, we don''t need to implement this hook. However, for the sake of
    making it complete, let''s take a look at how we could use this hook to, for example,
    change the header of an existing outgoing email:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal之所以强大，不仅因为它允许我们添加自己的功能，还因为它允许我们修改现有功能。实现这一目标的一个重要途径是*alter*钩子系统。还记得[第二章](601b4dd0-c521-459e-9342-2645a109642c.xhtml)中的这些内容吗，*创建您的第一个模块*？这些是在使用之前用于更改数组或对象值的钩子。当涉及到发送邮件时，我们有一个alter钩子，允许我们在邮件定义发出之前更改内容：`hook_mail_alter()`。对于我们的模块，我们不需要实现此钩子。然而，为了使其完整，让我们看看我们如何可以使用此钩子来更改现有发出的电子邮件的标题：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, what is going on here? First of all, this hook implementation gets called
    in each module it is implemented in. It's not like `hook_mail()` in this respect
    as it allows us to alter mails sent from any module. However, in our example,
    we will just alter the mail we defined earlier.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？首先，这个钩子实现被调用在每个实现它的模块中。在这方面，它与`hook_mail()`不同，因为它允许我们修改来自任何模块发出的邮件。然而，在我们的示例中，我们只会修改我们之前定义的邮件。
- en: The only parameter (passed by reference as it is usual with alter hooks) is
    the `$message` array, which contains all the things we built in `hook_mail()`,
    as well as the key (*template*) and other things added by the mail manager itself,
    such as the headers. So, in our example, we are setting an HTML header so that
    whatever is getting sent out *could be* rendered as HTML. After this hook is invoked,
    the mail system formatter is also called, which, in the case of the `PhpMail`
    plugin, transforms all HTML tags into plain text, essentially canceling out our
    header. However, if we implement our own plugin, we can prevent that and successfully
    send out HTML emails with proper tags and everything.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一参数（作为它通常与alter钩子一起传递的引用）是`$message`数组，它包含我们在`hook_mail()`中构建的所有内容，以及邮件管理器本身添加的键（*模板*）和其他事物，例如标题。因此，在我们的示例中，我们正在设置一个HTML标题，以便发送出去的内容*可以*被渲染为HTML。在此钩子被调用后，邮件系统格式化器也会被调用，在`PhpMail`插件的情况下，它将所有HTML标签转换为纯文本，本质上取消了我们的标题。然而，如果我们实现自己的插件，我们可以防止这种情况发生，并成功发送带有适当标签的HTML电子邮件。
- en: So, that is basically all there is to altering existing outgoing mails. Next,
    we will take a look at how we can create our own mail plugin that uses a custom
    external mail system. We won't go into detail here, but we will prepare the architecture
    that will allow us to bring in the API we need and use it easily.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是修改现有发出的邮件的全部内容。接下来，我们将看看我们如何创建自己的邮件插件，该插件使用自定义的外部邮件系统。我们不会在这里详细介绍，但我们将准备一个架构，这将使我们能够引入所需的API并轻松使用它。
- en: Custom mail plugins
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义邮件插件
- en: In the previous section, we saw how we can use the Drupal 8 mail API to send
    emails programmatically in Drupal 8\. In doing so, we used the default PHP mailer,
    which although is good enough for our example, might not be so for our application.
    For example, we might want to use an external service via an API.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何使用Drupal 8邮件API在Drupal 8中程序化发送电子邮件。在这样做的时候，我们使用了默认的PHP邮件发送器，尽管对于我们的示例来说足够好，但可能不适合我们的应用程序。例如，我们可能想通过API使用外部服务。
- en: In this section, we will see how this works. To this end, we will write our
    own mail plugin that does just that, and then simply tell Drupal to use that system
    instead of the default one. Yet another plugin-based, non-invasive, extension
    point.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解这是如何工作的。为此，我们将编写自己的邮件插件，使其仅执行此操作，然后简单地告诉Drupal使用该系统而不是默认系统。这又是一个基于插件、非侵入性的扩展点。
- en: Before we start, I would like to mention that we won't go into any kind of detail
    related to the potential external API. Instead, we will stop at the Drupal 8-specific
    parts, so the code you will find in the repository won't do much—it will be used
    as an example only. It's up to you to use this technique if you need to.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我想提到，我们不会深入探讨任何与潜在的外部API相关的细节。相反，我们将停留在Drupal 8特定的部分，所以你将在仓库中找到的代码不会做很多事情——它只作为示例使用。如果你需要，使用这项技术取决于你。
- en: The mail plugin
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邮件插件
- en: 'So let''s start by creating our `Mail` plugin class, and if you remember, plugins
    go inside the `Plugin` folder of our module namespace. Mail plugins belong inside
    a `Mail` folder. So this is what a simple skeleton mail plugin class can look
    like:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先创建我们的`Mail`插件类，如果你记得，插件应该放在我们的模块命名空间中的`Plugin`文件夹里。邮件插件应该放在一个`Mail`文件夹里。所以一个简单的邮件插件类骨架可能看起来是这样的：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, we have a relatively easy plugin annotation; no unusual arguments
    there. Then, you will note that we implemented the mandatory `MailInterface`,
    which comes with the two methods implemented in the class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有一个相对简单的插件注释；没有不寻常的参数。然后，你会注意到我们实现了强制性的`MailInterface`，它包含在类中实现的两个方法。
- en: I mentioned the `format()` method earlier and said that it's responsible for
    doing certain processing before the message is ready to be sent. The previous
    implementation is a copy from the `PhpMail` plugin to exemplify just what kind
    of task would go there. However, you can do whatever you want in here, for example,
    allowing HTML tags. Imploding the body is something you will probably want to
    do anyway, as it is kind of expected that the mail body is constructed as an array
    by `hook_mail()`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过`format()`方法，并说过它负责在消息准备好发送之前进行某些处理。之前的实现是从`PhpMail`插件复制过来的，以展示那里可能进行的任务类型。然而，你可以在这里做任何你想做的事情，例如，允许HTML标签。将正文压缩成数组是你在`hook_mail()`中可能想要做的，因为通常期望邮件正文是由`hook_mail()`构建为一个数组。
- en: The `mail()` method, on the other hand, is left empty. This is because it's
    up to you to use the external API to send the email. For this, you can use the
    `$message` array we encountered in the `hook_mail()` implementation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`mail()`方法留空。这是因为使用外部API发送电子邮件取决于你。为此，你可以使用我们在`hook_mail()`实现中遇到的`$message`数组。
- en: Lastly, note that `ContainerFactoryPluginInterface` is another interface that
    our class implements. If you remember, that is what plugins need to implement
    in order for them to become container aware (for the dependencies to be injectable).
    Since this was only example code, it doesn't have any dependencies, so I did not
    include a constructor and left the `create()` method empty. Most likely, you will
    have to inject something, such as a PHP client library that works with your external
    API. So, it doesn't hurt to see this again.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，`ContainerFactoryPluginInterface`是我们类实现的另一个接口。如果你记得，这就是插件需要实现以便它们成为容器感知的（以便依赖项可以被注入）。由于这只是一个示例代码，它没有任何依赖项，所以我没有包含构造函数，并留空了`create()`方法。很可能会需要注入某些东西，比如一个与你的外部API一起工作的PHP客户端库。所以，再次查看这没有坏处。
- en: That is pretty much it for our plugin class. Now, let's take a look at how we
    can use it because for the moment, our `hello_world_log` emails are still being
    sent with the default PHP mailer.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的插件类来说，这就差不多了。现在，让我们看看我们如何使用它，因为到目前为止，我们的`hello_world_log`电子邮件仍然是通过默认的PHP邮件发送器发送的。
- en: Using mail plugins
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用邮件插件
- en: As I mentioned earlier, there is no UI in Drupal to select which plugin the
    mail manager should use for sending emails programmatically. It figures it out
    inside the `getInstance()` method by checking the `system.mail` configuration
    object, and more specifically, the `interface` key inside that (which is an array).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，Drupal中没有UI可以选择邮件管理器在发送电子邮件时应该使用哪个插件。它通过检查`system.mail`配置对象来在`getInstance()`方法中自行确定，更具体地说，是检查那个对象中的`interface`键（它是一个数组）。
- en: 'By default, this array contains only one record, that is, `''default'' => ''php_mail''`.
    That means that, by default, all emails are sent with the `php_mail` plugin ID.
    In order to get our plugin in the mix, we have a few options:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这个数组只包含一条记录，即`'default' => 'php_mail'`。这意味着默认情况下，所有邮件都使用`php_mail`插件ID发送。为了在我们的插件中混入，我们有几种选择：
- en: We can replace this value with our plugin ID, which means that all emails will
    be sent with our plugin
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以用我们的插件ID替换这个值，这意味着所有邮件都将通过我们的插件发送
- en: We can add a new record with the key in the `module_name_key_name` format, which
    means that all emails sent for a module with a specific key (or *template*) will
    use that plugin
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`module_name_key_name`格式的键来添加一个新的记录，这意味着所有发送给具有特定键（或*模板*）的模块的电子邮件都将使用该插件
- en: We can add a new record with the key in the `module_name` format, which means
    that all emails sent for a module will use that plugin (regardless of their key)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`module_name`格式的键添加一个新的记录，这意味着所有发送给模块的电子邮件都将使用该插件（无论它们的键是什么）
- en: For our example, we will set all emails sent from the `hello_world` module to
    use our new plugin. We can do this using the `hook_install()` implementation that
    runs whenever the module is installed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将设置从`hello_world`模块发送的所有电子邮件都使用我们新的插件。我们可以通过使用模块安装时运行的`hook_install()`实现来完成这项工作。
- en: 'Install (and uninstall) hooks need to go inside a `.install` PHP file in the
    root of our module. So this next function goes inside a new `hello_world.install`
    file. Also, if our module has already been enabled, we will need to first uninstall
    it and then install it again to get this function to fire:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 安装（和卸载）钩子需要放在我们模块根目录下的`.install` PHP文件中。因此，下一个函数将放在一个新的`hello_world.install`文件中。此外，如果我们的模块已经被启用，我们需要首先卸载它，然后再次安装它，以便触发此函数：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we load the configuration object as editable (so we can change
    it), and if we don't yet have a record with `hello_world` in the array of mail
    plugins we set it and map our plugin ID to it. Lastly, we save the object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们以可编辑的方式加载配置对象（因此我们可以更改它），如果我们还没有在设置的邮件插件数组中包含`hello_world`的记录，我们将设置它并将我们的插件ID映射到它。最后，我们保存对象。
- en: 'The opposite of this function is `hook_uninstall()`, which goes in the same
    file and—expectedly—gets fired whenever the module is uninstalled. Since we don''t
    want to change a site-wide configuration object and tie it to our module''s plugin,
    we should implement this hook as well. Otherwise, if our module gets uninstalled,
    the mail system will fail because it will try to use a nonexistent plugin. So,
    let''s tie up our loose ends:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与此函数相反的是`hook_uninstall()`，它位于同一文件中，并且预期在模块卸载时被触发。由于我们不希望更改全局配置对象并将其绑定到我们的模块插件，我们应该实现此钩子。否则，如果我们的模块被卸载，邮件系统将失败，因为它将尝试使用不存在的插件。所以，让我们把我们的尾巴系好：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, what we did here is basically the opposite. If the record we
    set previously exists, we unset it and save the configuration object.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在这里所做的基本上是相反的。如果之前设置的记录存在，我们将取消设置它并保存配置对象。
- en: So now, any mails sent programmatically for the `hello_world` module will use
    this plugin. Easy, right? However, since the plugin we wrote is not ready, the
    code you find in the repository will have the relevant line from the `hook_install()`
    implementation commented out so that we don't actually use it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，任何以编程方式发送给`hello_world`模块的邮件都将使用此插件。简单，对吧？然而，由于我们编写的插件尚未准备好，您在存储库中找到的代码将从`hook_install()`实现中的相关行注释掉，这样我们实际上就不会使用它。
- en: Tokens
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Token
- en: The last thing we will cover in this chapter is the Token API in Drupal 8\.
    We will cover a few bits of theory and, as usual, demonstrate them via examples
    on our existing *Hello World* module code. We will do this in the context of the
    mails we are sending out for error logs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将要讨论的最后一件事是Drupal 8中的Token API。我们将介绍一些理论知识，并像往常一样，通过在我们现有的*Hello World*模块代码中的示例来演示。我们将在发送错误日志邮件的上下文中这样做。
- en: It would be nice if we could include some personalized information in the mail
    text without having to hardcode it in the module code or configuration. For example,
    in our case, we might want to include in the email the username of the current
    user that is triggering the error log that is being emailed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够在不硬编码模块代码或配置的情况下在邮件文本中包含一些个性化信息，那将很棒。例如，在我们的情况下，我们可能想在电子邮件中包含触发错误日志的当前用户的用户名。
- en: Let's first understand how the Token API works, before going into our *Hello
    World* module.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入我们的*Hello World*模块之前，让我们首先了解Token API是如何工作的。
- en: The Token API
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Token API
- en: Tokens in Drupal are a standard formatted placeholder, which can be found inside
    a string and replaced by a real value extracted from a related object. The format
    tokens use is `type:token`, where `type` is the machine-readable name of a token
    type (a group of related tokens), and `token` is the machine-readable name of
    a token within this group.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal中的Token是一个标准格式的占位符，可以在字符串内部找到，并可以由从相关对象中提取的真实值替换。Token使用的格式是`type:token`，其中`type`是Token类型的机器可读名称（一组相关Token），而`token`是此组中Token的机器可读名称。
- en: The power of the Token API in Drupal is not only given by its flexibility but
    also by the fact that it is already a popular API. It is flexible because you
    can define groups which contain related tokens, linked by the data object that
    contains their value (for example, a Node object or User object). It is popular
    because in previous versions of Drupal, it was the contributed module many others
    were dependent on to define their own tokens, and it is now available in Drupal
    8 core with many tokens already defined out of the box. So, you'll find many existing
    tokens that you can use in your code, and if not, you can define your own.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal中Token API的力量不仅在于其灵活性，还在于它已经是一个流行的API。它的灵活性在于你可以定义包含相关标记的组，这些标记通过包含它们值的对象（例如，节点对象或用户对象）相互链接。它的流行是因为在Drupal的早期版本中，它是许多其他模块依赖的模块来定义自己的标记，而现在它已经包含在Drupal
    8的核心中，并且已经预定义了许多标记。因此，你会在你的代码中找到许多可以使用的现有标记，如果没有，你也可以定义自己的标记。
- en: There are three main components of this API—at least from the point of view
    of a Drupal 8 module developer. These components are two hooks—`hook_token_info()`
    and `hook_tokens()`—and the `Token` service, which is used to perform the replacement.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从Drupal 8模块开发者的角度来看，这个API有三个主要组件。这些组件是两个钩子——`hook_token_info()`和`hook_tokens()`——以及用于执行替换的`Token`服务。
- en: The first hook is used to define one or more token types and tokens. It essentially
    registers them with the system. The second is fired at the moment a token is found
    inside a string (a replacement is attempted by the service) and is used to do
    the replacement of the tokens based on the data that is passed to it from the
    service. For example, the User module defines two token types and a number of
    tokens inside `user_token_info()`. With `user_tokens()`, it checks whether the
    token is one of its own and tries to replace it with the contextual data (either
    a User object or the currently logged-in User object). To read the documentation
    related to each of these in detail and to see an extended example, you can find
    them either on the Drupal.org API page or inside the `token.api.php` file. There,
    you will also find *alter* hooks that correspond to these two and can be used
    to alter either the defined token information or logic to replace these tokens
    written by other modules or Drupal core.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个钩子用于定义一个或多个标记类型和标记。它本质上是在系统中注册它们。第二个钩子在找到字符串中的标记（服务尝试替换）时触发，并用于根据从服务传递给它的数据替换标记。例如，用户模块在`user_token_info()`中定义了两种标记类型和多个标记。通过`user_tokens()`，它检查标记是否是其自己的标记，并尝试用上下文数据（要么是用户对象，要么是当前登录的用户对象）替换它。要详细了解每个相关的文档并查看扩展示例，你可以在Drupal.org
    API页面或`token.api.php`文件中找到它们。在那里，你还可以找到与这两个相对应的*alter*钩子，可以用来修改定义的标记信息或替换其他模块或Drupal核心中编写的标记的逻辑。
- en: The Token service is what we can use as module developers if we have to replace
    tokens found inside a string. We will see how this is used in the next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Token服务是我们作为模块开发者可以使用来替换字符串中找到的标记的。我们将在下一节中看到它是如何使用的。
- en: Using tokens
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标记
- en: To quickly demonstrate how we can use tokens, let's include in our `hello_world_log`
    mails some information about the current user at the time the email is being sent
    out. This will naturally coincide with the user that is signed in at the time
    the error is being logged.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速演示我们如何使用标记，让我们在我们的`hello_world_log`邮件中包含一些关于在发送电子邮件时当前用户的信息。这自然会与在记录错误时登录的用户相一致。
- en: 'For this, we will need to alter our `hook_mail()` implementation. In there,
    we will ask the `current_user` service for the `AccountProxy` of the current user,
    add another string to our mail body and, of course, replace a token:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要修改我们的`hook_mail()`实现。在那里，我们将请求`current_user`服务当前用户的`AccountProxy`，向我们的邮件正文添加另一个字符串，当然，替换一个标记：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we are adding a new "paragraph" to our email. This is a simple
    string that informs us about the user that was logged in. However, in doing so,
    we use the `token` service (statically) to replace that piece of string with the
    token value. The `replace()` method of the service takes a string and optionally
    an array of data objects keyed by the type (group) of the tokens they should be
    used for.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们正在向我们的电子邮件添加一个新的“段落”。这是一个简单的字符串，告诉我们登录的用户。然而，在这样做的时候，我们使用`token`服务（静态地）将这段字符串替换为标记值。服务的`replace()`方法接受一个字符串，并可选地接受一个按标记（组）类型键控的数据对象数组。
- en: The choice of token and type in this case is important. The User module defines
    the `user` and `current-user` types. The difference between the two, if you check
    inside `user_tokens()`, is that the latter simply delegates to the former after
    it loads a full user entity. We could, alternatively, have done that ourselves
    and then passed the `user` type, but why should we? If somebody has done that
    for us already, we should not have to do it again. And what we pass to the `current-user`
    token type as a data object to be used in the replacement process is the `AccountProxy`
    (current user session).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，标记和类型的选择很重要。用户模块定义了`user`和`current-user`类型。如果你检查`user_tokens()`函数，两者的区别在于后者在加载完整的用户实体后，简单地委托给前者。我们也可以自己这样做，然后传递`user`类型，但为什么要这样做呢？如果有人已经为我们做了，我们就没必要再做了。而且我们传递给`current-user`标记类型作为替换过程中的数据对象的是`AccountProxy`（当前用户会话）。
- en: So, that's it. Now, the email message will get an extra line that contains the
    dynamically generated username of the currently logged-in user at the time the
    error happened. Under the hood, the token service scans the string, extracts the
    token, and calls all `hook_tokens()` implementations. The User module is the one
    that can return the replacement for this token based on the User object it receives.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，就是这样。现在，电子邮件消息将多一行，包含在发生错误时当前登录用户的动态生成的用户名。在底层，标记服务扫描字符串，提取标记，并调用所有`hook_tokens()`实现。用户模块是能够根据接收到的用户对象返回此标记替换的那个模块。
- en: Defining new tokens
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义新标记
- en: We just saw how we can programmatically use existing tokens inside our strings
    and get them replaced with minimal effort. All we need is the token service and
    the data object that can be used to replace the token. Keep in mind that there
    are tokens that don't even require any data objects due to their global nature.
    The `hook_tokens()` implementation will take care of that—let's see how.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何在字符串中程序化地使用现有标记，并轻松地将它们替换。我们需要的只是标记服务和可以用来替换标记的数据对象。记住，有些标记由于其全局性质甚至不需要任何数据对象。`hook_tokens()`实现将负责这一点——让我们看看。
- en: 'In the previous chapter, we created functionalities for a dynamic *Hello World*
    message: either calculated on the fly or loaded from a configuration object. How
    about we expose that message as a token? This would make its usage more flexible
    because our string becomes exposed to the entire token system.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们为动态的*Hello World*消息创建了功能：要么即时计算，要么从配置对象中加载。我们是否可以将该消息作为标记公开？这将使其使用更加灵活，因为我们的字符串现在可以暴露给整个标记系统。
- en: 'As mentioned earlier, we will start with the `hook_token_info()` implementation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将从`hook_token_info()`实现开始：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In here, we will need to define two things—the types and the tokens. In our
    case, we are defining one of each. The type is `hello_world` and comes with a
    human-readable name and description in case it needs to be rendered somewhere
    in the UI. The token is `salutation` and belongs to the `hello_world` type. It
    also gets a name and description. At the end, we return an array that contains
    both.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要定义两件事——类型和标记。在我们的例子中，我们定义了一个类型和一个标记。类型是`hello_world`，如果需要在UI中渲染，它还带有可读的名称和描述。标记是`salutation`，属于`hello_world`类型。它也获得一个名称和描述。最后，我们返回一个包含两者的数组。
- en: 'What follows is the `hook_tokens()` implementation in which we handle the replacement
    of our token:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`hook_tokens()`函数的实现，其中我们处理了我们的标记替换：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There is a bit more going on here, but I'll explain everything. This hook gets
    fired whenever a replacement of tokens is attempted on a string. And it's fired
    for each type that has been found inside that string, `$type` being the first
    argument. Inside `$tokens`, we get an array of tokens located in that string,
    which belong to `$type`. The `$data` array contains the objects needed to replace
    the tokens (and passed to the `replace()` method), keyed by the type. This array
    can be empty (as it will be in our case).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有更多的事情在进行中，但我将解释一切。这个钩子会在尝试在字符串上替换标记时被触发。并且它为字符串中找到的每个类型触发，`$type`是第一个参数。在`$tokens`中，我们得到一个数组，其中包含字符串中的标记，属于`$type`。`$data`数组包含替换标记所需的对象（并传递给`replace()`方法），按类型键控。这个数组可以是空的（在我们的情况下就是这样）。
- en: Inside the function, we loop through each token of this group and try to replace
    it. We only know of one, and we use our `HelloWorldSalutation` service to determine
    the replacement string.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们遍历这个组中的每个标记并尝试替换它。我们只知道一个，我们使用我们的`HelloWorldSalutation`服务来确定替换字符串。
- en: Finally, the function needs to return an array of all replacements found (which
    can be multiple if multiple tokens of the same type are found inside a string).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，函数需要返回所有找到的替换项的数组（如果字符串中找到多个相同类型的标记，则可能有多个）。
- en: The `bubbleable_metadata` parameter is a special cache metadata object that
    describes this token in the cache system. It is needed because tokens get cached,
    so if any dependent object changes, the cache needs to be invalidated for this
    token as well. By default, all objects inside the `$data` array are read and included
    in this object. However, in our case, it is empty, yet we still depend on a configuration
    object that can change—the one that stores the overridden salutation message.
    So, we will need to add a dependency on that configuration object even if the
    actual value for the salutation we compute uses the same `HelloWorldSalutation`
    service we used before. So, we have a simple example here, but with a complex
    twist. We will talk more about caching later in the book.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`bubbleable_metadata`参数是一个特殊的缓存元数据对象，它描述了在缓存系统中这个标记。这是必需的，因为标记会被缓存，所以如果任何依赖对象发生变化，缓存也需要为此标记进行失效。默认情况下，`$data`数组中的所有对象都被读取并包含在这个对象中。然而，在我们的情况下，它是空的，但我们仍然依赖于一个可能会改变的配置对象——存储覆盖问候信息的那个对象。因此，即使我们计算问候信息的实际值使用的是之前使用的相同的`HelloWorldSalutation`服务，我们仍然需要添加对这个配置对象的依赖。所以，这里有一个简单的例子，但有一个复杂的转折。我们将在本书的后面部分更多地讨论缓存。'
- en: 'That''s all there is to defining our token. It can now also be used inside
    strings and replaced using the `Token` service. Something like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是定义我们的标记的全部内容。现在它也可以在字符串内部使用，并使用`Token`服务进行替换。例如：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, we pass no other parameters. If our token was dependent on an
    entity object, for example, we would have passed it in the second parameter array
    and have made use of it inside `hook_tokens()` to compute the replacement.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们没有传递其他参数。如果我们的标记依赖于实体对象，例如，我们将在第二个参数数组中传递它，并在`hook_tokens()`内部使用它来计算替换。
- en: Token summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记摘要
- en: The token system is an important part of Drupal because it allows us to easily
    transform raw data into useful values using placeholder strings. It is a widely
    used and flexible system that many contributed modules build (and will build)
    upon. The great thing about tokens is the UI component. There are modules that
    will allow users to define strings in the UI but make it possible to fill them
    up with various tokens that it will replace. Also, this is something you can do
    as a module developer.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 标记系统是Drupal的重要组成部分，因为它允许我们使用占位符字符串轻松地将原始数据转换为有用的值。它是一个广泛使用且灵活的系统，许多贡献模块都是基于它（并将基于它）构建的。标记的伟大之处在于UI组件。有一些模块将允许用户在UI中定义字符串，但使其能够填充各种标记，这些标记将进行替换。此外，这也是作为模块开发者您可以做的事情。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed many things. We saw how logging works in Drupal
    8, how the mail API can be used programmatically (and extended), and how the token
    system can be employed to make our text more dynamic.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了许多内容。我们看到了在Drupal 8中日志是如何工作的，如何编程使用邮件API（以及如何扩展），以及如何使用标记系统使我们的文本更加动态。
- en: While going through this chapter, we also enriched our *Hello World* module.
    So, apart from understanding the theory about logging, we created our own logging
    channel service and logger plugin. For the latter, we decided to send out emails
    when log messages were of the type *error*. In doing this, we took a look at the
    mail API and how we can use it programmatically. We saw that, by default, PHP's
    native `mail()` function is used to send out emails, but we can create our own
    plugin very easily to use whatever external service we want—yet another great
    example of extensibility via plugins.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章的过程中，我们还丰富了我们的*Hello World*模块。因此，除了理解关于日志的理论外，我们还创建了自己的日志通道服务和日志插件。对于后者，我们决定当日志消息类型为*error*时发送电子邮件。在这个过程中，我们查看了一下邮件API以及我们如何编程使用它。我们看到，默认情况下，PHP的本地`mail()`函数用于发送电子邮件，但我们可以非常容易地创建自己的插件来使用我们想要的任何外部服务——这是通过插件实现扩展性的另一个绝佳例子。
- en: Lastly, we looked at tokens in Drupal 8\. We saw what components make up the
    API, how we can programmatically use existing tokens (replace them with the help
    of contextual data), and how we can define our own tokens for others to use. These
    are the main tenets of extensibility (and sharing)—using something someone else
    has exposed to you, and exposing something for someone else to use.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了 Drupal 8 中的标记（tokens）。我们了解了构成 API 的组件，如何程序化地使用现有的标记（通过上下文数据将它们替换），以及如何定义自己的标记供他人使用。这些都是可扩展性（和共享）的主要原则——使用他人向你暴露的东西，并为他人提供使用的东西。
- en: In the next chapter, we will look at another great topic—theming. Even though
    you may think that this falls within the purview of a frontend developer, module
    developers play an important role. Yes, much of the styling, client-side scripting,
    and visual architecture can be, and is, done by what we call *themers*. However,
    module developers need to understand and use theming tools to ensure that their
    data is rendered in the proper way. So, in the next chapter, we will focus on
    that.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一个重要主题——主题化。尽管你可能认为这属于前端开发者的范畴，模块开发者也扮演着重要的角色。是的，大部分的样式、客户端脚本和视觉架构都可以，并且确实是由我们所说的*主题开发者*完成的。然而，模块开发者需要理解和使用主题化工具，以确保他们的数据以正确的方式呈现。因此，在下一章中，我们将专注于这一点。
