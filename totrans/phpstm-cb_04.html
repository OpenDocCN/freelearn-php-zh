<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Integrating Framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Integrating Framework</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cooking with Symfony</li><li class="listitem" style="list-style-type: disc">Creating a controller with Symfony</li><li class="listitem" style="list-style-type: disc">Creating a model with Symfony</li><li class="listitem" style="list-style-type: disc">Creating a view with Symfony</li><li class="listitem" style="list-style-type: disc">Creating a model with the Yii framework</li><li class="listitem" style="list-style-type: disc">Creating a controller with the Yii framework</li><li class="listitem" style="list-style-type: disc">Creating a view with the Yii framework</li><li class="listitem" style="list-style-type: disc">Creating a model with the Zend framework</li><li class="listitem" style="list-style-type: disc">Creating a controller with the Zend framework</li><li class="listitem" style="list-style-type: disc">Creating a view with the Zend framework</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec49"/>Introduction</h1></div></div></div><p>Before you start off, try some introspection as homework. Do you believe in reinventing the wheel? Do you believe in adding technical debt? If your answer to those questions was yes, you probably need to skip this chapter altogether. In all other cases, you should use a framework. Frameworks are good and nice with you. They help. They save time. They save effort.</p><p>Let's move back to questions. What is a technical debt? It is the amount of money at stake by a company where the technological architecture has been designed in such a way that more effort or man hours (and thus money) will be required to maintain the system in future. What is reinventing the wheel? It is the process of putting in more effort to carry out a task that was already done in the past.</p><p>Will you please stop scratching your head? This isn't rocket science. The analogy with software engineering is quite simple. You probably spend time in coding petty tasks, such as user input validation and password validation for each and every project that you create. While this is a repetition of tasks in the first place, it is the most vulnerable part of your code. The vulnerability is not only from general attackers, but also from certain very trivial mistakes, such as not cleaning the code.</p><p>You need to strategize your actions. This reinventing of the wheel is not free of cost. You are a highly paid developer (because you purchased a PhpStorm license (pun intended). Your billing agency will spend money to get work done by you. If you do work that is prone to errors, the billing agency will have to shell out more money to fix and/or maintain the same project later. Thus the agency is bound to spend money in the future and hence has a technical debt.</p><p>Please use a framework. You can take actions rapidly in building up chunks and pieces of your code using chunks and pieces from the framework. Your development process will be accelerated. You will be exposed to a library of functions for common tasks, database queries, and input cleaning, to name a few. The decision to choose a framework, however, needs a lot of thought.</p><p>There are still a few dangling questions that come to mind. You need to hold on and stay tuned for loads of important information. There are three frameworks that PhpStorm can be easily embedded with: Symfony, Yii, and Zend, in the lexicographic order of their names.</p></div></div>
<div class="section" title="Cooking with Symfony"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec50"/>Cooking with Symfony</h1></div></div></div><p>
<span class="strong"><strong>Symfony</strong></span>
<a id="id247" class="indexterm"/> is a PHP web application framework for MVC applications available as free software and released under the MIT license.</p><p>To begin working with Symfony, you need to install Symfony on your local machine (also known as your local server). Life never lets you breathe easy. You have to choose from two (or more) paths to proceed. So is the case with PhpStorm.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec108"/>Getting ready</h2></div></div></div><p>Change often leads to confusion, so it is better to make few changes in the Symfony directory structure and jump to create a new controller. You create a new controller class inside the directory <code class="literal">&lt;Project-Root&gt;/src/Acme/DemoBundle/Controller</code>. Name it <code class="literal">CookingController.php</code>. Here are a few rules to follow:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">By default, you should create a controller with the suffix <code class="literal">Controller</code> in the name</li><li class="listitem" style="list-style-type: disc">Each controller should extend the class <code class="literal">Controller</code> that is defined in the namespace <code class="literal">Symfony\Bundle\FrameworkBundle\Controller\Controller namespace</code></li><li class="listitem" style="list-style-type: disc">The controller should be defined in the namespace <code class="literal">Acme\DemoBundle\Controller</code></li></ul></div><p>Since you will require the routing of methods as actions, you will need to use namespace <code class="literal">Sensio\Bundle\FrameworkExtraBundle\Configuration\Route</code>.</p><p>You need to define a route in a configuration file (a file with the <code class="literal">.yml</code> extension) so that Symfony knows exactly where your controller is.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec109"/>How to do it...</h2></div></div></div><p>To install Symfony, you<a id="id248" class="indexterm"/> can choose from a simple archive download from the Symfony website or use Composer for installation. Composer? Yes, it's the same system that was described in <a class="link" href="ch02.html" title="Chapter 2. PHP Development">Chapter 2</a>, <span class="emphasis"><em>PHP Development</em></span>, and some keywords to refresh your memory are composer.json, vendor directory, and so on.</p><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">If you want to install Symfony<a id="id249" class="indexterm"/> by downloading it from the website, you need to go to <a class="ulink" href="http://symfony.com/download">http://symfony.com/download</a>, select any of the archive formats, and download the archive to the disk.</li><li class="listitem">Once the archive has been downloaded to the disk, you can move the unzipped directory inside your web server document root and open it in PhpStorm. There are two points worth noting:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If you don't want the project to be web-based, you need not move it into the document root of your web server.</li><li class="listitem" style="list-style-type: disc">If you want to create a web-based project, you can also keep the unzipped folders anywhere. You can then create a symbolic link inside your web server document root to point to this unzipped folder. This is to keep the system clean, you see.</li></ul></div></li></ol></div><p>To open the project in PhpStorm, you need to go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Open</strong></span> and open the path of the directory where you kept the Symfony directory.</p><p>The composer method is a bit long, but a careful PhpStorm cookbook reader need not worry because the information on how to use Composer was provided in <a class="link" href="ch02.html" title="Chapter 2. PHP Development">Chapter 2</a>, <span class="emphasis"><em>PHP Development</em></span>. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">You need to specify <code class="literal">symfony/framework-standard-edition</code> as the package name, as shown in the following screenshot. PhpStorm will show you the list of packages with similar names.</li><li class="listitem">You need to specify the version number, and PhpStorm will be good to go. It will download the required dependencies for you.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>You should take care that you have a consistent Internet connection.</p></div></div><div class="mediaobject"><img src="graphics/3878OT_04_01.jpg" alt="How to do it..."/></div></li><li class="listitem">Once the <a id="id250" class="indexterm"/>framework has been downloaded, you can restart your IDE (not mandatory) to let PhpStorm breathe easy after doing the heavy-duty task of downloading the framework for you. As soon as you restart it, PhpStorm will be able to recognize which framework needs to be integrated. PhpStorm will guide you through integrating the framework usage.</li><li class="listitem">You can tell PhpStorm about the directory and the type of content it will contain by providing the details. You just have to select some values from the dropdown, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/3878OT_04_02.jpg" alt="How to do it..."/></div></li></ol></div><p>Thus, you are good to go with Symfony. There is a <code class="literal">readme.md</code> file provided at the project root level. You are encouraged to read it and follow the checklist that is provided with it.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec110"/>How it works...</h2></div></div></div><p>The <a id="id251" class="indexterm"/>Symfony framework adheres to the model-view-controller framework. Besides all the benefits that MVC serves, compartmentalizing the functionality is a major benefit. Thus, you will group all the database-related functions in the model, all the business logic in the controller, and all the presentation-related functions (generating the HTML) in the view. So, in order to dive deep into the details of Symfony, you need to understand the directory structure first.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec111"/>There's more...</h2></div></div></div><p>The directory structure is the basic skeleton of the project, and it is very important to know the directory structure before starting. Let's see the structure of Symfony.</p><div class="section" title="Directory structure of Symfony"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec09"/>Directory structure of Symfony</h3></div></div></div><p>When you download and install<a id="id252" class="indexterm"/> Symfony, you are provided with a directory<a id="id253" class="indexterm"/> structure by default. There are five directories visible: the <code class="literal">app</code>, <code class="literal">bin</code>, <code class="literal">src</code>, <code class="literal">vendor</code>, and <code class="literal">web</code> directories.</p><p>The <code class="literal">app</code> folder<a id="id254" class="indexterm"/> is designed to contain the application-specific resources. These resources include the configurations for the database connections and the like in the <code class="literal">config</code> directory. The <code class="literal">logs</code> directory is intended to contain the logs to be written by the Symfony framework application. The cache directory is intended to contain the cached versions of files and resources required to run the application. A cached version is faster than the regular version and is write-protected. The resource directory is designed to contain resources such as the view rendering pages and the like.</p><p>The <code class="literal">bin</code> folder<a id="id255" class="indexterm"/> is designed to keep the binary files (such as <code class="literal">.sh</code>) that would be required by the project. The files under <code class="literal">bin</code> need to be executable because of their nature—to be able to be executed and perform the intended tasks independently. You need to be careful while providing execute permissions to files and folders.</p><p>The <code class="literal">src</code> folder<a id="id256" class="indexterm"/> is designed to contain the PHP source code required by the project. This PHP source code can be anything: your templates, classes, and anything you think is related to your project.</p><p>The <code class="literal">web</code> folder<a id="id257" class="indexterm"/> is designed to keep all the content that has to be rendered in a web browser over the Internet. This content includes HTML, JavaScript, CSS, images, icons, sprites, <code class="literal">robots.txt</code>, and so on, as and when required for the project.</p><p>The <code class="literal">vendor</code> directory<a id="id258" class="indexterm"/> is designed to keep all the third-party tools that are required for the project to run. This is an excellent feature because it keeps the third-party code in a separate compartment, thus protecting them from accidental edits.</p><p>It is worth noting here that a<a id="id259" class="indexterm"/> framework sets rules for you to work. If you stick to those rules, you will be on the winning side. One example supposes that there is the plugin <code class="literal">X</code>, which you downloaded from the Internet, a part of your code depends on it, and there is one <code class="literal">config</code> directory available for the project as a whole. There is a big chance that you might end up making changes or overwriting the <code class="literal">config</code> file. A framework will prevent you from doing that. How? It will indicate to you that a configuration inside the vendor directory must not be disturbed. If you still proceed to make changes intentionally or unintentionally, there is a limit to every warranty.</p><p>Mind you, "is designed to contain" means that it was the default intention. You can obviously store your classes wherever you want.</p><p>After you get yourself set on the directory structure, it is time to get your hands really dirty. Friends, Romans, Countrymen! Roll up your sleeves and do remember all that you shall see.</p><p>Inside the <code class="literal">app</code> folder, there is the <code class="literal">cache</code> folder. As already stated, it is used to cache some contents precooked so that they can be rendered very quickly. The caching can be done on commonly used elements, such as the images, strings, JavaScript, CSS, and certain preprocessed data. Since the PHP being executed on the web server writes the caches, the user running the web server (yes, you heard it right) needs permission to write into the <code class="literal">cache</code> folder. Exactly the same is true for the logs directory as well. You need to set permissions to the two folders mentioned as <code class="literal">777</code>. You can do even better. You can change the ownership of the two directories such that they are now owned by <code class="literal">www-data</code> or the Apache user (the username under the Linux environment). Try the <code class="literal">chown</code> or <code class="literal">chmod</code> command. Whatever you do, make sure you are doing it right. Ownership/permission changes are actions that <a id="id260" class="indexterm"/>can prove to be an issue, so don't do it when you feel sleepy.</p><p>Did you enjoy playing in the mud? More mud follows.</p><p>Go back to a point in history where you were really very hungry and were attempting to bake pizza using some cheese, salt, capsicum, and tomato (as a fallback topping). Remember? That was some freestyle cooking. What if you want more disciplined adventures in life? Try following the Symfony way.</p></div></div></div>
<div class="section" title="Creating a controller with Symfony"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec51"/>Creating a controller with Symfony</h1></div></div></div><p>So you will have to <a id="id261" class="indexterm"/>create a new controller first. This controller will be<a id="id262" class="indexterm"/> responsible for making decisions about how you will cook your Pizza.</p><p>Change often leads to confusion, so it is better to make few changes in the Symfony directory structure and just jump to create a new controller.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec112"/>How to do it...</h2></div></div></div><p>Create a new controller class inside the directory <code class="literal">&lt;Project-Root&gt;/src/Acme/DemoBundle/Controller</code>. Name it <code class="literal">CookingController.php</code>. There are a few rules to follow:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">By default, you should create a controller with the suffix <code class="literal">Controller</code> in the name</li><li class="listitem" style="list-style-type: disc">Each controller should extend a class <code class="literal">Controller</code> that is defined in the namespace <code class="literal">Symfony\Bundle\FrameworkBundle\Controller\Controller</code></li><li class="listitem" style="list-style-type: disc">The controller should be defined in the namespace <code class="literal">Acme\DemoBundle\Controller</code></li><li class="listitem" style="list-style-type: disc">Since you will be required to route the methods as actions, you will need to use namespace <code class="literal">Sensio\Bundle\FrameworkExtraBundle\Configuration\Route</code>.</li><li class="listitem" style="list-style-type: disc">You need to define a route in a configuration file (a file with the <code class="literal">.yml</code> extension) so that Symfony knows exactly where your controller is.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>You can define the route later.</p></div></div></li></ul></div><p>So, your first controller looks like the following code:</p><div class="informalexample"><pre class="programlisting">namespace Acme\DemoBundle\Controller;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Template;
class CookingController extends Controller {
  /**
    * @Route("/", name="_cooking")
    * @Template()
  */
  public function indexAction() {
    return array();
  }

  /**
    * @Route("/nameDish/{dishname}", name="_cook_dish")
    * @Template()
  */
  public function nameDishAction($dishname) {
  return array('name' =&gt; $dishname);
  }
}</pre></div><p>And the content of the YML document (located at <code class="literal">&lt;Project-root&gt;/src/Acme/DemoBundle/Resources/config/routing.yml&gt;</code>) will be (appended by):</p><div class="informalexample"><pre class="programlisting">_cook:
resource: "@AcmeDemoBundle/Controller/CookingController.php"
type: annotation
prefix: /cook</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec113"/>How it works...</h2></div></div></div><p>The <a id="id263" class="indexterm"/>human mind is a very lazy machine. No sooner <a id="id264" class="indexterm"/>does it see any technical detail, than it starts getting confused. In order to eliminate the doubt, the working is explained here. Hang on. Begin with the source code because PHP is something you are more comfortable with. Here is the working.</p><p>The code starts with the declaration of a namespace that means you declared a virtual region or boundary for the elements of this controller. Technically, it is known as the namespace.</p><p>The code proceeds by including such namespaces for the base <code class="literal">Controller</code> and the routing system (denoted by <code class="literal">Route</code>).</p><p>If you want to include some presentation-layer templates, you can use the namespace of the templating engine as well. Twig is the name given to the default templating engine shipped with the default installation of Symfony.</p><p>Here, the most important aspect of a controller is that <code class="literal">CookingController</code> is a controller, so it is bound to extend the <code class="literal">Controller</code> class.</p><p>Inside the class are some simple methods that have public access. Did you say insecure? No, no dear! Since they are to be made available through a web browser, the access level has to be public.</p><p>The actual cooking starts by giving your dish a name. For this purpose, the method <code class="literal">nameDishAction</code> has the dish name as the parameter. Until now, things have been normal.</p><p>There is this annotation <code class="literal">@Route("/nameDish/{dishname}", name="_cook_dish")</code>, which adds the twist to the tale. <code class="literal">Route</code> creates a map between the action and the URL. This is another form of dependency injection. So, the name of the action <code class="literal">nameDish</code> is mapped with a name for the Symfony system (<code class="literal">_cook_dish</code>). If you look more closely, you will see that it also defines the way you will use this controller. The value specified in the braces is the placeholder for the argument that will be passed to this action.</p><p>Regarding the <a id="id265" class="indexterm"/>YML contents, it is worth mentioning that<a id="id266" class="indexterm"/> YML is actually YAML and is pronounced yamel. This is similar to any markup language with a key and its corresponding values. So, your resource will indicate the name of the controller you just created, the type your controller will be referenced as, and the prefix that will be required to be put with the actions as (to be) defined in your controller.</p><p>You just created a new Symfony controller to kick-start cooking. By the way, do you remember the last time you used the terminology dependency injection?</p></div></div>
<div class="section" title="Creating a model with Symfony"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec52"/>Creating a model with Symfony</h1></div></div></div><p>How does an application <a id="id267" class="indexterm"/>remember things? Persistence is the name of the<a id="id268" class="indexterm"/> phenomenon by which any application maintains its state. To have persistence, you need to have data structure(s). To manage data structures in a typical engineering perspective, you can use models—the M in the MVC paradigm.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec114"/>Getting ready</h2></div></div></div><p>Remember that you have some toppings as well as some ingredients to be added to your pizza dish. So, typically, you need an array to store (represent) the toppings and the ingredients. This is a green signal to go ahead and use model. But again, there is a twist in the tale. Symfony has no default model system in place. Bad design? Maybe not. It was originally designed to be a request-response system. Symfony looks to you for this purpose. You can create a model freestyle.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec115"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start by <a id="id269" class="indexterm"/>creating a new directory at the same level as <a id="id270" class="indexterm"/>the controller. Name it <code class="literal">Model</code>. This is descriptive naming, you see.</li><li class="listitem">Inside the <code class="literal">Model</code> directory, use PhpStorm's new class wizard to create a new class. Name it <code class="literal">CookingModel.php</code>. It is not that Symfony will not accept anything other than <code class="literal">/*Model$/</code> in the class name.</li><li class="listitem">You are encouraged to stick to names similar to the default Symfony names. Your model will look somewhat like the following code:<div class="informalexample"><pre class="programlisting">namespace Acme\DemoBundle\Model;
use Doctrine\Common\CommonException;


class CookingModel {
  /**
    * Get the ingredients that will be added to your dish
    * @return array Containing the list of ingredients
  */
  public function getIngredients(){
    $ingredients = array('salt','cheese','');
    $ingredientCount = 0;
    try {
      while ($ingredientCount &lt; count($ingredients)) {
        if ($ingredients[$ingredientCount] == '') {
          throw new CommonException("\nYou have run out of capsicum.");
        }
        $ingredientCount++;
      }
    } catch (CommonException $e) {
      $ingredients[$ingredientCount] = 'tomato';
    }
    return $ingredients;
  }

  /**
    * Get the toppings that will be added to your dish
    * @return array Containing the list of toppings
  */

  public function getToppings(){
    return array('pepperoni','mushroom','onion','spinach');
  }
}</pre></div></li><li class="listitem">Since you just created a new model, the model will be of no use unless it is used inside a controller. Revisit <code class="literal">CookingController</code>. It had no action to actually cook a pizza. <code class="literal">Acme\DemoBundle\Model\CookingModel</code> should be appended to the controller file header. When you add the required action, you will do something like the following code:<div class="informalexample"><pre class="programlisting">/**
  * @Route("/startCooking/{dishname}", name="_start_cooking_dish")
  * @Template()
  * @param string $dishname The name of the dish to be cooked.
*/
public function startCookingAction($dishname){
  $items = new CookingModel();
  return array(
    'dishname' =&gt; $dishname,
    'ingredients' =&gt; $items-&gt;getIngredients(),
    'toppings' =&gt; $items-&gt;getToppings()
  );
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec116"/>How it works...</h2></div></div></div><p>Now that you <a id="id271" class="indexterm"/>already have some experience in cooking, the model <a id="id272" class="indexterm"/>class is quite simple. If you recall, the content of the model is just a smart copy-paste from the <code class="literal">PizzaDish</code> class.</p><p>The namespace for the <code class="literal">CommonException</code> class was used to catch some exceptions if they occurred while cooking. This is safe cooking indeed.</p><p>The <code class="literal">getIngredients</code> method processes the available ingredients and returns an array containing the ingredients. It also prevents your pizza from becoming unenjoyable without capsicum—it adds tomato as a fallback ingredient.</p><p>The <code class="literal">getToppings</code> method functions similarly. It provides a list of the toppings you would like to add to make your pizza yummier.</p><p>Inside the controller, the model is used just like any other class. Inside the <code class="literal">startCookingAction</code>, all you did was create a new model object and obtain the value from the model.</p><p>Even simpler! So, you <a id="id273" class="indexterm"/>created a new model in Symfony. Congratulations! You<a id="id274" class="indexterm"/> can safely gobble up the pizza you just baked (or cooked—mind you, you are an engineer and not a cook, so the difference between cooking and baking should not bother you).</p></div></div>
<div class="section" title="Creating a view with Symfony"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec53"/>Creating a view with Symfony</h1></div></div></div><p>You can skip this section<a id="id275" class="indexterm"/> if you have planned to use Symfony to create a <a id="id276" class="indexterm"/>command-line software. But if you want to write software where you need to show beautiful presentation, you need to follow this section very carefully. The face of your application is known as view.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec117"/>Getting ready</h2></div></div></div><p>You need to create views in a particular directory if you stick to the default Symfony settings. The name of the directory in the present installation is <code class="literal">&lt;Project-root&gt;/symfony/src/Acme/DemoBundle/Resources/views</code>. You also have to create a directory that contains the name of the controller minus the word <code class="literal">controller</code>. Thus, you will create a directory with the name <code class="literal">Cooking</code> as you created a controller with the name <code class="literal">CookingController</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec118"/>How to do it...</h2></div></div></div><p>While naming the file, you have to keep in mind that you will name the view file with the extension <code class="literal">.html.twig</code>, and the filename will be the same as the name of the action minus <code class="literal">Action</code>, which will render the view.</p><p>So, you can have views with the name <code class="literal">index.html.twig</code>, <code class="literal">nameDish.html.twig</code>, and <code class="literal">startCooking.html.twig</code> as you created <code class="literal">indexAction</code>, <code class="literal">nameDishAction</code>, and <code class="literal">startCookingAction</code>, respectively.</p><p>By this time, you must be asking what bird <a id="id277" class="indexterm"/>
<span class="strong"><strong>TWIG</strong></span> is. You must also be thinking about starting to curse the author for having provided so much information. Dear, dear, dear. Art is long and life is short. Twig is a templating engine for PHP. It is designed to inject dynamic behavior into HTML pages. This is especially helpful for user interface developers<a id="id278" class="indexterm"/> who have little knowledge about the server-side<a id="id279" class="indexterm"/> language, which renders the HTML onto a web browser. Assuming you have to create a view, you will do something like this for <code class="literal">startCookingAction</code>:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Let us cook {{ dishname }}&lt;/title&gt;
&lt;style type="text/css"&gt;
.align-center{
  text-align: center;
}
.heading{
  font-weight: bold;
  font-size: 40px;
}
.normal-text{
  font-size: 16px;
}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="align-center heading"&gt;You are now cooking {{ dishname }}!&lt;/div&gt;
&lt;div class="align-center normal-text"&gt;By adding ingredients
{% for key, ingredient in ingredients %}
| {{ ingredient }}
{% endfor %}
&lt;/div&gt;
&lt;div class="align-center normal-text"&gt;And toppings
{% for key, topping in toppings %}
| {{ topping }}
{% endfor %}
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>The immediate remedy for the visual injury caused to you just now is to explain to you how this code works. An overview of this code is that it is for an HTML page.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec119"/>How it works...</h2></div></div></div><p>Inside the HTML <code class="literal">title</code> tag, there is <code class="literal">{{ dishname }}</code>, which is the dynamic content. If you revisit the method <code class="literal">startCookingAction</code> inside <code class="literal">CookingController</code>, you will notice that you returned an array with the index <code class="literal">dishname</code>. The placeholder <code class="literal">dishname</code> assumes its value from the controller action. If the controller returns an array, you will obviously require iterating the entire array to use the values in the view. A for-loop begins and ends with <code class="literal">for</code> and <code class="literal">endfor</code> respectively. Thus, the loop iterates over the array returned from the controller (<code class="literal">$ingredients</code> and <code class="literal">$toppings</code>) with the array index as key and the array values as <a id="id280" class="indexterm"/>the ingredient and topping respectively. The values thus <a id="id281" class="indexterm"/>obtained (ingredient and topping respectively) are used in the view.</p><p>You just cooked your pizza using a new method. Do you love it? There is no pun intended here.</p></div></div>
<div class="section" title="Creating a model with the Yii framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec54"/>Creating a model with the Yii framework</h1></div></div></div><p>The roadmap begins with creating a<a id="id282" class="indexterm"/> model. Then, create a controller and use the <a id="id283" class="indexterm"/>model you created. Finally, give a face to your application by creating a view. Use the model to get data and pass it on to the view.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec120"/>How to do it...</h2></div></div></div><p>Creating a new model is extremely easy. It is no different to creating a simple PHP class in PhpStorm. To create a new model, you need to create a new PHP class inside <code class="literal">&lt;project-root&gt;/app/models</code>. Your model will look like the following code:</p><div class="informalexample"><pre class="programlisting">namespace app\models;
class Cooking {
  /**
    * Get the ingredients that will be added to your dish
    * @return array Containing the list of ingredients
  */
  public function getIngredients(){
    $ingredients = array('salt','cheese','');
    $ingredientCount = 0;
    try {
      while ($ingredientCount &lt; count($ingredients)) {
        if ($ingredients[$ingredientCount] == '') {
          throw new \ErrorException("\nYou have run out of capsicum.");
        }
        $ingredientCount++;
      }
    } catch (\ErrorException $e) {
      $ingredients[$ingredientCount] = 'tomato';
    }
    return $ingredients;
  }
  public function getToppings(){
    return array('pepperoni','mushroom','onion','spinach');
  }
}</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec121"/>How it works...</h2></div></div></div><p>This model is exactly the same as<a id="id284" class="indexterm"/> the model you created in Symfony. Remember? The<a id="id285" class="indexterm"/> namespace of the model is declared so that any other class is able to access the methods defined in the model.</p><p>The exception available is defined in the <code class="literal">ErrorException</code> class, so it is used to handle the exception.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>This is why they say that your business logic is what really matters. So, irrespective of the framework, your data class (the model) remained the same.</p></div></div></div></div>
<div class="section" title="Creating a controller with the Yii framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec55"/>Creating a controller with the Yii framework</h1></div></div></div><p>To create a new controller, create a new PHP class inside the controller folder. Name it <code class="literal">CookingController.php</code>. The reason for this? You have been doing this for a while now, so you should continue doing it lest your stomach gets angry. Keep cooking, comrade.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec122"/>How to do it...</h2></div></div></div><p>To create a new controller, go<a id="id286" class="indexterm"/> to a new PHP class. Use the name <code class="literal">CookingController.php</code>. Do<a id="id287" class="indexterm"/> remember the directory <code class="literal">&lt;project-root&gt;/app/controllers</code>. Your controller will look somewhat like the following code:</p><div class="informalexample"><pre class="programlisting">namespace app\controllers;

use app\models\Cooking;
use Yii;
use yii\web\Controller;

class CookingController extends Controller
{
  public function actionIndex(){
    $items = new Cooking();
    $dishname = 'pizza';
    $ingredients = $items-&gt;getIngredients();
    $toppings = $items-&gt;getToppings();
    return $this&gt;render('index',array('dishname'=&gt;$dishname,
    'ingredients'=&gt;$ingredients,'toppings' =&gt; $toppings));
  }
}</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec123"/>How it works...</h2></div></div></div><p>On careful examination<a id="id288" class="indexterm"/> of the controller, you will have mixed <a id="id289" class="indexterm"/>feelings. You will be able to see some known-to-you elements in the code and some new elements.</p><p>The namespace of the controller is declared as <code class="literal">app\controllers</code>. This means that if some other controller needs to use the methods (actions) defined in this controller, that controller will have to use this namespace.</p><p>Since the data is being fetched from the model you created, in order to use the model's methods, you need to use the namespace in which the model is declared.</p><p>You need to use the namespace where the parent controller (defined by the framework) is defined.</p><p>The controller contains an action <code class="literal">actionIndex</code>. In Yii, the actions defined follow this naming convention: the word <code class="literal">action</code> followed by the actual purpose of the action. Thus, the <code class="literal">actionIndex</code> will be the default action for the controller.</p><p>The action requires a view as well. It is called by the method render: the first argument being the name of the view and the other argument the list of values to be passed on from the controller to the view.</p></div></div>
<div class="section" title="Creating a view with the Yii framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec56"/>Creating a view with the Yii framework</h1></div></div></div><p>Now, create a <a id="id290" class="indexterm"/>view to<a id="id291" class="indexterm"/> make your application complete. In creating a new view, you need to be careful.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec124"/>How to do it...</h2></div></div></div><p>The proper location of a view in a project is the <code class="literal">&lt;project-root&gt;/views/&lt;first-name-of-the-controller&gt;</code> directory. Thus, you will require a new directory under the views. Create a new directory with the name <code class="literal">cooking</code>. Inside this directory, create a new PHP file with the name <code class="literal">index.php</code>. Having<a id="id292" class="indexterm"/> done that, you need to write some basic HTML code to make a view. You<a id="id293" class="indexterm"/> might write something like the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?php
use yii\helpers\Html;
$this-&gt;title = 'Let us cook ';
?&gt;
&lt;!DOCTYPE html&gt;
&lt;html &gt;
&lt;head&gt;
&lt;head&gt;
&lt;meta charset="&lt;?= Yii::$app-&gt;charset ?&gt;"/&gt;
&lt;title&gt;&lt;?= Html::encode($this-&gt;title).$dishname ?&gt;&lt;/title&gt;
&lt;style type="text/css"&gt;
.align-center{text-align: center;}
.heading {font-weight: bold;font-size: 40px;}
.normal-text {font-size: 16px;}
&lt;/style&gt;
&lt;/head&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div class="align-center heading"&gt;You are now cooking &lt;?php echo $dishname; ?&gt;!&lt;/div&gt;
&lt;div class="align-center normal-text"&gt;By adding ingredients
&lt;?php
foreach($ingredients as $ingredient){
  ?&gt; | &lt;?php
  echo $ingredient;
}
?&gt;
&lt;/div&gt;
&lt;div class="align-center normal-text"&gt;And toppings
&lt;?php
foreach($toppings as $topping){
  ?&gt; | &lt;?php
  echo $topping;
}
?&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec125"/>How it works...</h2></div></div></div><p>The <code class="literal">html</code> part in the code is <a id="id294" class="indexterm"/>standard and does not use any other <a id="id295" class="indexterm"/>framework. The CSS is also kept basic to keep the code readable and simple to understand. When you use the namespace <code class="literal">YII/helpers/HTML</code>, it brings to your control the HTML helper class that performs basic HTML operations, such as encoding the input that might contain some special characters into HTML entities, and so on. The framework sets the charset (the character set) to be used on the web page.</p><p>The data that you passed on from the controller is now available in your view. The variable name is the name of the array index that you passed, and the value of the variable is the array value that was set at that array index. Thus, you will have <code class="literal">$dishname</code>, <code class="literal">$ingredients</code>, and <code class="literal">$toppings</code> in your view. In order to display the contents of the array, you just need to do a simple PHP <code class="literal">foreach</code> to iterate over the array, and your cooking process will be complete.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>It is not only <code class="literal">foreach</code> that will do the trick—you can use whichever loop control structure you like.</p></div></div></div></div>
<div class="section" title="Creating a model with the Zend framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec57"/>Creating a model with the Zend framework</h1></div></div></div><p>You will require a new <a id="id296" class="indexterm"/>model to make all the ingredients<a id="id297" class="indexterm"/> and the toppings available. Then, you would require a controller that would be the entry point for your application, and which would control the cooking process. To wrap up things, you require a view to which you will pass on the data from the controller, and your cooking will conclude.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec126"/>How to do it...</h2></div></div></div><p>This time, creating a new model is not at all difficult.</p><p>You just need to create a new PHP class inside the <code class="literal">&lt;project-root&gt;/module/Application/src/Application/Model</code> directory in just the same way as you have done all the while.</p><p>Name it <code class="literal">Cooking</code>, and set the namespace as <code class="literal">Application\Model</code>. The purpose of your model class will be to supply the ingredients to facilitate the cooking process.</p><p>Your model will look somewhat like the following code:</p><div class="informalexample"><pre class="programlisting">namespace Application\Model;
class Cooking {
  /**
    * Get the ingredients that will be added to your dish
    * @return array Containing the list of ingredients
  */
  public function getIngredients(){
    $ingredients = array( 'salt','cheese', '' );

    $ingredientCount = 0;
    try {
      while ($ingredientCount &lt; count($ingredients)) {
        if ($ingredients[$ingredientCount] == '') {
          throw new \ErrorException("\nYou have run out of capsicum.");
        }
        $ingredientCount++;
      }
    } catch (\ErrorException $e) {
      $ingredients[$ingredientCount] = 'tomato';
    }
    return $ingredients;
  }
  public function getToppings(){
    return array( 'pepperoni', 'mushroom', 'onion', 'spinach' );
  }
}</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec127"/>How it works...</h2></div></div></div><p>The model is quite<a id="id298" class="indexterm"/> easy to understand because if you are careful <a id="id299" class="indexterm"/>enough and possess a reasonable memory, you will easily recall that the model is exactly the same. The only difference here is the exception-handling class. Zend provides <code class="literal">ErrorException</code> to handle common exceptions.</p><p>You must feel better by now since you created a model quite easily.</p></div></div>
<div class="section" title="Creating a controller with the Zend framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec58"/>Creating a controller with the Zend framework</h1></div></div></div><p>Now's the time to create a <a id="id300" class="indexterm"/>new controller. To do that, you will <a id="id301" class="indexterm"/>have to perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new class inside <code class="literal">&lt;project root&gt;/module/Application/src/Application/Controller</code>.</li><li class="listitem"> Name it <code class="literal">CookingController</code>, and set the namespace <code class="literal">Application\Controller</code>.</li><li class="listitem">Use the namespace for the model since you need the model's methods in your code.</li><li class="listitem">Use the namespace for <code class="literal">AbstractActionController</code> as you need to tell Zend that your controller is <code class="literal">AbstractActionController</code>.</li><li class="listitem">Use the namespace for <code class="literal">ViewModel</code> since you will need to render a view when you run the code. Your controller will look like the following code:<div class="informalexample"><pre class="programlisting">namespace Application\Controller;

use Application\Model\Cooking;
use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;
class CookingController extends AbstractActionController {
  public function indexAction() {
    $dishname = 'Pizza';
    $items = new Cooking();
    $renderView = new ViewModel(
      array('dishname' =&gt; $dishname,'ingredients' =&gt; $items-&gt;getIngredients(),
    'toppings' =&gt; $items-&gt;getToppings()));
    $renderView-&gt;setTerminal(true);
    return $renderView;
  }
}</pre></div></li></ol></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec128"/>How it works...</h2></div></div></div><p>The code that you wrote<a id="id302" class="indexterm"/> just now is a controller class that uses<a id="id303" class="indexterm"/> some other classes to make things work as per your requirements. Thus, the typical thing that you might have noticed is the <code class="literal">ViewModel</code> method. The <code class="literal">ViewModel</code> method is actually a constructor method to the class <code class="literal">ViewModel</code> defined in the namespace <code class="literal">Zend\View\Model\ViewModel</code>. The purpose of this method is to render the view and pass on some values from the controller if need be. The <code class="literal">setTerminal</code> method that belongs to the <code class="literal">ViewModel</code> class prevents any other layout from rendering in your view. Without this, the framework looks for a <code class="literal">layout.phtml</code> file somewhere, which will render the general layout of the view component. Thus, your entire presentation will reside inside the <code class="literal">index.phtml</code> file that you will create next.</p></div></div>
<div class="section" title="Creating a view with the Zend framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec59"/>Creating a view with the Zend framework</h1></div></div></div><p>Having created the controller<a id="id304" class="indexterm"/> and the model, you can proceed to <a id="id305" class="indexterm"/>create a view and give your application a face.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec129"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to the <code class="literal">&lt;project-root&gt;/module/Application/view/application/cooking</code> directory, create a new PHP file, and name it <code class="literal">index.phtml</code>.<p>Phtml is a special extension used in the Zend framework that tells the web server that the expected content in the file will be more HTML and less PHP.</p><p>In other words, it is a way to tell the server that the file is a view component. Just as you have been doing all this while to create a view, you will take similar actions this time as well. After all, a view is a view.</p></li><li class="listitem">You will create something like the following code:<div class="informalexample"><pre class="programlisting">&lt;?php echo $this-&gt;doctype(); ?&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;?php echo $this-&gt;headTitle('Let us cook '.$dishname)-&gt;setSeparator(' - ')-&gt;setAutoEscape(false) ?&gt;
&lt;/head&gt;</pre></div><p>Now we've defined the title. Let's move to other parts of the code, which are as follows:</p><div class="informalexample"><pre class="programlisting">&lt;style type="text/css"&gt;
.align-center{ text-align: center; }
.heading{ font-weight: bold; font-size: 40px; }
.normal-text{ font-size: 16px; }
&lt;/style&gt;</pre></div></li><li class="listitem">A simple-to-understand piece of CSS to garnish the recipes is as follows:<div class="informalexample"><pre class="programlisting">&lt;body&gt;
&lt;div class="align-center heading"&gt;You are now cooking &lt;?php echo $dishname; ?&gt;!&lt;/div&gt;
&lt;div class="align-center normal-text"&gt;By adding ingredients
&lt;?php
foreach($ingredients as $ingredient){
  ?&gt; | &lt;?php
  echo $ingredient;
}?&gt;
&lt;/div&gt;
&lt;div class="align-center normal-text"&gt;and toppings
&lt;?php
foreach($toppings as $topping){
  ?&gt; | &lt;?php
  echo $topping;
}?&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec130"/>How it works...</h2></div></div></div><p>The HTML part is quite simple. The difference is in the following two points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">$this-&gt;doctype()</code>: This is a method in the <code class="literal">Zend\View\Renderer\PhpRenderer</code> class that sets the <code class="literal">doctype</code> declaration for an HTML page</li><li class="listitem" style="list-style-type: disc"><code class="literal">$this-&gt;headTitle($title)</code>: This is a method in the same class that sets the title of a page as <code class="literal">$title</code>. The remaining part is exactly the same in terms of usage.</li></ul></div><p>Details! Thunderbolt! Your<a id="id306" class="indexterm"/> pizza still won't be cooked. You will have<a id="id307" class="indexterm"/> to work more in the Zend framework. It's time to move to the <span class="emphasis"><em>There's more…</em></span> section to bake your incomplete pizza.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec131"/>There's more...</h2></div></div></div><p>You need to create a configuration related to your application module. Inside <code class="literal">&lt;Project-root&gt;/module/Application/config</code>, create a new PHP file with the name <code class="literal">module.config.php</code>. You need to tell the Zend framework about the routes, the controllers, and the views that you will use to cook the pizza.</p><p>Your efforts can take the following shape:</p><div class="informalexample"><pre class="programlisting">return array('router' =&gt; array('routes' =&gt; array('home' =&gt; array('type' =&gt;'Zend\Mvc\Router\Http\Literal', 'options' =&gt; array('route' =&gt; '/', 'defaults' =&gt; array('controller' =&gt; 'Application\Controller\Cooking', 'action' =&gt; 'index', ),),),),),
'controllers' =&gt; array( 'invokables' =&gt; array( 'Application\Controller\Cooking' =&gt;'Application\Controller\CookingController'),),
'view_manager' =&gt; array( 'template_path_stack' =&gt; array( __DIR__ . '/../view',),),);</pre></div><p>A router contains routes. Routes contain the home route. The home route contains the type of route and routing options. The routing options contain the route and the default values, such as the controller name and the action name. Thus, you will want your <code class="literal">CookingController</code> to be active by default and the <code class="literal">indexAction</code> to take place by default.</p><p>The controllers contain the name that you want Zend to know your controller by. Actually, the name that Zend remembers your controllers by are through their class names minus the <code class="literal">Controller</code> word. Thus Zend will invoke your controller by the settings you specify for the inviolable.</p><p>Having created a view, you will want to tell Zend where your view files are. Inside, the <code class="literal">view_manager</code> does the same by setting the path of the template (<code class="literal">template_path_stack</code>).</p><p>Still some work remains. Oh God! When will the pizza get cooked? God says: "Be patient and be honest. You will enjoy."</p><p>You have to create <a id="id308" class="indexterm"/>a new PHP class inside <code class="literal">&lt;Project-root&gt;/module/Application</code> (with the name <code class="literal">Module</code>) so that you are able to use the routing and the <a id="id309" class="indexterm"/>related settings for your module. Your <code class="literal">Module.php</code> file will look somewhat like the following code:</p><div class="informalexample"><pre class="programlisting">namespace Application;
class Module {
  public function getConfig(){
  return include __DIR__ . '/config/module.config.php';
}

public function getAutoloaderConfig() {
  return array(
    'Zend\Loader\StandardAutoloader' =&gt; array(
      'namespaces' =&gt; array(
      __NAMESPACE__ =&gt; __DIR__ . '/src/' . __NAMESPACE__,
),),);
  }
}</pre></div><p>You need to stick to the Zend system to make things right and standard. To use module-specific configurations, you use the settings inside the <code class="literal">getConfig</code> method. In order to tell Zend where the classes to be included for execution are, you need to use <code class="literal">getAutoloaderConfig</code>.</p><p>Now you can say that you created the pizza successfully. You can now sit back on your couch and enjoy the taste. If you did not quite like the taste, there is always a next time!</p></div></div></body></html>