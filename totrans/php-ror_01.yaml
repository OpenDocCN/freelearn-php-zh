- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Understanding the Ruby Mindset and Culture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Ruby 思维方式和文化
- en: Ruby has had quite a history since its inception by Yukihiro Matsumoto. The
    adoption of the language by the community has, of course, influenced the direction
    in which Ruby has been focused. But, at its core, Ruby has been very straightforward
    in the way you *can* and the way you *should* write programs/scripts with it.
    Every language has its own peculiarities, which the community takes to define
    what a good practice is and what is considered “bad” code. While this may be entirely
    subjective, this subjectiveness paves the way for what the author’s original intention
    for creating the language was into what the community wants the language to become.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 自 Yukihiro Matsumoto 创立以来已经有了一段相当长的历史。社区对语言的采用当然影响了 Ruby 的关注方向。但，在本质上，Ruby
    在你“可以”和“应该”使用它编写程序/脚本的方式上非常直接。每种语言都有其独特的特性，社区将这些特性用于定义什么是良好的实践，什么是被认为是“坏”代码。虽然这可能是完全主观的，但这种主观性为作者最初创建语言的原意铺平了道路，使其成为社区希望语言成为的样子。
- en: Ruby was created with the idea of being extremely easy to read, flexible, and
    object-oriented. The same can be said about the technologies that came to pass
    because of Ruby. I’m talking about frameworks created in Ruby, such as Ruby on
    Rails ([https://rubyonrails.org](https://rubyonrails.org)) and Sinatra ([http://sinatrarb.com/](http://sinatrarb.com/)).
    But I’m also talking about other tools that were created with that same mindset,
    such as Chef ([https://www.chef.io/](https://www.chef.io/)). All of these tools
    have common traits but the trait that stands out the most is readability. Once
    you’re in the Ruby “realm,” you’re able to read and understand code made for vanilla
    Ruby, a Ruby on Rails application API, or even a Chef recipe to manage and configure
    infrastructure. Ruby does not automatically make your code more understandable
    or readable, but it goes a long way to give you the tools to make your code easier
    to read. Making your code understandable is key to focusing more on the business
    (or hobby) at hand and focusing less on trying to understand what some code is
    doing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 的设计理念是极其易于阅读、灵活且面向对象。同样，这也适用于由于 Ruby 而产生的技术。我指的是在 Ruby 中创建的框架，例如 Ruby on
    Rails ([https://rubyonrails.org](https://rubyonrails.org)) 和 Sinatra ([http://sinatrarb.com/](http://sinatrarb.com/))。但我还指的是那些具有相同思维方式的工具，例如
    Chef ([https://www.chef.io/](https://www.chef.io/))。所有这些工具都有共同的特性，但最突出的特性是可读性。一旦你进入
    Ruby 的“领域”，你就能阅读和理解为纯 Ruby、Ruby on Rails 应用程序 API 或甚至 Chef 脚本（用于管理和配置基础设施）编写的代码。Ruby
    并不会自动使你的代码更易于理解或阅读，但它为你提供了使代码更容易阅读的工具。使代码易于理解是专注于手头业务（或爱好）并减少试图理解某些代码在做什么的关键。
- en: 'But before we get there, we will need to make the switch to the Ruby mindset.
    In this chapter, we will start our journey into this mindset by covering the following
    topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们到达那里之前，我们需要转换到 Ruby 思维方式。在本章中，我们将通过涵盖以下主题开始我们的思维之旅：
- en: Creating readable Ruby code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可读的 Ruby 代码
- en: Object-oriented Ruby
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象的 Ruby
- en: Writing Ruby-esque code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 Ruby 风格的代码
- en: You made up your mind to learn a new programming language. Congratulations!
    I, for one, would like to applaud this decision and hope it took you less time
    than it took me to be seriously curious about another programming language. I
    was a bit stubborn and reluctant at first, seeing every single downside of Ruby.
    My favorite phrase was, “I can do that in PHP easier.” But then, one day, it simply
    clicked and I never went back. Ruby has been my go-to language for a long time
    now. And I won´t try to oversell this to you. I refuse to say that Ruby is the
    best programming language there is because that would be answering a loaded question.
    There is no programming language that is universally better than the rest. What
    I can do is try to show you why I love Ruby.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你下定决心学习一门新的编程语言。恭喜！至少对我来说，我很想赞扬这个决定，并希望它没有花你像我第一次对另一种编程语言产生浓厚兴趣时那么多的时间。一开始，我有点固执和犹豫，看到了
    Ruby 的每一个缺点。我最喜欢的说法是，“我可以用 PHP 更容易做到那件事。”但后来，有一天，它突然变得清晰，我再也没有回头。Ruby 已经是我很长时间以来的首选语言。而且我不会试图过分夸大这一点。我拒绝说
    Ruby 是最好的编程语言，因为这会回答一个有争议的问题。没有一种编程语言在所有语言中都是普遍优于其他语言的。我能做的是尝试向你展示我为什么喜欢 Ruby。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with this book, you will need:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随这本书，你需要：
- en: Git client
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 客户端
- en: rbenv (Ruby version manager to enable multiple versions of Ruby)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: rbenv（Ruby 版本管理器，可启用多个 Ruby 版本）
- en: Ruby (versions 2.6.10 and 3.0 or above)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby（版本 2.6.10 和 3.0 或更高版本）
- en: Any IDE of your choice installed to edit code (Sublime, Visual Studio Code,
    vim, Emacs, Rubymine, etc.)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以选择安装任何IDE来编辑代码（Sublime, Visual Studio Code, vim, Emacs, Rubymine等）
- en: 'All code examples have been written to work with Ruby versions 2.6.10 and 3.0
    (or above). Some of the examples will need previous versions of Ruby (i.e. 2.6.10)
    to work with previous versions of Ruby on Rails (e.g. Ruby on Rails 5), but to
    guarantee that they work the same way as in this chapter, you should try to install
    the latest version of Ruby. You may get the installer for different operating
    systems here: [https://www.ruby-lang.org/en/downloads/](https://www.ruby-lang.org/en/downloads/).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码示例都已编写以与Ruby版本2.6.10和3.0（或更高版本）兼容。其中一些示例可能需要以前的Ruby版本（即2.6.10）才能与以前的Ruby
    on Rails版本（例如Ruby on Rails 5）兼容，但为了确保它们与本章中的方式相同，您应该尝试安装最新的Ruby版本。您可以从这里获取不同操作系统的安装程序：[https://www.ruby-lang.org/en/downloads/](https://www.ruby-lang.org/en/downloads/).
- en: 'Additionally, to be able to use different versions of Ruby, I would also suggest
    you install rbenv from this GitHub repository: [https://github.com/rbenv/rbenv](https://github.com/rbenv/rbenv).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了能够使用不同版本的Ruby，我建议您从以下GitHub仓库安装rbenv：[https://github.com/rbenv/rbenv](https://github.com/rbenv/rbenv).
- en: The code presented in this book is available at [https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码可在[https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails)找到。
- en: Ruby is meant to be read as sentences
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby的设计意图是像句子一样阅读
- en: 'Having said all that about Ruby, let’s get our hands dirty and start with the
    most basic of concepts. You already know about PHP variables. Variables hold information
    that can be used and referenced in our program. Also, PHP is a dynamically typed
    language, which means that the PHP “engine,” which interprets our PHP code, will
    automatically infer the type of content within that variable. That’s to say the
    following two things:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多关于Ruby的话，让我们动手实践，从最基本的概念开始。您已经了解了PHP变量。变量存储信息，可以在我们的程序中使用和引用。此外，PHP是一种动态类型语言，这意味着解释我们的PHP代码的“引擎”将自动推断该变量内的内容类型。也就是说以下两点：
- en: We don’t have to define what type of content our variable has
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要定义变量包含的内容类型
- en: A variable can change types without failing
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量可以在不失败的情况下改变类型
- en: Coming from PHP, you won’t have to break your head to learn a new way of using
    or defining variables with Ruby, as Ruby behaves exactly the same way. However,
    beware that in other languages that are strongly typed, such as Java, a variable
    has to be defined with the type that it will contain and it can’t change types
    over time.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 来自PHP的您不需要费尽脑筋去学习Ruby的新用法或定义变量的新方式，因为Ruby的行为完全相同。然而，请注意，在其他强类型语言中，如Java，变量必须用其将包含的类型定义，并且其类型不能随时间改变。
- en: 'So let’s play around with some variables in PHP:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在PHP中玩一些变量：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Ruby is not much different in this scenario:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，Ruby并没有太大的不同：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For those experienced PHP developers reading this whose eyes might be bleeding
    from my lack of using `$` symbol. Another difference between PHP and Ruby is that
    we do not use any tag to denote PHP code, whereas, in PHP, we use the opening
    PHP tags (`<?php`). So, the main differences (so far) between our snippets are
    the way we call PHP code with the PHP tags and the way we refer to variables.
    While this is a functioning Ruby code, I intentionally wrote the Ruby block very
    PHP-esque to also give you all a glimpse of Ruby’s flexibility. Ruby is extremely
    flexible to the point of being able to bend Ruby’s own behavior. An example of
    this flexibility is that while we can add a semicolon (`;`) at the end of each
    line, it is a Ruby best practice to leave them out. Should this topic of Ruby’s
    flexibility interest you, you may want to check metaprogramming in Ruby. This
    Ruby guide is a great starting point:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些阅读此文档且可能因我没有使用`$`符号而眼睛发红的经验丰富的PHP开发者。PHP和Ruby之间的另一个区别是，我们不需要任何标签来表示PHP代码，而在PHP中，我们使用开头的PHP标签（`<?php`）。因此，我们片段之间的主要区别（到目前为止）是我们调用PHP代码的方式和引用变量的方式。虽然这是一段有效的Ruby代码，但我故意将其写成PHP风格，以便让您也一窥Ruby的灵活性。Ruby非常灵活，甚至可以弯曲Ruby自己的行为。这种灵活性的一个例子是，虽然我们可以在每行末尾添加分号（`;`），但Ruby的最佳实践是省略它们。如果您对Ruby的灵活性感兴趣，您可能想查看Ruby的元编程。这是一份很好的起点指南：
- en: '[https://www.rubyguides.com/2016/04/metaprogramming-in-the-wild/](https://www.rubyguides.com/2016/04/metaprogramming-in-the-wild/)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.rubyguides.com/2016/04/metaprogramming-in-the-wild/](https://www.rubyguides.com/2016/04/metaprogramming-in-the-wild/)'
- en: But let’s not get ahead of ourselves, as this topic is really a complex one
    – at least for a beginner Ruby programmer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不要急于求成，因为这个主题真的很复杂——至少对于一个初学者Ruby程序员来说是这样。
- en: 'Given the preceding code in PHP, let´s now determine whether the name is empty.
    In PHP, you would use the `empty` internal function. We surround it with another
    internal function called `var_dump` to show the contents of the empty function
    result:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的PHP代码，现在让我们确定名字是否为空。在PHP中，你会使用`empty`内部函数。我们用另一个内部函数`var_dump`包围它，以显示`empty`函数的结果内容：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will output the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'According to the documentation of the `empty` function, this is `false` because
    the name is not an empty string. Now, let’s try that in Ruby:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`empty`函数的文档，这是`false`，因为名字不是一个空字符串。现在，让我们在Ruby中尝试一下：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are a couple of things that we have to notice here. The first thing that
    comes to mind is that this is read almost as a sentence. This is one of the key
    points to how the Ruby community has come together and used Ruby to make code
    that is read by humans. For the most part, you should avoid writing comments on
    your code unless it’s for copyright and/or it does require an explanation. Ruby
    goes as far as having a strange way to write multiline comments. If I were to
    write a multiline comment on my code, I would have to look the syntax up because
    I’ve never used that notation. That’s not to say that you can’t or that you shouldn’t.
    It’s there for a reason. It simply means that the Ruby community seldom uses that
    notation. To write a comment in Ruby, you would simply add the hashtag symbol
    (`#`) as the first character on a line:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，有几个需要注意的地方。首先想到的是，这几乎就像一个句子一样被阅读。这是Ruby社区如何聚集在一起并使用Ruby编写人类可读代码的关键点之一。在大多数情况下，你应该避免在代码中添加注释，除非它是版权声明和/或确实需要解释。Ruby甚至有一种奇怪的方式来编写多行注释。如果我要在我的代码上写多行注释，我必须查找语法，因为我从未使用过那种符号。这并不是说你不能或你不应该这样做。它有它的原因。这仅仅意味着Ruby社区很少使用那种符号。要在Ruby中添加注释，你只需在行首添加井号符号（`#`）：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you know from comments within a snippet of code, this line will be ignored
    by Ruby. Keep in mind that a programming language, just like a spoken language,
    evolves due to its use. The best of tools may be lost just because no one uses
    them. Part of learning a language also involves learning the usage of the tools
    and best practices. This includes knowing what the Ruby community has decided
    not to exploit and what to use. So, while the community rarely uses multiline
    comments, all Ruby developers will take advantage of one of its most powerful
    tools: objects.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从代码片段中的注释中知道的那样，这一行将被Ruby忽略。请记住，编程语言，就像 spoken language，会因使用而演变。最好的工具可能因为没有人使用而丢失。学习语言的一部分也涉及到学习工具的使用和最佳实践。这包括了解Ruby社区决定不利用什么以及使用什么。因此，尽管社区很少使用多行注释，但所有Ruby开发者都会利用其最强大的工具之一：对象。
- en: Everything is an object
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切都是对象
- en: 'The second thing that came to my mind while reading the previous code is that
    we are calling a method on a string. Now, let’s step back a bit, and this is where
    we start looking at code through our newbie set of Ruby eyes. Our variable name
    contains a string. Does this mean that our name is an object? Well, the short
    answer is *Yes*. Almost everything in Ruby is an object. I know this might seem
    as if we’re skipping a few chapters, but bear with me. We will see Ruby’s object-oriented
    syntax in [*Chapter 5*](B19230_05.xhtml#_idTextAnchor080). For now, let’s take
    this a step further within our code by getting what type of object our variable
    has with the following line:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读之前的代码时，我脑海中浮现的第二件事是我们正在对一个字符串调用一个方法。现在，让我们稍微退后一点，这就是我们开始用新手的眼光审视Ruby代码的地方。我们的变量名包含一个字符串。这意味着我们的名字是一个对象吗？嗯，简短的答案是*是的*。在Ruby中，几乎所有东西都是一个对象。我知道这可能会感觉像是我们跳过了几章，但请耐心等待。我们将在[*第五章*](B19230_05.xhtml#_idTextAnchor080)中看到Ruby的面向对象语法。现在，让我们通过以下行进一步在我们的代码中探索我们的变量具有哪种类型的对象：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will return the type of class of our object (in this specific case, `String`).
    We are able to do the same with the rest of our variables and we would get similar
    values (`Integer`, `Float`, `TrueClass`, or `Array`). And to take this even further
    to prove my point that almost everything in Ruby is an object, let’s read the
    following example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回我们对象所属的类类型（在这个特定案例中，`String`）。我们能够用其他变量做同样的事情，我们会得到类似的价值（`Integer`、`Float`、`TrueClass`或`Array`）。为了进一步证明我的观点，即Ruby中几乎一切都是对象，让我们阅读以下示例：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will also return a `String` type. So, bear that in mind when you’re writing
    Ruby code. Now, let’s go back to the initial example with the `empty` function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将返回一个`String`类型。所以，当你编写Ruby代码时，请记住这一点。现在，让我们回到最初的带有`empty`函数的例子：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The third thing we also notice is that we are actually asking a question. This
    baffled me the first time I saw it. How do you know when to ask? Is Ruby *so*
    intuitive that you can actually ask questions? What type of sorcery is this? Unfortunately,
    the truth is far less ominous than the code itself. In Ruby, we can name a function
    or a method with the question mark symbol as part of the name, solely to improve
    readability. It does not have any special execution or meaning to the Ruby interpreter.
    We are just able to name a method/function like that. Having said that, by convention,
    Ruby developers use the question mark to hint that we will return a Boolean value.
    In this case, it merely answers the question about the emptiness of the variable
    name. Simply put, if the name is empty, the question will return a `true` value,
    and vice versa. This naming technique is part of the Ruby philosophy to make our
    whole code readable. Additionally, this type of code style is permeated throughout
    many of Ruby’s internal classes. Some methods that are attached to number objects
    and array objects are an example of this. Here are a few examples:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到第三点是，我们实际上是在提问。这让我第一次看到它时感到困惑。你如何知道何时提问？Ruby是否真的如此直观，以至于你可以提问？这是什么魔法？不幸的是，事实远没有代码本身那么神秘。在Ruby中，我们可以将函数或方法命名为包含问号符号的一部分，仅为了提高可读性。它对Ruby解释器没有特殊的执行或含义。我们只是能够以这种方式命名方法/函数。话虽如此，按照惯例，Ruby开发者使用问号来暗示我们将返回一个布尔值。在这种情况下，它仅仅回答了关于变量名称是否为空的提问。简单来说，如果名称为空，则提问将返回`true`值，反之亦然。这种命名技术是Ruby哲学的一部分，旨在使我们的整个代码可读。此外，这种代码风格贯穿于Ruby的许多内部类中。一些附加到数字对象和数组对象的方法就是这种风格的例子。以下是一些示例：
- en: '`.``odd?`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.``odd?`'
- en: '`.``even?`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.``even?`'
- en: '`.``include?`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.``include?`'
- en: 'All these examples were named like that for the sole purpose of readability
    and nothing more. Some of them are even shared between different classes but have
    their own implementation for each type. While we are currently looking at the
    question mark symbol, let’s take a peek at a similar symbol: the exclamation point
    (`!`). Also known as a bang, it has a slightly different connotation within Ruby
    developers. Let’s look at it with an example.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例都是以这种命名方式命名的，仅为了提高可读性，没有其他原因。其中一些甚至在不同的类之间共享，但每个类型都有自己的实现。当我们目前正在查看问号符号时，让我们看一下一个类似的符号：感叹号（`!`）。在Ruby开发者中，它有一个稍微不同的含义。让我们用一个例子来看看。
- en: 'Let’s show the name in uppercase letters. In PHP, we would write the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们展示名称的大写字母形式。在PHP中，我们会写出以下代码：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In Ruby, the same can be accomplished with the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby中，可以通过以下代码实现相同的功能：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In both cases, this will return the name in uppercase (`BERNARD`). However,
    if we make any additional references to the `name` variable, the variable will
    remain unchanged:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，这将返回名称的大写形式（`BERNARD`）。然而，如果我们对`name`变量进行任何其他引用，变量将保持不变：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This would return the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下结果：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: But what happens if we add the bang symbol (`!`)?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们添加感叹号（`!`）会发生什么呢？
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will return the name in uppercase twice:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回名称的大写形式两次：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The bang symbol in fact modifies the variable contents permanently. Functions
    that are named with the bang symbol are referred to as `String` and `Array` classes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，感叹号符号会永久地修改变量内容。使用感叹号命名的函数被称为`String`和`Array`类：
- en: '`.``downcase!`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.``downcase!`'
- en: '`.``reverse!`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.``reverse!`'
- en: '`.``strip!`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.``strip!`'
- en: '`.``flatten!`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.``flatten!`'
- en: We can infer what they do just from reading them, but we now know what the bang
    symbol means in this context. Be careful when using these, but also don’t be shy
    of using them when the use case requires it. Now, when you read Ruby code, you
    will be aware of the question mark (`?`) and the bang (`!`) symbol.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过阅读它们来推断它们的功能，但现在我们知道了在这个上下文中感叹号符号的含义。使用时要小心，但如果使用场景需要，也不要害羞地使用它们。现在，当你阅读
    Ruby 代码时，你会意识到问号（`?`）和感叹号（`!`）符号的存在。
- en: Transitioning to Ruby
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转向 Ruby
- en: So far, we’ve seen examples in which our code looks very similar to PHP. As
    I mentioned before, I purposely did this to showcase the flexibility of Ruby.
    This makes the change to Ruby easier than other languages in which the syntax
    is a lot different than Ruby. However, this is only the beginning of our journey
    to becoming a Ruby developer. If we want to be able to read and write Ruby code
    and snippets like seasoned Ruby developers, we will need to see how the community
    has come to make Ruby code. In short, while we can write our code similar to other
    languages, we should avoid this practice and, in the process, learn about what
    Ruby has to offer to make our code more and more readable.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一些例子，我们的代码看起来非常类似于 PHP。正如我之前提到的，我故意这样做是为了展示 Ruby 的灵活性。这使得将代码转换为
    Ruby 比其他语法与 Ruby 差异很大的语言要容易得多。然而，这仅仅是我们成为 Ruby 开发者旅程的开始。如果我们想要能够像经验丰富的 Ruby 开发者一样阅读和编写
    Ruby 代码和代码片段，我们需要了解社区是如何使 Ruby 代码的。简而言之，虽然我们可以将代码编写得类似于其他语言，但我们应该避免这种做法，在这个过程中，了解
    Ruby 可以提供什么来使我们的代码越来越易于阅读。
- en: The first step we are going to take toward this goal is to remove unnecessary
    syntax within our code. To do this, we also must understand the utility of what
    we are removing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取的第一个步骤是移除代码中的不必要的语法。为了做到这一点，我们也必须理解我们正在移除的内容的用途。
- en: 'Let’s take for an example our original code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以我们的原始代码为例：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In Ruby, the semicolon can be useful to separate multiline code into a single
    line dividing each line with a semicolon. If we took the name and the example
    to turn it into uppercase, we would have the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，分号可以用来将多行代码合并成一行，每行用分号分隔。如果我们把名字和例子转换成大写，我们会得到以下内容：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And this works perfectly fine. But remember, we are trying to make our code
    more readable. This is not more readable. It’s the opposite. And, if we are not
    going to write our whole code in a single line, then let’s take the original snippet
    (in multiple lines), and remove every single semicolon. This is starting to look
    more like Ruby:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得非常好。但请记住，我们正在努力使我们的代码更易于阅读。这并不更易于阅读。相反。而且，如果我们不打算将整个代码写在一行中，那么让我们保留原始代码片段（多行），并移除每个分号。这开始看起来更像
    Ruby：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This certainly seems to improve readability slightly by removing unused characters,
    but we are not finished. Let’s put this into practice with another example. Let’s
    write an example that will print out the string `This person is allergic to chocolate`
    if the value of the `$chocolate_allergy` variable is set to `true`. Because of
    our background in PHP, we might be compelled to write something similar to PHP.
    In PHP, we would write the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移除未使用的字符，这确实稍微提高了可读性，但我们还没有完成。让我们用另一个例子来实践。让我们编写一个示例，如果 `$chocolate_allergy`
    变量的值为 `true`，则将打印出字符串 `This person is allergic to chocolate`。由于我们的 PHP 背景，我们可能会被促使编写类似于
    PHP 的代码。在 PHP 中，我们会编写以下内容：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With this in mind, we would write the following in Ruby:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们会在 Ruby 中编写以下代码：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This works fine, but it still looks a lot like PHP. An intermediate Ruby developer
    would most likely write something like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得很好，但它仍然看起来很像 PHP。一个中级 Ruby 开发者可能会写类似以下的内容：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is getting more and more readable by the second. But it also brings a
    couple of new practices to the table. For starters, the `puts` sentence is not
    surrounded by parenthesis. This is because, in Ruby, the use of parenthesis is
    optional for functions and methods. This is extremely useful as it’s starting
    to read like plain English. It works with functions with multiple arguments, too.
    As an example, an implemented function could very well look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得代码的可读性每秒都在提高。但它也带来了一些新的实践。首先，`puts` 语句没有被括号包围。这是因为，在 Ruby 中，对于函数和方法，括号的使用是可选的。这非常有用，因为它开始看起来像普通的英语。它也适用于具有多个参数的函数。例如，一个实现的函数可能看起来像这样：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Of course, this becomes cumbersome if we need to call nested functions. Let’s
    take this example with two functions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们需要调用嵌套函数，这会变得很繁琐。让我们看看以下两个函数的例子：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `concatenate` function takes two strings and prints out both strings joined
    with a space between them. The second function just turns the input string into
    an uppercase string and returns the value. And this is where it could become problematic
    if we failed to use the parenthesis. If we wanted to concatenate the two strings
    and turn each string into an uppercase string, we could try the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`concatenate` 函数接受两个字符串，并将它们之间用空格连接的字符串打印出来。第二个函数只是将输入字符串转换成大写字符串并返回值。如果我们没有使用括号，这可能会成为问题。如果我们想将两个字符串连接起来，并将每个字符串转换成大写字符串，我们可以尝试以下操作：'
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But we would fail miserably because the Ruby interpreter doesn’t know that
    `"something"` is the argument for the `to_upper` function. We can easily fix this
    with parenthesis:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们会失败得很惨，因为 Ruby 解释器不知道 `"something"` 是 `to_upper` 函数的参数。我们可以通过括号轻松解决这个问题：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Be careful with this knowledge as, like everything else, if overdone, it can
    be detrimental to our code’s readability. There are two additional points that
    we need to consider while deciding whether to use parenthesis. The first is that
    these rules also apply to the definition of the function. So, the `concatenate`
    function can be defined like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个知识，就像其他所有事情一样，如果过度使用，可能会损害我们代码的可读性。在决定是否使用括号时，我们需要考虑两个额外的点。第一个是，这些规则也适用于函数的定义。因此，`concatenate`
    函数可以这样定义：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second point is that the rule also applies to functions with no arguments
    – that is, we may remove the parenthesis from them, too. Let’s take the following
    as an example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点是，这个规则也适用于没有参数的函数——也就是说，我们也可以从它们中移除括号。让我们以下面的例子作为参考：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will now become the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将变成以下内容：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: More importantly, the use of methods that use the question mark and destructive
    methods (`!`) now make perfect sense for readability.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，使用带问号的方法和破坏性方法（`!`）现在对可读性来说非常合理。
- en: 'Let’s look at the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下内容：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This becomes as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这变成如下所示：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As another example, let’s take the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，让我们看看以下内容：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This now becomes as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在变成如下所示：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The last point we will look at now is related to how Ruby behaves with the
    return of values. While a method can explicitly return a value with the `return`
    keyword, Ruby doesn’t need this keyword. Within functions and methods, Ruby automatically
    returns the last value that is referenced. Let’s use the following example for
    this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要讨论的最后一点与 Ruby 在返回值方面的行为有关。虽然方法可以使用 `return` 关键字显式返回一个值，但 Ruby 不需要这个关键字。在函数和方法内部，Ruby
    会自动返回最后引用的值。让我们用以下例子来说明这一点：
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That example would turn into this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 那个例子将变成这样：
- en: '[PRE33]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You will see a lot of Ruby code like this. It can be intimidating and confusing
    at first, but once you understand what Ruby is doing, it simply starts to make
    more sense.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到很多这样的 Ruby 代码。一开始可能会觉得令人畏惧和困惑，但一旦你理解了 Ruby 在做什么，它就会变得更有意义。
- en: 'As you have probably realized by now, Ruby’s creator put a lot of emphasis
    on these tools to make it easier to write readable code. The community adopted
    this ideology and put it into practice. We not only see code using these conventions
    and rules to increment readability but we also see Ruby programmers adopt other
    conventions that, while they are not part of the Ruby rules per se, make perfect
    sense when used in context. I’m referring to variable and method naming. Because
    Ruby developers will try to make their code read like plain English, they will
    spend a lot of time thinking about how to name methods and variables to make the
    code more readable. For this reason, snake-case is more often used in Ruby, as
    it helps with readability. With that in mind, let’s look at this example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如你现在可能已经意识到的，Ruby 的创造者非常重视这些工具，以便更容易编写可读的代码。社区也采纳了这种理念并将其付诸实践。我们不仅看到使用这些约定和规则来提高可读性的代码，还看到
    Ruby 程序员采用其他约定，虽然它们本身不是 Ruby 规则的一部分，但在特定上下文中使用时却非常合理。我指的是变量和方法命名。因为 Ruby 开发者会努力使他们的代码看起来像普通英语，所以他们会在如何命名方法和变量以使代码更易读上花费大量时间。因此，在
    Ruby 中更常使用蛇形命名法，因为它有助于提高可读性。考虑到这一点，让我们看看这个例子：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can still improve its readability. And it wouldn’t just be a syntactic change;
    it would also involve variable names and even defining a method, just to improve
    readability. So, a seasoned Ruby developer might write the final snippet for this
    example as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以提升其可读性。这不仅仅是一个语法上的改变；它还涉及到变量名甚至定义一个方法，只是为了提高可读性。因此，一位经验丰富的Ruby开发者可能会为这个例子编写以下最终的代码片段：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, Ruby developers will go very far to make the code as readable
    as plain English. Of course, this is not always feasible and sometimes it’s not
    practical as it at times requires putting a lot of effort into writing even something
    simple, but for the most part, as long as it’s readable, by following these guidelines,
    other developers will thank you, not just the Ruby ones.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Ruby开发者会尽力使代码尽可能像普通英语一样易于阅读。当然，这并不总是可行的，有时它可能并不实用，因为它有时需要投入大量的努力来编写即使是简单的东西，但大部分情况下，只要它是可读的，遵循这些指南，其他开发者会感谢你，而不仅仅是Ruby开发者。
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered the syntactic differences and similarities between
    PHP and Ruby, Ruby’s tools for readability, and Ruby’s syntactic flexibility.
    We also learned about the question mark (`?`) and the exclamation or bang symbol
    (`!`). Making it this far means that you are indeed trying to reuse your previous
    programming skills but with a new language: Ruby. This is a great start because
    you can skip one of the most difficult parts of learning a new language from scratch:
    the logical part. And while we’ve only seen the surface of Ruby, more importantly,
    we got a clear glimpse of how Ruby developers think when they’re writing code.
    We learned that to a Ruby developer, readability comes first. We not only use
    syntax and language constructs to make this possible but we also use objects to
    increase the code’s legibleness. The more it reads like a sentence, the better.
    We looked at some simple examples of Ruby, and while you could follow along, it
    was not the purpose of the exercise. It was more to pique your interest.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了PHP和Ruby之间的语法差异和相似之处，Ruby的可读性工具，以及Ruby的语法灵活性。我们还学习了问号（`?`）和感叹号或叹号符号（`!`）。走到这一步意味着你确实在尝试重用你之前的编程技能，但使用的是一门新语言：Ruby。这是一个很好的开始，因为你可以跳过学习一门新语言中最困难的部分之一：逻辑部分。虽然我们只看到了Ruby的表面，更重要的是，我们清楚地看到了Ruby开发者编写代码时的思维方式。我们了解到，对于Ruby开发者来说，可读性是最重要的。我们不仅使用语法和语言结构来实现这一点，我们还使用对象来增加代码的可读性。它读起来越像句子，就越好。我们查看了一些简单的Ruby示例，虽然你可以跟随，但这并不是练习的目的。它更多的是为了激发你的兴趣。
- en: To move along on this learning path, we now need the proper tools to start writing
    and running Ruby code. In the next chapter, we will look at the different ways
    to install Ruby and set up our local environment so that we can start learning
    real examples of Ruby, and eventually follow along in the process.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续学习这条学习路径，我们现在需要适当的工具来开始编写和运行Ruby代码。在下一章中，我们将探讨安装Ruby的不同方法以及设置我们的本地环境，这样我们就可以开始学习Ruby的真实示例，并最终跟随这个过程。
