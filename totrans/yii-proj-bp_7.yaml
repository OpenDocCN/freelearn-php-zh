- en: Chapter 7. Creating a Management Module for the CMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our next project, we will be expanding upon the content management system
    we built in [Chapter 6](ch06.html "Chapter 6. Building a Content Management System"),
    *Building a Content Management System*, by migrating the management functionality
    into a module. Moving this functionality into a module will decouple administrative
    behaviors from the presentation layer of our application. This change will also
    enable us to develop and deploy administrative changes without having to make
    changes to our main application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our finished project will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Management Module for the CMS](img/7734OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we'll expanding upon the work we did in [Chapter 6](ch06.html "Chapter 6. Building
    a Content Management System"), *Building a Content Management System*, the only
    prerequisite for this chapter is the completed source code from the previous chapter.
    You can either build the project yourself, or you can use the completed source
    code available in the project resources folder from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What are modules?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Yii, modules are self-contained packages that operate independently of a
    Yii application but must reside within an existing application or module. Modules
    can additionally have as much or as little integration with our core application
    as we desire. In many aspects, modules are identical to Yii applications in that
    they have controllers, models, views, configurations, and components. This functionality
    allows us to deploy and manage code independently of our main application. It
    also provides us with greater usability if we choose to reuse our module across
    multiple projects. For our application, we'll be using our modules solely to separate
    the management of our application from the presentation layer and to independently
    deploy our application without having to make changes to our main application
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about Yii modules can be found in the official Yii guide located
    at [http://www.yiiframework.com/doc/guide/1.1/en/basics.module](http://www.yiiframework.com/doc/guide/1.1/en/basics.module).
  prefs: []
  type: TYPE_NORMAL
- en: Describing the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our dashboard module can be broken down into several components:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing and configuring the dashboard module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling custom routing for our module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the management functionality out of our application and into the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding file upload capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing the module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first component of this project will consist of creating and configuring
    our module so that it integrates with our primary application. We'll accomplish
    this by making several changes to our main configuration file as well as creating
    the basic structure for the module that we'll be using. We'll also go over managing
    our module assets independently of our main application.
  prefs: []
  type: TYPE_NORMAL
- en: Routing with a module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Yii framework, the default routes are defined by the name of the module
    combined with the default routes that are specified within `CUrlManager`. Unfortunately,
    Yii does not natively provide the functionality to define our own custom routes
    for a module without modifying the routes specified in `CUrlManager`. To get around
    this restriction, we'll be modifying our `CMSURLManager`, which we defined in
    [Chapter 6](ch06.html "Chapter 6. Building a Content Management System"), *Building
    a Content Management System*, in order to allow us to store and configure routes
    independently of our main application. When completed, we'll have a `routes.php`
    file in the `protected/modules/<module>/config/` file; this will contain all the
    custom routes for our module and will integrate with our main application without
    altering the application's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the management functionality into the module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The third component of this project will entail moving the management functionality
    from our controls to the module's controllers. This will additionally involve
    moving the presentation layers out of the theme we created in the previous chapter
    and into the module itself. For additional security and user experience, we'll
    also be modifying how our module handles errors for both unauthenticated and unauthorized
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Adding file upload capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make our content management system more versatile, we'll also be adding a
    file upload capability that will allow us to upload files from our content page
    and store them in our database. We'll also implement the functionality necessary
    to view these files in a file manager and additionally, to delete them.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we'll go over the different deployment options that we can use to easily
    deploy our module independently of our main application. Using a combination of
    both Git and Composer, we can deploy our module in a way that makes the most sense
    for the type of project we are using.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this project, we''ll be starting where we left off in the previous chapter,
    [Chapter 6](ch06.html "Chapter 6. Building a Content Management System"), *Building
    a Content Management System*. For your convenience, a skeleton project has been
    included in the project resources folder for this chapter that contains the foundation
    that we''ll be starting with. Begin by copying the source code over to a new folder,
    and make sure that it is available at a different URL. In this chapter, I''ll
    be using `http://chapter7.example.com` as our example URL. After importing the
    database and updating the database configuration using the instructions provided
    in the previous chapter, you should see the home page of our blog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Initializing the project](img/7734OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating the module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our application is set up, we can begin to create our module. We''ll
    start by creating the basic folder structure within our `protected/modules` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the basic structure of our module looks identical to that of
    our main application. With our folder structure in place, we now need to create
    the `DashboardModule` class that we''ll later tell Yii about so that it knows
    what to load. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new file, called `DashboardModule.php`, within `protected/modules/dashboard`
    with the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create an `init()` method for the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the module, we''ll want to set the `layoutPath` so that our module knows
    what layout to provide our views with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll also want to tell our module to automatically import the contents of
    the `components` directory in which we''ll be storing classes later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will tell Yii's autoloader to automatically load classes in the `components`
    folder. This is the same behavior that is used within Yii to load the classes
    registered in the import section of our `protected/config/main.php` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we''ll want to set a few custom components for our module—mainly the
    error handler—so that we can handle errors that occur within our module in a different
    manner from the errors that occur within our main application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then need to create two new classes; the first will be a controller
    component that all controllers within our module will extend from, and the second
    will be the default controller that will be accessed when no routes are specified.
    Within `protected/modules/dashboard/components/`, create a new file called `DashboardController.php`
    with the following definition. We''ll be adding more information to this component
    once we''ve registered our module with Yii:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create `DefaultController.php` inside `protected/modules/dashboard/controllers`.
    We''ll also specify our `actionIndex()` method so that, once we register our module
    with Yii, we can see something:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Registering the module with Yii
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can see anything in our module, we first need to tell Yii about our
    module. For this, we simply need to specify the module name within the modules
    section of our `main.php` file at `protected/config/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you navigate to `http://chapter7.example.com/dashboard`, you should
    see the text **Hello World** displayed. This is the simplest way to register a
    module with Yii. Unfortunately, this method requires us to make a change to our
    configuration file every time we want to use a new module, which in turn means
    we have to change the application code every time we use a new module. Another
    method of loading our module is to create a `protected/config/modules.php` file
    that we register in the modules section, instead. This allows us to simply change
    a cache setting outside our application without having to modify the code within
    our configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, first change the modules section of `main.php` at `protected/config/`
    so that it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a `modules.php` file at `protected/config/`. We''ll start by declaring
    where the `modules` directory is located, and the location where our generated
    configuration file should be cached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll then check to see whether a cached file already exists. If it does,
    we''ll simply return it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If a cached file doesn''t exist, we''ll iterate through all the folders in
    the `protected/modules` directory to retrieve all the module names and push them
    to an array. Since some Yii modules require additional configuration, we''ll tell
    our loader to inject anything in `main.php` at `protected/modules/<module>/config/`
    as options for the module to use. When we''ve compiled a list of all the modules
    we''re going to load, we''ll write that out as a serialized array to a file within
    our `protected/runtime` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting file that is generated then looks as follows and is returned
    all the way up to our `main.php` file at `protected/config/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we ever want to add a new module, we simply need to delete the `module.config.php`
    file at `protected/runtime/`. The first request to hit the system will immediately
    regenerate the updated file.
  prefs: []
  type: TYPE_NORMAL
- en: While slightly more expensive in terms of disk operation, this method of loading
    modules enables us to dynamically load modules with Yii just by adding them to
    the `modules` directory. It also eliminates any changes we need to make to our
    application in order to add a new module, which in turn means that we'll be less
    likely to introduce new behaviors or bugs to our main application while adding
    a new module.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom routes to a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While Yii will perform a lot of module routing for free, we have to add our
    routes to our `CUrlManager` configuration in `main.php` at `protected/config/`
    in order for our module to have any custom routing. While it''s easy to execute,
    this method does not keep our module and application configurations sufficiently
    separated. To get around this limitation in Yii, we need to modify the `CMSUrlManager`
    class that we created in the previous chapter in order to retrieve custom module
    routes that we define. This enables us to write routes as part of our module rather
    than as part of our application. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new file, `routes.php`, in `protected/modules/dashboard/config/`,
    that contains the following. For this module, we''ll define a custom route for
    our save actions to be loaded from:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This example is purely to illustrate how to add custom routing to a module,
    since Yii does not support it natively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With our custom route defined, we''ll next update `CMSUrlManager` to automatically
    import these rules. Open `CMSUrlManager.php` at `protected/components/`, and add
    the following to the `if` block of the `processRules()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll finally define a `addModuleRules()` method that will search all of our
    installed modules for a `routes.php` file at `config/` and register them with
    Yii:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, our dashboard module will be able to handle nonstandard routes without
    having to update a configuration file within our main application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have registered our application with Yii and defined our custom
    routes, we can start working on our controllers. First, we should work on our
    `DashboardController` component so that our controllers automatically inherit
    some common behaviors. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within our `DashboardController.php` component, we should first define our
    `accessRules()` method. This will ensure that only administrators have access
    to the dashboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll define the `default` layout that we''ll want to use throughout
    the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll create a custom error action that will prevent both unauthenticated
    users and unauthorized users from accessing our module. By default, if Yii encounters
    an unauthorized error, it will simply return a 403 error. Our error action will
    improve the user experience by redirecting unauthenticated users to the login
    page with a next `$_GET` parameter so that they can be returned to the exact page
    they wanted to go to after they have been authenticated. If a user is simply unauthorized,
    on the other hand, it will display the appropriate error and deny them access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete this, redirect the `$_GET` parameter. We also need to make a change
    to our `SiteController.php` file at `protected/controllers/` so that it knows
    how to handle the parameter. Simply replace the redirect with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to implement a way to manage our assets independently of our
    main application. Many module implementations simple add assets to a globally
    available `assets` folder. This implementation makes it very difficult to ensure
    that all traces of a module have been removed. An easier way of managing assets
    for modules is to create a folder for all of our module-specific assets to reside
    in, and then, publish that folder using `CAssetManager` independently of our application.
    This way, if we make any changes to our module assets, they won''t affect our
    main application. In our `SiteController`, we should define the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since this method is a getter and since it returns the path where the assets
    are published, we can call it from our layout file as follows (using the `dashboard.css`
    file that should be copied from the project resources folder to your module''s
    `assets` folder):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Migrating the functionality to the module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our module is set up, we can start by moving the functionality from
    our application controllers and theme into our dashboard module. We''ll go over
    everything that is needed for each model: Categories, Content, and Users.'
  prefs: []
  type: TYPE_NORMAL
- en: Migrating content management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this next section, we will migrate all of the management functionalities
    we built in the previous chapter into our new module:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with our `ContentController`, we first want to remove the `actionAdmin()`,
    `actionSave()`, and `actionDelete()` methods from the `ContentController.php`
    file at `protected/controllers/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we should remove the access control properties for the actions we just
    deleted from our `ContentController`. The restored `accessRules()` method should
    look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With our `ContentController` stripped of our administrative behaviors, we can
    begin moving the functionality into our `DefaultController.php` file at `protected/modules/dashboard/controllers/`,
    which we''ll be using as our `ContentController`. We''ll start by adding our `accessRules()`
    method to our `DefaultController`. Since we want to inherit the rules defined
    in `DashboardController.php` at `components/`, we''ll use `CMap::mergeArray()`
    to merge the parent rules with our newly defined rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Do the naming conventions have you confused? If you don't want to store the
    content-related functionality in `DefaultController`, you can set the `$defaultController`
    property in `DashboardModule` to `content`. This will override Yii's default behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll redefine our `loadModel()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll define our `actionDelete()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we''ll write an index method to display all of the content entries on
    our database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll write a method to both create new content entries and edit
    existing content entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we should copy our `save.php` file located at `protected/modules/dashboard/views/default/`
    from our project resources folder into our module. If you haven't done so already,
    copy the `default.php` layout file located at `protected/modules/dashboard/views/layouts/`
    into your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we need to make sure that our `index` view file is properly updated
    so that it links to the appropriate controller actions. If you were simply to
    copy the view from the theme file, you''d notice that none of the links work.
    To correct these links, we need to update our `createUrl` calls to point to the
    `save()` method our module''s `DefaultController`, and update the `CButtonColumn`
    links to point to our module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we''re finished, we''ll be able to view all the articles in our CMS,
    delete them, edit them, and navigate to the frontend view—all from a single interface,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Migrating content management](img/7734OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Migrating categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The changes for our users and categories controllers are going to be very similar—let''s
    work through them. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with our `CategoryController`, we first want to remove the `actionAdmin()`,
    `actionSave()`, and `actionDelete()` methods from the `CategoryController.php`
    file at `protected/controllers/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we should remove the access control properties for the actions we just
    deleted from our `CategoryController`. The restored `accessRules()` method should
    look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our new `accessRules()` method for our `CategoryController.php` file at `protected/modules/dashboard/controllers/`
    will then look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll reimplement all of the management actions with updated redirects,
    starting with our `actionIndex()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then re-implement the save method and modify it to work in our module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then reimplement the delete method in our module and update the redirects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll update the `loadModel()` method so that it works without our
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then copy the view files' `index.php` located at `protected/modules/dashboard/views/category/`
    and `save.php` located at `protected/modules/dashboard/views/category/` from the
    project resources folder into our module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice once again that we''ve updated our `CButtonColumn` links to point to
    our module rather than to the home page routes we had defined earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our final category management interface will look as follows and will behave
    identically to how our content management interface behaves:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Migrating categories](img/7734OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing user management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, we didn''t implement a UI for user management; let''s
    go ahead and implement that functionality now so that our dashboard module fully
    encompasses all the management functionality. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating a new controller, `UserController.php`, in `protected/modules/dashboard/controllers`
    with the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll define our `accessRules()` method for this controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll implement a `loadModel()` utility method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll update our delete action so that it redirects properly within
    our module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we''ll reimplement the index action to display a listing of all of our
    users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll migrate our save method into our module. Since we''ve already
    implemented all the core functionality of how our users behave into our User model
    class, the implementation of our `actionSave()` method is straightforward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, copy the `index.php` view file located at `protected/modules/dashboard/views/user/`
    and the `save.php` view file located at `protected/modules/dashboard/views/user/`
    from the project resources folder into your application. Once again, we're left
    with an interface that is identical to our content and category management interfaces:![Implementing
    user management](img/7734OS_07_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uploading files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final component that we'll be adding to our module is a file manager with
    file upload capabilities. For this component, we'll be creating a dedicated controller
    to view all of our uploaded files in paginated format, several new classes to
    handle the actual file upload, and a few view changes to our content save view
    so that we can associate files with a particular article.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than bundling all of this functionality into our `FileController` that
    we'll be building, we'll start by building three different components to handle
    the various aspects of uploading a file. The first class `File` will represent
    a `$_FILES['file']` object and will provide the functionality for saving the file.
    The second class, `FileUpload`, will be our call point for uploading our file
    and will return the appropriate database to us. The final class, `FileUploader`,
    will handle the interactions between the `File` and `FileUpload` class. These
    three classes will ensure that our `FileController` class is clean and will make
    working with the file upload extremely easy.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the File class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start by creating the `File` class, a simple object that represents
    `$_FILES[''file'']`, that we''ll be sending via a `POST` request. Create the `File.php`
    file in `protected/modules/dashboard/components/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: For simplicity, we'll be storing all of our files in the root directory of our
    main application called `/uploads`. Go ahead and create this folder now, and make
    sure that your web server has write access to it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the FileUploader class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next class we''ll be building out is the `FileUploader` class. This class
    will handle the validation and will call the `File` class that we just created
    in order to save the file to the uploads directory. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with the class definition in `FileUploader.php` located at `protected/modules/dashboard/components/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define some private attributes to be used as validators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll create a constructor for this new object that will set some basic
    variables for the validator later on and will also create the `File` object using
    the `$_FILES[''file'']` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll create the `checkServerSettings()` method that we defined earlier.
    This will ensure that we don''t try to upload files that are larger than what
    is defined in our `php.ini` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll create the validators that will validate that the file meets
    the restrictions we put in place earlier. This class will ultimately return an
    array to our `FileUpload` class that we''ll be creating next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating the FileUpload class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last component that we''ll create is the `FileUpload` class that will act
    as an intermediary between our `FileUploader` class and our `FileController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating the `FileUpload.php` file in `protected/modules/dashboard/components/`
    with the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, declare a few properties and the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then create our `_uploadFile()` method that we called in our constructor.
    This method will instantiate a `FileUploader` object and will perform the upload
    before passing it off to our `ContentMetadata` object, where we''ll store the
    reference to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll create the `_handleResourceUpload()` method. This method will
    take the response object returned by the `FileUploader` object and, if the file
    was successfully uploaded, will store the filename of the uploaded file in our
    database so that we can manage it easily. It will also link a particular file
    to a given article:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating the controller for the file manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the functionality in place to upload a file, we need to create
    the controller actions to manage it. We''ll be creating three separate actions:
    an `index` action where all files and their associations can be viewed; a `delete`
    action; and an `upload` action. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating the `FileController` class in `protected/modules/dashboard/controllers`
    with the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then define the `accessRules()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll define our `index` action that will allow us to view all files
    uploaded into our CMS. Since our `ContentMetadata` table might contain other attributes,
    we''ll only be searching against items that have a key of upload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll create an `upload` action that will call our `FileUpload` class.
    After uploading the file or having an error, the action will redirect the user
    to where they came from with either the relative URI to the file, or a useful
    error message generated from our `FileUploader` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we''ll create a `loadModel()` method and a `delete` action to remove files
    from our database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then move on to creating the views for our file manager. The first view
    we''ll create will be an index view, which will consist of a `CListView` container
    that will allow us to easily browse through our images. Add the following to `index.php`
    located at `protected/modules/dashboard/views/file/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll also create the corresponding `itemView` file called `_file.php` located
    at `protected/modules/dashboard/views/file/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we''ll need to update `save.php` at `protected/modules/dashboard/views/default/`
    with a file upload form so that files can be uploaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if you upload a file from the content save screen, the URL of the file
    will be returned back to you for you to add it to your article:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the controller for the file manager](img/7734OS_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Additionally, if you want to view all files uploaded to the CMS, or if you
    want to delete a file, you can navigate to `http://chapter7.example.com/dashboard/files`
    in your web browser or add a link to the sidebar in your `default.php` file at
    `protected/modules/dashboard/views/layouts/`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the controller for the file manager](img/7734OS_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Strategies for deploying our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last topic we should discuss is how we want to deploy our new module alongside
    our application. There are several different deployment strategies that we can
    make use of, each of which has its own advantages and disadvantages. In the next
    section, we'll go over the benefits and downfalls of a few different strategies.
    When the time comes to deploy your module alongside your application, be sure
    to give careful thought to how you want your module and application to be integrated.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying as the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest deployment strategy we can use is to simply commit our module's
    source code directly to our main application. When the time comes to deploy our
    application, our module is automatically included. While incredibly simple and
    basic, this strategy has several disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: First and foremost, it binds the state of our module to our application, which
    makes it more likely that we'll unintentionally introduce bugs or incomplete features
    when we deploy our application. The second disadvantage is that it tightly couples
    our module's state at any given time to our application. The final disadvantage
    is that it makes it very difficult to deploy a module update independently of
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying as a submodule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second deployment strategy is to commit our module code to a completely
    separate repository and include it in our project as a submodule. This method
    not only ensures that our project retrieves the latest code, but it also ensures
    that our module code and application code are properly separated. The alternative
    to using a submodule is to simply clone the module repository into the `protected/modules`
    directory every time we want to run a deployment. While this method is simple,
    it does increase the complexity of our application and requires us to have a detailed
    understanding of Git submodules. Additionally, it is difficult to automate while
    ensuring that deployments don't result in downtime.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying as a Composer dependency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A third strategy is to create a completely separate repository for our module,
    include it into our project as a Composer dependency, and use the `composer/installers`
    package to ensure that the module is placed in the correct directory. While it
    is significantly more complex than the other strategies, this strategy has the
    advantage of ensuring that our module and application code remain separated. It
    also has the advantage of moving deployment-related tasks back to the application
    rather than the module.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot of information on working with modules and overcoming some
    of the limitations that they have. We discussed how to create a module, how to
    integrate it with our application, how to handle custom routing for modules, how
    to migrate the management functionality from a regular Yii application into our
    module, and we also added a file manager and upload capabilities to our CMS. Additionally,
    we covered different strategies for deploying our module alongside our application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create an API module for our application that will
    allow for web services and native applications to connect to our CMS. We'll expand
    upon the topics covered in this chapter, and we'll also cover how we can override
    several core Yii components to make our API flexible and easy to develop with.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing to the next chapter, be sure to review the Yii Class Reference
    at [http://www.yiiframework.com/doc/api/](http://www.yiiframework.com/doc/api/)
    and review all the classes that we used in this chapter.
  prefs: []
  type: TYPE_NORMAL
