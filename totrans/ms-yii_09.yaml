- en: Chapter 9. RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**) is a modern approach for client-server
    communications that decouple the client (such as Bowers and mobile applications)
    from the server components in applications. RESTful implementations enable backend
    implementations to speak a common language (usually, XML or JSON) while taking
    complete advantage of HTTP verbs, such as `GET`, `POST`, `PUT`, and `DELETE`.
    RESTful applications enable us to build stateless, scalable, and uniform applications
    that we can distribute to our clients. With Yii2, we can quickly implement RESTful
    APIs as either a part or the whole of our application.'
  prefs: []
  type: TYPE_NORMAL
- en: ActiveController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest way to create RESTful APIs in Yii2 is to take advantage of `yii\rest\ActiveController`.
    Like `yii\web\Controller`, `yii\rest\ActiveController` provides a controller interface
    that we can implement in our `./controllers` directory. Unlike `yii\web\Controller`,
    implementing `yii\rest\ActiveController` with a `yii\db\ActiveRecord` model will
    immediately create a complete REST API for that model available, with very minimal
    coding. Models implemented with `yii\rest\ActiveController` also make the following
    additional features available out of the box:'
  prefs: []
  type: TYPE_NORMAL
- en: XML and JSON response formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data and HTTP caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Full HTTP verb support (`GET`, `POST`, `PATCH`, `HEAD`, and `OPTIONS`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for HATEOAS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, let''s expose our User model that we created in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*.
    To get started with `yii\rest\ActiveController`, we first need to create a controller
    in our `controllers/` directory called `UserController.php`, which references
    our User model that we created previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to make some configuration changes to our `config/web.php` configuration
    file so that Yii2 can route the correct routes to our newly created controller
    and to ensure that our application can accept JSON input. As we''ve already enabled
    pretty URLs and disabled the script name being displayed in our `urlManager` component,
    we simply need to add a custom URL rule for our user class. This URL rule is an
    instance of `yii\rest\UrlRule`, and it will handle all the required routing for
    our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to modify the base request object that our application uses so
    that it can parse the JSON input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The change to the request parser is added for convenience as JSON is an easy
    input type to work with. Without this change, our application will only be able
    to parse the `application/x-www-form-urlencoded` and `multipart/form-data` request
    formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'By simply adding a few lines of code, we''ve now implemented a complete REST
    API for our `Users` model. The following table exposes a complete list of methods
    that `yii\rest\ActiveController` exposes for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP Method | Endpoint | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/users` | This is a list of all users |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/users/<id>` | This has the information for the user with the given
    `<id>` tag |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/users` | This creates a new user with the data supplied in the
    request body |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | `/users/<id>` | This modifies a user with the given `<id>` tag
    with the data supplied in the request body |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `/users/<id>` | This deletes a user with a given `<id>` tag |'
  prefs: []
  type: TYPE_TB
- en: '| `HEAD` | `/users` | This retrieves the header information |'
  prefs: []
  type: TYPE_TB
- en: '| `HEAD` | `/users/<idl>` | This retrieves the header information for the given
    user `<id>` tag |'
  prefs: []
  type: TYPE_TB
- en: '| `OPTIONS` | `/users` | This retrieves the HTTP options for Ajax-like requests
    |'
  prefs: []
  type: TYPE_TB
- en: '| `OPTIONS` | `/users/<id>` | This retrieves the HTTP options for Ajax-like
    requests for a user with a given `<id>` tag |'
  prefs: []
  type: TYPE_TB
- en: 'An easy way to query against our newly created REST API is to use the command-line
    tool called CURL. For example, to retrieve the headers for our `/users` endpoint,
    we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously, `yii\rest\ActiveRecord` immediately provides us with
    a bunch of useful information, such as CORS headers and pagination details.
  prefs: []
  type: TYPE_NORMAL
- en: 'With CURL, we can also query for the raw data itself. Our API can respond in
    either a JSON or an XML format depending upon the `Accept` headers we submit along
    with our request. The next example illustrates a request that will respond in
    the JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, CURL will return data as a single line. As illustrated in the previous
    command, we're piping the JSON response from our cURL request to a tool called
    **jq** ([https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)), which
    is used to format the data in an easy-to-read format. Alternatively, you can install
    a graphic-based tool of your choice to submit and display responses in an easy-to-read
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we can filter specific fields by passing them as `GET` parameters
    within our request. For example, if we want to just retrieve the first and last
    name of the user with the ID of `1` in our database, we can execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Configuring ActiveController display fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have noticed, `yii\rest\ActiveController` only returns fields that
    are populated from the database and does not return extra fields that you may
    have created (such as a `full_name` field as the concatenation of the first and
    last name) or relations. Additionally, it exposes every field in the database,
    including sensitive data, such as encrypted password hashes. One way to get around
    this limitation is to modify the `fields()` method of our models.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to prevent accidentally exposing our hashed passwords over our
    API, we can implement a custom `fields` method in our `User` model, as follows.
    We can also change the display name of certain fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s query against our API, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We retrieve the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we can expose relational data by implementing the `extraFields()`
    method of our model, as shown in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `extraFields()` method will expose the entire model relationship in our
    response, and it can consequently be a security risk if our relations contain
    sensitive information. Ensure that you use the `fields()` method in the related
    attribute to restrict what data will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can expand this data by adding `expand=role` to our `GET` parameters, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Data serialization within responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to modifying the fields that are displayed in our response, we
    can also modify our response to contain useful information, such as the information
    that is sent in our headers (such as pagination information and links), and wrap
    our response in a container that is easy to identify in our response. We can do
    this by adding and specifying a serializer in our `yi\rest\ActiveController`,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we query our `/users` endpoint, we will have the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Disabling ActiveController actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While `yii\rest\ActiveController` provides many useful actions, there may be
    situations where you do not want to expose every method that is exposed by default.
    The following actions are automatically exposed by `yii\rest\ActiveController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Action name | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `index` | This lists all the resources provided by the model with pagination
    support |'
  prefs: []
  type: TYPE_TB
- en: '| `view` | This returns the details of a specific model |'
  prefs: []
  type: TYPE_TB
- en: '| `create` | This creates a new model instance |'
  prefs: []
  type: TYPE_TB
- en: '| `update` | This updates an existing model instance |'
  prefs: []
  type: TYPE_TB
- en: '| `delete` | This deletes a model |'
  prefs: []
  type: TYPE_TB
- en: '| `options` | This returns the available methods |'
  prefs: []
  type: TYPE_TB
- en: 'Apart from overriding the action method, there are several different ways to
    disable actions. Actions can be disabled by removing them from the actions list
    within the `actions()` method of your controller. For example, to disable `delete`
    and `create`, we can remove them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, actions can be disabled by removing the route from `yii\rest\UrlRule`
    within our web configuration by setting the `only` or the `except` parameters
    of our rule. In the following example, the `delete`, `create`, and `update` actions
    have been disabled in our router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Customizing ActiveController actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several ways to modify the data that is returned by each action provided
    by `yii\rest\ActiveController`. Apart from directly overloading a specific method,
    the data providers for each action can be modified as well. For example, to change
    the data provider for our index action, we can write code that''s similar to the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Authentication filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 7](part0042_split_000.html#181NK2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 7. Authenticating and Authorizing Users"), *Authenticating and Authorizing
    Users*, we covered the basics of user access control filters to control which
    users can have access to our controllers. Unlike stateful applications that depend
    upon the presence of session data to persist user data across each request, RESTful
    APIs are stateless by nature, which means that each request must provide the required
    information to authenticate each user. To assist us in authenticating users over
    our API, Yii2 provides three built-in methods to control access to our API:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP basic authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query parameter authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth2 authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, we can define our own custom authentication methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with authenticating users within our API, we need to make the
    following changes to our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring the user component of our configuration by doing the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabling sessions by setting `enableSession` to `false`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the `loginUrl` property to null to prevent redirects to the login page
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the authentication method in the `behaviors()` method of our controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing `yii\web\IdentityInterface::findIdentityByAccessToken()` in our
    user identity class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may encounter issues if you mix your REST API with your normal Yii2 application.
    For this reason, it is strongly encouraged that you run your API as a separate
    application from your Yii2 app.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP basic authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most basic way to handle authentication is to implement HTTP basic authentication.
    HTTP basic authentication is provided by `the yii\filters\auth\HttpBasicAuth`
    class, and it can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we attempt to query our API without sufficient credentials, we will
    receive the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we attempt to navigate to any endpoint in our application, we will then
    receive the following popup asking us to authenticate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTTP basic authentication](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, Yii2 will pass this information to `yii\web\IdentityInterface::findIdentityByAccessToken()`
    with just the username as the token. Generally, a username isn''t sufficient information
    to authenticate a user. This behavior can be overwritten by specifying the `auth`
    property of `yii\filters\auth\HttpBasicAuth`, which will allow us to pass both
    the username and password to a function of our choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Within our User model, we can define the `httpBasicAuth()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the example shown, we're validating the username and password against the
    users we created in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*.
    In this situation, we're validating the password against the previously created
    bcrypt hash. Ensure that you reference the credentials listed in that chapter
    for an example.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we query against our API, we will receive a valid response if we have
    valid credentials and an error if we provide the wrong credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Query parameter authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an alternative to query parameter authentication, we can grant access to
    our API by specifying a query parameter. This can be a global query parameter
    that we treat as a secret key, or it can be a per-user token that we issue on
    our login request. Query parameter authentication can be implemented by implementing
    `yii\filters\auth\QueryParamAuth`. In the following example, we''re looking for
    a `GET` parameter called `token`, which contains our token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Authentication can be performed in our model by implementing `yii\web\IdentityInterface::findIdentityByAccessToken()`.
    The simplest example is to create a new migration that adds a new column to our
    user''s table called `access_token` that is populated on our authentication request.
    We can then validate against it by adding the following code to our `User` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: OAuth2 authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most complex authentication method in Yii2 is OAuth2 authentication, as
    implemented by `yii\auth\filters\HttpBearerAuth`. Like `yii\auth\filters\QueryParamAuth`,
    `yii\auth\filters\HttpBearerAuth` can be implemented by setting the appropriate
    behavior in the `behaviors()` method and then implementing `yii\web\IdentityInterface::findIdentityByAccessToken()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re unfamiliar with the OAuth2 workflow, you can simulate a login request
    by setting the `Authorization` header with a specific Bearer token, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `<token>` part of the header is what will ultimately be passed to `yii\web\IdentityInterface::findIdentityByAccessToken()`.
  prefs: []
  type: TYPE_NORMAL
- en: Composite authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To increase the security of our API, we can bundle several different authentication
    filters together by implementing `yii\filters\auth\CompositeAuth`. To authenticate
    against our API, we need to satisfy all the authentication requirements, as listed
    in our `behaviors()` method. Composite authentication can be configured as follows
    within our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Custom authentication filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an alternative to built-in authentication providers, we can also define
    our own authentication filters. For example, as part of our login request, we
    may generate a unique token for the user to make all additional requests against.
    Rather than requiring clients of our API to store the users'' raw password or
    pass the credentials as a `GET` parameter that may end up in our server log files,
    we can have our users submit their authentication token as a unique header. An
    example class of how to implement this is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Our custom authentication method can then be implemented in our controller,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you would expect, the `x-auth-token` parameter will be the token that is
    passed to `yii\web\IdentityInterface::findIdentityByAccessToken()`.
  prefs: []
  type: TYPE_NORMAL
- en: Action-specific authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Authentication can be restricted to certain actions using the `only` and `except`
    keywords as part of the authenticator behavior. For example, using our previously
    created `HeaderParamAuth` class, we can only require authentication to the `delete`,
    `create`, and `update` actions while allowing unauthenticated users to access
    the main index action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Checking access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When exposing API endpoints, you often need to bundle both authentication and
    authorization. With `yii\rest\Controller`, this can be handled by overriding the
    `yii\rest\Controller::checkAccess()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can use the access control filter, as shown in [Chapter 7](part0042_split_000.html#181NK2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 7. Authenticating and Authorizing Users"), *Authenticating and Authorizing
    Users*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Authorization determines which actions require authenticated access. When working
    with APIs, you'll need to properly implement authentication to determine which
    users, or which set of users, have access to a specific command. Refer to the
    material in [Chapter 7](part0042_split_000.html#181NK2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 7. Authenticating and Authorizing Users"), *Authenticating and Authorizing
    Users* for more details on how to authenticate users in your app.
  prefs: []
  type: TYPE_NORMAL
- en: Verb filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When creating custom API endpoints, you may want to only allow certain HTTP
    verbs to be issued against these actions. For instance, a PUT request to an endpoint
    that deletes a user doesn''t make much sense. One way to control which HTTP verbs
    can be executed against our actions is to use `yii\filters\VerbFilter`. When using
    `yii\filters\VerbFilter`, we simply need to specify which HTTP verbs will be accepted
    by each of our public actions. The following example shows the default verb filter
    that is used by `yii\rest\ActiveController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Cross-origin resource headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working with JavaScript applications that issue AJAX requests against
    your API, you may want to use **cross-origin resource sharing** (**CORS**) headers
    to ensure that only domains that you specify can run against your domain. CORS
    headers can be implemented by adding `yii\filters\Cors` to your `behaviors()`
    method, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This behavior can be extended by setting specific CORS headers that you want
    to specify for your controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CORS headers have a very specific purpose when it comes to preventing AJAX requests
    from browsers and other domains from accessing content on your domain, and they
    are meant to be implemented as a security precaution for your end users rather
    than your API. CORS headers will not prevent tools such as CURL or noncompliant
    browsers from accessing your API. Before implementing CORS, ensure that you have
    a concrete understanding of what they are, what they protect against, and what
    headers to use. For more information on CORS, refer to the W3C reference guide
    at [http://www.w3.org/TR/cors/](http://www.w3.org/TR/cors/).
  prefs: []
  type: TYPE_NORMAL
- en: Rate Limiting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating APIs, you may want to implement rate limiting within your API
    to prevent excessive requests being made to your API and exhausting server resources.
    This is extremely important if your API is dependent upon another API that has
    rate limits already in place. Rate limiting in Yii2 is implemented by `yii\filters\RateLimiter`
    and `yii\filters\RateLimitInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with rate limiting, we first need to add `yii\filters\Ratelimiter`
    to our controller behaviors. The `yii\filters\RateLimiter` class is coupled to
    our user identity class. Consequently, rate limiting will only be applied to actions
    that are protected by authentication. Any action that is not protected by an authenticate
    filter will not have rate limiting applied to it. The following example illustrates
    the code blocks required to implement `yii\filters\RateLimiter` within our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to implement the required methods in our user identity class
    with the `yii\filters\RateLimitInterface` interface. The first method, `yii\filters\RateLimitInterface::getRateLimit()`,
    defines the number of requests we can make in a unit of time. For global rate
    limiting, we can simply return `[100, 600]`, which will allow 100 requests in
    600 seconds. As the complete request and action are passed to the `yii\filters\RateLimitInterface::getRateLimit()`
    method, however, we can further refine our rate limits for each controller and
    action pairing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`yii\filters\RateLimiter` is coupled with your user identity. If you want to
    implement rate limiting for unauthenticated users, you will need to implement
    a custom filter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to implement two methods to load the available rate limits and
    update the available rate limits after each request. These two methods are `yii\filters\RateLimitInterface::loadAllowance()`
    and `yii\filters\RateLimitInterface::saveAllowance()`. As rate limit data isn''t
    considered sensitive and won''t have a significant impact upon our application
    if the data is accidentally removed, this data can be stored either in our cache
    component or within a NoSQL solution, such as MongoDB or Redis. The method signatures
    are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Combined together, our extended class will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when your query against authenticated API endpoints, the following additional
    headers will be returned with the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have MinGW and MSYS, there's no need to be jealous of those with
    a Linux installation anymore, since they implement in your system the most important
    parts of a Linux development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By extending `yii\rest\Controller` (or `yii\rest\ActiveController`), we can
    easily implement error handling in our application by defining a proper error
    handler within our configuration, as illustrated in previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike view-based responses, we do not need to include a definition within
    the `actions()` method of our controller for the error handler that we want to
    use. Instead, we can simply return the error as it occurs, or we can override
    the error to display a more generic response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Custom API controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While convenient, `yii\rest\ActiveController` doesn't solve every problem with
    creating APIs. When not using `yii\rest\ActiveController`, you'll want to extend
    your controller classes from `yii\rest\Controller` in order to take full advantage
    the built-in REST API defaults implemented by `yii\rest\Controller`. The following
    sections illustrate some additional information on creating custom API controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Returning data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several way in which we can think about custom API controllers in
    Yii2\. The easiest way to think about passing data to our clients is to bypass
    the view portion of our MVC model and directly return data from our controllers.
    For example, if we were to create a new controller called `SiteController` within
    our controller''s namespace, we could directly return data from our newly created
    controller, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember, once we start making changes to our default URL manager rules, we''ll
    need to add the rules required to route data to other controllers. This rule will
    ensure that `site/<action> maps` back to our site controller: `[''class'' => ''yii\web\UrlRule'',
    ''pattern'' => ''site/<action>'', ''route'' => ''site/index'']`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Curling against the site/index endpoint of our API will return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Response Formatting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yii2 has a very specific response structure that it will return with the default
    `yii\rest\Controller`. When creating an API, you may already have a specific response
    structure you may want to use (for instance, if you're refactoring an existing
    but outdated API with a Yii2 API). You may also want to have a uniform structure
    in your API responses as the responses provided by `yii\rest\Controller` and `yii\rest\ActiveController`
    don't match up (as illustrated by the previous sections).
  prefs: []
  type: TYPE_NORMAL
- en: 'In these situations, you''ll need to modify the response structure. To do this,
    we simply need to override the `response` component of our application and modify
    the `$response->data` variable within the `beforeSend` event with the actual response
    that we want. In this example, we will have the following response structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The code required to make this change is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we were to query our API, we would receive a uniform response structure
    for both our `SiteController` and `UserController`. This is for `SiteController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This query regards `UserController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we expanded upon our knowledge of everything we've learned
    thus far and also learned how to create RESTful JSON and XML APIs in Yii2\. First,
    we covered the usage of `yii\rest\ActiveController`, which enabled us to quickly
    create CRUD APIs based upon our model classes. We then covered Yii2's built-in
    authentication filters and covered how we can protect our resources by requiring
    authentication. We also covered the creation of our own authentication filters
    to support different authentication schemes. We then covered several other useful
    API classes, including `yii\filters\VerbFilter, yii\filters\Cors`, and learned
    how to handle errors within our API. Additionally, we detailed some important
    information about creating our own API endpoints by extending `yii\rest\Controller`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having covered all the information required to build applications in Yii2,
    we''ll spend the remaining chapters of this book exploring ways in which we can
    enhance our applications. In the next chapter, we''ll specifically go over one
    of the most important aspect of building applications: testing. We''ll cover how
    to set up testing within our application using a powerful called Codeception,
    and we will detail how to set up and create function, unit, and acceptance testing
    as well as how to create data fixtures to test with.'
  prefs: []
  type: TYPE_NORMAL
