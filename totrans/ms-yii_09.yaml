- en: Chapter 9. RESTful APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。RESTful API
- en: '**Representational State Transfer** (**REST**) is a modern approach for client-server
    communications that decouple the client (such as Bowers and mobile applications)
    from the server components in applications. RESTful implementations enable backend
    implementations to speak a common language (usually, XML or JSON) while taking
    complete advantage of HTTP verbs, such as `GET`, `POST`, `PUT`, and `DELETE`.
    RESTful applications enable us to build stateless, scalable, and uniform applications
    that we can distribute to our clients. With Yii2, we can quickly implement RESTful
    APIs as either a part or the whole of our application.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**表征状态转移**（**REST**）是客户端-服务器通信的现代方法，它将客户端（如Bowers和移动应用程序）与应用程序的服务器组件解耦。RESTful实现使后端实现能够使用一种通用语言（通常是XML或JSON）进行通信，同时充分利用HTTP动词，如`GET`、`POST`、`PUT`和`DELETE`。RESTful应用程序使我们能够构建无状态、可扩展和统一的应用程序，我们可以将其分发给我们的客户端。使用Yii2，我们可以快速实现RESTful
    API，作为我们应用程序的一部分或全部。'
- en: ActiveController
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ActiveController
- en: 'The simplest way to create RESTful APIs in Yii2 is to take advantage of `yii\rest\ActiveController`.
    Like `yii\web\Controller`, `yii\rest\ActiveController` provides a controller interface
    that we can implement in our `./controllers` directory. Unlike `yii\web\Controller`,
    implementing `yii\rest\ActiveController` with a `yii\db\ActiveRecord` model will
    immediately create a complete REST API for that model available, with very minimal
    coding. Models implemented with `yii\rest\ActiveController` also make the following
    additional features available out of the box:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yii2中创建RESTful API的最简单方法是利用`yii\rest\ActiveController`。像`yii\web\Controller`一样，`yii\rest\ActiveController`提供了一个控制器接口，我们可以在我们的`./controllers`目录中实现。与`yii\web\Controller`不同，使用`yii\rest\ActiveController`和`yii\db\ActiveRecord`模型实现将立即为该模型创建一个完整的REST
    API，而无需编写大量代码。使用`yii\rest\ActiveController`实现的模型还提供了以下附加功能：
- en: XML and JSON response formats
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML和JSON响应格式
- en: Rate limiting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率限制
- en: Data and HTTP caching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据和HTTP缓存
- en: Authentication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: Full HTTP verb support (`GET`, `POST`, `PATCH`, `HEAD`, and `OPTIONS`)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全支持HTTP动词（`GET`、`POST`、`PATCH`、`HEAD`和`OPTIONS`）
- en: Data validation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据验证
- en: Pagination
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页
- en: Support for HATEOAS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持HATEOAS
- en: 'As an example, let''s expose our User model that we created in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*.
    To get started with `yii\rest\ActiveController`, we first need to create a controller
    in our `controllers/` directory called `UserController.php`, which references
    our User model that we created previously:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们公开我们在[第4章](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "第4章。活动记录、模型和表单")中创建的用户模型，*活动记录、模型和表单*。要开始使用`yii\rest\ActiveController`，我们首先需要在`controllers/`目录中创建一个名为`UserController.php`的控制器，它引用我们之前创建的用户模型：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we need to make some configuration changes to our `config/web.php` configuration
    file so that Yii2 can route the correct routes to our newly created controller
    and to ensure that our application can accept JSON input. As we''ve already enabled
    pretty URLs and disabled the script name being displayed in our `urlManager` component,
    we simply need to add a custom URL rule for our user class. This URL rule is an
    instance of `yii\rest\UrlRule`, and it will handle all the required routing for
    our controller:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要对我们的`config/web.php`配置文件进行一些配置更改，以便Yii2可以将正确的路由路由到我们新创建的控制器，并确保我们的应用程序可以接受JSON输入。因为我们已经启用了美观的URL并禁用了在`urlManager`组件中显示脚本名称，所以我们只需要为我们的用户类添加一个自定义URL规则。这个URL规则是`yii\rest\UrlRule`的一个实例，它将处理我们控制器所需的所有路由：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we need to modify the base request object that our application uses so
    that it can parse the JSON input:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改我们的应用程序使用的基请求对象，以便它可以解析JSON输入：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The change to the request parser is added for convenience as JSON is an easy
    input type to work with. Without this change, our application will only be able
    to parse the `application/x-www-form-urlencoded` and `multipart/form-data` request
    formats.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对请求解析器的更改是为了方便，因为JSON是一种易于处理的输入类型。如果没有这个更改，我们的应用程序将只能解析`application/x-www-form-urlencoded`和`multipart/form-data`请求格式。
- en: 'By simply adding a few lines of code, we''ve now implemented a complete REST
    API for our `Users` model. The following table exposes a complete list of methods
    that `yii\rest\ActiveController` exposes for us:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地添加几行代码，我们现在已经为我们的`Users`模型实现了一个完整的REST API。以下表格展示了`yii\rest\ActiveController`为我们提供的完整方法列表：
- en: '| HTTP Method | Endpoint | Result |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| HTTP方法 | 端点 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `GET` | `/users` | This is a list of all users |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/users` | 这是一个所有用户的列表 |'
- en: '| `GET` | `/users/<id>` | This has the information for the user with the given
    `<id>` tag |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/users/<id>` | 这包含具有给定 `<id>` 标签的用户的详细信息 |'
- en: '| `POST` | `/users` | This creates a new user with the data supplied in the
    request body |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/users` | 这使用请求体中的数据创建一个新用户 |'
- en: '| `PATCH` | `/users/<id>` | This modifies a user with the given `<id>` tag
    with the data supplied in the request body |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | `/users/<id>` | 这使用请求体中的数据修改具有给定 `<id>` 标签的用户 |'
- en: '| `DELETE` | `/users/<id>` | This deletes a user with a given `<id>` tag |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `/users/<id>` | 这将删除具有给定 `<id>` 标签的用户 |'
- en: '| `HEAD` | `/users` | This retrieves the header information |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `HEAD` | `/users` | 这检索头部信息 |'
- en: '| `HEAD` | `/users/<idl>` | This retrieves the header information for the given
    user `<id>` tag |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `HEAD` | `/users/<idl>` | 这检索给定 `<id>` 标签用户的头部信息 |'
- en: '| `OPTIONS` | `/users` | This retrieves the HTTP options for Ajax-like requests
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `OPTIONS` | `/users` | 这检索类似 Ajax 的请求的 HTTP 选项 |'
- en: '| `OPTIONS` | `/users/<id>` | This retrieves the HTTP options for Ajax-like
    requests for a user with a given `<id>` tag |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `OPTIONS` | `/users/<id>` | 这检索具有给定 `<id>` 标签的用户的类似 Ajax 的请求的 HTTP 选项 |'
- en: 'An easy way to query against our newly created REST API is to use the command-line
    tool called CURL. For example, to retrieve the headers for our `/users` endpoint,
    we can run the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 查询我们新创建的 REST API 的简单方法是使用名为 CURL 的命令行工具。例如，为了检索 `/users` 端点的头部，我们可以运行以下命令：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You''ll get output similar to the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到类似以下输出的结果：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As mentioned previously, `yii\rest\ActiveRecord` immediately provides us with
    a bunch of useful information, such as CORS headers and pagination details.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`yii\rest\ActiveRecord` 立即为我们提供了一组有用的信息，例如 CORS 头和分页详情。
- en: 'With CURL, we can also query for the raw data itself. Our API can respond in
    either a JSON or an XML format depending upon the `Accept` headers we submit along
    with our request. The next example illustrates a request that will respond in
    the JSON format:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CURL，我们还可以查询原始数据本身。我们的 API 可以根据我们随请求一起提交的 `Accept` 头部以 JSON 或 XML 格式响应。下一个示例演示了一个将以
    JSON 格式响应的请求：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: By default, CURL will return data as a single line. As illustrated in the previous
    command, we're piping the JSON response from our cURL request to a tool called
    **jq** ([https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)), which
    is used to format the data in an easy-to-read format. Alternatively, you can install
    a graphic-based tool of your choice to submit and display responses in an easy-to-read
    format.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CURL 将数据作为单行返回。如前一个命令所示，我们将 cURL 请求的 JSON 响应通过管道传输到名为 **jq**（[https://stedolan.github.io/jq/](https://stedolan.github.io/jq/))
    的工具，该工具用于以易于阅读的格式格式化数据。或者，您可以选择安装一个基于图形的工具来提交和以易于阅读的格式显示响应。
- en: 'Additionally, we can filter specific fields by passing them as `GET` parameters
    within our request. For example, if we want to just retrieve the first and last
    name of the user with the ID of `1` in our database, we can execute the following
    command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以通过在请求中传递它们作为 `GET` 参数来过滤特定的字段。例如，如果我们只想检索数据库中 ID 为 `1` 的用户的姓氏和名字，我们可以执行以下命令：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will return the following response:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下响应：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Configuring ActiveController display fields
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 ActiveController 显示字段
- en: As you may have noticed, `yii\rest\ActiveController` only returns fields that
    are populated from the database and does not return extra fields that you may
    have created (such as a `full_name` field as the concatenation of the first and
    last name) or relations. Additionally, it exposes every field in the database,
    including sensitive data, such as encrypted password hashes. One way to get around
    this limitation is to modify the `fields()` method of our models.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已注意到，`yii\rest\ActiveController` 只返回从数据库中填充的字段，并且不会返回您可能已创建的额外字段（例如，将姓氏和名字连接起来的
    `full_name` 字段）或关系。此外，它还公开数据库中的每个字段，包括敏感数据，如加密的密码散列。绕过这种限制的一种方法是我们修改模型中的 `fields()`
    方法。
- en: 'For example, to prevent accidentally exposing our hashed passwords over our
    API, we can implement a custom `fields` method in our `User` model, as follows.
    We can also change the display name of certain fields:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了防止意外在我们的 API 中公开散列密码，我们可以在 `User` 模型中实现自定义的 `fields` 方法，如下所示。我们还可以更改某些字段的显示名称：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s query against our API, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下方式查询我们的 API：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We retrieve the following response:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检索以下响应：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Additionally, we can expose relational data by implementing the `extraFields()`
    method of our model, as shown in the next example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过实现模型的`extraFields()`方法来公开关系数据，如下一个示例所示：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `extraFields()` method will expose the entire model relationship in our
    response, and it can consequently be a security risk if our relations contain
    sensitive information. Ensure that you use the `fields()` method in the related
    attribute to restrict what data will be returned.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`extraFields()`方法将在我们的响应中公开整个模型关系，如果我们的关系包含敏感信息，则可能存在安全风险。请确保您在相关属性中使用`fields()`方法来限制将返回的数据。'
- en: 'We can expand this data by adding `expand=role` to our `GET` parameters, as
    shown in the following example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`GET`参数中添加`expand=role`来扩展这些数据，如下面的示例所示：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Data serialization within responses
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应中的数据序列化
- en: 'In addition to modifying the fields that are displayed in our response, we
    can also modify our response to contain useful information, such as the information
    that is sent in our headers (such as pagination information and links), and wrap
    our response in a container that is easy to identify in our response. We can do
    this by adding and specifying a serializer in our `yi\rest\ActiveController`,
    as shown in the following example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了修改我们响应中显示的字段外，我们还可以修改我们的响应以包含有用的信息，例如在头信息中发送的信息（例如分页信息和链接），并将我们的响应包装在一个易于在响应中识别的容器中。我们可以通过在`yi\rest\ActiveController`中添加并指定序列化器来完成此操作，如下面的示例所示：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, when we query our `/users` endpoint, we will have the following response:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们查询我们的`/users`端点时，我们将得到以下响应：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Disabling ActiveController actions
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用ActiveController动作
- en: 'While `yii\rest\ActiveController` provides many useful actions, there may be
    situations where you do not want to expose every method that is exposed by default.
    The following actions are automatically exposed by `yii\rest\ActiveController`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`yii\rest\ActiveController`提供了许多有用的动作，但可能存在您不希望公开默认暴露的每个方法的情况。以下动作由`yii\rest\ActiveController`自动暴露：
- en: '| Action name | Result |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 动作名称 | 结果 |'
- en: '| --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `index` | This lists all the resources provided by the model with pagination
    support |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `index` | 这将列出模型提供的所有资源，并支持分页 |'
- en: '| `view` | This returns the details of a specific model |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `view` | 这将返回特定模型的详细信息 |'
- en: '| `create` | This creates a new model instance |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `create` | 这将创建一个新的模型实例 |'
- en: '| `update` | This updates an existing model instance |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `update` | 这将更新现有的模型实例 |'
- en: '| `delete` | This deletes a model |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `delete` | 这将删除模型 |'
- en: '| `options` | This returns the available methods |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `options` | 这将返回可用的方法 |'
- en: 'Apart from overriding the action method, there are several different ways to
    disable actions. Actions can be disabled by removing them from the actions list
    within the `actions()` method of your controller. For example, to disable `delete`
    and `create`, we can remove them, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除了重写动作方法外，还有几种不同的方法可以禁用动作。可以通过从控制器中的`actions()`方法内的动作列表中移除它们来禁用动作。例如，要禁用`delete`和`create`，我们可以按照以下方式移除它们：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Alternatively, actions can be disabled by removing the route from `yii\rest\UrlRule`
    within our web configuration by setting the `only` or the `except` parameters
    of our rule. In the following example, the `delete`, `create`, and `update` actions
    have been disabled in our router:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过从我们的网络配置中的`yii\rest\UrlRule`移除路由来禁用动作，通过设置规则的`only`或`except`参数。在以下示例中，我们的路由器中已禁用了`delete`、`create`和`update`动作：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Customizing ActiveController actions
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义ActiveController动作
- en: 'There are several ways to modify the data that is returned by each action provided
    by `yii\rest\ActiveController`. Apart from directly overloading a specific method,
    the data providers for each action can be modified as well. For example, to change
    the data provider for our index action, we can write code that''s similar to the
    following code block:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以修改`yii\rest\ActiveController`提供的每个动作返回的数据。除了直接重载特定方法外，还可以修改每个动作的数据提供者。例如，要更改索引动作的数据提供者，我们可以编写类似于以下代码块的代码：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Authentication filters
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证过滤器
- en: 'In [Chapter 7](part0042_split_000.html#181NK2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 7. Authenticating and Authorizing Users"), *Authenticating and Authorizing
    Users*, we covered the basics of user access control filters to control which
    users can have access to our controllers. Unlike stateful applications that depend
    upon the presence of session data to persist user data across each request, RESTful
    APIs are stateless by nature, which means that each request must provide the required
    information to authenticate each user. To assist us in authenticating users over
    our API, Yii2 provides three built-in methods to control access to our API:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](part0042_split_000.html#181NK2-ad3e09b384df46aea690d9c8897d5fe7 "第7章。认证和授权用户")，*认证和授权用户*中，我们介绍了用户访问控制过滤器的基础知识，以控制哪些用户可以访问我们的控制器。与依赖于会话数据以在每次请求之间持久化用户数据的面向状态的程序不同，RESTful
    API本质上是无状态的，这意味着每个请求都必须提供所需的信息以对每个用户进行身份验证。为了帮助我们通过API进行用户认证，Yii2提供了三个内置方法来控制对API的访问：
- en: HTTP basic authentication
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP基本认证
- en: Query parameter authentication
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询参数认证
- en: OAuth2 authentication
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth2认证
- en: Additionally, we can define our own custom authentication methods.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以定义我们自己的自定义认证方法。
- en: 'To get started with authenticating users within our API, we need to make the
    following changes to our application:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始在我们的API中认证用户，我们需要对我们的应用程序进行以下更改：
- en: 'Configuring the user component of our configuration by doing the following:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过以下方式配置我们的配置中的用户组件：
- en: Disabling sessions by setting `enableSession` to `false`
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将`enableSession`设置为`false`来禁用会话
- en: Setting the `loginUrl` property to null to prevent redirects to the login page
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`loginUrl`属性设置为null以防止重定向到登录页面
- en: Specifying the authentication method in the `behaviors()` method of our controller
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的控制器`behaviors()`方法中指定认证方法
- en: Implementing `yii\web\IdentityInterface::findIdentityByAccessToken()` in our
    user identity class
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的用户身份类中实现`yii\web\IdentityInterface::findIdentityByAccessToken()`
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You may encounter issues if you mix your REST API with your normal Yii2 application.
    For this reason, it is strongly encouraged that you run your API as a separate
    application from your Yii2 app.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将REST API与您的正常Yii2应用程序混合使用，可能会遇到问题。因此，强烈建议您将API作为与Yii2应用程序分开的独立应用程序运行。
- en: HTTP basic authentication
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP基本认证
- en: 'The most basic way to handle authentication is to implement HTTP basic authentication.
    HTTP basic authentication is provided by `the yii\filters\auth\HttpBasicAuth`
    class, and it can be implemented as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 处理认证的最基本方法是实现HTTP基本认证。HTTP基本认证由`the yii\filters\auth\HttpBasicAuth`类提供，可以按以下方式实现：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, if we attempt to query our API without sufficient credentials, we will
    receive the following response:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试在没有足够凭据的情况下查询我们的API，我们将收到以下响应：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we attempt to navigate to any endpoint in our application, we will then
    receive the following popup asking us to authenticate:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试导航到应用程序中的任何端点，我们将收到以下弹出窗口，要求我们进行身份验证：
- en: '![HTTP basic authentication](img/00039.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![HTTP基本认证](img/00039.jpeg)'
- en: 'By default, Yii2 will pass this information to `yii\web\IdentityInterface::findIdentityByAccessToken()`
    with just the username as the token. Generally, a username isn''t sufficient information
    to authenticate a user. This behavior can be overwritten by specifying the `auth`
    property of `yii\filters\auth\HttpBasicAuth`, which will allow us to pass both
    the username and password to a function of our choice:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Yii2将仅将用户名作为令牌传递给`yii\web\IdentityInterface::findIdentityByAccessToken()`。通常，用户名不足以对用户进行身份验证。可以通过指定`yii\filters\auth\HttpBasicAuth`的`auth`属性来覆盖此行为，这将允许我们将用户名和密码传递到我们选择的功能中：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Within our User model, we can define the `httpBasicAuth()` method as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的用户模型中，我们可以定义`httpBasicAuth()`方法如下：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In the example shown, we're validating the username and password against the
    users we created in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*.
    In this situation, we're validating the password against the previously created
    bcrypt hash. Ensure that you reference the credentials listed in that chapter
    for an example.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在所示示例中，我们正在验证用户名和密码与我们创建在[第4章](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "第4章。活动记录、模型和表单")的用户，*活动记录、模型和表单*。在这种情况下，我们正在将密码与先前创建的bcrypt散列进行验证。确保您参考该章节中列出的凭据以获取示例。
- en: Now, if we query against our API, we will receive a valid response if we have
    valid credentials and an error if we provide the wrong credentials.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们查询我们的 API，如果我们有有效的凭据，我们将收到有效的响应；如果我们提供错误的凭据，我们将收到错误。
- en: Query parameter authentication
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询参数认证
- en: 'As an alternative to query parameter authentication, we can grant access to
    our API by specifying a query parameter. This can be a global query parameter
    that we treat as a secret key, or it can be a per-user token that we issue on
    our login request. Query parameter authentication can be implemented by implementing
    `yii\filters\auth\QueryParamAuth`. In the following example, we''re looking for
    a `GET` parameter called `token`, which contains our token:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 作为查询参数认证的替代方案，我们可以通过指定查询参数来授权访问我们的 API。这可以是一个全局查询参数，我们将其视为密钥，或者它可以是我们在登录请求上签发的每个用户的令牌。查询参数认证可以通过实现
    `yii\filters\auth\QueryParamAuth` 来实现。在以下示例中，我们正在寻找一个名为 `token` 的 `GET` 参数，其中包含我们的令牌：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Authentication can be performed in our model by implementing `yii\web\IdentityInterface::findIdentityByAccessToken()`.
    The simplest example is to create a new migration that adds a new column to our
    user''s table called `access_token` that is populated on our authentication request.
    We can then validate against it by adding the following code to our `User` model:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 认证可以通过在我们的模型中实现 `yii\web\IdentityInterface::findIdentityByAccessToken()` 来执行。最简单的例子是创建一个新的迁移，为我们的用户表添加一个名为
    `access_token` 的新列，该列在我们认证请求时被填充。然后我们可以通过向我们的 `User` 模型添加以下代码来对其进行验证：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: OAuth2 authentication
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth2 认证
- en: The most complex authentication method in Yii2 is OAuth2 authentication, as
    implemented by `yii\auth\filters\HttpBearerAuth`. Like `yii\auth\filters\QueryParamAuth`,
    `yii\auth\filters\HttpBearerAuth` can be implemented by setting the appropriate
    behavior in the `behaviors()` method and then implementing `yii\web\IdentityInterface::findIdentityByAccessToken()`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Yii2 中，最复杂的认证方法是 OAuth2 认证，这是通过 `yii\auth\filters\HttpBearerAuth` 实现的。与 `yii\auth\filters\QueryParamAuth`
    类似，`yii\auth\filters\HttpBearerAuth` 可以通过在 `behaviors()` 方法中设置适当的行为，然后实现 `yii\web\IdentityInterface::findIdentityByAccessToken()`
    来实现。
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you''re unfamiliar with the OAuth2 workflow, you can simulate a login request
    by setting the `Authorization` header with a specific Bearer token, as shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉 OAuth2 的工作流程，可以通过设置带有特定 Bearer 令牌的 `Authorization` 标头来模拟登录请求，如下所示：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `<token>` part of the header is what will ultimately be passed to `yii\web\IdentityInterface::findIdentityByAccessToken()`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 标头中的 `<token>` 部分最终将被传递给 `yii\web\IdentityInterface::findIdentityByAccessToken()`。
- en: Composite authentication
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合认证
- en: 'To increase the security of our API, we can bundle several different authentication
    filters together by implementing `yii\filters\auth\CompositeAuth`. To authenticate
    against our API, we need to satisfy all the authentication requirements, as listed
    in our `behaviors()` method. Composite authentication can be configured as follows
    within our controller:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高我们 API 的安全性，我们可以通过实现 `yii\filters\auth\CompositeAuth` 将几个不同的认证过滤器捆绑在一起。为了认证我们的
    API，我们需要满足 `behaviors()` 方法中列出的所有认证要求。复合认证可以在我们的控制器中按如下方式配置：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Custom authentication filters
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义认证过滤器
- en: 'As an alternative to built-in authentication providers, we can also define
    our own authentication filters. For example, as part of our login request, we
    may generate a unique token for the user to make all additional requests against.
    Rather than requiring clients of our API to store the users'' raw password or
    pass the credentials as a `GET` parameter that may end up in our server log files,
    we can have our users submit their authentication token as a unique header. An
    example class of how to implement this is shown as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 作为内置认证提供程序的替代方案，我们还可以定义我们自己的认证过滤器。例如，作为我们登录请求的一部分，我们可能为用户生成一个唯一的令牌，以便对所有附加请求进行操作。而不是要求我们的
    API 客户端存储用户的原始密码或将凭据作为可能出现在我们服务器日志文件中的 `GET` 参数传递，我们可以让我们的用户提交他们的认证令牌作为唯一的标头。以下是如何实现此功能的示例类：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our custom authentication method can then be implemented in our controller,
    as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在我们的控制器中实现我们的自定义认证方法，如下所示：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you would expect, the `x-auth-token` parameter will be the token that is
    passed to `yii\web\IdentityInterface::findIdentityByAccessToken()`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期，`x-auth-token` 参数将是传递给 `yii\web\IdentityInterface::findIdentityByAccessToken()`
    的令牌。
- en: Action-specific authentication
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作特定认证
- en: 'Authentication can be restricted to certain actions using the `only` and `except`
    keywords as part of the authenticator behavior. For example, using our previously
    created `HeaderParamAuth` class, we can only require authentication to the `delete`,
    `create`, and `update` actions while allowing unauthenticated users to access
    the main index action:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`only`和`except`关键字作为验证器行为的一部分，可以将身份验证限制为某些操作。例如，使用我们之前创建的`HeaderParamAuth`类，我们只能要求对`delete`、`create`和`update`操作进行身份验证，同时允许未经身份验证的用户访问主索引操作：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Checking access
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查访问
- en: 'When exposing API endpoints, you often need to bundle both authentication and
    authorization. With `yii\rest\Controller`, this can be handled by overriding the
    `yii\rest\Controller::checkAccess()` method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当公开API端点时，您通常需要捆绑身份验证和授权。使用`yii\rest\Controller`，这可以通过覆盖`yii\rest\Controller::checkAccess()`方法来处理：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Alternatively, you can use the access control filter, as shown in [Chapter 7](part0042_split_000.html#181NK2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 7. Authenticating and Authorizing Users"), *Authenticating and Authorizing
    Users*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用访问控制过滤器，如[第7章](part0042_split_000.html#181NK2-ad3e09b384df46aea690d9c8897d5fe7
    "第7章。验证和授权用户")，*验证和授权用户*中所示。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Authorization determines which actions require authenticated access. When working
    with APIs, you'll need to properly implement authentication to determine which
    users, or which set of users, have access to a specific command. Refer to the
    material in [Chapter 7](part0042_split_000.html#181NK2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 7. Authenticating and Authorizing Users"), *Authenticating and Authorizing
    Users* for more details on how to authenticate users in your app.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 授权确定哪些操作需要经过身份验证的访问。当与API一起工作时，您需要正确实现身份验证以确定哪些用户或用户组可以访问特定的命令。有关如何在您的应用程序中验证用户的详细信息，请参阅[第7章](part0042_split_000.html#181NK2-ad3e09b384df46aea690d9c8897d5fe7
    "第7章。验证和授权用户")，*验证和授权用户*。
- en: Verb filters
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动词过滤器
- en: 'When creating custom API endpoints, you may want to only allow certain HTTP
    verbs to be issued against these actions. For instance, a PUT request to an endpoint
    that deletes a user doesn''t make much sense. One way to control which HTTP verbs
    can be executed against our actions is to use `yii\filters\VerbFilter`. When using
    `yii\filters\VerbFilter`, we simply need to specify which HTTP verbs will be accepted
    by each of our public actions. The following example shows the default verb filter
    that is used by `yii\rest\ActiveController`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自定义API端点时，您可能只想允许某些HTTP动词针对这些操作发出。例如，向删除用户的端点发出PUT请求没有太多意义。控制可以对我们的操作执行哪些HTTP动词的一种方法是通过使用`yii\filters\VerbFilter`。在使用`yii\filters\VerbFilter`时，我们只需指定每个公共操作将接受哪些HTTP动词。以下示例显示了`yii\rest\ActiveController`使用的默认动词过滤器：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Cross-origin resource headers
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨源资源头部
- en: 'When working with JavaScript applications that issue AJAX requests against
    your API, you may want to use **cross-origin resource sharing** (**CORS**) headers
    to ensure that only domains that you specify can run against your domain. CORS
    headers can be implemented by adding `yii\filters\Cors` to your `behaviors()`
    method, as shown in the following example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当与对您的API发出AJAX请求的JavaScript应用程序一起工作时，您可能希望使用**跨源资源共享**（**CORS**）头部以确保只有您指定的域可以运行。可以通过将`yii\filters\Cors`添加到您的`behaviors()`方法来实现CORS头部，如下例所示：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This behavior can be extended by setting specific CORS headers that you want
    to specify for your controller:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置特定的CORS头部，您可以扩展此行为，这些头部是您希望为您的控制器指定的：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: CORS headers have a very specific purpose when it comes to preventing AJAX requests
    from browsers and other domains from accessing content on your domain, and they
    are meant to be implemented as a security precaution for your end users rather
    than your API. CORS headers will not prevent tools such as CURL or noncompliant
    browsers from accessing your API. Before implementing CORS, ensure that you have
    a concrete understanding of what they are, what they protect against, and what
    headers to use. For more information on CORS, refer to the W3C reference guide
    at [http://www.w3.org/TR/cors/](http://www.w3.org/TR/cors/).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到防止来自浏览器和其他域的AJAX请求访问您的域内容时，CORS（跨源资源共享）头部具有一个非常具体的目的，并且它们旨在作为对您的最终用户的安全预防措施，而不是您的API。CORS头部不会阻止CURL等工具或不符合规范的浏览器访问您的API。在实施CORS之前，请确保您对它们有具体的理解，了解它们保护什么，以及使用哪些头部。有关CORS的更多信息，请参阅W3C参考指南[http://www.w3.org/TR/cors/](http://www.w3.org/TR/cors/)。
- en: Rate Limiting
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 速率限制
- en: When creating APIs, you may want to implement rate limiting within your API
    to prevent excessive requests being made to your API and exhausting server resources.
    This is extremely important if your API is dependent upon another API that has
    rate limits already in place. Rate limiting in Yii2 is implemented by `yii\filters\RateLimiter`
    and `yii\filters\RateLimitInterface`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建API时，您可能希望在API中实现速率限制，以防止对API进行过多的请求并耗尽服务器资源。如果您的API依赖于已经设置了速率限制的另一个API，这一点尤为重要。在Yii2中，速率限制是通过
    `yii\filters\RateLimiter` 和 `yii\filters\RateLimitInterface` 实现的。
- en: 'To get started with rate limiting, we first need to add `yii\filters\Ratelimiter`
    to our controller behaviors. The `yii\filters\RateLimiter` class is coupled to
    our user identity class. Consequently, rate limiting will only be applied to actions
    that are protected by authentication. Any action that is not protected by an authenticate
    filter will not have rate limiting applied to it. The following example illustrates
    the code blocks required to implement `yii\filters\RateLimiter` within our controller:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用速率限制，我们首先需要将 `yii\filters\Ratelimiter` 添加到我们的控制器行为中。`yii\filters\RateLimiter`
    类与我们的用户身份类耦合。因此，速率限制只会应用于受认证保护的操作。任何未受认证过滤器保护的操作都不会应用速率限制。以下示例说明了在控制器中实现 `yii\filters\RateLimiter`
    所需的代码块：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we need to implement the required methods in our user identity class
    with the `yii\filters\RateLimitInterface` interface. The first method, `yii\filters\RateLimitInterface::getRateLimit()`,
    defines the number of requests we can make in a unit of time. For global rate
    limiting, we can simply return `[100, 600]`, which will allow 100 requests in
    600 seconds. As the complete request and action are passed to the `yii\filters\RateLimitInterface::getRateLimit()`
    method, however, we can further refine our rate limits for each controller and
    action pairing:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的用户身份类中实现 `yii\filters\RateLimitInterface` 接口所需的方法。第一个方法 `yii\filters\RateLimitInterface::getRateLimit()`
    定义了我们在单位时间内可以发出的请求数量。对于全局速率限制，我们可以简单地返回 `[100, 600]`，这将允许在600秒内发出100个请求。然而，由于完整的请求和操作都传递给了
    `yii\filters\RateLimitInterface::getRateLimit()` 方法，因此我们可以进一步细化每个控制器和操作配对的速率限制：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Tip
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`yii\filters\RateLimiter` is coupled with your user identity. If you want to
    implement rate limiting for unauthenticated users, you will need to implement
    a custom filter.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`yii\filters\RateLimiter` 与您的用户身份耦合。如果您想为未认证的用户实现速率限制，您需要实现一个自定义过滤器。'
- en: 'Next, we need to implement two methods to load the available rate limits and
    update the available rate limits after each request. These two methods are `yii\filters\RateLimitInterface::loadAllowance()`
    and `yii\filters\RateLimitInterface::saveAllowance()`. As rate limit data isn''t
    considered sensitive and won''t have a significant impact upon our application
    if the data is accidentally removed, this data can be stored either in our cache
    component or within a NoSQL solution, such as MongoDB or Redis. The method signatures
    are defined as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现两种方法来加载可用的速率限制，并在每次请求后更新可用的速率限制。这两种方法是 `yii\filters\RateLimitInterface::loadAllowance()`
    和 `yii\filters\RateLimitInterface::saveAllowance()`。由于速率限制数据并不被视为敏感信息，并且如果数据意外删除，对我们的应用程序也不会有重大影响，因此这些数据可以存储在我们的缓存组件中，或者存储在NoSQL解决方案中，例如MongoDB或Redis。方法签名定义如下：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Combined together, our extended class will look as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 结合起来，我们的扩展类将如下所示：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, when your query against authenticated API endpoints, the following additional
    headers will be returned with the response:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您查询受保护的API端点时，响应将返回以下附加头信息：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Now that you have MinGW and MSYS, there's no need to be jealous of those with
    a Linux installation anymore, since they implement in your system the most important
    parts of a Linux development environment.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了MinGW和MSYS，您不再需要羡慕那些拥有Linux安装的用户了，因为它们在您的系统中实现了Linux开发环境的最重要部分。
- en: Error handling
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'By extending `yii\rest\Controller` (or `yii\rest\ActiveController`), we can
    easily implement error handling in our application by defining a proper error
    handler within our configuration, as illustrated in previous chapters:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展 `yii\rest\Controller`（或 `yii\rest\ActiveController`），我们可以在配置中定义适当的错误处理器，从而轻松地在我们的应用程序中实现错误处理，如前几章所示：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Unlike view-based responses, we do not need to include a definition within
    the `actions()` method of our controller for the error handler that we want to
    use. Instead, we can simply return the error as it occurs, or we can override
    the error to display a more generic response:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于视图的响应不同，我们不需要在我们的控制器`actions()`方法中包含我们想要使用的错误处理程序的定义。相反，我们可以简单地返回发生的错误，或者我们可以覆盖错误以显示更通用的响应：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Custom API controllers
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义API控制器
- en: While convenient, `yii\rest\ActiveController` doesn't solve every problem with
    creating APIs. When not using `yii\rest\ActiveController`, you'll want to extend
    your controller classes from `yii\rest\Controller` in order to take full advantage
    the built-in REST API defaults implemented by `yii\rest\Controller`. The following
    sections illustrate some additional information on creating custom API controllers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然方便，但`yii\rest\ActiveController`并不能解决创建API时遇到的每一个问题。当不使用`yii\rest\ActiveController`时，您可能希望从`yii\rest\Controller`扩展您的控制器类，以充分利用`yii\rest\Controller`实现的内置REST
    API默认值。以下部分说明了创建自定义API控制器的一些附加信息。
- en: Returning data
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回数据
- en: 'There are several way in which we can think about custom API controllers in
    Yii2\. The easiest way to think about passing data to our clients is to bypass
    the view portion of our MVC model and directly return data from our controllers.
    For example, if we were to create a new controller called `SiteController` within
    our controller''s namespace, we could directly return data from our newly created
    controller, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yii2中，我们可以以几种方式考虑自定义API控制器。考虑将数据传递给客户端的最简单方法是通过绕过MVC模型中的视图部分，直接从我们的控制器返回数据。例如，如果我们要在我们的控制器命名空间内创建一个名为`SiteController`的新控制器，我们可以直接从我们新创建的控制器返回数据，如下所示：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Remember, once we start making changes to our default URL manager rules, we''ll
    need to add the rules required to route data to other controllers. This rule will
    ensure that `site/<action> maps` back to our site controller: `[''class'' => ''yii\web\UrlRule'',
    ''pattern'' => ''site/<action>'', ''route'' => ''site/index'']`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一旦我们开始修改我们的默认URL管理器规则，我们就需要添加将数据路由到其他控制器的所需规则。此规则将确保`site/<action> maps`回我们的`site`控制器：`['class'
    => 'yii\web\UrlRule', 'pattern' => 'site/<action>', 'route' => 'site/index']`。
- en: 'Curling against the site/index endpoint of our API will return the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们API的`site/index`端点进行Curl请求将返回以下内容：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Response Formatting
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应格式化
- en: Yii2 has a very specific response structure that it will return with the default
    `yii\rest\Controller`. When creating an API, you may already have a specific response
    structure you may want to use (for instance, if you're refactoring an existing
    but outdated API with a Yii2 API). You may also want to have a uniform structure
    in your API responses as the responses provided by `yii\rest\Controller` and `yii\rest\ActiveController`
    don't match up (as illustrated by the previous sections).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Yii2有一个非常具体的响应结构，它将使用默认的`yii\rest\Controller`返回。当创建API时，您可能已经有一个特定的响应结构您可能想要使用（例如，如果您正在重构一个现有的但过时的API，并使用Yii2
    API）。您可能还希望您的API响应具有统一的格式，因为`yii\rest\Controller`和`yii\rest\ActiveController`提供的响应不匹配（如前几节所示）。
- en: 'In these situations, you''ll need to modify the response structure. To do this,
    we simply need to override the `response` component of our application and modify
    the `$response->data` variable within the `beforeSend` event with the actual response
    that we want. In this example, we will have the following response structure:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，您需要修改响应结构。为此，我们只需覆盖我们应用程序的`response`组件，并在`beforeSend`事件中修改`$response->data`变量，以包含我们想要的实际响应。在这个例子中，我们将有以下响应结构：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The code required to make this change is shown as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此更改所需的代码如下所示：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, if we were to query our API, we would receive a uniform response structure
    for both our `SiteController` and `UserController`. This is for `SiteController`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们查询我们的API，我们将为我们的`SiteController`和`UserController`都收到一个统一响应结构。这是针对`SiteController`的：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This query regards `UserController`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '本查询涉及`UserController`:'
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we expanded upon our knowledge of everything we've learned
    thus far and also learned how to create RESTful JSON and XML APIs in Yii2\. First,
    we covered the usage of `yii\rest\ActiveController`, which enabled us to quickly
    create CRUD APIs based upon our model classes. We then covered Yii2's built-in
    authentication filters and covered how we can protect our resources by requiring
    authentication. We also covered the creation of our own authentication filters
    to support different authentication schemes. We then covered several other useful
    API classes, including `yii\filters\VerbFilter, yii\filters\Cors`, and learned
    how to handle errors within our API. Additionally, we detailed some important
    information about creating our own API endpoints by extending `yii\rest\Controller`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们扩展了我们迄今为止所学的所有知识，并学习了如何在Yii2中创建RESTful JSON和XML API。首先，我们介绍了`yii\rest\ActiveController`的用法，这使得我们能够快速基于我们的模型类创建CRUD
    API。然后，我们介绍了Yii2的内置身份验证过滤器，并介绍了我们如何通过要求身份验证来保护我们的资源。我们还介绍了创建自己的身份验证过滤器以支持不同的身份验证方案。接着，我们介绍了几个其他有用的API类，包括`yii\filters\VerbFilter`、`yii\filters\Cors`，并学习了如何在我们的API中处理错误。此外，我们还详细介绍了通过扩展`yii\rest\Controller`来创建自己的API端点的一些重要信息。
- en: 'Having covered all the information required to build applications in Yii2,
    we''ll spend the remaining chapters of this book exploring ways in which we can
    enhance our applications. In the next chapter, we''ll specifically go over one
    of the most important aspect of building applications: testing. We''ll cover how
    to set up testing within our application using a powerful called Codeception,
    and we will detail how to set up and create function, unit, and acceptance testing
    as well as how to create data fixtures to test with.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在涵盖了构建Yii2应用程序所需的所有信息之后，我们将花费本书剩余的章节来探讨如何增强我们的应用程序。在下一章中，我们将具体介绍构建应用程序最重要的一个方面：测试。我们将介绍如何使用强大的Codeception工具在我们的应用程序中设置测试，并详细说明如何设置和创建功能测试、单元测试和验收测试，以及如何创建用于测试的数据固定值。
