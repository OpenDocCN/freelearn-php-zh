- en: Chapter 2. Reactive Programming with RxPHP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。使用 RxPHP 进行反应式编程
- en: In this chapter, we're going to have a better look at how we can use PHP's reactive
    extension library RxPHP. We'll mostly build on what we saw in the previous chapter,
    but going into greater detail.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地了解如何使用 PHP 的反应式扩展库 RxPHP。我们将主要基于前一章的内容，但会进行更详细的探讨。
- en: 'In particular, we''ll go through the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是以下内容：
- en: Various components of RxPHP that we'll use in this and all further chapters.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在本章和所有后续章节中使用 RxPHP 的各种组件。
- en: We'll quickly have a look at how to read and understand the Rx documentation.
    In particular, we'll have a look at marble diagrams that explain the functionality
    of Rx operators.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将快速浏览如何阅读和理解 Rx 文档。特别是，我们将查看解释 Rx 操作符功能的宝石图。
- en: List a few basic operators that we'll use throughout the entire book and explain
    their functionality.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出我们将全书使用的几个基本操作符及其功能说明。
- en: Write custom operator that decodes JSON strings into their appropriate array
    representations while properly handling errors.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义操作符，将 JSON 字符串解码成适当的数组表示，同时正确处理错误。
- en: Implement a simple script that downloads an HTML page via cURL. Then compare
    the same approach when utilizing RxPHP.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个简单的脚本，通过 cURL 下载 HTML 页面。然后比较使用 RxPHP 的相同方法。
- en: How to write a custom Observable for our cURL example.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为我们的 cURL 示例编写自定义的可观察对象。
- en: We'll dig into RxPHP's source code and see what happens when we use built-in
    Observables and operators.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将深入研究 RxPHP 的源代码，看看当我们使用内置的可观察对象和操作符时会发生什么。
- en: Before we look into each part of RxPHP separately, we'll quickly mention some
    very common terms that we'll use when talking about various aspects of Reactive
    Extensions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们单独查看 RxPHP 的各个部分之前，我们将简要提及一些非常常见的术语，这些术语将在我们讨论反应式扩展的各个方面时使用。
- en: Basic principles of Reactive Extensions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式扩展的基本原理
- en: Let's have a look at a very simple example of RxPHP, similar to what we did
    in the previous chapter, and use it to demonstrate some of the basic principles
    behind Reactive Extensions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个非常简单的 RxPHP 示例，类似于我们在前一章中做的，并使用它来展示反应式扩展背后的基本原理。
- en: 'We won''t bother with defining an observer right now and will focus only on
    Observables and operators:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会麻烦定义观察者，而只关注可观察对象和操作符：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we have one Observable, two operators and one observer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个可观察对象，两个操作符和一个观察者。
- en: An Observable can be chained with operators. In this example, the operators
    are `map()` and `filter()`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象可以与操作符链式连接。在这个例子中，操作符是 `map()` 和 `filter()`。
- en: Observables have the `subscribe()` method that is used by observers to start
    receiving values at the end of the chain.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象有 `subscribe()` 方法，观察者使用它来在链的末尾开始接收值。
- en: 'We can represent this chain by the following diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下图表来表示这个链：
- en: '![Basic principles of Reactive Extensions](img/00005.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![反应式扩展的基本原理](img/00005.jpeg)'
- en: Each arrow shows the direction of propagation of items and notifications
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个箭头都显示了项目通知的传播方向。
- en: We should probably explain the difference between using Observables and just
    iterating the array.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要解释使用可观察对象和迭代数组之间的区别。
- en: Observables are like a push model, where a value is pushed down the operator
    chain when it's ready. This is very important because it's the Observable that
    decides when it should emit the next value. The internal logic of Observables
    can do whatever it needs to (for example, it can run some asynchronous task) and
    still remain completely hidden.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象就像一个推送模型，当值准备好时，它会被推送到操作符链中。这一点非常重要，因为可观察对象决定了何时应该发出下一个值。可观察对象的内部逻辑可以执行它需要的任何操作（例如，运行一些异步任务），并且仍然保持完全隐藏。
- en: A similar concept to Observables are Promises. However, while a Promise represents
    a single value that will exist in the future, an Observable represents a stream
    of values.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与可观察对象类似的概念是承诺。然而，虽然承诺代表未来将存在的单个值，但可观察对象代表一系列值。
- en: On the other hand, iterating the array is like a pull model. We'd be pulling
    one item after another. The important consequence is that we'd have to have the
    array prepared beforehand (that's before we start iterating it).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，迭代数组就像一个拉模型。我们会一个接一个地拉取项目。重要的后果是，我们必须事先准备好数组（即在开始迭代之前）。
- en: Another important difference is that Observables behave like a data stream (or
    data flow). We talked about streams in [Chapter 1](part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d
    "Chapter 1. Introduction to Reactive Programming"), *Introduction to Reactive
    Programming*. In practice, this means that an Observable knows when it has emitted
    all its items, or when an error has occurred and is able to send proper notification
    down the chain.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的区别是，Observables的行为类似于数据流（或数据流）。我们在[第1章](part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d
    "第1章。响应式编程简介")，*响应式编程简介*中讨论了流。在实践中，这意味着Observable知道它已经发出了所有项目，或者当发生错误时能够向下发送适当的通知。
- en: 'For this reason, Observables can call three different methods on their observers
    (we''ll see how this is implemented later in this chapter when we write a custom
    operator and a custom Observable):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Observables可以在它们的观察者上调用三种不同的方法（我们将在本章后面编写自定义操作符和自定义Observable时看到这是如何实现的）：
- en: '`onNext`: This method is called when the next item is ready to be emitted.
    We typically say that "an Observable emits an item".'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNext`：当下一个项目准备好发出时，会调用此方法。我们通常说“Observable发出一个项目”。'
- en: '`onError`: Notification called when an error has occurred. This could be any
    type of error represented by an instance of the `Exception` class.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`：当发生错误时调用的通知。这可能是由`Exception`类的实例表示的任何类型的错误。'
- en: '`onComplete`: Notification called when there''re no more items to be emitted.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onComplete`：当没有更多项目要发出时调用的通知。'
- en: Each Observable can emit zero or more items.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Observable可以发出零个或多个项目。
- en: Each Observable can send one error, or one complete notification; but never
    both.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Observable可以发送一个错误，或者一个完整的通知；但不能同时发送两者。
- en: This is why the `CallbackObserver` class we used in [Chapter 1](part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d
    "Chapter 1. Introduction to Reactive Programming"), *Introduction to Reactive
    Programming*, takes three callables as arguments. These callables are called when
    the observer receives a next item, on error notification or on complete notification,
    respectively. All three callables are optional parameters and we can decide to
    ignore any of them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们在[第1章](part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d
    "第1章。响应式编程简介")，*响应式编程简介*中使用的`CallbackObserver`类，将三个可调用函数作为参数。这些可调用函数分别在观察者收到下一个项目、错误通知或完成通知时被调用。所有三个可调用函数都是可选参数，我们可以决定忽略任何一个。
- en: 'For example, we can make an observer like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个如下所示的观察者：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This observer defines all three callables. We can test it on the Observable
    we defined above and have a look at its output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个观察者定义了所有三个可调用函数。我们可以在上面定义的Observable上测试它，并查看其输出：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can see that only three values passed the `filter()` operator, followed by
    a proper complete notification at the end.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，只有三个值通过了`filter()`操作符，并在最后有一个适当的完成通知。
- en: 'In RxPHP, every operator that takes a callable as an argument wraps its call
    internally with `try…catch` block. If the callable throws `Exception`, then this
    `Exception` is sent as `onError` notification. Consider the following example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxPHP中，每个接受可调用函数作为参数的操作符都会用`try…catch`块内部包装其调用。如果可调用函数抛出`Exception`，则此`Exception`作为`onError`通知发送。考虑以下示例：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the same observer that we defined previously, this example will have the
    following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前定义的相同观察者，此示例将产生以下输出：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's important to see that, when an error occurred, no more items were emitted,
    there's also no complete notification. This is because, when the observer received
    an error, it automatically unsubscribed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，当发生错误时，不再发出更多项目，也没有完整的通知。这是因为，当观察者收到错误时，它会自动取消订阅。
- en: We'll talk more about the process behind subscribing and unsubscribing in [Chapter
    3](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d "Chapter 3. Writing
    a Reddit Reader with RxPHP"), *Writing a Reddit Reader with RxPHP*, and in [Chapter
    10](part0070_split_000.html#22O7C1-bd355a22cf10407cb10df27e65585b8d "Chapter 10. Using
    Advanced Operators and Techniques in RxPHP"), *Using Advanced Operators and Techniques
    in RxPHP*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d "第3章。使用RxPHP编写Reddit阅读器")，*使用RxPHP编写Reddit阅读器*和[第10章](part0070_split_000.html#22O7C1-bd355a22cf10407cb10df27e65585b8d
    "第10章。在RxPHP中使用高级操作符和技术")，*在RxPHP中使用高级操作符和技术*中更多地讨论订阅和取消订阅背后的过程。
- en: In [Chapter 8](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d
    "Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension"), *Multicasting
    in RxPHP and PHP7 pthreads Extension*, we'll look more in-depth into what happens
    inside observers when they receive an error or complete notification.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d "第8章。RxPHP和PHP7
    pthreads扩展中的多播")中，我们将更深入地探讨当观察者接收到错误或完成通知时在观察者内部发生的情况。
- en: One last thing before we move on. We said that Observables represent data streams.
    The great advantage of this is that we can easily combine or split streams, similar
    to what we saw in [Chapter 1](part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d
    "Chapter 1. Introduction to Reactive Programming"), *Introduction to Reactive
    Programming*, when talking about the `gulp` build tool.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有一点需要说明。我们提到可观察对象代表数据流。这个优点在于我们可以轻松地合并或拆分流，类似于我们在[第1章](part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d
    "第1章。响应式编程简介")中提到的`gulp`构建工具。
- en: 'Let''s have a look at a slightly more advanced example of merging two Observables:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个稍微复杂一点的例子，合并两个可观察对象：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We used the `merge()` operator to combine the existing Observable with another
    Observable. Notice that we can add the operator anywhere we want. Since we added
    it after the `filter()` operator and before the `subscribe()` call, the items
    from the second Observable are going to be emitted right into the observer and
    will skip the preceding operator chain.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`merge()`操作符将现有的可观察对象与另一个可观察对象合并。注意，我们可以在任何我们想要的地方添加操作符。由于我们在`filter()`操作符之后和`subscribe()`调用之前添加了它，第二个可观察对象的项将直接发送到观察者，并跳过前面的操作符链。
- en: 'We can represent this chain by the following diagram:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下图表来表示这个链：
- en: '![Basic principles of Reactive Extensions](img/00006.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![响应式扩展的基本原理](img/00006.jpeg)'
- en: 'The output for this example looks like the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的输出如下所示：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These principles apply to all Rx implementations. Now, we should have a basic
    idea of what working with Observables, observers and operators in Rx looks like
    and we can talk more about each of them separately.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则适用于所有Rx实现。现在，我们应该对在Rx中使用可观察对象、观察者和操作符有一个基本的了解，然后我们可以分别讨论它们。
- en: Naming conventions in Reactive Extensions
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式扩展的命名规范
- en: When talking about Observables, we use terms such as **emit/send value/item**.
    Commonly, we say that **an Observable emits an item**, but we understand the same
    from **an Observable sends a value** as well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论可观察对象时，我们使用诸如**发出/发送值/项**之类的术语。通常，我们说**一个可观察对象发出一个项**，但我们同样理解**一个可观察对象发送一个值**。
- en: By **emit/send** we mean that an Observable is calling the `onNext` method on
    an observer.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**发出/发送**，我们指的是一个可观察对象在观察者上调用`onNext`方法。
- en: When talking about Observables, we use terms such as **send error/complete notification/signal**.
    We also often mention that **an Observable completes**, which means that an Observable
    has sent a complete notification.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论可观察对象时，我们使用诸如**发送错误/完成通知/信号**之类的术语。我们也经常提到**一个可观察对象完成了**，这意味着一个可观察对象已经发送了一个完成通知。
- en: By **notification/signal** we mean that an Observable is calling the `onError`
    or `onComplete` method on an observer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**通知/信号**，我们指的是一个可观察对象在观察者上调用`onError`或`onComplete`方法。
- en: In the preceding paragraph, we worked with a simple RxPHP demo that had one
    Observable, two operators and one observer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的段落中，我们使用了一个简单的RxPHP演示，其中有一个可观察对象、两个操作符和一个观察者。
- en: This structure formed an **operator/Observable chain**. We'll understand the
    same thing from both of the terms **operator chain** and **Observable chain**
    (sometimes also referred to as a **chain of Observable operators**). This is because,
    from our perspective, we're chaining operators; but under the hood, each operator
    returns another instance of the `Observable` class, so, in fact, we're chaining
    Observables. In practice, this doesn't matter, so we'll just remember that these
    have the same meaning.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构形成了一个**操作符/可观察对象链**。我们将从**操作符链**和**可观察对象链**（有时也称为**可观察对象操作符链**）这两个术语中理解相同的内容。这是因为从我们的角度来看，我们正在链式调用操作符；但在底层，每个操作符都返回`Observable`类的另一个实例，所以实际上我们是在链式调用可观察对象。在实践中，这并不重要，所以我们只需记住它们具有相同的意义。
- en: When talking about Observable chains, we sometimes use the term **source Observable**.
    This is the source of items in the chain. In other words, it's the first Observable
    in the chain. In the preceding example, the source Observable was `Observable::fromArray($fruits)`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到可观察对象链时，我们有时会使用术语**源可观察对象**。这是链中项目的来源。换句话说，它是链中的第一个可观察对象。在先前的示例中，源可观察对象是`Observable::fromArray($fruits)`。
- en: When talking about operators, we use the term source Observable to also describe
    the Observable directly preceding this particular operator (because it's the source
    of items for this operator).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到算子时，我们使用术语源可观察对象来描述直接位于此特定算子之前的可观察对象（因为它为该算子提供项目来源）。
- en: Sometimes instead of the `onNext`, `onError` and `onComplete` terms and method
    names, you'll encounter just `next`, `error` and `complete`. This comes from RxJS
    5, which follows the ES7 Observable specification ( [https://github.com/tc39/proposal-observable](https://github.com/tc39/proposal-observable)
    ), but their meaning is exactly the same. Most Rx implementations use the names 
    `onNext`, `onError` and `onComplete`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会遇到只是`next`、`error`和`complete`这样的术语和方法名，而不是`onNext`、`onError`和`onComplete`。这来自RxJS
    5，它遵循ES7可观察对象规范（[https://github.com/tc39/proposal-observable](https://github.com/tc39/proposal-observable)），但它们的含义完全相同。大多数Rx实现使用名称`onNext`、`onError`和`onComplete`。
- en: All these terms are used in various literature and articles regarding Rx, so
    we'll tolerate all of them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些术语都用于各种关于Rx的文献和文章中，因此我们将容忍所有这些术语。
- en: Components of RxPHP
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxPHP组件
- en: Since this chapter is going to be mostly about Observables, observers and operators,
    we're going to start with them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章将主要关于可观察对象、观察者和算子，我们将从它们开始。
- en: We've already seen a sneak peak in this chapter, and now we'll go into more
    detail.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经看到了一个预览，现在我们将更详细地介绍。
- en: Observables
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察对象
- en: Observables emit items. In other words, Observables are sources of values. Observers
    can subscribe to Observables in order to be notified when the next item is ready,
    all items have been emitted, or an error has occurred.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象发出项目。换句话说，可观察对象是值的来源。观察者可以订阅可观察对象，以便在下一个项目准备好、所有项目都已发出或发生错误时被通知。
- en: The main difference between an Observable (in the sense of reactive programming)
    and the observer pattern is that an Observable can tell you when all of the data
    has been emitted and when an error occurs. All three types of events are consumed
    by observers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象（在响应式编程的意义上）与观察者模式之间的主要区别是，可观察对象可以告诉你何时所有数据都已发出，何时发生错误。所有三种类型的事件都被观察者消费。
- en: 'RxPHP comes with several basic types of Observables for general usage. Here
    are a few that are easy to use:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: RxPHP附带了几种基本类型的可观察对象，适用于一般用途。以下是一些易于使用的例子：
- en: '`ArrayObservable`: This creates an Observable from an array and emits all values
    right after the first observer subscribes.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayObservable`：它从一个数组创建一个可观察对象，并在第一个观察者订阅后立即发出所有值。'
- en: '`RangeObservable`: This generates a sequence of numbers from a predefined range.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RangeObservable`：它从预定义的范围内生成一个数字序列。'
- en: '`IteratorObservable`: This iterates and emits each item in the iterable. This
    can be any array wrapped as Iterator. Consider the following example, where we
    iterate an array instead of using `ArrayObservable`:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IteratorObservable`：它遍历并发出可迭代中的每个项目。这可以是任何作为迭代器包装的数组。考虑以下示例，我们遍历一个数组而不是使用`ArrayObservable`：'
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that this also includes generators. Consider another example with an anonymous
    function and `yield` keyword.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这还包括生成器。考虑另一个使用匿名函数和`yield`关键字的例子。
- en: '[PRE8]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Calling the `$iterator()`function returns an instance of a `Generator` class
    that implements the Iterator interface. However, these basic Observables are good
    mostly for demonstration purposes and are not very practical in real-world usage.
    In a PHP environment, we can't create Observables from mouse events as in JavaScript
    and RxJS, so we'll have to learn how to write custom Observables very soon in
    this chapter in order to create some real-world examples. In [Chapter 3](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 3. Writing a Reddit Reader with RxPHP"), *Writing a Reddit Reader with
    RxPHP*, we'll learn about the `Observable::create()` static method to create Observables
    with some basic custom logic. But, more on that later.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `$iterator()` 函数返回一个实现了 Iterator 接口的 `Generator` 类的实例。然而，这些基本 Observables
    主要用于演示目的，在现实世界的使用中并不实用。在 PHP 环境中，我们无法像在 JavaScript 和 RxJS 中那样从鼠标事件创建 Observables，因此我们将在本章中很快学习如何编写自定义
    Observables，以便创建一些真实世界的示例。在 [第 3 章](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "第 3 章。使用 RxPHP 编写 Reddit 阅读器")，*使用 RxPHP 编写 Reddit 阅读器*，我们将学习 `Observable::create()`
    静态方法来创建具有一些基本自定义逻辑的 Observables。但，关于这一点我们稍后再说。
- en: 'Observables can be divided into two groups based on when they start emitting
    values:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们开始发出值的时间，Observables 可以分为两组：
- en: '**Hot**: In this group, values are emitted even when there are no observers
    subscribed. This is, for example, `Rx.Observable.fromEvent` from RxJS that we
    used in  [Chapter 1](part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d
    "Chapter 1. Introduction to Reactive Programming") , *Introduction to Reactive
    Programming*. This creates an Observable from any JavaScript event. Values are
    emitted immediately, so when you subscribe to this Observable some time later,
    you receive only new values and no previously emitted values.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热**: 在这个组中，即使在没有观察者订阅的情况下也会发出值。例如，这是我们在 [第 1 章](part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d
    "第 1 章。响应式编程简介") 中使用的 RxJS 的 `Rx.Observable.fromEvent`，*响应式编程简介*。这从一个任何 JavaScript
    事件创建一个 Observables。值立即发出，所以当你稍后订阅这个 Observables 时，你只会收到新值，而不会收到之前发出的值。'
- en: '**Cold**: In this group, values are emitted when at least one observer has
    been subscribed. This is, for example, RxPHP''s `ArrayObservable`. It creates
    an Observable and, every time we subscribe, we receive all values passed as an
    input to the `fromArray()` method.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冷**: 在这个组中，当至少有一个观察者订阅时才会发出值。例如，RxPHP 的 `ArrayObservable`。它创建一个 Observables，并且每次我们订阅时，我们都会收到传递给
    `fromArray()` 方法的所有值。'
- en: 'All built-in Observables in RxPHP can be instantiated easily by calling static
    methods from the `Rx\Observable` namespace. The following list represents the
    three Observables mentioned above:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在 RxPHP 中的内置 Observables 都可以通过从 `Rx\Observable` 命名空间调用静态方法轻松实例化。以下列表代表了上面提到的三个
    Observables：
- en: The `RxObservable::fromArray()` method returns `Rx\Observable\ArrayObservable`
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RxObservable::fromArray()` 方法返回 `Rx\Observable\ArrayObservable`'
- en: The `RxObservable::range()` method returns `Rx\Observable\RangeObservable`
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RxObservable::range()` 方法返回 `Rx\Observable\RangeObservable`'
- en: The `RxObservable::fromIterator()` method returns `Rx\Observable\IteratorObservable`
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RxObservable::fromIterator()` 方法返回 `Rx\Observable\IteratorObservable`'
- en: Don't be surprised that static method names don't necessarily match returned
    class names. Also, it's usually easier to use static calls than to instantiate
    Observables directly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不要惊讶静态方法名不一定与返回的类名匹配。此外，通常使用静态调用比直接实例化 Observables 更容易。
- en: Observers
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者
- en: Observers are consumers of Observables. In other words, observers react to Observables.
    We've already seen the `CallbackObserver` class, which takes three optional arguments
    representing callables for each type of signal.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者是 Observables 的消费者。换句话说，观察者对 Observables 做出反应。我们已经看到了 `CallbackObserver`
    类，它接受三个可选参数，代表每种类型信号的调用者。
- en: 'Consider a similar example that we used at the end of [Chapter 1](part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d
    "Chapter 1. Introduction to Reactive Programming") , *Introduction to Reactive
    Programming*, where we defined our observer:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个类似的例子，我们在 [第 1 章](part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d
    "第 1 章。响应式编程简介") 的结尾使用的例子，*响应式编程简介*，其中我们定义了我们的观察者：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `CallbackObserver` class lets us create a custom observer without necessarily
    extending the base class. Its constructor takes three optional arguments:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallbackObserver` 类允许我们创建一个自定义观察者，而不必一定扩展基类。它的构造函数接受三个可选参数：'
- en: '`onNext`: This callable is called when a new item from the source Observable
    is emitted. This is the most common callback we''ll use.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNext`：当源可观察者发射新项目时，将调用此调用函数。这是我们最常用的回调之一。'
- en: '`onComplete`: This callable is called when there are no items left and the
    Observable is done emitting items. Some Observables produce an infinite number
    of items and this callback is never called.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onComplete`：当没有剩余项目并且可观察者完成项目发射时，将调用此调用函数。一些可观察者会产生无限数量的项目，并且此回调永远不会被调用。'
- en: '`onError`: This callable is called when an error has occurred somewhere in
    the chain.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`：当链中出现错误时，将调用此调用函数。'
- en: 'We can write the same example in a more reusable form to quickly test what''s
    going on inside Observable chains:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将相同的示例编写成更可重用的形式，以便快速测试可观察者链内部的情况：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When extending `AbstractObserver`, the methods we need to implement are `completed()`, `next()`,
    and `error()`, with the same functionality as described previously.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当扩展`AbstractObserver`时，我们需要实现的方法是`completed()`、`next()`和`error()`，其功能与之前描述的相同。
- en: We're using the `subscribe()` method to subscribe an observer to an Observable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`subscribe()`方法将观察者订阅到可观察者上。
- en: There's also the `subscribeCallback()` method that takes just three callables
    as arguments. Since RxPHP 2, the `subscribeCallback()` method is deprecated and
    its functionality has been merged with `subscribe()`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有`subscribeCallback()`方法，它只接受三个调用函数作为参数。自RxPHP 2以来，`subscribeCallback()`方法已被弃用，其功能已合并到`subscribe()`中。
- en: 'This means that, in RxPHP 2, we can also write the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，在RxPHP 2中，我们也可以编写以下代码：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We made a single callable instead of subscribing with an observer. This handles
    only `onNext` signals.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个单一的调用函数，而不是使用观察者进行订阅。这仅处理`onNext`信号。
- en: Singles
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单个值
- en: 'Singles are like Observables; the only difference is that they always emit
    just one value. In RxPHP, we don''t distinguish any difference between Observables
    and Singles, so we can use the `Observable::just()` static method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 单个值就像可观察者一样；唯一的区别是它们总是只发射一个值。在RxPHP中，我们不会区分可观察者和单个值之间的任何区别，因此我们可以使用`Observable::just()`静态方法：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This creates a new Observable that calls `onNext()` with the value `42`, and
    immediately after that `onComplete()`. The output for this very simple example
    is the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的可观察者，它使用值`42`调用`onNext()`，然后立即调用`onComplete()`。这个非常简单的示例的输出如下：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Similar to the preceding explanation, calling `RxObservable::just()` static
    method returns an instance of `Rx\Observable\ReturnObservable`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的解释类似，调用`RxObservable::just()`静态方法返回一个`Rx\Observable\ReturnObservable`实例。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The term "Single" was used mostly in RxJS 4\. Since RxPHP was originally ported
    from RxJS 4, and later also took things from RxJS 5, you might encounter this
    term sometimes. If you're familiar only with RxJS 5, then you've probably never
    heard of it. Nonetheless, we'll always refer to all sources of values as Observables,
    even when they emit just a single, or no value at all.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: “单个”一词在RxJS 4中使用得最多。由于RxPHP最初是从RxJS 4移植过来的，后来也借鉴了RxJS 5的一些内容，你可能会偶尔遇到这个术语。如果你只熟悉RxJS
    5，那么你可能从未听说过它。尽管如此，我们始终将所有值源称为可观察者，即使它们只发射一个或没有任何值。
- en: Subject
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主题
- en: The `Subject` is a class that acts as an Observable and observer at the same
    time. This means that it can subscribe to an Observable just like an observer,
    and also emit values like an Observable does. Eventually, it can also emit its
    own values independently of its source Observable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subject`是一个同时充当可观察者和观察者的类。这意味着它可以像观察者一样订阅可观察者，也可以像可观察者一样发射值。最终，它还可以独立于其源可观察者发射自己的值。'
- en: In order to see how the `Subject` class can be used in different situations,
    we'll work through three examples based on the same example we used at the beginning
    of this chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解`Subject`类如何在不同的场景中使用，我们将基于本章开头使用的相同示例进行三个示例。
- en: 'We can use a `Subject` class instead of an Observable. However, we need to
    emit items manually by calling `onNext()` on the `Subject` instance:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Subject`类而不是可观察者。但是，我们需要通过在`Subject`实例上调用`onNext()`来手动发射项目：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code produces the same output as the original example with Observable:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码产生的输出与原始示例中的可观察者相同：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Another use case could be using `Subject` to subscribe to an Observable. We''ll
    reuse the `PrintObserver` class we made a moment ago to print all of the items
    and notifications that went through the `Subject` instance:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例可能是使用`Subject`来订阅可观察者。我们将重用我们刚才创建的`PrintObserver`类来打印通过`Subject`实例的所有项目和通知：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that we subscribed `PrintObserver` to the `Subject` and then subscribed
    the `Subject` at the end of the operator chain. As we can see, by default the `Subject`
    class just passes through both items and notifications. The output is the same
    as in the previous example.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将`PrintObserver`订阅到`Subject`上，然后在操作符链的末尾订阅`Subject`。正如我们所看到的，默认情况下，`Subject`类只是传递两个项目和通知。输出与上一个示例相同。
- en: 'The final situation we want to demonstrate is using an instance of Subject
    in the middle of an operator chain:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要展示的最终情况是在操作符链的中间使用`Subject`的一个实例：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Yet again, the console output is the same.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，控制台输出是相同的。
- en: Later in this chapter, we'll write the `DebugSubject` class, that we'll use
    many times throughout this book, to quickly see what's going on in our Observable
    chains.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将编写`DebugSubject`类，我们将在整本书中多次使用它，以便快速查看我们的可观察链中发生了什么。
- en: Disposable
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可丢弃对象
- en: 'All Rx implementations internally use the Dispose pattern. This design decision has
    two reasons:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Rx实现都内部使用销毁模式。这个设计决策有两个原因：
- en: To be able to unsubscribe from an Observable
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够从可观察对象中取消订阅
- en: To be able to release all data used by that Observable
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够释放该可观察对象使用的所有数据
- en: For example, if we had an Observable that downloads a large file from the Internet
    and saves it to a temporary location until it's completely downloaded, we'd like
    to remove the temporary file if its observer unsubscribed, or any error occurred.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个可观察对象，它从互联网下载一个大型文件并将其保存到临时位置，直到完全下载，我们希望在观察者取消订阅或发生任何错误时删除该临时文件。
- en: There're already a couple of classes available out-of-the-box with RxPHP, each
    with a different purpose. We don't need to worry about Disposables right now.
    We'll have a look at how they are used inside built-in Observables and operators
    in the next [Chapter 3](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 3. Writing a Reddit Reader with RxPHP"), *Writing a Reddit Reader with
    RxPHP*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxPHP中，已经有一些现成的类，每个类都有不同的用途。我们现在不需要担心可丢弃对象。我们将在下一章[第3章](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "第3章。使用RxPHP编写Reddit阅读器")，*使用RxPHP编写Reddit阅读器*中查看它们如何在内置的可观察对象和操作符中使用。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about the dispose pattern on Wikipedia [https://en.wikipedia.org/wiki/Dispose_pattern](https://en.wikipedia.org/wiki/Dispose_pattern)
    or, more specifically, why it's used in reactive extensions on StackOverflow 
    [http://stackoverflow.com/a/7707768/310726](http://stackoverflow.com/a/7707768/310726)
    .
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在维基百科上了解更多关于销毁模式的信息[https://en.wikipedia.org/wiki/Dispose_pattern](https://en.wikipedia.org/wiki/Dispose_pattern)，或者更具体地说，为什么它在反应式扩展中在StackOverflow上被使用[http://stackoverflow.com/a/7707768/310726](http://stackoverflow.com/a/7707768/310726)。
- en: However, it's good to know that something like releasing resources in Rx is
    important and we need to aware of it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，了解在Rx中像释放资源这样的操作很重要，我们需要对此有所了解。
- en: Scheduler
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调度器
- en: Observables and operators usually don't execute their work directly, but use
    an instance of the `Scheduler` class to decide how and when it should be executed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象和操作符通常不会直接执行它们的工作，而是使用`Scheduler`类的一个实例来决定如何以及何时执行。
- en: In practice, a `Scheduler` receives an action as an anonymous function and schedules
    its execution according to its internal logic. This is particularly relevant to
    all Observables and operators that need to work with time. For example, all delayed
    or periodical emissions need to schedule via a Scheduler.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`Scheduler`接收一个动作作为匿名函数，并根据其内部逻辑安排其执行。这对于所有需要与时间一起工作的可观察对象和操作符特别相关。例如，所有延迟或周期性发射都需要通过调度器进行安排。
- en: In languages such as JavaScript, this is relatively simple with, for example,
    the  `setTimeout()` function and the event-based nature of JavaScript interpreters.
    However, in PHP, where all code is executed strictly sequentially, we'll have
    to use an event loop.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在像JavaScript这样的语言中，这相对简单，例如使用`setTimeout()`函数和JavaScript解释器的基于事件的本质。然而，在PHP中，所有代码都是严格顺序执行的，我们将不得不使用事件循环。
- en: In most situations in RxPHP, we don't have to even worry about Schedulers because,
    if not set differently, all Observables and operators internally use the `ImmediateScheduler`
    class, which executes all actions immediately without any further logic.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxPHP的大多数情况下，我们甚至不需要担心调度器，因为如果没有设置不同的，所有可观察对象和操作符内部都使用`ImmediateScheduler`类，该类立即执行所有操作，而不需要任何进一步的逻辑。
- en: We'll encounter Schedulers once more at the end of this chapter, when talking
    about event loops.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的末尾再次遇到调度器，当我们讨论事件循环时。
- en: In [Chapter 6](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "Chapter 6. PHP Streams API and Higher-Order Observables"), *PHP Streams API and
    Higher-Order Observables*, we'll go into much more detail about event loops in
    PHP. We'll also talk about the Event Loop Interopability specification ([https://github.com/async-interop/event-loop](https://github.com/async-interop/event-loop))
    and how it's related to RxPHP.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d "第6章。PHP
    Streams API和高级Observables")，*PHP Streams API和高级Observables*中，我们将更详细地讨论PHP中的事件循环。我们还将讨论事件循环互操作性规范([https://github.com/async-interop/event-loop](https://github.com/async-interop/event-loop))以及它与RxPHP的关系。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In RxPHP 2, using Schedulers has been significantly simplified and, most of
    the time, we don't need to worry about event loops at all, as we'll see in [Chapter
    6](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d "Chapter 6. PHP
    Streams API and Higher-Order Observables"), *PHP Streams API and Higher-Order
    Observables*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxPHP 2中，使用调度器已经显著简化，大多数时候我们根本不需要担心事件循环，正如我们将在[第6章](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "第6章。PHP Streams API和高级Observables")，*PHP Streams API和高级Observables*中看到的。
- en: Operators
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作符
- en: We've used operators already without any further explanation, but now that we
    know how to use Observables, observers, and Subjects, it's time to see how operators
    glue this all together.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了操作符，但没有进一步的解释，但现在我们知道了如何使用Observables、observers和Subjects，是时候看看操作符是如何将这些全部粘合在一起的了。
- en: The core principle of Rx is using various operators to modify data flow. Typically,
    an operator returns another Observable and therefore allows the chaining of operator
    calls.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Rx的核心原则是使用各种操作符来修改数据流。通常，一个操作符返回另一个Observable，因此允许操作符调用的链式。
- en: In Rx, there are tons of operators, and in RxPHP in particular, there are about
    40 already. Other implementations such as RxJS have even more. Those include all
    we saw in the previous chapter when talking about functional programming, such
    as `map()`, `filter()`, and a lot more. This also includes operators for very
    specific use cases, such as `merge()`, `buffer()`, or `retry()`, just to name
    a few.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rx中，有大量的操作符，特别是在RxPHP中，已经有大约40个。其他实现，如RxJS，甚至更多。这包括我们在上一章讨论函数式编程时看到的全部内容，例如`map()`、`filter()`以及更多。这也包括针对非常特定用例的操作符，例如`merge()`、`buffer()`或`retry()`，仅举几例。
- en: The process of creating operator chains is a little more complicated under the
    hood than it seems. We don't need to worry about it for now because we'll talk
    about it again in [Chapter 3](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 3. Writing a Reddit Reader with RxPHP"), *Writing a Reddit Reader with
    RxPHP*. Before we start using more advanced operators in practice, we should have
    a look at how each operator is described in the documentation. This is mostly
    because some functionality isn't obvious at first sight and, when it comes to
    asynchronous events, it's sometimes hard to understand what each operator does.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层创建操作符链的过程比表面上看起来要复杂一些。我们现在不需要担心它，因为我们在[第3章](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "第3章。使用RxPHP编写Reddit阅读器")，*使用RxPHP编写Reddit阅读器*中还会再次讨论它。在我们开始实际使用更高级的操作符之前，我们应该看看文档中每个操作符是如何描述的。这主要是因为一些功能一开始并不明显，而且当涉及到异步事件时，有时很难理解每个操作符的作用。
- en: Understanding the operator diagrams
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解操作符图表
- en: Each operator is described in the documentation using a diagram called the **marble
    diagram**, where each marble represents an emitted value.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作符都在文档中使用称为**宝石图**的图表进行描述，其中每个宝石代表一个发出的值。
- en: The filter() operator
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: filter()操作符
- en: First, we'll have a look at how the `filter()` operator is defined. We used
    the PHP function `array_filter()` in the previous chapter, so we know that it
    takes values and a predicate function as input. Then it evaluates each value with
    the predicate and, based on whether it returns true or false, it adds or skips
    the value in its response array. The behavior of the `filter()` operator is the
    same, it just works with data flows instead of arrays. This means it receives
    items from its source (the preceding Observable) and propagates them to its consequent
    observer (or chained operator).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看看`filter()`操作符是如何定义的。我们在上一章中使用了PHP函数`array_filter()`，所以我们知道它接受值和谓词函数作为输入。然后它使用谓词评估每个值，并根据它返回true或false，将其值添加到其响应数组中或跳过该值。`filter()`操作符的行为相同，只是它处理的是数据流而不是数组。这意味着它从其源（前面的Observable）接收项目，并将它们传播到其后续观察者（或链式操作符）。
- en: 'Using a marble diagram, it will look like the following figure:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用水滴图，它看起来像以下图示：
- en: '![The filter() operator](img/00007.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![filter() 操作符](img/00007.jpeg)'
- en: Marble diagram representing the filter() Operator from http://reactivex.io/documentation/operators/filter.html
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 http://reactivex.io/documentation/operators/filter.html 的 filter() 操作符的水滴图
- en: 'Let''s exaplain this diagram in more detail:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释这个图：
- en: At the top and bottom, we have two timelines that represent Observables. The
    arrow in the top right corner suggests that time goes from left to right.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在顶部和底部，我们有两条时间线，代表 Observables。右上角的箭头表明时间从左到右流动。
- en: We can think of everything above the rectangle as input Observable and everything
    below the rectangle as output Observable. There're usually one or more input and
    only one output.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将矩形以上的内容视为输入 Observable，将矩形以下的内容视为输出 Observable。通常有一个或多个输入，只有一个输出。
- en: Each circle (marble) represents a single value in time emitted by its respective
    Observable. The number inside each circle stands for its value. All values are
    ordered by the time they were emitted, which goes from left to right. Different
    colors are used to make it obvious that values at the top and bottom are the same
    (for example the blue "30" at the top is the same value as the bottom "30").
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个圆圈（水滴）代表其各自的 Observable 在时间上发出的单个值。圆圈内部的数字代表其值。所有值按它们发出的时间顺序排列，从左到右。使用不同的颜色使其明显，顶部和底部的值是相同的（例如，顶部的蓝色
    "30" 与底部的 "30" 是相同的值）。
- en: 'The rectangle in the middle represents the transformation between the top and
    bottom Observables. Its functionality is usually described in words or pseudocode.
    In this case, we have an expression that looks like ES6 syntax, which says that
    it returns `true` if `x` is greater than `10`. Rewritten to PHP, it''s equal to
    the following:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间的矩形代表顶部和底部 Observables 之间的转换。其功能通常用文字或伪代码描述。在这种情况下，我们有一个看起来像 ES6 语法表达式的表达式，它表示如果
    `x` 大于 `10` 则返回 `true`。用 PHP 重新编写，它等于以下内容：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The bottom line, therefore, only contains circles with a value greater than `10`.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，最下面的一行只包含值大于 `10` 的圆圈。
- en: Vertical lines on the right side of each line mark the point where these Observables
    complete. This means they have emitted all values and sent an `onComplete` notification.
    The `filter()` operator has no effect on the `onComplete` notification, so both
    Observables end at the same time.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一行的右侧垂直线标记了这些 Observables 完成的点。这意味着它们已经发出了所有值并发送了一个 `onComplete` 通知。`filter()`
    操作符对 `onComplete` 通知没有影响，因此这两个 Observables 同时结束。
- en: This was pretty simple. Marble diagrams are a very comfortable way of representing
    data flows without worrying about implementation details (this reminds us of declarative
    programming, as we defined it in the first chapter, doesn't it?).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单。水滴图是一种非常舒适的方式来表示数据流，而不必担心实现细节（这让我们想起了我们在第一章中定义的声明式编程，不是吗？）。
- en: In some diagrams, you can also see a cross sign on the timeline, which represents
    an error (an `onError` notification to be precise). We'll see further on in this
    chapter that we can work with `onComplete` and `onError` notifications just as
    with `onNext`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些图中，你还可以看到时间线上的一个交叉符号，它代表一个错误（一个精确的 `onError` 通知）。我们将在本章后面看到，我们可以像处理 `onNext`
    一样处理 `onComplete` 和 `onError` 通知。
- en: The debounceTime() operator
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: debounceTime() 操作符
- en: 'Let''s have a look at another diagram. This time we have a `debounceTime()`
    operator from RxJS 5, which we saw in the first chapter, in the *Autocomplete
    with RxJS* example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个图。这次我们有一个来自 RxJS 5 的 `debounceTime()` 操作符，我们在第一章的 *使用 RxJS 实现自动完成* 示例中见过：
- en: '![The debounceTime() operator](img/00008.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![debounceTime() 操作符](img/00008.jpeg)'
- en: Marble diagram representing the debounceTime() operator from http://reactivex.io/documentation/operators/debounce.html
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 http://reactivex.io/documentation/operators/debounce.html 的 debounceTime()
    操作符的水滴图
- en: In the rectangle in the middle, we don't have any pseudocode this time; just
    a single expression `debounceTime(20)`. Well, in order to figure out what it does,
    we need to look at the documentation, or try to analyze the diagram.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间的矩形中，这次我们没有伪代码；只有一个表达式 `debounceTime(20)`。好吧，为了弄清楚它做什么，我们需要查看文档，或者尝试分析这个图。
- en: When the `debounceTime()` operator receives a value, it waits a certain interval
    before reemitting it. If any other values arrive before the interval expires,
    the original value is discarded and the later value is used instead; the interval
    is restarted as well. This can go on for an infinite number of values.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当`debounceTime()`操作符接收到一个值时，它会等待一定的时间间隔后再重新发出它。如果在间隔结束之前有其他值到达，原始值将被丢弃，并使用后来的值；同时，间隔也会重新开始。这可以无限进行下去。
- en: 'The diagram exactly describes the previous paragraph:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图表精确地描述了上一段文字：
- en: First, value **a** arrives. The transformation function waits until 20ms interval
    expires, and after that, the operator reemits the value further. The interval
    is represented by shifting the bottom values on the timeline slightly to the right.
    As we said previously, the horizontal lines represent values in time. When the
    bottom circle, labeled **a**, is shifted to the right, it means this event happened
    after the top **a** circle.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，值**a**到达。转换函数等待20毫秒的间隔结束，然后操作符重新发出该值。间隔通过在时间线上稍微向右移动底部值来表示。正如我们之前所说的，水平线代表时间中的值。当标记为**a**的底部圆圈向右移动时，这意味着这个事件发生在顶部的**a**圆圈之后。
- en: Then, two more values arrive, both of them in a very short time. The first one
    is discarded, but after the second one, there's another longer time gap, so only
    the second value gets reemitted.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，又有两个值到达，它们都非常短。第一个被丢弃，但在第二个之后，有一个更长的时间间隔，所以只有第二个值被重新发出。
- en: The process with the last value **d** is analogous to the first one.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最后一个值**d**的过程与第一个类似。
- en: This operator is useful when we know we can ignore some events that occur quickly
    after one another. A prime example is using `debounceTime()` for autocomplete
    features when we want to start searching after a user has stopped typing a keyword.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们知道可以忽略一些快速连续发生的事件时，这个操作符很有用。一个典型的例子是在用户停止输入关键字后，我们想要开始搜索时使用`debounceTime()`进行自动完成功能。
- en: The concat operator
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`concat`操作符'
- en: 'Now we can have a look at a slightly more complicated operator, which is `concat()`.
    Look at the following diagram and try to guess what it does:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看看一个稍微复杂一些的操作符，即`concat()`。看看下面的图表，并尝试猜测它做什么：
- en: '![The concat operator](img/00009.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![The concat operator](img/00009.jpeg)'
- en: Marble diagram representing the concat() operator from http://reactivex.io/documentation/operators/concat.html
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 来自http://reactivex.io/documentation/operators/concat.html的Marble图表表示`concat()`操作符
- en: 'Let''s analyze this together before looking to the documentation:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看文档之前，让我们一起来分析一下：
- en: At the top, we have two Observables as inputs to the operator.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在顶部，我们有两个可观测量作为操作符的输入。
- en: Both Observables should emit a value at the same time, but only the value from
    the first Observable is passed through. The same applies for the second and third
    values as well.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个可观测量应该同时发出一个值，但只有第一个可观测量的值被传递。同样，对于第二个和第三个值也是如此。
- en: Then the first Observable reaches the end and sends an `onComplete` notification.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，第一个可观测量到达了末尾，并发送了一个`onComplete`通知。
- en: Right after that, the operator starts emitting values from the second Observable.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧接着，操作符开始从第二个可观测量发出值。
- en: The `concat()` operator merges multiple Observables into one. It internally
    subscribes to each input Observable in order, one after another. This means that,
    when the first Observable completes, it subscribes to the next one. It's important
    to know that there's only ever one source Observable subscribed at a time (we'll
    work with `concat()` and a similar `merge()` operator in [Chapter 4](part0039_split_000.html#1565U2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 4. Reactive versus a Typical Event-Driven Approach"), *Reactive versus
    a typical Event-Driven Approach*).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat()`操作符将多个可观测量合并成一个。它内部按顺序订阅每个输入可观测量，一个接一个。这意味着，当第一个可观测量完成时，它会订阅下一个。重要的是要知道，一次只有一个源可观测量被订阅（我们将在[第4章](part0039_split_000.html#1565U2-bd355a22cf10407cb10df27e65585b8d
    "第4章。响应式与典型事件驱动方法")，*响应式与典型事件驱动方法*)中与`concat()`和类似的`merge()`操作符一起工作）。'
- en: In other words, the `concat()` operator concatenates multiple data streams into
    a single stream.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`concat()`操作符将多个数据流连接成一个单一的流。
- en: In the first chapter, we talked about functional programming and how most principles
    are the same in reactive programming. Implementing such a feature would be rather
    complicated because there's no built-in PHP function designed to deal with such
    a use case.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们讨论了函数式编程以及大多数原则在响应式编程中是相同的。实现这样的功能会比较复杂，因为没有内置的 PHP 函数专门用于处理这种用例。
- en: If we go back to the first chapter once more, we said that one key concept of
    reactive programming is to "express data flows with ease". This operator shows
    what that means in action.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次回到第一章，我们说过响应式编程的一个关键概念是“轻松表达数据流”。这个操作符展示了这意味着什么。
- en: Other common operators
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他常见操作符
- en: 'These were only three operators out of more than 40 available in RxPHP. Apart
    from very simple ones like `filter()` and `map()`, there''re also more sophisticated
    ones. We''ve seen `concat()` already, but here are a few interesting ones that
    we''ll use in further chapters:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是 RxPHP 中超过 40 个可用操作符中的三个。除了非常简单的如 `filter()` 和 `map()` 之外，还有一些更复杂的操作符。我们已经看到了
    `concat()`，但这里有一些在后续章节中会使用的有趣操作符：
- en: '`buffer()`: This operator has multiple variants, but all of them collect received
    values and reemits them in groups of a predefined size. For example, we can create
    groups of three items as follows:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buffer()`: 这个操作符有多个变体，但所有变体都会收集接收到的值，并以预定义大小的组重新发出。例如，我们可以创建包含三个项目的组如下：'
- en: '[PRE19]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Which prints the following output:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将打印以下输出：
- en: '[PRE20]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the last array contains just one value because the Observable sent
    an `onComplete` notification.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，最后一个数组只包含一个值，因为可观察对象发送了一个 `onComplete` 通知。
- en: '`merge()`: This operator merges all input Observables into a single output
    Observable, reemitting all values immediately (in contrast to `concat()`).'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`merge()`: 这个操作符将所有输入可观察对象合并为一个输出可观察对象，并立即重新发出所有值（与 `concat()` 相反）。'
- en: '`distinct()`: This operator reemits only those values that haven''t passed
    this operator before.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct()`: 这个操作符只重新发出之前未通过此操作符的值。'
- en: '`take()`: This operator reemits only a set number of values that arrive to
    the operator first, then sends an `onComplete` notification.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take()`: 这个操作符只重新发出到达操作符的第一个设定数量的值，然后发送一个 `onComplete` 通知。'
- en: '`retry()`: When source Observable sends `onError`, this operator tries to resubscribe
    automatically. You can also tell it to retry only a limited number of times until
    signaling `onError` (we''ll use this operator in [Chapter 4](part0039_split_000.html#1565U2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 4. Reactive versus a Typical Event-Driven Approach"), *Reactive versus
    a Typical Event-Driven Approach*).'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retry()`: 当源可观察对象发送 `onError` 时，这个操作符会尝试自动重新订阅。你也可以让它只尝试有限次数，直到发出 `onError`
    通知（我们将在 [第四章](part0039_split_000.html#1565U2-bd355a22cf10407cb10df27e65585b8d
    "第四章。响应式与典型事件驱动方法")，*响应式与典型事件驱动方法*）。'
- en: '`catchError()`: This operator lets us continue by subscribing to another Observable
    returned from its callback when an `onError` notification occurs.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catchError()`: 当发生 `onError` 通知时，这个操作符允许我们通过订阅其回调返回的另一个可观察对象来继续操作。'
- en: '`toArray()`: This operator collects all items from its source Observable and
    reemits them as a single array when the source Observable completes.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toArray()`: 这个操作符从其源可观察对象收集所有项目，并在源可观察对象完成时将它们作为一个单独的数组重新发出。'
- en: '`timeout()`: This operator sends an `onError` notification if no values arrived
    within a certain time span.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout()`: 如果在特定时间段内没有到达任何值，这个操作符会发送一个 `onError` 通知。'
- en: Enough theory; let's start writing our first custom class, which we'll utilize
    a few times throughout this book.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 理论已经足够，让我们开始编写我们的第一个自定义类，我们将在整本书中多次使用它。
- en: Writing the DebugSubject class
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 DebugSubject 类
- en: One common use case for `Subject` class is proxying all values and notifications
    from its source Observable.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subject` 类的一个常见用途是代理其源可观察对象的所有值和通知。'
- en: 'In one of the preceding paragraphs, we wrote the `PrintObserver` class, which
    prints all values it receives. However, a more common situation is where we want
    to output values from an Observable while being able to chain it with another
    operator or observer. The `Subject` class exactly fits this use case, so we''ll
    rewrite the preceding `PrintObserver` class and inherit `Subject` instead of `AbstractObserver`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的段落之一中，我们编写了 `PrintObserver` 类，它打印它接收到的所有值。然而，更常见的情况是我们希望在输出可观察对象的同时，能够将其与另一个操作符或观察者链式连接。`Subject`
    类正好符合这个用例，因此我们将重写前面的 `PrintObserver` 类，并继承 `Subject` 而不是 `AbstractObserver`：
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This `DebugSubject` class prints all values, their types, and the time they
    were received by the `DebugSubject`. It also allows us to set a unique identifier
    for each `DebugSubject` instance to be able to distinguish their output. We're
    going to use this class a couple of times throughout this book to quickly see
    what's going on inside our Observable chains.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`DebugSubject`类会打印出所有值、它们的类型以及它们被`DebugSubject`接收的时间。它还允许我们为每个`DebugSubject`实例设置一个唯一的标识符，以便能够区分它们的输出。我们将在整本书中多次使用这个类，以便快速查看Observable链内部的情况。'
- en: 'Then, using this class is just like using any other observer:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用这个类就像使用任何其他观察者一样：
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output in the console is as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出如下：
- en: '[PRE23]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Chaining Subjects and operators works just as with Observables:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 链式连接Subjects和操作符与连接Observables一样：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this example, we first created an instance of `DebugSubject`, then we chained
    it with the `map()` operator, which returns the lengths of each item. Finally,
    we subscribed another `DebugSubject` that will print only numbers because it''s
    placed after `map()`. Then we created an Observable from an array (we''ve seen
    this static method previously), which is going to be the source emitting all items.
    The result is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先创建了一个`DebugSubject`实例，然后使用`map()`操作符将其链式调用，该操作符返回每个项目的长度。最后，我们订阅了另一个只打印数字的`DebugSubject`，因为它放在`map()`之后。然后，我们从一个数组创建了一个Observable（我们之前已经看到过这个静态方法），它将作为所有项目的源发出。结果如下：
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that the order of messages matches our assumption that the source Observable
    emits one value at a time, which is propagated through the entire chain.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，消息的顺序与我们的假设相符，即源Observable一次发出一个值，这个值在整个链中传播。
- en: Note
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There's one important side effect of using Subjects as we did that isn't very
    obvious. Since we subscribe it to the preceding Observable, it turns it from "cold"
    into "hot", which might be unwanted in some use cases.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们这样的Subjects有一个重要的副作用，不是很明显。由于我们将其订阅到前面的Observable上，它将其从“冷”状态转换为“热”状态，这在某些用例中可能是不希望的。
- en: RxPHP provides a series of operators all starting with the "doOn" prefix that
    are intended to be placed inside the operator chain to execute side effects without
    subscribing to an Observable. We'll have a better look at them in [Chapter 5](part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d
    "Chapter 5. Testing RxPHP Code"), *Testing RxPHP Code*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: RxPHP提供了一系列以“doOn”前缀开头的操作符，目的是将它们放置在操作符链中，以执行副作用而无需订阅Observable。我们将在[第5章](part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d
    "第5章。测试RxPHP代码")中更详细地介绍它们，*测试RxPHP代码*。
- en: Writing JSONDecodeOperator
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写JSONDecodeOperator
- en: We're going to work with calls to remote API's a few times throughout this book,
    so it would be very handy to have an operator that transforms JSON string responses
    into their PHP array representations.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中多次处理对远程API的调用，因此有一个将JSON字符串响应转换为PHP数组表示的操作符将非常有用。
- en: 'This example looks like something that could be easily done with just the `map()`
    operator:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子看起来只需要使用`map()`操作符就可以轻松完成：
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This prints the correct result for sure, as we can see in the following output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这肯定能打印出正确的结果，正如我们可以在下面的输出中看到：
- en: '[PRE27]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Well, but what about malformed JSON strings? What happens if we try to decode
    the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，但是关于格式错误的JSON字符串呢？如果我们尝试解码以下内容会发生什么：
- en: '[PRE28]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The function `json_decode()` doesn''t throw an exception when trying to process
    an invalid JSON string; it just returns `null`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`json_decode()`在尝试处理无效的JSON字符串时不会抛出异常；它只返回`null`：
- en: '[PRE29]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is probably not what we want. If the JSON string is invalid, then something
    is wrong because this situation should never happen and we want to send an `onError`
    notification.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是我们想要的。如果JSON字符串无效，那么就会出现问题，因为这种情况不应该发生，我们希望发送一个`onError`通知。
- en: If we wanted to know any further information about which error occurred, we'd
    have to call `json_last_error()`. So, this is a perfect opportunity to write a
    custom operator that decodes JSON strings that, if any error occurs, will send
    an `onError`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想了解任何关于发生错误的进一步信息，我们必须调用`json_last_error()`。因此，这是一个编写自定义操作符的绝佳机会，该操作符可以解码JSON字符串，如果发生任何错误，将发送一个`onError`。
- en: 'All operators implement the `OperatorInterface` and `__invoke()` method. This
    so-called "magic" method is supported from PHP 5.3+ and allows the use of objects
    as functions:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作符都实现了`OperatorInterface`和`__invoke()`方法。这个所谓的“魔法”方法从PHP 5.3+开始支持，允许使用对象作为函数：
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When class implements `__invoke()`, it''s automatically considered as callable
    as well:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当类实现了 `__invoke()` 方法时，它也会自动被视为可调用的：
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Writing operators is very similar. A stub for our class will look like the
    following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 编写操作符非常相似。我们的类的存根将如下所示：
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Method `__invoke()` takes three arguments and returns a Disposable object.
    Right now, we''ll use just the first two and not worry about the `$scheduler`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `__invoke()` 接受三个参数并返回一个可丢弃的对象。现在，我们只使用前两个参数，而不用担心 `$scheduler`：
- en: '`ObservableInterface $observable`: This is our input Observable that we''ll
    subscribe to'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObservableInterface $observable`：这是我们订阅的输入可观察对象'
- en: '`ObserverInterface $observer`: This is where we''ll emit all output values
    from this operator'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObserverInterface $observer`：这是我们从这个操作符发出所有输出值的地方'
- en: 'We''ll follow almost the same principle as when writing a custom `Subject`
    class. We''re going to use `CallbackObserver` to subscribe to the Observable and
    perform all of our logic:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循与编写自定义 `Subject` 类几乎相同的原理。我们将使用 `CallbackObserver` 订阅可观察对象并执行所有逻辑：
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There''re a few interesting things to notice:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点有趣的事情需要注意：
- en: When `onError` or `onComplete` notifications occur, we just pass them along
    without any further logic.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发生 `onError` 或 `onComplete` 通知时，我们只是将它们传递下去，而不进行任何进一步的逻辑处理。
- en: The operator can send any signal any time it wants. Inside `CallbackObserver`
    class's `onNext` closure, we check whether any error occurred while decoding the
    input JSON string coming from the source Observable using `json_last_error()`.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符可以在任何时候发送任何信号。在 `CallbackObserver` 类的 `onNext` 闭包内部，我们检查从源可观察对象接收到的输入 JSON
    字符串解码时是否发生了任何错误，使用 `json_last_error()`。
- en: The operator has full access to the source Observable.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符可以完全访问源可观察对象。
- en: The operator can emit values independently on values from the source Observable.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符可以独立于源可观察对象中的值独立发出值。
- en: 'In order to use our operator, we have to use the `Observable::lift()`, method
    which takes a Closure as an argument that needs to return an instance of an operator
    (this function is a so-called operator factory):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们的操作符，我们必须使用 `Observable::lift()` 方法，该方法接受一个闭包作为参数，该闭包需要返回一个操作符的实例（此函数被称为操作符工厂）：
- en: '[PRE34]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Using custom operators was significantly simplified in RxPHP 2, but using the `lift()`
    method is universal and works in both versions of RxPHP.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxPHP 2 中，使用自定义操作符大大简化了，但使用 `lift()` 方法是通用的，并且在 RxPHP 的两个版本中都适用。
- en: 'Valid JSON string is decoded as expected:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的 JSON 字符串按预期解码：
- en: '[PRE35]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'On the other hand, the same invalid JSON string that we used above doesn''t
    call `onNext`, but `onError` instead. It sends this notification with an instance
    of `InvalidArgumentException` class and the error message from `json_last_error_msg()`,
    as shown in the following output:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们上面使用的相同无效 JSON 字符串不会调用 `onNext`，而是调用 `onError`。它使用 `InvalidArgumentException`
    类的实例和 `json_last_error_msg()` 的错误消息发送此通知，如下面的输出所示：
- en: '[PRE36]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As usual, we're going to reuse this class throughout this book. The next chapter
    is going to work with remote APIs a lot, so this operator is going to be very
    handy.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们将在这个书中重用这个类。下一章将大量处理远程 API，因此这个操作符将非常方便。
- en: Simplifying propagation of notifications
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化通知的传播
- en: 'In the `JSONDecodeOperator` class, we didn''t want to modify either `onError`
    nor `onComplete` notifications and we just passed them along. However, there''s
    an easier way to do this thanks to how PHP works with callables. A valid callable
    is also an array with two items: an object and a method name.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `JSONDecodeOperator` 类中，我们不想修改 `onError` 或 `onComplete` 通知，只是将它们传递下去。然而，由于
    PHP 与可调用对象的工作方式，有更简单的方法来做这件事。一个有效的可调用对象也是一个包含两个项目的数组：一个对象和一个方法名。
- en: 'This means we can rewrite the above `CallbackObserver` instantiation as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以将上面的 `CallbackObserver` 实例化重写如下：
- en: '[PRE37]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The functionality is exactly the same. Instead of creating an anonymous function
    for each notification, we can just pass the callable directly.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 功能完全相同。我们不需要为每个通知创建一个匿名函数，只需直接传递可调用即可。
- en: Using custom operators in RxPHP 2
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 RxPHP 2 中使用自定义操作符
- en: In [Chapter 1](part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d
    "Chapter 1. Introduction to Reactive Programming"), *Introduction to Reactive
    Programming*, we mentioned a magic `__call()` method. RxPHP 2 uses this method
    to allow the use of custom operators by auto-discovering them in two namespace
    formats.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d "第
    1 章。响应式编程简介")，*响应式编程简介*中，我们提到了一个神奇的 `__call()` 方法。RxPHP 2 使用此方法允许通过在两个命名空间格式中自动发现它们来使用自定义操作符。
- en: 'The first option is defining our operator class in the `Rx\Operator` namespace:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选项是在 `Rx\Operator` 命名空间下定义我们的操作符类：
- en: '[PRE38]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It''s the same `JSONDecodeOperator` class, just updated for RxPHP 2\. Using
    this operator is, then, very simple:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同的 `JSONDecodeOperator` 类，只是针对 RxPHP 2 更新了。使用此操作符非常简单：
- en: '[PRE39]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Since our operator resides under the `Rx\Operator` namespace, it's expanded
    by the `__call()` method to `Rx\Operator\JSONDecodeOperator`. This means we don't
    need to use the `lift()` method at all.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的操作符位于 `Rx\Operator` 命名空间下，它通过 `__call()` 方法扩展为 `Rx\Operator\JSONDecodeOperator`。这意味着我们根本不需要使用
    `lift()` 方法。
- en: 'Another way is to prefix the operator name and namespace with underscores `_`
    which are then merged into a full class name. This means we can put all application
    specific operators under a custom namespace:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用下划线 `_` 前缀操作符名称和命名空间，然后它们将被合并为一个完整的类名。这意味着我们可以将所有特定于应用程序的操作符放在一个自定义命名空间下：
- en: '[PRE40]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we can use the operator as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以按以下方式使用操作符：
- en: '[PRE41]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Writing CURLObservable
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 CURLObservable
- en: As we said, we're going to work with API calls and, for this reason, we need
    a comfortable way of creating HTTP requests. It's probably no surprise that we'll
    write a custom Observable that downloads a URL and passes it's response to its
    observers, where we'll decode it from JSON using the operator we created just
    a couple of lines above.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，我们将与 API 调用一起工作，因此我们需要一种舒适的方式来创建 HTTP 请求。可能不会令人惊讶，我们将编写一个自定义的 Observable，它下载一个
    URL 并将其响应传递给观察者，然后我们将使用上面创建的操作符从 JSON 中解码它。
- en: We're going to use PHP's cURL module, which is a wrapper around libcurl ( [https://curl.haxx.se/libcurl/](https://curl.haxx.se/libcurl/)
    ) - a C library for transferring data via any protocols imaginable.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 PHP 的 cURL 模块，它是对 libcurl（[https://curl.haxx.se/libcurl/](https://curl.haxx.se/libcurl/)）的封装
    - 一个用于通过任何可想象协议传输数据的 C 库。
- en: We'll start by using plain simple cURL in PHP and we'll see that it supports
    some sort of asynchronous approach out-of-the-box.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将首先使用 PHP 中的简单 cURL，我们将看到它支持某种异步方法。 '
- en: Imperative approach and cURL
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令式方法和 cURL
- en: If we just wanted to download a single URL, we wouldn't need anything special.
    However, we want to make this, and all future applications of `CURLObservable`
    class, more interactive, so we'll also keep track of the downloading progress.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想下载单个 URL，我们不需要任何特殊的东西。然而，我们希望使这个，以及所有未来的 `CURLObservable` 类的应用，更加交互式，因此我们还将跟踪下载进度。
- en: 'A plain and simple approach could look like this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的方法可能如下所示：
- en: '[PRE42]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We're using `CURLOPT_PROGRESSFUNCTION` option to set a callback function which
    is invoked internally by the cURL module. It takes four arguments that help us
    keep track of how much of the page's total size already has been downloaded.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 `CURLOPT_PROGRESSFUNCTION` 选项来设置一个回调函数，该函数由 cURL 模块内部调用。它接受四个参数，帮助我们跟踪页面总大小已下载的百分比。
- en: We probably don't need to show its output because it's pretty obvious.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能不需要显示其输出，因为它非常明显。
- en: There's also a small subset of cURL functions that work with multiple cURL handles
    simultaneously. These are all prefixed with `curl_multi_` and are executed by
    calling `curl_multi_exec()`. Nonetheless, the `curl_multi_exec()` function is
    blocking and the interpreter needs to wait until it finishes.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一小部分 cURL 函数可以同时与多个 cURL 处理程序一起工作。这些函数都以前缀 `curl_multi_` 开头，并通过调用 `curl_multi_exec()`
    来执行。不过，`curl_multi_exec()` 函数是阻塞的，解释器需要等待它完成。
- en: Implementing cURL into a custom Observable
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 cURL 实现到自定义的 Observable 中
- en: We've already seen how to write a custom observer, Subject and operator. Now
    is the right time to write an Observable as well. We want the Observable to emit
    values when downloading the URL and, at the end, return a complete response. We
    can distinguish between the two types of messages by checking their type. Progress
    will always be a double, while response will always be a string.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何编写自定义观察者、Subject 和操作符。现在是我们编写 Observable 的正确时机。我们希望 Observable 在下载
    URL 时发出值，并在最后返回一个完整的响应。我们可以通过检查它们的类型来区分这两种类型的消息。进度始终是双精度浮点数，而响应始终是字符串。
- en: 'Let''s start with our class synopsis to see how it''s going to work and then
    implement each method separately with a short description:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的类概要开始，看看它将如何工作，然后分别实现每个方法，并附上简短说明：
- en: '[PRE43]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Every time we write an Observable, we'll extend the base `Rx\Observable` class.
    We could theoretically just implement `Rx\ObservableInterface`, but, most of the
    time, we also want to inherit all its internal logic and all existing operators.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们编写一个 Observable，我们都会扩展基类 `Rx\Observable`。理论上我们可以只实现 `Rx\ObservableInterface`，但大多数情况下，我们还想继承其所有内部逻辑和所有现有操作符。
- en: The constructor and method `startDownload()` are going to be very simple. In `startDownload()`,
    we start downloading the URL while monitoring its progress.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数和方法 `startDownload()` 将会非常简单。在 `startDownload()` 中，我们开始下载 URL 并监控其进度。
- en: 'Please note that this code goes inside the `CURLObservable` class; we''re just
    trying to keep the code short and easy to read, so we have omitted indentation
    and class definition in this example:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此代码位于 `CURLObservable` 类内部；我们只是试图使代码更短、更易于阅读，所以在本例中省略了缩进和类定义：
- en: '[PRE44]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is mostly the same as the example using an imperative approach. The only
    interesting difference is that we're using a callable `[$this,'progress']` instead
    of just a function name, as we did earlier.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与使用命令式方法的示例相同。唯一的有趣差异是我们使用了一个可调用的 `[$this,'progress']` 而不是像之前那样只使用函数名。
- en: 'The actual emission of values happens inside the `progress()` method:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的值发射发生在 `progress()` 方法内部：
- en: '[PRE45]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Since we inherited the original Observable, we can make use of its protected
    property `$observers` that holds all subscribed observers, as its name suggests.
    To emit a value to all of them, we can simply iterate the array and call `onNext`
    on each observer.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们继承了原始 Observable，我们可以利用其受保护的属性 `$observers`，它持有所有已订阅的观察者，正如其名称所暗示的。要向所有这些观察者发射值，我们可以简单地遍历数组并在每个观察者上调用
    `onNext`。
- en: 'The only method we haven''t seen so far is `subscribe()`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止还没有看到的方法是 `subscribe()`：
- en: '[PRE46]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This method combines many of the things we''ve seen in this chapter:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法结合了本章中我们看到的一些东西：
- en: We definitely want to keep the original functionality of the Observable, so
    we'll call its parent implementation. This adds the observer to the array of observers,
    as mentioned a moment ago.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们肯定想保留 Observable 的原始功能，所以我们将调用其父实现。这会将观察者添加到之前提到的观察者数组中。
- en: The `parent::subscribe()` method returns a disposable. That's the object we
    can use to unsubscribe the observer from this Observable.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent::subscribe()` 方法返回一个可丢弃的对象。这是我们用来从 Observable 中取消订阅观察者的对象。'
- en: If we don't specify what Scheduler this Observable should use, it'll fall back
    to `ImmediateScheduler`. We've already mentioned `ImmediateScheduler` when we
    were talking about Schedulers in general. In RxPHP 2, we'd use `Scheduler::getImmediate()`
    instead of directly using the class name.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们没有指定此 Observable 应该使用哪个调度器，它将回退到 `ImmediateScheduler`。当我们谈论调度器时，我们已经提到了
    `ImmediateScheduler`。在 RxPHP 2 中，我们将使用 `Scheduler::getImmediate()` 而不是直接使用类名。
- en: Right after that, we schedule the work (in terms of Schedulers, it's usually
    referred to as "action") to be executed by the Scheduler. Note that the action
    itself is a closure.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随后，我们安排工作（在调度器的术语中通常称为“动作”）由调度器执行。请注意，动作本身是一个闭包。
- en: Then, we start downloading the URL. If we subscribe another observer to the
    same Observable, it'll re-download the same URL again. Download progress is then
    emitted with frequency according to cURL's internals. We'll talk more about the
    subscription process in the next chapter.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们开始下载 URL。如果我们向同一个 Observable 订阅另一个观察者，它将再次下载相同的 URL。下载进度将根据 cURL 的内部频率发射。我们将在下一章中更多地讨论订阅过程。
- en: When downloading finishes, we emit the response or an error.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载完成后，我们发出响应或错误。
- en: At the end of this method, it returns another disposable. This time, it's `CompositeDisposable`
    that is used to wrap other disposables. When calling its `dispose()` method, these
    wrapped ones are properly disposed as well.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此方法结束时，它返回另一个可丢弃的对象。这次，它使用 `CompositeDisposable` 来包装其他可丢弃的对象。当调用其 `dispose()`
    方法时，这些包装的对象也会被正确地处理。
- en: 'So, that''s it. Now we can test our Observable and see what its output is.
    We can try to grab a list of the most recent questions on [www.stackoverflow.com](http://www.stackoverflow.com)
    tagged with *functional-programming*":'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，就是这样。现在我们可以测试我们的 Observable 并查看其输出。我们可以尝试获取带有 *functional-programming* 标签的
    [www.stackoverflow.com](http://www.stackoverflow.com) 上最新的问题列表：
- en: '[PRE47]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This prints a couple of numbers and then the response JSON string:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出几个数字，然后是响应的 JSON 字符串：
- en: '[PRE48]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can see that one value was emitted twice. This is because of the timing
    and network latency when cURL evaluates the callback, which is nothing unusual.
    If we didn't want to see repeated values, we could use the `distinct()` operator
    that we saw when talking about "marble diagrams".
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s combine it with our `JSONDecodeOperator`. Since we''re now interested
    only in the string response and want to ignore all progress emissions, we''ll
    also use the `filter()` operator:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This returns part of the response array (for demonstration purposes, we added
    indentation and made the output a little longer):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When we used the `filter()` operator, you might notice that we called it `Observable::filter()`
    without necessarily using the `lift()` method. This is because almost all operators
    are, in fact, just `lift()` calls with predefined Closures that return an appropriate
    operator class. A good question is whether we can write our own shorthand for `JSONDecodeOperator`
    when we're already extending the base Observable class. Maybe something like `Observable::jsonDecode()`?
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: The answer is yes, we can. However, in RxPHP 1.x, it wouldn't help us a lot.
    When we chain operators, they return other instances of Observables that aren't
    under our control. We could theoretically use `Observable::jsonDecode()` right
    after creating `CurlObservable` because we'd know that it's going to be an instance
    of this class, but chaining it with `filter()` brings us back to the original
    Observable that doesn't know any `jsonDecode()` methods. In particular, the `filter()`
    operator returns an instance of `Rx\Observable\AnonymousObservable`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Running multiple requests asynchronously
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An interesting use case could be to start multiple requests asynchronously.
    All calls to `curl_exec()` are blocking, which means that they block the execution
    context until they're finished.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this is a very tricky problem that's hard to solve without using
    any extra PHP modules, such as **pthreads**, as we'll see much later in [Chapter
    9](part0066_split_000.html#1UU542-bd355a22cf10407cb10df27e65585b8d "Chapter 9. Multithreaded
    and Distributed Computing with pthreads and Gearman"), *Multithreaded and Distributed
    Computing with pthreads and Gearman*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: We can, however, make use of PHP's standard `proc_open()` to spawn non-blocking
    subprocesses that can run in parallel and then just ask for their output.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: The proc_open() and non-blocking fread()
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our goal is to have the means to start various subprocesses asynchronously.
    In this example, we''ll use a simple PHP script that''ll just sleep for a couple
    of seconds and represent our asynchronous task:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This script takes two arguments. The first one is an identifier of our choice
    that we''ll use to distinguish between multiple processes. The second one is the number
    of seconds this script will run while printing its name and the elapsed time every
    second. For example, we can run:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we''ll write another PHP script that uses `proc_open()` to spawn a subprocess.
    Also, as we said, we need the script to be non-blocking. This means that we need
    to be able to read output from the subprocess as it is printed using `printf()`
    above, while being able to spawn more subprocess, if needed:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We spawn a subprocess `php sleep.php proc1 3` and then go into a loop. With
    a 100ms delay, we check whether there's any new output from the subprocess using `fread()`.
    If there is, we print it; otherwise, just write the word "tick". The loop will
    end when the subprocess terminates (that's the condition with the `proc_get_status()`
    function).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing in this example is calling the `stream_set_blocking()`
    function, which makes operations with this stream non-blocking.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Event loop and RxPHP
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying event loop to Observables would work in a similar way. We'd create
    Observables, start an event loop and periodically check their progress. Luckily
    for us, RxPHP is prepared for this. In combination with the ReactPHP library (
    [https://github.com/reactphp/react](https://github.com/reactphp/react) ), we can
    use a Scheduler that's designed exactly for what we need.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can have a look at `IntervalObservable` that periodically
    emits values:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This prints three values with 1s delays:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In RxPHP 2, using event loops has been simplified and, most of the time, we
    don't even need to worry about starting the loop ourselves. We'll talk about differences
    between RxPHP 1.x and RxPHP 2 regarding event loops in [Chapter 6](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "Chapter 6. PHP Streams API and Higher-Order Observables"), *PHP Streams API and
    Higher-Order Observables*.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a closer look at all the components of RxPHP.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we've seen all three types of notifications used in Rx, Observables,
    observers, Subjects, Singles and operators. On practical examples, we have designed
    our custom observer, Subject, Observable and an operator. We'll use all these
    in the upcoming chapters.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: We saw that documentation regarding Rx operators is very often described in
    the form of "marble diagrams".
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is going to utilize all we did in this chapter. We're going
    to create a CLI Reddit reader using RxPHP and Symfony Console component. We'll
    also talk in more depth about the subscription process in Observable chains.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
