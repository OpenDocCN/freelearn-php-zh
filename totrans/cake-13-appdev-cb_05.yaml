- en: Chapter 5. Datasources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章 数据源
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Improving the SQL datasource query log
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进 SQL 数据源查询日志
- en: Parsing CSV files with a datasource
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据源解析 CSV 文件
- en: Consuming RSS feeds with a datasource
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据源消费 RSS 源
- en: Building a Twitter datasource
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 Twitter 数据源
- en: Adding transaction and locking support to the MySQL datasource
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 MySQL 数据源添加事务和锁定支持
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Datasources are the backbone of almost all model operations. They provide an
    abstraction between model logic and the underlying data layer, allowing a more
    flexible approach to data manipulation. Through this abstraction, CakePHP applications
    are able to manipulate data without knowing the specifics of how it's stored or
    fetched.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源是几乎所有模型操作的基础。它们在模型逻辑和底层数据层之间提供了一个抽象，允许更灵活的数据操作方法。通过这个抽象，CakePHP 应用程序能够在不知道数据存储或检索的具体细节的情况下操作数据。
- en: This chapter shows how to get information from existing datasources, use pre-built
    datasources to deal with non-relational data, and teaches us how to create a full-featured
    Twitter datasource.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何从现有数据源获取信息，使用预构建的数据源处理非关系数据，并教我们如何创建一个功能齐全的 Twitter 数据源。
- en: Improving the SQL datasource query log
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进 SQL 数据源查询日志
- en: This recipe shows how to create a component that will offer extended logging
    of all queries executed on any SQL-based datasource that supports the `EXPLAIN`
    command (this recipe is designed to work with MySQL, but can be adapted to other
    SQL based datasources), and show that information when the appropriate debug setting
    is set.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何创建一个组件，该组件将提供对在支持 `EXPLAIN` 命令的任何 SQL 基础数据源上执行的所有查询的扩展日志记录，并在适当的调试设置被设置时显示这些信息（这个配方是为
    MySQL 设计的，但可以适应其他基于 SQL 的数据源）。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To go through this recipe we need a sample table to work with. Create a table
    named `accounts`, using the following SQL statement:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个配方，我们需要一个样本表来操作。使用以下 SQL 语句创建一个名为 `accounts` 的表：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a table named `profiles`, using the following SQL statement:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下 SQL 语句创建一个名为 `profiles` 的表：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add some sample data, using the following SQL statements:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下 SQL 语句添加一些样本数据：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We proceed now to create the required model. Create the model `Profile` in
    a file named `profile.php` and place it in your `app/models` folder with the following
    contents:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在继续创建所需的模型。在名为 `profile.php` 的文件中创建模型 `Profile`，并将其放置在你的 `app/models` 文件夹中，内容如下：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create its appropriate controller `ProfilesController` in a file named `profiles_controller.php`
    and place it in your `app/controllers` folder with the following contents:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个名为 `profiles_controller.php` 的文件中创建适当的控制器 `ProfilesController`，并将其放置在你的 `app/controllers`
    文件夹中，内容如下：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a folder named `profiles` in your `app/views` folder, and then create
    the view in a file named `index.ctp` and place it in your `app/views/profiles`
    folder with the following contents:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `app/views` 文件夹中创建一个名为 `profiles` 的文件夹，然后在名为 `index.ctp` 的文件中创建视图，并将其放置在你的
    `app/views/profiles` 文件夹中，内容如下：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you don''t have a layout, copy the layout file named `default.ctp` from
    your `cake/libs/view/layouts` folder to your application `app/views/layouts` folder.
    If you do have a layout, make sure it includes the standard SQL view element where
    you want the SQL logging placed:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有布局，将 `cake/libs/view/layouts` 文件夹中的布局文件 `default.ctp` 复制到你的应用程序 `app/views/layouts`
    文件夹中。如果你已经有了布局，确保它包括你想要放置 SQL 日志的标准 SQL 视图元素：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, set your debug level to `2` by editing your `app/config/core.php`
    file and changing the `Configure::write(''debug'')` line to:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过编辑你的 `app/config/core.php` 文件并将 `Configure::write('debug')` 行更改为来设置你的调试级别为
    `2`：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a file named `query_log.php` and place it in your `app/controllers/components`
    folder with the following contents:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `query_log.php` 的文件，并将其放置在你的 `app/controllers/components` 文件夹中，内容如下：
- en: '[PRE8]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'While still editing the `query_log.php` file, add the following method to the
    `QueryLogComponent`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑 `query_log.php` 文件的同时，向 `QueryLogComponent` 添加以下方法：
- en: '[PRE9]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the `QueryLog` component to all your controllers. Create a file named `app_controller.php`
    and place it in your `app/` folder with the following contents:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `QueryLog` 组件添加到所有你的控制器中。创建一个名为 `app_controller.php` 的文件，并将其放置在你的 `app/` 文件夹中，内容如下：
- en: '[PRE10]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you already have an `app_controller.php` file, make sure your `components`
    property includes the `QueryLog` component as shown previously.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你已经有了一个 `app_controller.php` 文件，确保你的 `components` 属性包括之前显示的 `QueryLog` 组件。
- en: 'Create a file named `query_log.ctp` and place it in your `app/views/elements`
    folder with the following contents:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `query_log.ctp` 的文件，并将其放置在您的 `app/views/elements` 文件夹中，内容如下：
- en: '[PRE11]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, edit your `app/views/layouts/default.ctp` file and replace the line
    that reads `<?php echo $this->element(''sql_dump''); ?>` with the following:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编辑您的 `app/views/layouts/default.ctp` 文件，并将读取 `<?php echo $this->element('sql_dump');
    ?>` 的行替换为以下内容：
- en: '[PRE12]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we now browse to `http://localhost/profiles`, we should see the improved
    query log that includes the explanation of `SELECT` queries, as shown in the following
    screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在浏览到 `http://localhost/profiles`，我们应该看到改进后的查询日志，其中包含 `SELECT` 查询的解释，如下面的截图所示：
- en: '![How to do it...](img/1926_05_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/1926_05_01.jpg)'
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The SQL command `EXPLAIN` is used to obtain the execution plan for a `SELECT`
    query. When using `EXPLAIN`, MySQL includes information such as which tables are
    joined in the query, in which order they are joined, and what keys (if any) are
    used to optimize the query. This information can be used to optimize queries and
    considerably reduce their execution time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 命令 `EXPLAIN` 用于获取 `SELECT` 查询的执行计划。当使用 `EXPLAIN` 时，MySQL 会包括有关查询中连接了哪些表、它们以何种顺序连接以及使用了哪些键（如果有的话）以优化查询的信息。这些信息可用于优化查询并显著减少它们的执行时间。
- en: The `QueryLog` component checks the `debug` setting to determine if it should
    process the query log, and uses the `minimumTime` setting to add more information
    about those queries that took a certain number of milliseconds, or more. In our
    example, we set this value to `0` when we added the component to `AppController`
    to make sure all `SELECT` queries are properly explained.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryLog` 组件检查 `debug` 设置以确定是否应该处理查询日志，并使用 `minimumTime` 设置为那些耗时一定毫秒数或更多的查询添加更多信息。在我们的示例中，当我们将组件添加到
    `AppController` 时，我们将此值设置为 `0`，以确保所有 `SELECT` 查询都得到适当的解释。'
- en: The component uses the `beforeRender` callback to perform its processing right
    before a view is to be rendered. It starts by using the `ConnectionManager::sourceList()`
    method to obtain a list of all available datasources (that is, the name of all
    connections defined in the `app/config/database.php` file). For each of those
    connection names, it gets the actual datasource object using the `ConnectionManager::getDataSource()`
    method. As we will see in other recipes in this chapter, a datasource may not
    implement all methods, so the component then uses the `isInterfaceSupported()`
    method, available in all datasources, to see if that particular source implements
    the `getLog()` method.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 组件使用 `beforeRender` 回调在视图即将渲染之前执行其处理。它首先使用 `ConnectionManager::sourceList()`
    方法获取所有可用的数据源列表（即 `app/config/database.php` 文件中定义的所有连接的名称）。对于这些连接名称中的每一个，它使用 `ConnectionManager::getDataSource()`
    方法获取实际的源对象。正如我们将在本章的其他菜谱中看到的那样，源可能不会实现所有方法，因此组件随后使用所有数据源中都有的 `isInterfaceSupported()`
    方法，以查看该特定源是否实现了 `getLog()` 方法。
- en: Using the `getLog()` method, the component obtains the list of queries issued
    on a particular source, and filters those to check for only `SELECT` queries that
    run for the minimum time specified in the `minimumTime` setting. Once it has the
    list of `SELECT` queries that need to be explained, it issues an `EXPLAIN` SQL
    statement, and processes the result into a more readable format, ensuring that
    all fields obtained are lower case.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `getLog()` 方法，组件获取特定源上发出的查询列表，并过滤出只包含在 `minimumTime` 设置中指定最小时间的 `SELECT`
    查询。一旦它获得了需要解释的 `SELECT` 查询列表，它就会发出一个 `EXPLAIN` SQL 语句，并将结果处理成更易读的格式，确保所有获取的字段都是小写。
- en: Finally, and now that the query log is properly processed, it sets the appropriate
    view variable, which is utilized by the `query_log.ctp` element to show the log.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在查询日志已经正确处理，它设置了适当的视图变量，该变量由 `query_log.ctp` 元素用于显示日志。
- en: Parsing CSV files with a datasource
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据源解析 CSV 文件
- en: This recipe shows how to parse **comma-separated values** (**CSV**) files using
    a datasource, showing a clean approach to CSV processing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱展示了如何使用数据源解析 **逗号分隔值** （**CSV**）文件，展示了 CSV 处理的清晰方法。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We start by installing CakePHP's datasources plugin. Download the latest release
    from [http://github.com/mariano/datasources/downloads](http://github.com/mariano/datasources/downloads)
    and uncompress the downloaded file into your `app/plugins` folder. You should
    now have a directory named `datasources` inside `app/plugins`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先安装 CakePHP 的数据源插件。从 [http://github.com/mariano/datasources/downloads](http://github.com/mariano/datasources/downloads)
    下载最新版本，并将其解压缩到您的 `app/plugins` 文件夹中。现在您应该在 `app/plugins` 内部有一个名为 `datasources`
    的目录。
- en: The datasources plugin, located at [http://github.com/cakephp/datasources](http://github.com/cakephp/datasources),
    is an official CakePHP plugin that offers several community-provided datasources,
    such as XML-RPC and SOAP. This and other recipes use a customized version of the
    plugin, modified for the purpose of this book.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源插件位于 [http://github.com/cakephp/datasources](http://github.com/cakephp/datasources)，是官方
    CakePHP 插件，提供了一些社区提供的源，如 XML-RPC 和 SOAP。此食谱和其他食谱使用插件的定制版本，为本书的目的进行了修改。
- en: 'We need some sample data to work with. Create a file named `contacts.csv` and
    place it in a folder of your choice (such as `/home/mariano`), with contents similar
    to the ones shown below. This example includes only two rows of data, but the
    file used in this recipe uses several more rows, and should include the starting
    header row:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些样本数据来工作。创建一个名为 `contacts.csv` 的文件，并将其放置在您选择的文件夹中（例如 `/home/mariano`），内容类似于以下所示。此示例仅包含两行数据，但此食谱中使用的文件包含更多行，并且应包括起始标题行：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We start by creating a connection to use the CSV datasource. Open your `app/config/database.php`
    file and add the following connection:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个连接以使用 CSV 数据源。打开您的 `app/config/database.php` 文件，并添加以下连接：
- en: '[PRE14]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a model named `Contact` in a file named `contact.php` and place it in
    your `app/models` folder with the following contents:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `contact.php` 的文件中创建一个名为 `Contact` 的模型，并将其放置在您的 `app/models` 文件夹中，内容如下：
- en: '[PRE15]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create its controller in a file named `contacts_controller.php` and place it
    in your `app/controllers` folder with the following contents:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `contacts_controller.php` 的文件中创建其控制器，并将其放置在您的 `app/controllers` 文件夹中，内容如下：
- en: '[PRE16]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we need to create the view. Create a folder named `contacts` in your
    `app/views` folder, and in that folder create a file named `index.ctp` with the
    following contents:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要创建视图。在您的 `app/views` 文件夹中创建一个名为 `contacts` 的文件夹，并在该文件夹中创建一个名为 `index.ctp`
    的文件，内容如下：
- en: '[PRE17]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we now browse to `http://localhost/contacts`, we should see a paginated
    list, as shown in the following screenshot:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们现在浏览到 `http://localhost/contacts`，我们应该看到一个分页列表，如下面的截图所示：
- en: '![How to do it...](img/1926_05_02.jpg)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/1926_05_02.jpg)'
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start by creating a new connection named `csv`, specifying `datasources.CsvSource`
    as its type, that is, a datasource named `CsvSource` that is a part of a plugin
    named `datasources`. We set the path to our CSV files to CakePHP's temporary directory
    using the `path` setting, and we specify that we don't want that path to be created
    if it doesn't exist, by setting `readonly` to true.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的连接名为 `csv`，指定其类型为 `datasources.CsvSource`，即名为 `CsvSource` 的数据源，它是
    `datasources` 插件的一部分。我们使用 `path` 设置将 CSV 文件的路径设置为 CakePHP 的临时目录，并指定我们不想创建该路径，通过将
    `readonly` 设置为 true。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The fork we are using in this recipe adds a feature to the original plugin:
    allowing one to change the CSV file used via the model property `table`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中我们使用的分支为原始插件添加了一个功能：允许通过模型的 `table` 属性更改所使用的 CSV 文件。
- en: We then create the `Contact` model, specifying its underlying connection to
    be `csv` through the `useDbConfig` property. The CSV data source will then use
    the respective table name as the name of the file, attaching the `csv` extension
    to it. In this case, the CSV data source will use contacts for the `Contact` model,
    which can be changed through the model property table.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建 `Contact` 模型，指定其底层连接为 `csv`，通过 `useDbConfig` 属性。CSV 数据源将使用相应的表名作为文件名，并将其附加
    `csv` 扩展名。在这种情况下，CSV 数据源将使用 `Contact` 模型的 `contacts`，这可以通过模型属性 `table` 进行更改。
- en: Using that file name, it will look for it in the path that was defined in the
    connection settings. If the file cannot be loaded, or if the path does not exist,
    it will throw a missing table error, just as any model with a missing table would.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该文件名，它将在连接设置中定义的路径中查找。如果文件无法加载，或者路径不存在，它将抛出一个缺少表错误，就像任何缺少表的模型一样。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The default `csv` extension can be changed by specifying the `extension` setting
    in the connection.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`csv`扩展可以通过在连接中指定`extension`设置来更改。
- en: 'Once the file is properly loaded, the datasource allows us to fetch records
    by issuing simple `find()` calls. It supports some of the most common find settings:
    `limit, page, fields`, and includes basic support for defining the setting `conditions`
    to limit the obtained records (see the *There''s more* section below).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被正确加载，数据源允许我们通过发出简单的`find()`调用来获取记录。它支持一些最常见的查找设置：`limit, page, fields`，并且包括对定义设置`conditions`以限制获取的记录的基本支持（见下文*更多内容*部分）。
- en: The rest of the recipe shows how we use our `Contact` model just as we would
    use any model, exemplifying this flexibility with a paginated list of parsed CSV
    records.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱的其余部分展示了我们如何像使用任何模型一样使用我们的`Contact`模型，通过解析CSV记录的分页列表来展示这种灵活性。
- en: There's more...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Other than being able to define which page to obtain (through the `page` find
    setting) and how many records to obtain (using the `limit` find setting), the
    CSV datasource allows for some basic filtering, by means of the handy `Set::matches()`
    method. For example, we can modify our paginated list to obtain contacts whose
    ages are over 30, by adding the following `conditions` setting to our `index()`
    method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够定义获取哪一页（通过`page`查找设置）以及获取多少条记录（使用`limit`查找设置）之外，CSV数据源还允许通过方便的`Set::matches()`方法进行一些基本的过滤。例如，我们可以修改我们的分页列表以获取年龄超过30岁的联系人，通过向我们的`index()`方法添加以下`conditions`设置：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Dynamic loading of CSV files
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSV文件的动态加载
- en: The example used in this recipe is bound to the file `contacts.csv` by means
    of the default table named for the `Contact` model, but what would be required
    if we needed to process several CSV files and we don't want to create a model
    for each of those files?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中使用的示例通过为`Contact`模型命名的默认表绑定到`contacts.csv`文件，但如果我们需要处理多个CSV文件并且不想为每个文件创建一个模型，需要什么？
- en: 'Using the `table` model property, we can dynamically change the underlying
    CSV file a model is importing from, and execute our `find` operations just as
    if we would''ve created a model specifically for this file. We start by creating
    a model that uses the `csv` connection, but that is not tied to any file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`table`模型属性，我们可以动态更改模型导入的底层CSV文件，并执行我们的`find`操作，就像我们为该文件创建了一个特定的模型一样。我们首先创建一个使用`csv`连接的模型，但该模型没有绑定到任何文件：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Setting `useTable` to `false` allows us to avoid any file loading. We can then
    use the `listSources()` datasource method to obtain a list of all CSV files available
    for importing, and then dynamically change the `table` model property for each
    of those files, and fetch the actual records. We do this in the following `controller`
    method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将`useTable`设置为`false`允许我们避免任何文件加载。然后我们可以使用`listSources()`数据源方法获取所有可导入的CSV文件列表，然后动态更改每个文件的`table`模型属性，并获取实际的记录。我们在以下`controller`方法中这样做：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The list of files obtained through the `listSources()` method is fetched from
    the `path` setting specified in the datasource configuration, as defined in `app/config/database.php`.
    This path can be changed by first cleaning up the current connection, which releases
    the handle to the previously configured path, by using the datasource `setConfig()`
    method to change the `path` setting, and then calling it''s `connect()` method
    to load the path:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`listSources()`方法获取的文件列表是从数据源配置中指定的`path`设置获取的，如`app/config/database.php`中定义的。此路径可以通过首先清理当前连接来更改，这会释放先前配置的路径的句柄，使用数据源的`setConfig()`方法更改`path`设置，然后调用它的`connect()`方法来加载路径：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Consuming RSS feeds with a datasource
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据源消费RSS源
- en: This recipe shows how to get content from remote RSS feeds using a datasource.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱展示了如何使用数据源从远程RSS源获取内容。
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We start by installing the fork of CakePHP's datasources plugin. Download the
    latest release from [http://github.com/mariano/datasources/downloads](http://github.com/mariano/datasources/downloads)
    and uncompress the downloaded file into your `app/plugins` folder. You should
    now have a directory named `datasources`. The fork used in this recipe uses a
    refactored version of the RSS datasource developed by Donatas Kairys, member of
    Loadsys Consulting. This modified version improves the datasource performance,
    and adds the possibility of changing the feed URL through a find setting. More
    information about the original datasource can be obtained at [http://blog.loadsys.com/2009/06/19/cakephp-rss-feed-datasource](http://blog.loadsys.com/2009/06/19/cakephp-rss-feed-datasource).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先安装 CakePHP 数据源插件的分支。从 [http://github.com/mariano/datasources/downloads](http://github.com/mariano/datasources/downloads)
    下载最新版本，并将下载的文件解压缩到您的 `app/plugins` 文件夹中。现在您应该有一个名为 `datasources` 的目录。本食谱中使用的分支使用由
    Loadsys 咨询公司成员 Donatas Kairys 开发的 RSS 数据源的重构版本。此修改版本提高了数据源的性能，并添加了通过查找设置更改馈送 URL
    的可能性。有关原始数据源的信息，可以在 [http://blog.loadsys.com/2009/06/19/cakephp-rss-feed-datasource](http://blog.loadsys.com/2009/06/19/cakephp-rss-feed-datasource)
    获取。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We start by creating a connection to use the RSS datasource. Open your `app/config/database.php`
    file and add the following connection:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个连接来使用 RSS 数据源。打开您的 `app/config/database.php` 文件，并添加以下连接：
- en: '[PRE22]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a model named `Post` in a file named `post.php` and place it in your
    `app/models` folder with the following contents:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `post.php` 的文件中创建一个名为 `Post` 的模型，并将其放置在您的 `app/models` 文件夹中，内容如下：
- en: '[PRE23]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create its controller in a file named `posts_controller.php` and place it in
    your `app/controllers` folder with the following contents:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `posts_controller.php` 的文件中创建其控制器，并将其放置在您的 `app/controllers` 文件夹中，内容如下：
- en: '[PRE24]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we need to create the view. Create a folder named `posts` in your
    `app/views` folder, and in that folder create a file named `index.ctp` with the
    following contents:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要创建视图。在您的 `app/views` 文件夹中创建一个名为 `posts` 的文件夹，并在该文件夹中创建一个名为 `index.ctp`
    的文件，内容如下：
- en: '[PRE25]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we now browse to `http://localhost/posts`, we should see a paginated list
    of posts, as shown in the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在浏览到 `http://localhost/posts`，我们应该看到如以下截图所示的帖子分页列表：
- en: '![How to do it...](img/1926_05_03.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1926_05_03.jpg)'
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We start by creating a new connection named `feed`, specifying `datasources.FeedSource`
    as its type. We use the setting `url` to specify the address of the feed source.
    Among other available connection settings we have:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为 `feed` 的新连接，指定其类型为 `datasources.FeedSource`。我们使用设置 `url` 来指定馈送源的地址。在其他可用的连接设置中，我们有：
- en: '`encoding`: Sets the character encoding to use. Defaults to the CakePHP `App.encoding`
    configuration setting.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding`: 设置要使用的字符编码。默认为 CakePHP 的 `App.encoding` 配置设置。'
- en: '`cache`: If set to `false`, no caching will be done. Otherwise this is the
    cache configuration name to use. Defaults to the configuration named `default`.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache`: 如果设置为 `false`，则不会进行缓存。否则，这是要使用的缓存配置名称。默认为名为 `default` 的配置。'
- en: We then create the `Post` model, specifying its underlying connection to be
    `feed` through the `useDbConfig` property. We then proceed to setup a paginated
    list of posts sorting by publication date (pubDate field) in descending order,
    and limiting to nine posts per page.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建 `Post` 模型，通过 `useDbConfig` 属性指定其底层连接为 `feed`。然后我们继续设置按发布日期（pubDate 字段）降序排列的帖子分页列表，每页限制九个帖子。
- en: 'Just as with the CSV datasource shown in the recipe, *Parsing CSV files with
    a datasource*, the RSS datasource allows some basic filtering. For example, to
    only show posts that were created in the year 2009 or later, we would add the
    following `conditions` setting to our `index()` method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如食谱中所示的 CSV 数据源，*使用数据源解析 CSV 文件*，RSS 数据源允许一些基本的过滤。例如，要仅显示在 2009 年或之后创建的帖子，我们将在
    `index()` 方法中添加以下 `conditions` 设置：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There's more...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: There are cases where we might not be able to define the feed URL in a configuration
    file, for example, if the URL comes from a dynamic data source. Fortunately, for
    these cases we have the option to define the feed address through a custom find
    setting.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们可能无法在配置文件中定义馈送 URL，例如，如果 URL 来自动态数据源。幸运的是，对于这些情况，我们有通过自定义查找设置定义馈送地址的选项。
- en: 'In the above example, we could remove the feed URL from the connection settings,
    and specify it as a find setting named `url`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们可以从连接设置中移除馈送 URL，并将其指定为名为 `url` 的查找设置：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Changing connection settings at runtime
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在运行时更改连接设置
- en: 'We''ve seen how we can change the feed URL by using a custom find setting.
    However, we could also change this address by modifying the connection settings.
    Using the method `setConfig()`, available in all datasources, we can make changes
    to any connection setting. For example, instead of using the `url` custom find
    setting, we''ll change the feed URL by changing the connection:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以通过使用自定义查找设置来更改源URL。然而，我们也可以通过修改连接设置来更改此地址。使用所有数据源中都可用的`setConfig()`方法，我们可以更改任何连接设置。例如，我们不是使用`url`自定义查找设置，而是通过更改连接来更改源URL：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Building a Twitter datasource
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Twitter数据源
- en: In this recipe we will learn how to implement our own datasource by providing
    a way to read from and post messages to a Twitter account.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何通过提供从Twitter账户读取和发送消息的方式来实现我们自己的数据源。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will integrate this datasource with OAuth, which is an authentication mechanism
    supported by Twitter. To do so, we will use a class named `HttpSocketOauth` developed
    by Neil Crookes, which is an extension to CakePHP's own `HttpSocket` class that
    adds OAuth support in a clean and elegant way. Download the file named `http_socket_oauth.php`
    from the URL [http://github.com/neilcrookes/http_socket_oauth/raw/master/http_socket_oauth.php](http://github.com/neilcrookes/http_socket_oauth/raw/master/http_socket_oauth.php)
    and place it in your `app/vendors` folder.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将集成此数据源与OAuth，这是Twitter支持的一种身份验证机制。为此，我们将使用Neil Crookes开发的一个名为`HttpSocketOauth`的类，它是CakePHP自己的`HttpSocket`类的一个扩展，以干净优雅的方式添加了OAuth支持。从URL
    [http://github.com/neilcrookes/http_socket_oauth/raw/master/http_socket_oauth.php](http://github.com/neilcrookes/http_socket_oauth/raw/master/http_socket_oauth.php)
    下载名为 `http_socket_oauth.php` 的文件，并将其放置在您的 `app/vendors` 文件夹中。
- en: There are other ways to communicate with an `OAuth` provider such as Twitter,
    most noticeably using the **PHP OAuth library** available at [http://code.google.com/p/oauth-php](http://code.google.com/p/oauth-php).
    This recipe uses Neil's approach for its simplicity.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与像Twitter这样的`OAuth`提供者通信还有其他方法，最明显的是使用位于[http://code.google.com/p/oauth-php](http://code.google.com/p/oauth-php)的**PHP
    OAuth库**。此菜谱使用Neil的方法，因为它简单。
- en: 'Let us continue by creating the `Tweet` model. Create a file named `tweet.php`
    and place it in your `app/models` folder with the following contents:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建 `Tweet` 模型。创建一个名为 `tweet.php` 的文件，并将其放置在您的 `app/models` 文件夹中，以下是其内容：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create its controller in a file named `tweets_controller.php` and place it
    in your `app/controllers` with the following contents:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为 `tweets_controller.php` 的文件中创建其控制器，并将其放置在您的 `app/controllers` 目录中，以下是其内容：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We now need the appropriate view. Create a folder named `tweets` in your `app/views`
    folder, and inside it, create a file named `index.ctp` with the following contents:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要适当的视图。在您的 `app/views` 文件夹中创建一个名为 `tweets` 的文件夹，并在其中创建一个名为 `index.ctp`
    的文件，以下是其内容：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, we will need to register our application on Twitter. Go to the URL [http://twitter.com/apps/new](http://twitter.com/apps/new)
    and fill in the form (an example is shown in the following figure.) Make sure
    you specify a domain different than `localhost` when asked for your **Application
    Website**, and that you select **Read & Write** when asked for the **Default Access
    Type**. You will also need to specify **Browser** as the **Application Type**,
    and `http://localhost/tweets` as the **Callback URL**, replacing `localhost` with
    your own host. This callback won't actually be utilized, as we will define it
    at runtime, but it is mandatory, so we need to fill it in.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在Twitter上注册我们的应用程序。访问URL [http://twitter.com/apps/new](http://twitter.com/apps/new)
    并填写表格（以下图示了一个示例。）当被要求输入**应用程序网站**时，请确保指定一个不同于`localhost`的域名，并且在被要求输入**默认访问类型**时选择**读/写**。您还需要指定**浏览器**作为**应用程序类型**，并将`http://localhost/tweets`作为**回调URL**，用您自己的主机替换`localhost`。这个回调实际上不会被利用，因为我们将它在运行时定义，但它强制性的，所以我们需要填写它。
- en: '![Getting ready](img/1926_05_04.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/1926_05_04.jpg)'
- en: When you successfully submit this form, Twitter will give you some information
    regarding your newly registered application. In that screen, make sure to grab
    what is shown as **Consumer key** and **Consumer secret**, as we will need it
    when going through this recipe.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当您成功提交此表单时，Twitter将为您提供一些有关您新注册的应用程序的信息。在那个屏幕上，请确保抓取显示为**消费者密钥**和**消费者密钥**的内容，因为我们将在执行此菜谱时需要它。
- en: 'Add a new connection named `$twitter` to your `app/config/database.php`, by
    using the following contents and replacing `KEY` with your **Consumer key** and
    `SECRET_KEY` with the **Consumer secret** you obtained above:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下内容添加一个新的连接`$twitter`到您的`app/config/database.php`，并用您上面获得的**消费者密钥**替换`KEY`，用**消费者密钥**替换`SECRET_KEY`：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We start by fully implementing the datasource. Create a file named `twitter_source.php`
    and place it in your `app/models/datasources` folder with the following contents:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先完全实现数据源。创建一个名为`twitter_source.php`的文件，并将其放置在您的`app/models/datasources`文件夹中，内容如下：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now that we have the basic datasource skeleton, we need to add the ability
    for our datasorce to connect to Twitter, using OAuth. Add the following methods
    to the `TwitterSource`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了基本的数据源骨架，我们需要为我们的数据源添加连接到Twitter的能力，使用OAuth。向`TwitterSource`添加以下方法：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Our datasource is now able to connect by requesting the proper authorization
    from Twitter. The next step is adding support to fetch tweets by implementing
    the datasource `read()` method. Add the following method to the `TwitterSource`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据源现在能够通过请求Twitter的正确授权来连接。下一步是添加通过实现数据源`read()`方法来获取推文的支持。向`TwitterSource`添加以下方法：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The job would not be complete if we are unable to post new tweets with our
    datasource. To finish our implementation, add the following method to the `TwitterSource`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法使用数据源发布新推文，那么工作就不会完成。为了完成我们的实现，向`TwitterSource`添加以下方法：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For the datasource to work, we will have to get OAuth authorization on all
    our requests to Twitter. To do so, we implement a method that will talk with the
    datasource to get the authorization keys, and handle the authorization callbacks
    Twitter will issue. Edit your `app/controllers/tweets_controller.php` and add
    the following contents at the beginning of the `TweetsController` class:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使数据源工作，我们将在所有请求Twitter时获取OAuth授权。为此，我们实现了一个方法，该方法将与数据源通信以获取授权密钥，并处理Twitter将发出的授权回调。编辑您的`app/controllers/tweets_controller.php`文件，并在`TweetsController`类的开头添加以下内容：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Assuming your twitter account name is **cookbook5**, we now browse to `http://localhost/tweets/index/cookbook5`,
    and should see a paginated list of our tweets as shown in the following figure:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的Twitter账户名称是**cookbook5**，我们现在浏览到`http://localhost/tweets/index/cookbook5`，应该会看到一个分页的推文列表，如图所示：
- en: '![How to do it...](img/1926_05_05.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1926_05_05.jpg)'
- en: Using the form to post new tweets should submit our text to Twitter, and show
    us our new tweet in the listing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表单发布新推文应将我们的文本提交到Twitter，并在列表中显示我们的新推文。
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The Twitter datasource starts by specifying two new connection settings:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter数据源首先指定两个新的连接设置：
- en: '`key`: A Twitter application consumer key'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key`：Twitter应用程序消费者密钥'
- en: '`secret`: A Twitter application consumer secret key'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secret`：Twitter应用程序消费者密钥'
- en: It then defines a static schema, through the `_schema` property and the `listSources()`
    and `describe()` method implementations, to describe how a tweet post is built.
    This is done purely to add support for a Twitter based model to work with CakePHP's
    `FormHelper`. Doing so allows the `FormHelper` to determine what type of field
    to use when rendering a form for a Twitter-based model.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过`_schema`属性和`listSources()`和`describe()`方法实现来定义一个静态模式，以描述推文帖子是如何构建的。这样做纯粹是为了添加对基于Twitter的模型的支持，以便与CakePHP的`FormHelper`一起工作。这样做允许`FormHelper`在渲染基于Twitter的模型的表单时确定使用哪种类型的字段。
- en: The `connect()` and `close()` methods simply instantiate and erase respectively
    an instance of the `HttpSocketOauth` class, which is our handler to communicate
    with the Twitter API.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect()`和`close()`方法分别实例化和删除`HttpSocketOauth`类的一个实例，这是我们与Twitter API通信的处理程序。'
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: OAuth is a complicated process, and understanding it may prove to be a challenge.
    If you wish to obtain more detailed information about this protocol, there is
    probably no better resource than the *Beginner's Guide to OAuth*, available at
    [http://hueniverse.com/oauth](http://hueniverse.com/oauth).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth是一个复杂的过程，理解它可能是一个挑战。如果您想获取有关此协议的更详细信息，可能没有比[OAuth入门指南](http://hueniverse.com/oauth)更好的资源了。
- en: The `token()` method uses the connection to request a token from Twitter, which
    is needed for our requests to be successful. When one is obtained, we take the
    user to a specific Twitter URL using this token (the redirection takes place in
    the controller's `_authorize()` method), which is then used by Twitter to request
    the user for authorization.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`token()` 方法使用连接从 Twitter 请求一个令牌，这对于我们的请求成功是必需的。当获得令牌后，我们使用这个令牌将用户带到特定的 Twitter
    URL（重定向发生在控制器中的 `_authorize()` 方法中），然后 Twitter 使用这个令牌请求用户进行授权。'
- en: If the user allows the access to his/her Twitter account, the Twitter API will
    redirect the browser to the URL specified in the `callback` argument of the datasource
    `token()` method. This callback was set in `_authorize()` as the current URL.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户允许访问他的/她的 Twitter 账户，Twitter API 将将浏览器重定向到数据源 `token()` 方法中 `callback` 参数指定的
    URL。这个回调在 `_authorize()` 中设置为当前 URL。
- en: 'After the user is brought back to our application, the `_authorize()` method
    will check for the existence of two parameters sent by Twitter: `oauth_token`
    and `oauth_verifier`. These parameters are passed as arguments to the datasource
    `authorize()` method, which talks back to the Twitter API for the final stage
    in the OAuth authorization procedure. This stage ends with Twitter giving back
    a valid token, and a token secret key. They are saved in the controller as a session
    variable, to avoid doing this on every request.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户被带回到我们的应用程序后，`_authorize()` 方法将检查 Twitter 发送的两个参数的存在：`oauth_token` 和 `oauth_verifier`。这些参数作为参数传递给数据源的
    `authorize()` 方法，该方法与 Twitter API 通信以完成 OAuth 授权过程的最后阶段。这一阶段以 Twitter 返回一个有效的令牌和一个令牌密钥结束。它们被保存为控制器中的会话变量，以避免在每次请求时都这样做。
- en: Once we have the authorization information, we set it as a connection setting
    by using the `setConfig()` method available in all datasources, and setting this
    information in a setting named `authorize`, because we won't be able to read from
    or post to our Twitter account without this authorization.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了授权信息，我们就通过使用所有数据源中可用的 `setConfig()` 方法，并将这些信息设置在名为 `authorize` 的设置中，将其设置为连接设置，因为我们没有这个授权就无法从我们的
    Twitter 账户读取或发布。
- en: The datasource `read()` method is the implementation of all read procedures
    on our datasource. In our case, we only allow find operations that contain a condition
    on the field `username`. This condition tells us from which user account we want
    to obtain tweets. Using this account name and the authorization information, we
    make a request to the Twitter API to obtain the user timeline. Because the request
    was made using JSON, which can be identified from the request URL), we use PHP's
    `json_decode()` function to parse the response. We then browse through the resulting
    items (if no error was thrown) and change them into a more friendly format.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源 `read()` 方法是实现我们数据源上所有读取过程的实现。在我们的情况下，我们只允许包含在字段 `username` 上条件的查找操作。这个条件告诉我们从哪个用户账户获取推文。使用这个账户名称和授权信息，我们向
    Twitter API 发送请求以获取用户时间线。因为请求使用的是 JSON 格式（可以从请求 URL 中识别出来），所以我们使用 PHP 的 `json_decode()`
    函数来解析响应。然后我们浏览生成的项目（如果没有抛出错误），并将它们转换为更友好的格式。
- en: The datasource `write()` method is the implementation of save operations, that
    is, the creating of new tweets (modification of existing tweets is not supported
    in this implementation). Similarly to the `read()` method, we use the authorization
    information to make a POST request to the Twitter API, specifying as the tweet
    data whatever fields were sent to the method (combination of the `fields` and
    `values` arguments).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源 `write()` 方法是实现保存操作，即创建新的推文（在此实现中不支持现有推文的修改）。与 `read()` 方法类似，我们使用授权信息向 Twitter
    API 发送 POST 请求，指定作为推文数据的任何字段（`fields` 和 `values` 参数的组合）。
- en: Adding transaction and locking support to the MySQL datasource
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 MySQL 数据源添加事务和锁定支持
- en: CakePHP's built-in MySQL datasource provides some basic transaction support
    by sending all unknown method calls directly to the datasource. However, this
    only enables us to use some basic transaction commands, and any locking would
    have to be performed through manual SQL queries.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: CakePHP 内置的 MySQL 数据源通过将所有未知方法调用直接发送到数据源提供一些基本的事务支持。然而，这仅使我们能够使用一些基本的事务命令，并且任何锁定都必须通过手动
    SQL 查询来执行。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Table locking is a mechanism to effectively manage concurrent access to table
    contents by different client sessions. More information about locking in MySQL
    is available at [http://dev.mysql.com/doc/refman/5.5/en/internal-locking.html](http://dev.mysql.com/doc/refman/5.5/en/internal-locking.html).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 表锁定是一种机制，用于有效地管理不同客户端会话对表内容的并发访问。有关 MySQL 中锁定的更多信息，请参阅[http://dev.mysql.com/doc/refman/5.5/en/internal-locking.html](http://dev.mysql.com/doc/refman/5.5/en/internal-locking.html)。
- en: This recipe shows how to modify an existing datasource by implementing better
    transaction support to the MySQL driver, adding locking operations, and finally
    allowing a recovery procedure for locked queries.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱展示了如何通过实现更好的事务支持到 MySQL 驱动程序，添加锁定操作，并最终允许对锁定查询进行恢复程序来修改现有的数据源。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about transaction support in MySQL databases is available at
    [http://dev.mysql.com/doc/refman/5.5/en/commit.html](http://dev.mysql.com/doc/refman/5.5/en/commit.html).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 MySQL 数据库中事务支持的更多信息，请参阅[http://dev.mysql.com/doc/refman/5.5/en/commit.html](http://dev.mysql.com/doc/refman/5.5/en/commit.html)。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To go through this recipe we need a sample table to work with. Create a table
    named `profiles` using the following SQL statement:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个菜谱，我们需要一个用于操作的示例表。使用以下 SQL 语句创建一个名为 `profiles` 的表：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The above query includes the specification of the MySQL database engine. Even
    when MyISAM (another available engine) can handle table level locking, row level
    locking is only possible on InnoDb tables. Furthermore, transactions are only
    supported on InnoDb. More information about the different engines and their supported
    features is available at [http://dev.mysql.com/doc/refman/5.5/en/storage-engines.html](http://dev.mysql.com/doc/refman/5.5/en/storage-engines.html).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询包括对 MySQL 数据库引擎的指定。即使 MyISAM（另一个可用的引擎）可以处理表级锁定，行级锁定也仅在 InnoDb 表上可行。此外，事务仅在
    InnoDb 上受支持。有关不同引擎及其支持特性的更多信息，请参阅[http://dev.mysql.com/doc/refman/5.5/en/storage-engines.html](http://dev.mysql.com/doc/refman/5.5/en/storage-engines.html)。
- en: 'Add some sample data using the following SQL statements:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下 SQL 语句添加一些示例数据：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We proceed now to create the required model. Create the model `Profile` in
    a file named `profile.php` and place it in your `app/models` folder with the following
    contents:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在开始创建所需的模型。在名为 `profile.php` 的文件中创建模型 `Profile`，并将其放置在您的 `app/models` 文件夹中，内容如下：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create its appropriate controller `ProfilesController` in a file named `profiles_controller.php`
    and place it in your `app/controllers` folder with the following contents:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为 `profiles_controller.php` 的文件中创建相应的控制器 `ProfilesController`，并将其放置在您的 `app/controllers`
    文件夹中，内容如下：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We start by creating the skeleton of our datasource. Create a folder named
    `dbo` inside your `app/models/datasources` folder. In the `dbo` folder, create
    a file named `dbo_mysql_transaction.php` with the following contents:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建数据源的骨架。在您的 `app/models/datasources` 文件夹内创建一个名为 `dbo` 的文件夹。在 `dbo` 文件夹中，创建一个名为
    `dbo_mysql_transaction.php` 的文件，内容如下：
- en: '[PRE42]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We continue by adding methods to lock and unlock tables. Edit your `app/models/datasources/dbo/dbo_mysql_transaction.php`
    file and add the following methods to the `DboMysqlTransaction` class:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续添加锁定和解锁表的方法。编辑您的 `app/models/datasources/dbo/dbo_mysql_transaction.php`
    文件，并将以下方法添加到 `DboMysqlTransaction` 类中：
- en: '[PRE43]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We will now add our basic transaction commands. Edit your `app/models/datasources/dbo/dbo_mysql_transaction.php`
    file and add the following methods to the `DboMysqlTransaction` class:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将添加基本的事务命令。编辑您的 `app/models/datasources/dbo/dbo_mysql_transaction.php` 文件，并将以下方法添加到
    `DboMysqlTransaction` 类中：
- en: '[PRE44]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We end by adding methods to recover from a locked query, and to log those locks.
    Once again, edit your `app/models/datasources/dbo/dbo_mysql_transaction.php` file
    and add the following methods to the `DboMysqlTransaction` class:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过添加从锁定查询中恢复的方法以及记录这些锁的方法来结束。再次编辑您的 `app/models/datasources/dbo/dbo_mysql_transaction.php`
    文件，并将以下方法添加到 `DboMysqlTransaction` 类中：
- en: '[PRE45]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To test what happens when you reach a lock, edit your `app/controllers/profiles_controller.php`
    file and add the following method to the `ProfilesController` class:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试达到锁时会发生什么，编辑您的 `app/controllers/profiles_controller.php` 文件，并将以下方法添加到 `ProfilesController`
    类中：
- en: '[PRE46]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Open your MySQL client and issue the following SQL commands (don''t close the
    client after you issue these commands as you may want to release the lock as shown
    later):'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的 MySQL 客户端并执行以下 SQL 命令（在执行这些命令后不要关闭客户端，因为您可能需要像后面所示释放锁）：
- en: '[PRE47]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we now browse to `http://localhost/profiles` we should get an SQL error
    message that reads **SQL Error: 1205: Lock wait timeout exceeded; try restarting
    transaction**. A file named `locks.log` should have been created in your `app/tmp/logs`
    folder with the following contents (the database name `cookbook_chapter5_transaction`
    should change to the name of the database you are using):'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在浏览到`http://localhost/profiles`，我们应该得到一个读取的SQL错误消息，内容为**SQL错误：1205：锁定等待超时；尝试重新启动事务**。应在您的`app/tmp/logs`文件夹中创建一个名为`locks.log`的文件，其中包含以下内容（数据库名称`cookbook_chapter5_transaction`应更改为您使用的数据库名称）：
- en: '[PRE48]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To test the recovery of locked queries, we could release the lock in our MySQL
    client by issuing the following command:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试锁定查询的恢复，我们可以通过在MySQL客户端发出以下命令来释放锁：
- en: '[PRE49]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: and do so somewhere between the first failed transaction and the next recovery
    attempt. To change how much time MySQL waits to see if a lock can be obtained,
    access MySQL documentation for the server setting `innodb_lock_wait_timeout`.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并在第一次失败的事务和下一次恢复尝试之间进行。要更改MySQL等待锁定可获得的时长，请访问MySQL文档中的服务器设置`innodb_lock_wait_timeout`。
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As we are extending a DBO based datasource, we name our class using the `Dbo`
    prefix (DboMysqlTransaction), and place it in the `dbo` folder which is itself
    in our `app/models/datasources` folder.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们扩展了一个基于DBO的数据源，我们使用`Dbo`前缀（DboMysqlTransaction）命名我们的类，并将其放置在`dbo`文件夹中，该文件夹位于我们的`app/models/datasources`文件夹中。
- en: 'The initial implementation includes two class properties:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 初始实现包括两个类属性：
- en: '`backAutoCommit:Utilized` by the helper methods `_startTransaction()` and `_endTransaction()`,
    is used to temporarily change the auto commit setting.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backAutoCommit`：由辅助方法`_startTransaction()`和`_endTransaction()`使用，用于暂时更改自动提交设置。'
- en: '`lockTimeoutErrorCode`: Specifies MySQL''s code number for identifying deadlock
    time expired errors.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lockTimeoutErrorCode`：指定MySQL用于识别死锁超时错误的代码号。'
- en: 'Our first method is the class constructor, which is overridden to add our own
    connection settings, and the actual SQL commands to lock and unlock tables and
    to change the auto commit setting. The connection settings we added are:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个方法是类构造函数，它被重写以添加我们自己的连接设置，以及锁定和解锁表以及更改自动提交设置的SQL命令。我们添加的连接设置是：
- en: '`lock`: It is a set of settings that specify what to do when dealing with locked
    queries. Its subset of settings are:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock`：它是一组设置，用于指定处理锁定查询时要执行的操作。其设置子集包括：'
- en: '`log`: It is path to the file where to store logging information. If set to
    `false`, logging will be disabled. Defaults to a file named `locks.log` that is
    created in the `app/tmp/logs` directory.'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log`：它是存储日志信息的文件路径。如果设置为`false`，则禁用日志记录。默认为在`app/tmp/logs`目录中创建的名为`locks.log`的文件。'
- en: '`recover`: It decides whether to try to recover from locked queries. If set
    to `false`, no recovery will be attempted. Defaults to `true`.'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recover`：它决定是否尝试从锁定查询中恢复。如果设置为`false`，则不会尝试恢复。默认为`true`。'
- en: '`retries`: It decides if `recover` is set to `true`, how many attempts to rerun
    the failed (locked) query. Defaults to `1`.'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retries`：如果`recover`设置为`true`，则决定重试失败（锁定）查询的次数。默认为`1`。'
- en: '`autoCommit`: It gives the initial autocommit value (true for enabled, `false`
    for disabled). If set to `null`, it will get its value from the database server.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoCommit`：它给出初始的自动提交值（启用时为`true`，禁用时为`false`）。如果设置为`null`，它将从数据库服务器获取其值。'
- en: 'We then implement the `lock()` and `unlock()` methods. The `lock()` method
    allows us to lock a table for a certain operation. We can use it directly from
    a model to lock its underlying table for a `read` operation:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实现`lock()`和`unlock()`方法。`lock()`方法允许我们对表进行锁定以执行特定操作。我们可以直接从模型中使用它来锁定其底层表以执行`read`操作：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can change the locking operation to be `write`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将锁定操作更改为`write`：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can also use it to lock a specific table, using either the `lock()` method
    available on all models using this datasource, or directly invoking the method
    in the datasource:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用它来锁定特定的表，使用所有使用此数据源的所有模型上的`lock()`方法，或者直接在数据源中调用该方法：
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `unlock()` method is used similarly, either through the model, or directly
    using the datasource) and unlocks all locked tables.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`unlock()`方法的使用方式类似，无论是通过模型还是直接使用数据源，都可以解锁所有锁定表。'
- en: Note
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When you do lock table, make sure you disable auto commit, by using the `setAutoCommit()`
    method, like so: `$this->Profile->setAutoCommit(false)`;'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当您锁定表时，请确保您使用`setAutoCommit()`方法禁用自动提交，如下所示：`$this->Profile->setAutoCommit(false)`；
- en: In the next block of code, we add the implementation for starting, committing
    and rolling back transactions. There is not much detail needed for these methods
    except that they take care of disabling auto-commit upon starting a transaction,
    and reset its status after a transaction is finished.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一块代码中，我们添加了开始、提交和回滚事务的实现。对于这些方法，除了它们在开始事务时负责禁用自动提交，并在事务完成后重置其状态之外，不需要太多细节。
- en: 'The `query()` method is overridden to allow executing some of our datasource
    methods directly from our models. That is the case for the three methods we added:
    `lock(), unlock()`, and `setAutoCommit().`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`query()` 方法被重写，以便可以直接从我们的模型中执行一些数据源方法。这适用于我们添加的三个方法：`lock()`、`unlock()` 和
    `setAutoCommit()`。'
- en: Finally, we override the `_execute()` method to detect when a lock wait timeout
    error is thrown. In these cases, we use the `lockLog()` method to LOG the situation,
    and we proceed to retry the query if we were told to do so.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们重写 `_execute()` 方法以检测何时抛出锁等待超时错误。在这些情况下，我们使用 `lockLog()` 方法记录情况，并且如果我们被告知这样做，我们将继续重试查询。
