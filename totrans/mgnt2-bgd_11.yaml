- en: Chapter 10. The Major Functional Areas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Magento platform comprises various modules that deliver various bits of
    functionality. Developers are often more in touch with one group of functionality
    than others. Examples of some of the most commonly used functionalities include
    those related to CMS blocks and pages, categories, products, customers, imports,
    custom product types, custom payment, and shipping modules. This is not to say
    that other functionalities are less important. In this chapter, we will take a
    quick look at the functionalities in the Magento admin area, PHP code, and API
    calls. The chapter is divided into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: CMS management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catalog management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Products and customer import
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom product types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom offline shipping methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom offline payment methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The intention is not to go into the details of each functional area. Rather,
    the aim is to show the admin interface and the corresponding programmatic and
    API approach towards basic management.
  prefs: []
  type: TYPE_NORMAL
- en: CMS management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Content is what helps differentiate one store from another. Quality content
    can boost a store's visibility on search engines, provide informative insight
    to the customers who buy products, and provide credibility and trust. Magento
    provides a solid content management system, which can be used to create rich content
    for a store. We can use it to manage blocks and pages too.
  prefs: []
  type: TYPE_NORMAL
- en: Managing blocks manually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A CMS block is a small modular unit of content that can be positioned almost
    anywhere on a page. They can even be called into another blocks. Blocks support
    HTML and JavaScript as its content. Therefore, they are able to display static
    information such as text, images, and embedded video as well as dynamic information.
  prefs: []
  type: TYPE_NORMAL
- en: Blocks can be created via an admin interface, APIs, or code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps outline the block creation process from within an admin
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the Magento admin area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Content** | **Elements** | **Blocks** menu, click on **Add New Block**.
    This opens a screen that is similar to the one shown in the following screenshot:![Managing
    blocks manually](img/00070.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in some values for the required fields (**Block Title**, **Identifier**,
    **Store View**, **Status**, and **Content**) and click on the **Save Block** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the block is saved, you will see the **You saved the block.** success message
    in the browser. CMS blocks are stored in the `cms_block` and `cms_block_store`
    tables in a database.
  prefs: []
  type: TYPE_NORMAL
- en: The **Identifier** value is probably the most interesting aspect here. We can
    use it in a CMS page, another CMS block, or some code to fetch the block that
    we have just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that we have created a block with the **Identifier** value of `foggyline_hello`,
    we can call it in the CMS page or another block by using the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass the actual integer ID value of a block to the preceding expression,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: However, this approach requires us to know the actual integer ID of a block.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding expressions show that blocks are included in a page or another
    block via a widget, which is also known as a frontend app. A widget of the `Magento\Cms\Block\Widget\Block`
    class type is using the `widget/static_block/default.phtml` template file to render
    the actual CMS block.
  prefs: []
  type: TYPE_NORMAL
- en: Managing blocks via code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides the manual creation of blocks via the admin interface, we can create
    CMS blocks by using code, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the instance manager to create a new model instance of the `Magento\Cms\Model\Block`
    class. Then, we set some properties through defined methods and finally called
    the `save` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can load and update the existing blocks using a code snippet that is similar
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The block's `load` method accepts either an integer value of a block ID or a
    string value of a block identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can manage the creation and updating of blocks through the available
    APIs method. The following code snippet shows how a CMS block is created via a
    console cURL REST API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The bearer string is just a login token that we obtain by first running the
    authentication API call, as described in the previous chapter. Once we have the
    authentication token, we can make a `V1/cmsBlock` `POST` request, passing a JSON
    object as data.
  prefs: []
  type: TYPE_NORMAL
- en: Managing blocks via API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can get the newly created CMS block through an API by executing a snippet
    of code that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can update the existing CMS block by using an API and executing a snippet
    of code that is similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the HTTP PUT method and passed the integer `4` as a part of the
    `V1/cmsBlock/4` URL. The number 4 represents the ID value of the block in the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Managing pages manually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CMS pages are robust content units unlike CMS blocks, which are simply embedded
    into certain pages. The CMS page can have its own URL. Examples of CMS pages are
    pages such as **404 Not Found**, **Home page**, **Enable Cookies**, and **Privacy
    and Cookie Policy**. The idea, when it comes to dealing with CMS pages, is that
    we can control the content area of a page without affecting site-wide elements
    such as the header, footer, or sidebars. Magento does not really come with many
    out-of-the-box CMS pages other than the ones that were listed previously.
  prefs: []
  type: TYPE_NORMAL
- en: Like blocks, pages can also be created via the admin interface, APIs, or code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps outline the page creation process from within the admin
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to Magento admin area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Content** | **Elements** | **Pages menu**, click on **Add New Page**.
    This opens a screen that is similar the one shown in the following screenshot:![Managing
    pages manually](img/00071.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in some values for the required fields (**Page Title**, **Store View**,
    **Status**, and **Content**) and click on the **Save** Block button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the page is saved, you will see the **You saved this page.** success message
    in the browser. CMS pages are stored in the `cms_page` and `cms_page_store` tables
    in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that we have created a page with **Page Title** value **Info**, we
    can access this page in a browser via a URL such as `http://magento2.ce/info`.
    Though we could have to specify the **URL Key** value in the **New Page** edit
    screen, Magento automatically assigns **URL Key** that matches **Page Title**.
  prefs: []
  type: TYPE_NORMAL
- en: Managing pages via code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides the manual creation through the admin interface, we can create CMS
    pages via code, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the instance manager to create a new model instance of the `Magento\Cms\Model\Page`
    class. Then, we set some properties through the defined methods and finally called
    the `save` method. The **URL Key** that we set through the admin interface is
    actually an identifier that we set via the `setIdentifier` method call.
  prefs: []
  type: TYPE_NORMAL
- en: Managing pages via API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can load and update the existing pages by using a code snippet that is similar
    to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The page model `load` method accepts either an integer ID value of a page identifier
    (**URL Key**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can manage the creation and updating of pages through the available
    APIs method. The following code snippet shows how a CMS page is created via a
    console cURL REST API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can update the existing CMS page through an API by executing a snippet of
    code that is similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the HTTP PUT method, passing the integer `7` as a part of the
    `V1/cmsPage/7` URL. The number 7 represents the ID value of the page in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Catalog management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Magento_Catalog` module is one of the backbones of the entire Magento platform.
    It provides robust support for the inventory management of various product types.
    This module is what manages products, categories and their attributes, the display
    on the frontend, and many more things.
  prefs: []
  type: TYPE_NORMAL
- en: Managing categories manually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can access the catalog functionality within the Magento admin area by navigating
    to **Products** | **Inventory** | **Catalog** or **Products** | **Inventory**
    | **Category**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we start with a blank Magento installation, we will probably start with
    categories as one of the first entities to be created. We can manually create
    categories by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the Magento admin area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Products** | **Inventory** | **Category** menu. This opens a screen
    that is similar to the one shown in the following screenshot:![Managing categories
    manually](img/00072.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the left-hand side of the screen, click on **Default Category**. Then, when
    the page reloads, click on the **Add Subcategory** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Though it may seem that nothing has happened, as the screen content does not
    change, we should now fill in the required options in the **General Information**
    tab, setting **Name** to some string value and **Is Active** to Yes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click on the **Save Category** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The new category should now be created. To the left screen area, if you click
    on the name of the newly created category, you will see its ID value above the
    **General Information** tab, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing categories manually](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Knowing the category ID enables you to directly test it on a storefront simply
    by opening a URL such as `http://magento2.ce/index.php/catalog/category/view/id/3`
    in the browser, where the number `3` is the ID of the category. You will see a
    loaded category page that probably shows the **We can't find products matching
    the selection.** message, which is good, as we haven't assigned products to a
    category.
  prefs: []
  type: TYPE_NORMAL
- en: Though we will not go into its details, it is worth noting that we have simply
    scratched the surface here, as categories enable us to provide many additional
    options using the **Display Settings**, **Custom Design** tabs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that categories are EAV entities, their data is stored across several
    tables in the database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`catalog_category_entity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_category_entity_datetime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_category_entity_decimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_category_entity_int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_category_entity_text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_category_entity_varchar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few additional tables that link categories to products:'
  prefs: []
  type: TYPE_NORMAL
- en: '`catalog_category_product`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_category_product_index`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_category_product_index_tmp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_url_rewrite_product_category`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing categories via code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides the manual creation through the admin interface, we can create categories
    via code, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: What is specific here is that when creating a new category, we first created
    a `$parentCategory` instance, which represents the root category object. We used
    the `Category` model `TREE_ROOT_ID` constant as the ID value of a parent category
    ID. Then, we created an instance of the category, set its `path`, `parent_id`,
    `name`, and `is_active` value.
  prefs: []
  type: TYPE_NORMAL
- en: Managing categories via API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can further manage category creation through the available APIs method.
    The following code snippet shows category creation via the console cURL REST API
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The bearer string is just a login token that we obtain by first running the
    authentication API call, as described in the previous chapter. Once we have the
    authentication token, we can make a `/V1/categories POST` request, passing a JSON
    object as data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the newly created category as a JSON object through an API by executing
    a snippet of code that looks like the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Managing products manually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at how to create a new product. We can manually create
    products by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the Magento admin area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Products** | **Inventory** | **Catalog** menu, click on the **Add Product**
    button. This opens a screen similar to the one shown in the following screenshot:![Managing
    products manually](img/00074.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, fill in the required options on the **Product Details** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click on the **Save** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is successfully saved, the page reloads and shows the **You saved the
    product.** message.
  prefs: []
  type: TYPE_NORMAL
- en: Like categories, we have barely scratched the surface of products here. Looking
    at the other available tabs, there are a large number of additional options that
    can be assigned to a product. Simply assigning the required options should be
    enough for us to see the product on the store's frontend on a URL such as `http://magento2.ce/index.php/catalog/product/view/id/4`,
    where the number `4` is the ID value of a product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Products are also EAV entities, whose data is stored across several tables
    in a database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`catalog_product_entity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_datetime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_decimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_gallery`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_group_price`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_media_gallery`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_media_gallery_value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_tier_price`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog_product_entity_varchar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also a large number of other table referencing products, such as `catalog_product_bundle_selection`,
    but these are mostly used to link bits of functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Managing products via code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides the manual creation through the admin interface, we can create products
    via code, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Managing products via API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example uses the REST API to create a new simple product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `Bearer` token should have been previously obtained by using an authentication
    request. The response should be a JSON object that contains all the exposed product
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the existing product as information through an API that executes
    a snippet of code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `product_dynamic_125` part in the preceding URL stands for this specific
    product SKU value. The response is a JSON object that contains all the exposed
    product data.
  prefs: []
  type: TYPE_NORMAL
- en: The entire list of the available catalog APIs can be seen in the `vendor/magento/module-catalog/etc/webapi.xml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Customer management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing customers is another important aspect of the Magento platform. Most
    of the time, customer creation is something that is left for a new customer to
    do. A new customer who visits a store initiates the registration process and finishes
    up with a customer account being created. Once registered, customers can then
    further edit their account details on the storefront under the **My Account**
    page, which is usually available on a link such as `http://magento2.ce/index.php/customer/account/index/`.
  prefs: []
  type: TYPE_NORMAL
- en: As a part of this section, we are interested in the possibility of managing
    customer accounts by using the admin area, code, and API.
  prefs: []
  type: TYPE_NORMAL
- en: Managing customers manually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps outline the customer account creation process from within
    the admin interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to Magento admin area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Customers** | **All Customers** menu, click on the **Add New Customer**
    button. This opens a screen that looks similar to the one shown in the following
    screenshot:![Managing customers manually](img/00075.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in some values for the required fields (**Associate to Website**, **Group**,
    **First Name**, **Last Name**, and **Email**) and click on the **Save Customer**
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the customer is saved, you will see the **You saved the customer.** success
    message in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The **Associate to Website** value is probably the most important value for
    cases like this one, where customer accounts are being indirectly created by a
    user who's not a customer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Magento supports the setting up of multiple websites, customer accounts
    can be set to either the **Global** or **Per Website** value, depending on the
    **Stores** | **Settings** | **Configuration** | **Customers** | **Customer Configuration**
    | **Account Sharing Option** | **Share Customer Accounts** option. Thus, if the
    **Share Customer Accounts** option has been set to **Per Website**, it is of the
    utmost important to point the **Associate to Website** value to the proper website.
    Otherwise, a customer account will be created but the customer won't be able to
    log in to it on the storefront.
  prefs: []
  type: TYPE_NORMAL
- en: The `Magento_Customer` module uses the EAV structure to store customer data.
    Thus, there is no single table that stores customer information. Rather, multiple
    tables exist, depending on the customer property and its data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list comprises tables that store customer entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '`customer_entity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`customer_entity_datetime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`customer_entity_decimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`customer_entity_int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`customer_entity_text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`customer_entity_varchar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Customer accounts will not really be complete without a customer address. The
    address can be added via the **Addresses** tab under the customer edit screen
    in the admin area, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing customers manually](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note that Magento enables us to set one of the addresses as **Default Shipping
    Address** and **Default Billing Address**.
  prefs: []
  type: TYPE_NORMAL
- en: Like the customer entity, the customer address entity also uses the EAV structure
    to store its data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list comprises tables that store the customer address entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '`customer_address_entity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`customer_address_entity_datetime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`customer_address_entity_decimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`customer_address_entity_int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`customer_address_entity_text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`customer_address_entity_varchar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing customers via code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides the manual creation via the admin interface, we can create customers
    via code, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the instance manager to create a new model instance of the
    `Magento\Customer\Model\Customer` class. We can then set some properties through
    the defined methods and finally call the `save` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can load and update an existing customer by using a code snippet that is
    similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can use either the `load` or `loadByEmail` method call. The `load` method
    accepts the integer ID value of the existing customer entity, while `loadByEmail`
    accepts a string e-mail address. It is worth noting that `setWebsiteId` has to
    be called prior to any of the load methods. Otherwise, we will get an error message
    that says **A customer website ID must be specified when using the website scope**.
  prefs: []
  type: TYPE_NORMAL
- en: Managing customers via an API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we can manage the creation and updating of customer information using
    the available API method. The following code snippet shows how to create a customer
    via a console cURL REST API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the authentication token, we can make a `V1/customers` `POST` request,
    passing a JSON object as data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the newly created customer via an API by executing a snippet of
    code that is similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can update an existing customer through an API by executing a snippet of
    code that is similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the HTTP PUT method, passing the integer `24` as a part of the
    `V1/customers/24 and as part of the body` URL. The number 24 represents the ID
    value of a customer in the database. Also, note the `password_hash` value; without
    it, the update will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Managing customer address via code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to customers, we can create a customer address using code, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the instance manager to create a new model instance of the `Magento\Customer\Model\Address`
    class. We then set some properties through the defined methods and finally called
    the `save` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can load and update the existing customer address by using a code snippet
    that is similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the `load` method to load an existing address by its ID value.
    Then, we called the `setCity` method passing it the updated string. After the
    `save` method is executed, the address should reflect the change.
  prefs: []
  type: TYPE_NORMAL
- en: Managing customers address via an API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Surprisingly, a customer address cannot be created or updated directly via
    an API call, as there is no `POST` or `PUT REST` API defined. However, we can
    still get the existing customer address information by using an API, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The entire list of available customer APIs can be seen in the `vendor/magento/module-customer/etc/webapi.xml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Products and customers import
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Magento provides an out-of-the-box mass import and export functionality via
    the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AdvancedPricingImportExport`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BundleImportExport`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CatalogImportExport`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConfigurableImportExport`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CustomerImportExport`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GroupedImportExport`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImportExport`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TaxImportExport`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The heart of the import functionality actually lies in the `ImportExport` module,
    while other modules provide individual import and export entities through the
    `vendor/magento/module-{partialModuleName}-import-export/etc/import.xml` and `vendor/magento/module-{partialModuleName}-import-export/etc/export.xml`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: These functionalities can be accessed from the Magento admin area from the **System**
    | **Data Transfer** menu. They enable us to export and import several entity types,
    such as **Advanced Pricing**, **Products**, **Customers Main File**, and **Customer
    Addresses**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the **Entity Type** options for the **Import
    Settings** screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Products and customers import](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next to **Import Settings**, when we select **Entity Type** for import, the
    **Import Behavior** section appears, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Products and customers import](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Most entity types have similar options for **Import Behavior**. Most of the
    time, we will be interested in the **Add/Update** behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Since importing is a bit more complicated process than exporting, we will focus
    on importing and the CSV file format. More specifically, our focus is on **Products**,
    **Customers Main File**, and **Customer Addresses** imports.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with a clean Magento installation, the following columns are required
    during the product import in order to make the product visible on the storefront
    afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sku` (for example, "test-sku"): This can have almost any value as long as
    it is unique across Magento.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attribute_set_code` (for example, "Default"): This can have any of the values
    found in a database when the `SELECT DISTINCT attribute_set_name FROM eav_attribute_set;`
    query is executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product_type` (for example, "simple"): This can have the values of `simple`,
    `configurable`, `grouped`, `virtual`, `bundle`, or `downloadable`. Additionally,
    if we create or install a third-party module that adds a new product type, we
    can use that one as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`categories` (for example, "Root/Shoes"): Create a full category path using
    the "Root category name/Child category name/Child child category name" syntax.
    If there are multiple categories, then a pipe ("|") is used to separate them.
    An example of this is "Root category name/Child category name/Child child category
    name| Root category name/Child_2 category name".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product_websites` (for example, "base"): This can have the values found in
    a database when the `SELECT DISTINCT code FROM store_website;` query is executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` (for example, "Test"): This can have almost any value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`product_online` (for example, "1"): This can be either `1` for `visible` or
    `0` for `not visible`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`visibility` (for example, "Catalog, Search"): This can have the values of
    "Not Visible Individually", "Catalog", "Search", or "Catalog, Search".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`price` (for example, "9.99"): This can be an integer or a decimal value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qty` (for example, "100"): This can be an integer or a decimal value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Though the products will get imported just with the preceding list that comprises
    a set of columns, we usually would like to assign additional information to them,
    such as descriptions and images. We can do so with the help of the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`description` (for example, "The description"): This can have any string value.
    HTML and JavaScript are supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short_description` (for example, "The short description"): This can have any
    string value. HTML and JavaScript are supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`base_image` (for example, `butterfly.jpg`): This is the final import image
    name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`small_image` (for example, `galaxy.jpg`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thumbnail_image` (for example, `serenity.jpg`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding the importing of images, we only need to provide the final image name
    as long as the **Images File Directory** path is set during the import. We can
    use a relative path for the Magento installation, such as `var/export`, `var/import`,
    `var/export/some/dir`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the import is finished, it is suggested to run the `php bin/magento indexer:reindex`
    command via the console. Otherwise, the products won't be visible on the storefront
    until the indexer is run.
  prefs: []
  type: TYPE_NORMAL
- en: Once the reindexing is done, we can try opening the storefront URL, which looks
    like `http://magento2.ce/index.php/catalog/product/view/id/1`. The number `1`
    in this case is a newly imported product ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with a clean Magento installation, the following columns are required
    during a customer''s main file import in order for our customer to be able to
    successfully log in to the storefront afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '`email` (for example, `<[john.doe@fake.mail](mailto:john.doe@fake.mail)>`):
    an e-mail address as a string value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_website` (for example, base): This can have any of the values found in the
    database when the `SELECT DISTINCT code FROM store_website;` query is executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firstname` (for example, John): a string value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastname` (for example, Doe): a string value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`group_id` (for example, 1): This can have any of the values found in the database
    when the `SELECT customer_group_id code FROM customer_group WHERE customer_group_id
    != 0;` query is executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Though a customer will be able to log in to the storefront with just the previously
    listed set of columns, we usually would like to assign other relevant pieces of
    information. We can do so with the help of the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gender` (for example, Male): This can be either Male or Female'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`taxvat` (for example, HR33311122299): any valid VAT number, though an import
    will accept even the invalid ones'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dob` (for example, 1983-01-16): date of birth'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prefix` (for example, Mr): any string value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`middlename` (for example, the dev guy): any string value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`suffix` (for example, engineer): any string value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password` (for example, 123abc): any string value that has a minimum length
    of 6 characters, as defined via `\Magento\CustomerImportExport\Model\Import\Customer::MIN_PASSWORD_LENGTH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to pay special attention to the `password` column. This is a clear text
    password. Therefore, we need to be careful not to distribute a CSV file in a nonsecure
    manner. Ideally, we can provide the `password_hash` column instead of `password`.
    However, entries under the `password_hash` column will need to be hashed via the
    same algorithm as the one that was called within the `hashPassword` method of
    the `Magento\Customer\Model\Customer` class. This further calls the `getHash`
    method on an instance of the `Magento\Framework\Encryption\Encryptor` class, which
    finally resolves to the `md5` or `sha256` algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with a clean Magento installation, the following columns are required
    during the customer address import in order for our customers to be able to successfully
    use the addresses on the storefront afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_website` (for example, base): This can have any of the values found in the
    database when the `SELECT DISTINCT code FROM store_website;` query is executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_email` (for example, `<[john@change.me](mailto:john@change.me)>`): an e-mail
    address as a string value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_entity_id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firstname` (for example, John): any string value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastname` (for example, Doe): any string value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`street` (for example, Ashton Lane): any string value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`city` (for example, Austin): any string value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`telephone` (for example, 00 385 91 111 000): any string value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`country_id` (for example, GB): the country code in the ISO-2 format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postcode` (for example, TX 78753): any string value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Though a customer will be able to use the addresses on the storefront with
    just a listed set of columns, we usually would like to assign other relevant pieces
    of information. We can do so with the help of the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`region` (for example, California): This can be blank, a free form string,
    or a specific string that matches any of the values found in the database when
    the `SELECT DISTINCT default_name FROM directory_country_region;` query is executed.
    On running `SELECT DISTINCT country_id FROM directory_country_region;`, 13 different
    country codes that have entries within the `directory_country_region` table are
    shown—`AT`, `BR`, `CA`, `CH`, `DE`, `EE`, `ES`, `FI`, `FR`, `LT`, `LV`, `RO`,
    `US`. This means that countries with that code need to have a proper region name
    assigned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`company` (for example, Foggyline): This can be any string value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fax` (for example, 00 385 91 111 000): This can be any string value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`middlename` (for example, the developer): This can be any string value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prefix` (for example, Mr): This can be any string value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`suffix` (for example, engineer): This can be any string value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vat_id` (for example, HR33311122299): This can be any valid VAT number, though
    import will accept even the non-valid ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_address_default_billing_` (for example, "1"): This can be either "1" as yes
    or "0" as no, to flag the address as being the default billing address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_address_default_shipping_` (for example, "1"): This can be either "1" as
    yes or "0" as no, to flag the address as being default shipping address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While CSV imports are a great and relatively fast way to mass import products,
    customers, and their addresses, there are some limitations to it. CSV is simply
    flat data. We cannot apply any logic to it. Depending on how clean and valid the
    data is, the CSV import might do just fine. Otherwise, we might want to opt for
    APIs. We need to keep in mind that a CSV import is much faster than the API creation
    of products and customers because CSV imports work directly by bulk inserting
    on the database, while APIs instantiate full models, respect the event observers,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The custom product types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Magento provides the following six out-of-the-box product types:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurable products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouped products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundle products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloadable products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each product has its specifics. For example, the virtual and downloadable products
    do not have the `weight` attribute. Therefore, they are excluded from the standard
    shipping calculations. With custom coding around built-in product types, by using
    observers and plugins we can achieve almost any functionality. However, this is
    not enough sometimes or there is no solution to the requirement. In cases such
    as these, we might need to create our own product type that will match the project
    requirements in a more streamlined way.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a miniature module called `Foggyline_DailyDeal` that will add a
    new product type to Magento.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a module registration file named `app/code/Foggyline/DailyDeal/registration.php`
    that has the following partial content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create an `app/code/Foggyline/DailyDeal/etc/module.xml` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create an `app/code/Foggyline/DailyDeal/etc/product_types.xml` file that
    has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `customAttributes` element is parsed by `vendor/magento/module-catalog/Model/ProductTypes/Config.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `app/code/Foggyline/DailyDeal/Model/Product/Type/DailyDeal.php` file
    with partial content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create an `app/code/Foggyline/DailyDeal/Model/Product/Price.php` file
    with partial content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After this is done, create an `app/code/Foggyline/DailyDeal/Model/ResourceModel/Indexer/Price.php`
    file with partial content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create an `app/code/Foggyline/DailyDeal/Model/ResourceModel/Indexer/Stock.php`
    file with partial content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create an `app/code/Foggyline/DailyDeal/Setup/InstallData.php` file
    with partial content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Extend the `install` method from within the `InstallData` class by adding the
    following `foggylinedailydeal` type specifics to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, run `php bin/magento setup:upgrade` from the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you now open the **Products** | **Inventory** | **Catalog** menu in the
    admin area and click on the dropdown icon next to the **Add Product** button,
    you will see the **Daily Deal** product type on the list, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The custom product types](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the **Daily Deal** product type in the dropdown list should open
    the product edit page, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The custom product types](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There is no noticeable difference between the custom product type edit screen
    and one of the built-in product types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that we have named the product `Daily Deal Test Product` and saved
    it, we should be able to see it on the storefront, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The custom product types](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we add the product to the cart and perform a checkout, an order should be
    created just as with any other product type. Within the admin area, on the order
    view page, under **Items Ordered**, we should be able to see the product on the
    list, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The custom product types](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Again, there is no noticeable difference between the custom product type and
    the built-in product type that is rendering under the **Items Ordered** section.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we should run the `php bin/magento indexer:reindex` command on the
    console. Even though we haven't really implemented any code within the indexers,
    this is just to ensure that none of the existing indexers broke.
  prefs: []
  type: TYPE_NORMAL
- en: The entire module code can be downloaded from [https://github.com/ajzele/B05032-Foggyline_DailyDeal](https://github.com/ajzele/B05032-Foggyline_DailyDeal).
  prefs: []
  type: TYPE_NORMAL
- en: Custom offline shipping methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Magento provides several out-of-the-box offline shipping methods, such as `Flatrate`,
    `Freeshipping`, `Pickup`, and `Tablerate`. We can see those in the `vendor/magento/module-offline-shipping/Model/Carrier`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: However, project requirements quite often are such that we need a custom coded
    shipping method where a special business logic is applied. Thus, the shipping
    price calculation can be controlled by us. In such cases, knowing how to code
    our own offline shipping method might come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and create a small module called `Foggyline_Shipbox` that provides
    Magento an extra offline shipping method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a module registration file named `app/code/Foggyline/Shipbox/registration.php`
    with partial content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create an `app/code/Foggyline/Shipbox/etc/module.xml` file with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create an `app/code/Foggyline/Shipbox/etc/config.xml` file with content,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After this is done, create an `app/code/Foggyline/Shipbox/etc/adminhtml/system.xml`
    file with content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create an `app/code/Foggyline/Shipbox/Model/Carrier/Shipbox.php` file
    with partial content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Extend the `collectRates` method in the `Carrier\Shipbox` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Magento admin area, if you now look under **Stores** | **Settings**
    | **Configuration** | **Sales** | **Shipping Methods**, you will see **Foggyline
    Shipbox** on the list, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom offline shipping methods](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Set the **Enabled** option to **Yes** and click the **Save Config** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you now run the `SELECT * FROM core_config_data WHERE path LIKE "%shipbox%";`
    query on the MySQL server, you will see results that are similar to the ones shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom offline shipping methods](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note how there is no direct code within the code snippets in the preceding screenshot
    that is related to the **Ship to Applicable Countries** and **Ship to Specific
    Countries** options, because the handling of these options is built into the parent
    `AbstractCarrier` class. Thus, simply by adding the `sallowspecific` option in
    `config.xml` and `system.xml`, we enabled a feature where the shipping method
    can be shown or hidden from certain countries.
  prefs: []
  type: TYPE_NORMAL
- en: The crux of the implementation comes down to the `collectRates` method. This
    is where we implement our own business logic that should calculate the shipping
    price based on the items in the cart. We can use the `$request->getAllItems()`in
    the `collectRates` method to fetch the collection of all the cart items, traverse
    through them, form a final shipping price based on various conditions, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go ahead and jump to the storefront in order to test the checkout.
    We should be able to see our method on the checkout, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom offline shipping methods](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we complete one order, we should further see the shipping method details
    on the order itself. Within the admin area, under **Sales** | **Operations** |
    **Orders**, if we **View** our order in the **Payment & Shipping Method** section,
    we should see the shipping method, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom offline shipping methods](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, in the **Order Totals** section, we should see the shipping amount
    in **Shipping & Handling**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom offline shipping methods](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With this, we conclude our custom offline shipping method module. The full module
    can be found at [https://github.com/ajzele/B05032-Foggyline_Shipbox](https://github.com/ajzele/B05032-Foggyline_Shipbox).
  prefs: []
  type: TYPE_NORMAL
- en: Custom offline payment methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Magento provides several out-of-the-box offline payment methods, such as `Banktransfer`,
    `Cashondelivery`, `Checkmo`, and `Purchaseorder`. You can see them in the `vendor/magento/module-offline-payments/Model`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to payment methods, it is more common to use an online payment
    provider (gateway), such as PayPal or Braintree. Sometimes, project requirements
    may be such that we may need a custom coded payment method. You will need to think
    of programmatic product import and order creation script that might specialize
    in some specifically labeled payment method. Thus, the payment process will be
    controlled by us.
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, knowing how to code our own offline payment method might come
    in handy. It is worth noting that while we can make an offline payment that will
    grab a user's credit card information, it is not really advisable to do so unless
    our infrastructure is PCI-compliant.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and create a small module called `Foggyline_Paybox` that provides
    Magento an extra offline payment method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a module registration file named `app/code/Foggyline/Paybox/registration.php`
    with partial content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create an `app/code/Foggyline/Paybox/etc/module.xml` file with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After this is done, create an `app/code/Foggyline/Paybox/etc/config.xml` file
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the `app/code/Foggyline/Paybox/etc/payment.xml` file with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create an `app/code/Foggyline/Paybox/etc/adminhtml/system.xml` file with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `app/code/Foggyline/Paybox/etc/frontend/di.xml` file with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'After this is done, create an `app/code/Foggyline/Paybox/Model/Paybox.php`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create an `app/code/Foggyline/Paybox/Model/PayboxConfigProvider.php` file
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the entire `vendor/magento/module-offline-payments/view/frontend/layout/checkout_index_index.xml`
    Magento core file into the `app/code/Foggyline/Paybox/view/frontend/layout/checkout_index_index.xml`
    module. Then, edit the module''s `checkout_index_index.xml` file by replacing
    the entire `<item name="offline-payments" xsi:type="array">` element and its children
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create an `app/code/Foggyline/Paybox/view/frontend/web/js/view/payment/offline-payments.js`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'After this is done, create an `app/code/Foggyline/Paybox/view/frontend/web/js/view/payment/method-renderer/paybox.js`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create an `app/code/Foggyline/Paybox/view/frontend/web/template/payment/paybox.html`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: With this, we conclude our custom offline payment method module. The entire
    module can be found at [https://github.com/ajzele/B05032-Foggyline_Paybox](https://github.com/ajzele/B05032-Foggyline_Paybox).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we touched upon some of the most common bits of functionality
    that developers come in contact with. We learned where to look in the admin area
    and how to programmatically manage the entities behind these functionalities.
    Thus, we were effectively able to manually and programmatically create and fetch
    CMS pages, blocks, categories, and products. We also learned how to create product
    and customer import scripts. Finally, we studied how to create our own custom
    product type, simple payment, and shipment module.
  prefs: []
  type: TYPE_NORMAL
- en: The following chapter will guide us through Magento's in-built tests and how
    we can use them to effectively QA an application to keep it healthy.
  prefs: []
  type: TYPE_NORMAL
