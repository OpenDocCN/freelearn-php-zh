- en: Chapter 10. The Major Functional Areas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。主要功能区域
- en: 'The Magento platform comprises various modules that deliver various bits of
    functionality. Developers are often more in touch with one group of functionality
    than others. Examples of some of the most commonly used functionalities include
    those related to CMS blocks and pages, categories, products, customers, imports,
    custom product types, custom payment, and shipping modules. This is not to say
    that other functionalities are less important. In this chapter, we will take a
    quick look at the functionalities in the Magento admin area, PHP code, and API
    calls. The chapter is divided into the following sections:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Magento平台包含各种模块，提供各种功能。开发者通常更熟悉某一组功能而不是其他功能。一些最常用的功能示例包括与CMS块和页面、分类、产品、客户、导入、自定义产品类型、自定义支付和运输模块相关的功能。这并不是说其他功能就不重要。在本章中，我们将快速查看Magento管理区域、PHP代码和API调用中的功能。本章分为以下部分：
- en: CMS management
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMS管理
- en: Catalog management
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录管理
- en: Customer management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户管理
- en: Products and customer import
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品和客户导入
- en: Custom product types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义产品类型
- en: Custom offline shipping methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义离线运输方法
- en: Custom offline payment methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义离线支付方法
- en: The intention is not to go into the details of each functional area. Rather,
    the aim is to show the admin interface and the corresponding programmatic and
    API approach towards basic management.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 目的不是深入了解每个功能区域，而是展示管理界面以及相应的程序性和API方法，以实现基本管理。
- en: CMS management
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMS管理
- en: Content is what helps differentiate one store from another. Quality content
    can boost a store's visibility on search engines, provide informative insight
    to the customers who buy products, and provide credibility and trust. Magento
    provides a solid content management system, which can be used to create rich content
    for a store. We can use it to manage blocks and pages too.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 内容是帮助区分一个商店与另一个商店的因素。优质内容可以提高商店在搜索引擎中的可见性，为购买产品的客户提供信息洞察，并提供信誉和信任。Magento提供了一个强大的内容管理系统，可用于为商店创建丰富内容。我们还可以用它来管理块和页面。
- en: Managing blocks manually
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动管理块
- en: A CMS block is a small modular unit of content that can be positioned almost
    anywhere on a page. They can even be called into another blocks. Blocks support
    HTML and JavaScript as its content. Therefore, they are able to display static
    information such as text, images, and embedded video as well as dynamic information.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个CMS块是内容的一个小型模块化单元，可以在页面的几乎任何位置定位。它们甚至可以被调用到另一个块中。块支持HTML和JavaScript作为其内容。因此，它们能够显示静态信息，如文本、图像和嵌入的视频，以及动态信息。
- en: Blocks can be created via an admin interface, APIs, or code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 块可以通过管理界面、API或代码创建。
- en: 'The following steps outline the block creation process from within an admin
    interface:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了从管理界面内创建块的过程：
- en: Log in to the Magento admin area.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到Magento管理区域。
- en: In the **Content** | **Elements** | **Blocks** menu, click on **Add New Block**.
    This opens a screen that is similar to the one shown in the following screenshot:![Managing
    blocks manually](img/00070.jpeg)
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容** | **元素** | **块**菜单中，点击**添加新块**。这将打开一个类似于以下截图的屏幕：![手动管理块](img/00070.jpeg)
- en: Fill in some values for the required fields (**Block Title**, **Identifier**,
    **Store View**, **Status**, and **Content**) and click on the **Save Block** button.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写所需字段的值（**块标题**、**标识符**、**商店视图**、**状态**和**内容**）并点击**保存块**按钮。
- en: Once the block is saved, you will see the **You saved the block.** success message
    in the browser. CMS blocks are stored in the `cms_block` and `cms_block_store`
    tables in a database.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 保存块后，您将在浏览器中看到**您已保存块**的成功消息。CMS块存储在数据库中的`cms_block`和`cms_block_store`表中。
- en: The **Identifier** value is probably the most interesting aspect here. We can
    use it in a CMS page, another CMS block, or some code to fetch the block that
    we have just created.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**标识符**值可能是这里最有趣的部分。我们可以在CMS页面、另一个CMS块或某些代码中使用它来获取我们刚刚创建的块。'
- en: 'Assuming that we have created a block with the **Identifier** value of `foggyline_hello`,
    we can call it in the CMS page or another block by using the following expression:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经创建了一个具有**标识符**值为`foggyline_hello`的块，我们可以通过以下表达式在CMS页面或另一个块中调用它：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can also pass the actual integer ID value of a block to the preceding expression,
    as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将块的实际整数ID值传递给前面的表达式，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, this approach requires us to know the actual integer ID of a block.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法要求我们知道块的实际整数ID。
- en: The preceding expressions show that blocks are included in a page or another
    block via a widget, which is also known as a frontend app. A widget of the `Magento\Cms\Block\Widget\Block`
    class type is using the `widget/static_block/default.phtml` template file to render
    the actual CMS block.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表达式表明，块通过小部件（也称为前端应用）包含在页面或另一个块中。`Magento\Cms\Block\Widget\Block`类类型的小部件正在使用`widget/static_block/default.phtml`模板文件来渲染实际的CMS块。
- en: Managing blocks via code
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过代码管理块
- en: 'Besides the manual creation of blocks via the admin interface, we can create
    CMS blocks by using code, as shown in the following code snippet:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过管理界面手动创建块之外，我们还可以使用代码创建CMS块，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we used the instance manager to create a new model instance of the `Magento\Cms\Model\Block`
    class. Then, we set some properties through defined methods and finally called
    the `save` method.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了实例管理器来创建`Magento\Cms\Model\Block`类的新模型实例。然后，我们通过定义的方法设置了一些属性，最后调用了`save`方法。
- en: 'We can load and update the existing blocks using a code snippet that is similar
    to the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似于以下代码的代码片段加载和更新现有块：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The block's `load` method accepts either an integer value of a block ID or a
    string value of a block identifier.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 块的`load`方法接受一个整数块ID或一个字符串块标识符。
- en: 'Finally, we can manage the creation and updating of blocks through the available
    APIs method. The following code snippet shows how a CMS block is created via a
    console cURL REST API call:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过可用的API方法来管理块创建和更新的操作。以下代码片段显示了如何通过控制台cURL REST API调用创建CMS块：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The bearer string is just a login token that we obtain by first running the
    authentication API call, as described in the previous chapter. Once we have the
    authentication token, we can make a `V1/cmsBlock` `POST` request, passing a JSON
    object as data.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 携带者字符串只是一个登录令牌，我们通过首先运行前面章节中描述的认证API调用来获取。一旦我们有了认证令牌，我们就可以发送一个`V1/cmsBlock`
    `POST`请求，传递一个JSON对象作为数据。
- en: Managing blocks via API
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过API管理块
- en: 'We can get the newly created CMS block through an API by executing a snippet
    of code that looks like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行类似于以下代码的代码片段通过API获取新创建的CMS块：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can update the existing CMS block by using an API and executing a snippet
    of code that is similar to this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用API并执行类似于以下代码的代码片段来更新现有的CMS块：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we used the HTTP PUT method and passed the integer `4` as a part of the
    `V1/cmsBlock/4` URL. The number 4 represents the ID value of the block in the
    database.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了HTTP PUT方法，并将整数`4`作为`V1/cmsBlock/4` URL的一部分传递。数字4代表数据库中块的ID值。
- en: Managing pages manually
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动管理页面
- en: CMS pages are robust content units unlike CMS blocks, which are simply embedded
    into certain pages. The CMS page can have its own URL. Examples of CMS pages are
    pages such as **404 Not Found**, **Home page**, **Enable Cookies**, and **Privacy
    and Cookie Policy**. The idea, when it comes to dealing with CMS pages, is that
    we can control the content area of a page without affecting site-wide elements
    such as the header, footer, or sidebars. Magento does not really come with many
    out-of-the-box CMS pages other than the ones that were listed previously.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: CMS页面是健壮的内容单元，与简单地嵌入到某些页面中的CMS块不同。CMS页面可以有自己的URL。CMS页面的例子包括**404未找到**、**主页**、**启用Cookies**和**隐私和Cookies政策**。在处理CMS页面时，我们的想法是我们可以控制页面内容区域，而不会影响网站范围的元素，如页眉、页脚或侧边栏。除了前面列出的之外，Magento并没有提供很多开箱即用的CMS页面。
- en: Like blocks, pages can also be created via the admin interface, APIs, or code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与块一样，页面也可以通过管理界面、API或代码创建。
- en: 'The following steps outline the page creation process from within the admin
    interface:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了从管理界面内部创建页面的过程：
- en: Log in to Magento admin area.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到Magento管理区域。
- en: In the **Content** | **Elements** | **Pages menu**, click on **Add New Page**.
    This opens a screen that is similar the one shown in the following screenshot:![Managing
    pages manually](img/00071.jpeg)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容** | **元素** | **页面菜单**中，点击**添加新页面**。这将打开一个与以下截图类似的屏幕：![手动管理页面](img/00071.jpeg)
- en: Fill in some values for the required fields (**Page Title**, **Store View**,
    **Status**, and **Content**) and click on the **Save** Block button.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写所需字段的值（**页面标题**、**商店视图**、**状态**和**内容**）并点击**保存块**按钮。
- en: Once the page is saved, you will see the **You saved this page.** success message
    in the browser. CMS pages are stored in the `cms_page` and `cms_page_store` tables
    in the database.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 页面保存后，你将在浏览器中看到**你已保存此页面**的成功消息。CMS 页面存储在数据库中的 `cms_page` 和 `cms_page_store`
    表中。
- en: Assuming that we have created a page with **Page Title** value **Info**, we
    can access this page in a browser via a URL such as `http://magento2.ce/info`.
    Though we could have to specify the **URL Key** value in the **New Page** edit
    screen, Magento automatically assigns **URL Key** that matches **Page Title**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经创建了一个**页面标题**值为**信息**的页面，我们可以通过类似 `http://magento2.ce/info` 的 URL 在浏览器中访问此页面。尽管我们可能需要在**新页面**编辑屏幕中指定**URL
    键**值，但 Magento 会自动分配与**页面标题**匹配的**URL 键**。
- en: Managing pages via code
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过代码管理页面
- en: 'Besides the manual creation through the admin interface, we can create CMS
    pages via code, as shown in the following code snippet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过管理界面手动创建之外，我们还可以通过以下代码片段创建 CMS 页面：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we used the instance manager to create a new model instance of the `Magento\Cms\Model\Page`
    class. Then, we set some properties through the defined methods and finally called
    the `save` method. The **URL Key** that we set through the admin interface is
    actually an identifier that we set via the `setIdentifier` method call.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了实例管理器来创建 `Magento\Cms\Model\Page` 类的新模型实例。然后，我们通过定义的方法设置了一些属性，并最终调用了
    `save` 方法。通过管理界面设置的**URL 键**实际上是通过 `setIdentifier` 方法调用设置的标识符。
- en: Managing pages via API
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 API 管理页面
- en: 'We can load and update the existing pages by using a code snippet that is similar
    to the following one:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似于以下代码段的代码片段来加载和更新现有的页面：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The page model `load` method accepts either an integer ID value of a page identifier
    (**URL Key**).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 页面模型 `load` 方法接受页面标识符（**URL 键**）的整数 ID 值。
- en: 'Finally, we can manage the creation and updating of pages through the available
    APIs method. The following code snippet shows how a CMS page is created via a
    console cURL REST API call:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过可用的 API 方法来管理页面的创建和更新。以下代码片段显示了如何通过控制台 cURL REST API 调用来创建 CMS 页面：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can update the existing CMS page through an API by executing a snippet of
    code that is similar to the following one:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行类似于以下代码段的代码来通过 API 更新现有的 CMS 页面：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we used the HTTP PUT method, passing the integer `7` as a part of the
    `V1/cmsPage/7` URL. The number 7 represents the ID value of the page in the database.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 HTTP PUT 方法，将整数 `7` 作为 `V1/cmsPage/7` URL 的一部分传递。数字 7 代表数据库中页面的 ID
    值。
- en: Catalog management
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录管理
- en: The `Magento_Catalog` module is one of the backbones of the entire Magento platform.
    It provides robust support for the inventory management of various product types.
    This module is what manages products, categories and their attributes, the display
    on the frontend, and many more things.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magento_Catalog` 模块是整个 Magento 平台的骨架之一。它为各种产品类型的库存管理提供强大的支持。该模块负责管理产品、类别及其属性、前端显示以及许多其他事情。'
- en: Managing categories manually
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动管理类别
- en: We can access the catalog functionality within the Magento admin area by navigating
    to **Products** | **Inventory** | **Catalog** or **Products** | **Inventory**
    | **Category**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过导航到**产品** | **库存** | **目录**或**产品** | **库存** | **类别**来访问 Magento 管理区域内的目录功能。
- en: 'If we start with a blank Magento installation, we will probably start with
    categories as one of the first entities to be created. We can manually create
    categories by performing the following steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从空白的 Magento 安装开始，我们可能会首先创建类别作为要创建的第一个实体之一。我们可以通过以下步骤手动创建类别：
- en: Log in to the Magento admin area.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 Magento 管理区域。
- en: Go to the **Products** | **Inventory** | **Category** menu. This opens a screen
    that is similar to the one shown in the following screenshot:![Managing categories
    manually](img/00072.jpeg)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**产品** | **库存** | **类别**菜单。这将打开一个类似于以下截图的屏幕：![手动管理类别](img/00072.jpeg)
- en: On the left-hand side of the screen, click on **Default Category**. Then, when
    the page reloads, click on the **Add Subcategory** button.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕的左侧点击**默认类别**。然后，当页面重新加载时，点击**添加子类别**按钮。
- en: Though it may seem that nothing has happened, as the screen content does not
    change, we should now fill in the required options in the **General Information**
    tab, setting **Name** to some string value and **Is Active** to Yes.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然看起来好像没有发生任何变化，因为屏幕内容没有改变，但现在我们应该在**一般信息**选项卡中填写所需的选项，将**名称**设置为某个字符串值，并将**是否激活**设置为是。
- en: Finally, click on the **Save Category** button.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击**保存类别**按钮。
- en: 'The new category should now be created. To the left screen area, if you click
    on the name of the newly created category, you will see its ID value above the
    **General Information** tab, as shown in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 新类别现在应该已创建。在左侧屏幕区域，如果您点击新创建的类别的名称，您将在**一般信息**选项卡上方看到其ID值，如图所示：
- en: '![Managing categories manually](img/00073.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![手动管理类别](img/00073.jpeg)'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Knowing the category ID enables you to directly test it on a storefront simply
    by opening a URL such as `http://magento2.ce/index.php/catalog/category/view/id/3`
    in the browser, where the number `3` is the ID of the category. You will see a
    loaded category page that probably shows the **We can't find products matching
    the selection.** message, which is good, as we haven't assigned products to a
    category.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 知道类别ID后，您可以直接在浏览器中打开一个类似于`http://magento2.ce/index.php/catalog/category/view/id/3`的URL来测试它，其中数字`3`是类别的ID。您将看到一个加载的类别页面，可能显示**找不到与选择匹配的产品**的消息，这是好的，因为我们还没有将产品分配给类别。
- en: Though we will not go into its details, it is worth noting that we have simply
    scratched the surface here, as categories enable us to provide many additional
    options using the **Display Settings**, **Custom Design** tabs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会深入探讨其细节，但值得注意的是，我们在这里只是触及了表面，因为类别使我们能够通过**显示设置**、**自定义设计**选项卡提供许多额外的选项。
- en: 'Given that categories are EAV entities, their data is stored across several
    tables in the database, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类别是EAV实体，它们的数据存储在数据库的多个表中，如下所示：
- en: '`catalog_category_entity`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_category_entity`'
- en: '`catalog_category_entity_datetime`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_category_entity_datetime`'
- en: '`catalog_category_entity_decimal`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_category_entity_decimal`'
- en: '`catalog_category_entity_int`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_category_entity_int`'
- en: '`catalog_category_entity_text`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_category_entity_text`'
- en: '`catalog_category_entity_varchar`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_category_entity_varchar`'
- en: 'There are a few additional tables that link categories to products:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个额外的表将类别链接到产品：
- en: '`catalog_category_product`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_category_product`'
- en: '`catalog_category_product_index`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_category_product_index`'
- en: '`catalog_category_product_index_tmp`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_category_product_index_tmp`'
- en: '`catalog_url_rewrite_product_category`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_url_rewrite_product_category`'
- en: Managing categories via code
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过代码管理类别
- en: 'Besides the manual creation through the admin interface, we can create categories
    via code, as shown in the following code snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过管理界面手动创建之外，我们还可以通过以下代码片段所示的方式通过代码创建类别：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What is specific here is that when creating a new category, we first created
    a `$parentCategory` instance, which represents the root category object. We used
    the `Category` model `TREE_ROOT_ID` constant as the ID value of a parent category
    ID. Then, we created an instance of the category, set its `path`, `parent_id`,
    `name`, and `is_active` value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里特别的是，在创建新类别时，我们首先创建了一个`$parentCategory`实例，它代表根类别对象。我们使用`Category`模型的`TREE_ROOT_ID`常量作为父类别ID的ID值。然后，我们创建了一个类别实例，设置了其`path`、`parent_id`、`name`和`is_active`值。
- en: Managing categories via API
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过API管理类别
- en: 'We can further manage category creation through the available APIs method.
    The following code snippet shows category creation via the console cURL REST API
    call:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过可用的API方法进一步管理类别创建。以下代码片段显示了通过控制台cURL REST API调用创建类别：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The bearer string is just a login token that we obtain by first running the
    authentication API call, as described in the previous chapter. Once we have the
    authentication token, we can make a `/V1/categories POST` request, passing a JSON
    object as data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 承载字符串只是一个登录令牌，我们通过首先运行上一章中描述的认证API调用来获取它。一旦我们有了认证令牌，我们就可以发出一个`/V1/categories
    POST`请求，传递一个JSON对象作为数据。
- en: 'We can get the newly created category as a JSON object through an API by executing
    a snippet of code that looks like the following one:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下类似代码片段的代码片段，通过API获取新创建的类别作为一个JSON对象：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Managing products manually
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动管理产品
- en: 'Now, let''s take a look at how to create a new product. We can manually create
    products by performing the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何创建一个新的产品。我们可以通过以下步骤手动创建产品：
- en: Log in to the Magento admin area.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到Magento管理区域。
- en: In the **Products** | **Inventory** | **Catalog** menu, click on the **Add Product**
    button. This opens a screen similar to the one shown in the following screenshot:![Managing
    products manually](img/00074.jpeg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**产品** | **库存** | **目录**菜单中，点击**添加产品**按钮。这将打开一个类似于以下截图的屏幕：![手动管理产品](img/00074.jpeg)
- en: Now, fill in the required options on the **Product Details** tab.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**产品详情**选项卡中填写所需的选项。
- en: Finally, click on the **Save** button.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击**保存**按钮。
- en: If it is successfully saved, the page reloads and shows the **You saved the
    product.** message.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果保存成功，页面将重新加载并显示**您已保存产品**的消息。
- en: Like categories, we have barely scratched the surface of products here. Looking
    at the other available tabs, there are a large number of additional options that
    can be assigned to a product. Simply assigning the required options should be
    enough for us to see the product on the store's frontend on a URL such as `http://magento2.ce/index.php/catalog/product/view/id/4`,
    where the number `4` is the ID value of a product.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与类别一样，我们在这里只是触及了产品的表面。查看其他可用的选项卡，有许多其他选项可以分配给产品。只需分配所需的选项就足以让我们在商店的前端URL（如`http://magento2.ce/index.php/catalog/product/view/id/4`）上看到产品，其中数字`4`是产品的ID值。
- en: 'Products are also EAV entities, whose data is stored across several tables
    in a database, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 产品也是EAV实体，其数据存储在数据库的多个表中，如下所示：
- en: '`catalog_product_entity`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity`'
- en: '`catalog_product_entity_datetime`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_datetime`'
- en: '`catalog_product_entity_decimal`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_decimal`'
- en: '`catalog_product_entity_gallery`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_gallery`'
- en: '`catalog_product_entity_group_price`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_group_price`'
- en: '`catalog_product_entity_int`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_int`'
- en: '`catalog_product_entity_media_gallery`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_media_gallery`'
- en: '`catalog_product_entity_media_gallery_value`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_media_gallery_value`'
- en: '`catalog_product_entity_text`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_text`'
- en: '`catalog_product_entity_tier_price`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_tier_price`'
- en: '`catalog_product_entity_varchar`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catalog_product_entity_varchar`'
- en: There are also a large number of other table referencing products, such as `catalog_product_bundle_selection`,
    but these are mostly used to link bits of functionalities.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 还有大量其他引用产品的表，例如`catalog_product_bundle_selection`，但这些主要用于链接功能片段。
- en: Managing products via code
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过代码管理产品
- en: 'Besides the manual creation through the admin interface, we can create products
    via code, as shown in the following code snippet:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过管理界面手动创建外，我们还可以通过代码创建产品，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Managing products via API
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过API管理产品
- en: 'The following example uses the REST API to create a new simple product:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用REST API创建一个新的简单产品：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Bearer` token should have been previously obtained by using an authentication
    request. The response should be a JSON object that contains all the exposed product
    data.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 应该通过使用身份验证请求预先获取`Bearer`令牌。响应应该是一个包含所有公开产品数据的JSON对象。
- en: 'We can get the existing product as information through an API that executes
    a snippet of code, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下代码片段的API获取现有产品信息：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `product_dynamic_125` part in the preceding URL stands for this specific
    product SKU value. The response is a JSON object that contains all the exposed
    product data.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的URL中，`product_dynamic_125`部分代表这个特定的产品SKU值。响应是一个包含所有公开产品数据的JSON对象。
- en: The entire list of the available catalog APIs can be seen in the `vendor/magento/module-catalog/etc/webapi.xml`
    file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的整个目录API列表可以在`vendor/magento/module-catalog/etc/webapi.xml`文件中查看。
- en: Customer management
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户管理
- en: Managing customers is another important aspect of the Magento platform. Most
    of the time, customer creation is something that is left for a new customer to
    do. A new customer who visits a store initiates the registration process and finishes
    up with a customer account being created. Once registered, customers can then
    further edit their account details on the storefront under the **My Account**
    page, which is usually available on a link such as `http://magento2.ce/index.php/customer/account/index/`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 管理客户是Magento平台的重要方面之一。大多数情况下，客户创建是由新客户自己完成的。访问商店的新客户启动注册过程，并最终创建客户账户。一旦注册，客户就可以在**我的账户**页面上进一步编辑他们的账户详情，该页面通常在类似`http://magento2.ce/index.php/customer/account/index/`的链接上可用。
- en: As a part of this section, we are interested in the possibility of managing
    customer accounts by using the admin area, code, and API.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的一部分，我们感兴趣的是通过使用管理区域、代码和API来管理客户账户的可能性。
- en: Managing customers manually
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动管理客户
- en: 'The following steps outline the customer account creation process from within
    the admin interface:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了从管理界面内部创建客户账户的过程：
- en: Log in to Magento admin area.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到Magento管理区域。
- en: In the **Customers** | **All Customers** menu, click on the **Add New Customer**
    button. This opens a screen that looks similar to the one shown in the following
    screenshot:![Managing customers manually](img/00075.jpeg)
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**客户** | **所有客户**菜单中，点击**添加新客户**按钮。这将打开一个类似于以下截图的屏幕：![手动管理客户](img/00075.jpeg)
- en: Fill in some values for the required fields (**Associate to Website**, **Group**,
    **First Name**, **Last Name**, and **Email**) and click on the **Save Customer**
    button.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写所需字段的值（**关联到网站**、**组**、**名**、**姓**和**电子邮件**）并点击**保存客户**按钮。
- en: Once the customer is saved, you will see the **You saved the customer.** success
    message in the browser.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户被保存，你将在浏览器中看到**您已保存客户**的成功消息。
- en: The **Associate to Website** value is probably the most important value for
    cases like this one, where customer accounts are being indirectly created by a
    user who's not a customer.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类情况，**关联到网站**值可能是最重要的值，在这种情况下，客户账户是由非客户用户间接创建的。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since Magento supports the setting up of multiple websites, customer accounts
    can be set to either the **Global** or **Per Website** value, depending on the
    **Stores** | **Settings** | **Configuration** | **Customers** | **Customer Configuration**
    | **Account Sharing Option** | **Share Customer Accounts** option. Thus, if the
    **Share Customer Accounts** option has been set to **Per Website**, it is of the
    utmost important to point the **Associate to Website** value to the proper website.
    Otherwise, a customer account will be created but the customer won't be able to
    log in to it on the storefront.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Magento支持设置多个网站，客户账户可以根据**商店** | **设置** | **配置** | **客户** | **客户配置** | **账户共享选项**
    | **共享客户账户**选项设置为**全局**或**按网站**。因此，如果**共享客户账户**选项已设置为**按网站**，将**关联到网站**值指向正确的网站至关重要。否则，将创建客户账户，但客户将无法在店面登录。
- en: The `Magento_Customer` module uses the EAV structure to store customer data.
    Thus, there is no single table that stores customer information. Rather, multiple
    tables exist, depending on the customer property and its data type.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magento_Customer`模块使用EAV结构来存储客户数据。因此，没有单个表存储客户信息。相反，根据客户属性及其数据类型存在多个表。'
- en: 'The following list comprises tables that store customer entity:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含存储客户实体的表：
- en: '`customer_entity`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer_entity`'
- en: '`customer_entity_datetime`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer_entity_datetime`'
- en: '`customer_entity_decimal`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer_entity_decimal`'
- en: '`customer_entity_int`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer_entity_int`'
- en: '`customer_entity_text`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer_entity_text`'
- en: '`customer_entity_varchar`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer_entity_varchar`'
- en: 'Customer accounts will not really be complete without a customer address. The
    address can be added via the **Addresses** tab under the customer edit screen
    in the admin area, as shown in the following screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 没有客户地址的客户账户将不会真正完整。地址可以通过在管理区域客户编辑屏幕下的**地址**选项卡添加，如下面的截图所示：
- en: '![Managing customers manually](img/00076.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![手动管理客户](img/00076.jpeg)'
- en: Note that Magento enables us to set one of the addresses as **Default Shipping
    Address** and **Default Billing Address**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Magento允许我们设置其中一个地址为**默认发货地址**和**默认账单地址**。
- en: Like the customer entity, the customer address entity also uses the EAV structure
    to store its data.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与客户实体类似，客户地址实体也使用EAV结构来存储其数据。
- en: 'The following list comprises tables that store the customer address entity:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含存储客户地址实体的表：
- en: '`customer_address_entity`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer_address_entity`'
- en: '`customer_address_entity_datetime`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer_address_entity_datetime`'
- en: '`customer_address_entity_decimal`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer_address_entity_decimal`'
- en: '`customer_address_entity_int`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer_address_entity_int`'
- en: '`customer_address_entity_text`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer_address_entity_text`'
- en: '`customer_address_entity_varchar`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer_address_entity_varchar`'
- en: Managing customers via code
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过代码管理客户
- en: 'Besides the manual creation via the admin interface, we can create customers
    via code, as shown in the following code snippet:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过管理界面手动创建之外，我们还可以通过以下代码片段创建客户：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we are using the instance manager to create a new model instance of the
    `Magento\Customer\Model\Customer` class. We can then set some properties through
    the defined methods and finally call the `save` method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用实例管理器来创建`Magento\Customer\Model\Customer`类的新模型实例。然后我们可以通过定义的方法设置一些属性，并最终调用`save`方法。
- en: 'We can load and update an existing customer by using a code snippet that is
    similar to the following one:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似于以下代码片段的代码片段来加载和更新现有客户：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can use either the `load` or `loadByEmail` method call. The `load` method
    accepts the integer ID value of the existing customer entity, while `loadByEmail`
    accepts a string e-mail address. It is worth noting that `setWebsiteId` has to
    be called prior to any of the load methods. Otherwise, we will get an error message
    that says **A customer website ID must be specified when using the website scope**.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`load`或`loadByEmail`方法调用。`load`方法接受现有客户实体的整数ID值，而`loadByEmail`接受一个字符串电子邮件地址。值得注意的是，必须在任何加载方法之前调用`setWebsiteId`。否则，我们将收到一个错误消息，指出**在使用网站范围时必须指定客户网站ID**。
- en: Managing customers via an API
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过API管理客户
- en: 'Finally, we can manage the creation and updating of customer information using
    the available API method. The following code snippet shows how to create a customer
    via a console cURL REST API call:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用可用的API方法来管理客户信息的创建和更新。以下代码片段显示了如何通过控制台cURL REST API调用创建客户：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once we have the authentication token, we can make a `V1/customers` `POST` request,
    passing a JSON object as data.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了认证令牌，我们就可以发送一个`V1/customers` `POST`请求，传递一个JSON对象作为数据。
- en: 'We can get the newly created customer via an API by executing a snippet of
    code that is similar to the following one:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行一个类似于以下代码片段的代码，通过API获取新创建的客户：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can update an existing customer through an API by executing a snippet of
    code that is similar to the following one:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行类似于以下代码片段的代码片段通过API更新现有客户：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we used the HTTP PUT method, passing the integer `24` as a part of the
    `V1/customers/24 and as part of the body` URL. The number 24 represents the ID
    value of a customer in the database. Also, note the `password_hash` value; without
    it, the update will fail.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了HTTP PUT方法，将整数`24`作为`V1/customers/24`的一部分以及作为URL的主体部分。数字24代表数据库中客户的ID值。此外，请注意`password_hash`值；如果没有它，更新将失败。
- en: Managing customer address via code
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过代码管理客户地址
- en: 'Similar to customers, we can create a customer address using code, as shown
    in the following code snippet:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 与客户类似，我们可以使用代码创建客户地址，如下面的代码片段所示：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we used the instance manager to create a new model instance of the `Magento\Customer\Model\Address`
    class. We then set some properties through the defined methods and finally called
    the `save` method.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了实例管理器创建`Magento\Customer\Model\Address`类的新模型实例。然后，我们通过定义的方法设置一些属性，并最终调用`save`方法。
- en: 'We can load and update the existing customer address by using a code snippet
    that is similar to the following one:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过类似于以下代码片段的代码片段加载和更新现有的客户地址：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we used the `load` method to load an existing address by its ID value.
    Then, we called the `setCity` method passing it the updated string. After the
    `save` method is executed, the address should reflect the change.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`load`方法通过其ID值加载现有的地址。然后，我们调用`setCity`方法并传递更新的字符串。在执行`save`方法后，地址应该反映这一变化。
- en: Managing customers address via an API
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过API管理客户地址
- en: 'Surprisingly, a customer address cannot be created or updated directly via
    an API call, as there is no `POST` or `PUT REST` API defined. However, we can
    still get the existing customer address information by using an API, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，客户地址不能通过API调用直接创建或更新，因为没有定义`POST`或`PUT REST` API。然而，我们仍然可以通过以下方式使用API获取现有的客户地址信息：
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The entire list of available customer APIs can be seen in the `vendor/magento/module-customer/etc/webapi.xml`
    file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的所有客户API列表可以在`vendor/magento/module-customer/etc/webapi.xml`文件中看到。
- en: Products and customers import
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品和客户导入
- en: 'Magento provides an out-of-the-box mass import and export functionality via
    the following modules:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Magento通过以下模块提供开箱即用的批量导入和导出功能：
- en: '`AdvancedPricingImportExport`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AdvancedPricingImportExport`'
- en: '`BundleImportExport`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BundleImportExport`'
- en: '`CatalogImportExport`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CatalogImportExport`'
- en: '`ConfigurableImportExport`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConfigurableImportExport`'
- en: '`CustomerImportExport`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomerImportExport`'
- en: '`GroupedImportExport`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GroupedImportExport`'
- en: '`ImportExport`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImportExport`'
- en: '`TaxImportExport`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TaxImportExport`'
- en: The heart of the import functionality actually lies in the `ImportExport` module,
    while other modules provide individual import and export entities through the
    `vendor/magento/module-{partialModuleName}-import-export/etc/import.xml` and `vendor/magento/module-{partialModuleName}-import-export/etc/export.xml`
    files.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 导入功能的核心实际上在于`ImportExport`模块，而其他模块通过`vendor/magento/module-{partialModuleName}-import-export/etc/import.xml`和`vendor/magento/module-{partialModuleName}-import-export/etc/export.xml`文件提供单独的导入和导出实体。
- en: These functionalities can be accessed from the Magento admin area from the **System**
    | **Data Transfer** menu. They enable us to export and import several entity types,
    such as **Advanced Pricing**, **Products**, **Customers Main File**, and **Customer
    Addresses**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能可以从Magento管理区域中的**系统** | **数据传输**菜单访问。它们使我们能够导出和导入多个实体类型，例如**高级定价**、**产品**、**主客户文件**和**客户地址**。
- en: 'The following screenshot shows the **Entity Type** options for the **Import
    Settings** screen:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了**导入设置**屏幕的**实体类型**选项：
- en: '![Products and customers import](img/00077.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![产品和客户导入](img/00077.jpeg)'
- en: 'Next to **Import Settings**, when we select **Entity Type** for import, the
    **Import Behavior** section appears, as shown in the following screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在**导入设置**旁边，当我们为导入选择**实体类型**时，会出现**导入行为**部分，如下面的截图所示：
- en: '![Products and customers import](img/00078.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![产品和客户导入](img/00078.jpeg)'
- en: Most entity types have similar options for **Import Behavior**. Most of the
    time, we will be interested in the **Add/Update** behavior.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数实体类型都有类似的**导入行为**选项。大多数时候，我们将对**添加/更新**行为感兴趣。
- en: Since importing is a bit more complicated process than exporting, we will focus
    on importing and the CSV file format. More specifically, our focus is on **Products**,
    **Customers Main File**, and **Customer Addresses** imports.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于导入过程比导出过程复杂一些，我们将重点关注导入和CSV文件格式。更具体地说，我们的重点是**产品**、**主客户文件**和**客户地址**的导入。
- en: 'When working with a clean Magento installation, the following columns are required
    during the product import in order to make the product visible on the storefront
    afterwards:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当与干净的Magento安装一起工作时，以下列在产品导入期间是必需的，以便在之后使产品在店面可见：
- en: '`sku` (for example, "test-sku"): This can have almost any value as long as
    it is unique across Magento.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sku`（例如，“test-sku”）：这可以具有几乎任何值，只要它在Magento中是唯一的。'
- en: '`attribute_set_code` (for example, "Default"): This can have any of the values
    found in a database when the `SELECT DISTINCT attribute_set_name FROM eav_attribute_set;`
    query is executed.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attribute_set_code`（例如，“默认”）：这可以具有在执行`SELECT DISTINCT attribute_set_name FROM
    eav_attribute_set;`查询时在数据库中找到的任何值。'
- en: '`product_type` (for example, "simple"): This can have the values of `simple`,
    `configurable`, `grouped`, `virtual`, `bundle`, or `downloadable`. Additionally,
    if we create or install a third-party module that adds a new product type, we
    can use that one as well.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product_type`（例如，“简单”）：这可以具有`simple`、`configurable`、`grouped`、`virtual`、`bundle`或`downloadable`的值。此外，如果我们创建或安装了一个添加新产品类型的第三方模块，我们也可以使用该模块。'
- en: '`categories` (for example, "Root/Shoes"): Create a full category path using
    the "Root category name/Child category name/Child child category name" syntax.
    If there are multiple categories, then a pipe ("|") is used to separate them.
    An example of this is "Root category name/Child category name/Child child category
    name| Root category name/Child_2 category name".'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`categories`（例如，“根/鞋子”）：使用“根类别名称/子类别名称/子子类别名称”语法创建完整的类别路径。如果有多个类别，则使用竖线（“|”）分隔它们。例如，“根类别名称/子类别名称/子子类别名称|
    根类别名称/子_2类别名称”。'
- en: '`product_websites` (for example, "base"): This can have the values found in
    a database when the `SELECT DISTINCT code FROM store_website;` query is executed.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product_websites`（例如，“基础”）：这可以具有在执行`SELECT DISTINCT code FROM store_website;`查询时在数据库中找到的值。'
- en: '`name` (for example, "Test"): This can have almost any value.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`（例如，“测试”）：这可以具有几乎任何值。'
- en: '`product_online` (for example, "1"): This can be either `1` for `visible` or
    `0` for `not visible`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product_online`（例如，“1”）：这可以是`1`表示“可见”或`0`表示“不可见”。'
- en: '`visibility` (for example, "Catalog, Search"): This can have the values of
    "Not Visible Individually", "Catalog", "Search", or "Catalog, Search".'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visibility`（例如，“目录，搜索”）：这可以具有“单独不可见”、“目录”、“搜索”或“目录，搜索”的值。'
- en: '`price` (for example, "9.99"): This can be an integer or a decimal value.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`price`（例如，“9.99”）：这可以是一个整数或小数值。'
- en: '`qty` (for example, "100"): This can be an integer or a decimal value.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qty`（例如，“100”）：这可以是一个整数或小数值。'
- en: 'Though the products will get imported just with the preceding list that comprises
    a set of columns, we usually would like to assign additional information to them,
    such as descriptions and images. We can do so with the help of the following columns:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然产品将仅通过包含一组列的前列列表导入，但我们通常希望为它们分配额外的信息，例如描述和图片。我们可以通过以下列来实现：
- en: '`description` (for example, "The description"): This can have any string value.
    HTML and JavaScript are supported.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short_description` (for example, "The short description"): This can have any
    string value. HTML and JavaScript are supported.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`base_image` (for example, `butterfly.jpg`): This is the final import image
    name.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`small_image` (for example, `galaxy.jpg`)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thumbnail_image` (for example, `serenity.jpg`)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding the importing of images, we only need to provide the final image name
    as long as the **Images File Directory** path is set during the import. We can
    use a relative path for the Magento installation, such as `var/export`, `var/import`,
    `var/export/some/dir`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Once the import is finished, it is suggested to run the `php bin/magento indexer:reindex`
    command via the console. Otherwise, the products won't be visible on the storefront
    until the indexer is run.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Once the reindexing is done, we can try opening the storefront URL, which looks
    like `http://magento2.ce/index.php/catalog/product/view/id/1`. The number `1`
    in this case is a newly imported product ID.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with a clean Magento installation, the following columns are required
    during a customer''s main file import in order for our customer to be able to
    successfully log in to the storefront afterwards:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '`email` (for example, `<[john.doe@fake.mail](mailto:john.doe@fake.mail)>`):
    an e-mail address as a string value'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_website` (for example, base): This can have any of the values found in the
    database when the `SELECT DISTINCT code FROM store_website;` query is executed'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firstname` (for example, John): a string value'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastname` (for example, Doe): a string value'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`group_id` (for example, 1): This can have any of the values found in the database
    when the `SELECT customer_group_id code FROM customer_group WHERE customer_group_id
    != 0;` query is executed'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Though a customer will be able to log in to the storefront with just the previously
    listed set of columns, we usually would like to assign other relevant pieces of
    information. We can do so with the help of the following columns:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '`gender` (for example, Male): This can be either Male or Female'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`taxvat` (for example, HR33311122299): any valid VAT number, though an import
    will accept even the invalid ones'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dob` (for example, 1983-01-16): date of birth'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prefix` (for example, Mr): any string value'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`middlename` (for example, the dev guy): any string value'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`suffix` (for example, engineer): any string value'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password` (for example, 123abc): any string value that has a minimum length
    of 6 characters, as defined via `\Magento\CustomerImportExport\Model\Import\Customer::MIN_PASSWORD_LENGTH`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to pay special attention to the `password` column. This is a clear text
    password. Therefore, we need to be careful not to distribute a CSV file in a nonsecure
    manner. Ideally, we can provide the `password_hash` column instead of `password`.
    However, entries under the `password_hash` column will need to be hashed via the
    same algorithm as the one that was called within the `hashPassword` method of
    the `Magento\Customer\Model\Customer` class. This further calls the `getHash`
    method on an instance of the `Magento\Framework\Encryption\Encryptor` class, which
    finally resolves to the `md5` or `sha256` algorithm.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with a clean Magento installation, the following columns are required
    during the customer address import in order for our customers to be able to successfully
    use the addresses on the storefront afterwards:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '`_website` (for example, base): This can have any of the values found in the
    database when the `SELECT DISTINCT code FROM store_website;` query is executed'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_email` (for example, `<[john@change.me](mailto:john@change.me)>`): an e-mail
    address as a string value'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_entity_id`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firstname` (for example, John): any string value'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastname` (for example, Doe): any string value'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`street` (for example, Ashton Lane): any string value'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`city` (for example, Austin): any string value'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`telephone` (for example, 00 385 91 111 000): any string value'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`country_id` (for example, GB): the country code in the ISO-2 format'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postcode` (for example, TX 78753): any string value'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Though a customer will be able to use the addresses on the storefront with
    just a listed set of columns, we usually would like to assign other relevant pieces
    of information. We can do so with the help of the following columns:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '`region` (for example, California): This can be blank, a free form string,
    or a specific string that matches any of the values found in the database when
    the `SELECT DISTINCT default_name FROM directory_country_region;` query is executed.
    On running `SELECT DISTINCT country_id FROM directory_country_region;`, 13 different
    country codes that have entries within the `directory_country_region` table are
    shown—`AT`, `BR`, `CA`, `CH`, `DE`, `EE`, `ES`, `FI`, `FR`, `LT`, `LV`, `RO`,
    `US`. This means that countries with that code need to have a proper region name
    assigned.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`company` (for example, Foggyline): This can be any string value.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fax` (for example, 00 385 91 111 000): This can be any string value.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`middlename` (for example, the developer): This can be any string value.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prefix` (for example, Mr): This can be any string value.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`suffix` (for example, engineer): This can be any string value.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vat_id` (for example, HR33311122299): This can be any valid VAT number, though
    import will accept even the non-valid ones.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_address_default_billing_` (for example, "1"): This can be either "1" as yes
    or "0" as no, to flag the address as being the default billing address.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_address_default_shipping_` (for example, "1"): This can be either "1" as
    yes or "0" as no, to flag the address as being default shipping address.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While CSV imports are a great and relatively fast way to mass import products,
    customers, and their addresses, there are some limitations to it. CSV is simply
    flat data. We cannot apply any logic to it. Depending on how clean and valid the
    data is, the CSV import might do just fine. Otherwise, we might want to opt for
    APIs. We need to keep in mind that a CSV import is much faster than the API creation
    of products and customers because CSV imports work directly by bulk inserting
    on the database, while APIs instantiate full models, respect the event observers,
    and so on.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The custom product types
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Magento provides the following six out-of-the-box product types:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Simple products
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurable products
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouped products
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual products
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundle products
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloadable products
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each product has its specifics. For example, the virtual and downloadable products
    do not have the `weight` attribute. Therefore, they are excluded from the standard
    shipping calculations. With custom coding around built-in product types, by using
    observers and plugins we can achieve almost any functionality. However, this is
    not enough sometimes or there is no solution to the requirement. In cases such
    as these, we might need to create our own product type that will match the project
    requirements in a more streamlined way.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a miniature module called `Foggyline_DailyDeal` that will add a
    new product type to Magento.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a module registration file named `app/code/Foggyline/DailyDeal/registration.php`
    that has the following partial content:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, create an `app/code/Foggyline/DailyDeal/etc/module.xml` with the following
    content:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, create an `app/code/Foggyline/DailyDeal/etc/product_types.xml` file that
    has the following content:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `customAttributes` element is parsed by `vendor/magento/module-catalog/Model/ProductTypes/Config.php`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `app/code/Foggyline/DailyDeal/Model/Product/Type/DailyDeal.php` file
    with partial content, as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, create an `app/code/Foggyline/DailyDeal/Model/Product/Price.php` file
    with partial content, as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After this is done, create an `app/code/Foggyline/DailyDeal/Model/ResourceModel/Indexer/Price.php`
    file with partial content, as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, create an `app/code/Foggyline/DailyDeal/Model/ResourceModel/Indexer/Stock.php`
    file with partial content, as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, create an `app/code/Foggyline/DailyDeal/Setup/InstallData.php` file
    with partial content, as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Extend the `install` method from within the `InstallData` class by adding the
    following `foggylinedailydeal` type specifics to it:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, run `php bin/magento setup:upgrade` from the console.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'If you now open the **Products** | **Inventory** | **Catalog** menu in the
    admin area and click on the dropdown icon next to the **Add Product** button,
    you will see the **Daily Deal** product type on the list, as shown in the following
    screenshot:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![The custom product types](img/00079.jpeg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the **Daily Deal** product type in the dropdown list should open
    the product edit page, as shown in the following screenshot:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![The custom product types](img/00080.jpeg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: There is no noticeable difference between the custom product type edit screen
    and one of the built-in product types.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that we have named the product `Daily Deal Test Product` and saved
    it, we should be able to see it on the storefront, as shown in the following screenshot:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![The custom product types](img/00081.jpeg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
- en: 'If we add the product to the cart and perform a checkout, an order should be
    created just as with any other product type. Within the admin area, on the order
    view page, under **Items Ordered**, we should be able to see the product on the
    list, as shown in the following screenshot:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '![The custom product types](img/00082.jpeg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
- en: Again, there is no noticeable difference between the custom product type and
    the built-in product type that is rendering under the **Items Ordered** section.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we should run the `php bin/magento indexer:reindex` command on the
    console. Even though we haven't really implemented any code within the indexers,
    this is just to ensure that none of the existing indexers broke.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The entire module code can be downloaded from [https://github.com/ajzele/B05032-Foggyline_DailyDeal](https://github.com/ajzele/B05032-Foggyline_DailyDeal).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Custom offline shipping methods
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Magento provides several out-of-the-box offline shipping methods, such as `Flatrate`,
    `Freeshipping`, `Pickup`, and `Tablerate`. We can see those in the `vendor/magento/module-offline-shipping/Model/Carrier`
    directory.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: However, project requirements quite often are such that we need a custom coded
    shipping method where a special business logic is applied. Thus, the shipping
    price calculation can be controlled by us. In such cases, knowing how to code
    our own offline shipping method might come in handy.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and create a small module called `Foggyline_Shipbox` that provides
    Magento an extra offline shipping method.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a module registration file named `app/code/Foggyline/Shipbox/registration.php`
    with partial content, as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, create an `app/code/Foggyline/Shipbox/etc/module.xml` file with the following
    content:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, create an `app/code/Foggyline/Shipbox/etc/config.xml` file with content,
    as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After this is done, create an `app/code/Foggyline/Shipbox/etc/adminhtml/system.xml`
    file with content, as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, create an `app/code/Foggyline/Shipbox/Model/Carrier/Shipbox.php` file
    with partial content, as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Extend the `collectRates` method in the `Carrier\Shipbox` class, as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the Magento admin area, if you now look under **Stores** | **Settings**
    | **Configuration** | **Sales** | **Shipping Methods**, you will see **Foggyline
    Shipbox** on the list, as shown in the following screenshot:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom offline shipping methods](img/00083.jpeg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: Set the **Enabled** option to **Yes** and click the **Save Config** button.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'If you now run the `SELECT * FROM core_config_data WHERE path LIKE "%shipbox%";`
    query on the MySQL server, you will see results that are similar to the ones shown
    in the following screenshot:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom offline shipping methods](img/00084.jpeg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
- en: Note how there is no direct code within the code snippets in the preceding screenshot
    that is related to the **Ship to Applicable Countries** and **Ship to Specific
    Countries** options, because the handling of these options is built into the parent
    `AbstractCarrier` class. Thus, simply by adding the `sallowspecific` option in
    `config.xml` and `system.xml`, we enabled a feature where the shipping method
    can be shown or hidden from certain countries.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: The crux of the implementation comes down to the `collectRates` method. This
    is where we implement our own business logic that should calculate the shipping
    price based on the items in the cart. We can use the `$request->getAllItems()`in
    the `collectRates` method to fetch the collection of all the cart items, traverse
    through them, form a final shipping price based on various conditions, and so
    on.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go ahead and jump to the storefront in order to test the checkout.
    We should be able to see our method on the checkout, as shown in the following
    screenshot:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom offline shipping methods](img/00085.jpeg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: 'If we complete one order, we should further see the shipping method details
    on the order itself. Within the admin area, under **Sales** | **Operations** |
    **Orders**, if we **View** our order in the **Payment & Shipping Method** section,
    we should see the shipping method, as shown in the following screenshot:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom offline shipping methods](img/00086.jpeg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, in the **Order Totals** section, we should see the shipping amount
    in **Shipping & Handling**, as shown in the following screenshot:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom offline shipping methods](img/00087.jpeg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
- en: With this, we conclude our custom offline shipping method module. The full module
    can be found at [https://github.com/ajzele/B05032-Foggyline_Shipbox](https://github.com/ajzele/B05032-Foggyline_Shipbox).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Custom offline payment methods
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Magento provides several out-of-the-box offline payment methods, such as `Banktransfer`,
    `Cashondelivery`, `Checkmo`, and `Purchaseorder`. You can see them in the `vendor/magento/module-offline-payments/Model`
    directory.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to payment methods, it is more common to use an online payment
    provider (gateway), such as PayPal or Braintree. Sometimes, project requirements
    may be such that we may need a custom coded payment method. You will need to think
    of programmatic product import and order creation script that might specialize
    in some specifically labeled payment method. Thus, the payment process will be
    controlled by us.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, knowing how to code our own offline payment method might come
    in handy. It is worth noting that while we can make an offline payment that will
    grab a user's credit card information, it is not really advisable to do so unless
    our infrastructure is PCI-compliant.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and create a small module called `Foggyline_Paybox` that provides
    Magento an extra offline payment method.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a module registration file named `app/code/Foggyline/Paybox/registration.php`
    with partial content, as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, create an `app/code/Foggyline/Paybox/etc/module.xml` file with the following
    content:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After this is done, create an `app/code/Foggyline/Paybox/etc/config.xml` file
    with the following content:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, create the `app/code/Foggyline/Paybox/etc/payment.xml` file with the
    following content:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, create an `app/code/Foggyline/Paybox/etc/adminhtml/system.xml` file with
    the following content:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create an `app/code/Foggyline/Paybox/etc/frontend/di.xml` file with the following
    content:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'After this is done, create an `app/code/Foggyline/Paybox/Model/Paybox.php`
    file with the following content:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, create an `app/code/Foggyline/Paybox/Model/PayboxConfigProvider.php` file
    with the following content:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Copy the entire `vendor/magento/module-offline-payments/view/frontend/layout/checkout_index_index.xml`
    Magento core file into the `app/code/Foggyline/Paybox/view/frontend/layout/checkout_index_index.xml`
    module. Then, edit the module''s `checkout_index_index.xml` file by replacing
    the entire `<item name="offline-payments" xsi:type="array">` element and its children
    with the following code:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, create an `app/code/Foggyline/Paybox/view/frontend/web/js/view/payment/offline-payments.js`
    file with the following content:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After this is done, create an `app/code/Foggyline/Paybox/view/frontend/web/js/view/payment/method-renderer/paybox.js`
    file with the following content:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, create an `app/code/Foggyline/Paybox/view/frontend/web/template/payment/paybox.html`
    file with the following content:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: With this, we conclude our custom offline payment method module. The entire
    module can be found at [https://github.com/ajzele/B05032-Foggyline_Paybox](https://github.com/ajzele/B05032-Foggyline_Paybox).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we touched upon some of the most common bits of functionality
    that developers come in contact with. We learned where to look in the admin area
    and how to programmatically manage the entities behind these functionalities.
    Thus, we were effectively able to manually and programmatically create and fetch
    CMS pages, blocks, categories, and products. We also learned how to create product
    and customer import scripts. Finally, we studied how to create our own custom
    product type, simple payment, and shipment module.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些开发者最常接触到的功能点。我们学习了在管理区域中查找信息的位置，以及如何编程管理这些功能背后的实体。因此，我们能够有效地手动和编程创建和获取
    CMS 页面、块、分类和产品。我们还学习了如何创建产品和客户导入脚本。最后，我们研究了如何创建我们自己的自定义产品类型、简单支付和运输模块。
- en: The following chapter will guide us through Magento's in-built tests and how
    we can use them to effectively QA an application to keep it healthy.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将引导我们了解 Magento 内置测试的使用方法，以及如何利用它们有效地进行应用程序的质量保证，以保持其健康状态。
