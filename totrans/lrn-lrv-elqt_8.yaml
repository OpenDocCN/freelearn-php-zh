- en: Chapter 8. It's Not Enough! Extending Eloquent, Advanced Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through this book, you learned that you can do many amazing things with Eloquent.
    It is a great active record implementation; it's easy to use, really flexible,
    and it offers many tools out of the box to improve your code base quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'A developer usually must face two types of projects: *Applications* and *applications*,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For *applications*, I intend something that you can do, maybe in a quick way,
    with some workarounds and some hacks, here and there. Also, I know that you know
    what I am talking about. That site you made for a friend, a little blog, and so
    on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's be clear and serious, you can't make every application with the same,
    perfect care. Being honest, neither me nor probably any one does. Then, you have
    to deal with *Applications*. Things can get really serious there, and you must
    be able to build a maintainable, awesome application structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s not just about something that works; in this case, I am thinking about
    something that can scale easily, with a good quality code base. It''s not just
    about calling your models from controllers. That''s not enough. You could stumble
    upon many issues: testability, maintainability, and also in following some principles.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore two different ways to extend Eloquent more
    seriously.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the very first part, you will learn how to extend the Eloquent Model class.
    Actually, the Model does many things, but what if we need something more? No problem:
    extending the existing Model class will be a bed of roses if standing on the shoulders
    of a giant.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Have you ever heard about the Ardent Project? It''s a package for Laravel 4
    that extends the Model class, adding some super powers: self-validating models
    and auto-hydrating from the request input data.'
  prefs: []
  type: TYPE_NORMAL
- en: You'll make something similar for the Laravel 5 Eloquent Model, and I will show
    you how to do it step by step. Also, it is inspired by the work of Philip Brown
    in his blog ([http://culttt.com/2013/08/05/extending-eloquent-in-laravel-4/](http://culttt.com/2013/08/05/extending-eloquent-in-laravel-4/)).
  prefs: []
  type: TYPE_NORMAL
- en: However, as mentioned earlier in this book, Laravel is mostly about freedom,
    especially when it comes to freedom in organizing your projects. Now, a really
    interesting trend is the **repository pattern**. It's a way to abstract your code
    in a better way and separate responsibilities. For a project bigger than the bakery's
    blog, it's a must-have in your knowledge base.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the repository pattern is not something related to Laravel only. This
    means that you will learn something new that you will be able to reuse in the
    future, with other languages and products.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, no more chitchat. It is time to get our hands dirty for the last time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Come on, hero! We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extending the Model: Aweloquent !'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diving into the repository pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The summary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extending the Model: Aweloquent!'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Eloquent Model can actually do tons of things in a very smart and easy way.
    However, something can be improved in terms of code to write every time you want
    to do a specific operation.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, when creating a new model instance, you are probably using some data
    that the user previously typed in to a form.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new author to our database can be the perfect example. All you have
    to do is to insert the first and last names in to a form and then press **save**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the dedicated post route (or relative controller method), you will
    do something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That's quite fine. However, you will probably also have to validate the user
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, assuming that you are still in a controller, you could add a controller
    validator call, just like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once again, saved the day!
  prefs: []
  type: TYPE_NORMAL
- en: Now, very often, developers debate the responsibilities of a single class in
    terms of what that class has to do and what not. Everyone has a thought about
    the topic.
  prefs: []
  type: TYPE_NORMAL
- en: The **Single Responsibility Principle**, a part of the SOLID principles, is
    very clear about that—put simply, the principle says that a class should do one
    and only one thing.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, however, you will often find very big classes. The Eloquent
    Model is one of them. At the time of writing, the Illuminate\Database\Eloquent\Model
    counts 3,399 lines of code. Not exactly something small!
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, the Model doesn't perform a single operation; it fills its own attributes,
    deals with relationships, and serializes its own attributes. Yes, it goes far
    beyond the principle you just read.
  prefs: []
  type: TYPE_NORMAL
- en: So, what's the deal with it?
  prefs: []
  type: TYPE_NORMAL
- en: Well, even if it is very big, a Model like this allows you to perform many operations
    using a single class.
  prefs: []
  type: TYPE_NORMAL
- en: 'A perfect example is how you can use a Model as a model, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use it as a factory (a class that is used to create instances
    in a more elegant and better way) using the `create()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If this isn''t enough, the Model also handles everything related to the persistence
    of the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: All using a single class—that's the main advantage.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are probably asking yourself what he is trying to say with all this stuff.
    The answer is really simple: there isn''t always a single correct solution. Some
    people hate the Eloquent Model, some people love it.'
  prefs: []
  type: TYPE_NORMAL
- en: So, in this specific situation, I will add new features to the existing Model
    class creating a new Eloquent Model… **the Aweloquent**!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we go any further, here's a clarification. I will repeat it again, but
    I also want to say it now. In the following part of this chapter, we will extend
    the Model class adding a feature that, in Laravel, is handled by the `Validator`
    class. I am not teaching you this because I want you to do this, but because I
    want to show you how to extend the Model class.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, you will probably find the **smart password hashing** feature
    stupid, but it's just an example. Extending Models and using repositories are
    two different techniques, which are totally separated. I am just giving you the
    knowledge, then you can choose what to do, and I am sure you will do the right
    thing, hero!
  prefs: []
  type: TYPE_NORMAL
- en: The Aweloquent Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I mentioned earlier, our powered-up Eloquent Model will be really similar
    to the Ardent Laravel 4 package-improved Model. I will also borrow some ideas
    from Philip Brown's Magniloquent project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be more precise, our improved Model will feature the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Auto Hydrate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model self-validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart password hashing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The autopurge of confirmation fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto Hydrate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of assigning attributes individually, or passing them in an array, the
    Aweloquent Model will be able to read the current request and autopopulate its
    attributes without any other code lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that you will be able to use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the more classic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Model self-validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will be able to specify validation rules and messages as static properties
    of a Model. Then, the Model will automatically perform the validation operation
    you need, without using any external classes or controller validators. You will
    be able, also, to assign a certain rule to a certain operation (the `'create'`
    or the `'update'` operation, or both).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in your Model, you will have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Smart password hashing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another thing you have to do frequently is to **hash a password**. Usually,
    you take the value from a `password` attribute. So, the Aweloquent Model automatically
    performs the hash operation on a `password` field, if present.
  prefs: []
  type: TYPE_NORMAL
- en: The autopurge of confirmation fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Laravel validator has the confirmed rule, based on an `x_confirmation` attribute
    (where `x` is the name of the field). You have probably used it used it for a
    password confirmation field. The auto purge feature of the Aweloquent Model automatically
    removes (after validation, of course) every `_confirmation` field.
  prefs: []
  type: TYPE_NORMAL
- en: However, it's not over yet! The Aweloquent Model will automatically exclude
    the `'_token'` field, used by the **Cross Site Request Forgery** (**CSRF**) protection
    middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, that's all! Now you can write some code.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing you have to do is to create a new class, the `AweloquentModel`
    class that extends the existing Eloquent Model one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my specific case, I made something really simple: I created a new folder
    called `Aweloquent` in the `app` one and then created an `AweloquentModel.php`
    file inside.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code you have to put into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Great! As a start, we have our new `AweloquentModel` class.
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can use it as a base for your future models. There are no changes
    here, just a simple extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the first feature: Auto Hydrate.'
  prefs: []
  type: TYPE_NORMAL
- en: The Auto Hydrate feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we implement this first feature, let's think about what we want as a
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, when you create a new model, you can quickly pass its attributes
    using the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'These parameters are passed from the constructor to another method called `fill()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As a logical consequence, if we want to implement this Auto Hydrate feature,
    we will have to write a new constructor to deal with the auto hydrating there
    and then to call the parent class. So, let''s go back to our `AweloquentModel`
    class. Here''s the first implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `autoHydrate` method creates the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An instance of the current request to get the required data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, and for each cycle, it adds to the attributes array every element
    in the request data array (excluding the CSRF `'_token'`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the explicit specified attribute (the one you can put in the Model
    constructor) has the priority over the request data array. So, you are still free
    to deal with the Model and decide what to define and what not, maybe to add some
    extra data that you are not getting from the form.
  prefs: []
  type: TYPE_NORMAL
- en: If you try to create a new user by setting up a basic form, the Auto Hydrate
    feature is already working.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move forward!
  prefs: []
  type: TYPE_NORMAL
- en: The Aweloquent Model self-validation feature – the basic version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is time to implement the self-validation feature of our Aweloquent Model.
    The idea is quite simple: for every model, you will be able to declare (as properties)
    rules and related messages. So, it should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'These rules and message will be used automatically by a `validate()` dedicated
    method. What I want to achieve is something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s open the `AweloquentModel.php` file and add some code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Great! The `Validator` `Facadec` is used to instantiate a new validator. The
    static `$rules` and `$message` attributes are used for the `make()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `$validator->fails()` call determines if the given model is valid
    or not. If not, the `$errors` property is populated using the validation errors
    `MessageBag` object.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this is a very basic validation system. However, we could do something
    more. For instance, an implementation of an operation-based validation would be
    great.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and try it, if you want! It already works!
  prefs: []
  type: TYPE_NORMAL
- en: The Aweloquent Model self-validation feature – the operation-based version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to implement the advanced version of the self-validation system, we
    have to define the rule format for every model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this specific one, I have chosen something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `$message` property is left untouched. The only one that has to be modified
    is `$rules`, as you may easily imagine.
  prefs: []
  type: TYPE_NORMAL
- en: In this new version of `$rules`, you can define rules for a single operation,
    `'create'`, or both. If you want to use a rule in both of them, there is a dedicated
    `'everytime'` item to avoid the duplication of rules.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we have to edit our `AweloquentModel` once again. This time, we have
    to define a method that has to work with the existing validate one and understand
    if we are creating or updating it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, merge the right rules in a single array and validate the model against
    those rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what we can do! Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Great, we have it!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `validate()` method doesn''t change too much. The only big difference stands
    in the newly line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Basically, we are saying, "Ok, now assign to the `$rules` property the result
    of this `mergeValidationRules()` method."
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `mergeValidationRules()` method, the first instruction to be used
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That is used to determine if the current operation is an insert or an update.
    Starting from this value, we can get the right rules array, merging them with
    the `everytime` rules.
  prefs: []
  type: TYPE_NORMAL
- en: Your new complex self-validating model is almost ready to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Smart password hashing and the confirmation fields autopurge method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last features we have to implement are the smart password hashing and confirmation
    fields auto purge methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is very easy and intuitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If a `'password'` field is present, hash it. Nothing more!
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if, it''s a little longer, the `purgeConfirmationFields()` isn''t so hard
    to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This time, I used the `Str` string utility class in order to use the `endsWith()`
    method, which is used to determine if a strings ends with a certain sequence of
    characters. Every `'_confirmation'` field is removed.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the save() Model method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, the last thing that we need to fix is the `save()` method. Actually, the
    `save()` method totally ignores the validation procedure, and this is no good.
    So, this is my final version of the `AweloquentModel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze the `save()` method in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to do is to validate the entire input. After that, if everything
    is fine, passwords are hashed and the confirmation fields are purged, as we don't
    need them anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `parent::save()` method is called, and the operation is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to create a perfect continuity with the parent class, I declared the
    `save()` method with the same signature as its parent (including the `$options`
    array parameter).
  prefs: []
  type: TYPE_NORMAL
- en: That's it! The `AweloquentModel` class is finished, and you can use it as you
    want in your projects. You also learned how to go deep inside the `Model` class
    and extend it in order to add new methods, behaviors, and features.
  prefs: []
  type: TYPE_NORMAL
- en: Diving into the repository pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you know a couple of things about good development and best practices, you
    have probably heard about software design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define them as useful solution templates for a certain kind of problem,
    or to be more precise:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"In software engineering, a design pattern is a general reusable solution
    to a commonly occurring problem within a given context in software design. A design
    pattern is not a finished design that can be transformed directly into source
    or machine code. It is a description or template for how to solve a problem that
    can be used in many different situations. Patterns are formalized best practices
    that the programmer can use to solve common problems when designing an application
    or system."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This extract is from the software design patterns page ([http://en.wikipedia.org/wiki/Software_design_pattern](http://en.wikipedia.org/wiki/Software_design_pattern))
    on Wikipedia.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's focus on the second sentence.
  prefs: []
  type: TYPE_NORMAL
- en: A design pattern is not something that can be transformed directly into source
    code.
  prefs: []
  type: TYPE_NORMAL
- en: That's the most important part because it explains many things. It is not something
    you learn specifically for Laravel or maybe for a certain language.
  prefs: []
  type: TYPE_NORMAL
- en: Absolutely, once you learned about design patterns, it is for life!
  prefs: []
  type: TYPE_NORMAL
- en: In the previous part of this chapter, you learned how to create an improved
    version of the Eloquent Model. You reached the objective by adding something to
    the existing model.
  prefs: []
  type: TYPE_NORMAL
- en: However, many people don't like that kind of approach. They strongly believe
    in the Single Responsibility Principle, so every class must do one and only one
    thing. Nothing more!
  prefs: []
  type: TYPE_NORMAL
- en: Let's be clear; I don't want to bore you by adding my useless opinion in this
    long-time debate.
  prefs: []
  type: TYPE_NORMAL
- en: In the final part of this chapter, I will introduce a specific design pattern
    that can be really useful for improving a Laravel application—the repository pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Hello, repository pattern!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You know that I like to explain a concepts with an example as a start. This
    is no exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you are building an application for a warehouse. In this warehouse,
    you can store whatever you want and you probably have a model like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing to say; it works, and you know it.
  prefs: []
  type: TYPE_NORMAL
- en: This is a cool solution for a simple project, the kind of project that you can
    call an *application*. However, what happens if we don't have an *Application*,
    instead?
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that the business you're helping grows and the management decides to
    create a mobile application that must be used internally. You will probably need
    to implement an API for the other developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t know how to deal with something like this, you will soon start
    to write duplicated code. In your Rest API, for sure, there will be an endpoint
    `\items` that does the same thing you did in the controller method such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Repeating the same code many times isn't safe. You know it, right?
  prefs: []
  type: TYPE_NORMAL
- en: But no fear, hero! The solution is called a **repository pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best definition of this concept is the one you can find on Martin Fowler''s
    website ([http://martinfowler.com/eaaCatalog/repository.html](http://martinfowler.com/eaaCatalog/repository.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A Repository mediates between the domain and data mapping layers, acting
    like an in-memory domain object collection. Client objects construct query specifications
    declaratively and submit them to Repository for satisfaction.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Objects can be added to and removed from the Repository, as they can from
    a simple collection of objects, and the mapping code encapsulated by the Repository
    will carry out the appropriate operations behind the scenes."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So, imagine a repository as something in between that abstracts all the necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the previous example, imagine that we have a repository with a
    dedicated method `getRecent($perPage, $pageNumber)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the same method in the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Rest API, the following method is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The same code is used twice and written once. However, there's more than this;
    let's see how to implement repositories in a Laravel project.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing repositories – a concrete implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to start with repositories is to implement a concrete implementation.
    As I mentioned earlier, a repository stands between the controller and model.
    It is something in the middle.
  prefs: []
  type: TYPE_NORMAL
- en: When you build a repository, you must do it thinking about what you will need
    from the repository. Let's imagine something for our `Author` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will probably need the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getAll($perPage, $pageNumber)`: This returns a paginated list of every author
    in my data source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find($authorId)`: This returns a specific author with a certain primary key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search($firstName, $lastName)`: This returns an array of results starting
    from the first name to the last name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enough of searching for and getting records! However, we will also need other
    methods, which are dedicated to data persistence:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create($authorData)`: This will save a new author in the data source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`save($authorData, $authorId)`: This will update an existing author in the
    data source with a certain primary key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start!
  prefs: []
  type: TYPE_NORMAL
- en: First of all, create a new directory in the `app` folder. Name it `Repositories`.
    Inside it, create a new file called `DbAuthorsRepository.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how you can use it in some test routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Nothing more!
  prefs: []
  type: TYPE_NORMAL
- en: By creating a repository, you learned how to improve your software architecture
    and the abstraction level of your solution. Also, instead of what you saw earlier
    in this chapter with Aweloquent, this time you can feel a great separation of
    responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is not the end yet; the repository pattern hasn't yet shown all
    of its power.
  prefs: []
  type: TYPE_NORMAL
- en: Coding on Abstractions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I already introduced you to the SOLID principles earlier in this chapter. I
    mentioned the Single Responsibility Principle, the *S* of SOLID. Now that we are
    close to the end, I will introduce the *D*.
  prefs: []
  type: TYPE_NORMAL
- en: The dependency inversion principle is one of my favorites because it really
    highlights the importance of abstracting your code base the best you can.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its definition is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A. High-level modules should not depend on low-level modules. Both should
    depend on abstractions.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*B. Abstractions should not depend on details. Details should depend on abstractions."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*-Wikipedia ([http://en.wikipedia.org/wiki/Dependency_inversion_principle](http://en.wikipedia.org/wiki/Dependency_inversion_principle))*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In a few words, the concept is that you must code abstractions and should not
    depend on concrete classes. Else, a better way to say it: you must depend on abstractions
    and not on concrete classes.'
  prefs: []
  type: TYPE_NORMAL
- en: In PHP, talking about abstraction refers to working with interfaces and contracts.
  prefs: []
  type: TYPE_NORMAL
- en: In a certain sense, Laravel itself widely uses this concept. The basic Laravel
    package is `Contracts`, that is made up of several interfaces that specify whatevery
    component must do and how it does it.
  prefs: []
  type: TYPE_NORMAL
- en: However, it's not just about a framework big thing. You can apply this principle
    in your everyday development. More specifically, you can apply the concept to
    repositories.
  prefs: []
  type: TYPE_NORMAL
- en: I will show you how!
  prefs: []
  type: TYPE_NORMAL
- en: Repositories – a complete implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dive in, let's introduce a little problem to our software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, our situation is the following: our controllers and routes use the
    `DbAuthorsRepository` class to get data, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the `DbAuthorsRepository` class uses the Author model in order to get
    the desired data from the physical storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's imagine that our data sources change. For a certain reason (I know,
    that is quite paradoxical), the management wants to switch to a file-based storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have two ways to deal with this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: You scream and are paralyzed by fear
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide to organize your code base in a better way, introducing interfaces in
    to your repository workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the plan:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Laravel service container, you can decide to bind a certain interface
    to a specific implementation.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you create an interface for every repository, you will be able to write
    your code once and then write every concrete repository you need and, finally,
    to switch from one repository to another, you will have to change a single line
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, let''s make it step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let's define a standard behavior for our author's repository defining
    an `AuthorRepository` interface. Create a new `AuthorRepository.php` file in `app/Repositories/Contracts`.
    I will use the `Contracts` folder for interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''re the contents of the fresh file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Interfaces are pure abstraction. All we are saying here is, "When I build a
    new author repository, I don't care about the underlying implementation. I don't
    care if I am working with a NoSQL database or a flat file driver. All I want is
    that every repository implements all these methods."
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Working in this manner means that we can define a standard format for every
    component (or repository, in this case) that we will use in the future.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we can update our `DbAuthorsRepository` class in order to implement our
    interface. Consider the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ok. Now, let's see the power of the entire mechanism in action.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First of all, open the `app/Providers/AppServiceProvider.php` file and add
    this binding to the `register()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Laravel now knows that every time you will request an instance of `AuthorsRepository`,
    it will have to create an instance of the `DbAuthorsRepository` using the service
    container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test our assumptions, open the routes file and add this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result will be exactly what we are expecting. Also, using the method injection
    technique, we don't have to explicitly call the service container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In fact, an alternative to this syntax would be the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Adding the new repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we are close to the end. Let''s return to our main problem: we have
    to implement a new file-based author''s repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, it is quite easy:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a new file in `app/Repositories`, called `FileAuthorsRepository`.
    It will be a new class, of course.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will implement the AuthorsRepository interface, obviously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are the class contents:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can easily see, I have implemented all the required methods from the
    interface. This means that our application will be able to use the FileAuthorsRepository
    in the same way as the DbAuthorsRepository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'I filled method bodies with some `dd` instructions, just to show you how the
    concept works. For our final step, go to the `AppServiceProvider` class and update
    the previous binding to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, browse to the `/authors` route. Yes, the output now is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**"getting all records from flat file driver..."**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Yes, it worked!
  prefs: []
  type: TYPE_NORMAL
- en: 'Our route file will never know what repository it is using: the interface defines
    all the methods you need.'
  prefs: []
  type: TYPE_NORMAL
- en: This is fantastic because, for instance, if you want to add a NoSQL repository
    to your application in the future, all you will have to do is to create a new
    `NoSQLAuthorsRepository` class that implements the `AuthorsRepository` interface.
    Then, in the `AppServiceProvider`, you will switch the binding with the one you
    need.
  prefs: []
  type: TYPE_NORMAL
- en: Easy, cool, and also testable!
  prefs: []
  type: TYPE_NORMAL
- en: 'Maybe I am a little repetitive, but focus your attention on this specific point:
    with the mentioned structure, you can abstract the way you work with your data
    from the way you access to it. I know that reading the same thing again and again
    is boring, but I need you to understand this concept.'
  prefs: []
  type: TYPE_NORMAL
- en: It is probable that the first time you read about repositories you will think
    *what am I doing here? What the hell?* I have done the same thing, so I totally
    understand your doubts. However, when you work on a more complex project, you
    will totally feel the difference.
  prefs: []
  type: TYPE_NORMAL
- en: That's the magic of repositories!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are done. In this final chapter, you learned about empowering your application
    in two different and separate ways: on one hand, adding features on an existing
    entity. In this case, the Eloquent Model.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other one, you learned how to structure your application in a different
    way using repositories in order to get a better code testability, maintainability,
    and a separation of purposes instead of delegating everything to a single class.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have all the tools you need to build great applications using Eloquent
    and Laravel.
  prefs: []
  type: TYPE_NORMAL
- en: What are you waiting for? Go on and make me proud!
  prefs: []
  type: TYPE_NORMAL
