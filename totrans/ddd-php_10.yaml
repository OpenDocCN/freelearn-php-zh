- en: Repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to interact with a Domain object, you need to hold a reference to
    it. One way of achieving this is by creation. Alternatively, you can traverse
    an association. In Object-Oriented programs, objects have links (references) to
    other objects, which makes them easily traversable, thereby contributing to the
    expressive power of our models. But here''s the catch: you need a mechanism to
    retrieve the first object, the Aggregate Root.'
  prefs: []
  type: TYPE_NORMAL
- en: Repositories act as storage locations, where a retrieved object is returned
    in the exact same state it was persisted in. In Domain-Driven Design, every Aggregate
    type typically has a unique associated Repository, which is used for its persistence
    and fetching needs. However, in the case where it's required to share an Aggregate
    object hierarchy, the types might share a Repository.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've successfully retrieved the Aggregate from the Repository, every
    change you make is persisted, which removes the need to go back to the Repository.
  prefs: []
  type: TYPE_NORMAL
- en: Definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Martin Fowler defines a Repository as:'
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism between the domain and data mapping layers, acting like an in-memory
    domain object collection. Client objects construct query specifications declaratively
    and submit them to Repository for satisfaction. Objects can be added to and removed
    from the Repository, as they can from a simple collection of objects, and the
    mapping code encapsulated by the Repository will carry out the appropriate operations
    behind the scenes. Conceptually, a Repository encapsulates the set of objects
    persisted in a data store and the operations performed over them, providing a
    more object-oriented view of the persistence layer. Repository also supports the
    objective of achieving a clean separation and one-way dependency between the domain
    and [data mapping layers](http://martinfowler.com/eaaCatalog/repository.html).
  prefs: []
  type: TYPE_NORMAL
- en: Repositories Are Not DAOs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Data Access Objects** (**DAOs**) are a common pattern for persisting Domain
    objects into the database. It''s easy to confuse the DAO pattern with a Repository.
    The significant difference is that Repositories represent collections, while DAOs
    are closer to the database and are often far more table-centric. Typically, a
    DAO would contain CRUD methods for a particular Domain object. Let''s see how
    a common interface for a DAO might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A DAO interface could have multiple implementations, which could range from
    using ORM constructions to using plain SQL queries. The main problem with DAOs
    is that their responsibilities are not clearly defined. DAOs are usually perceived
    as gateways to the database, so it''s relatively easy to greatly decrease cohesion
    with many specific methods in order to query the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the more we add new methods to implement, the harder it becomes
    to unit test the DAO, and it becomes increasingly coupled to the User object.
    This problem will grow over time, with many other contributors collaborating in
    making the Big Ball of Mud even bigger.
  prefs: []
  type: TYPE_NORMAL
- en: Collection-Oriented Repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Repositories mimic a collection by implementing their common interface characteristics.
    As a collection, a Repository shouldn't leak any intentions of persistence behavior,
    such as the notion of saving to a store.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying persistence mechanism has to support this need. You shouldn't
    be required to handle changes to the objects over their lifetime. The collection
    references the most recent changes to the object, meaning that upon each access,
    you get the latest object state.
  prefs: []
  type: TYPE_NORMAL
- en: Repositories implement a concrete collection type, the Set. A Set is a data
    structure with an invariant that doesn't contain duplicate entries. If you try
    to add an element that's already present to a Set, it won't be added. This is
    useful in our use case, as each Aggregate has a unique identity that's associated
    with the Root Entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider, for example, that we have the following Domain Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to persist this `Post` Entity, a simple in-memory `Post` Repository
    could be created like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And, as you would expect, it''s handled as a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, from the collection's point of view, there's no need for a save
    method in the Repository. Changes affecting the object are correctly handled by
    the underlying persistence layer. Collection-oriented Repositories are the ones
    that don't need to add an Aggregate that was persisted before. This mainly happens
    with the Repositories that are memory based, but we also have ways to do this
    with the Persisted-Oriented Repositories. We'll look at this in a moment; additionally,
    we'll cover this more in depth in the [Chapter 11](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml),
    *Application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step to design a Repository is to define a collection-like interface
    for it. The interface needs to define the usual collection methods, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For implementing such an interface, you could also use an abstract class. In
    general, when we talk about an interface, we refer to the general concept and
    not just the specific PHP interface. To keep your design simple, don't add methods
    you don't need; the Repository interface definition and its corresponding Aggregate
    should be placed in the same Module.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes `remove` doesn't physically delete the Aggregate from the database.
    This strategy - where the Aggregate has a status field that's updated to a *deleted*
    value - is known as a *soft delete*. Why is this approach interesting? It can
    be interesting for auditing changes and performance. In those cases, you can instead
    mark the Aggregate as disabled or *logically removed*. The interface could be
    updated accordingly by removing the removal methods or providing disable behavior
    in the Repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important aspect of Repositories are the finder methods, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As we suggested in [Chapter 4](0c7239ad-9b34-48aa-b60c-072a7b07273f.xhtml),
    *Entities*, we prefer Application-Generated Identities. The best place to generate
    a new Identity for an Aggregate is its Repository. So to retrieve the globally
    unique ID for a `Post`, a logical place to include it is in `PostRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The code responsible for building up each `Post` instance calls `nextIdentity`
    to get a unique identifier, `PostId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Some developers favor placing the implementation close to the interface definition
    as a subpackage of the Module. However, because we want a clear Separation of
    Concerns, we recommend instead placing it inside the Infrastructure layer.
  prefs: []
  type: TYPE_NORMAL
- en: In-Memory Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As Uncle Bob wrote in [Screaming Architecture](http://blog.8thlight.com/uncle-bob/2011/09/30/Screaming-Architecture.html):'
  prefs: []
  type: TYPE_NORMAL
- en: A good software architecture allows decisions about frameworks, databases, web-servers,
    and other environmental issues and tools, to be deferred and delayed. A good architecture
    makes it unnecessary to decide on Rails, or Spring, or Hibernate, or Tomcat or
    MySql, until much later in the project. A good architecture makes it easy to change
    your mind about those decisions too. A good architecture emphasizes the use-cases
    and decouples them from peripheral concerns.
  prefs: []
  type: TYPE_NORMAL
- en: In the early stages of your application, a fast in-memory implementation could
    come in handy. It's something you could use to mature other parts of your system,
    allowing you to delay database decisions to the correct moment. An in-memory Repository
    is simple, fast, and easy to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our `Post` Repository, an in-memory hash map is enough to provide all the
    functionality we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Doctrine ORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've talked about [Doctrine](http://www.doctrine-project.org/) in past chapters
    quite a bit. Doctrine is a set of libraries for database storage and object mapping.
    It comes bundled with the popular [Symfony2 web framework](http://symfony.com/) by
    default and, among other features, it allows you to easily decouple your application
    from the persistence layer, thanks to the [Data Mapper pattern](http://martinfowler.com/eaaCatalog/dataMapper.html).
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, the ORM stands over a powerful database abstraction layer that enables
    database interaction through an SQL dialect called **Doctrine Query Language**
    (**DQL**), which is inspired by the famous Java Hibernate framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we''re going to use Doctrine ORM, the first task to complete is adding the
    dependencies to our project through [Composer](https://getcomposer.org/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Object Mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mapping between your Domain objects and the database can be considered an
    implementation detail. The Domain lifecycle shouldn't be aware of these persistence
    details. As such, the mapping information should be defined as part of the Infrastructure
    layer, outside the Domain, and as the implementation for the Repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Doctrine Custom Mapping Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As our `Post` Entity is composed of Value Objects like `Body` or `PostId`,
    it''s a good idea to make Custom Mapping Types or use Doctrine Embeddables for
    them, as seen in the Value Objects chapter. This will make the object mapping
    considerably easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to implement the `__toString` magic method on the `PostId` Value
    Object, as Doctrine requires this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Doctrine offers multiple formats for the mapping, such as YAML, XML, or annotations.
    XML is our preferred choice, as it provides robust IDE autocompletion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs: []
  type: TYPE_NORMAL
- en: Write down what the mapping would look like in the case of using the Doctrine
    Embeddables approach. Take a look at Chapter Value Objects or Chapter Entities if
    you need some help.
  prefs: []
  type: TYPE_NORMAL
- en: Entity Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `EntityManager` is the central access point for the ORM functionality.
    Bootstrapping it is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Remember to configure it according to your needs and setup.
  prefs: []
  type: TYPE_NORMAL
- en: DQL Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the case of this Repository, we''ll only need the `EntityManager` to retrieve
    Domain objects directly from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you check some Doctrine examples out there, you may find that after running
    persist or remove, flush should be called. But as seen in our proposal, there's
    no call to `flush`. Flushing and dealing with transactions is delegated to the
    Application Service. That's why you can work with Doctrine, considering that flushing
    all the changes on Entities will happen at the end of the request. In terms of
    performance, one flush call is best.
  prefs: []
  type: TYPE_NORMAL
- en: Persistence-Oriented Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when collection-oriented Repositories don't fit well with our
    persistence mechanism. If you don't have a unit of work, keeping track of Aggregate
    changes is a difficult task. The only way to persist such changes is by explicitly
    calling `save`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface definition for a persistence-oriented Repository is similar to
    how you would define a collection-oriented equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we now have save and `saveAll` methods, which provide functionality
    similar to the previous add and `addAll` methods. However, the important difference
    is how the client uses them. Within a collection-oriented style, you use the add
    methods just once: when the Aggregate is created. In a persistence-oriented style,
    you''ll not only use the `save` action after creating a new Aggregate, but also
    when an existing one is modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Other than this difference, the details are only in the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Redis Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The [Redis](http://redis.io/) is an in-memory key value that can be used as
    a cache or store.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the circumstances, we could consider using Redis as a store for
    our Aggregates.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, make sure you have a PHP client to connect to Redis. A good
    one that we recommend is [Predis](https://github.com/nrk/predis):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: SQL Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a classic example, we could create a simple [PDO](http://php.net/manual/en/book.pdo.php) implementation
    for our `PostRepository` just by using plain SQL queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As we don''t have any mapping configuration, it would be very useful to have
    an initialization method for the schema within the same class. **Things that change
    together should remain together**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Extra Behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding additional behavior to a Repository can be very beneficial. An example
    of this is the ability to count all the items in a given collection. You might
    think to add a method with the name count; however, as we''re trying to mimic
    a collection, a better name would instead be size:'
  prefs: []
  type: TYPE_NORMAL
- en: You're also able to place specific calculations, counters, read-optimized queries,
    or complex commands (`INSERT`, `UPDATE`, or `DELETE`) into the Repository. However,
    all behavior should still follow the Repositories' collection characteristics.
    You're encouraged to move as much logic into Domain-specific stateless Domain
    Services as possible, instead of simply adding these responsibilities to the Repository.
  prefs: []
  type: TYPE_NORMAL
- en: In some instances, you won't require the entire Aggregate for simply accessing
    small amounts of information. To solve this, you can add Repository methods to
    access these as shortcuts. You should make sure to only access data that could
    be retrieved by navigating through the Aggregate Root. As such, you shouldn't
    allow access to the private and internal areas of the Aggregate Root, as this
    would violate the laid out contractual agreement.
  prefs: []
  type: TYPE_NORMAL
- en: For some use cases, you'll require very specific queries that are compositions
    of multiple Aggregate types, each returning specific information. These queries
    can be run and then returned as a single Value Object. It's very common for Repositories
    to return Value Objects.
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself creating many use case optimal finder methods, you may
    be introducing a common code smell. This could be an indication of a misjudged
    Aggregate boundary. If, however, you're confident that the boundaries are correct,
    it could be time to explore CQRS.
  prefs: []
  type: TYPE_NORMAL
- en: Querying Repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Upon comparison, Repositories are different than a collection if we consider
    their querying ability. A Repository deals with a large set of objects that typically
    aren't in memory when the query is performed. It's not feasible to load all the
    instances of a Domain object in memory and perform a query over them.
  prefs: []
  type: TYPE_NORMAL
- en: A good solution is to pass a criterion and let the Repository handle the implementation
    details to successfully perform the operation. It might translate the criterion
    to SQL or ORM queries or iterate over an in-memory collection. However, it doesn't
    matter, because the implementation deals with it.
  prefs: []
  type: TYPE_NORMAL
- en: Specification Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common implementation for the criterion object is the Specification pattern.
    A specification is a simple predicate that takes a Domain object and returns a
    boolean. Given a Domain object, it will return true if it specifies the specification,
    and false otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We just need to add a `query` method to our Repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In-Memory Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example, if we wanted to replicate the `latestPosts` query method in
    our `PostRepository` by using a Specification for an in-memory implementation,
    it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The in-memory implementation for the `latestPosts` behavior could look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `query` method for our Repository implementation could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieving all the latest posts from the Repository is as simple as creating
    a tailored instance of the above implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: SQL Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A standard specification works well for in-memory implementations. However,
    as we don''t pre-load all the Domain objects in memory for an SQL implementation,
    we need a more specific specification for these cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL implementation for this specification could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s an example of how to query an `SQLPostRepository` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Managing Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Domain Model isn''t the place to manage transactions. The operations applied
    over the Domain Model should be agnostic to the persistence mechanism. A common
    approach to solving this problem is placing a [Facade](http://en.wikipedia.org/wiki/Facade_pattern) in
    the Application layer, thereby grouping related use cases together. When a method
    of the Facade is invoked from the UI layer, the business method begins a transaction.
    Once complete, the Facade ends the interaction by committing the transaction.
    If anything goes wrong, the transaction is rolled back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem introduced with Facades is that we have to repeat the same boilerplate
    code over and over. If we unify the way we execute use cases, we could wrap them
    in a transaction using the [Decorator pattern](http://en.wikipedia.org/wiki/Decorator_pattern):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t want to couple our Application layer with the concrete transactional
    procedure, so instead we can create a simple interface for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'A Decorator''s pattern implementation that can make any Application Service
    transactional is as easy as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Following this, we could alternatively create a Doctrine transactional session
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have everything to execute our use cases within a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Testing Repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to be sure that the Repository will work in production, we'll need
    to test its implementation. To do this, we have to test the boundaries of the
    system, making sure that our expectations are correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of a Doctrine test, the setup will be a little bit more sophisticated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have this environment set up, we can continue to test the Repository''s
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Following our earlier assertion, if we save a `Post`, we expect to find it in
    the exact same state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can move on to test finding the latest posts by specifying a given date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Testing Your Services with In-Memory Implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting up a fully persistent Repository implementation can be complex and
    result in slow execution. You should care about keeping your tests fast. Going
    through the whole database setup and then querying will slow you down enormously. Having
    an in-memory implementation could help delay persistence decisions until the end.
    We can test in the same manner as we did before, but this time, we''ll use a full-featured
    fast and simple in-memory implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Wrap-Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Repository is a mechanism that acts as a storage location. The difference
    between a DAO and a Repository is that a DAO follows a database-first approach,
    decreasing cohesion with many low-level methods to query the database. Depending
    on the underlying persistence mechanics, we''ve seen different Repository approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Collection-oriented Repositories** tend to be purer to the Domain model,
    even if they persist Entities. From the client''s point of view, a collection-oriented
    Repository looks like a collection (Set). There''s no need for explicit persistence
    calls on Entity updates, as the Repository tracks changes on the objects. We explored
    how to use Doctrine as the underlying persistence mechanism for this type of Repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistence-oriented Repositories** require explicit persistence calls, as
    they don''t track object changes. We explored Redis and plain SQL implementations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way, we discovered Specifications as a pattern that helps us query
    the database without sacrificing flexibility and cohesion. We also studied how
    to manage transactions and how to test our services with simple and fast in-memory
    Repository implementations.
  prefs: []
  type: TYPE_NORMAL
