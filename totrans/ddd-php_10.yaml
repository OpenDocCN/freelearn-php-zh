- en: Repositories
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库
- en: 'In order to interact with a Domain object, you need to hold a reference to
    it. One way of achieving this is by creation. Alternatively, you can traverse
    an association. In Object-Oriented programs, objects have links (references) to
    other objects, which makes them easily traversable, thereby contributing to the
    expressive power of our models. But here''s the catch: you need a mechanism to
    retrieve the first object, the Aggregate Root.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与领域对象交互，你需要持有它的引用。实现这一目标的一种方式是通过创建。或者，你也可以遍历一个关联。在面向对象程序中，对象有链接（引用）到其他对象，这使得它们易于遍历，从而增加了我们模型的表达能力。但是，这里有一个问题：你需要一种机制来检索第一个对象，即聚合根。
- en: Repositories act as storage locations, where a retrieved object is returned
    in the exact same state it was persisted in. In Domain-Driven Design, every Aggregate
    type typically has a unique associated Repository, which is used for its persistence
    and fetching needs. However, in the case where it's required to share an Aggregate
    object hierarchy, the types might share a Repository.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库充当存储位置，检索的对象以持久化时的相同状态返回。在领域驱动设计中，每个聚合（Aggregate）类型通常都有一个唯一的关联仓库，用于其持久化和获取需求。然而，在需要共享聚合对象层次结构的情况下，类型可能共享一个仓库。
- en: Once you've successfully retrieved the Aggregate from the Repository, every
    change you make is persisted, which removes the need to go back to the Repository.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你成功从仓库中检索到聚合，你做的任何更改都会被持久化，这样就消除了返回到仓库的需要。
- en: Definition
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义
- en: 'Martin Fowler defines a Repository as:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 马丁·福勒将仓库（Repository）定义为：
- en: The mechanism between the domain and data mapping layers, acting like an in-memory
    domain object collection. Client objects construct query specifications declaratively
    and submit them to Repository for satisfaction. Objects can be added to and removed
    from the Repository, as they can from a simple collection of objects, and the
    mapping code encapsulated by the Repository will carry out the appropriate operations
    behind the scenes. Conceptually, a Repository encapsulates the set of objects
    persisted in a data store and the operations performed over them, providing a
    more object-oriented view of the persistence layer. Repository also supports the
    objective of achieving a clean separation and one-way dependency between the domain
    and [data mapping layers](http://martinfowler.com/eaaCatalog/repository.html).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 领域和数据映射层之间的机制，充当内存中的领域对象集合。客户端对象以声明性方式构建查询规范，并将其提交给仓库以满足。对象可以被添加到仓库中，也可以从简单的对象集合中移除，仓库封装的映射代码将在幕后执行适当的操作。从概念上讲，仓库封装了在数据存储中持久化的对象集合及其上的操作，提供了对持久化层的面向对象视图。仓库还支持实现领域和数据映射层之间干净分离和单向依赖的目标。
- en: Repositories Are Not DAOs
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库不是DAO
- en: '**Data Access Objects** (**DAOs**) are a common pattern for persisting Domain
    objects into the database. It''s easy to confuse the DAO pattern with a Repository.
    The significant difference is that Repositories represent collections, while DAOs
    are closer to the database and are often far more table-centric. Typically, a
    DAO would contain CRUD methods for a particular Domain object. Let''s see how
    a common interface for a DAO might look:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据访问对象（Data Access Objects**）(**DAO**)是将领域对象持久化到数据库的常见模式。很容易将DAO模式与仓库混淆。显著的差异在于，仓库代表集合，而DAO更接近数据库，通常是更以表为中心的。通常，DAO会包含特定领域对象的CRUD方法。让我们看看一个DAO的常见接口可能是什么样的：'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A DAO interface could have multiple implementations, which could range from
    using ORM constructions to using plain SQL queries. The main problem with DAOs
    is that their responsibilities are not clearly defined. DAOs are usually perceived
    as gateways to the database, so it''s relatively easy to greatly decrease cohesion
    with many specific methods in order to query the database:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: DAO接口可能有多个实现，这些实现可能从使用ORM构造到使用纯SQL查询。DAO的主要问题在于它们的职责定义不明确。DAO通常被视为数据库的网关，因此为了查询数据库，很容易通过许多特定方法来大大降低内聚性：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the more we add new methods to implement, the harder it becomes
    to unit test the DAO, and it becomes increasingly coupled to the User object.
    This problem will grow over time, with many other contributors collaborating in
    making the Big Ball of Mud even bigger.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们添加的新方法越多，单元测试DAO就越困难，它与用户对象耦合得也越来越紧密。随着时间的推移，这个问题会逐渐扩大，许多其他贡献者共同使这个大泥球（Big
    Ball of Mud）变得更大。
- en: Collection-Oriented Repositories
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合导向的仓库
- en: Repositories mimic a collection by implementing their common interface characteristics.
    As a collection, a Repository shouldn't leak any intentions of persistence behavior,
    such as the notion of saving to a store.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库通过实现它们的通用接口特征来模拟集合。作为一个集合，仓库不应该泄露任何持久化行为的意图，例如保存到存储的概念。
- en: The underlying persistence mechanism has to support this need. You shouldn't
    be required to handle changes to the objects over their lifetime. The collection
    references the most recent changes to the object, meaning that upon each access,
    you get the latest object state.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基础的持久化机制必须支持这一需求。你不需要在对象的整个生命周期中处理对象的变更。集合引用了对象的最新的变更，这意味着在每次访问时，你都会得到最新的对象状态。
- en: Repositories implement a concrete collection type, the Set. A Set is a data
    structure with an invariant that doesn't contain duplicate entries. If you try
    to add an element that's already present to a Set, it won't be added. This is
    useful in our use case, as each Aggregate has a unique identity that's associated
    with the Root Entity.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库实现了一个具体的集合类型，即Set。Set是一种数据结构，具有一个不变性，即不包含重复条目。如果你尝试向Set中添加一个已经存在的元素，它将不会被添加。这在我们的用例中很有用，因为每个聚合体都有一个与根实体关联的唯一标识符。
- en: 'Consider, for example, that we have the following Domain Model:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下领域模型：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we wanted to persist this `Post` Entity, a simple in-memory `Post` Repository
    could be created like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要持久化这个`Post`实体，可以创建一个简单的内存`Post`仓库，如下所示：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And, as you would expect, it''s handled as a collection:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，正如你所期望的，它被当作一个集合来处理：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, from the collection's point of view, there's no need for a save
    method in the Repository. Changes affecting the object are correctly handled by
    the underlying persistence layer. Collection-oriented Repositories are the ones
    that don't need to add an Aggregate that was persisted before. This mainly happens
    with the Repositories that are memory based, but we also have ways to do this
    with the Persisted-Oriented Repositories. We'll look at this in a moment; additionally,
    we'll cover this more in depth in the [Chapter 11](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml),
    *Application*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从集合的角度来看，在仓库中不需要保存方法。影响对象的变化被底层持久化层正确处理。集合导向的仓库是那些不需要添加之前已持久化的聚合体的仓库。这主要发生在基于内存的仓库中，但我们也有方法在持久化导向的仓库中这样做。我们稍后会看到这一点；此外，我们将在[第11章](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml)，*应用*中更深入地探讨这一点。
- en: 'The first step to design a Repository is to define a collection-like interface
    for it. The interface needs to define the usual collection methods, like so:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 设计仓库的第一步是为它定义一个类似集合的接口。该接口需要定义通常的集合方法，如下所示：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For implementing such an interface, you could also use an abstract class. In
    general, when we talk about an interface, we refer to the general concept and
    not just the specific PHP interface. To keep your design simple, don't add methods
    you don't need; the Repository interface definition and its corresponding Aggregate
    should be placed in the same Module.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现这样的接口，你也可以使用一个抽象类。一般来说，当我们谈论接口时，我们指的是一般概念，而不仅仅是特定的PHP接口。为了保持你的设计简单，不要添加你不需要的方法；仓库接口定义及其相应的聚合体应该放在同一个模块中。
- en: Sometimes `remove` doesn't physically delete the Aggregate from the database.
    This strategy - where the Aggregate has a status field that's updated to a *deleted*
    value - is known as a *soft delete*. Why is this approach interesting? It can
    be interesting for auditing changes and performance. In those cases, you can instead
    mark the Aggregate as disabled or *logically removed*. The interface could be
    updated accordingly by removing the removal methods or providing disable behavior
    in the Repository.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有时`remove`操作并不会在数据库中实际删除聚合体。这种策略——其中聚合体有一个状态字段被更新为*已删除*的值——被称为*软删除*。为什么这种方法有趣？它对于审计变更和性能来说可能很有趣。在这种情况下，你可以将聚合体标记为禁用或*逻辑删除*。接口可以根据需要相应地更新，通过移除删除方法或在仓库中提供禁用行为。
- en: 'Another important aspect of Repositories are the finder methods, like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库的另一个重要方面是查找方法，如下所示：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we suggested in [Chapter 4](0c7239ad-9b34-48aa-b60c-072a7b07273f.xhtml),
    *Entities*, we prefer Application-Generated Identities. The best place to generate
    a new Identity for an Aggregate is its Repository. So to retrieve the globally
    unique ID for a `Post`, a logical place to include it is in `PostRepository`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第 4 章](0c7239ad-9b34-48aa-b60c-072a7b07273f.xhtml) 中所建议的，*实体*，我们更喜欢应用程序生成的标识符。为聚合生成新标识符的最佳位置是其存储库。因此，为了检索
    `Post` 的全局唯一 ID，一个合理的做法是在 `PostRepository` 中包含它：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code responsible for building up each `Post` instance calls `nextIdentity`
    to get a unique identifier, `PostId`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 负责构建每个 `Post` 实例的代码调用 `nextIdentity` 来获取一个唯一标识符，`PostId`：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Some developers favor placing the implementation close to the interface definition
    as a subpackage of the Module. However, because we want a clear Separation of
    Concerns, we recommend instead placing it inside the Infrastructure layer.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者倾向于将实现放置在接口定义附近，作为模块的子包。然而，因为我们希望有一个清晰的关注点分离，所以我们建议将其放置在基础设施层内部。
- en: In-Memory Implementation
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存实现
- en: 'As Uncle Bob wrote in [Screaming Architecture](http://blog.8thlight.com/uncle-bob/2011/09/30/Screaming-Architecture.html):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如 Uncle Bob 在 [Screaming Architecture](http://blog.8thlight.com/uncle-bob/2011/09/30/Screaming-Architecture.html)
    中所写：
- en: A good software architecture allows decisions about frameworks, databases, web-servers,
    and other environmental issues and tools, to be deferred and delayed. A good architecture
    makes it unnecessary to decide on Rails, or Spring, or Hibernate, or Tomcat or
    MySql, until much later in the project. A good architecture makes it easy to change
    your mind about those decisions too. A good architecture emphasizes the use-cases
    and decouples them from peripheral concerns.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的软件架构允许将关于框架、数据库、Web 服务器和其他环境问题和工具的决定推迟和延迟。一个好的架构使得在项目后期才决定 Rails、Spring、Hibernate、Tomcat
    或 MySql 成为可能。一个好的架构还使得改变这些决定变得容易。一个好的架构强调使用案例，并将它们与外围关注点解耦。
- en: In the early stages of your application, a fast in-memory implementation could
    come in handy. It's something you could use to mature other parts of your system,
    allowing you to delay database decisions to the correct moment. An in-memory Repository
    is simple, fast, and easy to implement.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的早期阶段，一个快速的内存实现可能会很有用。你可以用它来成熟系统的其他部分，允许你将数据库决策推迟到正确的时间点。内存存储库简单、快速且易于实现。
- en: 'For our `Post` Repository, an in-memory hash map is enough to provide all the
    functionality we need:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 `Post` 存储库，一个内存中的哈希表就足以提供我们需要的所有功能：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Doctrine ORM
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Doctrine ORM
- en: We've talked about [Doctrine](http://www.doctrine-project.org/) in past chapters
    quite a bit. Doctrine is a set of libraries for database storage and object mapping.
    It comes bundled with the popular [Symfony2 web framework](http://symfony.com/) by
    default and, among other features, it allows you to easily decouple your application
    from the persistence layer, thanks to the [Data Mapper pattern](http://martinfowler.com/eaaCatalog/dataMapper.html).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在过去的章节中已经多次提到了 [Doctrine](http://www.doctrine-project.org/)。Doctrine 是一套用于数据库存储和对象映射的库。它默认捆绑了流行的
    [Symfony2 网络框架](http://symfony.com/)，并且，在众多特性中，它允许你通过 [数据映射模式](http://martinfowler.com/eaaCatalog/dataMapper.html)轻松地将你的应用程序与持久层解耦。
- en: Meanwhile, the ORM stands over a powerful database abstraction layer that enables
    database interaction through an SQL dialect called **Doctrine Query Language**
    (**DQL**), which is inspired by the famous Java Hibernate framework.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，ORM 位于一个强大的数据库抽象层之上，它通过一个称为 **Doctrine 查询语言**（**DQL**）的 SQL 语法来实现数据库交互，该语言受到了著名的
    Java Hibernate 框架的启发。
- en: 'If we''re going to use Doctrine ORM, the first task to complete is adding the
    dependencies to our project through [Composer](https://getcomposer.org/):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要使用 Doctrine ORM，第一个任务是完成通过 [Composer](https://getcomposer.org/) 向我们的项目中添加依赖项：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Object Mapping
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象映射
- en: The mapping between your Domain objects and the database can be considered an
    implementation detail. The Domain lifecycle shouldn't be aware of these persistence
    details. As such, the mapping information should be defined as part of the Infrastructure
    layer, outside the Domain, and as the implementation for the Repositories.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您的领域对象与数据库之间的映射可以被视为实现细节。领域生命周期不应该意识到这些持久性细节。因此，映射信息应该作为基础设施层的一部分来定义，位于领域之外，并且作为存储库的实现。
- en: Doctrine Custom Mapping Types
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Doctrine 自定义映射类型
- en: 'As our `Post` Entity is composed of Value Objects like `Body` or `PostId`,
    it''s a good idea to make Custom Mapping Types or use Doctrine Embeddables for
    them, as seen in the Value Objects chapter. This will make the object mapping
    considerably easier:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 `Post` 实体由像 `Body` 或 `PostId` 这样的值对象组成，因此制作自定义映射类型或使用 Doctrine Embeddables
    是一个好主意，正如在值对象章节中看到的那样。这将使对象映射变得容易得多：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Don''t forget to implement the `__toString` magic method on the `PostId` Value
    Object, as Doctrine requires this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在 `PostId` 值对象上实现 `__toString` 魔法方法，因为 Doctrine 需要这个：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Doctrine offers multiple formats for the mapping, such as YAML, XML, or annotations.
    XML is our preferred choice, as it provides robust IDE autocompletion:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Doctrine 提供了多种映射格式，如 YAML、XML 或注解。XML 是我们的首选选择，因为它提供了强大的 IDE 自动完成：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Exercise
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Write down what the mapping would look like in the case of using the Doctrine
    Embeddables approach. Take a look at Chapter Value Objects or Chapter Entities if
    you need some help.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用 Doctrine Embeddables 方法的情况下映射看起来会是什么样子写下来。如果你需要一些帮助，请查看第 值对象或实体章节。
- en: Entity Manager
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体管理器
- en: 'The `EntityManager` is the central access point for the ORM functionality.
    Bootstrapping it is easy:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityManager` 是 ORM 功能的中心访问点。启动它很容易：'
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Remember to configure it according to your needs and setup.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记得根据你的需求和设置进行配置。
- en: DQL Implementation
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DQL 实现
- en: 'In the case of this Repository, we''ll only need the `EntityManager` to retrieve
    Domain objects directly from the database:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个仓储的情况下，我们只需要 `EntityManager` 直接从数据库中检索领域对象：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you check some Doctrine examples out there, you may find that after running
    persist or remove, flush should be called. But as seen in our proposal, there's
    no call to `flush`. Flushing and dealing with transactions is delegated to the
    Application Service. That's why you can work with Doctrine, considering that flushing
    all the changes on Entities will happen at the end of the request. In terms of
    performance, one flush call is best.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查一些 Doctrine 示例，你可能会发现运行持久化或删除后应该调用 `flush`。但是，正如我们的提案中看到的，没有调用 `flush`。刷新和处理事务被委托给应用程序服务。这就是为什么你可以使用
    Doctrine，考虑到所有实体的更改将在请求结束时刷新。从性能的角度来看，一个刷新调用是最好的。
- en: Persistence-Oriented Repository
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向持久化的仓储
- en: There are times when collection-oriented Repositories don't fit well with our
    persistence mechanism. If you don't have a unit of work, keeping track of Aggregate
    changes is a difficult task. The only way to persist such changes is by explicitly
    calling `save`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，面向集合的仓储与我们的持久化机制不太匹配。如果你没有工作单元，跟踪聚合变化是一项艰巨的任务。唯一持久化这些变化的方法是显式调用 `save`。
- en: 'The interface definition for a persistence-oriented Repository is similar to
    how you would define a collection-oriented equivalent:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 面向持久化的仓储的接口定义类似于你定义面向集合的等效仓储：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this case, we now have save and `saveAll` methods, which provide functionality
    similar to the previous add and `addAll` methods. However, the important difference
    is how the client uses them. Within a collection-oriented style, you use the add
    methods just once: when the Aggregate is created. In a persistence-oriented style,
    you''ll not only use the `save` action after creating a new Aggregate, but also
    when an existing one is modified:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们现在有保存和 `saveAll` 方法，它们提供了类似于之前添加和 `addAll` 方法的功能。然而，重要的区别在于客户端如何使用它们。在面向集合的风格中，你只需使用一次添加方法：当聚合创建时。在面向持久化的风格中，你不仅在创建新的聚合后使用
    `save` 动作，而且在现有的聚合被修改时也会使用：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Other than this difference, the details are only in the implementation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个区别之外，细节仅在于实现中。
- en: Redis Implementation
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redis 实现
- en: The [Redis](http://redis.io/) is an in-memory key value that can be used as
    a cache or store.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[Redis](http://redis.io/) 是一个内存中的键值存储，可以用作缓存或存储。'
- en: Depending on the circumstances, we could consider using Redis as a store for
    our Aggregates.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 根据情况，我们可以考虑将 Redis 作为我们的聚合存储。
- en: 'To get started, make sure you have a PHP client to connect to Redis. A good
    one that we recommend is [Predis](https://github.com/nrk/predis):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，确保你有一个 PHP 客户端来连接 Redis。我们推荐的一个好的是 [Predis](https://github.com/nrk/predis)：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: SQL Implementation
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 实现
- en: 'In a classic example, we could create a simple [PDO](http://php.net/manual/en/book.pdo.php) implementation
    for our `PostRepository` just by using plain SQL queries:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个经典示例中，我们可以通过使用纯 SQL 查询为我们的 `PostRepository` 创建一个简单的 [PDO](http://php.net/manual/en/book.pdo.php)
    实现：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we don''t have any mapping configuration, it would be very useful to have
    an initialization method for the schema within the same class. **Things that change
    together should remain together**:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有任何映射配置，在同一个类中为模式提供一个初始化方法将非常有用。**共同变化的事物应该保持在一起**：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Extra Behavior
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外行为
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The implementation could look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可能看起来像这样：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Adding additional behavior to a Repository can be very beneficial. An example
    of this is the ability to count all the items in a given collection. You might
    think to add a method with the name count; however, as we''re trying to mimic
    a collection, a better name would instead be size:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 向存储库添加额外行为可能非常有益。一个例子是能够计算给定集合中所有项的能力。你可能会想到添加一个名为count的方法；然而，由于我们试图模仿集合，更好的名称应该是size：
- en: You're also able to place specific calculations, counters, read-optimized queries,
    or complex commands (`INSERT`, `UPDATE`, or `DELETE`) into the Repository. However,
    all behavior should still follow the Repositories' collection characteristics.
    You're encouraged to move as much logic into Domain-specific stateless Domain
    Services as possible, instead of simply adding these responsibilities to the Repository.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你还能够在存储库中放置特定的计算、计数器、读取优化查询或复杂命令（`INSERT`、`UPDATE`或`DELETE`）。然而，所有行为仍然应该遵循存储库的集合特征。你被鼓励尽可能地将逻辑移动到领域特定的无状态领域服务中，而不是简单地将这些责任添加到存储库中。
- en: In some instances, you won't require the entire Aggregate for simply accessing
    small amounts of information. To solve this, you can add Repository methods to
    access these as shortcuts. You should make sure to only access data that could
    be retrieved by navigating through the Aggregate Root. As such, you shouldn't
    allow access to the private and internal areas of the Aggregate Root, as this
    would violate the laid out contractual agreement.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能不需要整个聚合来简单地访问少量信息。为了解决这个问题，你可以添加存储库方法来作为快捷方式访问这些信息。你应该确保只访问可以通过聚合根导航检索到的数据。因此，你不应该允许访问聚合根的私有和内部区域，因为这会违反既定的合同协议。
- en: For some use cases, you'll require very specific queries that are compositions
    of multiple Aggregate types, each returning specific information. These queries
    can be run and then returned as a single Value Object. It's very common for Repositories
    to return Value Objects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些用例，你可能需要非常具体的查询，这些查询是多个聚合类型的组合，每个返回特定的信息。这些查询可以运行并作为单个值对象返回。存储库返回值对象是非常常见的。
- en: If you find yourself creating many use case optimal finder methods, you may
    be introducing a common code smell. This could be an indication of a misjudged
    Aggregate boundary. If, however, you're confident that the boundaries are correct,
    it could be time to explore CQRS.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己正在创建许多用例最优的查找方法，你可能引入了一个常见的代码异味。这可能表明对聚合边界的判断有误。然而，如果你确信边界是正确的，那么可能是时候探索CQRS了。
- en: Querying Repositories
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询存储库
- en: Upon comparison, Repositories are different than a collection if we consider
    their querying ability. A Repository deals with a large set of objects that typically
    aren't in memory when the query is performed. It's not feasible to load all the
    instances of a Domain object in memory and perform a query over them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较时，如果考虑到它们的查询能力，存储库与集合不同。存储库处理大量对象，这些对象在执行查询时通常不在内存中。在内存中加载域对象的全部实例并对其执行查询是不切实际的。
- en: A good solution is to pass a criterion and let the Repository handle the implementation
    details to successfully perform the operation. It might translate the criterion
    to SQL or ORM queries or iterate over an in-memory collection. However, it doesn't
    matter, because the implementation deals with it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的解决方案是传递一个标准并让存储库处理实现细节以成功执行操作。它可能将标准转换为SQL或ORM查询，或者遍历内存中的集合。然而，这并不重要，因为实现会处理它。
- en: Specification Pattern
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范模式
- en: 'A common implementation for the criterion object is the Specification pattern.
    A specification is a simple predicate that takes a Domain object and returns a
    boolean. Given a Domain object, it will return true if it specifies the specification,
    and false otherwise:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标准对象的一个常见实现是规范模式。规范是一个简单的谓词，它接受一个域对象并返回一个布尔值。给定一个域对象，如果它指定了规范，则返回true，否则返回false：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We just need to add a `query` method to our Repository:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要给我们的存储库添加一个`query`方法：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In-Memory Implementation
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存实现
- en: 'As an example, if we wanted to replicate the `latestPosts` query method in
    our `PostRepository` by using a Specification for an in-memory implementation,
    it would look like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想通过使用内存实现的规范来在我们的 `PostRepository` 中复制 `latestPosts` 查询方法，它可能看起来像这样：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The in-memory implementation for the `latestPosts` behavior could look like
    this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`latestPosts` 行为的内存实现可能看起来像这样：'
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `query` method for our Repository implementation could look like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们存储库实现的 `query` 方法可能看起来像这样：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Retrieving all the latest posts from the Repository is as simple as creating
    a tailored instance of the above implementation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从存储库中检索所有最新帖子就像创建上述实现的一个定制实例一样简单：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: SQL Implementation
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 实现
- en: 'A standard specification works well for in-memory implementations. However,
    as we don''t pre-load all the Domain objects in memory for an SQL implementation,
    we need a more specific specification for these cases:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 标准规范对于内存实现来说效果很好。然而，由于我们不会预先在内存中加载所有领域对象，对于 SQL 实现，我们需要一个更具体的规范来处理这些情况：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The SQL implementation for this specification could look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此规范的 SQL 实现可能看起来像这样：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And here''s an example of how to query an `SQLPostRepository` implementation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何查询 `SQLPostRepository` 实现的例子：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Managing Transactions
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理事务
- en: 'The Domain Model isn''t the place to manage transactions. The operations applied
    over the Domain Model should be agnostic to the persistence mechanism. A common
    approach to solving this problem is placing a [Facade](http://en.wikipedia.org/wiki/Facade_pattern) in
    the Application layer, thereby grouping related use cases together. When a method
    of the Facade is invoked from the UI layer, the business method begins a transaction.
    Once complete, the Facade ends the interaction by committing the transaction.
    If anything goes wrong, the transaction is rolled back:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型不是管理事务的地方。在领域模型上应用的操作应该对持久化机制无感知。解决此问题的常见方法是在应用程序层放置一个 [外观模式](http://en.wikipedia.org/wiki/Facade_pattern)，从而将相关的用例组合在一起。当从
    UI 层调用外观方法时，业务方法开始一个事务。一旦完成，外观通过提交事务结束交互。如果发生任何错误，事务将被回滚：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The problem introduced with Facades is that we have to repeat the same boilerplate
    code over and over. If we unify the way we execute use cases, we could wrap them
    in a transaction using the [Decorator pattern](http://en.wikipedia.org/wiki/Decorator_pattern):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用外观（Facades）引入的问题是我们必须反复重复相同的样板代码。如果我们统一执行用例的方式，我们可以使用 [装饰器模式](http://en.wikipedia.org/wiki/Decorator_pattern)
    将它们包装在事务中：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We don''t want to couple our Application layer with the concrete transactional
    procedure, so instead we can create a simple interface for it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望将应用程序层与具体的交易程序耦合起来，因此我们可以为它创建一个简单的接口：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A Decorator''s pattern implementation that can make any Application Service
    transactional is as easy as this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以将任何应用程序服务转换为事务性的装饰器模式实现就像这样简单：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Following this, we could alternatively create a Doctrine transactional session
    implementation:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们可以选择创建一个 Doctrine 事务会话实现：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we have everything to execute our use cases within a transaction:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了在事务中执行用例所需的一切：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Testing Repositories
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试存储库
- en: In order to be sure that the Repository will work in production, we'll need
    to test its implementation. To do this, we have to test the boundaries of the
    system, making sure that our expectations are correct.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保存储库在生产环境中能够正常工作，我们需要测试其实现。为此，我们必须测试系统的边界，确保我们的预期是正确的。
- en: 'In the case of a Doctrine test, the setup will be a little bit more sophisticated:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Doctrine 测试的情况下，设置将稍微复杂一些：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once we have this environment set up, we can continue to test the Repository''s
    behavior:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了此环境，我们就可以继续测试存储库的行为：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Following our earlier assertion, if we save a `Post`, we expect to find it in
    the exact same state.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前的断言，如果我们保存一个 `Post`，我们期望在完全相同的状态中找到它。
- en: 'Now we can move on to test finding the latest posts by specifying a given date:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续测试通过指定一个给定日期来查找最新帖子：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Testing Your Services with In-Memory Implementations
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内存实现测试您的服务
- en: 'Setting up a fully persistent Repository implementation can be complex and
    result in slow execution. You should care about keeping your tests fast. Going
    through the whole database setup and then querying will slow you down enormously. Having
    an in-memory implementation could help delay persistence decisions until the end.
    We can test in the same manner as we did before, but this time, we''ll use a full-featured
    fast and simple in-memory implementation:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个完全持久的仓库实现可能很复杂，并可能导致执行缓慢。你应该关心保持你的测试快速。通过整个数据库设置然后查询会极大地减慢你的速度。拥有一个内存实现可以帮助延迟持久化决策直到最后。我们可以像以前一样进行测试，但这次，我们将使用一个功能齐全、快速简单的内存实现：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Wrap-Up
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'A Repository is a mechanism that acts as a storage location. The difference
    between a DAO and a Repository is that a DAO follows a database-first approach,
    decreasing cohesion with many low-level methods to query the database. Depending
    on the underlying persistence mechanics, we''ve seen different Repository approaches:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库是一种充当存储位置的机制。DAO 和仓库之间的区别在于，DAO 采用数据库优先的方法，通过许多低级方法查询数据库，从而降低内聚性。根据底层持久化机制的不同，我们看到了不同的仓库方法：
- en: '**Collection-oriented Repositories** tend to be purer to the Domain model,
    even if they persist Entities. From the client''s point of view, a collection-oriented
    Repository looks like a collection (Set). There''s no need for explicit persistence
    calls on Entity updates, as the Repository tracks changes on the objects. We explored
    how to use Doctrine as the underlying persistence mechanism for this type of Repository.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向集合的仓库**倾向于更纯粹地符合领域模型，即使它们持久化实体。从客户端的角度来看，一个面向集合的仓库看起来就像一个集合（集合）。在实体更新时，不需要对实体进行显式的持久化调用，因为仓库跟踪对象的变化。我们探讨了如何使用
    Doctrine 作为此类仓库的底层持久化机制。'
- en: '**Persistence-oriented Repositories** require explicit persistence calls, as
    they don''t track object changes. We explored Redis and plain SQL implementations.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向持久化的仓库**需要显式的持久化调用，因为它们不跟踪对象变化。我们探讨了 Redis 和纯 SQL 的实现。'
- en: Along the way, we discovered Specifications as a pattern that helps us query
    the database without sacrificing flexibility and cohesion. We also studied how
    to manage transactions and how to test our services with simple and fast in-memory
    Repository implementations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们发现规范（Specification）是一种帮助我们查询数据库而不牺牲灵活性和内聚性的模式。我们还研究了如何管理事务以及如何使用简单快速的内存仓库实现来测试我们的服务。
