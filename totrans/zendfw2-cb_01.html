<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Zend Framework 2 Basics"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Zend Framework 2 Basics</h1></div></div></div><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up a Zend Framework 2 project</li><li class="listitem" style="list-style-type: disc">Handling routines</li><li class="listitem" style="list-style-type: disc">Understanding dependency injection</li><li class="listitem" style="list-style-type: disc">Using configurations to your benefit</li><li class="listitem" style="list-style-type: disc">The EventManager and Bootstrap classes</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Introduction</h1></div></div></div><p>In this chapter we will go through a basic Zend Framework 2 application, from download, to setup, to running it. If you are unfamiliar with how Zend Framework 2 works, and the best way to install it, you can use this chapter as a reference. Further on in the chapter, we will get somewhat deeper in the framework by looking at the <span class="strong"><strong>dependency injection</strong></span> (<span class="strong"><strong>DI</strong></span>) and how it can help us code more efficiently. Lastly we will go more into the details of the configuration options, the <code class="literal">EventManager</code> and <code class="literal">ModuleManager</code>.</p></div></div>
<div class="section" title="Setting up a Zend Framework 2 project"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Setting up a Zend Framework 2 project</h1></div></div></div><p>Nothing is <a id="id0" class="indexterm"/>more exciting than setting up a new project in our favourite framework. Every time we start a new project we begin with a clean slate.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Getting ready</h2></div></div></div><p>Before you can set up a new Zend Framework 2 application you need to make sure you have the following items ready:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A web server such as Apache running PHP Version 5.3.3 or higher that you can reach from a web browser</li><li class="listitem" style="list-style-type: disc">Git</li></ul></div><p>If you <a id="id1" class="indexterm"/>don't have everything ready as mentioned, you are best off reading the topics mentioned in the <span class="emphasis"><em>See also</em></span> section of this recipe (every topic we explain in this chapter is called a recipe) before you continue reading here.</p><p>We are assuming that Zend Framework 2 will be used on a Linux-based platform running an Apache 2 web server; this means that commands might not directly work on a Windows platform. Windows users, however, can set up a virtual machine with Linux on it to make full use of the book.</p><p>To install a virtual machine on Windows, we can use an application called Oracle VM VirtualBox, which is freely available. We can go to <a class="ulink" href="http://www.virtualbox.org">www.virtualbox.org</a> and download plus install the latest version of VirtualBox, we can go to VirtualBoxes (<a class="ulink" href="http://virtualboxes.org/images/ubuntu">http://virtualboxes.org/images/ubuntu</a>) and download a preconfigured virtual machine from there.</p><p>All we have to do on the VirtualBoxes website is click on the latest Ubuntu (which is a distribution of Linux) link in the list, please take note of the username and password displayed there as we will need it later to login. Once the image is downloaded, it can be made ready by following the instructions in the documentation that can be found on the VirtualBoxes site (<a class="ulink" href="http://virtualboxes.org/doc/register-and-load-a-downloaded-image">http://virtualboxes.org/doc/register-and-load-a-downloaded-image</a>).</p><p>Assuming the image is imported we can easily start up the virtual machine and put in our username and password that has been supplied with the downloaded virtual machine.</p><p>Once logged in to the virtual machine we need to make sure Git is installed, which can be done easily by typing in the following command (mind that the dollar sign is the command prompt, and not the command we actually need to type):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install git</strong></span>
</pre></div><p>If Git wasn't installed, the system will ask you to install Git, which can be done by pressing the <span class="emphasis"><em>Y</em></span> key, followed by the <span class="emphasis"><em>Enter</em></span> key, on the other hand if Git was already installed, than it will not do anything and tell you it already is installed.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>How to do it…</h2></div></div></div><p>First of all, we need the Zend Framework 2 skeleton so we can easily create a new project. A skeleton is a template structure that can be used to start developing with an application, and in this case it creates a template for us to develop within Zend Framework. Fortunately doing this is relatively easy, and almost never causes any problems, and when it does, it is usually related to Git not being able to retrieve the code. When Git isn't able to retrieve the skeleton, please make sure there are no spelling mistakes in the command, and that Git has outside access (we can test this by typing <code class="literal">ping Github.com</code> and see whether we get a response back).</p><p>The method <a id="id2" class="indexterm"/>we are going to use to retrieve the skeleton is called <span class="strong"><strong>cloning</strong></span>, through a version control system called Git. Cloning the source code will make sure we always get the latest version that the developer (in this case Zend itself) has put online.</p><div class="section" title="Cloning the skeleton"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Cloning the skeleton</h3></div></div></div><p>We can <a id="id3" class="indexterm"/>clone the skeleton—and almost everything else on Github for that matter — through use of the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git clone git://github.com/zendframework/</strong></span>
<span class="strong"><strong>  ZendSkeletonApplication.git</strong></span>
</pre></div></div><div class="section" title="Moving the skeleton"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Moving the skeleton</h3></div></div></div><p>Once finished <a id="id4" class="indexterm"/>we can go into the newly created folder called <code class="literal">ZendSkeletonApplication</code>, and copy and paste everything in there over to our web server document root. On a Linux system this is usually <code class="literal">/var/www</code> (this is also the case when we use Zend Server, as described in the <a class="link" href="apa.html" title="Appendix A. Setting up the Essentials">Appendix</a>, <span class="emphasis"><em>Setting up the Essentials</em></span>). We can do this, for example, by typing the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd ZendSkeletonApplication</strong></span>
<span class="strong"><strong>$ mv ./* /var/www –f</strong></span>
<span class="strong"><strong>$ cd /var/www</strong></span>
</pre></div></div><div class="section" title="Initializing the Composer"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Initializing the Composer</h3></div></div></div><p>When everything is<a id="id5" class="indexterm"/> copied over, we are going to initialize the project by typing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php composer.phar install</strong></span>
</pre></div><p>Now the <span class="strong"><strong>Command Line Interface</strong></span> (<span class="strong"><strong>CLI</strong></span>) of PHP executes <code class="literal">composer.phar</code>, which will in this instance, download and install the Zend Framework 2 library and set up a simple project for us to be able to work in.</p><p>This command can take a long time before it is successfully executed, as Composer needs to do a lot of things before it tells you that Zend Framework 2 is ready for use, we won't go into the details of the workings of Composer here, as it is already discussed in the <a class="link" href="apa.html" title="Appendix A. Setting up the Essentials">Appendix</a>, <span class="emphasis"><em>Setting up the Essentials</em></span>.</p><p>Once this command has been completed we need to make sure our web server document root is changed to match the layout of the skeleton. It is common practice that Zend Framework 2 uses the <code class="literal">public</code> folder as a main landing point for the application. The structure of the Zend Framework 2 skeleton allows us to bind the user to the <code class="literal">public</code> folder, while all our logic is safely outside the public area.</p><p>In essence<a id="id6" class="indexterm"/> this means we need to <code class="literal">root</code> or <code class="literal">jail</code> the web server in using the <code class="literal">public</code> folder first before we can actually see anything that we just installed. We want to <code class="literal">root</code> or <code class="literal">jail</code> the web server because we don't want the outside world to be able to abuse our web server more than necessary, and rooting or jailing makes sure that the web server itself has no access to any other folders than what it is jailed to, thus making our server a bit more secure.</p><p>In my personal case this means changing the Apache 2 configuration. In most Linux-based systems it will be the Apache web server that is serving our web requests.</p><p>The easiest thing that you can do is find your web server configuration (usually located in <code class="literal">/etc/apache2</code> and append the DocumentRoot with <code class="literal">/public</code>. For me this would change the document root from <code class="literal">/var/www' to '/var/www/public</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>If you are using Apache, you need to check if the <code class="literal">AllowOverride</code> setting is set correctly, this can be found in the same section as your document root and should reflect the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>AllowOverride FileInfo</strong></span>
</pre></div></div></div><p>Finally we need to restart the Apache web server, which can be done by the following command if you are logged in as a root user or invoke it by prepending the command with <code class="literal">sudo</code>, which tells the server that we want to execute it as a super user.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ apache2ctl restart</strong></span>
</pre></div><p>Now we are able to check our browser and see what we have actually done. We now simply go with a web browser to the project created by typing in the URL, in my case this would be the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>http://localhost/</strong></span>
</pre></div><p>This will result in the following screen:</p><div class="mediaobject"><img src="graphics/4841OS_01_01.jpg" alt="Initializing the Composer"/></div><p>Congratulations, you have now set up a basic Zend Framework 2 application.</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>How it works…</h2></div></div></div><p>After getting the basic Zend Framework 2 skeleton working, it is the perfect time to install the ZFTool. The ZFTool is a utility module that comes in handy when we want to list the current modules in our project, or add a new module, or even set up a new project. It also contains an extremely useful class-map generator that we can use in the somewhat more advanced areas of Zend Framework 2.</p><p>We can install this utility by using the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /var/www</strong></span>
<span class="strong"><strong>$ mkdir -p vendor/zftool</strong></span>
<span class="strong"><strong>$ cd vendor/zftool</strong></span>
<span class="strong"><strong>$ wget https://packages.zendframework.com/zftool.phar</strong></span>
</pre></div><p>Although we already set up our Zend Framework 2 skeleton through the composer, it might be a fun thing to show you how you can easily set up a new project through the ZFTool. </p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd /var/www</strong></span>
<span class="strong"><strong>$ php vendor/zftool/zftool.phar create project new-project</strong></span>
</pre></div><p>The preceding command will create a new Zend Framework 2 skeleton project in the folder <code class="literal">/var/www/new-project</code>. In turn this means that the document root for our new project should be set to <code class="literal">/var/www/new-project/public</code>.</p><p>To complete the Zend Framework 2 application in our new-project, we can simply go to the new-project directory and execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd new-project</strong></span>
<span class="strong"><strong>$ php composer.phar install</strong></span>
</pre></div><p>Another handy command of the ZFTool is the creation and display of modules in our project. The ZFTool can easily display a list of modules that we currently use (with larger applications we tend to lose sight of the modules) and the ability to create a new skeleton module for our application. To see a list of the current modules used in our application we can use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php ../vendor/zftool/zftool.phar modules</strong></span>
</pre></div><p>To create a new module named <code class="literal">wow-module</code> in our project based in the directory <code class="literal">/var/www/new-project</code> we can use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php ../vendor/zftool/zftool.phar create module wow-module</strong></span>
<span class="strong"><strong>  /var/www/new-project</strong></span>
</pre></div><p>Giving the path to the application is optional, but if we are using it with multiple projects on the same machine, it is best to make sure that we have the right path for our project.</p><p>And now for the last and probably the most useful command in the ZFTool box, the class-map generator. A class-map file is a file that has all the classes of a project with their respective paths declared, which makes it easier for the PHP auto loaders to load the class file. Normally class files are found in paths that we know of, creating a small lag because the auto loader actually needs to search for the file. With a class-map file, however, this is not the case as the auto load can immediately find the file required.</p><p>Class-mapping is a big issue in Zend Framework 2 because a bad class mapping can make a good application terribly slow, and to be completely fair Zend Framework 2 can use all the speed it can get.</p><p>What the class-map generator does is create a file that contains all the classes and paths that can be autoloaded. That way we don't have to worry about where the classes are located.</p><p>To generate a new class-map file, we can use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php zftool.phar classmap generate &lt;directory&gt; &lt;file&gt; -w</strong></span>
</pre></div><p>The command requires us to give in two different parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;directory</code>&gt;: The directory that needs to have the classes indexed. For example, this can be a new library you added to the <code class="literal">vendor</code> directory.</li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;file&gt;</code>: This is the class-map file the ZFTool needs to generate. Our auto loader in Zend Framework 2 needs to pick this file up, so we need to make sure that the ZFTool can find the file. If you don't specify a file, it will create a file called <code class="literal">autoload_classmap.php</code> in the current working directory.</li></ul></div><p>Most of the time it is necessary to append a class-map file instead of overwriting it, if you want to append it you can simply change <code class="literal">-w</code> with <code class="literal">-a</code>.</p><p>An example of a class-map file is the <code class="literal">autoload_namespaces.php</code> file in the <code class="literal">vendor/composer</code> directory, and it looks a little bit like this:</p><div class="informalexample"><pre class="programlisting">&lt;?php
return array(
  // Every class beginning with namespace Zend\ will be 
  // searched in this specific directory
  'Zend\\' =&gt; array(
    __DIR__ . '/../zendframework/zendframework/library'
  ),
  'ZendTest\\' =&gt; array(
    __DIR__ . '/../zendframework/zendframework/tests'
  ),
);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>There's more…</h2></div></div></div><p>There are also other ways of installing the ZFTool, some are just as easy as using the composer, so we'll cover two other methods of installing the ZFTool. That way we give ourselves the broadest options available to use.</p><p>Another method of installing ZFTool is by utilizing git, and thus cloning the source code from the repository itself. This however gets the current master version, which can be a bit buggy.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd vendor</strong></span>
<span class="strong"><strong>$ git clone https://github.com/zendframework/ZFTool.git</strong></span>
<span class="strong"><strong>$ cd ZFTool</strong></span>
<span class="strong"><strong>$ php ./zf.php</strong></span>
</pre></div><p>Instead of <code class="literal">zftool.phar</code> we have now got the <code class="literal">zf.php</code> file at our disposal, which can be used in exactly the same way. Now we have covered all the different options on installing ZFTool.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Making sure you have all that you need</em></span> recipe in the <a class="link" href="apa.html" title="Appendix A. Setting up the Essentials">Appendix</a>, <span class="emphasis"><em>Setting up the Essentials</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Downloading Zend Framework 2 and finding its documentation</em></span> recipe in the <a class="link" href="apa.html" title="Appendix A. Setting up the Essentials">Appendix</a>, <span class="emphasis"><em>Setting up the Essentials</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Composer and its uses within Zend Framework 2</em></span> recipe in the <a class="link" href="apa.html" title="Appendix A. Setting up the Essentials">Appendix</a>, <span class="emphasis"><em>Setting up the Essentials</em></span></li><li class="listitem" style="list-style-type: disc">Apache web server <a class="ulink" href="http://apache.org/">http://apache.org/</a></li><li class="listitem" style="list-style-type: disc">PHP website <a class="ulink" href="http://php.net">http://php.net</a></li></ul></div></div></div>
<div class="section" title="Handling routines"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Handling routines</h1></div></div></div><p>An important <a id="id7" class="indexterm"/>aspect (if not the most important one) is the routing within Zend Framework 2. In its most basic form routing tells the framework how the user should get from page A to page B, and what needs to be done to arrive at that destination. That is why we generally think this is the most important part to understand if you are just starting out.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>How to do it…</h2></div></div></div><p>To define a<a id="id8" class="indexterm"/> route we can simply go into one of the configuration files and add the router configuration to there.</p><div class="section" title="Setting up routing"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Setting up routing</h3></div></div></div><p>Let's look at our<a id="id9" class="indexterm"/> simple (<code class="literal">Segment</code>) configuration as follows (file: <code class="literal">/module/Application/config/module.config.php</code>):</p><div class="informalexample"><pre class="programlisting">return array(
  // Here we define our route configuration
  'routes' =&gt; array( 

    // We give this route the name 'website'
    'website' =&gt; array( 

      // The route type is of the class:
      // Zend\Mvc\Router\Http\Segment
      'type' =&gt; 'segment', 

        // Lets set the options for this route
        'options' =&gt; array( 

          /*
            The route that we want to match is /website
            where we can optionally add a controller name
            and an action name. For example:
              /website/index/index
          */ 
          'route' =&gt; '/website[/:controller[/:action]]',

          /*
            We don't want to accept everything, but this
            regex makes sure we only accept alpha-
            numeric characters and a dash and underscore.

            In our instance we want to check this for the
            action and the controller.
          */
          'constraints' =&gt; array( 
            'controller' =&gt; '[a-zA-Z][a-zA-Z0-9_-]*',
            'action' =&gt; '[a-zA-Z][a-zA-Z0-9_-]*'
          ),

          /*
           We want to make sure that if the user only 
           types /website in the URL bar it will actually
           go somewhere. We defined that here.
          */
          'defaults' =&gt; array( 
            'controller' =&gt; 'Website\Controller\Index', 
            'action' =&gt; 'index'
          ),
        ),
      ),
    ),
  ),
);</pre></div><p>With this basic <a id="id10" class="indexterm"/>configuration we can easily define routes in our application, and in this instance we have configured a route that responds to the <code class="literal">/website</code> URL. When we would go to the <code class="literal">/website</code> URL, we would be routed to the <code class="literal">Website\Controller\Index::indexAction</code> by default. If we however use the route <code class="literal">/website/another/route</code>, we would be routed to the <code class="literal">Website\Controller\Another::routeAction</code>, as we have defined that the controller and action can be parsed behind that. If we omit the route path and put in <code class="literal">/website/another</code>, we would be redirected to the <code class="literal">Website\Controller\Another::indexAction</code>, as that is used by default by the framework.</p><p>The preceding<a id="id11" class="indexterm"/> example has only one really major drawback, which is, when we decide to use anonymous function in the configuration to create more dynamic routes, we would not be able to cache the route as closures are not serializeable by the cache.</p><p>However, there is another method of declaring the route, and that is in the code. The need to create the route functionality in the code could (obviously everyone has their own reasons and requirements) arise because we want to cache the configuration in a later stage (as we cannot cache anonymous function, for example) or when we want to load up a route dynamically from a database.</p><p>Let's take a look at the <code class="literal">/module/Application/Module.php</code> example:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// We are working in the Application module
namespace Application;

// Our main imports that we want to use
use Zend\Mvc\ModuleRouteListener;
use Zend\Mvc\MvcEvent;

// Define our module class, this is always 'Module', but 
// needs to be specifically created by the developer.
class Module
{
  public function onBootstrap(MvcEvent $e)
  {
    // First we want to get the ServiceManager
    $sm = $e-&gt;getApplication()-&gt;getServiceManager();
    
    /*
      Say our logged in user is 'gdog' and we want
      him to be able to go to /gdog to see his profile.
    */
    $user = 'gdog';

    // Now get the router
    $router = $sm-&gt;get('router');

    // Lets add a route called 'member' to our router
    $router-&gt;addRoute('member', array(

      /*
        We want to make /$user the main end point, with 
        an optional controller and action.
      */
     'route' =&gt; '/'. $user. '[/:controller[/:action]]',

      /*
        We want a default end point (if no controller
        and action is given) to go to the index action
        of the index controller.
      */
      'defaults' =&gt; array( 
        'controller' =&gt; 'Member\Controller\Index', 
        'action' =&gt; 'index' 
      ), 

      /*
        We only want to allow alphanumeric characters
        with an exception to the dash and underscore.
      */
      'constraints' =&gt; array( 
          'controller' =&gt; '[a-zA-Z][a-zA-Z0-9_-]*', 
          'action' =&gt; '[a-zA-Z][a-zA-Z0-9_-]*' 
      ), 
    ));
  }
}</pre></div><p>Naturally there are more ways of adding a route, but the method mentioned in the preceding code <a id="id12" class="indexterm"/>for adding a route displays a canny way of dynamically adding a route. What we created there is that whenever Gdog goes to his profile, he can simply type in <code class="literal">http://example.ext/gdog</code> and end up on his profile.</p><p>Even more wonderful is that if our friend Gdog wants to see his friends, he is able to do that by just typing in for example, <code class="literal">http://example.ext/gdog/my/friends</code>, which will resolve to the <code class="literal">Member</code> module and then go to the <code class="literal">My</code> controller, lastly executing the <code class="literal">Friends</code> action.</p></div><div class="section" title="Using SimpleRouteStack"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Using SimpleRouteStack</h3></div></div></div><p>This route stack is—as <a id="id13" class="indexterm"/>the name implies—the simplest router around and is basically a list with routes that is being parsed to see which route matches, by default this type of router is not used in Zend Framework 2. The general rule of thumb is that if we want to add a route with a high priority, we give it a high index number for example, 100, or 200. If we want to give the route a very low priority, we would give it an index number of, for example, 5 or 10.</p><p>Giving priorities to routes comes in handy when we have very specific routes (which usually have a high priority) and less specific routes (low priority). If we, for example, want to make <code class="literal">/website/url</code> redirect to a completely different module, controller, and action, but not affect the other website routes, we need to give the <code class="literal">/website/url</code> route a higher priority so that when it is found, it will not search for the lower priority routes.</p><p>If we, by accident, turn the priorities around, we would find our <code class="literal">/website/url</code> always redirect to the route that contains all the <code class="literal">/website</code> routes.</p><p>
<code class="literal">SimpleRouteStack</code> uses a <code class="literal">Zend\Mvc\Router\PriorityList</code> class to manage its routes priorities.</p><p>We need to consider routing before we want to start creating our application, as when the application grows we might get into trouble with our routing if we haven't considered 'how to route' beforehand. It would therefore be wise for us to 'sitemap' the application before coding the routes to make sure we have a correct route list and are not creating any conflicting routes.</p><p>The <code class="literal">SimpleRouteStack</code> class has a number of methods defined that are very useful for us:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getRoute($name)</code> / <code class="literal">getRoutes($name)</code>: This will retrieve the current route—if a name is provided—or routes that are defined in our <code class="literal">SimpleRouteStack</code>. If we are unsure about the routes we have defined, this would be a good place to check first.</li></ul></div><p>
<code class="literal">addRoute($name, $route, $priority)</code> / <code class="literal">addRoutes($routes)</code>: We can use this to add a new route or an array of routes to our route type by simply adding it through this method. A route requires a <code class="literal">name</code>, <code class="literal">route</code> (which can be a string or an instance of <code class="literal">RouteInterface</code>) and if we fancy a priority, we can give that as the third parameter.</p><p>
<code class="literal">hasRoute($name)</code>: If we would want to check whether a specific route already exists, we can search using its <code class="literal">name</code> and find out if it does or doesn't.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">removeRoute($name)</code>: When we are tired of a route we can simply give its name and remove it from the list. This can be particularly handy if we want for example to have a module override a certain /login when the user has logged in to route to/user.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SimpleRouteStack</code>: Does not have a functionality to have multiple routes with the same priority. If there is a route with a priority already defined, it will prioritize the last route added as the route with the highest priority.</li></ul></div></div><div class="section" title="Using TreeRouteStack"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Using TreeRouteStack</h3></div></div></div><p>Routers <a id="id14" class="indexterm"/>are not restricted to using the URI path to find out how to route a request. They can also use other information such as the query parameters, headers, methods, or hostnames to find a match.</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>How it works…</h2></div></div></div><p>In Zend Framework 2, we will generally use routing that is based on a request URI, which contains path segments that should be queried. Routes are matched by a router, which utilizes <code class="literal">RouteStack</code> to find the match to the query made by the router. We use <code class="literal">RouteStack</code> because we want a decent way of managing our different routes. With Zend Framework 2 there are loads of route types provided, but only two flavorless routers namely <code class="literal">SimpleRouteStack</code> and <code class="literal">TreeRouteStack</code>.</p><p>When we are defining a router, we need to make sure we understand how it works. Although creating lists with different paths is simple enough, it is wise to remember that the Zend Framework 2 router generally works with the <span class="strong"><strong>Last In First Out</strong></span> (<span class="strong"><strong>LIFO</strong></span>) concept, which means that a route that would be used often would be registered last, and a route that is less common would be registered earlier in the router stack.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>There's more…</h2></div></div></div><p>Besides the two standard route types, Zend Framework 2 comes with a whole scale of route types that are more specialized to the Internet navigation or even through the console.</p><div class="section" title="Namespace – Zend\Mvc\Router\Http"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Namespace – Zend\Mvc\Router\Http</h3></div></div></div><p>A wonderful set of HTTP routers can be found in the <code class="literal">Zend\Mvc\Router\Http</code> namespace<a id="id15" class="indexterm"/> and we will take a quick look at the different classes that reside within this namespace.</p><div class="section" title="The Hostname class explained"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec01"/>The Hostname class explained</h4></div></div></div><p>The <code class="literal">Zend\Mvc\Router\Http\Hostname</code> namespace<a id="id16" class="indexterm"/> will try to match its routing against the hostname defined in the configuration. For example, if we define the route to be <code class="literal">something.example.ext</code>, our router will make its routing decision based on the full URL. But, if we add a single colon at the beginning of that same route, for example: <code class="literal">:something.example.ext</code>, the router would base its route on the <code class="literal">something</code> variable, which could be anything from <code class="literal">aardvark.example.ext</code> to <code class="literal">zyxt.example.ext</code>.</p></div><div class="section" title="The Literal class explained"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec02"/>The Literal class explained</h4></div></div></div><p>The <code class="literal">Zend\Mvc\Router\Http\Literal</code> class<a id="id17" class="indexterm"/> will literally match the path we give in. For example, if we put a route in there, which is <code class="literal">/grouphug</code>, the route will only resolve to that URL, and nothing else.</p></div></div><div class="section" title="Methods explained"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec08"/>Methods explained</h3></div></div></div><p>The <code class="literal">Zend\Mvc\Router\Http\Method</code> class<a id="id18" class="indexterm"/> is used when we want to match against an HTTP method instead of a segment or path. This could be, for example, a <code class="literal">POST</code>, <code class="literal">DELETE</code> and so on. The method is also called <code class="literal">verb</code> by Zend Framework 2, which means that instead of a <code class="literal">route</code> parameter, it requests a <code class="literal">verb</code> parameter when adding the route, which is an excellent way to create RESTful APIs.</p></div><div class="section" title="The Part class explained"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec09"/>The Part class explained</h3></div></div></div><p>The <code class="literal">Zend\Mvc\Router\Http\Part</code> class<a id="id19" class="indexterm"/> is used to describe <code class="literal">child_routes</code> in our routing configuration. This means that—although never used directly—we can define that <code class="literal">/user/profile</code> is being redirected to use the <code class="literal">UserController</code>, with the <code class="literal">profile</code> action.</p><p>Let's consider the following configuration:</p><div class="informalexample"><pre class="programlisting">return array(
  // We begin our router configuration
  'router' =&gt; array(

    // Define our routes 
    'routes' =&gt; array(

      // We are defining a route named 'Example'
      'Example' =&gt; array(
        'type' =&gt; 'Literal',
        'options' =&gt; array(
  
           /*
            This route will resolve to /recipe 
            which will resolve to the Example 
            module's IndexController and execute 
            the IndexAction.
           */
           'route' =&gt; 'recipe',
           'defaults' =&gt; array(
             '__NAMESPACE__' =&gt; 'Example\Controller',
             'controller' =&gt; 'Index',
           ),
         ),
                
         'may_terminate' =&gt; true,

          /*
            Here we begin to define our Part route, 
            which always begins with the 
            'child_routes' configuration.
          */
          'child_routes' =&gt; array(
            'client' =&gt; array(
              'type' =&gt; 'Literal',
              'options' =&gt; array(
           
              /*
                This child route (or Part) 
                will resolve to /recipe/foo       
                and will call the fooAction in  
                the IndexController.
              */
              'route' =&gt; '/foo',
              'defaults' =&gt; array(
               'action' =&gt; 'fooAction'
              ),
            ),
          ),
        ),
      ),
    ),
  ),
);</pre></div></div><div class="section" title="Regex explained"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec10"/>Regex explained</h3></div></div></div><p>The <code class="literal">Zend\Mvc\Router\Http\Regex</code> class<a id="id20" class="indexterm"/> would be used when we have a complex routing structure that requires us to dynamically create the route. This would, for example, come in handy when we look at News sites, where posts are built up like <code class="literal">/archive/some-subject-2013.html</code>. This fairly complex route (as <code class="literal">some-subject-2013.html</code> is dynamic in our case) would require a <code class="literal">Regex</code> router that can resolve the Controller, Action, and in our case also the output format.</p><p>Let's consider the following example:</p><div class="informalexample"><pre class="programlisting">// We begin our router configuration
'router' =&gt; array(

  // Define our routes 
  'routes' =&gt; array(

    // We are defining a route named 'Archive'
    'Archive' =&gt; array(
      'type' =&gt; 'Literal',
      'options' =&gt; array(

        /*
          This route will resolve to /archive 
          which will resolve to the Archive 
          module's IndexController and execute 
          the IndexAction.
        */
        'regex' =&gt; '/archive/(?&lt;id&gt;[a-zA-Z0-9_-
  ]+)(\.(?&lt;format&gt;(html|xml)))?',
        'defaults' =&gt; array(
            '__NAMESPACE__' =&gt; 'Archive\Controller',
            'controller' =&gt; 'Index',
            'action' =&gt; 'indexAction',
            'format' =&gt; 'html',
        ), 
        'spec' =&gt; '/archive/%id%.%format%',
      ),
    ),
  ),
),</pre></div><p>In the preceding example, it is important to note that <code class="literal">/archive/%id%.%format%</code> tells us that we will receive two parameters in our method called <code class="literal">indexAction</code> that is, <code class="literal">id</code> and <code class="literal">format</code>.</p></div><div class="section" title="The Scheme class explained"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec11"/>The Scheme class explained</h3></div></div></div><p>The <code class="literal">Zend\Mvc\Router\Http\Scheme</code> class<a id="id21" class="indexterm"/> is always using the <code class="literal">defaults</code> parameter and will accept only one other parameter, which is called <code class="literal">scheme</code> and can only contain one of the following options, that is, <code class="literal">http</code>, <code class="literal">https</code>, and <code class="literal">mailto</code>.</p></div><div class="section" title="The Segment class explained"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec12"/>The Segment class explained</h3></div></div></div><p>The <code class="literal">Zend\Mvc\Router\Http\Segment</code> class<a id="id22" class="indexterm"/> is probably one of the most-used routers that we would use, as you can dynamically define the route and controller for any module by using, for example, <code class="literal">/:controller/:action</code>, which is easily recognizable by the colon separation. We can define any <code class="literal">constraints</code> to the segment by configuring only the use of alphanumeric characters or another definition that we would like to use.</p><p>An example of <code class="literal">Segment</code> is given in the first example in the <span class="emphasis"><em>How to do it...</em></span> section.</p></div></div></div>
<div class="section" title="Understanding dependency injection"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Understanding dependency injection</h1></div></div></div><p>When<a id="id23" class="indexterm"/> we talk about the dependency injection, or in short DI, we talk about the simple task of, for example, injecting data in object or methods at initialization when needed by one or other higher up classes, which either modify or dispose off the object after use. The DI is probably the most complex feature in Zend Framework 2 to understand. Unfortunately because DI's over complexity in debugging and performance and the Service Locator (explained in <a class="link" href="ch06.html" title="Chapter 6. Modules, Models, and Services">Chapter 6</a>, <span class="emphasis"><em>Modules, Models and Services</em></span>). However, although it is not the best tool in the shed, we must try to learn it, because when mastered it could prove to be a very powerful tool to create a very maintainable piece of code.</p><p>If we come across a situation where it is necessary for us to input a lot of parameters in classes because of objects deeper in the code are dependent on them is probably the most annoying and un-maintainable piece of code that we can find in even the most professional environment. We need to think mainly about objects that are used more than once in an application, and always required to instantiate again.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>How to do it…</h2></div></div></div><p>Let us take a look at the following example and assume that <code class="literal">FirstClass</code> is the only class that we will actually need further in the code:</p><div class="informalexample"><pre class="programlisting">namespace OneNamespace
{
  class FirstClass 
  {
    private $secondClass;
    public function __construct(SecondClass $secondClass)
    {
      $this-&gt;secondClass = $secondClass;  
    } 
  }

  class SecondClass 
  {
    private $thirdClass;
    private $vehicle;
    public function __construct(ThirdClass $thirdClass, $vehicle)
    {
      $this-&gt;thirdClass = $thirdClass;
      $this-&gt;vehicle = $vehicle;
    }
  }
}

namespace AnotherNamespace 
{
  class ThirdClass 
  {
    private $first_name;
    private $last_name;

    public function __construct($first_name, $last_name)
    {
      $this-&gt;first_name = $first_name;
      $this-&gt;last_name = $last_name;
    }
  }
}

// Let us now create the example through the classic 
// method.
$thirdClass = new AnotherNamespace\ThirdClass("John", "Doe");
$secondClass = new OneNamespace\SecondClass($thirdClass, 
  'Motorcycle');
$firstClass = new OneNamespace\FirstClass($secondClass);</pre></div><p>Both the preceding examples give either variables that are only used to instantiate another class and/or add <a id="id24" class="indexterm"/>complexity in reading the code. Although they both are correct, the use of DI can, in this case, make the configuration of both the classes much easier.</p><div class="section" title="Initializing the DI at call-time"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec13"/>Initializing the DI at call-time</h3></div></div></div><p>Let's take a <a id="id25" class="indexterm"/>look at this DI example, considering that we have the same classes as the preceding example:</p><div class="informalexample"><pre class="programlisting">namespace OneNamespace
{
  class FirstClass 
  {
    [..] 
  }

  class SecondClass 
  {
    [..]  
  }
}

namespace AnotherNamespace 
{
  class ThirdClass 
  {
    [..]
  }
}

// Instead of configuring all the classes, we will now 
// simply configure the Di, and only instantiate the 
// class that we want to use.
$di = new \Zend\Di\Di();
$lister = $di-&gt;get(
    'OneNamespace\FirstClass',
    array(
        'first_name' =&gt; 'Jane',
        'last_name' =&gt; 'Doe',
        'vehicle' =&gt; 'Car',
    )
);</pre></div><p>In the preceding example, we simply say to the DI that <code class="literal">AnotherNamespace\ThirdClass</code> has two parameters in its <code class="literal">__construct</code> method. The DI will then <a id="id26" class="indexterm"/>utilize <code class="literal">Reflection</code> to find out what parameters are present there, and will then give any class that has a <code class="literal">first_name</code>, <code class="literal">vehicle</code>, or <code class="literal">last_name</code> parameter in its constructor that parameter.</p><p>Of course we will see a potential flaw here, as you might need to utilize multiple instantiations, one can presume that at some point the same parameter name will be used. In our example, it would cause a problem if another class also has a <code class="literal">$first_name</code> parameter but requires a different input, as the DI will simply give the one that is in its list.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>If we use DI to instantiate our classes and all we need the constructor for is to set our variables, we can easily remove the constructor altogether as the DI doesn't use the constructor to initialize the variables. Instead the DI will just set the properties of the values.</p></div></div><p>One good thing about this is that this can flaw only happens when we use the DI at a call-time level, and<a id="id27" class="indexterm"/> not in a global configuration level as we will see now. That is why it isn't recommended to use the DI at call-time level at all.</p></div><div class="section" title="Initializing the DI through a Configuration object"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec14"/>Initializing the DI through a Configuration object</h3></div></div></div><p>What we also <a id="id28" class="indexterm"/>can do to create a more specific (or accurate) initialization of our object – and to make sure classes with the same property names don't conflict – is initializing the DI with a configuration object.</p><p>The idea behind this is that we first create a configuration object (or array) that defines which classes need which properties set, and then use that to initialize the DI, which in its turn finds out when it needs to initiate what.</p><p>Take a look at the following example, which shows you the exact thing we just explained:</p><div class="informalexample"><pre class="programlisting">&lt;?php
// We are assuming that we are using the same classes as 
// in the previously shown examples.
namespace OneNamespace 
{
  class FirstClass 
  {
    [..] 
  }

  class SecondClass 
  {
    [..]  
  }
}

namespace AnotherNamespace 
{
  class ThirdClass 
  {
    [..]
  }
}

// After defining our classes we now begin to create our 
// configuration array which we will use to initialize 
// the DI.
$configuration = array(

  // We want to use this specific configuration at 
  // initialization of our class.
  'instance' =&gt; array(
    
    // We specify the class name to use here
    'SecondClass' =&gt; array(
       
      // We want to use this as a parameter
      'parameters' =&gt; array(

        // The property name to fill is vehicle.
        'vehicle' =&gt; 'Airplane'
      ),
    ),

    'FirstClass' =&gt; array(
      // Again we want to use this as a parameter
      'parameters' =&gt; array(

        // The property name to fill is first name and 
        //last name.
        'first_name' =&gt; 'Neil',
        'last_name' =&gt; 'deGrasse Tyson',
      ),
    ),
  ),
);

// We want to instantiate the Di\Configuration now.
use \Zend\Di\Configuration; 

$diConfiguration = new Configuration($configuration);

// Now instantiate the Di itself, with the configuration 
// attached.
$di = new \Zend\Di\Di($configuration);

// And to get the object we want to use, we just do the 
//same as before.
$firstClass = $di-&gt;get('OneNamespace\FirstClass');</pre></div><p>To make <a id="id29" class="indexterm"/>everything even nicer, we would just put the <code class="literal">Zend\Di\Configuration</code> of the DI in the bootstrap of our module, so that we can use it easily throughout the namespace. This way we can simply put the configuration of the DI in our <code class="literal">module.config.php</code> and let the framework take care of it.</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>How it works…</h2></div></div></div><p>The DI or dependency injector is an important, and most of the time overlooked feature of Zend Framework 2. The DI makes our lives a lot easier by automatically finding the classes we need in our application.</p><p>With all its complexity however, comes a couple of features we should be wary of.</p><div class="section" title="The DI only gives out one instance of an object"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec15"/>The DI only gives out one instance of an object</h3></div></div></div><p>This means that every <code class="literal">get()</code> call will result in the same instantiation over and over again. If we would like a new instance, we would need to call <code class="literal">newInstance()</code> as the DI implements the singleton pattern<a id="id30" class="indexterm"/>, which means that all the data persists every time we call the <code class="literal">get()</code> method unless we force a new instance of the DI.</p></div><div class="section" title="Defining either all properties, or using a Fully Qualified (FQ) setter parameter"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec16"/>Defining either all properties, or using a Fully Qualified (FQ) setter parameter</h3></div></div></div><p>When our <a id="id31" class="indexterm"/>class has more properties than we define, we will find out that the DI will use the last value for every other property in the class. Of course this is unwanted, and if we wrote the class ourselves we should consider refactoring the configuration and/or class.</p><p>However, when there is no<a id="id32" class="indexterm"/> other way we can define the right properties only by using a <span class="strong"><strong>Fully Qualified</strong></span> (<span class="strong"><strong>FQ</strong></span>) setter parameter.</p><p>In our configuration we would then define a very specific property name, for example, <code class="literal">class::method:paramPos</code>. If we take our <code class="literal">ThirdClass</code> example from earlier on, this would then be <code class="literal">ThirdClass::setFirstName:0</code> and <code class="literal">ThirdClass::setLastName:0</code> respectively.</p></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>There's more…</h2></div></div></div><p>There is loads more we can learn about the DI in Zend Framework 2. The following list provides a very short and compact description of other interesting DI components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">RuntimeDefinition</code> (default), <code class="literal">CompilerDefinition</code> and <code class="literal">ClassDefinition</code>: These definitions are used to determine how to configure our objects. Although the default one usually does the job, it can't hurt to see what the other two Definitions do, because they all have their pros and cons.</li><li class="listitem" style="list-style-type: disc"><code class="literal">InstanceManager</code>: Used to define the configuration, specifically the <code class="literal">Aliases</code>, <code class="literal">Parameters</code> and <code class="literal">Preferences</code>.</li></ul></div></div></div>
<div class="section" title="Using configurations to your benefit"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Using configurations to your benefit</h1></div></div></div><p>Configurations <a id="id33" class="indexterm"/>play a crucial role in the workings of Zend Framework 2, therefore it is essential to know how it works.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>How to do it…</h2></div></div></div><p>Go through the following sections to use configurations to your benefit:</p><div class="section" title="Creating a global configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec17"/>Creating a global configuration</h3></div></div></div><p>When <a id="id34" class="indexterm"/>beginning to code in Zend Framework 2 there is <a id="id35" class="indexterm"/>some misunderstanding as to what the different configuration files do. By default we have multiple configuration files, and it might not always be simple to understand where things need to go. That is why we like to apply a simple rule:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Is the configuration necessary throughout all our modules? If yes, place your configuration in the <code class="literal">config/application.config.php</code> file. If not, place your configuration in the <code class="literal">config/global.php</code> file at the module where it belongs.</p></div></div><p>The configuration that we usually place in the <code class="literal">global.php</code> file can be, for example, the caching method and configuration, the database configuration. Normally we would like to place items in there that are environment related, but nothing that is security sensitive.</p><p>Let's take a look at a bad example of <code class="literal">global.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php
return array(

  // We want to create a new database connection
  'db' =&gt; array(

    // The driver we want to use is the Pdo, our  
    // favorite
    'driver' =&gt; 'Pdo',

    // This is our connection url, defining a MySQL 
    // connection, with database 'somename' which is 
    // available on the localhost server.
    'dsn' =&gt; 'mysql:dbname=somename;host=localhost',

    // This is exactly what we should NOT do in this  
    // file, shame on you developer!
    'username' =&gt; 'terribleuser',
    'password' =&gt; 'evenworsepassword',
  ),

  // We need a database adapter defined as well, 
  // otherwise we can't use it at all.
  'service_manager' =&gt; array(
    'factories' =&gt; array(
      'Zend\Db\Adapter\Adapter' =&gt; 
  'Zend\Db\Adapter\AdapterServiceFactory',
    ),
  ),
);</pre></div><p>It is <a id="id36" class="indexterm"/>terrible practice to put the username and password in the <code class="literal">global.php</code> file. The <code class="literal">global.php</code> file is to be put in our version<a id="id37" class="indexterm"/> control, and therefore should contain only configuration items that are required to globally run the application, not specific information that is relevant per environment, such as database usernames and passwords.</p></div><div class="section" title="Creating configuration that only works for a local machine"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec18"/>Creating configuration that only works for a local machine</h3></div></div></div><p>One of the benefits <a id="id38" class="indexterm"/>of the ultra-many configuration files in Zend Framework 2, is that you are able to override your global configuration with your local configuration. This certainly comes in handy when developing and you find yourself in a position where your details are slightly different in configuration than your production environment.</p><p>Let's assume that we have the following <code class="literal">/config/autoload/global.php</code> configuration file:</p><div class="informalexample"><pre class="programlisting">&lt;?php
return array(

  // We want to create a new database connection
  'db' =&gt; array(

    // The driver we want to use is the Pdo, our  
    // favorite
    'driver' =&gt; 'Pdo',

    // This is our connection url, defining a MySQL 
    // connection, with database 'somename' which is 
    // available on the localhost server.
    'dsn' =&gt; 'mysql:dbname=somename;host=localhost',
  ),

  // We need a database adapter defined as well, 
  // otherwise we can't use it at all.
  'service_manager' =&gt; array(
    'factories' =&gt; array(
      'Zend\Db\Adapter\Adapter' =&gt; 
  'Zend\Db\Adapter\AdapterServiceFactory',
    ),
  ),
);</pre></div><p>As we can see in the preceding example, we create a nice and simple MySQL database connection to<a id="id39" class="indexterm"/> our <code class="literal">somename</code> database which resides on the localhost. But as good developers we have not defined our username and password in here. That is where the /<code class="literal">config/autoload/local.php</code> file comes in.</p><p>Let's take a look at how our <code class="literal">local.php</code> might look like:</p><div class="informalexample"><pre class="programlisting">&lt;?php
return array(
  'db' =&gt; array(
    'username' =&gt; 'awesomeuser',
    'password' =&gt; 'terriblepassword',
  ),
);</pre></div><p>If we are using a version control system (please say yes), we should not commit this file, not only for security reasons but also because this is a local configuration file and wouldn't be necessary on a live system, as we would create a new one with the right details for that environment.</p></div><div class="section" title="Editing your application.config.php file"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec19"/>Editing your application.config.php file</h3></div></div></div><p>If we <a id="id40" class="indexterm"/>look at our default <code class="literal">config/application.config.php</code> file we have only a few properties set, but loads of inline comments,<a id="id41" class="indexterm"/> which really come in handy when we can't remember the exact name or description of a property any more.</p><p>The main configuration that we will be changing the most in our application as we develop is the <code class="literal">modules</code> property. This specific property is a simple array with the different module namespaces that we have (and want to use) in our application. At default this looks somewhat like this:</p><div class="informalexample"><pre class="programlisting">&lt;?php 

return array(
  // This should be an array of module namespaces used 
  // in the application.
  'modules' =&gt; array(
    'Application',
  ),
[..]</pre></div><p>When we add or remove a module, this line needs to be modified as well and one can even suggest modifying this before starting a new module or removing one. The reason for this is simple, when we forget to modify this file when removing a module it will generate a <code class="literal">500 – Application Error</code> when visiting the application in our browser. And because this configuration file is read quite early in the instantiation, it can sometimes be hard for the developer to pinpoint why the application fails to load all of a sudden.</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>How it works…</h2></div></div></div><p>If we look at the <code class="literal">index.php</code> file in the <code class="literal">public</code> folder, we can see that we parse our initial configuration file to the Zend Framework MVC Application with the line <code class="literal">require 'config/application.config.php'</code>. This then loads up the main configuration file, which in its turn defines all our properties.</p><p>A nifty property in the <code class="literal">application.config.php</code> file is the <code class="literal">config_glob_paths</code> property. Any additional configuration files are by default read by finding files in the <code class="literal">config/autoload</code> folder as well, using a very specific file pattern namely; <code class="literal">*global.php</code> and <code class="literal">*local.php</code>. The order in which this is defined is also very important.</p><p>When we say <code class="literal">*global.php</code>, we can define anything from <code class="literal">somemodule.global.php</code> to <code class="literal">menu.global.php</code> to just <code class="literal">global.php</code>, as the file pattern (also named <code class="literal">GLOB_BRACE</code>) searches for anything that matches that. The same happens for <code class="literal">*local.php</code>.</p><p>The order this is defined is very important as said before because we want our global configuration to be loaded before our local configuration, otherwise there would be no point in overriding our global configuration, would there?</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>There's more…</h2></div></div></div><p>To summarize the configuration files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">config/application.config.php</code>: Modules can be added and removed here, and very low level configuration happens here.</li><li class="listitem" style="list-style-type: disc"><code class="literal">config/autoload/some-module.global.php</code>: Used to override your default values of your module configuration. Make sure not to put sensitive information in here, but hostnames and database names should go in here.</li><li class="listitem" style="list-style-type: disc"><code class="literal">config/autoload/some-module.local.php</code>: You can put your usernames and passwords and other configuration items that are very specific to your local environment here.</li><li class="listitem" style="list-style-type: disc"><code class="literal">module/SomeModule/config/module.config.php</code>: Module specific configuration happens here, use only default values and make sure nothing too specific will be entered here.</li></ul></div></div></div>
<div class="section" title="The EventManager and Bootstrap classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>The EventManager and Bootstrap classes</h1></div></div></div><p>We will be showing<a id="id42" class="indexterm"/> off <a id="id43" class="indexterm"/>one of the most beautiful features of Zend Framework 2: The EventManager.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>How to do it…</h2></div></div></div><p>The <code class="literal">EventManager</code> and <code class="literal">Bootstrap</code> classes are an essential part of our application, this recipe is all about how to use those two tools:</p><div class="section" title="Using the bootstrap"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec20"/>Using the bootstrap</h3></div></div></div><p>The bootstrap<a id="id44" class="indexterm"/> is in our case the start of a module, whenever a module is requested it will use the <code class="literal">onBootstrap()</code> method located in the <code class="literal">Module.php</code> file. Although the method is not required, we usually want this method in our module as it is an easy method of making sure that some instances already exist or are configured before venturing further in our client request.</p></div><div class="section" title="Starting a session"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec21"/>Starting a session</h3></div></div></div><p>Sessions are a<a id="id45" class="indexterm"/> wonderful way of saving information about a user on a temporary basis. Think about saving the information of a logged-in user, or history on the pages they have been. Once we begin creating an application we find ourselves saving a lot of things in the session.</p><p>The first <a id="id46" class="indexterm"/>thing we need to do is modify the <code class="literal">/module/Application/config/module.config.php</code> file, and add another section called <code class="literal">session</code> to it. Let's assume that we have a completely empty module configuration:</p><div class="informalexample"><pre class="programlisting">&lt;?php
return array(
  'service_manager' =&gt; array(
     // These are the factories needed by the Service 
     // Locator to load in the session manager
    'factories' =&gt; array(
      'Zend\Session\Config\ConfigInterface' =&gt; 
  'Zend\Session\Service\SessionConfigFactory',
      'Zend\Session\Storage\StorageInterface' =&gt; 
  'Zend\Session\Service\SessionStorageFactory',
      'Zend\Session\ManagerInterface' =&gt; 
  'Zend\Session\Service\SessionManagerFactory',
    ),
    'abstract_factories' =&gt; array(
  'Zend\Session\Service\ContainerAbstractFactory',
    ),
  ),
  'session_config' =&gt; array(
    // How long can the session be idle for in seconds 
    // before it is being invalidated
    'remember_me_seconds' =&gt; 3600,

    // What is the name of the session (can be anything)
    'name' =&gt; 'some_name',
  ),
  // What kind of session storage do we want to use, 
  // only SessionArrayStorage is available at the minute
  'session_storage' =&gt; array(
    'type' =&gt; 'SessionArrayStorage',
    'options' =&gt; array(), 
  ),
  // These are session containers we can use to store 
  // our information in
  'session_containers' =&gt; array(
    'ContainerOne',
    'ContainerTwo',
  ),
);</pre></div><p>And that is it. Sessions are now useable in our controllers and models. We have now created two <a id="id47" class="indexterm"/>session containers that we can use to store our information in. We can access these containers in any Controller or Model that has a service locator available by doing the following (file: <code class="literal">/module/Application/src/Application/Controller/IndexController.php</code>):</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Application;

use Zend\Mvc\Controller\AbstractActionController;

class IndexController extends AbstractController
{
  public function indexAction()
  {
    // Every session container we define receives a 
    // SessionContainer\ prefix before the name
    $containerOne = $this-&gt;getServiceLocator()
  -&gt;get('SessionContainer\ContainerOne');
  }
}</pre></div><div class="section" title="Using the EventManager class"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec03"/>Using the EventManager class</h4></div></div></div><p>The <code class="literal">EventManager</code> class<a id="id48" class="indexterm"/> is possibly one of the nicest features in the framework. When used properly, it can make our code a lot more dynamic and maintainable without creating spaghetti code.</p><p>What it does is relatively simple, for example; a class might have a method called <code class="literal">MethodA</code>. This <code class="literal">MethodA</code> has a list of listeners, which are interested in the outcome of that class. When <code class="literal">MethodA</code> executes, it just runs through its normal procedures, and when finished it just notifies the <code class="literal">EventManager</code> a specific event has occurred. Now the <code class="literal">EventManager</code> will trigger all of the interested parties that this event has taken place, and the parties in their turn will execute their code.</p><p>Got it? Don't worry if you don't, because this example code might clear things up (file: <code class="literal">/module/Application/src/Application/Model/SwagMachine.php</code>):</p><div class="informalexample"><pre class="programlisting">&lt;?php
// Don't forget to add the namespace
namespace Application\Model;

// We shouldn't forget to add these!
use Zend\EventManager\EventManager;
 
class SwagMachine
{
  // This will hold our EventManager
  private $em;

  public function getEventManager() 
  {
    // If there is no EventManager, make one!
    if (!$this-&gt;em) {
      $this-&gt;em = new EventManager(__CLASS__);
    }
 
    // Return the EventManager.
    return $this-&gt;em;
  }
 
  public function findSwag($id)
  {
    // Trigger our findSwag.begin event 
    // and push our $id variable with it.
    $response = $this-&gt;getEventManager()
                     -&gt;trigger(
           'findSwag.begin', 
           $this,
           array(
             'id' =&gt; $id
           )
    );
  
    // Make our last response, the final 
    // ID if there is a response.
    if ($response-&gt;count() &gt; 0)
      $id = $response-&gt;last();
 
    // ********************************
    // In the meantime important code 
    // is happening...
    // ********************************
  
    // ...And that ends up with the 
    // folowing return value:
    $returnValue = 'Original Value ('. $id. ')';
    
    // Now let's trigger our last 
    // event called findSwag.end and 
    // give the returnValue as a 
    // parameter.
    $this-&gt;getEventManager()
         -&gt;trigger(
           'findSwag.end', 
           $this, 
           array(
             'returnValue' =&gt; $returnValue
           )
    );
 
    // Now return our value.
    return $returnValue;
  }
}</pre></div><p>As we can see we created a little class with two event triggers, <code class="literal">findSwag.begin</code> and <code class="literal">findSwag.end</code>, respectively <a id="id49" class="indexterm"/>on the beginning of the method, and one on the end of the method. The <code class="literal">findSwag.begin</code> event will potentially modify the <code class="literal">$id</code>, and the <code class="literal">findSwag.end</code> event only parses the <code class="literal">returnValue</code> object, with no modification possible to the value.</p><p>Now let's see the code that implements the triggers (file: <code class="literal">/module/Application/src/Application/Controller/IndexController.php</code>):</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;

class IndexController extends AbstractActionController
{
  public function indexAction() 
  {
    // Get our SwagMachine
    $machine = new SwagMachine();
    
    // Let's attach our first callback, 
    // which potentially will increase 
    // the $id with 10, which would 
    // make it result in 30!
    $machine-&gt;getEventManager()
            -&gt;attach(
        'findSwag.begin',
        function(Event $e) 
        {
          // Get the ID from our findSwag() 
          // method, and add it up with 12.
          return $e-&gt;getParam('id') + 10;
        },
        200
    );
    
    // Now attach our second callback, 
    // which potentially will increase 
    // the value of $id to 60! We give 
    // this a *higher* priority then 
    // the previous attached event 
    // trigger.
    $machine-&gt;getEventManager()
            -&gt;attach(
        'findSwag.begin',
        function(Event $e) 
        {
        // Get the ID from our findSwag() 
        // method, and add it up with 15.
        return $e-&gt;getParam('id') + 40;
      },
      100
    );
  
    // Now create a trigger callback 
    // for the end event called findSwag.end, 
    // which has no specific priority, 
    // and will just output to the screen.
    $machine-&gt;getEventManager()
            -&gt;attach(
        'findSwag.end',
        function(Event $e) 
        {
          echo 'We are returning: '
             . $e-&gt;getParam('returnValue');
        }
    );

    // Now after defining the triggers, 
    // simply try and find our 'Swag'.      
    echo $machine-&gt;findSwag(20);
  }
}</pre></div><p>As we can see attaching triggers to events is pretty straightforward. And – if the events are properly <a id="id50" class="indexterm"/>documented – can come in handy when we want to, say, modify parameters going into a method (like we did with the <code class="literal">findSwag.begin</code>), or just outputting the results to a log (like <code class="literal">findSwag.end</code>).</p><p>When we look at what is on our screen, it should be something like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>We are returning: Original Value (60)</strong></span>
<span class="strong"><strong>Original Value (60)</strong></span>
</pre></div><p>The result consists of the top line being the output from the <code class="literal">findSwag.end</code> trigger, while the value <code class="literal">60</code> comes from the highest priority trigger, the one with priority <code class="literal">100</code> (as that is considered a higher priority than <code class="literal">200</code>).</p></div><div class="section" title="Changing the View output"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec04"/>Changing the View output</h4></div></div></div><p>Sometimes it is<a id="id51" class="indexterm"/> necessary that we have different View outputs, for example when we need to build ourselves a REST service or a SOAP service. Although this can be arranged much simpler by a controller plugin, it is an example on how to hook into the <code class="literal">dispatch</code> event, and see what is going on there.</p><p>Without further ado, let us take a look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">Module.php:
namespace Application;

// We are going to use events, and because we use a MVC, 
// we need to use the MvcEvent.
use Zend\Mvc\MvcEvent;

class Module
{
  public function onBootstrap(MvcEvent $e)
  {
    // Get our SharedEventManager from the MvcEvent $e 
    // that we got from the method
    $sharedEvents = $e-&gt;getApplication()
                      -&gt;getEventManager()
                      -&gt;getSharedManager();

    // Also retrieve the ServiceManager of the 
    // application.
    $sm = $e-&gt;getApplication()-&gt;getServiceManager();

    // Let's propose a new ViewStrategy to our 
    // EventManager.
    $sharedEvents-&gt;attach(

        // We are attaching the event to this namespace 
        // only.
        __NAMESPACE__, 

        // We want to attach to this very specific 
        // event, the Dispatch event of our controller.
        MvcEvent::EVENT_DISPATCH, 

        // The callback function of the event, used when 
        // the event we attached to happens. In our 
        // callback we also want our local variable $sm 
        // to be available for use.
        function($e) use ($sm) 
        {
          // Get our alternate view strategy from the 
          // ServiceManager and attach the EventManager     
          // to the strategy.
          $strategy = $sm-&gt;get('ViewJsonStrategy');
          $view = $sm-&gt;get('ViewManager')-&gt;getView();
          $strategy-&gt;attach($view-&gt;getEventManager());
        }, 

        // We want to give this a priority, so this will 
        // get more priority.
        100
    );
}</pre></div><p>As we can see<a id="id52" class="indexterm"/> it is relatively simple to attach a callback function to the <code class="literal">EventManager</code> object. In this example we are using <code class="literal">McvEvent::EVENT_DISPATCH</code> as the event we want to hook in to. So what basically happens is that whenever a controller executes the <code class="literal">onDispatch()</code> method, this event will be triggered as well. This means that through events we can modify the outcome of a method without actually needing to modify the code.</p></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>How it works…</h2></div></div></div><p>The EventManager class works through a couple of different methods<a id="id53" class="indexterm"/>, namely the Observer pattern, the Aspect-Oriented Programming technique (or AOP) and the Event-Driven architecture.</p><div class="section" title="The Observer pattern explained"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec22"/>The Observer pattern explained</h3></div></div></div><p>Simply said the<a id="id54" class="indexterm"/> Observer pattern<a id="id55" class="indexterm"/> means that there are several interested parties, called listeners that want to know when the application triggers a certain event. When a specific event is triggered, the listeners will be notified so that they can take their necessary actions.</p></div><div class="section" title="Aspect-Oriented Programming (AOP) explained"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec23"/>Aspect-Oriented Programming (AOP) explained</h3></div></div></div><p>If we <a id="id56" class="indexterm"/>want to explain what AOP is, we could <a id="id57" class="indexterm"/>say that in short it stands for writing clean code that have only function and are as isolated from the rest of the code as possible.</p><div class="section" title="Event-driven architecture explained"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl3sec233"/>Event-driven architecture explained</h4></div></div></div><p>The benefit of an <a id="id58" class="indexterm"/>Event-driven architecture<a id="id59" class="indexterm"/> is that instead of creating bulks of code that need to check every condition, we can easily hook ourselves to different events, which in essence will create a more responsive application.</p></div></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>There's more…</h2></div></div></div><p>The <code class="literal">EventManager</code> object is queried through a <code class="literal">PriorityQueue</code>, which tells us that an important event will generally get a lower value, while an unimportant event a higher value. For example, the highest priority might get priority <code class="literal">-1000</code> while a quite low priority might get 40. The <code class="literal">EventManager</code> class then gets the queue through a <span class="strong"><strong>FIFO</strong></span> (<span class="strong"><strong>First In, First Out</strong></span>) concept, meaning the higher the priority, the lower the number.</p></div></div></body></html>