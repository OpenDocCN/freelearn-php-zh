<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Building a Blog Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Building a Blog Application</h1></div></div></div><p>Now that we have seen FuelPHP's elementary features in the previous chapters, it is time to use more advanced ones. In this chapter, we will build a typical blog application managed via a secured administration interface. We will implement it as a module since this is a convenient way in FuelPHP to improve code reusability.</p><p>By the end of the chapter, you should know:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to generate an administration interface</li><li class="listitem" style="list-style-type: disc">How to create your own module</li><li class="listitem" style="list-style-type: disc">What are CSRF attacks and how to protect your website from them</li><li class="listitem" style="list-style-type: disc">How to create and use tasks</li><li class="listitem" style="list-style-type: disc">How and when to use presenters</li><li class="listitem" style="list-style-type: disc">How to easily create pagination</li><li class="listitem" style="list-style-type: disc">How to use the slug observer</li><li class="listitem" style="list-style-type: disc">What are the <span class="strong"><strong>Auth</strong></span> and <span class="strong"><strong>Email</strong></span> packages and how to use them</li><li class="listitem" style="list-style-type: disc">How to parse markdown</li><li class="listitem" style="list-style-type: disc">How to use <span class="strong"><strong>WYSIWYGS </strong></span>editors and display their content</li></ul></div><p>The aim of this chapter is also to consolidate your acquired knowledge, and thus the implementation will be a little longer and more repetitive than usual. Please take your time to analyze and understand how each part works, and play around by tweaking or adding features. </p><div class="section" title="Specifications"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Specifications</h1></div></div></div><p>First, let's define <a id="id213" class="indexterm"/>what should be expected in our final<a id="id214" class="indexterm"/> application:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A blog displays posts. A post is described by a title, a small description (that acts as a summary), the post's content, a category, a publication date, and an author.</li><li class="listitem" style="list-style-type: disc">The blog's home page displays a paginated list of posts. If the user clicks on the title, he should be able to see the full version of the post.</li><li class="listitem" style="list-style-type: disc">By clicking on the post category, a similar list should appear, but only displaying the posts belonging to this category.</li><li class="listitem" style="list-style-type: disc">Posts and categories should only be created and edited by authenticated users in the administration interface.</li><li class="listitem" style="list-style-type: disc">The length of the post's small description should be limited to 200 characters and edited in the Markdown syntax.</li><li class="listitem" style="list-style-type: disc">The content should be edited with a WYSIWYG plugin.</li><li class="listitem" style="list-style-type: disc">The administrators should be able to moderate comments.</li><li class="listitem" style="list-style-type: disc">Each time <a id="id215" class="indexterm"/>someone writes a comment, an email should be sent to the post's author.</li><li class="listitem" style="list-style-type: disc">We<a id="id216" class="indexterm"/> want to be able to easily install a new blog on other websites.</li></ul></div></div></div>
<div class="section" title="Conception"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Conception</h1></div></div></div><p>Let's try to determine our models from the preceding specifications. Post is obviously a model, as it is the main feature of our blog (we display posts). Each post is created and updated by an <a id="id217" class="indexterm"/>authenticated user, meaning that users have to be saved into the database; therefore, we also have a <span class="strong"><strong>User</strong></span> model. There can be posts without<a id="id218" class="indexterm"/> comments, and categories without any posts, meaning they belong<a id="id219" class="indexterm"/> to distinct models; therefore, there is also<a id="id220" class="indexterm"/> a <span class="strong"><strong>Category</strong></span> and a <span class="strong"><strong>Comment</strong></span> model.</p><p>That sums up to four models:</p><div class="mediaobject"><img src="graphics/5401OS_03_01.jpg" alt="Conception"/><div class="caption"><p>Entity Relationship diagram (Min-Max notation)</p></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Post</strong></span>: This model has the following properties: title, small description, content, and publication date. A post is linked to a unique category and each category has many posts, so<a id="id221" class="indexterm"/> we will add an additional column here, named <code class="literal">category_id</code>. Similarly, each post belongs to a user (the author), so we will add the <code class="literal">user_id</code> column.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Category</strong></span>: This model only has a name property.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Comment</strong></span>: This<a id="id222" class="indexterm"/> model has the following properties: name, email, status and content. Since a comment belongs to a unique post and each post can have many comments, we will also add a <code class="literal">post_id</code> column. When a comment is posted by a visitor, its status value will be <code class="literal">pending</code>, since it has not been reviewed. The administrator can publish or hide each comment by changing their status in the administration panel to <code class="literal">published</code> or <code class="literal">not_published</code>.</li></ul></div><p>We will not generate a <span class="strong"><strong>User</strong></span> model. We will use the one from the Auth package, that will manage users and their<a id="id223" class="indexterm"/> authentication for us.</p></div>
<div class="section" title="Preliminary steps"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Preliminary steps</h1></div></div></div><p>You first need to:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install a<a id="id224" class="indexterm"/> new FuelPHP instance</li><li class="listitem">Configure Apache and your host file to handle it: in this chapter, we will access our application by<a id="id225" class="indexterm"/> requesting the <code class="literal">http://myblog.app</code> URL.</li><li class="listitem">Update Composer if necessary</li><li class="listitem">Create a new database for your application</li><li class="listitem">And configure FuelPHP in order to allow your application to access this database</li></ol></div><p>These steps have been covered in <a class="link" href="ch01.html" title="Chapter 1. Building Your First FuelPHP Application">Chapter 1</a>, <span class="emphasis"><em>Building Your First FuelPHP Application</em></span>, so you might want to take a look at it.</p><p>This project will also need the ORM and Auth packages. We have already used the ORM package, and as written earlier, the Auth package will allow us to manage our users and their authentication. Since both packages are already installed, we just need to enable them. For doing this, simply open the <code class="literal">APPPATH/config/config.php</code> file and insert at the end of the returned array the following code:</p><div class="informalexample"><pre class="programlisting">'always_load'  =&gt; array(
    'packages'  =&gt; array(
        'orm',
        'auth',
    ),
),</pre></div><p>Or you can uncomment the appropriate lines. This will load the <code class="literal">ORM</code> and <code class="literal">Auth</code> package every time a FuelPHP instance is loaded.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>You can also load a package in an ad hoc manner, using the <code class="literal">Package::load</code> method. This will be addressed later in this chapter when we will use the <code class="literal">Email</code> package.</p></div></div><p>We also need to change few configuration items for the <code class="literal">Auth</code> package. First, copy the <code class="literal">PKGPATH/auth/config/auth.php</code> configuration file to <code class="literal">APPPATH/config/auth.php</code> (this configuration file will overwrite the one of the <code class="literal">Auth</code> package) and replace:</p><div class="informalexample"><pre class="programlisting">'driver' =&gt; 'Simpleauth',</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">'driver' =&gt; 'Ormauth',</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>One reason we chose to use the <code class="literal">Ormauth</code> driver is that it has a much more fine-grained ACL system than the <code class="literal">Simpleauth</code> driver. <code class="literal">Ormauth</code> is more flexible and manages users, groups, roles, and permissions, whereas <code class="literal">Simpleauth</code> only manages users, groups, and roles. Another reason is that <code class="literal">Ormauth</code> already contains migrations and models managing all these components. In a nutshell, we mainly chose this driver because it is easy to set up and shows the<a id="id226" class="indexterm"/> whole scope of what is possible. However, it is important to point out that we will only use a very small fraction of its features and we could have limited ourselves to the <code class="literal">Simpleauth</code> driver.</p></div></div><p>Finally, copy the <code class="literal">PKGPATH/auth/config/ormauth.php</code> configuration file to <code class="literal">APPPATH/config/ormauth.php</code>, and set the value of <code class="literal">login_hash_salt</code> to a random string (for security precautions).</p></div>
<div class="section" title="Scaffolding the posts"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Scaffolding the posts</h1></div></div></div><p>We will now, as we did in <a class="link" href="ch01.html" title="Chapter 1. Building Your First FuelPHP Application">Chapter 1</a>, <span class="emphasis"><em>Building Your First FuelPHP Application</em></span> and <a class="link" href="ch02.html" title="Chapter 2. Building a To-do List Application">Chapter 2</a>, <span class="emphasis"><em>Building a To-do List Application</em></span>, generate the necessary code to handle our posts. Since posts should only be created and edited by<a id="id227" class="indexterm"/> authenticated administrators in an administration panel, we will generate the scaffold using <code class="literal">admin</code> (alias <code class="literal">admin/orm</code>):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil generate admin post title:string slug:string small_description:string[200] content:text category_id:int user_id:int</strong></span>
</pre></div><p>The command should output the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Creating controller: APPPATH/classes/controller/base.php</strong></span>
<span class="strong"><strong>Creating controller: APPPATH/classes/controller/admin.php</strong></span>
<span class="strong"><strong>Creating views: APPPATH/views/admin/template.php</strong></span>
<span class="strong"><strong>Creating views: APPPATH/views/admin/dashboard.php</strong></span>
<span class="strong"><strong>Creating views: APPPATH/views/admin/login.php</strong></span>
<span class="strong"><strong>Creating migration: APPPATH/migrations/001_create_posts.php</strong></span>
<span class="strong"><strong>Creating model: APPPATH/classes/model/post.php</strong></span>
<span class="strong"><strong>Creating controller: APPPATH/classes/controller/admin/post.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/admin/post/index.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/admin/post/view.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/admin/post/create.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/admin/post/edit.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/admin/post/_form.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/template.php</strong></span>
</pre></div><p>You will notice that additional files have been created compared to <code class="literal">scaffold/orm</code>. These files fall into two broad categories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first five generated files have been generated to handle the administration panel in a general manner (authentication and layout).</li><li class="listitem" style="list-style-type: disc">The other ones, except the last one, have been generated to specifically handle the post administration.</li></ul></div><p>You can notice<a id="id228" class="indexterm"/> that we haven't yet generated the categories and comments, we will come back to that later. Our priority right now is to make the <a id="id229" class="indexterm"/>administration panel work to see what we are dealing with.</p></div>
<div class="section" title="Migrating part 1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Migrating part 1</h1></div></div></div><p>Now, execute <a id="id230" class="indexterm"/>the migration file that has been generated:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil refine migrate</strong></span>
</pre></div><p>If you request the URL <code class="literal">http://myblog.app/admin</code> and try<a id="id231" class="indexterm"/> to log in, an error will be thrown because no table handling our users exist. To create this table (and all the other ones necessary for the <code class="literal">Ormauth</code> driver), you have to execute the <code class="literal">Auth</code> package migrations. This is done using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil refine migrate --packages=auth</strong></span>
</pre></div><p>The <code class="literal">oil refine migrate</code> command allows you to specify which modules and packages you want to migrate. You can even choose to execute all migrations (from your applications, modules, and packages) with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil refine migrate -all</strong></span>
</pre></div><p>Though in our case it doesn't make any difference, be aware that it will execute even migrations for packages<a id="id232" class="indexterm"/> that are not defined in the <code class="literal">always_load.packages</code> key of the <code class="literal">APPPATH/config/config.php</code> configuration file. Some of you might have expected this behavior, but we felt that it was an important point to stress.</p></div>
<div class="section" title="The administration panel"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>The administration panel</h1></div></div></div><p>Once the<a id="id233" class="indexterm"/> migrations have been executed, request <a id="id234" class="indexterm"/>the following URL:</p><p>
<code class="literal">http://myblog.app/admin</code>
</p><p>During the <a id="id235" class="indexterm"/>migration, the <code class="literal">Auth</code> package created a default user with the following credentials:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Username: admin</li><li class="listitem" style="list-style-type: disc">Password: admin</li></ul></div><p>If you log in using these credentials, the administration panel welcome page will be displayed, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5401OS_03_02.jpg" alt="The administration panel"/></div><p>It is very similar to the default welcome page; the major difference is the upper navigation bar. As you can see in the <code class="literal">APPPATH/views/admin/template.php</code> generated file, the navigation bar automatically detects controllers in the <code class="literal">APPPATH/classes/controller/admin</code> folder and create links toward their index action. Since the <code class="literal">Controller_Admin_Post</code> controller has been generated, there is a link toward the posts list. If you click on it, you should see a CRUD scaffold pretty similar to the one<a id="id236" class="indexterm"/> generated by <code class="literal">scaffold/orm</code>:</p><div class="mediaobject"><img src="graphics/5401OS_03_03.jpg" alt="The administration panel"/></div></div>
<div class="section" title="The Auth package"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>The Auth package</h1></div></div></div><p>If you take a look <a id="id237" class="indexterm"/>at your database now, you should see<a id="id238" class="indexterm"/> that many tables with names that are prefixed by the <span class="strong"><strong>users</strong></span> keyword, have <a id="id239" class="indexterm"/>been created:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">users</li><li class="listitem" style="list-style-type: disc">users_clients</li><li class="listitem" style="list-style-type: disc">users_groups</li><li class="listitem" style="list-style-type: disc">users_group_permissions</li><li class="listitem" style="list-style-type: disc">users_group_roles</li><li class="listitem" style="list-style-type: disc">users_metadata</li><li class="listitem" style="list-style-type: disc">users_permissions</li><li class="listitem" style="list-style-type: disc">users_providers</li><li class="listitem" style="list-style-type: disc">users_roles</li><li class="listitem" style="list-style-type: disc">users_role_permissions</li><li class="listitem" style="list-style-type: disc">users_scopes</li><li class="listitem" style="list-style-type: disc">users_sessions</li><li class="listitem" style="list-style-type: disc">users_sessionscopes</li><li class="listitem" style="list-style-type: disc">users_user_permissions</li><li class="listitem" style="list-style-type: disc">users_user_roles</li></ul></div><p>The <code class="literal">Ormauth</code> driver of the <code class="literal">Auth</code> package manages these tables, and some of them are linked to models located at <code class="literal">PKGPATH/auth/classes/model/auth</code>. As explained earlier, the driver provides a much more complete solution than a simple authentication system, as it manages users, groups, roles, and permissions.</p><p>It is important to point out that two other drivers exist:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Simpleauth</code>, which is a much simpler driver than <code class="literal">Ormauth</code> and only manages users, groups and roles.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Opauth</code>, which allows users to connect using <code class="literal">OAuth</code> or <code class="literal">OpenID</code> providers including Facebook, Twitter, or Google.</li></ul></div><p>As we wil<a id="id240" class="indexterm"/>l use only a very small part of the package, explaining it to its full extent would be out of scope. For more details, you are recommended to<a id="id241" class="indexterm"/> read the official documentation at <a class="ulink" href="http://fuelphp.com/docs/packages/auth/intro.html">http://fuelphp.com/docs/packages/auth/intro.html</a> (It can be accessed through the FuelPHP website by navigating to <span class="strong"><strong>DOCS</strong></span> | <span class="strong"><strong>TABLE OF CONTENTS</strong></span> | <span class="strong"><strong>Auth</strong></span> | <span class="strong"><strong>Introduction</strong></span>)</p><p>It would be good practice to change your admin password, as the current setting (username and password both set to <code class="literal">admin</code>) will be a major security flaw when publishing your project to the production server. You can change it using the <code class="literal">Auth::change_password</code> method, and <a id="id242" class="indexterm"/>for doing that you are recommended to read the method's official documentation at <a class="ulink" href="http://fuelphp.com/docs/packages/auth/ormauth/usage.html#/method_change_password">http://fuelphp.com/docs/packages/auth/ormauth/usage.html#/method_change_password</a> (It can be accessed through the FuelPHP website by navigating to <span class="strong"><strong>DOCS</strong></span> | <span class="strong"><strong>TABLE OF CONTENTS</strong></span> | <span class="strong"><strong>Auth</strong></span> | <span class="strong"><strong>Ormauth</strong></span> | <span class="strong"><strong>Usage</strong></span>).</p><p>We suggest that you execute this method in the console of <span class="strong"><strong>Oil</strong></span> or inside a migration file (it is better if you want to propagate the change to other instances).</p><p>You could also add new users by using the <code class="literal">Auth::create_user</code> method. Note however that, for the long run, creating or using a user management system could be a good idea.</p></div>
<div class="section" title="Creating the Blog module"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Creating the Blog module</h1></div></div></div><p>By creating the post administration interface, we have now completed the first step of our project. Before<a id="id243" class="indexterm"/> generating and implementing our other features, it is important to remember that one additional objective is to easily install blogs <a id="id244" class="indexterm"/>on other websites by reusing the same code. For doing that, we will create a blog module, and this is where we should implement our code.</p><div class="section" title="Moving files to the Blog module"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Moving files to the Blog module</h2></div></div></div><p>The first <a id="id245" class="indexterm"/>step is to specify to FuelPHP where to look for modules. At the end of the <code class="literal">APPPATH/config/config.php</code> configuration file returned <a id="id246" class="indexterm"/>array, add (or uncomment appropriate lines):</p><div class="informalexample"><pre class="programlisting">'module_paths' =&gt; array(
    APPPATH.'modules'.DS
),</pre></div><p>We then need to create our blog module folders. Create a folder located at <code class="literal">APPPATH/modules/blog</code> with the following subfolders:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">classes</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">classes/controller</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">classes/controller/admin</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">classes/model</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">config</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">migrations</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">views</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">views/admin</code></li></ul></div><p>You can also generate all these folders using the following <code class="literal">oil</code> command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil generate module blog –folders=classes/controller/admin,classes/model,config,migrations,views/admin</strong></span>
</pre></div><p>The next step is to move the files we generated earlier to the blog module. As it can be a bit long to complete (some code also need to be changed), we implemented an open source task for that. The repository can be found here:</p><p>
<a class="ulink" href="https://github.com/sdrdis/move_scaffold_to_module">https://github.com/sdrdis/move_scaffold_to_module</a>
</p><p>To install this task, simply<a id="id247" class="indexterm"/> save:</p><p>
<a class="ulink" href="https://raw.githubusercontent.com/sdrdis/move_scaffold_to_module/master/movescaffoldtomodule.php">https://raw.githubusercontent.com/sdrdis/move_scaffold_to_module/master/movescaffoldtomodule.php</a>
</p><p>Into the <code class="literal">APPPATH/tasks/</code> repository.</p><p>Before executing the task and moving all the files, it is important to underline that we will also move the <code class="literal">001_create_posts.php</code> migration file to the blog module. As a consequence, the <code class="literal">oil</code> utility will consider this migration file as a new one and try to execute it. We could leave it as it is; since the migration checks if the <code class="literal">posts</code> table exists before trying to create it, it will successfully be executed, though it won't do anything. But the <code class="literal">oil</code> utility will have saved that a <code class="literal">001_create_posts.php</code> migration has been executed in the application folder, so this isn't the cleanest solution. Since we haven't entered any<a id="id248" class="indexterm"/> relevant post right now, let's first undo this migration by executing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil refine migrate:down</strong></span>
</pre></div><p>Then execute the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil r moveScaffoldToModule -scaffold=post -module=blog</strong></span>
</pre></div><p>The command<a id="id249" class="indexterm"/> should output (<code class="literal">BLOGPATH</code> being the path of the blog module):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Creating controller: BLOGPATH/classes/controller/admin/post.php</strong></span>
<span class="strong"><strong>Deleting controller: APPPATH/classes/controller/admin/post.php</strong></span>
<span class="strong"><strong>Creating model: BLOGPATH/classes/model/post.php</strong></span>
<span class="strong"><strong>Deleting model: APPPATH/classes/model/post.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/admin/post/create.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/admin/post/edit.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/admin/post/index.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/admin/post/view.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/admin/post/_form.php</strong></span>
<span class="strong"><strong>Deleting views: APPPATH/views/admin/post</strong></span>
<span class="strong"><strong>Creating migration: BLOGPATH/migrations/001_create_posts.php</strong></span>
<span class="strong"><strong>Deleting migration: APPPATH/migrations/001_create_posts.php</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>This task was created for making your life easier when implementing this project. Please note, it supposes that the code was directly generated from the <code class="literal">oil</code> utility and that you didn't make any changes inside it. It can certainly be improved.</p><p>Hopefully, it won't be needed anymore in FuelPHP 1.8 as a <code class="literal">--module</code> option might be implemented in the <code class="literal">oil generate scaffold</code> and <code class="literal">oil generate admin</code> commands, allowing developers to directly generate scaffolds inside a module.</p></div></div><p>Now, let's<a id="id250" class="indexterm"/> execute the migration file<a id="id251" class="indexterm"/> inside the blog module:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil refine migrate --modules=blog</strong></span>
</pre></div></div><div class="section" title="Improving the navigation bar"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Improving the navigation bar</h2></div></div></div><p>You might have <a id="id252" class="indexterm"/>noticed that, though our post administration<a id="id253" class="indexterm"/> panel can be accessed by requesting<a id="id254" class="indexterm"/> the following URL:</p><p>
<code class="literal">http://myblog.app/blog/admin/post</code>
</p><p>It doesn't appear in the upper navigation bar anymore. If we take a look at the administration template located at <code class="literal">APPPATH/views/admin/template.php</code>, we can see that those links are generated by the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?php
    $files = new GlobIterator(APPPATH.'classes/controller/admin/*.php');
foreach($files as $file)
    {
        $section_segment = $file-&gt;getBasename('.php');
        $section_title = Inflector::humanize($section_segment);
        ?&gt;
&lt;li class="&lt;?php echo Uri::segment(2) == $section_segment ? 'active' : '' ?&gt;"&gt;
&lt;?php echo Html::anchor('admin/'.$section_segment, $section_title) ?&gt;
&lt;/li&gt;
&lt;?php
    }
?&gt;</pre></div><p>As you can see, the links are currently created according to files located at <code class="literal">APPPATH/classes/controller/admin/</code>. However, we would like to support modules by looking for files in the <code class="literal">classes/controller/admin</code> subdirectory of each module. For doing this, replace this code by the following:</p><div class="informalexample"><pre class="programlisting">&lt;?php
// Get the navigation bar's links from an helper. We moved
// the code there because it is a bit long.
$links = Helper::get_navigation_bar_links();

foreach ($links as $link) {
    // A link will be active if the current url starts with
    // its url. For instance, we want the post link to be
    // active when requesting these urls:
    // http://myblog.app/blog/admin/post
    // http://myblog.app/blog/admin/post/create
    // http://myblog.app/blog/admin/post/view/1
    // ...
    $active = Str::starts_with(
        Uri::current(),
        Uri::base().$link['url']
    );
    ?&gt;
&lt;li class="&lt;?php echo $active ? 'active' : '' ?&gt;"&gt;
&lt;?php echo Html::anchor(
            $link['url'],
            $link['title']
        ) ?&gt;
&lt;/li&gt;
&lt;?php
}
?&gt;</pre></div><p>Create <a id="id255" class="indexterm"/>the helper <a id="id256" class="indexterm"/>at the location <code class="literal">APPPATH/classes/helper.php</code> and add the following content (read the comments for more information):</p><div class="informalexample"><pre class="programlisting">&lt;?php
class Helper {
    static function get_navigation_bar_links() {
        // This method will return a list of links. Each
        // link will contain a title and a url.
        $links = array();

        // For all admin controllers of our application
        $files = new GlobIterator(
            APPPATH.'classes/controller/admin/*.php'
        );
        foreach($files as $file)
        {
            // Url and title are deducted from the file
            // basename
            $section_segment = $file-&gt;getBasename('.php');
            $links[] = array(
                'title' =&gt; Inflector::humanize(
                    $section_segment
                ),
                'url' =&gt; 'admin/'.$section_segment,
            );
        }

        // Currently, only one path is defined:
        // APPPATH/module. But this could to change.
        $module_paths = \Config::get('module_paths');
        foreach ($module_paths as $module_path) {
            // For each admin controller of each module
            $files = new GlobIterator(
                $module_path
                .
                '*/classes/controller/admin/*.php'
            );
            foreach($files as $file)
            {
                // We get the module name from the path...
                $exploded_path = explode(
                    '/',
                    $file-&gt;getPath()
                );
                $module = $exploded_path[
                    count($exploded_path) - 4
                ];
                $section_segment = $file-&gt;getBasename('.php');
                $links[] = array(
                    'title' =&gt; Inflector::humanize(
                        $section_segment
                    ),
                    'url' =&gt; $module.'/admin/'.$section_segment,
                );
            }
        }

        return $links;
    }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>Note that the above code supposes that all modules containing at least an admin controller can be requested.</p></div></div><p>If you refresh your administration panel, the <span class="strong"><strong>Post</strong></span> link should appear in the upper navigation toolbar.</p><p>One caveat of this solution is that you have to perform the same changes on each new project if <a id="id257" class="indexterm"/>you want to display the <span class="strong"><strong>Post</strong></span> link in the navigation toolbar. However, the solution is universal in the sense that, if you add other modules and admin controllers, their links will automatically appear. Moreover, if you don't use this solution, you will still be able<a id="id258" class="indexterm"/> to manage posts via the following URL:</p><p>
<code class="literal">http://myblog.app/blog/admin/post</code>
</p></div></div>
<div class="section" title="Scaffolding the rest of our project"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Scaffolding the rest of our project</h1></div></div></div><p>Now that the post<a id="id259" class="indexterm"/> administration panel is working and inside the blog module, it is time to generate our other models.</p><div class="section" title="Scaffolding categories"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Scaffolding categories</h2></div></div></div><p>Let's first take care of the Category model.</p><div class="section" title="Generating files"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec21"/>Generating files</h3></div></div></div><p>This step<a id="id260" class="indexterm"/> is quite straightforward; as we did previously, we will use the <code class="literal">oil</code> command to generate our scaffold:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil generate admin/orm category name:string -s</strong></span>
</pre></div><p>Note that we added the <code class="literal">-s</code> (<code class="literal">s</code> for skip) parameter, as some files have already been generated previously and we don't want to replace them. This command line should output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Creating migration: APPPATH/migrations/002_create_categories.php</strong></span>
<span class="strong"><strong>Creating model: APPPATH/classes/model/category.php</strong></span>
<span class="strong"><strong>Creating controller: APPPATH/classes/controller/admin/category.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/admin/category/index.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/admin/category/view.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/admin/category/create.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/admin/category/edit.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/admin/category/_form.php</strong></span>
</pre></div><p>Don't launch the generated migration though; we will first move the code to our blog module.</p></div><div class="section" title="Moving categories to the blog module"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec22"/>Moving categories to the blog module</h3></div></div></div><p>Let's use the <code class="literal">moveScaffoldToModule</code> task to move the category<a id="id261" class="indexterm"/> scaffold into the blog module:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil r moveScaffoldToModule -scaffold=category -module=blog</strong></span>
</pre></div><p>The command should output (<code class="literal">BLOGPATH</code> being the path of the blog module):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Creating controller: BLOGPATH/classes/controller/admin/category.php</strong></span>
<span class="strong"><strong>Deleting controller: APPPATH/classes/controller/admin/category.php</strong></span>
<span class="strong"><strong>Creating model: BLOGPATH/classes/model/category.php</strong></span>
<span class="strong"><strong>Deleting model: APPPATH/classes/model/category.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/admin/category/create.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/admin/category/edit.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/admin/category/index.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/admin/category/view.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/admin/category/_form.php</strong></span>
<span class="strong"><strong>Deleting views: APPPATH/views/admin/category</strong></span>
<span class="strong"><strong>Creating migration: BLOGPATH/migrations/002_create_categories.php</strong></span>
<span class="strong"><strong>Deleting migration: APPPATH/migrations/002_create_categories.php</strong></span>
</pre></div></div><div class="section" title="Migrating"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec23"/>Migrating</h3></div></div></div><p>Now we just have to<a id="id262" class="indexterm"/> execute our migration file. To do that, enter the following command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil refine migrate --modules=blog</strong></span>
</pre></div><p>If you access your administration panel, you should now be able to manage categories.</p></div></div><div class="section" title="Scaffolding comments"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Scaffolding comments</h2></div></div></div><p>This section is quite<a id="id263" class="indexterm"/> similar to the previous one. First, generate the scaffold:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil generate admin/orm comment name:string email:string content:text status:string post_id:integer -s</strong></span>
</pre></div><p>This command should output the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Creating migration: APPPATH/migrations/002_create_comments.php</strong></span>
<span class="strong"><strong>Creating model: APPPATH/classes/model/comment.php</strong></span>
<span class="strong"><strong>Creating controller: APPPATH/classes/controller/admin/comment.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/admin/comment/index.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/admin/comment/view.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/admin/comment/create.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/admin/comment/edit.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/admin/comment/_form.php</strong></span>
</pre></div><p>Then, move the scaffold to the blog module:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil r moveScaffoldToModule -scaffold=comment -module=blog</strong></span>
</pre></div><p>This command should output the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Creating controller: BLOGPATH/classes/controller/admin/comment.php</strong></span>
<span class="strong"><strong>Deleting controller: APPPATH/classes/controller/admin/comment.php</strong></span>
<span class="strong"><strong>Creating model: BLOGPATH/classes/model/comment.php</strong></span>
<span class="strong"><strong>Deleting model: APPPATH/classes/model/comment.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/admin/comment/create.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/admin/comment/edit.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/admin/comment/index.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/admin/comment/view.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/admin/comment/_form.php</strong></span>
<span class="strong"><strong>Deleting views: APPPATH/views/admin/comment</strong></span>
<span class="strong"><strong>Creating migration: BLOGPATH/migrations/003_create_comments.php</strong></span>
<span class="strong"><strong>Deleting migration: APPPATH/migrations/002_create_comments.php</strong></span>
</pre></div><p>Before launching the migration file, we will improve it by changing the <code class="literal">status</code> column type to <code class="literal">ENUM</code>, since there are only three possible values: <code class="literal">not_published</code>, <code class="literal">pending</code>, and <code class="literal">published</code>. To do that, edit the <code class="literal">BLOGPATH/migrations/003_create_comments.php</code> file and replace the following line:</p><div class="informalexample"><pre class="programlisting">'status' =&gt; array('constraint' =&gt; 11, 'type' =&gt; 'int'),</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">'status' =&gt; array(
    'constraint' =&gt; "'not_published','pending','published'",
    'type' =&gt; 'enum',
    'default' =&gt; 'pending'
),</pre></div><p>And finally, launch the migration file using oil:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil refine migrate --modules=blog</strong></span>
</pre></div><p>Comments should <a id="id264" class="indexterm"/>now be manageable in the administration interface.</p></div><div class="section" title="Scaffolding posts (front)"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Scaffolding posts (front)</h2></div></div></div><p>In order to have<a id="id265" class="indexterm"/> a starting point, we are going to generate the scaffold of posts for the front. We will, of course, change the controller a lot, because we don't want visitors to edit and create posts.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Before doing anything, check that no file has been generated at <code class="literal">APPPATH/views/template.php</code> (as I write, <code class="literal">oil generate admin/orm</code> seems to generate an incorrect file at that location). If that is the case, delete that file: it will be regenerated later by oil.</p></div></div><p>Enter the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil generate scaffold/orm post title:string slug:string small_description:string[200] content:text category_id:int user_id:int</strong></span>
</pre></div><p>It should output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Creating migration: APPPATH/migrations/002_create_posts.php</strong></span>
<span class="strong"><strong>Creating model: APPPATH/classes/model/post.php</strong></span>
<span class="strong"><strong>Creating controller: APPPATH/classes/controller/post.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/post/index.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/post/view.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/post/create.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/post/edit.php</strong></span>
<span class="strong"><strong>Creating view: APPPATH/views/post/_form.php</strong></span>
</pre></div><p>Now move the scaffold to the blog module by entering the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil r moveScaffoldToModule -scaffold=post -module=blog</strong></span>
</pre></div><p>This should print the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Creating controller: BLOGPATH/classes/controller/post.php</strong></span>
<span class="strong"><strong>Deleting controller: APPPATH/classes/controller/post.php</strong></span>
<span class="strong"><strong>Deleting model: APPPATH/classes/model/post.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/post/create.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/post/edit.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/post/index.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/post/view.php</strong></span>
<span class="strong"><strong>Creating view: BLOGPATH/views/post/_form.php</strong></span>
<span class="strong"><strong>Deleting views: APPPATH/views/post</strong></span>
<span class="strong"><strong>Deleting migration: APPPATH/migrations/002_create_posts.php</strong></span>
</pre></div><p>Note that, as a migration file with as similar file name was already in the blog module, the task simply removed the one in the application directory (without copying it into the blog module). This is the expected behavior since a migration that creates the posts table already exists in the module.</p><p>You should be able<a id="id266" class="indexterm"/> to access the scaffold by requesting the<a id="id267" class="indexterm"/> following URL:</p><p>
<code class="literal">http://myblog.app/blog/post</code>
</p></div></div>
<div class="section" title="Refining the administration panel"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Refining the administration panel</h1></div></div></div><p>Now that all the scaffolds<a id="id268" class="indexterm"/> have been created, it is time to refine our administration panel:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">As categories<a id="id269" class="indexterm"/> are very simple models (they only have a <code class="literal">name</code> attribute), the <span class="strong"><strong>View</strong></span> link doesn't give the user more information than in the listing, so we will remove it. We will also display the number of posts associated with each category in the categories list; it will give us an idea of the most used categories.</li><li class="listitem" style="list-style-type: disc">We don't need to create new comments inside the administration panel, so we need to remove the associated links and actions. We also need to do some improvements in the edition form and in the listing.</li><li class="listitem" style="list-style-type: disc">Same for the posts; we will remove most columns when listing posts, we will add a WYSIWYG editor, a markdown editor and a category select box inside the post creation and edition forms.</li></ul></div><p>Note that there could be a lot of other improvements. You are recommended to add the changes you <a id="id270" class="indexterm"/>deem necessary.</p><div class="section" title="Refining the posts administration panel"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Refining the posts administration panel</h2></div></div></div><p>Let's start with the <a id="id271" class="indexterm"/>posts administration panel. You might want to add some categories for the purpose of testing. Note that <a id="id272" class="indexterm"/>you should be able to test your application again at the end of each section.</p><div class="section" title="Improving the post creation and edition forms"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec24"/>Improving the post creation and edition forms</h3></div></div></div><p>We will begin <a id="id273" class="indexterm"/>with the creation/edition form. We <a id="id274" class="indexterm"/>generated it and, as we saw in the previous chapters, the view managing this form can be found at: <code class="literal">BLOGPATH/views/admin/post/_form.php</code>.</p><div class="section" title="Removing and automatically filling the slug"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec16"/>Removing and automatically filling the slug</h4></div></div></div><p>The <span class="strong"><strong>slug</strong></span> property should only depend on the title, and it will be used in URLs for improving the SEO. Its <a id="id275" class="indexterm"/>value will be automatically filled from the title, so we don't need its related field in the form. Therefore, remove the second <code class="literal">div</code> with the class <code class="literal">form-group</code> along <a id="id276" class="indexterm"/>with its content (which contains the <code class="literal">slug</code> input).</p><p>To automatically fill its value, we will use an observer (as for the <code class="literal">created_at</code> and <code class="literal">updated_at</code> columns); <code class="literal">Orm\Observer_Slug</code>. In a model's instance, this observer takes a property value and saves its slug version into a second property. In the default case, without any additional configuration, it will take the value of <code class="literal">title</code> and save its slug version into <code class="literal">slug</code>. This is exactly our case, so it will be pretty simple, but you are recommended to read the official <a id="id277" class="indexterm"/>documentation for more information:</p><p>
<a class="ulink" href="http://fuelphp.com/docs/packages/orm/observers/included.html#os_slug">http://fuelphp.com/docs/packages/orm/observers/included.html#os_slug</a>
</p><p>(It can be accessed through FuelPHP website by navigating to <span class="strong"><strong>DOCS</strong></span> | <span class="strong"><strong>TABLE OF CONTENTS</strong></span> | <span class="strong"><strong>ORM</strong></span> | <span class="strong"><strong>Observers+</strong></span> | <span class="strong"><strong>Included observers</strong></span>)</p><p>Open the <span class="strong"><strong>Post</strong></span> model located at <code class="literal">BLOGPATH/classes/model/post.php</code> and add the following at the end of the <code class="literal">$_observers</code> property:</p><div class="informalexample"><pre class="programlisting">'Orm\\Observer_Slug',</pre></div><p>Finally, we have to remove all elements related to the <span class="strong"><strong>Slug</strong></span> field processing.</p><p>First, in the <code class="literal">validate</code> method of the <span class="strong"><strong>Post</strong></span> model, remove:</p><div class="informalexample"><pre class="programlisting">$val-&gt;add_field('slug', 'Slug', 'required|max_length[255]');</pre></div><p>Then, open the <span class="strong"><strong>Post</strong></span> controller located at <code class="literal">BLOGPATH/classes/controller/admin/post.php</code> and remove:</p><div class="informalexample"><pre class="programlisting">'slug' =&gt; Input::post('slug'),</pre></div><p>And:</p><div class="informalexample"><pre class="programlisting">$post-&gt;slug = Input::post('slug');</pre></div><p>And:</p><div class="informalexample"><pre class="programlisting">$post-&gt;slug = $val-&gt;validated('slug');</pre></div></div><div class="section" title="Changing the small description input to a textarea"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec17"/>Changing the small description input to a textarea</h4></div></div></div><p>We want <a id="id278" class="indexterm"/>to change the small description input into a <code class="literal">textarea</code>, because though its length is limited to 200 characters, the standard input isn't user friendly. Replace:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo Form::input('small_description', ... ); ?&gt;</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">&lt;?php
echo Form::textarea(
    'small_description',
    Input::post(
        'small_description',
isset($post) ? $post-&gt;small_description : ''
    ),
    array(
        'class' =&gt; 'col-md-4 form-control',
        'placeholder' =&gt; 'Small description',
        'rows' =&gt; 4,
        'maxlength' =&gt; 200,
    )
);
?&gt;</pre></div><p>We <a id="id279" class="indexterm"/>want to write content using the markdown syntax (take a look at <a class="ulink" href="https://en.wikipedia.org/wiki/Markdown">https://en.wikipedia.org/wiki/Markdown</a> if you are not familiar with it) and display the formatted small description in our front end, but we won't need to change anything else for now since this formatting process will happen in our front views. Though, you could add a JavaScript markdown plugin here to make this <code class="literal">textarea</code> even more user-friendly.</p></div><div class="section" title="Editing the post content using a WYSIWYG editor"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec18"/>Editing the post content using a WYSIWYG editor</h4></div></div></div><p>The next form item is<a id="id280" class="indexterm"/> the content and we want to edit it with a WYSIWYG editor. We just have to add a JavaScript plugin. We will use <span class="strong"><strong>TinyMCE</strong></span>, a well-known open source WYSIWYG editor.</p><p>First, you will need to include the TinyMCE JavaScript file. Open the template file located at <code class="literal">APPPATH/views/admin/template.php</code> and add:</p><div class="informalexample"><pre class="programlisting">'//tinymce.cachefly.net/4.1/tinymce.min.js'</pre></div><p>At the end of the <code class="literal">Asset::js</code> first array parameter.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>Note that we<a id="id281" class="indexterm"/> used the JavaScript file hosted on TinyMCE's recommended CDN at the time this book was written. Depending on when you read this book and your requirements, you might want to use a different URL or host TinyMCE on your servers.</p></div></div><p>Next, we need to specify to TinyMCE which <code class="literal">textarea</code> has to be transformed to WYSIWGs. Inside the same template, add the following at the end of the first <code class="literal">script</code> tag:</p><div class="informalexample"><pre class="programlisting">// Transforms textareas with the wysiwyg class to wysiwygs
tinymce.init({selector:'textarea.wysiwyg'});</pre></div><p>Finally, we need to add the <code class="literal">wysiwyg</code> class to our content <code class="literal">textarea</code>. Return  to the file located at <code class="literal">APPPATH/views/admin/post/_form.php</code>, search for <code class="literal">Form::textarea('content'</code> and inside this method call, replace:</p><div class="informalexample"><pre class="programlisting">'class' =&gt; 'col-md-8 form-control'</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">'class' =&gt; 'col-md-8 form-control wysiwyg'</pre></div></div><div class="section" title="Replacing the category input by a select box"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec19"/>Replacing the category input by a select box</h4></div></div></div><p>The next item in the <a id="id282" class="indexterm"/>form is <span class="strong"><strong>Category id</strong></span>. Setting the category id manually is not user friendly for the <a id="id283" class="indexterm"/>administrator; the best would be to display a select box, so that categories can be chosen by their title.</p><p>First, create a view file at <code class="literal">BLOGPATH/views/admin/category/selector.php</code>, and add the following content:</p><div class="informalexample"><pre class="programlisting">&lt;?php
/*
Loading the list of all categories here, since it doesn't
depend on the post being created / edited. (Temporary)
*/
$categories = \Blog\Model_Category::find('all');

$options = array();
foreach ($categories as $category) {
    $options[$category-&gt;id] = $category-&gt;name;
}
echo Form::select('category_id', $category_id, $options);</pre></div><p>Then, back on the <code class="literal">BLOGPATH/views/admin/post/_form.php</code> view file, fix the category field title by replacing:</p><div class="informalexample"><pre class="programlisting">Form::label('Category id', 'category_id'</pre></div><p>With:</p><div class="informalexample"><pre class="programlisting">Form::label('Category', 'category_id'</pre></div><p>And include our select box by replacing:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo Form::input('category_id', ... ) ?&gt;</pre></div><p>With:</p><div class="informalexample"><pre class="programlisting">&lt;div&gt;
&lt;?php
$select_box = \View::forge('admin/category/selector');

// Other way to set a view parameter; sets the $category_id
// variable.
$select_box-&gt;set(
    'category_id',
    Input::post(
        'category_id',
        isset($post) ? $post-&gt;category_id : null
    )
);

echo $select_box;
?&gt;
&lt;/div&gt;</pre></div><p>If you test the form, the select box should be working. But there is a small issue; when we created the selector view, we loaded a list of categories inside the view. This isn't respecting the<a id="id284" class="indexterm"/> MVC pattern, as we are loading models inside a view. But it would not make sense to load these objects inside the <span class="strong"><strong>Post</strong></span> <a id="id285" class="indexterm"/>controller, because the view doesn't actually depend on any post; we always load all categories, no matter the context. As written earlier in <a class="link" href="ch01.html" title="Chapter 1. Building Your First FuelPHP Application">Chapter 1</a>, <span class="emphasis"><em>Building Your First FuelPHP Application</em></span>, we should use a presenter in that case. Luckily, we don't need to make many changes.</p><p>First, create the presenter file at <code class="literal">BLOGPATH/classes/presenter/admin/category/selector.php</code> and add the following content:</p><div class="informalexample"><pre class="programlisting">&lt;?php
namespace Blog;

class Presenter_Admin_Category_Selector extends \Presenter
{
    public function view()
    {
        $this-&gt;categories = Model_Category::find('all');
    }
}</pre></div><p>Then, edit the <code class="literal">BLOGPATH/views/admin/post/_form.php</code> view file to replace the following line:</p><div class="informalexample"><pre class="programlisting">$select_box = \View::forge('admin/category/selector');</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">$select_box = \Presenter::forge('admin/category/selector');</pre></div><p>And finally, edit the <code class="literal">BLOGPATH/views/admin/category/selector.php</code> view and remove the following line:</p><div class="informalexample"><pre class="programlisting">$categories = \Blog\Model_Category::find('all');</pre></div><p>Though we won't need them immediately, we will add the relations between the post and category models. Since each post can only have one category, and each category can be related to<a id="id286" class="indexterm"/> many posts, there is a <code class="literal">belongs_to</code> relationship between posts and categories, and a <code class="literal">has_many</code> relationship between categories and posts.</p><p>First, open the <span class="strong"><strong>Post</strong></span> model located at <code class="literal">BLOGPATH/classes/model/post.php</code>, and add the following code inside the class:</p><div class="informalexample"><pre class="programlisting">protected static $_belongs_to = array('category');</pre></div><p>Then, open the <span class="strong"><strong>Category</strong></span> model located at <code class="literal">BLOGPATH/classes/model/category.php</code>, and add the following code inside the class:</p><div class="informalexample"><pre class="programlisting">protected static $_has_many = array('posts');</pre></div></div><div class="section" title="Replacing the user_id field by author"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec20"/>Replacing the user_id field by author</h4></div></div></div><p>The last field in our form is the <span class="strong"><strong>user_id field</strong></span>. We will replace this field by an author field. This field won't be editable; the author of a post will simply be the authenticated user that creates it.</p><p>We first need to <a id="id287" class="indexterm"/>add the relation between posts and users; since each post can only be related to a single user, and users can have as many posts as they want, the relation's type is <code class="literal">belongs_to</code>.</p><p>Open the <span class="strong"><strong>Post</strong></span> model located at <code class="literal">BLOGPATH/classes/model/post.php</code> and add the following at the end of the <code class="literal">$_belongs_to</code> array:</p><div class="informalexample"><pre class="programlisting">'author' =&gt; array(
    'model_to'          =&gt; 'Auth\Model\Auth_User',
    'key_from'          =&gt; 'user_id',
    'key_to'            =&gt; 'id',
    'cascade_save'      =&gt; true,
    'cascade_delete'    =&gt; false,
),</pre></div><p>Next, we will change how the field is displayed in the creation/edition form. Open <code class="literal">BLOGPATH/views/admin/post/_form.php</code>, and first replace:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo Form::label('User id', ... ); ?&gt;</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo Form::label('Author'); ?&gt;</pre></div><p>And then replace:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo Form::input('user_id', ... ); ?&gt;</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">&lt;div&gt;
&lt;?php
/*
This field is not editable, so we simply display the author.
current_user is a global variable that defines the current
logged user.
*/
$author = isset($post) ? $post-&gt;author : $current_user;
echo $author-&gt;username;
?&gt;
&lt;/div&gt;</pre></div><p>And finally, we need the <span class="strong"><strong>Post</strong></span> controller to reflect that behavior. For doing that, we first change how the <code class="literal">user_id</code> attribute is saved in the create and edit actions. Open the <span class="strong"><strong>Post</strong></span> controller located at <code class="literal">BLOGPATH/classes/controller/admin/post.php</code>, and, inside the create action, replace the following:</p><div class="informalexample"><pre class="programlisting">'user_id' =&gt; Input::post('user_id'),</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">'user_id' =&gt; $this-&gt;current_user-&gt;id,</pre></div><p>And inside the edit action, simply delete the following line:</p><div class="informalexample"><pre class="programlisting">$post-&gt;user_id = Input::post('user_id');</pre></div><p>And:</p><div class="informalexample"><pre class="programlisting">$post-&gt;user_id = $val-&gt;validated('user_id');</pre></div><p>Though, you still won't be able to create a new post now, as the following message will appear: <span class="strong"><strong>The field User Id is required and must contain a value</strong></span>. This is happening because of the <span class="strong"><strong>Post</strong></span> model <code class="literal">validate</code> method. The remaining thing to do is to remove the <code class="literal">user_id</code> validation. Open the <span class="strong"><strong>Post</strong></span> model located at <code class="literal">BLOGPATH/classes/model/post.php</code>, and remove the following line inside the <code class="literal">validate</code> method:</p><div class="informalexample"><pre class="programlisting">$val-&gt;add_field('user_id', ... );</pre></div></div><div class="section" title="Removing the View link"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec21"/>Removing the View link</h4></div></div></div><p>Since we are not interested in keeping the detailed view of posts, we can remove the <code class="literal">View</code> link. Open <code class="literal">BLOGPATH/views/admin/post/edit.php</code> and remove the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo Html::anchor(..., 'View'); ?&gt; |</pre></div></div></div><div class="section" title="The posts' list"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec25"/>The posts' list</h3></div></div></div><p>If you have tested the form we improved to create new posts, you have <a id="id288" class="indexterm"/>probably noticed that the listing is not well adapted.</p><div class="section" title="Removing the Slug, Small description and Content columns"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec22"/>Removing the Slug, Small description and Content columns</h4></div></div></div><p>The first issue is that the <span class="strong"><strong>Slug</strong></span>, <span class="strong"><strong>Small description</strong></span>, and <span class="strong"><strong>Content</strong></span> columns are displayed, though their<a id="id289" class="indexterm"/> value's length can be important. Since this can have a terrible effect on the table layout, we will <a id="id290" class="indexterm"/>have to remove them. Open the<a id="id291" class="indexterm"/> listing view located at <code class="literal">BLOGPATH/views/admin/post/index.php</code> and remove the following lines:</p><div class="informalexample"><pre class="programlisting">&lt;th&gt;Slug&lt;/th&gt;
&lt;th&gt;Small description&lt;/th&gt;
&lt;th&gt;Content&lt;/th&gt;</pre></div><p>And:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt;&lt;?php echo $item-&gt;slug; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $item-&gt;small_description; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $item-&gt;content; ?&gt;&lt;/td&gt;</pre></div></div><div class="section" title="Displaying the category and author names"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec23"/>Displaying the category and author names</h4></div></div></div><p>The second issue is<a id="id292" class="indexterm"/> that we are displaying the categories' and <a id="id293" class="indexterm"/>users' ids, though displaying their associated names would be more convenient.</p><p>First, change the table titles accordingly by replacing:</p><div class="informalexample"><pre class="programlisting">&lt;th&gt;Category id&lt;/th&gt;</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">&lt;th&gt;Category&lt;/th&gt;</pre></div><p>And the following line:</p><div class="informalexample"><pre class="programlisting">&lt;th&gt;User id&lt;/th&gt;</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">&lt;th&gt;Author&lt;/th&gt;</pre></div><p>And change each line value by replacing:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt;&lt;?php echo $item-&gt;category_id; ?&gt;&lt;/td&gt;</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt;&lt;?php echo $item-&gt;category-&gt;name; ?&gt;&lt;/td&gt;</pre></div><p>And the following line:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt;&lt;?php echo $item-&gt;user_id; ?&gt;&lt;/td&gt;</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt;&lt;?php echo $item-&gt;author-&gt;username; ?&gt;&lt;/td&gt;</pre></div><p>You could leave the code as it is, since the correct information will appear in the listing. But if you activate the profiler, you will notice that if you have several posts, a lot of SQL requests will be executed. As we saw before, this is because we are calling <code class="literal">$item-&gt;category</code> and <code class="literal">$item-&gt;author</code>, and, if not cached, each call executes a SQL request. In order to optimize the <a id="id294" class="indexterm"/>number of requests being made, we will use the <code class="literal">related</code> key. Open the <span class="strong"><strong>Post</strong></span> controller located at <code class="literal">BLOGPATH/classes/controller/post.php</code> and, inside the index <a id="id295" class="indexterm"/>action, replace the following line:</p><div class="informalexample"><pre class="programlisting">$data['posts'] = Model_Post::find('all');</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">$data['posts'] = Model_Post::find(
    'all',
    array(
        'related' =&gt; array(
            'category',
            'author',
        ),
    )
);</pre></div></div><div class="section" title="Removing the view link"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec24"/>Removing the view link</h4></div></div></div><p>Since we are<a id="id296" class="indexterm"/> implementing the administration panel, we can reduce the code to what is strictly necessary. The post edition and visualization is redundant, since we have access to the post information when we are editing it. Thus, we will remove the <span class="strong"><strong>View</strong></span> link. Simply remove the following line:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo Html::anchor(..., 'View'); ?&gt; |</pre></div><p>It is a good idea to remove the <span class="strong"><strong>View</strong></span> action inside the <span class="strong"><strong>Post</strong></span> controller as well as the view located at <code class="literal">BLOGPATH/admin/post/view.php</code>, since they are now useless code.</p></div></div></div><div class="section" title="Refining the categories administration panel"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Refining the categories administration panel</h2></div></div></div><p>Let's now focus<a id="id297" class="indexterm"/> on the categories <a id="id298" class="indexterm"/>administration panel. The <span class="strong"><strong>Category</strong></span> model is quite simple, so there is not much to do. As a matter of fact, we will almost only change the listing page.</p><div class="section" title="Removing the View link"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec26"/>Removing the View link</h3></div></div></div><p>Since the model only has one<a id="id299" class="indexterm"/> attribute that is already displayed on the list, the view link and page are not of much use. First, delete the <span class="strong"><strong>View</strong></span> link inside the view located at <code class="literal">BLOGPATH/views/admin/category/index.php</code> by removing:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo Html::anchor(..., 'View'); ?&gt; |</pre></div><p>You can then remove the <span class="strong"><strong>View</strong></span> action inside the <span class="strong"><strong>Category</strong></span> controller and the view located at <code class="literal">BLOGPATH/views/admin/category/view.php</code>, since they are now useless code.</p><p>We also have to remove the <span class="strong"><strong>View</strong></span> link inside the edition form. Open <code class="literal">BLOGPATH/views/admin/category/edit.php</code> and remove the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo Html::anchor(..., 'View'); ?&gt; |</pre></div></div><div class="section" title="Adding the number of post's column"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec27"/>Adding the number of post's column</h3></div></div></div><p>One challenge<a id="id300" class="indexterm"/> of this section is to display how many posts there are for each category. This is not simple and there is no ideal solution.</p><p>Let's first add our column into our table. Under:</p><div class="informalexample"><pre class="programlisting">&lt;th&gt;Name&lt;/th&gt;</pre></div><p>Add:</p><div class="informalexample"><pre class="programlisting">&lt;th&gt;Number of posts&lt;/th&gt;</pre></div><p>And under:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt;&lt;?php echo $item-&gt;name; ?&gt;&lt;/td&gt;</pre></div><p>Add:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt;&lt;?php /* Depends on solution */ ?&gt;&lt;/td&gt;</pre></div><p>Now let's test different options.</p><div class="section" title="Solution 1: using count"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec25"/>Solution 1: using count</h4></div></div></div><p>The first <a id="id301" class="indexterm"/>solution is quite straightforward; we use the <code class="literal">count</code> method. Replace:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt;&lt;?php /* Depends on solution */ ?&gt;&lt;/td&gt;</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt;
&lt;?php
echo \Blog\Model_Post::count(
    array(
        'where' =&gt; array(
            array('category_id' =&gt; $item-&gt;id)
        )
    )
);
?&gt;
&lt;/td&gt;</pre></div><p>Though the solution is quite simple, there are major drawbacks. Firstly, it doesn't respect the MVC pattern. Secondly, it will generate a request for each category displayed. Don't use this if you have a lot of categories.</p></div><div class="section" title="Solution 2: using related"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec26"/>Solution 2: using related</h4></div></div></div><p>Another solution is to use the <code class="literal">related</code> key. First, open the <span class="strong"><strong>Category</strong></span> controller located at <code class="literal">BLOGPATH/classes/controller/admin/category.php</code> and, inside the index action, replace the following line:</p><div class="informalexample"><pre class="programlisting">$data['categories'] = Model_Category::find('all');</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">$data['categories'] = Model_Category::find(
    'all',
    array(
        'related' =&gt; array(
            'posts',
        ),
    )
);</pre></div><p>And back to the <code class="literal">BLOGPATH/views/admin/category/index.php</code> view, replace:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt;&lt;?php /* Depends on solution */ ?&gt;&lt;/td&gt;</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt;&lt;?php echo count($item-&gt;posts); ?&gt;&lt;/td&gt;</pre></div><p>On the one hand, this solution limits the number of requests but, on the other hand, it might load a lot of useless post instances into the memory, so this is not ideal either. Don't use this if you have<a id="id302" class="indexterm"/> a lot of posts.</p></div><div class="section" title="Solution 3: using DB::query"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec27"/>Solution 3: using DB::query</h4></div></div></div><p>Another solution<a id="id303" class="indexterm"/> is to load categories using <code class="literal">DB::query</code>. First, open the <span class="strong"><strong>Category</strong></span> controller located at <code class="literal">BLOGPATH/classes/controller/admin/category.php</code> and, inside the index action, replace the following line:</p><div class="informalexample"><pre class="programlisting">$data['categories'] = Model_Category::find('all');</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">$data['categories'] = Model_Category::find_all_with_nb_posts();</pre></div><p>Then add the following method inside the <span class="strong"><strong>Category</strong></span> model:</p><div class="informalexample"><pre class="programlisting">public static function find_all_with_nb_posts() {
    return \DB::query(
        'SELECT
            `categories`.*,
            count(`posts`.`id`) as nb_posts
        FROM `categories`
        LEFT JOIN `posts` ON (
            `posts`.`category_id` = `categories`.`id`
        )
        GROUP BY `categories`.id'
    )
    -&gt;as_object('\Blog\Model_Category')
    -&gt;execute()
    -&gt;as_array();
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>It is possible to execute a custom query and then transform the result into model's instances thanks to the <code class="literal">as_object</code> method. In this request, we add a custom column, <code class="literal">nb_posts</code>, that counts the number of posts for each category. This column is accessible in our categories instances under the <code class="literal">nb_posts</code> attribute.</p></div></div><p>And back to the <code class="literal">BLOGPATH/views/admin/category/index.php</code> view, replace:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt;&lt;?php /* Depends on solution */ ?&gt;&lt;/td&gt;</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt;&lt;?php echo $item-&gt;nb_posts ?&gt;&lt;/td&gt;</pre></div><p>This solution is interesting for its performance: no additional queries or memory usage. Its drawback is that it doesn't use the ORM, and this solution might be tricky to implement for<a id="id304" class="indexterm"/> more complex problems.</p><p>For this instance though, we are recommending this solution.</p></div></div></div><div class="section" title="Refining the comments administration panel"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Refining the comments administration panel</h2></div></div></div><p>We also need to make some adjustments here. You are recommended to manually add some comments now, because<a id="id305" class="indexterm"/> you won't be able to<a id="id306" class="indexterm"/> after we change the interface (there would be no point in adding comments through the administration interface, since any user will be able to do it on the website).</p><div class="section" title="Improving the comments listing"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec28"/>Improving the comments listing</h3></div></div></div><p>First, we will improve<a id="id307" class="indexterm"/> the comments<a id="id308" class="indexterm"/> listing.</p><div class="section" title="Removing the view and adding a new comment link"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec28"/>Removing the view and adding a new comment link</h4></div></div></div><p>As we won't need those<a id="id309" class="indexterm"/> features, we will remove their<a id="id310" class="indexterm"/> links, actions and views.</p><p>First, open the <code class="literal">BLOGPATH/views/admin/comment/index.php</code> view file and remove:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo Html::anchor(..., 'View'); ?&gt; |</pre></div><p>And:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo Html::anchor(..., 'Add new Comment', ...); ?&gt;</pre></div><p>And you are also recommended to remove the create and view action of the <span class="strong"><strong>Comment</strong></span> controller, as well as the <code class="literal">BLOGPATH/views/admin/comment/create.php</code> and <code class="literal">BLOGPATH/views/admin/comment/view.php</code> files.</p></div><div class="section" title="Removing the Email and Content columns"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec29"/>Removing the Email and Content columns</h4></div></div></div><p>We will remove<a id="id311" class="indexterm"/> these two columns because they can take too<a id="id312" class="indexterm"/> much space. For doing that, open <code class="literal">BLOGPATH/views/admin/comment/index.php</code> and remove the following lines:</p><div class="informalexample"><pre class="programlisting">&lt;th&gt;Email&lt;/th&gt;
&lt;th&gt;Content&lt;/th&gt;</pre></div><p>And:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt;&lt;?php echo $item-&gt;email; ?&gt;&lt;/td&gt;
&lt;td&gt;&lt;?php echo $item-&gt;content; ?&gt;&lt;/td&gt;</pre></div></div><div class="section" title="Replacing the Post id column by Post"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec30"/>Replacing the Post id column by Post</h4></div></div></div><p>It would be more<a id="id313" class="indexterm"/> convenient to know the title of the post the comment is related to, instead of the post's id.</p><p>First, replace:</p><div class="informalexample"><pre class="programlisting">&lt;th&gt;Post id&lt;/th&gt;</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">&lt;th&gt;Post&lt;/th&gt;</pre></div><p>And then replace:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt;&lt;?php echo $item-&gt;post_id; ?&gt;&lt;/td&gt;</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">&lt;td&gt;
&lt;?php
echo $item-&gt;post ? $item-&gt;post-&gt;title : '&lt;i&gt;Post deleted&lt;/i&gt;';
?&gt;
&lt;/td&gt;</pre></div><p>But if we want this to work, we have to define the relations between posts and comments. Open the <span class="strong"><strong>Post</strong></span> model located at <code class="literal">BLOGPATH/classes/model/post.php</code>, and add the following property:</p><div class="informalexample"><pre class="programlisting">protected static $_has_many = array('comments');</pre></div><p>And then open the <span class="strong"><strong>Comment</strong></span> model located at <code class="literal">BLOGPATH/classes/model/comment.php</code>, and add the following property:</p><div class="informalexample"><pre class="programlisting">protected static $_belongs_to = array('post');</pre></div><p>Now, you are able to display the listing again. But, you might notice that if you have several comments, a lot of requests are executed. Again, we need to use the <code class="literal">related</code> key to prevent that. Open the <code class="literal">Comment</code> controller located at <code class="literal">BLOGPATH/classes/controller/admin/comment.php</code> and, inside the index action, replace:</p><div class="informalexample"><pre class="programlisting">$data['comments'] = Model_Comment::find('all');</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">$data['comments'] = Model_Comment::find(
    'all',
    array(
        'related' =&gt; array('post'),
        // display last comments first
        'order_by' =&gt; array('id' =&gt; 'DESC'),
    )
);</pre></div></div></div><div class="section" title="Improving the comment edition form"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec29"/>Improving the comment edition form</h3></div></div></div><p>We will improve two fields<a id="id314" class="indexterm"/> in the comment edition form; <code class="literal">Status</code>, and <code class="literal">Post id</code>.</p><div class="section" title="Changing the Status input to a select box"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec31"/>Changing the Status input to a select box</h4></div></div></div><p>Since there are only<a id="id315" class="indexterm"/> three possible statuses, we will replace the input by a select box. Open the form located at <code class="literal">BLOGPATH/views/admin/comment/_form.php</code>, and replace:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo Form::input('status', ...); ?&gt;</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">&lt;div&gt;
&lt;?php
echo Form::select(
    'status',
    $comment-&gt;status,
    array(
        'not_published' =&gt; 'not_published',
        'pending' =&gt; 'pending',
        'published' =&gt; 'published',
    )
);
?&gt;
&lt;/div&gt;</pre></div></div><div class="section" title="Replacing Post id by Post"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec32"/>Replacing Post id by Post</h4></div></div></div><p>Again, displaying a<a id="id316" class="indexterm"/> post's id is not relevant for the administrator; the best would be to display the post's title.</p><p>First, replace:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo Form::label('Post id', ...); ?&gt;</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">&lt;?php
echo Form::label(
    'Post',
    null, // No associated input
    array('class' =&gt; 'control-label')
);
?&gt;</pre></div><p>And then replace:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo Form::input('post_id', ...); ?&gt;</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">&lt;div&gt;&lt;?php echo $comment-&gt;post ? $comment-&gt;post-&gt;title : '&lt;i&gt;Post deleted&lt;/i&gt;'; ?&gt;&lt;/div&gt;</pre></div><p>We then need to prevent any change in the <code class="literal">post_id</code> property when processing the form. Open the <span class="strong"><strong>Comment</strong></span> controller and, inside the <code class="literal">action_edit</code> method, remove the following line:</p><div class="informalexample"><pre class="programlisting">$comment-&gt;post_id = Input::post('post_id');</pre></div><p>And:</p><div class="informalexample"><pre class="programlisting">$comment-&gt;post_id = $val-&gt;validated('post_id');</pre></div><p>Finally, we need to remove the <code class="literal">post_id</code> validation. Open the <span class="strong"><strong>Comment</strong></span> model and remove the following line:</p><div class="informalexample"><pre class="programlisting">$val-&gt;add_field('post_id', ...);</pre></div></div><div class="section" title="Removing the View link"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec33"/>Removing the View link</h4></div></div></div><p>Since there is no view<a id="id317" class="indexterm"/> action anymore, we have to remove the <span class="strong"><strong>View</strong></span> link. Open <code class="literal">BLOGPATH/views/admin/comment/edit.php</code> and remove the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo Html::anchor(..., 'View'); ?&gt; |</pre></div></div></div></div><div class="section" title="Protecting your website against CSRF attacks"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Protecting your website against CSRF attacks</h2></div></div></div><p>You would certainly<a id="id318" class="indexterm"/> like to prevent hackers from changing your website content, as the consequences <a id="id319" class="indexterm"/>could be disastrous. Although the risks are limited as long as you are the only one to access an administration panel you implemented yourself, you might want to protect your website against <span class="strong"><strong>Cross-Site Request Forgery</strong></span> (<span class="strong"><strong>CSRF</strong></span>) attacks.</p><p>CSRF attacks are based on<a id="id320" class="indexterm"/> the trust a website has in a user's browser. Let's illustrate these attacks with an example. Suppose you logged yourself into your administration interface. If you access, a bit later, a webpage on another website that contains the following code:</p><div class="informalexample"><pre class="programlisting">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;My attack&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;img src="http://myblog.app/blog/admin/post/delete/1" /&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p>In your website, the delete action of the <span class="strong"><strong>Post</strong></span> controller will get called and the post with <code class="literal">id = 1</code> will be deleted (if it exists), without your approval or any notification. The hacker that created the webpage has then succeeded in his CSRF attack by exploiting the fact that you <a id="id321" class="indexterm"/>were logged in to your administration panel. It worked because your action didn't verify that the request was legitimate. More advanced attacks can even submit forms, and you could then find yourself with unwanted content on your website.</p><p>Luckily, FuelPHP allows you to easily protect your website by including a security token in links or forms. This security token is later checked when the action is called. That process ensures that the client requested the action from the website, and not from somewhere else.</p><div class="section" title="Protecting links"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec30"/>Protecting links</h3></div></div></div><p>First, let's <a id="id322" class="indexterm"/>protect the delete links in the post listing.</p><p>Open the <code class="literal">BLOGPATH/views/admin/post/index.php</code> view file and replace:</p><div class="informalexample"><pre class="programlisting">'blog/admin/post/delete/'.$item-&gt;id</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">'blog/admin/post/delete/'.$item-&gt;id.
'?'.\Config::get('security.csrf_token_key').
'='.\Security::fetch_token()</pre></div><p>If you refresh the webpage, the delete links should now point to a URL looking like:</p><p><code class="literal">http://myblog.app/blog/admin/post/delete/ID?fuel_csrf_token=215be7bad7eb4999148a22341466f66395ce483d12b17cae463b7bf4b6d6d86233ce38ce6b145c08bf994e56610c1502158b32eca6f6d599a5bb3527d019c324</code>
</p><p>Now that we call the delete action of the <span class="strong"><strong>Post</strong></span> controller with the CSRF token as a <code class="literal">get</code> parameter, we just have to check if its value is correct before deleting the post. In order to do that, open the <span class="strong"><strong>Post</strong></span> controller and, inside the delete action, replace:</p><div class="informalexample"><pre class="programlisting">if ($post = Model_Post::find($id))</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">if (($post = Model_Post::find($id)) and \Security::check_token())</pre></div><p>Your delete action is now protected. You should do the same with the delete links of the <span class="strong"><strong>Category</strong></span> and <span class="strong"><strong>Comment</strong></span> administration interfaces. In general, it is even recommended to add this protection to any link that executes an important or critical action.</p></div><div class="section" title="Protecting forms"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec31"/>Protecting forms</h3></div></div></div><p>We will now use<a id="id323" class="indexterm"/> a very similar technique to protect our post creation and edition forms. First, open the <code class="literal">BLOGPATH/views/admin/post/_form.php</code> view file and add:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo Form::csrf(); ?&gt;</pre></div><p>Just after:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo Form::open(array("class"=&gt;"form-horizontal")); ?&gt;</pre></div><p>The <code class="literal">Form::csrf</code> method will automatically add a hidden input to your form containing the token. If you display the HTML code of the post creation or edition webpage, you should see that this method returned a string similar to:</p><div class="informalexample"><pre class="programlisting">&lt;input name="fuel_csrf_token" value="2411b0a6b942105fb80aa0cb1aaf89ca91e0ea715f5641bbfbb5ded23221fcecbbfe7016c8dbd922a19b12274989e67f71d266300ad14ebd9730c3ec604ec4f5" type="hidden" id="form_fuel_csrf_token" /&gt;</pre></div><p>Now, let's check that this token is correct before making any change to the database.</p><p>Open the <span class="strong"><strong>Post</strong></span> controller and, inside the create action, replace:</p><div class="informalexample"><pre class="programlisting">if ($post and $post-&gt;save())</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">if (\Security::check_token() and $post and $post-&gt;save())</pre></div><p>And inside the edit action, replace:</p><div class="informalexample"><pre class="programlisting">if ($post-&gt;save())</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">if (\Security::check_token() &amp;&amp; $post-&gt;save())</pre></div><p>For the sake of this section's conciseness, we do not display a special error message when the token doesn't have the expected value, but you are recommended to add this feature. </p><p>Anyway, your post creation and edition forms are now protected too. You should do the same with the<a id="id324" class="indexterm"/> creation and edition forms of the <span class="strong"><strong>Category</strong></span> and <span class="strong"><strong>Comment</strong></span> administration interfaces. In general, it is even recommended to add this protection to all your forms.</p></div></div></div>
<div class="section" title="Refining the front-end"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Refining the front-end</h1></div></div></div><p>We now <a id="id325" class="indexterm"/>have to refine the front-end of our website, that is to <a id="id326" class="indexterm"/>say what visitors will see.</p><div class="section" title="Refining the posts' listing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Refining the posts' listing</h2></div></div></div><p>If you<a id="id327" class="indexterm"/> request the<a id="id328" class="indexterm"/> following URL:</p><p>
<code class="literal">http://myblog.app/blog/post</code>
</p><p>You will see the scaffold we generated earlier with <code class="literal">scaffold/orm</code>.</p><div class="section" title="Deleting useless features"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec32"/>Deleting useless features</h3></div></div></div><p>The first important thing to do is to<a id="id329" class="indexterm"/> prevent any edition on our posts. As we did several times for the administration panel, remove the create, edit and delete actions of the <span class="strong"><strong>Post</strong></span> controller and their associated views. Note that, here, we are talking about the <span class="strong"><strong>Post</strong></span> controller located at <code class="literal">BLOGPATH/classes/controller/post.php</code>, since we are working on the website's front-end. You can also delete the <code class="literal">BLOGPATH/views/admin/post/_form.php</code> view file, as it is only called from the create and edit views.</p></div><div class="section" title="Changing how the posts' listing is displayed"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec33"/>Changing how the posts' listing is displayed</h3></div></div></div><p>Currently, the posts' listing is displayed in a table and, for <a id="id330" class="indexterm"/>our blog, we want to display the list more linearly, as most blogs are displayed.</p><p>The simplest way is to replace the view located at <code class="literal">BLOGPATH/post/index.php</code> by:</p><div class="informalexample"><pre class="programlisting">&lt;?php if ($posts): ?&gt;
&lt;?php foreach ($posts as $item): ?&gt;
&lt;div class="post" id="post_&lt;?php echo $item-&gt;id; ?&gt;"&gt;
&lt;h2&gt;
&lt;?php
echo Html::anchor('blog/post/view/'.$item-&gt;id, $item-&gt;title);
?&gt;
&lt;/h2&gt;
&lt;?php
/*
As we will display the same information when visualizing a
post, we will implement different views in order
to easily reuse them later in BLOGPATH/views/post/view.php
*/
echo \View::forge(
    'post/small_description',
    array('post' =&gt; $item)
);
echo \View::forge(
    'post/additional_informations',
    array('post' =&gt; $item)
);
?&gt;
&lt;/div&gt;
&lt;?php endforeach; ?&gt;
&lt;?php else: ?&gt;
&lt;p&gt;No Posts.&lt;/p&gt;
&lt;?php endif; ?&gt;</pre></div><p>As we are displaying <a id="id331" class="indexterm"/>additional content in separated views (see comments), we need to create these views. Create the <code class="literal">BLOGPATH/views/post/small_description.php</code> view file and set its content with the following:</p><div class="informalexample"><pre class="programlisting">&lt;div class="post_small_description"&gt;
&lt;?php
echo \Markdown::parse($post-&gt;small_description) 
?&gt;
&lt;/div&gt;</pre></div><p>And create the <code class="literal">BLOGPATH/views/post/additional_informations.php</code> view file and set its content by the following:</p><div class="informalexample"><pre class="programlisting">&lt;div class="post_date"&gt;
&lt;?php
echo \Date::forge($post-&gt;created_at)-&gt;format('us_full');
?&gt;
&lt;/div&gt;
&lt;div class="post_category"&gt;
    Category:
&lt;?php echo $post-&gt;category-&gt;name ?&gt;
&lt;/div&gt;
&lt;div class="post_author"&gt;
    By
&lt;?php echo $post-&gt;author-&gt;username ?&gt;
&lt;/div&gt;</pre></div><p>Finally, in order to optimize the number of requests being made, open the <span class="strong"><strong>Post</strong></span> controller (the one for the front-end), and replace:</p><div class="informalexample"><pre class="programlisting">$data['posts'] = Model_Post::find('all');</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">$data['posts'] = Model_Post::find(
    'all',
    array(
        'related' =&gt; array(
            'author',
            'category',
        ),
    )
);</pre></div></div><div class="section" title="Adding pagination"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec34"/>Adding pagination</h3></div></div></div><p>If you add a lot of posts, you <a id="id332" class="indexterm"/>will notice that the list becomes very long. To prevent this behavior, we will now add the <code class="literal">Pagination</code> feature.</p><p>At the beginning of the index action of the <span class="strong"><strong>Post</strong></span> controller, add the following code in order to create a <code class="literal">Pagination</code> instance:</p><div class="informalexample"><pre class="programlisting">// Pagination configuration
$config = array(
    'total_items'    =&gt; Model_Post::count(),
    'per_page'       =&gt; 10,
    'uri_segment'    =&gt; 'page',
);

// Create a pagination instance named 'posts'
$pagination = \Pagination::forge('posts', $config);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>Here, we set the main<a id="id333" class="indexterm"/> options of the <code class="literal">Pagination</code> configuration, but you are recommended to take a look at the official documentation, as there are many more options:</p><p>
<a class="ulink" href="http://fuelphp.com/docs/classes/pagination.html">http://fuelphp.com/docs/classes/pagination.html</a>
</p><p>(It can be accessed through FuelPHP website by navigating to <span class="strong"><strong>DOCS</strong></span> | <span class="strong"><strong>Core</strong></span> | <span class="strong"><strong>Pagination</strong></span>)</p><p>If you don't have a lot of posts, you can lower the <code class="literal">per_page</code> value in order to test the pagination.</p></div></div><p>Now when we retrieve the posts, we have to take into account the pagination. Replace:</p><div class="informalexample"><pre class="programlisting"> $data['posts'] = Model_Post::find(...);</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">$data['posts'] = Model_Post::find(
    'all',
    array(
        'related' =&gt; array(
            'author',
            'category',
        ),
        'rows_offset' =&gt; $pagination-&gt;offset,
        'rows_limit' =&gt; $pagination-&gt;per_page,
    )
);</pre></div><p>We need to pass the pagination instance we created to our view in order to display it. At the end of the action, add the following code:</p><div class="informalexample"><pre class="programlisting">$this-&gt;template-&gt;content-&gt;set('pagination', $pagination);</pre></div><p>This will have the same effect as setting a <code class="literal">pagination</code> key inside the <code class="literal">$data</code> parameter.</p><p>Open the <code class="literal">BLOGPATH/views/post/index.php</code> view file, and under:</p><div class="informalexample"><pre class="programlisting">&lt;?php endforeach; ?&gt;</pre></div><p>Add:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo $pagination; ?&gt;</pre></div><p>Now, if you refresh<a id="id334" class="indexterm"/> your listing page and have enough posts, you will see that your pagination appears but is escaped, in the sense that it displays the HTML code. This is because view parameters are escaped by default and we didn't notify FuelPHP not to escape the <code class="literal">pagination</code> parameter. Open the <span class="strong"><strong>Post</strong></span> controller again and, inside the index action, replace:</p><div class="informalexample"><pre class="programlisting">$this-&gt;template-&gt;content-&gt;set('pagination', $pagination);</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">$this-&gt;template-&gt;content-&gt;set('pagination', $pagination, false);</pre></div></div><div class="section" title="Using posts' slug"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec35"/>Using posts' slug</h3></div></div></div><p>If you display the listing, everything <a id="id335" class="indexterm"/>should look just fine. But if you click on the title of one post, the view page will be shown but the URL will look like this:</p><p>
<code class="literal">http://myblog.app/blog/post/view/1</code>
</p><p>This is not great for the SEO, because we don't use the slug we created earlier. To fix that, first open the <code class="literal">BLOGPATH/views/post/index.php</code> view file, and replace:</p><div class="informalexample"><pre class="programlisting">echo Html::anchor('blog/post/view/'.$item-&gt;id, $item-&gt;title);</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">echo Html::anchor(
    'blog/post/view/'.$item-&gt;slug,
    $item-&gt;title
);</pre></div><p>Now that the link is pointing to the right URL, the view action has to handle this new behavior. Open the <span class="strong"><strong>Post</strong></span> controller and first replace the following line:</p><div class="informalexample"><pre class="programlisting">public function action_view($id = null)</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">public function action_view($slug = null)</pre></div><p>And then replace the view action's content by:</p><div class="informalexample"><pre class="programlisting">is_null($slug) and Response::redirect('blog/post');

$data['post'] = Model_Post::find(
    'first',
    array(
        'where' =&gt; array(
            array('slug' =&gt; $slug),
        ),
    )
);
if ( ! $data['post'])
{
    Session::set_flash(
        'error',
        'Could not find post with slug: '.$slug
    );
    Response::redirect('blog/post');
}

$this-&gt;template-&gt;title = "Post";
$this-&gt;template-&gt;content = View::forge('post/view', $data);</pre></div></div><div class="section" title="Listing posts by categories"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec36"/>Listing posts by categories</h3></div></div></div><p>One interesting<a id="id336" class="indexterm"/> additional feature would be to list posts belonging to each category. For instance, if we request the following URL:</p><p>
<code class="literal">http://myblog.app/blog/post/category/1</code>
</p><p>We would like to display posts belonging to the category with <code class="literal">id = 1</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>The best would have been to use a slug, as we did for posts. We didn't implement it for the sake of this chapter's conciseness, but you are recommended to do so.</p></div></div><p>First, open the <code class="literal">BLOGPATH/views/post/additional_informations.php</code> and replace:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo $post-&gt;category-&gt;name ?&gt;</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">&lt;?php
echo Html::anchor(
    'blog/post/category/'.$post-&gt;category-&gt;id,
    $post-&gt;category-&gt;name
);
?&gt;</pre></div><p>If you think about it, the list of posts displayed for a category is similar to the one where no category is filtered. The view and even the requests are similar.</p><p>We could have written a category action inside the <span class="strong"><strong>Post</strong></span> controller and, in that case, the index and category actions could have called a same common method; this solution would have been acceptable and even recommended in most cases.</p><p>But we will take a different approach here. Since the actions have a lot in common, we will reroute:</p><p>
<code class="literal">http://myblog.app/blog/post/category/category_id</code>
</p><p>To:</p><p>
<code class="literal">http://myblog.app/blog/post/index</code>
</p><p>And add the category processing inside the index action. </p><p>First, create and open the <code class="literal">BLOGPATH/config/routes.php</code> file, and set its content to:</p><div class="informalexample"><pre class="programlisting">&lt;?php
return array(
    'blog/post/category/:category_id' =&gt; 'blog/post/index',
);</pre></div><p>Now we have<a id="id337" class="indexterm"/> to add the category processing inside our index action in the <span class="strong"><strong>Post</strong></span> controller. First, in the index action of the <span class="strong"><strong>Post</strong></span> controler, replace:</p><div class="informalexample"><pre class="programlisting">$config = array(...);</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">$config = array(
    'per_page'       =&gt; 10,
    'uri_segment'    =&gt; 'page',
);

// Get the category_id route parameter
$category_id = $this-&gt;param('category_id');
if (is_null($category_id)) {
    $config['total_items'] = Model_Post::count();
} else {
    $config['total_items'] = Model_Post::count(
        array(
            'where' =&gt; array(
                array('category_id' =&gt; $category_id),
            ),
        )
    );
}</pre></div><p>Then, replace:</p><div class="informalexample"><pre class="programlisting">$data['posts'] = Model_Post::find(...);</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">$data['posts'] = Model_Post::query()
    -&gt;related(array('author', 'category'))
    -&gt;rows_offset($pagination-&gt;offset)
    -&gt;rows_limit($pagination-&gt;per_page);

if (!is_null($category_id)) {
    $data['posts']-&gt;where('category_id', $category_id);
}

$data['posts'] = $data['posts']-&gt;get();</pre></div><p>You can notice we used the <code class="literal">query</code> method here as it was more convenient than the <code class="literal">find</code> method in this case.</p></div><div class="section" title="Adding indexes"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec37"/>Adding indexes</h3></div></div></div><p>In order to optimize our <a id="id338" class="indexterm"/>website, we will add some indexes to our tables. For doing that, create a migration file located at <code class="literal">BLOGPATH/migrations/004_create_indexes.php</code> and set its content to:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Fuel\Migrations;

class Create_indexes
{
  public function up()
  {
        // For optimizing relations
        \DBUtil::create_index('comments', 'post_id');
        \DBUtil::create_index('posts', 'category_id');
        \DBUtil::create_index('posts', 'user_id');

        // For optimizing slug retrieval
        \DBUtil::create_index('posts', 'slug');
  }
  public function down()
  {
        \DBUtil::drop_index('comments', 'post_id');
        \DBUtil::drop_index('posts', 'category_id');
        \DBUtil::drop_index('posts', 'user_id');
        \DBUtil::drop_index('posts', 'slug');
  }
}</pre></div><p>Don't forget to execute the migration file.</p></div></div><div class="section" title="Refining the posts' visualization webpage"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Refining the posts' visualization webpage</h2></div></div></div><p>When clicking<a id="id339" class="indexterm"/> on a post's title in the listing page, you will see that the visualization webpage is not perfect. We need to improve how it is<a id="id340" class="indexterm"/> displayed, to display the post's validated comments, and to display and process the comment form.</p><div class="section" title="Changing the post layout"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec38"/>Changing the post layout</h3></div></div></div><p>In order to improve how a <a id="id341" class="indexterm"/>post is displayed, open the <code class="literal">BLOGPATH/views/post/view.php</code> view file and set the following content:</p><div class="informalexample"><pre class="programlisting">&lt;div class="post_view"&gt;
&lt;h2&gt;
&lt;?php echo $post-&gt;title; ?&gt;
&lt;/h2&gt;

&lt;?php
// Reusing views we created earlier
echo \View::forge(
    'post/small_description',
    array('post' =&gt; $post)
);
?&gt;
&lt;div class="post_content"&gt;
&lt;?php echo $post-&gt;content; ?&gt;
&lt;/div&gt;
&lt;?php
echo \View::forge(
    'post/additional_informations',
    array('post' =&gt; $post)
);
?&gt;
&lt;/div&gt;
&lt;?php echo Html::anchor('blog/post', 'Back'); ?&gt;</pre></div><p>Now, if you visualize a post with a content containing HTML elements, you will see that it will be escaped (you will see the HTML code). This is because any parameter sent to a view is by default filtered.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>The way each parameter is by default filtered can be changed in the <code class="literal">APPPATH/config/config.php</code> configuration file, using the <code class="literal">security.output_filter</code> key. Its default value is <code class="literal">array('Security::htmlentities')</code>, explaining why the HTML code is escaped. You could change this value to <code class="literal">array('Security::xss_clean')</code> to solve this issue, but you should know that it can potentially cause a performance hit.</p></div></div><p>For solving<a id="id342" class="indexterm"/> that, inside the view action of the <span class="strong"><strong>Post</strong></span> controller, add:</p><div class="informalexample"><pre class="programlisting">$this-&gt;template-&gt;content-&gt;set(
'post_content',
$data['post']-&gt;content,
false
);</pre></div><p>After:</p><div class="informalexample"><pre class="programlisting">$this-&gt;template-&gt;content-&gt;set(
    'post_content',
    $data['post']-&gt;content,
    false
);</pre></div><p>And, in the <code class="literal">BLOGPATH/views/post/view.php</code> view file, replace:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo $post-&gt;content; ?&gt;</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo \Security::xss_clean($post_content); ?&gt;</pre></div><p>You should be cautious when disabling the <code class="literal">filter</code> parameter, as it can add security issues. Since the posts are edited only by administrators, it is less risky, but this doesn't prevent us from taking extra measures. That is why we used the <code class="literal">Security::xss_clean</code> method to limit potential issues.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>You are<a id="id343" class="indexterm"/> probably wondering why we set the post content in an additional unfiltered view parameter, instead of just setting the <code class="literal">filter</code> parameter of <code class="literal">View::forge</code> to false. The reason is that, in that case, we would have sent a totally unfiltered <code class="literal">post</code> object (since all objects properties are filtered when <code class="literal">filter</code> is set to true). This would have forced us to manually escape most other properties we display on views, resulting in many more changes.</p><p>If you decide, in another case, to disable the <code class="literal">filter</code> parameter directly in <code class="literal">View::forge</code>, beware of an important detail; when the <code class="literal">filter</code> parameter is enabled, it escapes all passed objects' properties and therefore, changes them in the process. Consequently, the objects will be irreversibly changed after any <code class="literal">View::forge</code> with the <code class="literal">filter</code> parameter set to <code class="literal">true</code>. Thus, even if you set the <code class="literal">filter</code> parameter to false when calling <code class="literal">View::forge</code> in the controller, your objects' attributes might still get escaped if you are displaying sub views with <code class="literal">filter</code> set to <code class="literal">true</code>, so be sure to disable <code class="literal">filter</code> in that case too.</p></div></div></div><div class="section" title="Adding the comment form"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec39"/>Adding the comment form</h3></div></div></div><p>We also<a id="id344" class="indexterm"/> want the user to be able to post comments. To do that, we will<a id="id345" class="indexterm"/> first implement the comment creation form (derived from the one of the administration panel). Create the <code class="literal">BLOGPATH/views/comment/_form.php</code> view file and set its content to:</p><div class="informalexample"><pre class="programlisting">&lt;h3&gt;Add a comment&lt;/h3&gt;
&lt;?php echo Form::open(array("class"=&gt;"form-horizontal")); ?&gt;

  &lt;fieldset&gt;
    &lt;div class="form-group"&gt;
&lt;?php
echo Form::label(
    'Name',
    'name',
    array('class' =&gt; 'control-label')
);

echo Form::input(
    'name',
    Input::post(
        'name',
    isset($comment) ? $comment-&gt;name : ''
    ),
    array(
        'class' =&gt; 'col-md-4 form-control',
        'placeholder' =&gt; 'Name'
    )
);
?&gt;

    &lt;/div&gt;
    &lt;div class="form-group"&gt;
&lt;?php
echo Form::label(
    'Email',
    'email',
    array('class' =&gt; 'control-label')
);

echo Form::input(
    'email',
    Input::post(
        'email',
        isset($comment) ? $comment-&gt;email : ''
    ),
    array(
        'class' =&gt; 'col-md-4 form-control',
        'placeholder' =&gt; 'Email'
    )
);
?&gt;

   &lt;/div&gt;
    &lt;div class="form-group"&gt;
&lt;?php
echo Form::label(
    'Content',
    'content',
    array('class' =&gt; 'control-label')
);

echo Form::textarea(
    'content',
    Input::post(
        'content',
        isset($comment) ? $comment-&gt;content : ''
    ),
    array(
        'class' =&gt; 'col-md-8 form-control',
        'rows' =&gt; 8,
        'placeholder' =&gt; 'Content'
    )
);
?&gt;

    &lt;/div&gt;
    &lt;div class="form-group"&gt;
      &lt;label class='control-label'&gt;&amp;nbsp;&lt;/label&gt;
&lt;?php
echo Form::submit(
    'submit',
    'Save',
    array('class' =&gt; 'btn btn-primary')
);
?&gt;
&lt;/div&gt;
  &lt;/fieldset&gt;
&lt;?php echo Form::close(); ?&gt;</pre></div><p>As mentioned earlier, it is a <a id="id346" class="indexterm"/>derived version of the comment form in the administration panel, except we removed the <span class="strong"><strong>Status</strong></span> and <span class="strong"><strong>Post</strong></span> fields. Now, add the<a id="id347" class="indexterm"/> following line at the end of <code class="literal">BLOGPATH/views/post/view.php</code> to display the form when showing a post:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo View::forge('comment/_form'); ?&gt;</pre></div><p>We now have to process it. Open the <span class="strong"><strong>Post</strong></span> controller and, inside the view action, before the following line:</p><div class="informalexample"><pre class="programlisting">$this-&gt;template-&gt;title = "Post";</pre></div><p>Add:</p><div class="informalexample"><pre class="programlisting">// Is the user sending a comment? If yes, process it.
if (Input::method() == 'POST')
{
    $val = Model_Comment::validate('create');

    if ($val-&gt;run())
    {
        $comment = Model_Comment::forge(array(
            'name' =&gt; Input::post('name'),
            'email' =&gt; Input::post('email'),
            'content' =&gt; Input::post('content'),
            'status' =&gt; 'pending',
            'post_id' =&gt; $data['post']-&gt;id,
        ));

        if ($comment and $comment-&gt;save())
        {
            Session::set_flash(
                'success',
                e('Your comment has been saved, it will'.
                 ' be reviewed by our administrators')
            );
        }

        else
        {
            Session::set_flash(
                'error',
                e('Could not save comment.')
            );
        }
    }
    else
    {
        Session::set_flash('error', $val-&gt;error());
    }
}</pre></div><p>This is derived <a id="id348" class="indexterm"/>from the generated scaffold code, so there is nothing that you have not already seen. If you try to validate the<a id="id349" class="indexterm"/> comment form, you will notice that the <code class="literal">status</code> validation prevents the comment object from being saved. Open the <code class="literal">BLOGPATH/model/comment.php</code> model file, and replace:</p><div class="informalexample"><pre class="programlisting">$val-&gt;add_field('status', 'Status', 'required|max_length[255]');</pre></div><p>By:</p><div class="informalexample"><pre class="programlisting">// We require status only if we are editing the comment (thus
// we are on the administration panel).
if ($factory == 'edit') {
    $val-&gt;add_field(
        'status',
        'Status',
        'required|max_length[255]'
    );
}</pre></div></div><div class="section" title="Displaying comments"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec40"/>Displaying comments</h3></div></div></div><p>Now that the user is able to create comments, it would be nice to display them. A small correction; it<a id="id350" class="indexterm"/> would be nice to display those that have been validated by the administrator. We don't want to display all comments, but only those<a id="id351" class="indexterm"/> with their <code class="literal">status = published</code>. In order to make our work easier, we will first add a relation to the <span class="strong"><strong>Post</strong></span> model that only retrieves published comments. Open the <span class="strong"><strong>Post</strong></span> model, and add the following at the end of the <code class="literal">$_has_many</code> property:</p><div class="informalexample"><pre class="programlisting">'published_comments' =&gt; array(
    'model_to'          =&gt; '\Blog\Model_Comment',
    'conditions' =&gt; array(
        'where' =&gt; array(
            array('status' =&gt; 'published'),
        ),
    ),
),</pre></div><p>As you can see, it is also possible to add default conditions (and orders) to relations. From now on, <code class="literal">$post-&gt;published_comments</code> will retrieve the post's comments with <code class="literal">status = published</code>.</p><p>Let's use this relation to display our published comments. Open <code class="literal">BLOGPATH/views/post/view.php</code> and before:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo View::forge('comment/_form'); ?&gt;</pre></div><p>Add:</p><div class="informalexample"><pre class="programlisting">&lt;div class="comments"&gt;
&lt;?php
foreach ($post-&gt;published_comments as $comment):
    echo \View::forge(
        'comment/item',
        array('comment' =&gt; $comment)
    );
endforeach;
?&gt;
&lt;/div&gt;</pre></div><p>Finally, create the <code class="literal">BLOGPATH/views/comment/item.php</code> view file and set its content to:</p><div class="informalexample"><pre class="programlisting">&lt;div class="comment"&gt;
&lt;div class="comment_content"&gt;
&lt;?php echo $comment-&gt;content; ?&gt;
&lt;/div&gt;
&lt;div class="comment_date"&gt;
&lt;?php
echo \Date::forge($comment-&gt;created_at)-&gt;format('us_full');
?&gt;
&lt;/div&gt;
&lt;div class="comment_name"&gt;
        By
&lt;?php echo $comment-&gt;name; ?&gt;
&lt;/div&gt;
&lt;/div&gt;</pre></div></div><div class="section" title="Notifying the author when a new comment is posted"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec41"/>Notifying the author when a new comment is posted</h3></div></div></div><p>As<a id="id352" class="indexterm"/> comments require a validation from the administrator, we will send an email to the post's author when a new comment is posted.</p><p>We will do that with the <code class="literal">Email</code> package. This package is located at the <code class="literal">PKGPATH/email</code> directory. You can adapt the package configuration file by copying <code class="literal">PKGPATH/email/config/email.php</code> to <code class="literal">APPPATH/config/email.php</code> and changing the returned array, depending on your local configuration. You must at least set the <code class="literal">defaults.from.email</code> and <code class="literal">defaults.from.name</code> values.</p><p>You can choose between several email drivers. The default driver is <code class="literal">mail</code> and, as we could expect, simply use the <code class="literal">mail</code> PHP method. The <code class="literal">sendmail</code> driver is also commonly chosen and use the open source <code class="literal">sendmail</code> utility. The <code class="literal">smtp</code> driver connects to the email server using sockets. Other drivers, such as <code class="literal">mailgun</code> or <code class="literal">mandrill</code>, allow you to use external services to send your emails.</p><p>You should read the official documentation at</p><p>
<a class="ulink" href="http://fuelphp.com/docs/packages/email/introduction.html">http://fuelphp.com/docs/packages/email/introduction.html</a>
</p><p>(It can be accessed through FuelPHP website by navigating to <span class="strong"><strong>DOCS</strong></span> | <span class="strong"><strong>TABLE OF CONTENTS</strong></span> | <span class="strong"><strong>Email</strong></span> | <span class="strong"><strong>Introduction</strong></span>)</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>If you want to send emails from your local system, you will probably have to change additional configuration files, such as <code class="literal">php.ini</code>. Feel free to search the web for more information, as there are countless resources on the topic.</p></div></div><p>In order to send those<a id="id353" class="indexterm"/> emails, open the <span class="strong"><strong>Post</strong></span> controller and, inside the view action, just before:</p><div class="informalexample"><pre class="programlisting">Session::set_flash('success', ...);</pre></div><p>Add:</p><div class="informalexample"><pre class="programlisting">// Manually loading the Email package
\Package::load('email');

$email = \Email::forge();

// Setting the to address
$email-&gt;to(
    $data['post']-&gt;author-&gt;email,
    $data['post']-&gt;author-&gt;username
);

// Setting a subject
$email-&gt;subject('New comment');

// Setting the body and using a view since the message is long
$email-&gt;body(
    \View::forge(
        'comment/email',
        array(
            'comment' =&gt; $comment,
        )
    )-&gt;render()
);

// Sending the email
$email-&gt;send();</pre></div><p>Finally, create the <code class="literal">BLOGPATH/views/comment/email.php</code> view file and set its content to:</p><div class="informalexample"><pre class="programlisting">Hi,

A new comment has been posted.


Author: &lt;?php echo $comment-&gt;name; ?&gt;


Email: &lt;?php echo $comment-&gt;email; ?&gt;


Content:
&lt;?php echo $comment-&gt;content; ?&gt;



Go to the administration panel to accept / reject it.
&lt;?php echo Uri::base().'admin' ?&gt;


Thanks,</pre></div></div></div></div>
<div class="section" title="Clearing rejected comments"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Clearing rejected comments</h1></div></div></div><p>If your blog gets spammed <a id="id354" class="indexterm"/>and you find yourself with a lot of comments with status set as <code class="literal">not_published</code>, you might want to remove all these comments to clean your comments database. We could simply implement a link and an action but, for the sake of the example, let's implement a task for doing that.</p><p>Tasks are classes<a id="id355" class="indexterm"/> that can be executed through the command line using the <code class="literal">oil</code> utility. They are generally used for background processes or cron jobs. Sometimes, they can also be used for generating or modifying existing code, like the task we previously used for moving scaffolds to modules.</p><p>Let's generate our task file using the <code class="literal">oil</code> utility:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil generate task clearComments</strong></span>
</pre></div><p>It should output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>No tasks actions have been provided, the TASK will only create default task.</strong></span>
<span class="strong"><strong>    Preparing task method [Index]</strong></span>
<span class="strong"><strong>Creating tasks: APPPATH/tasks/clearcomments.php</strong></span>
</pre></div><p>If you now open the task file located at <code class="literal">APPPATH/tasks/clearcomments.php</code>, you should see the following class:</p><div class="informalexample"><pre class="programlisting">&lt;?php
namespace Fuel\Tasks;

class Clearcomments
{
    // ...
  public function run($args = NULL)
  {
    // ...
  }

    // ...
  public function index($args = NULL)
  {
    // ...
  }
}</pre></div><p>The <code class="literal">oil</code> utility generated a class named <code class="literal">Clearcomments</code>, with two methods: <code class="literal">run</code> and <code class="literal">index</code>. Each method can be called using the <code class="literal">oil</code> utility.</p><p>The following<a id="id356" class="indexterm"/> command executes the <code class="literal">run</code> method:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil refine clearComments:run</strong></span>
</pre></div><p>The following command executes the <code class="literal">index</code> method:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil refine clearComments:index</strong></span>
</pre></div><p>If you add a public method named <code class="literal">my_method</code>, it will also be called when executing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil refine clearComments:my_method</strong></span>
</pre></div><p>The <code class="literal">run</code> method is the default method and can therefore be called this way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil refine clearComments</strong></span>
</pre></div><p>It is possible to pass additional parameters to the task. For instance:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil refine clearComments:run param_1 param_2</strong></span>
</pre></div><p>In that case, the <code class="literal">oil</code> utility will call <code class="literal">Clearcomments::run('param_1', 'param_2')</code>.</p><p>You should read the official documentation at:</p><p>
<a class="ulink" href="http://fuelphp.com/docs/packages/oil/generate.html#/tasks">http://fuelphp.com/docs/packages/oil/generate.html#/tasks</a></p><p>(It can be accessed through FuelPHP website by navigating to <span class="strong"><strong>DOCS</strong></span> | <span class="strong"><strong>TABLE OF CONTENTS</strong></span> | <span class="strong"><strong>Oil</strong></span> | <span class="strong"><strong>Generate</strong></span>)</p><p>
<a class="ulink" href="http://fuelphp.com/docs/general/tasks.html">http://fuelphp.com/docs/general/tasks.html</a></p><p>(It can be accessed through FuelPHP website by navigating to <span class="strong"><strong>DOCS</strong></span> | <span class="strong"><strong>TABLE OF CONTENTS</strong></span> | <span class="strong"><strong>FuelPHP</strong></span> | <span class="strong"><strong>General</strong></span> | <span class="strong"><strong>Tasks</strong></span>)</p><p>Replace the<a id="id357" class="indexterm"/> class content by the following:</p><div class="informalexample"><pre class="programlisting">public function run()
{
    \DB::query(
        'DELETE FROM comments WHERE status="not_published";'
    )-&gt;execute();
    return 'Rejected comments deleted.';
}</pre></div><p>Now, if you run:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php oil refine clearComments</strong></span>
</pre></div><p>It should delete all rejected comments.</p><p>You can execute this task manually or you can set up a cron job to execute it regularly.</p></div>
<div class="section" title="Additional improvements"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Additional improvements</h1></div></div></div><p>Many additional improvements <a id="id358" class="indexterm"/>are possible. Some edge cases need to be handled: for instance, try to successfully display the administration panel when post or categories are deleted. You can set the route configuration so that your welcome page shows your posts' listing. When visualizing a post, you<a id="id359" class="indexterm"/> can optimize the SQL requests being sent, by using the related parameter. You could even send an e-mail to all commenters when a new comment is being posted, and allow them to unsubscribe if they want to. You should add the improvements you deem necessary, this can only have a beneficial effect on your FuelPHP skills.</p><p>We have one additional suggestion about modules. In this chapter, for the sake of simplicity and conciseness, we created a single module, blog, to manage posts, comments and categories. Yet, depending on the website, developers might want to disable (for instance, disable comments), change these features or even add new ones.</p><p>We could handle this issue by creating a configuration file defining whether or not a specific feature should be enabled, or the way some features should operate. It can do the trick but, if your module accumulates many features, your code could become unmaintainable.</p><p>A better way to solve<a id="id360" class="indexterm"/> this issue is to create several smaller modules that handle each feature. After all, comments can also be used on product pages, for instance. There can also be multiple ways to display a list of posts, so separating models and controllers/views into distinct modules can also be a good idea. You should always aim for simple and small modules that interact with each other, instead of a big module that does everything.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Summary</h1></div></div></div><p>In this chapter, we have built a complex project with many features. By trying to make the code as maintainable as possible (by using modules for instance), we have provided a snapshot of how projects should be implemented so that adding new features remains easy. We have also addressed some common ORM issues, learnt how to easily paginate a listing, and used the Auth and Email packages. You certainly don't know everything about the FuelPHP framework, but implementing most projects should not be a problem for you now.</p><p>In the next chapter, you will learn how to add reusable features by installing an external package as well as creating your own.</p></div></body></html>