<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Menus and Menu Links</h1>
                </header>
            
            <article>
                
<p>Navigation is an important part of any web application. The ability to create menus and links easily in order to connect pages together is a core aspect of any content management system. Drupal 8 is fully equipped with both the site-building capabilities and developer API to easily build and manipulate menus and links.</p>
<p>In this chapter, we will discuss menus and menu links from a Drupal 8 module developer perspective. In doing so, we will touch upon a few key aspects:</p>
<ul>
<li>The general architecture of the menu system in Drupal 8</li>
<li>Manipulating and rendering menus</li>
<li>Defining various types of menu links</li>
</ul>
<p>By the end of this chapter, you should be able to understand what menus and menu links are, how to use them in your code and how to define menu links in your module. So let's get started.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The menu system</h1>
                </header>
            
            <article>
                
<p>Before we get our hands dirty with menus and menu links, let's talk a bit about the general architecture behind the menu system. To this end, I want to talk a bit about its main components, what some of its key players are and what classes you should be looking at. As always, no great developer has ever relied solely on a book or documentation to figure out complex systems.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Menus</h1>
                </header>
            
            <article>
                
<p>Menus are configuration entities represented by the following class: <kbd>Drupal\system\Entity\Menu</kbd>. I mentioned in <a href="5c4ab442-1596-40ca-b305-d72b6c47ed59.xhtml">Chapter 1</a>, <em>Developing for Drupal 8</em>, that we have something called configuration entities in Drupal 8, which we will explore in detail later in this book. However, for now, it's enough to understand that menus can be created through the UI and become an exportable configuration. Additionally, this exported configuration can also be included inside a module so that it gets imported when the module is first installed. This way, a module can ship with its own menus. We will see how this latter aspect works when we talk about the different kinds of storage in Drupal 8. For now, we will work with menus that come with Drupal 8 core.</p>
<p>Each menu can have multiple menu links, structured hierarchically in a tree with a maximum depth of <kbd>9</kbd>. The ordering of the menu links can be done easily through the UI or via the weighting of the menu links, if defined in code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Menu links</h1>
                </header>
            
            <article>
                
<p>At their most basic level, menu links are YAML-based plugins (like the Layout plugins we saw in the previous chapter). To this end, regular menu links are defined inside a <kbd>module_name.links.menu.yml</kbd> file and can be altered by other modules by implementing <kbd>hook_menu_links_discovered_alter()</kbd>. When I say regular, I mean those links that go into menus. We will see shortly that there are also a few other types.</p>
<p>There are a number of important classes you should check out in this architecture though: <kbd>MenuLinkManager</kbd> (the plugin manager) and <kbd>MenuLinkBase</kbd> (menu link plugins base class and which implements <kbd>MenuLinkInterface</kbd>).</p>
<p>Menu links can, however, also be content entities. The links created via the UI are stored as entities because they are considered content. The way this works is that for each created <kbd>MenuLinkContent</kbd> entity, a plugin derivative is created. We are getting dangerously close to advanced topics that are too early to cover. But in a nutshell, via these derivatives, it's as if a new menu link plugin is created for each <kbd>MenuLinkContent</kbd> entity, making the latter behave as any other menu link plugin. This is a very powerful system specific to Drupal 8.</p>
<p>Menu links have a number of properties, among which a path or route. When created via the UI, the path can be external or internal or can reference an existing resource. When created programmatically, you'll typically use a route.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Multiple types of menu links</h1>
                </header>
            
            <article>
                
<p>The menu links we've been talking about so far are the links that show up in menus. There are also a few different kinds of links that show up elsewhere but are still considered menu links and work similarly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Local tasks</h1>
                </header>
            
            <article>
                
<p>Local tasks, otherwise known as tabs, are grouped links that usually show up above the main content of a page (depending on the region where the tabs block is placed). They are usually used to group together related links that have to deal with the current page. For example, on an entity page, such as the Node detail page, you can have two tabsâ€”one for viewing the Node and one for editing it (and maybe one for deleting it); <span><span>i</span></span>n other words, local tasks:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3e6a626e-a51f-480f-9ede-0434a00c9901.png" style="width:25.58em;height:8.00em;"/></p>
<p>Local tasks take access rules into account, so if the current user does not have access to the route of a given tab, the link is not rendered. Moreover, if that means only one link in the set remains accessible, that link doesn't get rendered as there is no point. So, for tabs, a minimum of two links are needed for them to show up.</p>
<p>Modules can define local task links inside a <kbd>module_name.links.task.yml</kbd> file, whereas other modules can alter them by implementing <kbd>hook_menu_local_tasks_alter()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Local actions</h1>
                </header>
            
            <article>
                
<p>Local actions are links that relate to a given route and are typically used for operations. For example, on a <strong>list</strong> page, you might have a local action link to create a new list item, which will take you to the relevant form page.</p>
<p>In the following screenshot, we can see a local action link used to create a new user on the main user management page:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/71204c74-d253-4143-adfb-536da804adcf.png" style="width:25.42em;height:17.25em;"/></p>
<div class="packt_figure CDPAlignCenter CDPAlign"/>
<p>Modules can define local action links inside a <kbd>module_name.links.action.yml</kbd> file, whereas other modules can alter them by implementing <kbd>hook_menu_local_actions_alter()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Contextual links</h1>
                </header>
            
            <article>
                
<p>Contextual links are used by the Contextual module to provide handy links next to a given component (a render array). You probably encountered this when hovering over a block, for example, and getting that little icon with a dropdown that has the <span class="packt_screen">Configure block</span> link:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/1ae8da6d-16a2-4c5f-82e1-290b9fd6f1cf.png" style="width:19.33em;height:7.75em;"/></div>
<p>Contextual links are tied to render arrays. In fact, any render array can show a group of contextual links that have previously been defined.</p>
<p>Modules can define contextual links inside a <kbd>module_name.links.contextual.yml</kbd> file, whereas other modules can alter them by implementing <kbd>hook_contextual_links_alter()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MenuLink trees</h1>
                </header>
            
            <article>
                
<p>As I mentioned in the section about menus, menu links are stored hierarchically inside a menu. This hierarchy is represented via a menu link tree. There are a number of key players here we should go over.</p>
<p>We have the <kbd>MenuLinkTree</kbd> service, which is the interface used to load and prepare the tree of a certain menu. The loading is deferred to the <kbd>MenuTreeStorage</kbd> service, which does so on the basis of a <kbd>MenuTreeParameters</kbd> object that contains metadata on certain restrictions to be applied on the menu links that are loaded. We will see some examples of this a bit later.</p>
<p>What comes out of the <kbd>MenuLinkTree</kbd> service is an array of <kbd>MenuLinkTreeElement</kbd> objects. These are essentially value objects that wrap the <kbd>MenuLinkInterface</kbd> plugins and that provide some extra data about their placement in the tree they are loaded in. One such important piece of information is the subtree (the array of <kbd>MenuLinkTreeElement</kbd> objects that are below it).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Menu link tree manipulators</h1>
                </header>
            
            <article>
                
<p>When loading a menu link tree, you get the entire tree that fits the specified parameters. However, when using that tree, you probably want to perform some checks and remove certain items. A common example is to remove the menu links to which the user doesn't have access. This is where manipulators come into place.</p>
<p>The <kbd>MenuLinkTree</kbd> service has a <kbd>transform()</kbd> method, which alters a tree based on an array of manipulators. The latter take the form of callables, typically service names with specific methods. So, the actual manipulators are services that traverse the tree and make alterations to the tree items, their order, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Menu active trail</h1>
                </header>
            
            <article>
                
<p>A menu trail is a list (array) of menu link plugins that are parents of a menu link. For the active trail, that specific menu link represents the current route (if there is a menu link for that route).</p>
<p>The Drupal 8 menu system also has a service that can be used to determine the active trail of the current route if used by a menu link. By passing a menu name to look inside of, the <kbd>MenuActiveTrail</kbd> service returns an array of plugin IDs of the parents all the way up to the menu root, if the current route is in fact an active link. There is also a method that can be used to check that: <kbd>getActiveLink()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rendering menus</h1>
                </header>
            
            <article>
                
<p>Now that we have covered some theory about the menu system, it's time to get our hands dirty with some code. The first thing we will look at is how to work with menus programmatically with the view of rendering them in our module. For this, we will work with the default <strong>Administration</strong> menu that comes with Drupal core and has many links in it, at various levels. Note that the code we write in this section will not be included in the code repository.</p>
<p>Drupal core provides a block, called <kbd>SystemMenuBlock</kbd>, which can be used to render any menu inside a block. However, let's take a look at how we can do this ourselves instead.</p>
<p>The first thing we will need to do is get the <kbd>MenuLinkTree</kbd> service. We can inject it, or, if that's not possible, get it statically via the helper <kbd>\Drupal</kbd> class:</p>
<pre>$menu_link_tree = \Drupal::menuTree(); </pre>
<p>Next, we will need to create a <kbd>MenuTreeParameters</kbd> object so that we can use it to load our menu tree. There are two ways we can do this. We can either create it ourselves and set our own options on it or we can get a default one based on the current route:</p>
<pre>$parameters = $menu_link_tree-&gt;getCurrentRouteMenuTreeParameters('admin');  </pre>
<p>Providing the name of a menu (in our case, "admin"), this method gives us a <kbd>MenuTreeParameters</kbd> instance with the following options set on it:</p>
<ul>
<li>The links in the active trail of the current route are marked as expanded, that is, they will show up in the resulting tree that we load.</li>
<li>The children of the links in the active trail that have the "expanded" property set are also included in the resulting tree.</li>
</ul>
<p>Essentially, this set of parameters gives us a tree within the context of the current route we are on. In other words, it will load all the root links in the menu and all the children of the root link that are in the active trail of the current route. It will leave out the children of the other root links.</p>
<p>You can, of course, further customize this set of parameters or create one from scratch. For example, if we want to load only the tree of a root link inside a menu, we could do it as follows:</p>
<pre>$parameters = new MenuTreeParameters();<br/>$parameters-&gt;setRoot($plugin_id);</pre>
<p>In this example, <kbd>$plugin_id</kbd> is the ID of the menu link that should be at the root of the tree (defined in the YAML file or derived through a derivative).</p>
<p>I encourage you to look inside the <kbd>MenuTreeParameters</kbd> class and explore the other options you have <span><span>for loading</span></span>Â a tree.</p>
<p>For our example, we want to work with the entire menu tree of the Administration menu, so just instantiating a new <kbd>MenuTreeParameters</kbd> object will be enough, as we want to load all links in the menu. We can do this as follows:</p>
<pre>$tree = $menu_link_tree-&gt;load('admin', $parameters); </pre>
<p>Now, we have an array of <kbd>MenuLinkTreeElement</kbd> objects inside the <kbd>$tree</kbd> variable, which contain, among others, the following:</p>
<ul>
<li>The link property, which is the menu link plugin</li>
<li>The subtree property, which is an array of <kbd>MenuLinkTreeElement</kbd> objects going down the tree</li>
<li>Various metadata about the link within the tree (depth, whether in the active trail, whether it has children, access, and so on)</li>
</ul>
<p>However, it is important to note that notwithstanding any <kbd>MenuTreeParameters</kbd> we may have had, we are now sitting on top of all menu links in that menu, regardless of any access check. It is our responsibility to make sure that we don't render links to pages the user has no access to (as they will get a 403Â error when they get there). To do this, we use the manipulators we discussed earlier, which are simple methods on a service.</p>
<p>The Drupal 8 menu system comes with a few default manipulators that can be found inside the <kbd>DefaultMenuLinkTreeManipulators</kbd> service. Most of the time, they will be sufficient for you:</p>
<ul>
<li>Access (handled by the <kbd>checkAccess()</kbd> method): Checks whether the user has access to the links in the tree. If they don't, the link becomes an instance of <kbd>InaccessibleMenuLink</kbd> and any links in its subtree are cleared out.</li>
<li>Node Access (handled by the <kbd>checkNodeAccess()</kbd> method): Checks whether the user has access to the Node entity linked to by the menu link. If you know that the menu has links to Nodes, you can use this before the regular access check because it's a bit more performant.</li>
<li>Index and Sort (handled by the <kbd>generateIndexAndSort()</kbd> method): Creates unique indexes in the tree and sorts it by them.</li>
<li>Flatten (handled by the <kbd>flatten()</kbd> method): Flattens the menu tree to one level.</li>
</ul>
<p>If these are not enough, you can add your own manipulators as needed. All you have to do is define a service that has a public method and then reference it when transforming the tree. However, speaking of transforming, let's go ahead and use the access check manipulator to ensure that the current user has access to our tree links:</p>
<pre><span>$manipulators </span><span>= [<br/></span><span>  [</span><span>'callable' </span><span>=&gt; </span><span>'menu.default_tree_manipulators:checkAccess'</span><span>]<br/></span><span>]</span><span>;<br/></span><span>$tree </span><span>= </span><span>$menu_link_tree</span><span>-&gt;</span><span>transform</span><span>(</span><span>$tree</span><span>, </span><span>$manipulators</span><span>)</span><span>;</span></pre>
<p>As I mentioned earlier, we use the <kbd>transform()</kbd> method on the service and pass an array of callables. The latter are nothing more than the service name, followed by <kbd>:</kbd> and the method name to be used (like shown in the code above). So if you create your own service, you can reference it the same way.</p>
<p>Now, each <kbd>MenuLinkTreeElement</kbd> that remains in the tree has its <kbd>access</kbd> property filled with an instance of <kbd>AccessResultInterface</kbd> (a system of denoting access that we will talk more about in a later chapter). If the link is not accessible, it becomes an instance of <kbd>InaccessibleMenuLink</kbd>, so we know that we cannot render it, and even if we did render it, it will go to the home page rather than the 403.</p>
<p>Now, to render the tree, all we have to do is turn this tree into a render array:</p>
<pre>$menu = $menu_link_tree-&gt;build($tree);  </pre>
<p>Inside <kbd>$menu</kbd>, we now have a render array that uses the <kbd>menu</kbd> theme hook with a theme hook suggestion based on the menu name. So, in our case, it is <kbd>menu__admin</kbd>. Remember what these are from the previous chapter?</p>
<p>The <kbd>menu</kbd> theme hook will use the <kbd>menu.html.twig</kbd> (or <kbd>menu--admin.html.twig</kbd> if it exists inside a theme) file to render the menu links inside a simple, albeit hierarchical, HTML list.</p>
<p>As a quick recap from the theming chapter, at this point you have a few options <span><span>for gaining</span></span>Â full control over the output of the menu:</p>
<ul>
<li>Creating a new theme hook and mimicking what the <kbd>build()</kbd> method does to build the render array</li>
<li>Altering the theme registry to switch out the template with your own</li>
<li>Overriding the template inside a theme</li>
<li>Implementing a preprocessor for the theme hook and altering variables there</li>
</ul>
<p>So, as you can see, you have many options. The choice you make depends on what you need to achieve, how happy you are with what the default markup is, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with menu links</h1>
                </header>
            
            <article>
                
<p>Now that we know how to load and manipulate trees of menu links, let's talk a bit more about the regular menu links. In this section, we will look at how our module can define menu links and how we can work with them programmatically once we get our hands on them from a tree or somewhere else.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining menu links</h1>
                </header>
            
            <article>
                
<p>In our <em>Hello World</em>Â module we defined a couple of routes, one of which mapping to the <kbd>/hello</kbd> path. Let's now create a link to that path <span><span>which</span></span>Â goes inside the main menu that is shippedÂ with Drupal core.</p>
<p>As I mentioned, menu links are defined inside a <kbd>*.links.menu.yml</kbd> file. So, let's create that file for our module and add our menu link definition in it:</p>
<pre>hello_world.hello:<br/>  title: 'Hello'<br/>  description: 'Get your dynamic salutation.'<br/>  route_name: hello_world.hello<br/>  menu_name: main<br/>  weight: 0</pre>
<p>In a typical YAML notation, we have the machine name (in this case, also the plugin ID) <kbd>hello_world.hello</kbd>, followed by the relevant information below it. These are the most common things you will define for a menu link:</p>
<ul>
<li>The <kbd>title</kbd> is the menu link title whereas the <kbd>description</kbd> is, by default, set as the <kbd>title</kbd> attribute on the resulting link tag.</li>
<li>The <kbd>route_name</kbd> indicates the route to be used behind this link.</li>
<li>The <kbd>menu_name</kbd> indicates the menu that it should be in; this is the machine name of the menu.</li>
<li>The <kbd>weight</kbd> can be used to order links within the menu.</li>
</ul>
<p>An additional common property is <kbd>parent</kbd> that can be used toÂ indicate another menu link the current one should be a child of. As such, you can build the hierarchy.</p>
<p>Once this is in, you should clear the cache and check out the links in the menu. You'll note that you can edit it, but some things cannot be changed through the UI due to them being defined in code.</p>
<p>Note that links that are created as a result of plugin derivatives, such as the ones created in the UI, have machine names (plugin IDs) in the following format:</p>
<pre>main_plugin_id:plugin_derivative_id</pre>
<p>The <kbd>main_plugin_id</kbd> is the ID of the menu link plugin that is responsible for deriving multiple links, whereas the <kbd>plugin_derivative_id</kbd> is the ID given to each individual derivative. For example, in the case of <kbd>MenuLinkContent</kbd> entities, the format is like this:</p>
<pre>menu_link_content:867c544e-f1f7-43aa-8bf7-22fcb08a4b50  </pre>
<p>The UUID in the previous code is actually the UUID of the menu link content entity, which happens to be the plugin derivative ID.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with menu links</h1>
                </header>
            
            <article>
                
<p>I mentioned earlier that <kbd>MenuLinkTreeElement</kbd> objects wrap individual menu links, but what can you do with these programmatically if you choose to work with this data yourself and not rely on the <kbd>menu</kbd> theme hook? Let's cover a few common things you can do.</p>
<p>First of all, the most important thing to do is to access the menu link plugin. You can do so directly, as it is a public property on the <kbd>MenuLinkTreeElement</kbd>:</p>
<pre>$link = $data-&gt;link;  </pre>
<p>Now, you can work with the <kbd>$link</kbd> variable, which is an instance of <kbd>MenuLinkInterface</kbd>, and more often than not, an actual <kbd>MenuLinkDefault</kbd> instance that extends the <kbd>MenuLinkBase</kbd> class.</p>
<p>So if we inspect that interface, we can see a number of handy methods. The most common of these will be the getters for the menu link definition we saw earlier when defining the plugins. The <kbd>getUrlObject()</kbd> is also an important method that transforms the route of the menu link into a <kbd>Url</kbd> object that we already know how to use. If the menu link is created in the UI, it could be that it has no route but only a path, in which case, this method will still be able to construct a common <kbd>Url</kbd> object based on that path.</p>
<p>If you have your hands on a menu link that is not from a tree where you have already handled access, you can ask the <kbd>Url</kbd> object to check access before actually using it:</p>
<pre>$access = $url-&gt;access()  </pre>
<p>If the link is not routed, the access will always return <kbd>TRUE</kbd> because it means that the link is external, or, in any case, no access check can be done. We will talk more about the access system in a separate chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining local tasks</h1>
                </header>
            
            <article>
                
<p>Let's now take a look at an example of how we can define local task links by heading back to our <em>Hello World</em> module. On the <kbd>/hello</kbd> page, let's add two local tasksâ€”one for the regular <kbd>/hello</kbd> page, and the other for the configuration form where the salutation can be changed. This is a good example of using local tasks (tabs), as the configuration form is strictly related to what is on the page and is used to make changes to it.</p>
<p>As I mentioned, local tasks go inside a <kbd>*.links.task.yml</kbd> file. So, let's create one for our module with two links in it:</p>
<pre>hello_world.page:<br/>  route_name: hello_world.hello<br/>  title: 'Hello World'<br/>  base_route: hello_world.hello<br/> hello_world.config:<br/>  route_name: hello_world.greeting_form<br/>  title: 'Configuration'<br/>  base_route: hello_world.hello<br/>  weight: 100</pre>
<p>As usual, the topmost lines are the machine name (plugin IDs) of the links and we have the definitions under them. We have a <kbd>route_name</kbd> property again to specify what route these links should go to, a <kbd>title</kbd> for the link title, and a <kbd>base_route</kbd>. The latter is the route the local task should show up on. As you can see, both our links will show up on the <kbd>/hello</kbd> page. The <kbd>weight</kbd> property can be used to order the tabs.</p>
<p>If you clear the cache and go to that page (as a user who has access to both routes), you'll be able to see the following two tabs:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d7bc1c29-2acc-45c3-8f71-6e4eed51b12f.png" style="width:29.75em;height:21.25em;"/></p>
<p>If you visit as an anonymous user, neither will show up for the reason I mentioned earlier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining local actions</h1>
                </header>
            
            <article>
                
<p>Nothing about our Hello World module calls for defining a local action link. So instead of doing that, let's check out one that actually makes sense. If you navigate to the <kbd>admin/content</kbd> screen, you'll see the <kbd>+ Add content</kbd> button. It looks exactly the same as the example we saw earlier on the user management page. That is a local action link for this route. The <kbd>+</kbd> styling indicates that these links are primarily used to add or create new items relevant to the current route.</p>
<p>This particular local action link is defined in the <kbd>node</kbd> module inside the <kbd>node.links.action.yml</kbd> file, and it looks like this:</p>
<pre>node.add_page:<br/>  route_name: node.add_page<br/>  title: 'Add content'<br/>  appears_on:<br/>    - system.admin_content</pre>
<p>Again, we have the machine name (plugin ID) and the definition. I hope that <kbd>route_name</kbd> and <kbd>title</kbd> are, by now, clear to you. A new thing here, though, is the <kbd>appears_on</kbd> key that is used to indicate the routes (plural) on which this action link should show up. So, a key feature is that one action link can exist on multiple pages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining contextual links</h1>
                </header>
            
            <article>
                
<p>Contextual links are a bit more complicated than the other types of links we've seen before, but nothing is too challenging for us. Let's take a look at how we can add contextual links to our salutation component so that users can navigate to the configuration form via a contextual link.</p>
<p>First, we will need to create the <kbd>.links.contextual.yml</kbd> file and define the link:</p>
<pre><span>hello_world.override:<br/></span><span>  title: </span><span>'Override'<br/></span><span>  </span><span>route_name: </span>hello_world.greeting_form<br/>  <span>group: </span>hello_world</pre>
<p>Nothing too complicated here. Again, we have a <kbd>title</kbd> link and a <kbd>route_name</kbd>. Additionally, we have a <kbd>group</kbd> key, which indicates the group name that this link will be a part of. We will reference this later.</p>
<p>Next, we will need to alter our theme hook template file because the contextual links are printed in a <kbd>title_suffix</kbd> variable that is available in all theme hooks and is used by various modules to add miscellaneous data to templates. The Contextual module is one such example. So, we will need to get that printed. This is what it will look like now:</p>
<pre><span>&lt;div </span><span>{{ attributes }}</span><span>&gt;<br/></span><span>  </span><span>{{ title_prefix }}</span><br/>  <span>{{ salutation }}</span><br/>  <span>{% </span><span>if </span><span>target %}</span><br/>        <span>&lt;span </span><span>class=</span><span>"salutation--target"</span><span>&gt;</span><span>{{ target }}</span><span>&lt;/span&gt;<br/></span><span>  </span><span>{% </span><span>endif </span><span>%}</span><br/>  <span>{{ title_suffix }}</span><br/><span>&lt;/div&gt;</span></pre>
<p>You'll note that we included the <kbd>title_prefix</kbd> variable to keep things nice and consistent. Usually, these will be empty, so no need to worry.</p>
<p>Finally, comes the more complex partâ€”one that may even change in the future, but, for now, this is how we have to proceed.</p>
<p>Our <kbd>hello_world_salutation</kbd> theme hook defines individual variables rather than a render element. In such cases, inside a general preprocessor, the Contextual module looks at the first defined variable to check whether there are any contextual links defined. In the case of theme hooks that use render elements, it checks that element instead.</p>
<p>This is what the contextual links definition looks like inside a render array and also what we need to add for our use case:</p>
<pre><span>'#contextual_links' </span><span>=&gt; [<br/></span><span>  </span><span>'hello_world' </span><span>=&gt; [<br/></span><span>    </span><span>'route_parameters' </span><span>=&gt; []<br/></span><span>  ]</span><span>,<br/></span><span>]</span></pre>
<p>Here, we defined that the <kbd>hello_world</kbd> group of contextual links should be rendered here. Also, we specified an array of route parameters, which, in our case, is empty. This is because, typically, the contextual links are just thatâ€”contextual, meaning that they usually work with an entity or something that has an ID, and its route requires a parameter. So, here is where we can supply that because as we've seen, the <kbd>*.links.contextual.yml</kbd> definition is static and generic.</p>
<div class="packt_infobox">The <kbd>#contextual_links</kbd> property is, in fact, a render element itself that gets replaced with another render element (<kbd>contextual_links_placeholder</kbd>). The latter outputs a simple text placeholder in the HTML, which gets replaced with the correctÂ links via JavaScript.</div>
<p>So, now that we know how to make use of the contextual links, let's alter our Hello World salutation component to make use of this. This is what it looks like now:</p>
<pre><span>public function </span><span>getSalutationComponent</span><span>() {<br/></span><span>  </span><span>$render </span><span>= [<br/></span><span>    </span><span>'#theme' </span><span>=&gt; </span><span>'hello_world_salutation'</span><span>,<br/></span><span>    </span><span>'#salutation' </span><span>=&gt; [<br/></span><span>      </span><span>'#contextual_links' </span><span>=&gt; [<br/></span><span>        </span><span>'hello_world' </span><span>=&gt; [<br/></span><span>          </span><span>'route_parameters' </span><span>=&gt; []<br/></span><span>        ]</span><span>,<br/></span><span>      </span><span>]<br/></span><span>    ]<br/></span><span>  ]</span><span>;<br/></span><span><br/></span><span>  </span><span>$config </span><span>= </span><span>$this</span><span>-&gt;</span><span>configFactory</span><span>-&gt;</span><span>get</span><span>(</span><span>'hello_world.custom_salutation'</span><span>)</span><span>;<br/></span><span>  </span><span>$salutation </span><span>= </span><span>$config</span><span>-&gt;</span><span>get</span><span>(</span><span>'salutation'</span><span>)</span><span>;<br/></span><span><br/></span><span>  </span><span>if </span><span>(</span><span>$salutation </span><span>!= </span><span>""</span><span>) {<br/></span><span>    </span><span>$render</span><span>[</span><span>'#salutation'</span><span>][</span><span>'#markup'</span><span>] = </span><span>$salutation</span><span>;<br/></span><span>    </span><span>$render</span><span>[</span><span>'#overridden'</span><span>] = </span><span>TRUE</span><span>;<br/></span><span>    </span><span>return </span><span>$render</span><span>;<br/></span><span>  </span><span>}<br/></span><span><br/></span><span>  </span><span>$time </span><span>= </span><span>new </span><span>\DateTime()</span><span>;<br/></span><span>  </span><span>$render</span><span>[</span><span>'#target'</span><span>] = </span><span>$this</span><span>-&gt;</span><span>t</span><span>(</span><span>'world'</span><span>)</span><span>;<br/></span><span><br/></span><span>  </span><span>if </span><span>((int) </span><span>$time</span><span>-&gt;</span><span>format</span><span>(</span><span>'G'</span><span>) &gt;= </span><span>00 </span><span>&amp;&amp; (int) </span><span>$time</span><span>-&gt;</span><span>format</span><span>(</span><span>'G'</span><span>) &lt; </span><span>12</span><span>) {<br/></span><span>    </span><span>$render</span><span>[</span><span>'#salutation'</span><span>][</span><span>'#markup'</span><span>] = </span><span>$this</span><span>-&gt;</span><span>t</span><span>(</span><span>'Good morning'</span><span>)</span><span>;<br/></span><span>    </span><span>return </span><span>$render</span><span>;<br/></span><span>  </span><span>}<br/></span><span><br/></span><span>  </span><span>if </span><span>((int) </span><span>$time</span><span>-&gt;</span><span>format</span><span>(</span><span>'G'</span><span>) &gt;= </span><span>12 </span><span>&amp;&amp; (int) </span><span>$time</span><span>-&gt;</span><span>format</span><span>(</span><span>'G'</span><span>) &lt; </span><span>18</span><span>) {<br/></span><span>    </span><span>$render</span><span>[</span><span>'#salutation'</span><span>][</span><span>'#markup'</span><span>] = </span><span>$this</span><span>-&gt;</span><span>t</span><span>(</span><span>'Good afternoon'</span><span>)</span><span>;<br/></span><span>    </span><span>return </span><span>$render</span><span>;<br/></span><span>  </span><span>}    <br/></span><span>  <br/></span><span>  </span><span>if </span><span>((int) </span><span>$time</span><span>-&gt;</span><span>format</span><span>(</span><span>'G'</span><span>) &gt;= </span><span>18</span><span>) {<br/></span><span>    </span><span>$render</span><span>[</span><span>'#salutation'</span><span>][</span><span>'#markup'</span><span>] = </span><span>$this</span><span>-&gt;</span><span>t</span><span>(</span><span>'Good evening'</span><span>)</span><span>;<br/></span><span>    </span><span>return </span><span>$render</span><span>;<br/></span><span>  </span><span>}<br/></span><span>}</span></pre>
<p>The main changes are as follows. First, we have already defined the <kbd>#salutation</kbd> variable at the top and made it into a render array. As you remember, these are highly nestable. In this render array, we added our <kbd>#contextual_links</kbd> render element. Second, every time we need to set the value for the salutation string below, we do so in a <kbd>#markup</kbd> element this time, because, as we saw in the previous chapter, we need a property that defines how the render array gets rendered.</p>
<p>So now if you clear the cache and navigate to the <kbd>/hello</kbd> page, you should be able to hover over the salutation and see the contextual links icon pop up and contain our <kbd>Override</kbd> link. You should land on the salutation <strong>configuration</strong> form when you click on the link and also note a <kbd>destination</kbd> query parameter in the URL:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5c4f4c02-d460-4726-a38f-e8e06838b1ac.png" style="width:21.42em;height:9.75em;"/></p>
<div class="packt_tip">The destination query parameter is used by Drupal to return the user to the page they previously were on after they submitted a form on that page. This is a handy trick to keep in mind, as it is a very popular UX technique.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered a lot of ground for working with menus and menu links. We started by getting an overview of the architecture of the menu system in Drupal 8. I threw many classes and hooks at you because I am a firm believer that the best way to learn is to dig into the code.</p>
<p>We also saw what types of menu links there are in Drupal 8. We not only have regular links that belong to actual menus, but all sorts of other utility link systems, such as local tasks, local actions, and contextual links.</p>
<p>Then, we got our hands dirty and started with a practical example of how to load menu links in a tree, manipulate them, and finally turn them into a render array. Right after that, we looked at how we can define all these types of menu links and how to understand them if we need to work with them programmatically.</p>
<p>In the next chapter, we will look at one of the most important aspects of any kind of content management frameworkâ€”the different types of data storage we can have in Drupal 8 and how we can work with them.</p>


            </article>

            
        </section>
    </body></html>