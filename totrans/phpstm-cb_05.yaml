- en: Chapter 5. Testing and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 测试和调试
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Installing PHPUnit
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装PHPUnit
- en: Test case in PHPUnit
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHPUnit中的测试用例
- en: Testing an application with PHPUnit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PHPUnit测试应用程序
- en: Starting a debugging session
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始调试会话
- en: Setting a breakpoint
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置断点
- en: Configuring breakpoint conditions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置断点条件
- en: Creating exception breakpoints
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建异常断点
- en: Stepping through your code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步进你的代码
- en: Running to a line of code selected
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行到选定的代码行
- en: Watching expressions and variables
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察表达式和变量
- en: Evaluating expressions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估表达式
- en: Changing code on the fly
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线更改代码
- en: Code coverage in PhpStorm
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PhpStorm中的代码覆盖率
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Whenever you create a new software, there is a business dependency inherent
    on that. Obviously, if your software were not sold, you would probably have opted
    for some other profession. Due to the business factor, you are always expected
    to make your software reliable. This can be done only after your software has
    passed testing. It is not that you, the programmers, will do the entire testing
    and kick the tester out. You will be required to do the unit testing while actually
    writing the code. If you unit test your code, the chances of failure decrease
    drastically. The unit testing should ideally be done while creating code, and
    an ideal timeline to unit test is as soon as some milestone functionality has
    been created.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你创建一个新的软件时，都会在它上面固有一个业务依赖。显然，如果你的软件没有出售，你可能已经选择了其他职业。由于业务因素，你总是期望你的软件是可靠的。这只能在软件通过测试后才能实现。并不是说，程序员们将做所有的测试并将测试人员踢出去。你需要在编写代码的同时进行单元测试。如果你对你的代码进行单元测试，失败的可能性会大大降低。理想情况下，单元测试应该在创建代码时进行，而进行单元测试的理想时间是在某个里程碑功能创建后立即进行。
- en: To act wisely and do (unit) testing, use PHPUnit. **PHPUnit** is a system (application)
    written in your favorite PHP. It lets you write test cases for the code you write
    so that you can keep on checking for any error that might creep into your logic.
    Thus, by the time you use a build tool to create something like a phar or any
    other archive, you have already ensured that the first level of filtration has
    been applied.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '要明智行事并进行（单元）测试，请使用PHPUnit。**PHPUnit**是一个用你最喜欢的PHP编写的系统（应用程序）。它让你为编写的代码编写测试用例，这样你就可以继续检查任何可能潜入你逻辑中的错误。因此，在你使用构建工具创建类似phar或其他存档时，你已经确保了已经应用了第一层过滤。 '
- en: 'It is obvious for you to ask the purpose of PHPUnit then. The answer to this
    is simple: you need PHPUnit to prevent errors from passing on to the integration
    testing phase. But what if there were some errors or functionality that could
    not be detected at the unit-testing phase? What if there were errors due to another
    component or module passing on erroneous data?'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你会问PHPUnit的用途。这个答案很简单：你需要PHPUnit来防止错误传递到集成测试阶段。但如果在单元测试阶段有一些错误或功能无法检测到怎么办？如果由于另一个组件或模块传递了错误数据而出现错误怎么办？
- en: Instead of applying the same rule to change the tense of a person's existence,
    you are again advised to act wisely. Use a debugger. Most of the IDEs show debugger
    with a bug icon next to it, so you would not find it difficult to find it in PhpStorm.
    PhpStorm provides you with options to select a debugger and integrate it for usage.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将改变一个人存在的时态的规则应用到测试用例上，你再次被建议要明智行事。使用调试器。大多数IDEs都会在调试器旁边显示一个带有bug图标的调试器，所以你不会在PhpStorm中很难找到它。PhpStorm为你提供了选择调试器并集成以供使用的选项。
- en: Using a debugger, you can do wonders. You actually gain fine-grained control
    over your code. You gain the power to walk across walls and see through iron plates!
    Will you stop dreaming about being a superpower, please. You are still a software
    engineer? A debugger gives you the power to look into the value of any variable
    in your code and the return value of a method, to pause the execution at will
    and resume it at will, and the list is endless.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试器，你可以创造奇迹。你实际上可以对你的代码获得细粒度的控制。你获得了穿越墙壁和透视铁板的权力！请停止梦想成为超级英雄，你仍然是一名软件工程师？调试器给你提供了查看代码中任何变量的值和方法返回值的能力，可以随意暂停执行并随意恢复，而且列表无穷无尽。
- en: Before diving into the deep sea of knowledge, it is important to know the difference
    between testing and debugging. **Testing** is a process that is likely to be done
    during the development phase, just after some business logic has been developed
    and it needs to be cleaned and sanitized properly before being released into production.
    **Debugging** is the process of removal of bugs from the code. A bug is that unwanted
    (improper) functionality that has passed the testing phase and has been discovered
    in the later testing phases or even in the production phase. Actually, both are
    similar because the aim of both is just to clean the product and functional software
    application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入知识海洋之前，了解测试和调试之间的区别很重要。**测试**是一个可能在开发阶段进行的过程，在开发了一些业务逻辑之后，它需要在发布到生产之前被彻底清理和净化。**调试**是从代码中移除错误的过程。错误是那些在测试阶段通过且在后续测试阶段或甚至在生产阶段被发现的不希望（不适当）的功能。实际上，两者是相似的，因为它们的目的只是清理产品和功能软件应用。
- en: Installing PHPUnit
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 PHPUnit
- en: The discussion starts with testing because it precedes debugging in the software
    development life cycle. PHP provides a unit-testing system, which is known as
    PHPUnit.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论从测试开始，因为在软件开发生命周期中，测试发生在调试之前。PHP 提供了一个单元测试系统，称为 PHPUnit。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you use PHPUnit, you gain the freedom to write some code and to check some
    code. Yes, you read it right. You can use PHPUnit to write some program that will
    check the input and output of some other program. Interesting phenomenon, right?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 PHPUnit，你将获得编写一些代码和检查一些代码的自由。是的，你没听错。你可以使用 PHPUnit 编写一些程序来检查其他程序输入和输出。有趣的现象，对吧？
- en: When you can write an application (PHP code) using an application (PhpStorm),
    why not test the application (PHP code) with an application (PHPUnit test cases)?
    Since PHPUnit is just an application written in PHP, it is available in the form
    of a **PHP Archive** (**PHAR**). It is just a method to ship your files and folders
    as a whole and to make it ready to be executed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你可以使用一个应用程序（PhpStorm）编写一个应用程序（PHP 代码）时，为什么不使用一个应用程序（PHPUnit 测试用例）来测试这个应用程序（PHP
    代码）呢？由于 PHPUnit 只是一个用 PHP 编写的应用程序，它以**PHP 归档**（**PHAR**）的形式提供。它只是将你的文件和文件夹作为一个整体发送并使其准备就绪以执行的方法。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please make sure that you have PHP interpreter installed before installing PHPUnit.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 PHPUnit 之前，请确保你已经安装了 PHP 解释器。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: You can install it very easily by just downloading the PHPUnit archive (the
    `phar` file) and setting the `/path/to/phpunit.phar` in the list of include paths.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过下载 PHPUnit 归档（PHAR 文件）并在包含路径列表中将 `/path/to/phpunit.phar` 设置为非常容易地安装它。
- en: 'You just need to perform the following steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要执行以下步骤：
- en: Go to the **Project** view.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**项目**视图。
- en: Access the right-click context menu on the **External Libraries** directory.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**外部库**目录上右键单击以访问上下文菜单。
- en: Select the **Configure PHP includes path** option.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**配置 PHP 包含路径**选项。
- en: 'You can also do that quickly by selecting the **External Libraries** directory,
    pressing *F4*, and pointing to the correct `phpunit.phar` file, as shown in the
    following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过选择**外部库**目录，按 *F4*，并指向正确的 `phpunit.phar` 文件来快速完成，如下面的截图所示：
- en: '![How to do it...](img/3878OT_05_15.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/3878OT_05_15.jpg)'
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since you have installed PHPUnit as a package (PHAR), the testing system swings
    into action as soon as you inherit (or extend) a class defined inside the directory
    `phpunit-lts.phar` under the `phpunit` directory and the framework subdirectory
    with the name `PHPUnit_Framework_TestCase`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经将 PHPUnit 作为包（PHAR）安装，测试系统将在你继承（或扩展）位于 `phpunit` 目录下 `phpunit-lts.phar`
    目录和名为 `PHPUnit_Framework_TestCase` 的框架子目录中的类时立即启动。
- en: Test case in PHPUnit
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHPUnit 中的测试用例
- en: Having installed PHPUnit successfully, your challenge is not over yet—it has
    just led to another array of challenges. Testing is no easy task, but it is interesting.
    Just as you love writing beautiful PHP code, you will love writing test cases
    in PHPUnit because it is just like writing PHP code while taking care of some
    conventions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 成功安装 PHPUnit 后，你的挑战还没有结束——它只是引出了一系列新的挑战。测试不是一件容易的事情，但它很有趣。就像你喜欢编写漂亮的 PHP 代码一样，你也会喜欢在
    PHPUnit 中编写测试用例，因为它就像编写 PHP 代码的同时注意一些约定。
- en: A **test case** is a piece of an application that is written specifically to
    check (or test) for certain conditions in another application. Thus, when you
    write down a test case, you actually write a PHP code to test if something has
    gone wrong in other PHP code (which happens to be the code you have written to
    meet the business requirements).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例**是一段专门编写来检查（或测试）另一个应用程序中某些条件的应用程序代码的一部分。因此，当你编写测试用例时，你实际上是在编写PHP代码来测试其他PHP代码（即你编写的满足业务需求的代码）中是否出现了错误。'
- en: 'Here, it is quite important to state that you, the programmer, usually have
    the following point of view:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，很重要的一点是指出，作为程序员，你通常有以下观点：
- en: You think that since you know your code very well you know that your code is
    errorless
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你认为既然你非常了解你的代码，你就知道你的代码没有错误
- en: Even if there are some errors in your code, since you know the code deeply,
    you can fix it in a flash
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使你的代码中存在一些错误，由于你对代码了解得很深，你可以迅速修复它们
- en: You think that the time you waste in writing test cases can be better utilized
    in writing more code
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你认为你在编写测试用例上浪费的时间可以更好地用于编写更多的代码
- en: These (and many such) points are incorrect. You need to write test cases.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些（以及许多类似）点是错误的。你需要编写测试用例。
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a new test case, you need to create a new PHPUnit class. Thus, perform
    the following steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的测试用例，你需要创建一个新的PHPUnit类。因此，执行以下步骤：
- en: Go to the **Project** view.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**项目**视图。
- en: Select the file you want to test. This file should be a valid PHP class. Obvious
    statement.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要测试的文件。这个文件应该是一个有效的PHP类。这是一个明显的陈述。
- en: From the right-click context menu, select **New** | **PHPUnit** | **PHPUnit
    Test**, as shown in the following screenshot:![How to do it...](img/3878OT_05_14.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从右键单击上下文菜单中选择**新建** | **PHPUnit** | **PHPUnit 测试用例**，如图所示：![如何操作...](img/3878OT_05_14.jpg)
- en: Provide the name and the related details just as you would do to create a new
    PHP class.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供名称和相关细节，就像你创建新的PHP类时做的那样。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The test cases that you create will be PHP methods with the public access specifier
    inside this class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的测试用例将是这个类中具有公共访问修饰符的PHP方法。
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To see how a test case works, you need to follow some conventions. The reason
    is that, since a test case is a PHP code, it has to have some functionality inherent
    in it. The conventions are listed for quick reference:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看测试用例的工作原理，你需要遵循一些约定。原因是，由于测试用例是PHP代码，它必须具有一些固有的功能。以下列出了这些约定，以便快速参考：
- en: The test class should have the same name as the target class. Thus, you will
    create `XXXTest` inside the file `XXXTest.php` given that the name of the class
    to be tested is `XXX`.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试类应该与目标类具有相同的名称。因此，在`XXXTest.php`文件中创建`XXXTest`，假设要测试的类名为`XXX`。
- en: All test classes should extend (inherit) the `PHPUnit_Framework_TestCase` class.
    This class is made available to you when you include the PHAR in your PhpStorm
    project (as we saw in the *Installing PHPUnit* recipe of this chapter).
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有测试类都应该扩展（继承）`PHPUnit_Framework_TestCase`类。当你将PHAR包含到你的PhpStorm项目中时，这个类就对你可用（正如我们在本章的*安装PHPUnit*小节中看到的）。
- en: 'Thus, your class `XXXTest` will have the following declaration:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你的`XXXTest`类将具有以下声明：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The exact method to be tested inside the test class should have its name starting
    with `test` followed by the name of the method to be tested.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类中要测试的确切方法应该以`test`开头，后跟要测试的方法名。
- en: It is not that your test will fail just due to this reason, but it is a standard
    naming practice.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 并非你的测试仅仅因为这个原因就会失败，但这是一种标准的命名约定。
- en: There is also no constraint on you to map one-to-one test methods to one single
    target method. Again, it is just a good practice.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何约束要求你将一对一的测试方法映射到单个目标方法。这同样只是一种良好的实践。
- en: 'Thus, given that the name of the method to be tested is `YYY`, a test inside
    your test class will have the declaration (definition) as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑到要测试的方法名为`YYY`，你的测试类中的测试将具有以下声明（定义）：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As per the convention, you should write one test inside one method only. It
    leads to better organization of code and makes it easier to understand.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 根据约定，你应该在单个方法中编写一个测试。这有助于更好地组织代码，并使其更容易理解。
- en: 'The actual testing is done by asserting some facts. The facts are the output
    of the methods you will be testing. Thus, if some method returns a string, you
    can check if the method return type is `string` by writing the following line
    of code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的测试是通过断言一些事实来完成的。这些事实是你将要测试的方法的输出。因此，如果某个方法返回一个字符串，你可以通过编写以下代码行来检查该方法返回类型是否为`string`：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A test class should have the common content inside a `setUp` method. This is
    particularly helpful in cases in which you need to have a chunk of code shared
    across all the test methods in this class. It is your call whether to use it or
    not.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类应该在`setUp`方法内部包含常见内容。这在需要在这个类的所有测试方法中共享一段代码的情况下特别有用。是否使用它由你决定。
- en: At the end of a test method being called, you might not need to have the resources
    at hand. You might want to remove it from memory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在被调用的测试方法结束时，你可能不需要保留资源。你可能想要将其从内存中删除。
- en: Here, it is quite important to remember that you should always design your tests
    wisely. You should always prevent unwanted memory usage in your test because once
    you do that, you will have to add another testing on this test class as well.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，记住这一点非常重要，你应该始终明智地设计你的测试。你应该始终防止在测试中产生不必要的内存使用，因为一旦你做到了这一点，你将不得不在这个测试类上添加另一个测试。
- en: Having known the nuances of test cases, you are all set to test. This is a deliberate
    misuse of the letters of the alphabet to alert you!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了测试用例的细微差别，你现在已经准备好进行测试了。这是故意滥用字母表中的字母来提醒你！
- en: Whatever you do, PhpStorm assists you. So, instead of waiting and thinking about
    what to do, get set, go!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你做什么，PhpStorm都会帮助你。所以，不要等待和思考要做什么，准备就绪，出发吧！
- en: Testing an application with PHPUnit
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHPUnit测试应用程序
- en: There must be a question hovering in your mind about the role of PhpStorm in
    this testing. It's time for action. Having sufficient knowledge of the conventions
    to write tests, you can proceed to face the real world of testing. The more you
    test, the purer your code will become. Testing is good. Testing is healthy. Testing
    is recommended.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你心中可能有一个关于PhpStorm在这个测试中作用的问题。现在是采取行动的时候了。有了足够的关于编写测试的规范知识，你可以进入测试的真正世界。你测试得越多，你的代码就会越纯净。测试是好的。测试是健康的。测试是推荐的。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Good question. This question is best answered with some diving back into time
    to get back the same pizza cooking use case. You have grown up listening to grandma''s
    advice to reuse objects. Now is the time for you to reuse. Perform the following
    steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 好问题。这个问题最好通过回到过去，回到相同的比萨饼烹饪用例来回答。你从小就听着奶奶的建议去重复使用物品。现在是你重复使用的时候了。执行以下步骤：
- en: 'Reuse the `PizzaDish` class. You will create a test class somewhat like the
    following:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复使用`PizzaDish`类。你将创建一个类似于以下测试类：
- en: '[PRE3]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As promised, you can see that the PHPUnit is all about writing PHP classes.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如承诺的那样，你可以看到PHPUnit完全是关于编写PHP类。
- en: To execute this test, you need to execute (run) this class.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行这个测试，你需要运行（执行）这个类。
- en: Running this class is extremely simple. *Ctrl* + *Shift* + *F10* is your savior.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行这个类非常简单。*Ctrl* + *Shift* + *F10*是你的救星。
- en: If you want to run a single method, PhpStorm provides for that as well. You
    just need to place the cursor anywhere inside the body of the method you want
    to execute and issue the run command.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你只想运行一个方法，PhpStorm也为此提供了支持。你只需将光标放在你想要执行的方法体内任何位置，然后发出运行命令。
- en: Tip
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If the cursor is not inside a method body, the entire test class will be executed.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果光标不在方法体内，整个测试类将被执行。
- en: 'The following screenshot shows the test result:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了测试结果：
- en: '![How to do it...](img/3878OT_05_01.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/3878OT_05_01.jpg)'
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to execute your unit test, PhpStorm makes some improvisations. Just
    as it does with every other library, it uses its own version of the execution
    script to execute the test. The full name of the file is `/tmp/ide-phpunit.php`.
    Thus, it is this file that accepts the name of the test class file you have written.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行你的单元测试，PhpStorm进行了一些改进。就像它对其他每个库所做的那样，它使用自己的执行脚本来执行测试。该文件的完整名称是`/tmp/ide-phpunit.php`。因此，正是这个文件接受你编写的测试类文件的名称。
- en: The working of the testing application is simple. As already stated, all classes
    that inherit `PHPUnit_Framework_TestCase` class become test classes. The `setUp`
    method instantiates an object of the target class `PizzaDish` and makes it available
    to the entire test class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应用程序的工作原理很简单。正如已经提到的，所有继承自`PHPUnit_Framework_TestCase`类的类都成为测试类。`setUp`方法实例化目标类`PizzaDish`的对象，并将其提供给整个测试类。
- en: Inside your test class, the `testGetInstance` and `testGetDishName` methods
    get executed when you run the test. Inside the test method, a new object is instantiated
    to initiate the actual testing process. Up until this point, the activities that
    you did were the same as those for a PHP class. Inside the methods, there are
    certain assertions that do the actual testing. There are these special methods,
    namely, `assertInstanceOf` and `assertInternalType`, which are declared in the
    `Assert` class provided by the framework. You can view the documentation of the
    method by putting the cursor under the method name and pressing *Ctrl* + *Q*.
    These are the actual methods that perform the testing task by checking if the
    given assertion is true. Thus, the motive of the test class that you created is
    to check whether the desired class is instantiated or not and whether the name
    of the dish that you want to cook is of the type `string`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试类内部，当你运行测试时，`testGetInstance`和`testGetDishName`方法会被执行。在测试方法内部，会实例化一个新的对象以启动实际的测试过程。直到这一点，你所做的活动与PHP类的活动相同。在方法内部，有一些断言执行实际的测试。有这些特殊的方法，即`assertInstanceOf`和`assertInternalType`，这些方法是在框架提供的`Assert`类中声明的。你可以通过将光标放在方法名下并按*Ctrl*
    + *Q*来查看该方法的文档。这些是实际通过检查给定的断言是否为真来执行测试任务的方法。因此，你创建的测试类的目的是检查是否实例化了所需的类，以及你想要烹饪的菜名是否为`string`类型。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Once you run the test, you will be able to see the test results in the usual
    run view which is accessible by *Alt* + *4*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行测试，你将能够在通常的运行视图中看到测试结果，该视图可以通过*Alt* + *4*访问。
- en: Starting a debugging session
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始调试会话
- en: '*"Now is the time for all programmers to start debugging their code"*'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"现在是所有程序员开始调试他们的代码的时候了"*'
- en: Like most IDEs, PhpStorm also uses a bug icon to show the debugger. Just as
    a bug leeches your blood and doesn't let you concentrate on your main task, a
    software bug can leech precious CPU cycles and not allow your software to work
    as expected.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数IDE一样，PhpStorm也使用一个错误图标来显示调试器。就像虫子吸血并让你无法专注于主要任务一样，软件错误可以消耗宝贵的CPU周期，并阻止你的软件按预期工作。
- en: To prevent such bugs from entering the life cycle of software, you need to do
    debugging. Debugging is the process of diving deep into the code and finding out
    the potential areas that might be the problem causing regions in the code, so
    do extensive lookup to find and rectify the bugs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止此类错误进入软件的生命周期，你需要进行调试。调试是一个深入代码的过程，找出可能成为代码中问题区域的潜在区域，因此需要进行广泛的查找以发现和修复错误。
- en: The tools available for the purpose are termed debuggers in the industry. **Xdebug**
    is the name for one such tool. It is a very commonly used, free, and open source
    debugger that is available to be plugged in with most IDEs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此目的的工具在业界被称为调试器。**Xdebug**是此类工具的名称。它是一个非常常用、免费且开源的调试器，可以与大多数IDE连接。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To plug it in, you need to install it on your development machine. Perform
    the following steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接它，你需要在你的开发机器上安装它。执行以下步骤：
- en: Check out the source code from **GitHub**, the repository where Xdebug is hosted.
    You need to issue this command in your terminal `git clone git://github.com/xdebug/xdebug.git`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**GitHub**检出源代码，这是Xdebug托管的地方。你需要在终端中发出此命令`git clone git://github.com/xdebug/xdebug.git`。
- en: Move into the directory where the code has been checked out.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入已检出代码的目录。
- en: Issue the command `phpize`. There will be lots of text output to the console
    when you do this. Once the output finishes, you need to execute the configuration
    file, which happens to be an executable shell script.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出`phpize`命令。当你这样做时，控制台将输出大量文本。一旦输出完成，你需要执行配置文件，它恰好是一个可执行的shell脚本。
- en: You need to enable `xdebug` using the switch `--enable-xdebug` while configuring.
    Thus, you should write `./configure --enable-xdebug`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置时，你需要使用`--enable-xdebug`开关启用`xdebug`。因此，你应该写`./configure --enable-xdebug`。
- en: When this has been done, you need to issue the command `make && make install`
    to complete the compilation.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，你需要发出`make && make install`命令以完成编译。
- en: The output of steps will be a module—precisely a shared object or a `.so` file
    that you need to specify in the PHP settings. Kindly note it.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 步骤的输出将是一个模块——确切地说是一个共享对象或 `.so` 文件，您需要在 PHP 设置中指定它。请记住这一点。
- en: 'Inside the appropriate `ini` file, you need to write the following code:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在适当的 `ini` 文件中，您需要写下以下代码：
- en: '[PRE4]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In order to know which `php.ini` file your PhpStorm uses, you need to go to
    **Tools** | **Run Command** and issue the command `php --ini`. You will be given
    a list of all the `.ini` files that are parsed. You now have the correct `.ini`
    file to make the changes in.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了知道您的 PhpStorm 使用哪个 `php.ini` 文件，您需要转到 **工具** | **运行命令** 并执行命令 `php --ini`。您将获得所有解析的
    `.ini` 文件列表。现在您有了正确的 `.ini` 文件来做出更改。
- en: Note
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is this shortcut as well, *Ctrl* + *Shift* + *X*, which opens the command-line
    tool console.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，还有一个快捷键，*Ctrl* + *Shift* + *X*，它打开命令行工具控制台。
- en: Having installed a powerful debugger, you can proceed to making your code bug-free.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了强大的调试器后，您可以继续使您的代码无错误。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'A debugging session is to be started only for a web-based PHP application.
    In order to be able to initiate the debugging for a web application, perform the
    following steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 仅针对基于 Web 的 PHP 应用程序启动调试会话。为了能够启动 Web 应用的调试，请执行以下步骤：
- en: You need to have, let's say for Chrome, an `xdebug` helper. It helps you to
    initiate a debugging session once you type in a URL.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要有一个，比如说 Chrome 的 `xdebug` 辅助工具。它帮助您在输入 URL 后启动调试会话。
- en: You know that corresponding to a client, there should be a server so that when
    you attempt to initiate a debug session, there must have been a listener for the
    incoming connection.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您知道，对于客户端，应该有一个服务器，这样当您尝试启动调试会话时，必须有监听传入连接的监听器。
- en: So, you need to start the listener for the incoming debug connection. To do
    that, you need to go to **Run** | **Start Listen to debug connections**.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，您需要启动传入调试连接的监听器。为此，您需要转到 **运行** | **开始监听调试连接**。
- en: 'Once you initiate the session for the first time, PhpStorm shows an alert regarding
    some entry, as shown in the screenshot following the next information box:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一次启动会话后，PhpStorm 会显示有关某些条目的警报，如下一个信息框后的截图所示：
- en: Note
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure that the checkbox is checked for **Can accept external connection**.
    This will be found in **Settings** | **PHP** | **Debug**.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保已勾选 **可以接受外部连接** 的复选框。这可以在 **设置** | **PHP** | **调试** 中找到。
- en: '![How to do it...](img/3878OT_05_02.jpg)'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/3878OT_05_02.jpg)'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: Once you accept the connection, PhpStorm saves it. The saved servers can be
    viewed later under **File** | **Settings** | **PHP** | **Servers**. From this
    point onwards, the debugging process becomes the same for a web-based application
    and a command-line application. So the debugger will view whatever variables will
    be there in the code, and according to the breakpoints that you provide, it will
    pause, continue, step through, or step over the code, thus making it very easy
    for you to see what is going on inside the code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您接受连接，PhpStorm 会将其保存。已保存的服务器可以在 **文件** | **设置** | **PHP** | **服务器** 下稍后查看。从这一点开始，基于
    Web 的应用程序和命令行应用程序的调试过程将相同。因此，调试器将查看代码中的任何变量，并根据您提供的断点，暂停、继续、逐行或跳过代码，从而使您能够非常容易地看到代码内部正在发生什么。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can also visit [http://www.xdebug.org/wizard.php](http://www.xdebug.org/wizard.php)
    to know more about `xdebug` installation for your server.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以访问 [http://www.xdebug.org/wizard.php](http://www.xdebug.org/wizard.php)
    了解更多关于您服务器上 `xdebug` 安装的详细信息。
- en: Setting a breakpoint
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置断点
- en: A breakpoint in a code is that point (or line of code) where you want the program
    execution to pause for a while. When you were cooking pizza and adding ingredients,
    suppose you wanted to know at any instant which ingredient was about to be added,
    you can set a breakpoint to actually make the interpreter pause at the line where
    the variable contained the name of the ingredient to be added. After a breakpoint
    is set, you can see which value a variable assumes under the variables frame in
    the debug window.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的断点是指您希望程序执行暂停的（或代码行）。当您在烤披萨并添加配料时，假设您想知道在任何时刻即将添加哪种配料，您可以设置一个断点，使解释器暂停在包含即将添加的配料名称的变量的那一行。设置断点后，您可以在调试窗口的变量框架中看到变量的值。
- en: 'There are two types of breakpoints, which are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 断点有两种类型，如下所示：
- en: '**Permanent breakpoint**: A normal breakpoint is one which remains till eternity,
    until you manually remove it'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**永久断点**：一个常规断点是指它将一直存在，直到您手动移除它'
- en: '**Temporary breakpoint**: A temporary breakpoint, on the other hand, is a breakpoint
    that gets removed or disabled upon certain conditions, the most common being a
    hit.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**临时断点**：另一方面，临时断点是在满足某些条件时被移除或禁用的断点，最常见的条件是触发。'
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To set a normal breakpoint, you need to select a suspicious line of code by
    placing the cursor under it.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置一个常规断点，您需要通过将光标放在可疑代码行下选择该行代码。
- en: Go to **Run** | **Toggle Line Breakpoint**.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**运行** | **切换行断点**。
- en: There will be a red circle created at the left-hand side panel to give you a
    visual indication that the line is a breakpoint.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板上将会创建一个红色圆圈，以提供视觉指示，表明该行是一个断点。
- en: You can do the same using the keyboard shortcut *Ctrl* + *F8*.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用键盘快捷键 *Ctrl* + *F8* 做同样的事情。
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: A breakpoint allows you to view the state of the variables stack. So, when the
    interpreter halts at a breakpoint, you can view the contents of the variables
    involved in the program execution. If you have added some variables or expressions
    to *watch*, you can constantly view the content of the selected variable at all
    times as long as it remains in the current scope. At all other times during the
    execution, there is the message **Cannot evaluate expression** shown. The debugger
    provides instruction to the interpreter to pause the execution when a breakpoint
    is hit. Upon request, the debugger instructs the interpreter to write (output)
    messages to the console (and it appears to the human eye that PhpStorm has done
    it!)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 断点允许您查看变量栈的状态。因此，当解释器在断点处停止时，您可以查看程序执行中涉及的变量的内容。如果您添加了一些变量或表达式到**监视**中，您可以在当前作用域内始终查看所选变量的内容，只要它保持在该作用域内。在执行的其他所有时间，都会显示消息**无法评估表达式**。调试器向解释器提供指令，在断点被触发时暂停执行。根据请求，调试器指示解释器将（输出）消息写入控制台（对人类眼睛来说，这看起来像是PhpStorm
    完成了这项工作！）
- en: Configuring breakpoint conditions
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置断点条件
- en: PhpStorm provides you ways to customize the breakpoints. So you have some more
    comfort to sit back and enjoy the debugging happening, while being sure that your
    task will be done in time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: PhpStorm 提供了自定义断点的方法。因此，您有更多的舒适度来坐下来享受调试过程，同时确保您的任务能够按时完成。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Once you set a breakpoint, you can press *Ctrl* + *Shift* + *F8* to get a configuration
    panel. Using the panel, you can change the regular breakpoint to a temporary breakpoint.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您设置了断点，您可以按 *Ctrl* + *Shift* + *F8* 来获取一个配置面板。使用该面板，您可以将常规断点更改为临时断点。
- en: Select the checkbox next to the **Remove once hit** option. That breakpoint
    will only be existent till the breakpoint is hit once.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**一旦触发则移除**选项旁边的复选框。这样，该断点只会在断点被触发一次后存在。
- en: You can select **Log message to console** to output once this breakpoint gets
    hit.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以选择**将消息记录到控制台**，以便在断点被触发时输出。
- en: You can create an expression to be evaluated once this breakpoint gets hit by
    selecting the **Log evaluated expression** checkbox. You can also keep this breakpoint
    dormant conditionally.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过勾选**记录评估表达式**复选框来创建一个表达式，一旦这个断点被触发就会进行评估。您也可以有条件地使这个断点保持休眠状态。
- en: You can tell PhpStorm to activate this breakpoint to remain disabled until an
    exception of a particular type is thrown, as shown in the following screenshot:![How
    to do it...](img/3878OT_05_03.jpg)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以告诉PhpStorm激活此断点，使其保持禁用状态，直到抛出特定类型的异常，如以下截图所示：![如何操作...](img/3878OT_05_03.jpg)
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: Again, there is no logical explanation as to how a breakpoint works. You need
    to follow the steps shown, and PhpStorm will do the trick for you. The working
    is more related to the operating system.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，关于断点是如何工作的，并没有逻辑上的解释。您需要遵循显示的步骤，PhpStorm 会为您完成这项工作。其工作原理与操作系统有关。
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: While the pop up is still open, you can press *Ctrl* + *Shift* + *F8* to get
    a larger panel in which you can have a peek into the code as well, while still
    having the control panel open.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹出窗口仍然打开时，您可以按 *Ctrl* + *Shift* + *F8* 来获取一个更大的面板，您可以在其中查看代码，同时仍然保持控制面板打开。
- en: 'This is as shown in the following screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示：
- en: '![How it works...](img/3878OT_05_04.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3878OT_05_04.jpg)'
- en: Creating exception breakpoints
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建异常断点
- en: There is new information for your brain to absorb. Until this point in time,
    you assumed that a breakpoint can be created only manually when you suspected
    some line of code might be problematic. But you can actually create a breakpoint
    to be hit when an exception is hit. This type of breakpoint is known as **exception
    breakpoint**. The question that comes to mind is "what is the reason for this
    name?" This breakpoint gets activated on encountering an exception.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您的大脑需要吸收新的信息。直到这个时间点，您都认为只有在怀疑某些代码行可能有问题时，才能手动创建断点。但实际上，您可以在遇到异常时创建一个断点。这种类型的断点被称为**异常断点**。您可能会想，“为什么会有这个名字？”这个断点在遇到异常时被激活。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a new exception breakpoint, you just need to remember a few small
    steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的异常断点，您只需记住几个小步骤：
- en: Inside the editor, press *Ctrl* + *Shift* + *F8*, where there will be a pop
    up.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器内部，按*Ctrl* + *Shift* + *F8*，那里将弹出一个窗口。
- en: In the left-hand top corner, there is the **+** sign, press it and you will
    get an option to create an exception breakpoint.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左上角，有一个**+**号，按它，您将获得创建异常断点的选项。
- en: On proceeding, you will be asked to enter the name of the exception at which
    you want the execution to halt.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，您将被要求输入希望执行停止的异常名称。
- en: You can also make a customization in the way the breakpoint will behave. You
    can ask PhpStorm to activate this breakpoint when an unexpected (or uncaught)
    exception is thrown in the code, as shown in the following screenshot. This is
    particularly helpful for a wise programmer since most of the expected exceptions
    will have already been covered in the code. All the other rules that were applicable
    on a general breakpoint are applicable on the exception breakpoint except for
    this one difference.![How to do it...](img/3878OT_05_05.jpg)
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以自定义断点行为的方式。您可以要求PhpStorm在代码中抛出意外（或未捕获）异常时激活此断点，如下面的截图所示。这对于明智的程序员来说特别有帮助，因为大多数预期的异常已经包含在代码中。除了这个不同之处外，适用于一般断点的所有其他规则也适用于异常断点。![如何操作...](img/3878OT_05_05.jpg)
- en: Note
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You cannot disable an exception breakpoint once it is hit. In other words, you
    cannot make a temporary exception breakpoint.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦触发，您就不能禁用异常断点。换句话说，您不能创建一个临时的异常断点。
- en: If you want the exception breakpoint to be activated upon some condition, you
    can leave the exception disabled until either another exception occurs or another
    breakpoint is hit. PhpStorm provides you with the options to choose from a list
    of breakpoints for the purpose.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您希望异常断点在某些条件下被激活，您可以暂时禁用异常，直到另一个异常发生或另一个断点被触发。PhpStorm为您提供了从断点列表中选择选项的功能。
- en: Tip
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To avoid laboring hard in making the decision as to which exception to choose,
    you can select the exception to be the `Exception` class. This can prove handy
    because all the exception classes ultimately inherit this `Exception` class.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了避免在决定选择哪个异常时费尽心思，您可以选择将异常设置为`Exception`类。这可能会很有用，因为所有异常类最终都继承了这个`Exception`类。
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The execution continues in the normal way—if you have set breakpoints, there
    will be pauses as there used to be. But now, the execution will pause on an exception
    as well. Thus, this exception breakpoint is an invisible breakpoint that will
    not be visible to you, but internally it will be active. Being a breakpoint, it
    will continue working as a breakpoint.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 执行将继续以正常方式进行——如果您设置了断点，将会有暂停，就像以前一样。但现在，执行将在异常发生时暂停。因此，这个异常断点是一个不可见的断点，您将看不到它，但内部它将是活跃的。作为一个断点，它将继续像断点一样工作。
- en: Stepping through your code
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐步执行您的代码
- en: 'Life teaches new lessons at every moment. For all of you who found the phrase
    *stepping through code* new, this is a process wherein you do an analysis of the
    values of variables, the control structures, and the method call hierarchy. The
    process includes three types of stepping:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 生活时刻都在教导我们新的课程。对于所有那些发现短语“逐步执行代码”是新的你们来说，这是一个分析变量值、控制结构和方法调用层次的过程。这个过程包括三种类型的逐步执行：
- en: '**Step Into**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进入**'
- en: '**Step Over**'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跳过**'
- en: '**Step Out**'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跳出**'
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Do you need to step through code at all? Yes, of course. When? When you have
    to find out what the eyesore in the code is. You have to step into the code when
    you need to know the next line in the entire program. You have to step over code
    when you need to know the next executed line in the entire program. You have to
    step out of code when you need to know the next line after the method selected.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你真的需要逐步执行代码吗？当然需要。什么时候？当你需要找出代码中的瑕疵时。当你需要知道整个程序中的下一行时，你必须进入代码。当你需要知道整个程序中的下一行将要执行时，你必须跳过代码。当你需要知道所选方法之后的下一行时，你必须从代码中退出。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In order to step through code, you just need to be in a debugging session.
    The rest is just a click away or just a matter of a keyboard shortcut. Perform
    the following steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了逐步执行代码，你只需处于调试会话中。其余的只是点击或键盘快捷键的事。执行以下步骤：
- en: Begin with stepping over the code. When your debug session is active, you need
    to press *F8* or select the button as shown in the following screenshot:![How
    to do it...](img/3878OT_05_06.jpg)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从逐步执行代码开始。当你的调试会话处于活动状态时，你需要按*F8*或选择以下截图所示的按钮：![如何操作...](img/3878OT_05_06.jpg)
- en: In order to step into the code, you just need to press *F7* or select the button
    as shown in the following screenshot:![How to do it...](img/3878OT_05_07.jpg)
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进入代码，你只需按*F7*或选择以下截图所示的按钮：![如何操作...](img/3878OT_05_07.jpg)
- en: In order to step out of the code, you need to use the keyboard combination *Shift*
    + *F8* or select the button as shown in the following screenshot:![How to do it...](img/3878OT_05_08.jpg)
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了从代码中退出，你需要使用键盘组合*Shift* + *F8*或选择以下截图所示的按钮：![如何操作...](img/3878OT_05_08.jpg)
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once you have used any of the stepping-through methods, you will obviously wish
    to know what goes on behind the scenes. A very high level of explanation will
    tell you that when you step into the code, the debugger takes you to the next
    line in the program. Once you are on the next line in the code, you can do a lot
    of inspection in that particular line of code, such as the contents of the variables.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用了任何逐步执行的方法，你显然会想知道幕后发生了什么。一个非常高级的解释会告诉你，当你进入代码时，调试器会带你到程序中的下一行。一旦你在代码的下一行，你可以在该代码行上执行很多检查，例如变量的内容。
- en: Once you step into the code, the debugger actually shows you the immediate next
    line executed in the same program file or another program file. Once shown, you
    can again do lots of inspections in that particular line of code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你进入代码，调试器实际上会显示在同一程序文件或另一个程序文件中立即执行的下一行。一旦显示，你可以在该代码行上再次执行很多检查。
- en: Once you step out of the code, the debugger shows you the immediate next line
    that will be executed after the current method is executed. If the debugger is
    unable to find any such line, the execution will be finished in the usual way,
    as it should have been without a debugger.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你从代码中退出，调试器会显示在当前方法执行之后将立即执行的下一行。如果调试器无法找到这样的行，执行将以通常的方式完成，就像没有调试器一样。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You must have a debugging session before you try the shortcut keys such as *F8*,
    *F7*, and *Shift* + *F8*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试*F8*、*F7*和*Shift* + *F8*等快捷键之前，你必须有一个调试会话。
- en: Running to a line of code selected
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳转到选定的代码行
- en: If you want no breakpoints in your code, but you still want the debugger to
    break at some point in your code, you are at the correct recipe and reading the
    correct text. This is also true when the breakpoint you set is already executed
    or stepped over, but you still suspect another line to be buggy.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在代码中设置断点，但仍然希望调试器在代码的某个点中断，你找到了正确的配方，正在阅读正确的文本。这也适用于你设置的断点已经执行或跳过，但你仍然怀疑另一行有错误。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To tell PhpStorm to ask the debugger to break at some arbitrary point of your
    choice, you should exercise the **Run to Caret** option. As a prerequisite, you
    have to place the cursor at some line of code in your program. Having done that,
    you have to now go to **Run** | **Run to Cursor**, and PhpStorm will obediently
    (and politely) ask Xdebug to pause at the location where your cursor has been
    placed. This is just the same behavior it would have exhibited in the case of
    a regular breakpoint.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要让 PhpStorm 告诉调试器在某个你选择的任意点中断，你应该使用 **运行到光标处** 选项。作为先决条件，你必须将光标放在程序中的某一行代码上。完成这个步骤后，你现在需要转到
    **运行** | **运行到光标处**，PhpStorm 将会顺从地（并且礼貌地）请求 Xdebug 在光标所在的位置暂停。这和常规断点的情况是一样的行为。
- en: 'There are three cases to be covered:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有三种情况需要考虑：
- en: One is when you have just started debugging your code; the execution will pause
    on the line you have specified.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种情况是你刚开始调试代码；执行将在你指定的行上暂停。
- en: Another is when you specified a breakpoint in your code, and the debugger has
    proceeded ahead of that breakpoint (obviously after pausing there), the debugger
    will again stop at the line you specified.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个情况是当你已经在代码中指定了一个断点，并且调试器已经超过该断点（显然是在暂停之后），调试器将再次在指定的行上停止。
- en: The third case is when you specify a line that will not be executed at all—if
    you have capsicum, you will not add tomato. In this case, the execution will continue
    past that line and move ahead to the next breakpoint or finish altogether.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种情况是当你指定了一行根本不会执行的代码——如果你有辣椒，你不会加番茄。在这种情况下，执行将继续到那一行之后，并移动到下一个断点或完全结束。
- en: '![How to do it...](img/3878OT_05_09.jpg)'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/3878OT_05_09.jpg)'
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The working of the magic is quite simple to understand. Just as there were temporary
    breakpoints that disappeared once hit, this **Run to Caret** option functions
    in the same way. Thus, the line of code you place the cursor on becomes a temporary
    breakpoint, with the additional feature of being invisible. Thus, as soon as the
    breakpoint is hit once, it is automatically removed invisibly. If there is a line
    that will never be executed, the debugger simply ignores this location in the
    code and proceeds ahead.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法的运作原理非常简单易懂。就像临时断点一旦触发就会消失一样，这个 **运行到光标处** 选项也是以同样的方式工作的。因此，你放置光标的代码行变成一个临时断点，具有额外的不可见特性。因此，一旦断点被触发一次，它就会自动无痕地移除。如果有一行永远不会被执行，调试器将简单地忽略代码中的这个位置并继续前进。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The keyboard shortcuts increase your speed. Use *Alt* + *F9* to be fast.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘快捷键可以提升你的速度。使用 *Alt* + *F9* 来快速操作。
- en: Watching expressions and variables
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察表达式和变量
- en: The most important utility of a debugger is that it actually provides you with
    X-Ray goggles with which you can see through opaque objects.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器的最重要的功能是它实际上为你提供了X光眼镜，让你可以看穿不透明物体。
- en: This phenomenon of *see-ing* through the opaque object (call it execution) is
    known as **watching**. It is synonymous with real-world watching. Do you watch
    something? You constantly pay attention to what is happening around that something
    to watch it. Daddy says, "I will see you son," and across the globe irrespective
    of the location, the problem of the son getting worried arises. But is the PhpStorm
    watching feature expected to worry you?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这种看穿不透明物体（称为执行）的现象被称为 **监视**。它与现实世界的监视是同义的。你监视某物吗？你不断地关注你所监视的周围发生的事情。爸爸说，“我会看到你，儿子”，无论地点如何，儿子担忧的问题就会出现。但是，PhpStorm
    的监视功能会让你担忧吗？
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'If you are determined to watch the whereabouts and howabouts of a variable,
    you can ask PhpStorm to do that for you. When you start debugging, in the debug
    window, there are three frames: **Frames**, **Variables**, and **Watches** open
    by default. To add variables to the watch feature, there are two methods:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决心要观察一个变量的位置和活动情况，你可以让 PhpStorm 帮你完成。当你开始调试时，在调试窗口中，默认打开三个框架：**框架**、**变量**和**监视**。要将变量添加到监视功能中，有两种方法：
- en: If that variable appears in the list of variables covered up to that point,
    you can select the variable, access the right-click context menu, select the **Add
    to Watch** option from the list. You will see that the watches section will have
    an added variable as this one.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果那个变量出现在到那个点为止被覆盖的变量列表中，你可以选择该变量，访问右键点击的上下文菜单，从列表中选择 **添加到监视** 选项。你会看到监视部分将添加一个变量，就像这个一样。
- en: If that variable does not appear in the list of variables, you do not need to
    worry. If you remember the name of the variable you suspect, you can add it directly
    to the list of variables under watch (in the **Watches** window) by selecting
    the **+** sign and adding the exact name of the variable in the textbox that appears,
    as shown in the following screenshot:![How to do it...](img/3878OT_05_10.jpg)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果该变量未出现在变量列表中，您无需担心。如果您记得您怀疑的变量名，您可以直接在监视变量列表（在**监视**窗口中）下添加它，通过选择**+**符号并在出现的文本框中输入变量的确切名称，如图所示：![如何操作...](img/3878OT_05_10.jpg)
- en: PhpStorm also enables you to add expressions under watch in just the same way
    as it does for a variable. All you need to do is to write an expression in just
    the same way as you would have written inside the editor. PhpStorm will take care
    of the rest.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: PhpStorm还允许您以与变量相同的方式添加监视表达式。您只需像在编辑器内部编写一样编写一个表达式即可。PhpStorm会处理其余部分。
- en: How it works...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When a variable is put under watch, PhpStorm simply outputs the contents to
    the console, which happens to be a watch window. Thus, a variable put under watch
    is made to be visible at all times during the execution (debugging) of the program.
    If the variable value changes, the change is reflected immediately in the watch
    window. If the variable has gone out of scope during the execution, the content
    of the variable becomes **Cannot evaluate expression**. So it might appear to
    you that the content is not available, even though the content is actually available.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量被置于监视之下时，PhpStorm会简单地将其内容输出到控制台，这恰好是一个监视窗口。因此，被监视的变量在程序执行（调试）的整个过程中始终保持可见。如果变量值发生变化，变化将立即反映在监视窗口中。如果在执行过程中变量超出了作用域，变量的内容将变为**无法评估表达式**。因此，您可能会觉得内容不可用，尽管实际上内容是可用的。
- en: The same is true for an expression as well. The IDE treats it as normal content
    and attempts to show the value at all times. Just as it used to happen in the
    case of a normal variable under watch, the expression evaluates to **Cannot evaluate
    expression** if the expression contains a variable that is not covered in the
    current scope.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表达式也是如此。IDE将其视为正常内容，并尝试始终显示其值。就像在监视正常变量的情况下发生的那样，如果表达式包含当前作用域中未覆盖的变量，表达式将评估为**无法评估表达式**。
- en: Tip
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Please do remember to use the *exact* name of the variable.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必记住使用变量的*确切*名称。
- en: Changing code on the fly
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 飞行中更改代码
- en: According to no survey, it has been established that most of the bugs in programming
    arise due to uncertainty in the type and value of data. The real utility of a
    debugger is apparent when you have the freedom to interfere with the data that
    is generated during the execution. Thus, you can actually change the value of
    variables that the interpreter has covered while you are fighting against bugs
    in your code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 根据没有调查，已经确定大多数编程错误是由于数据类型和值的不确定性引起的。调试器的真正效用在于您在执行过程中可以自由地干预生成的数据。因此，您实际上可以更改解释器在您与代码中的错误作斗争时覆盖的变量的值。
- en: This can be particularly useful in cases where you have to set the width of
    a text container, and you cannot be sure about the maximum width of the text container.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这在您必须设置文本容器的宽度，但又无法确定文本容器的最大宽度的情况下尤其有用。
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The **Debug** view is your friend in this scenario. Focus on the `Variables`
    frame.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此场景中，**调试**视图是您的朋友。关注**变量**框架。
- en: To assign a value to a variable, select it from the list of variables available.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要给变量赋值，从可用的变量列表中选择它。
- en: Access the right-click context menu. Select the **Set Value** option, and in
    the textbox that appears, provide some value. You are done immediately after pressing
    the return key.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问右键单击上下文菜单。选择**设置值**选项，并在出现的文本框中提供一些值。按下回车键后，您立即完成。
- en: From now onwards, wherever this variable is accessed, it will assume this particular
    value. The keyboard shortcut to do this is provided by PhpStorm as *F2*.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从现在开始，无论何时访问这个变量，它都将假定这个特定的值。执行此操作的快捷键由PhpStorm提供，即*F2*。
- en: How it works...
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By now, you must have easily guessed that the debugger sits between your code
    and the interpreter. Thus, when you assign a value to a variable, the debugger
    *cheats* the interpreter by passing on the changed value as the original value.
    The interpreter, a poor blind creature, gets into this gotcha by assuming that
    the value is the one specified in the code and proceeds ahead using this value.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您肯定已经轻松猜到调试器位于您的代码和解释器之间。因此，当您给一个变量赋值时，调试器通过传递更改后的值作为原始值来“欺骗”解释器。解释器，一个可怜的盲生物，通过假设值是代码中指定的值，并使用这个值继续前进，而陷入了这种困境。
- en: The world is not being trusted at all!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 世界根本不被信任！
- en: Note
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you assign some value to a variable, it is not that the value will be fixed
    irrespective of the business logic. As soon as a condition where the variable
    will change its value is met, the change will occur normally as it would have
    occurred in the absence of the debugger.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当您给一个变量赋值时，并不意味着值将固定，而不考虑业务逻辑。一旦满足变量将更改其值的条件，变化就会像没有调试器时一样正常发生。
- en: Code coverage in PhpStorm
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PhpStorm中的代码覆盖率
- en: Having set the platform to write clean code and to remove bugs from code to
    make good software, you must be thinking that your task is done, and you can now
    sit back and relax.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在将平台设置为编写干净代码并从代码中移除错误以制作好软件之后，您肯定在想，您的任务已经完成，现在您可以坐下来放松了。
- en: Not now! There's much more to do. Since you have promised that you will not
    tire and that you will not falter, you should have the fire burning within to
    proceed. This time, you are going to proceed with code coverage. Yes you read
    it right, code coverage.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在还不是时候！还有更多的事情要做。既然您承诺您不会感到疲倦，您不会失败，您内心必须燃烧着继续前进的火焰。这次，您将进行代码覆盖率。是的，您没有看错，代码覆盖率。
- en: This is the right time to get informed about this phenomenon now that you have
    working knowledge about a testing system (**PHPUnit**) and a debugging system
    (**Xdebug**). Code coverage is a phenomenon that is brought about by the combined
    functionality provided by PHPUnit and Xdebug. This means that you have to have
    both the systems installed on your development machine if you really want code
    coverage.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对测试系统（**PHPUnit**）和调试系统（**Xdebug**）有了实际的知识，这是了解这种现象的合适时机。代码覆盖率是由PHPUnit和Xdebug提供的联合功能带来的现象。这意味着，如果您真的想要代码覆盖率，您必须在您的开发机器上安装这两个系统。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To solve matters such as these, there comes code coverage. No, no, don't think
    that code coverage will remove the unused lines—it will be *you* who will remove
    them. Coverage will let you know from where to remove the unused lines. Thus,
    code coverage is a phenomenon by which you check which lines of code are covered
    in the execution and which lines are not. Questions are firing inside you—what
    is the role of PhpStorm in this then? When you do code coverage, you get a visual
    indication as to which lines are not covered. It is this PhpStorm feature that
    takes care of managing this visual indication to you.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些事情，出现了代码覆盖率。不，不，不要认为代码覆盖率会移除未使用的行——将是你移除它们。覆盖率会告诉你从哪里移除未使用的行。因此，代码覆盖率是一种检查在执行过程中哪些代码行被覆盖，哪些代码行没有被覆盖的现象。您内心充满了疑问——那么PhpStorm在这个问题中扮演什么角色呢？当您进行代码覆盖率时，您会得到一个视觉指示，告诉您哪些行没有被覆盖。正是这个PhpStorm功能负责管理这种视觉指示给您。
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Covering a PHP code again requires some PHP code. You have to code everything
    in this world! The simplest way to code is to write tests for a target class.
    The framework (PHPUnit) will try to cover the entire class. In this case, you
    have to do nothing new while writing the code, for the change occurs when you
    try to run the test.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 再次覆盖PHP代码需要一些PHP代码。您必须编写世界上的一切！编写测试的简单方法是为目标类编写测试。框架（PHPUnit）将尝试覆盖整个类。在这种情况下，您在编写代码时不需要做任何新的工作，因为变化发生在您尝试运行测试时。
- en: 'There is an option available in PhpStorm which lets you run a test with coverage.
    To do that, you will need to perform the following steps:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: PhpStorm中有一个选项可以让您运行带有覆盖率测试。为此，您需要执行以下步骤：
- en: You need to select the test file and go to **Run | Run** `<test>` **with Coverage**,
    as shown in the following screenshot.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要选择测试文件并转到**运行 | 运行** `<test>` **带有覆盖率**，如图下所示截图。
- en: The target file will be tested in the usual way, and the coverage for the entire
    file will also be taken care of.![How to do it...](img/3878OT_05_11.jpg)
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标文件将以常规方式测试，并且整个文件的覆盖率也将得到处理。![如何操作...](img/3878OT_05_11.jpg)
- en: However, suppose you want to cover a selected part of the code or a method,
    you can do that too. There is an annotation provided in PHPUnit with the name
    covers. Using this annotation, you can tell the PHP interpreter that you want
    to cover only a selected part of the target class.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，假设你想覆盖代码的一部分或一个方法，你也可以做到。PHPUnit提供了一个名为`covers`的注释。使用这个注释，你可以告诉PHP解释器你只想覆盖目标类中的选定部分。
- en: 'Thus, if you just want to test the `getDishName` method inside the (target)
    `PizzaDish` class, you can use something like the following code just before the
    `testGetDishName` method declaration in the `PizzaDishTest` class:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，如果你只想测试(target) `PizzaDish`类中的`getDishName`方法，你可以在`PizzaDishTest`类中`testGetDishName`方法声明之前使用如下代码：
- en: '[PRE5]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There will be instances in your programming life when you will not want to
    do anything interesting. You will just bother testing code and not covering any
    code—you will just want to test. You have an option. There is an annotation available
    with the name `coversNothing`. This is a way to tell the PHPUnit framework "Ok
    mate, you will only do testing for me. Don''t waste time in covering the code."
    Thus, you can write something like the following code:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编程生涯中，会有一些时候你不想做任何有趣的事情。你只是想测试代码，而不覆盖任何代码——你只想测试。你有选择。有一个名为`coversNothing`的注释可用。这是告诉PHPUnit框架“好的，伙计，你只会为我进行测试。不要浪费时间在覆盖代码上。”的一种方式。因此，你可以编写如下代码：
- en: '[PRE6]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Having used the annotations, you successfully maneuvered the functioning of
    code coverage. Congratulations!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用了注释后，你成功操作了代码覆盖率的功能。恭喜你！
- en: How it works...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: The annotations are special features in PHP that provide some information to
    the interpreter to do some work silently. So, when you write `@covers <Classname>::<Method-name>`,
    you are telling the interpreter to cover certain code in a target class. Similarly,
    when you write `@coversNothing`, the interpreter understands that it does not
    have to do coverage.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是PHP中的特殊功能，为解释器提供一些信息以执行某些工作而不发出声音。因此，当你写下`@covers <Classname>::<Method-name>`时，你是在告诉解释器覆盖目标类中的某些代码。同样，当你写下`@coversNothing`时，解释器理解它不需要进行覆盖率。
- en: Thus, PhpStorm provides you a visual indication by coloring regions in your
    code with certain colors denoting coverage and miss. When you run the test with
    coverage, there is a coverage view in the right-hand bottom corner of the editor
    window, which is shown in the following screenshot. You can view the statistics
    for the code that has just been tested (for coverage as well).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，PhpStorm通过用特定颜色给你的代码区域着色来提供视觉指示，表示覆盖率和不覆盖。当你运行带有覆盖率的测试时，编辑器窗口的右下角会显示覆盖率视图，如下面的截图所示。你可以查看刚刚测试过的代码的统计数据（包括覆盖率）。
- en: '![How it works...](img/3878OT_05_12.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3878OT_05_12.jpg)'
- en: You get visual indications as well. It is shown in the editor window of the
    target class (here `PizzaDish.php`, as shown in the following screenshot) the
    area with red color is uncovered.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会得到视觉指示。它显示在目标类的编辑器窗口中（这里为`PizzaDish.php`，如下面的截图所示），红色区域表示未覆盖。
- en: '![How it works...](img/3878OT_05_13.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/3878OT_05_13.jpg)'
- en: There's more…
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: Now we have learned code coverage in PhpStorm, it is time to see the purpose
    of code coverage.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了PhpStorm中的代码覆盖率，是时候看看代码覆盖率的目的了。
- en: Purpose of code coverage
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码覆盖率的目的
- en: 'Again, there''s that same question in your mind: why do I need code coverage
    at all? The answer is not so obvious but is worth knowing about. You agreed that
    there were bugs in the code, so you used some debugging tool to find out and remove
    those bugs. You agreed that the algorithm you implemented went away at times,
    so you tested it and fixed it. But did you ever get a feeling that there might
    be unused lines in the code you have written? There might be lines that the interpreter
    will be unable to process, and there might be lines inside some conditions that
    are *never* met. Who will take into account these and many other such cases? Another
    question that will come to your mind is "what is the harm in having an extra line
    of code when you can have lines of comment in the code?" The answer is here.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你心中可能又出现了同样的疑问：我为什么需要代码覆盖率呢？答案并不明显，但了解这一点是很有价值的。你同意代码中存在错误，所以你使用了某些调试工具来找出并移除这些错误。你同意你实现的算法有时会失效，所以你对其进行了测试并修复了它。但你是否曾有过一种感觉，认为你编写的代码中可能存在未使用的行？可能存在一些解释器无法处理的行，也可能存在一些在某个条件下永远不会被满足的行。谁会考虑到这些以及其他许多类似的情况呢？另一个可能会出现在你脑海中的问题是：“当你可以在代码中添加注释行时，多一行代码有什么危害？”答案就在这里。
- en: A comment is something that the interpreter does not bother about, but an active
    but unused line is something that it bothers about. It is just like moving around
    in your kitchen with a pistol tied around your waist after you have come back
    from a shooting session. Would you need a pistol inside your kitchen? Why are
    you carrying it with you then?
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是解释器不会关心的事情，但一个活跃但未使用的行是解释器会关心的事情。这就像你在射击结束后，腰间绑着一把手枪在厨房里走来走去。你需要在厨房里放一把手枪吗？为什么你要随身携带它呢？
