- en: Chapter 5. Testing and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing PHPUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test case in PHPUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing an application with PHPUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting a debugging session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a breakpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring breakpoint conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating exception breakpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stepping through your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running to a line of code selected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watching expressions and variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing code on the fly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code coverage in PhpStorm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you create a new software, there is a business dependency inherent
    on that. Obviously, if your software were not sold, you would probably have opted
    for some other profession. Due to the business factor, you are always expected
    to make your software reliable. This can be done only after your software has
    passed testing. It is not that you, the programmers, will do the entire testing
    and kick the tester out. You will be required to do the unit testing while actually
    writing the code. If you unit test your code, the chances of failure decrease
    drastically. The unit testing should ideally be done while creating code, and
    an ideal timeline to unit test is as soon as some milestone functionality has
    been created.
  prefs: []
  type: TYPE_NORMAL
- en: To act wisely and do (unit) testing, use PHPUnit. **PHPUnit** is a system (application)
    written in your favorite PHP. It lets you write test cases for the code you write
    so that you can keep on checking for any error that might creep into your logic.
    Thus, by the time you use a build tool to create something like a phar or any
    other archive, you have already ensured that the first level of filtration has
    been applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is obvious for you to ask the purpose of PHPUnit then. The answer to this
    is simple: you need PHPUnit to prevent errors from passing on to the integration
    testing phase. But what if there were some errors or functionality that could
    not be detected at the unit-testing phase? What if there were errors due to another
    component or module passing on erroneous data?'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of applying the same rule to change the tense of a person's existence,
    you are again advised to act wisely. Use a debugger. Most of the IDEs show debugger
    with a bug icon next to it, so you would not find it difficult to find it in PhpStorm.
    PhpStorm provides you with options to select a debugger and integrate it for usage.
  prefs: []
  type: TYPE_NORMAL
- en: Using a debugger, you can do wonders. You actually gain fine-grained control
    over your code. You gain the power to walk across walls and see through iron plates!
    Will you stop dreaming about being a superpower, please. You are still a software
    engineer? A debugger gives you the power to look into the value of any variable
    in your code and the return value of a method, to pause the execution at will
    and resume it at will, and the list is endless.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the deep sea of knowledge, it is important to know the difference
    between testing and debugging. **Testing** is a process that is likely to be done
    during the development phase, just after some business logic has been developed
    and it needs to be cleaned and sanitized properly before being released into production.
    **Debugging** is the process of removal of bugs from the code. A bug is that unwanted
    (improper) functionality that has passed the testing phase and has been discovered
    in the later testing phases or even in the production phase. Actually, both are
    similar because the aim of both is just to clean the product and functional software
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PHPUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The discussion starts with testing because it precedes debugging in the software
    development life cycle. PHP provides a unit-testing system, which is known as
    PHPUnit.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you use PHPUnit, you gain the freedom to write some code and to check some
    code. Yes, you read it right. You can use PHPUnit to write some program that will
    check the input and output of some other program. Interesting phenomenon, right?
  prefs: []
  type: TYPE_NORMAL
- en: When you can write an application (PHP code) using an application (PhpStorm),
    why not test the application (PHP code) with an application (PHPUnit test cases)?
    Since PHPUnit is just an application written in PHP, it is available in the form
    of a **PHP Archive** (**PHAR**). It is just a method to ship your files and folders
    as a whole and to make it ready to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please make sure that you have PHP interpreter installed before installing PHPUnit.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can install it very easily by just downloading the PHPUnit archive (the
    `phar` file) and setting the `/path/to/phpunit.phar` in the list of include paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'You just need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the **Project** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access the right-click context menu on the **External Libraries** directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Configure PHP includes path** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can also do that quickly by selecting the **External Libraries** directory,
    pressing *F4*, and pointing to the correct `phpunit.phar` file, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3878OT_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since you have installed PHPUnit as a package (PHAR), the testing system swings
    into action as soon as you inherit (or extend) a class defined inside the directory
    `phpunit-lts.phar` under the `phpunit` directory and the framework subdirectory
    with the name `PHPUnit_Framework_TestCase`.
  prefs: []
  type: TYPE_NORMAL
- en: Test case in PHPUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having installed PHPUnit successfully, your challenge is not over yet—it has
    just led to another array of challenges. Testing is no easy task, but it is interesting.
    Just as you love writing beautiful PHP code, you will love writing test cases
    in PHPUnit because it is just like writing PHP code while taking care of some
    conventions.
  prefs: []
  type: TYPE_NORMAL
- en: A **test case** is a piece of an application that is written specifically to
    check (or test) for certain conditions in another application. Thus, when you
    write down a test case, you actually write a PHP code to test if something has
    gone wrong in other PHP code (which happens to be the code you have written to
    meet the business requirements).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, it is quite important to state that you, the programmer, usually have
    the following point of view:'
  prefs: []
  type: TYPE_NORMAL
- en: You think that since you know your code very well you know that your code is
    errorless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if there are some errors in your code, since you know the code deeply,
    you can fix it in a flash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You think that the time you waste in writing test cases can be better utilized
    in writing more code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These (and many such) points are incorrect. You need to write test cases.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new test case, you need to create a new PHPUnit class. Thus, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the **Project** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the file you want to test. This file should be a valid PHP class. Obvious
    statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the right-click context menu, select **New** | **PHPUnit** | **PHPUnit
    Test**, as shown in the following screenshot:![How to do it...](img/3878OT_05_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the name and the related details just as you would do to create a new
    PHP class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The test cases that you create will be PHP methods with the public access specifier
    inside this class.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see how a test case works, you need to follow some conventions. The reason
    is that, since a test case is a PHP code, it has to have some functionality inherent
    in it. The conventions are listed for quick reference:'
  prefs: []
  type: TYPE_NORMAL
- en: The test class should have the same name as the target class. Thus, you will
    create `XXXTest` inside the file `XXXTest.php` given that the name of the class
    to be tested is `XXX`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All test classes should extend (inherit) the `PHPUnit_Framework_TestCase` class.
    This class is made available to you when you include the PHAR in your PhpStorm
    project (as we saw in the *Installing PHPUnit* recipe of this chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, your class `XXXTest` will have the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The exact method to be tested inside the test class should have its name starting
    with `test` followed by the name of the method to be tested.
  prefs: []
  type: TYPE_NORMAL
- en: It is not that your test will fail just due to this reason, but it is a standard
    naming practice.
  prefs: []
  type: TYPE_NORMAL
- en: There is also no constraint on you to map one-to-one test methods to one single
    target method. Again, it is just a good practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, given that the name of the method to be tested is `YYY`, a test inside
    your test class will have the declaration (definition) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As per the convention, you should write one test inside one method only. It
    leads to better organization of code and makes it easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual testing is done by asserting some facts. The facts are the output
    of the methods you will be testing. Thus, if some method returns a string, you
    can check if the method return type is `string` by writing the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A test class should have the common content inside a `setUp` method. This is
    particularly helpful in cases in which you need to have a chunk of code shared
    across all the test methods in this class. It is your call whether to use it or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of a test method being called, you might not need to have the resources
    at hand. You might want to remove it from memory.
  prefs: []
  type: TYPE_NORMAL
- en: Here, it is quite important to remember that you should always design your tests
    wisely. You should always prevent unwanted memory usage in your test because once
    you do that, you will have to add another testing on this test class as well.
  prefs: []
  type: TYPE_NORMAL
- en: Having known the nuances of test cases, you are all set to test. This is a deliberate
    misuse of the letters of the alphabet to alert you!
  prefs: []
  type: TYPE_NORMAL
- en: Whatever you do, PhpStorm assists you. So, instead of waiting and thinking about
    what to do, get set, go!
  prefs: []
  type: TYPE_NORMAL
- en: Testing an application with PHPUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There must be a question hovering in your mind about the role of PhpStorm in
    this testing. It's time for action. Having sufficient knowledge of the conventions
    to write tests, you can proceed to face the real world of testing. The more you
    test, the purer your code will become. Testing is good. Testing is healthy. Testing
    is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Good question. This question is best answered with some diving back into time
    to get back the same pizza cooking use case. You have grown up listening to grandma''s
    advice to reuse objects. Now is the time for you to reuse. Perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reuse the `PizzaDish` class. You will create a test class somewhat like the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As promised, you can see that the PHPUnit is all about writing PHP classes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To execute this test, you need to execute (run) this class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running this class is extremely simple. *Ctrl* + *Shift* + *F10* is your savior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to run a single method, PhpStorm provides for that as well. You
    just need to place the cursor anywhere inside the body of the method you want
    to execute and issue the run command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If the cursor is not inside a method body, the entire test class will be executed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following screenshot shows the test result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3878OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to execute your unit test, PhpStorm makes some improvisations. Just
    as it does with every other library, it uses its own version of the execution
    script to execute the test. The full name of the file is `/tmp/ide-phpunit.php`.
    Thus, it is this file that accepts the name of the test class file you have written.
  prefs: []
  type: TYPE_NORMAL
- en: The working of the testing application is simple. As already stated, all classes
    that inherit `PHPUnit_Framework_TestCase` class become test classes. The `setUp`
    method instantiates an object of the target class `PizzaDish` and makes it available
    to the entire test class.
  prefs: []
  type: TYPE_NORMAL
- en: Inside your test class, the `testGetInstance` and `testGetDishName` methods
    get executed when you run the test. Inside the test method, a new object is instantiated
    to initiate the actual testing process. Up until this point, the activities that
    you did were the same as those for a PHP class. Inside the methods, there are
    certain assertions that do the actual testing. There are these special methods,
    namely, `assertInstanceOf` and `assertInternalType`, which are declared in the
    `Assert` class provided by the framework. You can view the documentation of the
    method by putting the cursor under the method name and pressing *Ctrl* + *Q*.
    These are the actual methods that perform the testing task by checking if the
    given assertion is true. Thus, the motive of the test class that you created is
    to check whether the desired class is instantiated or not and whether the name
    of the dish that you want to cook is of the type `string`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you run the test, you will be able to see the test results in the usual
    run view which is accessible by *Alt* + *4*.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a debugging session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"Now is the time for all programmers to start debugging their code"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Like most IDEs, PhpStorm also uses a bug icon to show the debugger. Just as
    a bug leeches your blood and doesn't let you concentrate on your main task, a
    software bug can leech precious CPU cycles and not allow your software to work
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent such bugs from entering the life cycle of software, you need to do
    debugging. Debugging is the process of diving deep into the code and finding out
    the potential areas that might be the problem causing regions in the code, so
    do extensive lookup to find and rectify the bugs.
  prefs: []
  type: TYPE_NORMAL
- en: The tools available for the purpose are termed debuggers in the industry. **Xdebug**
    is the name for one such tool. It is a very commonly used, free, and open source
    debugger that is available to be plugged in with most IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To plug it in, you need to install it on your development machine. Perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the source code from **GitHub**, the repository where Xdebug is hosted.
    You need to issue this command in your terminal `git clone git://github.com/xdebug/xdebug.git`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move into the directory where the code has been checked out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Issue the command `phpize`. There will be lots of text output to the console
    when you do this. Once the output finishes, you need to execute the configuration
    file, which happens to be an executable shell script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to enable `xdebug` using the switch `--enable-xdebug` while configuring.
    Thus, you should write `./configure --enable-xdebug`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When this has been done, you need to issue the command `make && make install`
    to complete the compilation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output of steps will be a module—precisely a shared object or a `.so` file
    that you need to specify in the PHP settings. Kindly note it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the appropriate `ini` file, you need to write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to know which `php.ini` file your PhpStorm uses, you need to go to
    **Tools** | **Run Command** and issue the command `php --ini`. You will be given
    a list of all the `.ini` files that are parsed. You now have the correct `.ini`
    file to make the changes in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: There is this shortcut as well, *Ctrl* + *Shift* + *X*, which opens the command-line
    tool console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Having installed a powerful debugger, you can proceed to making your code bug-free.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A debugging session is to be started only for a web-based PHP application.
    In order to be able to initiate the debugging for a web application, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to have, let's say for Chrome, an `xdebug` helper. It helps you to
    initiate a debugging session once you type in a URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You know that corresponding to a client, there should be a server so that when
    you attempt to initiate a debug session, there must have been a listener for the
    incoming connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, you need to start the listener for the incoming debug connection. To do
    that, you need to go to **Run** | **Start Listen to debug connections**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you initiate the session for the first time, PhpStorm shows an alert regarding
    some entry, as shown in the screenshot following the next information box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure that the checkbox is checked for **Can accept external connection**.
    This will be found in **Settings** | **PHP** | **Debug**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/3878OT_05_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you accept the connection, PhpStorm saves it. The saved servers can be
    viewed later under **File** | **Settings** | **PHP** | **Servers**. From this
    point onwards, the debugging process becomes the same for a web-based application
    and a command-line application. So the debugger will view whatever variables will
    be there in the code, and according to the breakpoints that you provide, it will
    pause, continue, step through, or step over the code, thus making it very easy
    for you to see what is going on inside the code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also visit [http://www.xdebug.org/wizard.php](http://www.xdebug.org/wizard.php)
    to know more about `xdebug` installation for your server.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a breakpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A breakpoint in a code is that point (or line of code) where you want the program
    execution to pause for a while. When you were cooking pizza and adding ingredients,
    suppose you wanted to know at any instant which ingredient was about to be added,
    you can set a breakpoint to actually make the interpreter pause at the line where
    the variable contained the name of the ingredient to be added. After a breakpoint
    is set, you can see which value a variable assumes under the variables frame in
    the debug window.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of breakpoints, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Permanent breakpoint**: A normal breakpoint is one which remains till eternity,
    until you manually remove it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Temporary breakpoint**: A temporary breakpoint, on the other hand, is a breakpoint
    that gets removed or disabled upon certain conditions, the most common being a
    hit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To set a normal breakpoint, you need to select a suspicious line of code by
    placing the cursor under it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Run** | **Toggle Line Breakpoint**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There will be a red circle created at the left-hand side panel to give you a
    visual indication that the line is a breakpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can do the same using the keyboard shortcut *Ctrl* + *F8*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A breakpoint allows you to view the state of the variables stack. So, when the
    interpreter halts at a breakpoint, you can view the contents of the variables
    involved in the program execution. If you have added some variables or expressions
    to *watch*, you can constantly view the content of the selected variable at all
    times as long as it remains in the current scope. At all other times during the
    execution, there is the message **Cannot evaluate expression** shown. The debugger
    provides instruction to the interpreter to pause the execution when a breakpoint
    is hit. Upon request, the debugger instructs the interpreter to write (output)
    messages to the console (and it appears to the human eye that PhpStorm has done
    it!)
  prefs: []
  type: TYPE_NORMAL
- en: Configuring breakpoint conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PhpStorm provides you ways to customize the breakpoints. So you have some more
    comfort to sit back and enjoy the debugging happening, while being sure that your
    task will be done in time.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you set a breakpoint, you can press *Ctrl* + *Shift* + *F8* to get a configuration
    panel. Using the panel, you can change the regular breakpoint to a temporary breakpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the checkbox next to the **Remove once hit** option. That breakpoint
    will only be existent till the breakpoint is hit once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can select **Log message to console** to output once this breakpoint gets
    hit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can create an expression to be evaluated once this breakpoint gets hit by
    selecting the **Log evaluated expression** checkbox. You can also keep this breakpoint
    dormant conditionally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can tell PhpStorm to activate this breakpoint to remain disabled until an
    exception of a particular type is thrown, as shown in the following screenshot:![How
    to do it...](img/3878OT_05_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again, there is no logical explanation as to how a breakpoint works. You need
    to follow the steps shown, and PhpStorm will do the trick for you. The working
    is more related to the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the pop up is still open, you can press *Ctrl* + *Shift* + *F8* to get
    a larger panel in which you can have a peek into the code as well, while still
    having the control panel open.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3878OT_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating exception breakpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is new information for your brain to absorb. Until this point in time,
    you assumed that a breakpoint can be created only manually when you suspected
    some line of code might be problematic. But you can actually create a breakpoint
    to be hit when an exception is hit. This type of breakpoint is known as **exception
    breakpoint**. The question that comes to mind is "what is the reason for this
    name?" This breakpoint gets activated on encountering an exception.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new exception breakpoint, you just need to remember a few small
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the editor, press *Ctrl* + *Shift* + *F8*, where there will be a pop
    up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the left-hand top corner, there is the **+** sign, press it and you will
    get an option to create an exception breakpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On proceeding, you will be asked to enter the name of the exception at which
    you want the execution to halt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also make a customization in the way the breakpoint will behave. You
    can ask PhpStorm to activate this breakpoint when an unexpected (or uncaught)
    exception is thrown in the code, as shown in the following screenshot. This is
    particularly helpful for a wise programmer since most of the expected exceptions
    will have already been covered in the code. All the other rules that were applicable
    on a general breakpoint are applicable on the exception breakpoint except for
    this one difference.![How to do it...](img/3878OT_05_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You cannot disable an exception breakpoint once it is hit. In other words, you
    cannot make a temporary exception breakpoint.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you want the exception breakpoint to be activated upon some condition, you
    can leave the exception disabled until either another exception occurs or another
    breakpoint is hit. PhpStorm provides you with the options to choose from a list
    of breakpoints for the purpose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: To avoid laboring hard in making the decision as to which exception to choose,
    you can select the exception to be the `Exception` class. This can prove handy
    because all the exception classes ultimately inherit this `Exception` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The execution continues in the normal way—if you have set breakpoints, there
    will be pauses as there used to be. But now, the execution will pause on an exception
    as well. Thus, this exception breakpoint is an invisible breakpoint that will
    not be visible to you, but internally it will be active. Being a breakpoint, it
    will continue working as a breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Stepping through your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Life teaches new lessons at every moment. For all of you who found the phrase
    *stepping through code* new, this is a process wherein you do an analysis of the
    values of variables, the control structures, and the method call hierarchy. The
    process includes three types of stepping:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step Into**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step Over**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step Out**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do you need to step through code at all? Yes, of course. When? When you have
    to find out what the eyesore in the code is. You have to step into the code when
    you need to know the next line in the entire program. You have to step over code
    when you need to know the next executed line in the entire program. You have to
    step out of code when you need to know the next line after the method selected.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to step through code, you just need to be in a debugging session.
    The rest is just a click away or just a matter of a keyboard shortcut. Perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Begin with stepping over the code. When your debug session is active, you need
    to press *F8* or select the button as shown in the following screenshot:![How
    to do it...](img/3878OT_05_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to step into the code, you just need to press *F7* or select the button
    as shown in the following screenshot:![How to do it...](img/3878OT_05_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to step out of the code, you need to use the keyboard combination *Shift*
    + *F8* or select the button as shown in the following screenshot:![How to do it...](img/3878OT_05_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have used any of the stepping-through methods, you will obviously wish
    to know what goes on behind the scenes. A very high level of explanation will
    tell you that when you step into the code, the debugger takes you to the next
    line in the program. Once you are on the next line in the code, you can do a lot
    of inspection in that particular line of code, such as the contents of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: Once you step into the code, the debugger actually shows you the immediate next
    line executed in the same program file or another program file. Once shown, you
    can again do lots of inspections in that particular line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Once you step out of the code, the debugger shows you the immediate next line
    that will be executed after the current method is executed. If the debugger is
    unable to find any such line, the execution will be finished in the usual way,
    as it should have been without a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You must have a debugging session before you try the shortcut keys such as *F8*,
    *F7*, and *Shift* + *F8*.
  prefs: []
  type: TYPE_NORMAL
- en: Running to a line of code selected
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want no breakpoints in your code, but you still want the debugger to
    break at some point in your code, you are at the correct recipe and reading the
    correct text. This is also true when the breakpoint you set is already executed
    or stepped over, but you still suspect another line to be buggy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To tell PhpStorm to ask the debugger to break at some arbitrary point of your
    choice, you should exercise the **Run to Caret** option. As a prerequisite, you
    have to place the cursor at some line of code in your program. Having done that,
    you have to now go to **Run** | **Run to Cursor**, and PhpStorm will obediently
    (and politely) ask Xdebug to pause at the location where your cursor has been
    placed. This is just the same behavior it would have exhibited in the case of
    a regular breakpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are three cases to be covered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One is when you have just started debugging your code; the execution will pause
    on the line you have specified.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another is when you specified a breakpoint in your code, and the debugger has
    proceeded ahead of that breakpoint (obviously after pausing there), the debugger
    will again stop at the line you specified.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The third case is when you specify a line that will not be executed at all—if
    you have capsicum, you will not add tomato. In this case, the execution will continue
    past that line and move ahead to the next breakpoint or finish altogether.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to do it...](img/3878OT_05_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The working of the magic is quite simple to understand. Just as there were temporary
    breakpoints that disappeared once hit, this **Run to Caret** option functions
    in the same way. Thus, the line of code you place the cursor on becomes a temporary
    breakpoint, with the additional feature of being invisible. Thus, as soon as the
    breakpoint is hit once, it is automatically removed invisibly. If there is a line
    that will never be executed, the debugger simply ignores this location in the
    code and proceeds ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The keyboard shortcuts increase your speed. Use *Alt* + *F9* to be fast.
  prefs: []
  type: TYPE_NORMAL
- en: Watching expressions and variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important utility of a debugger is that it actually provides you with
    X-Ray goggles with which you can see through opaque objects.
  prefs: []
  type: TYPE_NORMAL
- en: This phenomenon of *see-ing* through the opaque object (call it execution) is
    known as **watching**. It is synonymous with real-world watching. Do you watch
    something? You constantly pay attention to what is happening around that something
    to watch it. Daddy says, "I will see you son," and across the globe irrespective
    of the location, the problem of the son getting worried arises. But is the PhpStorm
    watching feature expected to worry you?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are determined to watch the whereabouts and howabouts of a variable,
    you can ask PhpStorm to do that for you. When you start debugging, in the debug
    window, there are three frames: **Frames**, **Variables**, and **Watches** open
    by default. To add variables to the watch feature, there are two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: If that variable appears in the list of variables covered up to that point,
    you can select the variable, access the right-click context menu, select the **Add
    to Watch** option from the list. You will see that the watches section will have
    an added variable as this one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If that variable does not appear in the list of variables, you do not need to
    worry. If you remember the name of the variable you suspect, you can add it directly
    to the list of variables under watch (in the **Watches** window) by selecting
    the **+** sign and adding the exact name of the variable in the textbox that appears,
    as shown in the following screenshot:![How to do it...](img/3878OT_05_10.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PhpStorm also enables you to add expressions under watch in just the same way
    as it does for a variable. All you need to do is to write an expression in just
    the same way as you would have written inside the editor. PhpStorm will take care
    of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a variable is put under watch, PhpStorm simply outputs the contents to
    the console, which happens to be a watch window. Thus, a variable put under watch
    is made to be visible at all times during the execution (debugging) of the program.
    If the variable value changes, the change is reflected immediately in the watch
    window. If the variable has gone out of scope during the execution, the content
    of the variable becomes **Cannot evaluate expression**. So it might appear to
    you that the content is not available, even though the content is actually available.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true for an expression as well. The IDE treats it as normal content
    and attempts to show the value at all times. Just as it used to happen in the
    case of a normal variable under watch, the expression evaluates to **Cannot evaluate
    expression** if the expression contains a variable that is not covered in the
    current scope.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please do remember to use the *exact* name of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Changing code on the fly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to no survey, it has been established that most of the bugs in programming
    arise due to uncertainty in the type and value of data. The real utility of a
    debugger is apparent when you have the freedom to interfere with the data that
    is generated during the execution. Thus, you can actually change the value of
    variables that the interpreter has covered while you are fighting against bugs
    in your code.
  prefs: []
  type: TYPE_NORMAL
- en: This can be particularly useful in cases where you have to set the width of
    a text container, and you cannot be sure about the maximum width of the text container.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Debug** view is your friend in this scenario. Focus on the `Variables`
    frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To assign a value to a variable, select it from the list of variables available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access the right-click context menu. Select the **Set Value** option, and in
    the textbox that appears, provide some value. You are done immediately after pressing
    the return key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From now onwards, wherever this variable is accessed, it will assume this particular
    value. The keyboard shortcut to do this is provided by PhpStorm as *F2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, you must have easily guessed that the debugger sits between your code
    and the interpreter. Thus, when you assign a value to a variable, the debugger
    *cheats* the interpreter by passing on the changed value as the original value.
    The interpreter, a poor blind creature, gets into this gotcha by assuming that
    the value is the one specified in the code and proceeds ahead using this value.
  prefs: []
  type: TYPE_NORMAL
- en: The world is not being trusted at all!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you assign some value to a variable, it is not that the value will be fixed
    irrespective of the business logic. As soon as a condition where the variable
    will change its value is met, the change will occur normally as it would have
    occurred in the absence of the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage in PhpStorm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having set the platform to write clean code and to remove bugs from code to
    make good software, you must be thinking that your task is done, and you can now
    sit back and relax.
  prefs: []
  type: TYPE_NORMAL
- en: Not now! There's much more to do. Since you have promised that you will not
    tire and that you will not falter, you should have the fire burning within to
    proceed. This time, you are going to proceed with code coverage. Yes you read
    it right, code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: This is the right time to get informed about this phenomenon now that you have
    working knowledge about a testing system (**PHPUnit**) and a debugging system
    (**Xdebug**). Code coverage is a phenomenon that is brought about by the combined
    functionality provided by PHPUnit and Xdebug. This means that you have to have
    both the systems installed on your development machine if you really want code
    coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To solve matters such as these, there comes code coverage. No, no, don't think
    that code coverage will remove the unused lines—it will be *you* who will remove
    them. Coverage will let you know from where to remove the unused lines. Thus,
    code coverage is a phenomenon by which you check which lines of code are covered
    in the execution and which lines are not. Questions are firing inside you—what
    is the role of PhpStorm in this then? When you do code coverage, you get a visual
    indication as to which lines are not covered. It is this PhpStorm feature that
    takes care of managing this visual indication to you.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Covering a PHP code again requires some PHP code. You have to code everything
    in this world! The simplest way to code is to write tests for a target class.
    The framework (PHPUnit) will try to cover the entire class. In this case, you
    have to do nothing new while writing the code, for the change occurs when you
    try to run the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an option available in PhpStorm which lets you run a test with coverage.
    To do that, you will need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to select the test file and go to **Run | Run** `<test>` **with Coverage**,
    as shown in the following screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The target file will be tested in the usual way, and the coverage for the entire
    file will also be taken care of.![How to do it...](img/3878OT_05_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, suppose you want to cover a selected part of the code or a method,
    you can do that too. There is an annotation provided in PHPUnit with the name
    covers. Using this annotation, you can tell the PHP interpreter that you want
    to cover only a selected part of the target class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Thus, if you just want to test the `getDishName` method inside the (target)
    `PizzaDish` class, you can use something like the following code just before the
    `testGetDishName` method declaration in the `PizzaDishTest` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There will be instances in your programming life when you will not want to
    do anything interesting. You will just bother testing code and not covering any
    code—you will just want to test. You have an option. There is an annotation available
    with the name `coversNothing`. This is a way to tell the PHPUnit framework "Ok
    mate, you will only do testing for me. Don''t waste time in covering the code."
    Thus, you can write something like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Having used the annotations, you successfully maneuvered the functioning of
    code coverage. Congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The annotations are special features in PHP that provide some information to
    the interpreter to do some work silently. So, when you write `@covers <Classname>::<Method-name>`,
    you are telling the interpreter to cover certain code in a target class. Similarly,
    when you write `@coversNothing`, the interpreter understands that it does not
    have to do coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, PhpStorm provides you a visual indication by coloring regions in your
    code with certain colors denoting coverage and miss. When you run the test with
    coverage, there is a coverage view in the right-hand bottom corner of the editor
    window, which is shown in the following screenshot. You can view the statistics
    for the code that has just been tested (for coverage as well).
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3878OT_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You get visual indications as well. It is shown in the editor window of the
    target class (here `PizzaDish.php`, as shown in the following screenshot) the
    area with red color is uncovered.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3878OT_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have learned code coverage in PhpStorm, it is time to see the purpose
    of code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Purpose of code coverage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Again, there''s that same question in your mind: why do I need code coverage
    at all? The answer is not so obvious but is worth knowing about. You agreed that
    there were bugs in the code, so you used some debugging tool to find out and remove
    those bugs. You agreed that the algorithm you implemented went away at times,
    so you tested it and fixed it. But did you ever get a feeling that there might
    be unused lines in the code you have written? There might be lines that the interpreter
    will be unable to process, and there might be lines inside some conditions that
    are *never* met. Who will take into account these and many other such cases? Another
    question that will come to your mind is "what is the harm in having an extra line
    of code when you can have lines of comment in the code?" The answer is here.'
  prefs: []
  type: TYPE_NORMAL
- en: A comment is something that the interpreter does not bother about, but an active
    but unused line is something that it bothers about. It is just like moving around
    in your kitchen with a pistol tied around your waist after you have come back
    from a shooting session. Would you need a pistol inside your kitchen? Why are
    you carrying it with you then?
  prefs: []
  type: TYPE_NORMAL
