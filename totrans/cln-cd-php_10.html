<html><head></head><body>
		<div id="_idContainer039">
			<h1 id="_idParaDest-127" class="chapter-number"><a id="_idTextAnchor128"/>10</h1>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor129"/>Automated Testing</h1>
			<p>If you’ve read all the chapters of this book from the very beginning, you’ll have not only an idea of the theoretical background but also a good set of tools at hand that will help you write great <strong class="bold">PHP: Hypertext Preprocessor</strong> (<strong class="bold">PHP</strong>) code. Of course, you can just go and refactor all the code there is, probably using some automated code manipulation capabilities our tools offer.</p>
			<p>You will not write perfect code on the first try—it usually takes several iterations until you are satisfied. And since you never stop learning, you will refactor parts of your code even months or years later. Yet even the most sophisticated code quality tools will not prevent you from having to do one tedious task: testing your code after you’ve made changes to ensure that it still works as expected. That is why in this chapter, we want to introduce you <a id="_idIndexMarker398"/>to <strong class="bold">automated testing</strong>.</p>
			<p>Through automated testing, you will be able to verify that your improvements to the code did not break its functionality in a fast and reliable way. This is one of the cornerstones of writing clean code since it enables you to refactor code with confidence.</p>
			<p>The topic of automated testing deserves a whole book or two, so we can only scratch the surface here. Yet since we are convinced you will greatly benefit from it in your daily work, we hope that this chapter will make you want to learn more about this exciting topic.  </p>
			<p>The following sections will give you a good overview:</p>
			<ul>
				<li>Why you need automated tests</li>
				<li>Types of automated tests</li>
				<li>About code coverage</li>
			</ul>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor130"/>Technical requirements</h1>
			<p>Additional to the technical requirements of the previous chapters, you will need to install the<strong class="bold"> Xdebug</strong> PHP extension. We will provide you with more information on that topic in the corresponding section, <em class="italic">About code coverage</em>, later in this chapter.</p>
			<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Clean-Code-in-PHP">https://github.com/PacktPublishing/Clean-Code-in-PHP</a></p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor131"/>Why you need automated tests</h1>
			<p>Although <strong class="bold">PHPUnit</strong>, the <a id="_idIndexMarker399"/>standard unit testing framework <a id="_idIndexMarker400"/>for PHP, has existed since 2006, automated tests are still not used in all PHP projects today. A lot of potential is wasted here because automated tests have many benefits, such as the <a id="_idIndexMarker401"/>following:</p>
			<ul>
				<li><strong class="bold">Speed and reliability</strong>: Imagine you need to execute the same testing steps over and over. Soon enough, you would make mistakes, or just skip the tests at some point. Automated tests, however, do the boring work for you in a much faster and more reliable way—and they do not complain.</li>
				<li><strong class="bold">Documentation</strong>: With automated tests, you can indirectly document the functionality of code through assertions, which explain what the code is expected to do. Compared to comments or articles in a wiki, you will immediately be notified by the failing tests when something has changed significantly. We will discuss this topic again in <a href="B19050_13.xhtml#_idTextAnchor195"><em class="italic">Chapter 13</em></a><em class="italic">, Creating Effective Documentation,</em> when we talk about creating effective documentation.</li>
				<li><strong class="bold">Onboarding</strong>: A test suite with good coverage of our code will help new developers to get productive on a project faster. Not only do the tests act as additional documentation, but they also let the developers make changes or add features with confidence. They can verify that their changes do not break anything before they get deployed to any staging or production environment.</li>
				<li><strong class="bold">Continuous integration/continuous deployment (CI/CD)</strong>: Be it CI or CD, if your tests are automated, you can trust through your build pipeline that the code you merge is not broken, which enables you to push code to production faster, and thus more often. In the next chapter, we will have an in-depth look at this topic.</li>
				<li><strong class="bold">Better code</strong>: You do not<a id="_idIndexMarker402"/> strictly have to follow the<a id="_idIndexMarker403"/> infamous <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>) approach to benefit from tests already in development. Writing unit-testable code even improves your code. To be able to test code in isolation (for example, without having a real database running in the background), you need to write your code with separation in mind. If external dependencies are injected <a id="_idIndexMarker404"/>using <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>), they are much easier to replace with test objects than if you instantiate them in the class functions. We will have a closer look at the <strong class="bold">DI pattern</strong> in <a href="B19050_12.xhtml#_idTextAnchor174"><em class="italic">Chapter 12</em></a><em class="italic">, Working in a Team</em>. Additionally, long and complex functions are equally hard to test as short ones (think of—for example—the <strong class="bold">NPath complexity</strong> here, which we discussed in <a href="B19050_08.xhtml#_idTextAnchor100"><em class="italic">Chapter 8</em></a>), so you will very soon start to write shorter functions to reduce the number of decision paths in your code.</li>
				<li><strong class="bold">Easier refactoring</strong>: Automated tests are an invaluable tool when you want to refactor a project based on the results of the static code analyzers we introduced back in <a href="B19050_07.xhtml#_idTextAnchor084"><em class="italic">Chapter 7</em></a>. You can apply their recommendations or even the automated code fixes, and just after running the tests, you will know if this introduced any side effects or not. Since refactoring is the most important use case for us in the context of this book, we will discuss it in more detail in the next section.</li>
			</ul>
			<p class="callout-heading">TDD</p>
			<p class="callout">TDD is a way of developing code that combines writing tests and the actual code at the same time. The basic idea is simple and often referred to<a id="_idIndexMarker405"/> as <strong class="bold">red/green/refactor</strong>: before you write any code for a new feature or even a bug fix, the first step is to write a test that checks the expected outcome. Since you have no actual code written yet, the tests will fail (indicated by the color red). In the second step, you write the code, without paying too much attention to making it perfect, until the tests pass (green). Since you now already have working tests, you can easily improve (refactor) the code until you are satisfied.</p>
			<p class="callout">The TDD paradigm ensures that you will have all your code covered with tests and that the code is already written in a fully testable way. Do not take things too seriously, though: there are times when you just want to experiment without having a clear goal in mind—for example when you play around with a new <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>). In this case, you do not need to follow TDD.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor132"/>Easier refactoring with tests</h2>
			<p>If you start<a id="_idIndexMarker406"/> a project <em class="italic">on the green</em> (that is, you write it from scratch), you can have the comfort of getting immediate feedback from your code quality tools as soon as you start coding it. This is a great help, yet even the best tools will not prevent you from making bad decisions and writing code that you will want to undo at some point. </p>
			<p>That happens to everyone and should not discourage you at all. You learn something new every day, and while your personal skills evolve, so will your code. If you look at your code from 1 year ago, you’ll probably want to refactor it right away.</p>
			<p>And of course, not only your skills, but the whole PHP ecosystem constantly improves. Many things that are standard today were simply non-existent back in the day. New packages or language features are constantly being introduced, and you want to use them in your projects to not stick with the old techniques forever.</p>
			<p>So, code changes over time—that is completely normal, and we as developers should embrace change; no piece of our code will ever be final. We refer to changing existing code as <strong class="bold">refactoring</strong>. The<a id="_idIndexMarker407"/> interesting part about refactoring is that code gets changed, but the software appears unchanged to the user. All work happens “under the hood”. If you—for example—updated the framework of your project to the latest version, and the users noticed no direct changes, then you did your job well.</p>
			<p>Refactoring has<a id="_idIndexMarker408"/> benefits; otherwise, we would not do it. If done right, it can lead—for example—to improved performance, increased security, or generally allows an application to be scalable in the cloud. And yet, refactoring often comes with a bad connotation. Managers in particular tend to think that refactoring means changing code just because there is yet another hype in the web development world the engineers want to follow, and precious working hours are wasted. </p>
			<p>Let us be honest: of course, this happens too. The line is often difficult to draw. For example, imagine your duty is to maintain an old but perfectly working PHP application that uses <a id="_idIndexMarker409"/>the <strong class="bold">Singleton pattern</strong> for object instantiation. If you only have to do small changes occasionally, there actually is no need to refactor it to use DI. However, if you are required to implement ongoing changes, such as adding new modules and tests for it, it might be a good choice to do so.</p>
			<p>Often, you will have to justify your refactoring work. It is then helpful to rather speak of <strong class="bold">system health maintenance</strong> on<a id="_idIndexMarker410"/> the code instead. Everybody is completely fine with the fact that machines require maintenance: parts get replaced, the lubricant must be renewed, and so on. Yet, for some reason, our software ought to work forever.</p>
			<p>Having good <a id="_idIndexMarker411"/>arguments for refactoring now, we want to understand how testing can help us here. To accomplish that, let us have a closer look at the different test types there are in the next section.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor133"/>Types of automated tests</h1>
			<p>Although <strong class="bold">unit tests</strong> are <a id="_idIndexMarker412"/>probably the most known type of automated testing, there is more to discover. In this section, we will introduce the most common (and important) test types. A well-known testing concept is the <strong class="bold">testing pyramid</strong>, which<a id="_idIndexMarker413"/> is shown here: </p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_10.1_B19050.jpg" alt="Figure 10.1: Testing pyramid&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1: Testing pyramid</p>
			<p>This concept basically shows three types of tests—namely, <strong class="bold">end-to-end tests</strong> (or <strong class="bold">E2E tests</strong> in short), <strong class="bold">integration tests</strong>, and <strong class="bold">unit tests</strong>. We will explain each test type and its position in the testing pyramid in the following sections.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor134"/>Unit tests</h2>
			<p>As the <a id="_idIndexMarker414"/>name implies, <strong class="bold">unit tests</strong> are <a id="_idIndexMarker415"/>about testing small units of code. It is best practice to write one test for each functionality of an object only; otherwise, the tests will become bigger and harder to understand and maintain. This keeps the tests small as well, and that is why there is usually a lot of them. Depending on the project size, having hundreds or thousands of unit tests is completely normal, so it is important to keep them executing as fast as possible. Usually, they should not take longer than a few microseconds each. </p>
			<p>Unit tests should run in isolation, which means that in the tests, the tested objects do not interact with any other external services, such as databases or APIs. This is achieved by faking the external dependencies, which is <a id="_idIndexMarker416"/>called <strong class="bold">mocking</strong> in unit testing jargon. Simply speaking, we replace external objects—such as services or repositories that are used within our test <a id="_idIndexMarker417"/>object—with <strong class="bold">mock objects</strong> (or <strong class="bold">mocks</strong>, in short). These objects simulate the behavior of the dependencies they replace during the runtime of the unit tests. This ensures that a test does not suddenly fail just because—for example—some data in the database, which our test was relying on, has changed.</p>
			<p>Because tests of this type are small, fast, and do not rely on external dependencies, it is relatively easy to create a test setup for them. They are extremely helpful because they can tell you within seconds if your last changes to the code caused any problems or not. That is why they are the foundation of the testing pyramid.</p>
			<p>If you are new to testing, it makes sense to start<a id="_idIndexMarker418"/> with <strong class="bold">PHPUnit</strong>, as it is the industry standard in the PHP world. If you start on a new project, it is most likely that PHPUnit will be used. There are other testing frameworks that have their unique advantages, such<a id="_idIndexMarker419"/> as <strong class="bold">Pest</strong> (<a href="https://pestphp.com">https://pestphp.com</a>). Once you have grasped the concept of unit testing with PHPUnit, we encourage you to give them a try as well.</p>
			<p>A <a id="_idIndexMarker420"/>drawback of unit tests is the fact that they do not interact with each other. This may even lead to having all your tests passing while your application is broken, just because<a id="_idIndexMarker421"/> the interaction between the classes was not tested properly. </p>
			<p>To illustrate <a id="_idIndexMarker422"/>this problem, we create an elementary demo application. Let us have a look at the most important parts of it. </p>
			<p class="callout-heading">Demo application source code</p>
			<p class="callout">You will find the full source code in the GitHub repository to this book: </p>
			<p class="callout">https://github.com/PacktPublishing/Clean-Code-in-PHP</p>
			<p>First, we create a rudimentary class, called <strong class="source-inline">MyApp</strong>, as follows:</p>
			<pre class="source-code">
&lt;?php
class MyApp
{
    public function __construct(
        private myRepository $myRepository
    ) {
    }
    public function run(): string
    {
        $dataArray = $this-&gt;myRepository-&gt;getData();
        return $dataArray['value_1'] .
          $dataArray['value_2'];
    }
}</pre>
			<p>The <strong class="source-inline">MyRepository</strong> method gets injected through the constructor. The only method, <strong class="source-inline">run</strong>, uses the repository to fetch data and concatenate it. It is important to note that <strong class="source-inline">MyClass</strong> expects a certain array structure to be returned by <strong class="source-inline">MyRepository</strong>. This is not recommended<a id="_idIndexMarker423"/> to do, but you will still find this a lot “in the wild”. Therefore, it serves perfectly as a demonstration. </p>
			<p><strong class="source-inline">MyRepository</strong> looks like this:</p>
			<pre class="source-code">
&lt;?php
class MyRepository
{
    public function getData(): array
    {
        return [
            'value_1' =&gt; 'some data...',
            'value_2' =&gt; 'and some more data'
        ];
    }
}</pre>
			<p>In real life, <strong class="source-inline">MyRepository</strong> would fetch the data from an external data source, such as a database. For our example, it returns a hardcoded array. If the <strong class="source-inline">run</strong> method of <strong class="source-inline">MyClass</strong> gets executed, it will return a <strong class="source-inline">some data...and some more data</strong> string.</p>
			<p>Of course, we also added tests (using PHPUnit) for the preceding classes. For brevity, we will only show the test cases in the following code snippet, not the whole test classes:</p>
			<pre class="source-code">
public function testRun(): void
{
    // Arrange
<strong class="bold">    $repositoryMock = </strong>
<strong class="bold">      $this-&gt;createMock(MyRepository::class);</strong>
<strong class="bold">    $repositoryMock</strong>
<strong class="bold">        -&gt;expects($this-&gt;once())</strong>
<strong class="bold">        -&gt;method('getData')</strong>
<strong class="bold">        -&gt;willReturn([</strong>
<strong class="bold">            'value_1' =&gt; 'a',</strong>
<strong class="bold">            'value_2' =&gt; 'b'</strong>
<strong class="bold">        ]);</strong>
    // Act
    $appTest = new MyApp($repositoryMock);
    $result = $appTest-&gt;run();
    // Assert
    $this-&gt;assertEquals('ab', $result);
}
public function testGetDataReturnsAnArray(): void
{
    // Arrange
    $repositoryTest = new MyRepository();
    // Act
    $result = $repositoryTest-&gt;getData();
    // Assert
<strong class="bold">    $this-&gt;assertIsArray($result);</strong>
<strong class="bold">    $this-&gt;assertCount(2, $result);</strong>
}</pre>
			<p class="callout-heading">The Arrange-Act-Assert (AAA) pattern</p>
			<p class="callout">You may have<a id="_idIndexMarker424"/> noticed that we added three lines of comments to both of our test cases: <strong class="source-inline">Arrange</strong>, <strong class="source-inline">Act</strong>, and <strong class="source-inline">Assert</strong>. We did that to demonstrate the most used pattern to write unit tests: the <strong class="bold">AAA pattern</strong>. Even without having ever written a single unit test yourself, it helps you to understand how they work. </p>
			<p class="callout">Firstly, the test objects and required prerequisites such as mock objects get prepared (<strong class="source-inline">Arrange</strong>). Secondly, the actual work of the object under test is executed (<strong class="source-inline">Act</strong>). Finally, we ensure that the results of the test meet our expectations (<strong class="source-inline">Assert</strong>). If one of the assertions is not met, the whole test fails. </p>
			<p>Two things are <a id="_idIndexMarker425"/>noteworthy here, as set out next: </p>
			<ol>
				<li>In <strong class="source-inline">testRun()</strong>, we create a <strong class="source-inline">$repositoryMock</strong> mock instead of using the actual <strong class="source-inline">MyRepository</strong> method. This is because we assume that <strong class="source-inline">MyRepository</strong> would normally fetch the data from an external data source, and we do not want to write unit tests that have external dependencies.</li>
				<li><strong class="source-inline">testGetDataReturnsAnArray()</strong> does not test the repository very well. We just check if the result is an array and that it has two entries, but not which array keys are returned.</li>
			</ol>
			<p>Now, imagine that for whatever reason, one fellow developer decided that the <strong class="source-inline">value_1</strong> and <strong class="source-inline">value_2</strong> array keys were too long, and renamed them <strong class="source-inline">val1</strong> and <strong class="source-inline">val2</strong>. If we now execute our application, it will of course break, as illustrated here:</p>
			<pre class="source-code">
$ php index.php 
PHP Warning:  Undefined array key "value_1" in
  /home/curtis/clean-
  code/chapter10/unit_tests_fail/src/MyApp.php on line 18
PHP Warning:  Undefined array key "value_2" in
  /home/curtis/clean-
  code/chapter10/unit_tests_fail/src/MyApp.php on line 18</pre>
			<p>However, if you execute the tests, they will still pass, as we see here:</p>
			<pre class="source-code">
$ vendor/bin/phpunit tests
PHPUnit 9.5.20 #StandWithUkraine
 
..                                         2 / 2 (100%)
 
Time: 00:00.008, Memory: 6.00 MB
 
OK (2 tests, 4 assertions)</pre>
			<p>This illustrates<a id="_idIndexMarker426"/> that having unit tests is important, but it does not necessarily mean that we will not introduce bugs anymore because they can be faulty or they test the wrong things, as in our example. </p>
			<p>Often enough, objects<a id="_idIndexMarker427"/> such as <strong class="bold">repositories</strong> that interact with external systems are not tested at all because it requires a more complex test setup—for example, using an additional test database with fake data. If we just replace such an object with a mock, the test will work correctly. If there are significant changes on the original object later and the mock does not get updated to reflect those changes, we can end up in a situation like we just described.</p>
			<p>To overcome this problem, we need a way to additionally test our classes without replacing dependencies with mocks. For that, we will introduce the second test type of the testing pyramid—integration tests—in the next section. </p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor135"/>Integration tests</h2>
			<p>The<a id="_idIndexMarker428"/> second<a id="_idIndexMarker429"/> types of test we want to look at are <strong class="bold">integration tests</strong>. Unlike unit tests, which are supposed to not use any external dependencies, with this test type we want to do the opposite: we want to test code as it would normally run, without replacing anything with mocks. </p>
			<p>You might have already witnessed unit test suites that made use of a test database or some external API. Technically <a id="_idIndexMarker430"/>speaking, these tests are not unit tests anymore, but integration tests (or <strong class="bold">functional tests</strong>, as they are also called). We could theoretically use PHPUnit for these tests as well, or use particular testing tools that take over a lot of groundwork for us.</p>
			<p>The following code snippet <a id="_idIndexMarker431"/>shows an example of an integration test:</p>
			<pre class="source-code">
public function productIsSaved(<strong class="bold">Tester $tester</strong>)
{
    $product = new Product();
    $product-&gt;setId(123);
    $product-&gt;setName('USB Coffee Maker');
    $product-&gt;save();
    
   $this-&gt;tester-&gt;<strong class="bold">seeInDatabase</strong>(
        'products',
        ['id' =&gt; 123, 'name' =&gt; 'USB Coffee Maker' ]
    );
}</pre>
			<p>The preceding function<a id="_idIndexMarker432"/> shows what an integration test could look like if we used the <strong class="bold">Codeception</strong> test tool (see the next information box for more information). An object called <strong class="source-inline">$tester</strong> gets passed into the test that is a <strong class="source-inline">Helper</strong> object that offers the functionality we need to perform—for example, database checks. After executing the <strong class="source-inline">save</strong> method on the <strong class="source-inline">$product</strong> test object, we use this <strong class="source-inline">Helper</strong> object to validate if the data we would expect has actually been written into the database.</p>
			<p class="callout-heading">Codeception</p>
			<p class="callout">Codeception (<a href="https://codeception.com">https://codeception.com</a>) combines <a id="_idIndexMarker433"/>a variety of <a id="_idIndexMarker434"/>test types, such as unit, integration, and even E2E tests in one tool. Under the hood, it is based on existing tools such as PHPUnit. It offers modules for all major frameworks and thus integrates well into most PHP projects.</p>
			<p>Using<a id="_idIndexMarker435"/> integration tests makes the test setup more complex <a id="_idIndexMarker436"/>because we must make sure that the external dependencies we use are always in a reliable state. For example, if you need to rely on a certain user in your database, you must make sure that it always has the same data, such as the user <strong class="bold">identifier</strong> (<strong class="bold">ID</strong>) you test for; otherwise, your tests will fail. This usually requires creating a fresh test database before every test run, to make sure no leftovers from previous test runs disturb our test. Furthermore, we need to run <strong class="bold">database migrations</strong> to<a id="_idIndexMarker437"/> ensure that the test database schema is up to date. Finally, we have to fill it with test data, which<a id="_idIndexMarker438"/> is called <strong class="bold">seeding</strong>. </p>
			<p>The main<a id="_idIndexMarker439"/> drawback of this test type is the execution speed. Database transactions are slow (compared to using mock objects), and we need to prepare the test database upon every test run. Integration tests also tend to break easier, or they become flaky (unstable) because the interaction with other dependencies quickly becomes very complex: if the previous test changed the database in a way the next test did not expect, your test run fails, although the code has not changed.</p>
			<p>For example, a new test is added to the test suite that checks if a class updates a dataset in a certain way. Since this is an integration test, it will use the test database for it and change that particular dataset. After the execution of this test, however, the changed data will still be in the test database. If another test that runs <em class="italic">after</em> this new test is relying on the previous data, it will fail. Despite the added complexity of your test setup, integration tests ensure that the integration of tested objects within the application context works fine. That is why they should be an integral part of your test strategy, being the second layer in the testing pyramid. </p>
			<p>You will find<a id="_idIndexMarker440"/> a lot of integration tests<a id="_idIndexMarker441"/> when it comes to testing repositories, models, or controllers. However, they cannot test the interaction between PHP and the browser. Since we use PHP mainly to build web applications, this is an aspect that we should not forget about. Luckily, the last test type from the testing pyramid covers exactly this problem.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor136"/>E2E tests</h2>
			<p>For this <a id="_idIndexMarker442"/>test type, we<a id="_idIndexMarker443"/> will leave the realm of PHP for a moment. With <strong class="bold">E2E tests</strong>, we want to ensure that the whole flow from the server to the client (for example, the browser) and back again to the server is working alright. We basically simulate a user sitting in front of the computer and clicking through our application.</p>
			<p>To achieve this, we first need a reproducible testing environment. Just as for integration tests, we must ensure that the application we want to test is always in the same state. This means that we need to ensure that the same set of data (for example, blog posts, or articles in a shop) is available on every test run.</p>
			<p>Secondly, we need to automate the user interaction with our testing environment. Here is where things get interesting: we not only need the application, but also a local web server and a browser to run it in and simulate the user interaction. The web server adds more complexity to the test setup but is usually not a blocker. For user interaction, we need to use a <a id="_idIndexMarker444"/>so-called <strong class="bold">headless browser</strong>. Such a browser can interact with a server without having to open a browser window. This is an extremely useful feature because we can use it on the command line without having to install a full-fledged operating system<a id="_idIndexMarker445"/> with a <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>) such as Ubuntu Desktop or Windows. This saves us a lot of installation time and helps us not to increase the complexity even further.</p>
			<p>At the time of<a id="_idIndexMarker446"/> writing, <strong class="bold">Google Chrome</strong> is the preferred choice, as it is not only the most widely used browser engine nowadays, but also provides a <strong class="bold">Headless</strong> mode, or in other words, it can act like a headless browser. With modern frameworks such as <strong class="bold">Cypress</strong>, it is<a id="_idIndexMarker447"/> effortless to automate user interaction with our application. Think of it as a script that tells the browser which <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) to <a id="_idIndexMarker448"/>open, which button to click, and so on. The following example shows a simplified Cypress test:</p>
			<pre class="source-code">
describe('Application Login', function () {
    it('successfully logs in', function () {
        cy.visit('http://localhost:8000/login')
        cy.get('#username')
            .type('test@test.com')
        cy.get('#password')
            .type('supersecret')
        cy.get('#submit')
            .click()
        cy.url()
            .should('contain',
              'http://localhost:8000/home')
    })
})</pre>
			<p class="callout-heading">Cypress</p>
			<p class="callout">The<a id="_idIndexMarker449"/> Cypress testing framework (<a href="https://www.cypress.io/">https://www.cypress.io/</a>) makes writing E2E tests very easy, as it handles the setup of and communication with the headless browser for you. Yes—the tests are to be written in JavaScript, but that should not stop you from giving it a try.</p>
			<p>The <strong class="source-inline">cy</strong> object represents the tester, which executes certain steps. In the preceding code example, it firstly opens the login page of a fictive application, fills out the <strong class="source-inline">#username</strong> and <strong class="source-inline">#password</strong> fields in a login form, and submits it by clicking on the <strong class="bold">#submit </strong>button. As the last step, it checks whether the login was successful and if the tester has been forwarded to the home screen. All these actions are then executed in a real browser, running in the background. Using this technology, it is possible to write test suites that literally click through our application, just as a human being would. They do not just test the PHP code <a id="_idIndexMarker450"/>but also the frontend code—a JavaScript error, for example, will quickly break the tests. Even if you cannot fix the bug yourself, you can still inform the frontend engineers in your team that there is a problem.</p>
			<p>The modern<a id="_idIndexMarker451"/> frameworks make it much easier to write tests than was the case with older technologies, such as Selenium. In fact, it is so comfortable nowadays that also people who are not developers but have a solid technical foundation, such <a id="_idIndexMarker452"/>as <strong class="bold">quality assurance</strong> (<strong class="bold">QA</strong>) engineers, can easily write their own test suites. This approach takes a lot of pressure from the teams because the developers have to write fewer tests, and the QA people can set up their tests as they need them without having to wait for the developers.</p>
			<p>Of course, E2E tests have some drawbacks, which is why they are just the third layer of tests in the testing pyramid: the test environment is more complex and needs more work to set up, especially if a database or any external API is used. This test type is also the slowest since it involves the browser in addition to the test setups of the previous test types. Lastly, these tests can easily break because usually, the <a id="_idIndexMarker453"/>testing frameworks use <strong class="bold">Hypertext Markup Language</strong> (<strong class="bold">HTML</strong>) <strong class="source-inline">id</strong> and <strong class="source-inline">class</strong> attributes, or <a id="_idIndexMarker454"/>even <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) selectors, to navigate through the DOM and find elements to interact with. Thus, a small change on the DOM can quickly break your whole test suite.</p>
			<p class="callout-heading">Page objects</p>
			<p class="callout">If you are interested in creating maintainable E2E tests, you should check out the concept <a id="_idIndexMarker455"/>of <strong class="bold">page objects</strong> (<a href="https://www.martinfowler.com/bliki/PageObject.html">https://www.martinfowler.com/bliki/PageObject.html</a>).</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor137"/>The testing pyramid in practice</h2>
			<p>With unit, integration, and E2E tests, you now know the three most important test types, and <a id="_idIndexMarker456"/>their pros and cons. The suggested approach of having unit tests as a huge foundation, a fair amount of integration tests, and—finally—some E2E tests is a good starting point.</p>
			<p>However, you do not have to strictly follow it all the time, since every project is different: if you, for example, want to start testing a yet completely untested application, introducing unit tests would require a lot of refactoring effort to make the classes testable. This refactoring will most likely introduce more bugs in the beginning than it will solve. </p>
			<p>In this case, starting with a good E2E test coverage will be quicker and safer. Once the main parts of the application can be automatically tested, you can safely start with the refactoring and introduce unit and/or integration tests. If your application breaks because of the necessary refactoring, your E2E tests have you covered.</p>
			<p>At the end of this chapter, we will list some more test types for you to evaluate if you are interested. For now, the three test types we covered in this chapter are the most important ones and should be enough for you to get started. </p>
			<p>There is one important question that we have not really covered yet, though: how much of your code do you really need to test? We will discuss this in the next section.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor138"/>About code coverage</h1>
			<p>Now we’ve explored the different test types, you probably want to start writing tests right away. But before you put this book away to get coding, let us finish this chapter with the question of how much of your code you should test.</p>
			<p>A part of the answer lies within the concept of code coverage, which we already briefly mentioned in <a href="B19050_08.xhtml#_idTextAnchor100"><em class="italic">Chapter 8</em></a><em class="italic">, Code Quality Metrics</em> when we talked about code quality metrics. Let us have a closer look at it now.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor139"/>Understanding code coverage</h2>
			<p><strong class="bold">Code coverage</strong> measures <a id="_idIndexMarker457"/>the proportion of code that is covered with tests. The higher the code coverage, the better—if there are more tests, the software is less likely to contain bugs, and it will be harder to introduce new ones unnoticed. Higher code coverage is also a possible indicator of better code quality—as we discussed in a previous section of this chapter, tested code must be written in a certain way, which usually leads to better quality. </p>
			<p>Generally, the <a id="_idIndexMarker458"/>degree of coverage is expressed simply using the percentage of tested code—that is, from 0% (fully untested) to 100% (complete code coverage). But how can we measure code coverage? For that, we will use PHPUnit, as it can create a code coverage report for us. However, it requires an additional PHP extension for <a id="_idIndexMarker459"/>the code coverage<a id="_idIndexMarker460"/> functionality. For this chapter, we decided to use <strong class="bold">Xdebug</strong>, the standard PHP <strong class="bold">debugger</strong> and <strong class="bold">profiler</strong>. </p>
			<h3>Setting up Xdebug</h3>
			<p>Xdebug is <a id="_idIndexMarker461"/>an extension for PHP, so it requires to be loaded <a id="_idIndexMarker462"/>as a module. Since its installation is a bit more complex and mainly depends on the operating system you are running PHP on, please refer to the official <a id="_idIndexMarker463"/>documentation at <a href="https://xdebug.org">https://xdebug.org</a> on how to install and configure it. There are also plenty of tutorials available on the internet.</p>
			<p>If you refactor your code, you probably want to know what performance implications the changes had. Did you improve the execution time, or did it get even worse? With a so-called <strong class="bold">profiler</strong>, you <a id="_idIndexMarker464"/>can measure the execution time of each function in detail and see where bottlenecks are hidden. </p>
			<p>We cannot cover this topic in our book, but since over the course of this chapter we already worked with Xdebug, you might want to <a id="_idIndexMarker465"/>check out its profiling capabilities as well: <a href="https://xdebug.org/docs/profiler">https://xdebug.org/docs/profiler</a>. Other commercial services that offer<a id="_idIndexMarker466"/> more <a id="_idIndexMarker467"/>comfort are—for example—<strong class="bold">Tideways</strong> (<a href="https://tideways.com">https://tideways.com</a>) or <strong class="bold">Blackfire </strong>(<a href="https://www.blackfire.io">https://www.blackfire.io</a>).</p>
			<p class="callout-heading">Xdebug alternatives</p>
			<p class="callout">Please note that you can use other extensions for this, such as <strong class="bold">PCOV</strong> (<a href="https://github.com/krakjoe/pcov">https://github.com/krakjoe/pcov</a>), which <a id="_idIndexMarker468"/>performs better if you<a id="_idIndexMarker469"/> only want to do code coverage reports. However, Xdebug is an incredibly useful debugger that you should know—if you do not, we encourage you to check out some tutorials about it.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor140"/>How to generate code coverage reports</h2>
			<p>To <a id="_idIndexMarker470"/>demonstrate how to create a code coverage report, we will use our little demo application from the previous section of this chapter. To follow up on the example, check it out from GitHub, run <strong class="source-inline">composer install</strong>, and make sure you have Xdebug installed with <strong class="source-inline">mode</strong> set to <strong class="source-inline">coverage</strong>. </p>
			<p>Before we start generating a report, let us see which report formats PHPUnit has to offer. It can generate reports in a variety of formats that you will most likely not need right now, such as <strong class="source-inline">Clover</strong>, <strong class="source-inline">Cobertura</strong>, <strong class="source-inline">Crap4J</strong>, or the <strong class="source-inline">PHPUnit</strong> XML format. They can get more relevant, though, when you start integrating PHPUnit with other tools. </p>
			<p>However, we do not want to do this in this book, so we are only interested in the two most accessible formats: text and HTML. The text format can directly be printed on the command line, which is useful when you want instant results or to integrate PHPUnit in your build pipeline, while the HTML format offers more information.</p>
			<p>For our example, we want to write both report formats into a new folder called <strong class="source-inline">reports</strong> in the project root. Although you can generate them using the many PHPUnit runtime options, we want to use the <strong class="source-inline">phpunit.xml</strong> configuration file to define what to generate upon every test run. The following code snippet shows a minimal version, reduced for readability. In our GitHub repository, you will find the full <strong class="source-inline">phpunit.xml</strong> file:</p>
			<pre class="source-code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;phpunit bootstrap="vendor/autoload.php"&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="default"&gt;
            &lt;directory&gt;tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
    <strong class="bold">&lt;coverage&gt;</strong>
<strong class="bold">        &lt;include&gt;</strong>
<strong class="bold">            &lt;directory suffix=".php"&gt;src&lt;/directory&gt;</strong>
<strong class="bold">        &lt;/include&gt;</strong>
<strong class="bold">        &lt;report&gt;</strong>
<strong class="bold">            &lt;html outputDirectory="reports/coverage" /&gt;</strong>
<strong class="bold">            &lt;text outputFile="reports/coverage.txt" /&gt;</strong>
<strong class="bold">        &lt;/report&gt;</strong>
<strong class="bold">    &lt;/coverage&gt;</strong>
&lt;/phpunit&gt;</pre>
			<p>Besides <a id="_idIndexMarker471"/>the basic configuration, which includes a definition of the <strong class="source-inline">tests</strong> folder we need for the regular test runs, we added the <strong class="source-inline">&lt;coverage&gt;</strong> node. This contains two child nodes: <strong class="source-inline">&lt;includes&gt;</strong> and <strong class="source-inline">&lt;report&gt;</strong>. It is important to specify when using the <strong class="source-inline">&lt;includes&gt;</strong> node which directory and file extension should be used for collecting code coverage information. Otherwise, PHPUnit will not generate any reports, but also will not complain about missing information. This can be quite confusing at times.</p>
			<p>Furthermore, we need to tell PHPUnit where to write which reports. We use the <strong class="source-inline">&lt;report&gt;</strong> node for this, and as you can see, we specified both the HTML and text reports to be written into the <strong class="source-inline">reports</strong> folder in our project root, which will be created if it does not exist.</p>
			<p>PHPUnit expects the configuration file to be named <strong class="source-inline">phpunit.xml</strong> and to be in the project root. If this has been done, you can quickly execute the generation of the reports by running the following command without any further options or arguments:</p>
			<p class="source-code">$ vendor/bin/phpunit</p>
			<p>After the execution of the preceding command, you will find a <strong class="source-inline">reports</strong> folder generated in your project root. It should contain two things: first, a <strong class="source-inline">coverage.txt</strong> file that contains a report in text format, and second, a <strong class="source-inline">coverage</strong> folder that contains an HTML report.</p>
			<p class="callout-heading">Code coverage is costly</p>
			<p class="callout">Using Xdebug to generate code coverage reports will slow down the execution of your test suite because Xdebug has to collect a lot of data, and it was not built for performance. We therefore recommend you enable Xdebug and the report generation only if necessary but keep it disabled during your regular test runs.</p>
			<p>The <a id="_idIndexMarker472"/>text report is short, but already tells you how well your tests cover your application, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/Figure_10.2_B19050.jpg" alt="Figure 10.2: Text code coverage report&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2: Text code coverage report</p>
			<p>To get more details, please open the <strong class="source-inline">reports/coverage/index.html</strong> file in your browser. It should look like this:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_10.3_B19050.jpg" alt="Figure 10.3: HTML code coverage report&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3: HTML code coverage report</p>
			<p>You will<a id="_idIndexMarker473"/> find the same information from the text report there, but with a better visualization. Furthermore, the report is interactive. For example, if you click on the <strong class="source-inline">MyOtherClass.php</strong> link on the left, you will be taken to a detailed report for that class, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Figure_10.4_B19050.jpg" alt="Figure 10.4: HTML code coverage report – class view&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4: HTML code coverage report – class view</p>
			<p>Two <a id="_idIndexMarker474"/>things are noteworthy here: firstly, in the <strong class="bold">Functions and Methods</strong> section, you might have already recognized the CRAP metric which we introduced in <a href="B19050_08.xhtml#_idTextAnchor100"><em class="italic">Chapter 8</em></a><em class="italic">, Code Quality Metrics</em>. Here, you can finally see it in action.</p>
			<p>Secondly, the report shows you in detail which lines have been accessed during the test (green background), and which have not (red background). If there had been any lines that were inaccessible at all (for example, another statement after the last <strong class="source-inline">return</strong> statement), it would have been displayed as <strong class="bold">Dead Code</strong> (yellow background). Dead code can safely be removed.</p>
			<p>You now have a nice overview of the code coverage of your project. If files appear with a red bar, they have not been executed during the test run at all, so this is where you could improve your test suite.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor141"/>Using the @covers annotation </h2>
			<p>There is one<a id="_idIndexMarker475"/> problem with code coverage: it tells you which code has been <em class="italic">executed</em> during the test, but that does not mean that the <a id="_idIndexMarker476"/>executed code has also been <em class="italic">tested</em> (that is, using assertions). This is something that PHPUnit cannot determine automatically. This means that even if your code coverage reports show 100% and green bars everywhere, it does not mean that your code is well tested. It was just executed during the run of your test suite.</p>
			<p>To overcome this problem, it is recommended to use the <strong class="source-inline">@covers</strong> annotation at the class level, as illustrated here:</p>
			<p class="source-code"><strong class="bold">/**</strong></p>
			<p class="source-code"><strong class="bold"> * @covers MyRepository</strong></p>
			<p class="source-code"><strong class="bold"> */</strong></p>
			<p class="source-code">class MyRepositoryTest extends TestCase</p>
			<p class="source-code">{</p>
			<p class="source-code">    public function testGetDataReturnsAnArray(): void</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // ...</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This improves the accuracy of our tests because by using the <strong class="source-inline">@covers</strong> annotation, we explicitly declare which code is meant to be tested by our tests. For example, let us say the class under test uses an external service. You only want to test that one class, not the service it uses, so you solely write assertions that check the class under test. Without the <strong class="source-inline">@covers</strong> annotation, though, PHPUnit would still include the external service in the code coverage report because it was executed during the test.</p>
			<p>You can use <strong class="source-inline">@covers</strong> also on a method level; however, this could cause problems if— for example—you refactor a class and extract methods to some other class. If you forget to adjust the <strong class="source-inline">@covers</strong> annotation on the method level here, the coverage report will not be accurate anymore.</p>
			<p>To <a id="_idIndexMarker477"/>force<a id="_idIndexMarker478"/> usage of the <strong class="source-inline">@covers</strong> annotation, use the <strong class="source-inline">forceCoversAnnotation</strong> option in the <strong class="source-inline">phpunit.xml</strong> file. If it is set to <strong class="source-inline">true</strong>, tests that do not use the annotation will be marked as risky; they do not fail, but they appear separately in the reports as something to be improved. This way, your fellow developers (and you) will not forget to use it.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor142"/>What to test</h2>
			<p>We now know <a id="_idIndexMarker479"/>how to get detailed information about how much of our code is tested. So, should you strive for complete code coverage now? Should 100% be your goal?</p>
			<p>As we saw in the tests of our example application in a previous part of this chapter, writing tests for a class does not automatically mean that you really test every aspect of it. Here, unfortunately, even measuring the code coverage will not help. However, it can help you identify tests that do not test anything. Especially when a lot of mocks are used in a test case, it can happen that only the mock gets tested, but no “real code”. Consider the following test case, which is a valid test that would pass:</p>
			<p class="source-code">public function testUselessTestCase(): void</p>
			<p class="source-code">{</p>
			<p class="source-code">    $repositoryMock = </p>
			<p class="source-code">      $this-&gt;createMock(MyRepository::class);</p>
			<p class="source-code">    $repositoryMock</p>
			<p class="source-code">        -&gt;method('getData')</p>
			<p class="source-code">        -&gt;willReturn([</p>
			<p class="source-code">            'value_1' =&gt; 'a',</p>
			<p class="source-code">            'value_2' =&gt; 'b'</p>
			<p class="source-code">        ]);</p>
			<p class="source-code">    $this-&gt;assertEquals(</p>
			<p class="source-code">        [ </p>
			<p class="source-code">           'value_1' =&gt; 'a',</p>
			<p class="source-code">           'value_2' =&gt; 'b'</p>
			<p class="source-code">        ],</p>
			<p class="source-code">        $repositoryMock-&gt;getData()</p>
			<p class="source-code">    );</p>
			<p class="source-code">}</p>
			<p>This<a id="_idIndexMarker480"/> example is simplified, but it demonstrates how code coverage reports can help because this test would not add a single tested line to our code coverage ratio. Unfortunately, no tool can tell you (yet) which tests are well written and which should be improved or are even useless, as in our example.</p>
			<p>Following <a id="_idIndexMarker481"/>the <strong class="bold">Pareto principle</strong>, aiming for 80% code coverage should already vastly improve your code base, and this can be achieved with a reasonable amount of effort. Put your focus on the code that makes your application special—often referred<a id="_idIndexMarker482"/> to as <strong class="bold">business logic</strong>. This is the code that requires most of your attention.</p>
			<p class="callout-heading">Pareto principle</p>
			<p class="callout">The Pareto principle states that 80% of results are achieved with 20% of the total effort. The remaining 20% of the results require the quantitatively most work, with 80% of the total effort.</p>
			<p>There is also trivial code that does not really need to be tested. A common example is testing for getters and setters. If these methods contain further logic, it makes sense to test them, of course. But if they are just simple functions that set or return the value of a property, it is a waste of time to write tests for them. Still, you would need to do this if you would like to strive for 100% code coverage. </p>
			<p>Other examples are configuration files, factories, or route definitions. It is sufficient to use E2E or integration tests, which ensure that the application works in general. They implicitly (that is, without using concrete assertions) test all<a id="_idIndexMarker483"/> the <strong class="bold">glue code</strong>, which is all the code that keeps your application together but is tedious to test.</p>
			<p>Particularly, E2E tests <a id="_idIndexMarker484"/>are usually not counted into the code coverage metric because it is technically difficult to do so. If you have them, though, they will add an extra layer of test coverage that cannot be measured. You cannot brag about 100% code coverage, but you know that all the different test types have your back, and that should be our number one goal.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor143"/>Summary</h1>
			<p>In this chapter, we discussed why you should use automated testing and how it improves your code quality. We covered the main three testing types, which are unit testing, integration testing, and E2E testing, with their pros and cons, potential pitfalls, and our recommendations on how to use them. Finally, you learned about the concept of code coverage, and how to use it in your own projects.</p>
			<p>Together with the knowledge from the previous chapter about code quality tools and how to organize them, in the next chapter, we can finally start combining all these tools together into a process that helps to run all of them in structured and reliable ways—build pipelines.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor144"/>Further reading</h1>
			<p>There are more test types out there than we could cover in this chapter. If you find the world of automated testing as fascinating as the authors do, you might want to check out other test types as well, such as the following: </p>
			<ul>
				<li><strong class="bold">Mutation testing</strong> is about modifying the code to be tested in tiny changes (so-called mutants). If your tests can catch these mutants, they are usually well written; otherwise, they will let the mutant escape. <strong class="bold">Infection</strong> is currently the best-known tool for this test type in the PHP world (<a href="https://infection.github.io">https://infection.github.io</a>). </li>
				<li><strong class="bold">Visual regression testing</strong> literally compares screenshots of the application made during tests with original screenshots to catch problems in <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>). While this is not directly PHP-related, it could be interesting for you if you want to keep the styling of your web project perfect. A good candidate to check is <strong class="bold">BackstopJS</strong> (<a href="https://github.com/garris/BackstopJS">https://github.com/garris/BackstopJS</a>).</li>
				<li><strong class="bold">API testing</strong> can be considered E2E testing, but just for the API your application might provide. Since the tests are based on <strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) requests, a headless browser is not needed, which makes the setup easier. A good choice to start with API testing is <strong class="bold">Codeception</strong> (https://codeception.com).</li>
				<li><strong class="bold">Behavior-driven development</strong> (<strong class="bold">BDD</strong>) is a very interesting approach because it focuses on the communication between stakeholders (for example, the project manager), QA (if there is any), and the developers. This is done by a special way of writing tests in a language called <strong class="bold">Gherkin</strong>, which basically enables non-technical people to write test suites. The BDD tool for PHP is called <strong class="bold">Behat</strong> (<a href="https://github.com/Behat/Behat">https://github.com/Behat/Behat</a>).</li>
			</ul>
		</div>
	</body></html>