- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Code Quality Tools
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码质量工具
- en: In the previous parts of this book, we learned the basics of clean code. Now,
    it is time to apply that knowledge to our everyday work. There are literally dozens
    of tools available for the PHP ecosystem that can help us detect flaws and potential
    bugs, apply the correct code styling, and generally inform us about quality issues.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几部分，我们学习了编写清洁代码的基础知识。现在，是时候将那些知识应用到我们的日常工作中了。对于PHP生态系统，实际上有数十种工具可以帮助我们检测缺陷和潜在的bug，应用正确的代码风格，并通常让我们了解质量方面的问题。
- en: To ensure a quick and easy start within the world of code quality tools, this
    section will introduce you to the most commonly used ones. For each, you will
    learn how to install, configure, and use it directly on your code. You will also
    learn about some useful extra features they provide.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在代码质量工具的世界中快速轻松地开始，本节将向你介绍最常用的工具。对于每一个，你将学习如何安装、配置和使用它直接在你的代码上。你还将了解它们提供的一些有用的额外功能。
- en: 'We will look at the following groups of tools:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下工具组：
- en: Syntax checking and code styling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法检查和代码风格
- en: Static code analysis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态代码分析
- en: IDE extensions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDE扩展
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you only need a bare minimum of tools to already be set up.
    The chances are high that you already have them installed if you have ever worked
    with PHP code before:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你只需要设置好最基本的一组工具。如果你之前曾经使用过PHP代码，那么你很可能已经安装了它们：
- en: A local installation of a recent PHP version (PHP 8.0 or higher is recommended).
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地安装最新版本的PHP（建议使用PHP 8.0或更高版本）。
- en: A code editor – often called an **Integrated Development Environment** (**IDE**).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个代码编辑器——通常被称为**集成开发环境**（**IDE**）。
- en: Composer, either installed as binary or globally. Please check [https://getcomposer.org/](https://getcomposer.org/)
    if you are not familiar with Composer yet.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Composer，无论是作为二进制安装还是全局安装。如果你还不熟悉Composer，请查看[https://getcomposer.org/](https://getcomposer.org/)。
- en: 'Please note that for the rest of this book, all examples are based on a Linux
    environment such as Ubuntu or macOS. If you are using Windows for development,
    you will most likely need to make some adjustments, as described here: https://www.php.net/manual/en/install.windows.commandline.php.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本书的其余部分，所有示例都是基于Linux环境，如Ubuntu或macOS。如果你使用Windows进行开发，你很可能需要做一些调整，如这里所述：[https://www.php.net/manual/en/install.windows.commandline.php](https://www.php.net/manual/en/install.windows.commandline.php)。
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Clean-Code-in-PHP](https://github.com/PacktPublishing/Clean-Code-in-PHP)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Clean-Code-in-PHP](https://github.com/PacktPublishing/Clean-Code-in-PHP)
- en: Syntax checking and code styling
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法检查和代码风格
- en: The first group of tools we want to discuss helps us keep our code syntactically
    correct (i.e., it can be executed correctly by PHP) and formatted in a structured
    way. It seems to be obvious that the code needs to be written without errors,
    but it is always good to double-check, as some tools can actively change your
    code. Having a simple and fast way to ensure this will be essential when we automate
    the whole code quality process later in this book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要讨论的第一组工具帮助我们保持代码在语法上正确（即，可以被PHP正确执行）并以结构化的方式格式化。代码需要无错误地编写似乎是显而易见的，但总是好的进行双重检查，因为一些工具可以主动更改你的代码。在我们稍后在本书中自动化整个代码质量过程时，有一个简单快捷的方式来确保这一点将是至关重要的。
- en: Having your code formatted following a common style guide reduces the effort
    required to read and understand your code, as well as the code of others. Especially
    when you are working in a team, an accepted style guide saves you hours of discussions
    about how to correctly format the code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 按照一个通用的风格指南格式化你的代码可以减少阅读和理解代码，以及他人代码所需的努力。特别是当你在一个团队中工作时，一个被接受的风格指南可以节省你数小时的讨论，关于如何正确格式化代码。
- en: 'We will learn about the following tools:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习以下工具：
- en: A PHP built-in linter
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP内置的linter
- en: The PHP CS Fixer tool
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP CS Fixer工具
- en: The PHP built-in linter
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP内置的linter
- en: 'The first tool we want to look at is actually not a code quality tool of its
    own but rather an option built into the PHP binary itself: the Linter. It checks
    any code for syntax errors without executing it. This is particularly useful to
    ensure that the code works after refactoring sessions or when your code has been
    changed by an external tool.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要首先探讨的工具实际上并不是一个独立的代码质量工具，而是一个内置在PHP二进制文件中的选项：Linter。它检查任何代码的语法错误而不执行它。这在确保代码在重构会话之后或代码被外部工具更改后仍然可以工作特别有用。
- en: Installation and usage
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装和使用
- en: 'Since the Linter is already part of your PHP installation, we can immediately
    start using it by looking at an example. If you look closely, you will probably
    notice the error the author made in the following class example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Linter 已经是 PHP 安装的一部分，我们可以通过查看一个示例立即开始使用它。如果您仔细观察，您可能会注意到作者在以下类示例中犯的错误：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Do not worry if you do not spot the error immediately – that is precisely what
    the Linter is there for! Simply pass the full name and path of the file to be
    checked to the PHP binary, using the `-l` option. By adding the `-f` option, PHP
    will also check for fatal errors, which is something we want. Both options can
    be combined into `-lf`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有立即发现错误，请不要担心——这正是 Linter 存在的原因！只需使用 `-l` 选项将待检查文件的完整名称和路径传递给 PHP 二进制文件。通过添加
    `-f` 选项，PHP 还会检查致命错误，这是我们想要的。这两个选项可以组合为 `-lf`。
- en: 'Let us assume the preceding class can be found in the `example.php` file in
    the current folder – then, all we need to type is the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设前面的类可以在当前文件夹中的 `example.php` 文件中找到——那么，我们只需要输入以下内容：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will get the following output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can tell the linter to check a complete directory as well:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以让代码检查器检查整个目录：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The built-in PHP linter stops on the first error – as in, it will not give you
    a full list of all the detected errors. So, you better make sure to run the command
    again after resolving the issue.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 PHP 代码检查器会在第一个错误处停止——也就是说，它不会给出所有检测到的错误的全列表。所以，在解决问题后，您最好再次运行命令。
- en: A recap of the PHP built-in Linter
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP 内置 Linter 的回顾
- en: The built-in PHP linter is a handy tool for quick code checks but cannot do
    much more than that. There are other more sophisticated linters such as [https://github.com/overtrue/phplint](https://github.com/overtrue/phplint).
    Not only will this one return a full list of errors but it can also run multiple
    processes in parallel, which will be noticeably faster on large code bases. However,
    other code quality tools already include a linter, such as the tool that we will
    check in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 PHP 代码检查器是一个方便的工具，可以快速检查代码，但它的功能并不仅限于此。还有其他更复杂的代码检查器，例如 [https://github.com/overtrue/phplint](https://github.com/overtrue/phplint)。这个工具不仅会返回一个完整的错误列表，还可以并行运行多个进程，这在大型代码库上会明显更快。然而，其他代码质量工具已经包含了代码检查器，例如我们将在下一节检查的工具。
- en: 'PHP CS Fixer: a code sniffer'
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP CS Fixer：一个代码嗅探器
- en: Another essential tool is a code sniffer. It scans PHP code for coding standard
    violations and other bad practices. *PHP CS Fixer* ([https://github.com/FriendsOfPHP/PHP-CS-Fixer](https://github.com/FriendsOfPHP/PHP-CS-Fixer))
    is a viable choice to start with, since, as the name already implies, it not only
    reports the findings but also fixes them right away.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个必不可少的工具是代码嗅探器。它扫描 PHP 代码中的编码标准违规和其他不良实践。*PHP CS Fixer* ([https://github.com/FriendsOfPHP/PHP-CS-Fixer](https://github.com/FriendsOfPHP/PHP-CS-Fixer))
    是一个可行的起点，因为正如其名所暗示的，它不仅报告发现的问题，还可以立即修复它们。
- en: Other code sniffers
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 其他代码嗅探器
- en: '*PHP CS Fixer* is not the only available code sniffer. Another well-known one
    is the *PHP_CodeSniffer* ([https://github.com/squizlabs/PHP_CodeSniffer](https://github.com/squizlabs/PHP_CodeSniffer)),
    which we can fully recommend using as well.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*PHP CS Fixer* 并不是唯一的代码嗅探器。另一个广为人知的是 *PHP_CodeSniffer* ([https://github.com/squizlabs/PHP_CodeSniffer](https://github.com/squizlabs/PHP_CodeSniffer))，我们也可以强烈推荐使用它。'
- en: Installation and usage
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装和使用
- en: 'Using Composer, the installation is straightforward:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Composer，安装过程非常简单：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Alternatives to Composer
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Composer 的替代方案
- en: There are multiple ways to install the tools we will introduce in this book.
    We will also check more options out later in this book.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将介绍多种安装工具的方法。我们将在本书的后面部分检查更多选项。
- en: 'The typical use case for code sniffers is to take care of the placement of
    brackets and the number of indentations, whether they’re whitespaces or tabs.
    Let’s check out the following PHP file with its ugly format:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码嗅探器的典型用途是处理括号的放置和缩进的数量，无论是空格还是制表符。让我们检查以下具有丑陋格式的 PHP 文件：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we run the code sniffer with its default settings, the command is nice and
    short:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用默认设置运行代码嗅探器，命令既简洁又简短：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will scan and fix the `example.php` file all in one go, leaving our code
    neat and shiny:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将一次性扫描并修复 `example.php` 文件，使我们的代码整洁且光亮：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you do not want to fix the file immediately, you can use the `--dry-run`
    option to just scan for issues. Add the `-v` option as well, to display the findings:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想立即修复文件，可以使用 `--dry-run` 选项仅扫描问题。同时添加 `-v` 选项，以显示发现的内容：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As with all code quality tools, you can also run it on all the files in a folder.
    The following command will scan the `src` folder recursively, so all subfolders
    are scanned as well:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有代码质量工具一样，你还可以在文件夹中的所有文件上运行它。以下命令将递归地扫描 `src` 文件夹，因此所有子文件夹也会被扫描：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Rules and rulesets
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则和规则集
- en: So far, we used *PHP CS Fixer* with its default settings. Before we can change
    these defaults, let us have a closer look at how it knows what to check and fix.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的是 *PHP CS Fixer* 的默认设置。在我们改变这些默认设置之前，让我们更仔细地看看它是如何知道要检查和修复什么的。
- en: A common pattern within code quality tools is the organization of rules within
    rulesets. A rule is a simple instruction that tells *PHP CS Fixer* how our code
    should be formatted regarding a certain aspect. For example, if we want to make
    use of strict types in PHP, every PHP file should contain the `declare(strict_types=1);`
    instruction.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码质量工具中，规则在规则集中的组织是一个常见的模式。规则是一个简单的指令，告诉 *PHP CS Fixer* 我们应该如何格式化代码的某个方面。例如，如果我们想在PHP中使用严格类型，每个PHP文件都应该包含
    `declare(strict_types=1);` 指令。
- en: 'There is a rule in *PHP CS Fixer* that can be used to force this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *PHP CS Fixer* 中有一个规则可以强制执行：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This command will check each file in `src` and add `declare(strict_types=1);`
    after the opening PHP tag.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将检查 `src` 中的每个文件，并在PHP标签后添加 `declare(strict_types=1);`。
- en: Since a coding standard such as PSR-12 ([https://www.php-fig.org/psr/psr-12/](https://www.php-fig.org/psr/psr-12/))
    includes many instructions on how the code should be formatted, it would be cumbersome
    to add all these rules to the preceding command. That is why rulesets have been
    introduced, which are simply a combination of rules, and even other rulesets.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于像PSR-12 ([https://www.php-fig.org/psr/psr-12/](https://www.php-fig.org/psr/psr-12/))
    这样的编码标准包含了大量关于代码应该如何格式化的指令，将这些规则全部添加到前面的命令中会显得很繁琐。这就是为什么引入了规则集，它们只是规则的组合，甚至还可以是其他规则集的组合。
- en: 'If we want to format code following PSR-12 explicitly, we can just run this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想明确按照PSR-12格式化代码，我们可以直接运行这个命令：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, a ruleset is indicated by the `@` symbol.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，规则集是通过 `@` 符号指示的。
- en: Rules and ruleset documentation
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 规则和规则集文档
- en: 'It is impossible to discuss every rule and ruleset for *PHP CS Fixer* within
    the scope of this book. If you are curious about what else it has to offer, please
    check out the official GitHub repository: [https://github.com/FriendsOfPHP/PHP-CS-Fixer/tree/master/doc](https://github.com/FriendsOfPHP/PHP-CS-Fixer/tree/master/doc)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的范围内不可能讨论 *PHP CS Fixer* 的每个规则和规则集。如果您对它还能提供什么感兴趣，请查看官方GitHub仓库：[https://github.com/FriendsOfPHP/PHP-CS-Fixer/tree/master/doc](https://github.com/FriendsOfPHP/PHP-CS-Fixer/tree/master/doc)
- en: Configuration
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置
- en: 'Executing commands manually is fine to start with, but at some point, we will
    not want to remember all the options every time. That is where configuration files
    come into play: most PHP code quality tools allow us to store the desired configuration
    in one or more files and in various formats, such as YAML, XML, or plain PHP.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 手动执行命令可以作为一个起点，但到了某个阶段，我们可能不想每次都记住所有的选项。这时配置文件就派上用场了：大多数PHP代码质量工具允许我们将所需的配置存储在一个或多个文件中，并支持多种格式，例如YAML、XML或纯PHP。
- en: 'For *PHP CS Fixer*, all the relevant settings can be controlled via the `.php-cs-fixer.dist.php`
    configuration file. Here, you will find an example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *PHP CS Fixer*，所有相关设置都可以通过 `.php-cs-fixer.dist.php` 配置文件来控制。在这里，您将找到一个示例：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Numerous things are happening here. Firstly, an instance of `PhpCsFixer\Finder`
    is created, which is configured to use the same directory to look for PHP files
    where this configuration file is located. As the `root` folder of the application
    is usually located here, we may want to exclude certain subdirectories (such as
    `templates` in this example) from being scanned.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了许多事情。首先，创建了一个 `PhpCsFixer\Finder` 的实例，该实例被配置为使用与配置文件相同的目录来查找PHP文件。由于应用程序的
    `root` 文件夹通常位于此处，我们可能希望排除某些子目录（例如本例中的 `templates`）不被扫描。
- en: Secondly, an instance of `PhpCsFixer\Config` is created. Here, we tell *PHP
    CS Fixer* which rules and rulesets to apply. We already discussed the `@PSR-12`
    ruleset, as well as the `declare_strict_types` rule. The `array_syntax` rule forces
    the usage of the short array syntax.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，创建了一个 `PhpCsFixer\Config` 的实例。在这里，我们告诉 *PHP CS Fixer* 应该应用哪些规则和规则集。我们已经讨论了
    `@PSR-12` 规则集以及 `declare_strict_types` 规则。`array_syntax` 规则强制使用短数组语法。
- en: You may have noticed that the name of the configuration file, `.php-cs-fixer.dist.php`,
    contains the abbreviation `dist`. This stands for distribution and usually indicates
    that this file is the one the project gets distributed with. In other words, this
    is the file that gets added to the Git repository and is immediately available
    after checkout.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到配置文件名，`.php-cs-fixer.dist.php`，包含缩写 `dist`。这代表分发，通常表示此文件是项目分发的文件。换句话说，这是添加到
    Git 仓库并在检出后立即可用的文件。
- en: If you want to use your own configuration on your local system, you can create
    a copy of it and rename it `.php-cs-fixer.php`. If this file exists, *PHP CS Fixer*
    will use it instead of `dist-file`. It is good practice to let Git ignore this
    file. Otherwise, you might accidentally add your local settings to the repository.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在本地系统上使用自己的配置，可以创建它的副本并将其重命名为 `.php-cs-fixer.php`。如果此文件存在，*PHP CS Fixer*
    将使用它而不是 `dist-file`。让 Git 忽略此文件是一个好习惯。否则，您可能会意外地将本地设置添加到仓库中。
- en: Advanced usage
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级用法
- en: 'The ability of *PHP CS Fixer* does not stop at automatically fixing coding
    standard violations. It can also be used to apply small refactoring tasks. One
    great use case, for example, is the automated migration to a higher PHP version:
    *PHP CS Fixer* ships with migration rulesets, which can introduce some new language
    features to your code base.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*PHP CS Fixer* 的能力不仅限于自动修复编码标准违规。它还可以用于应用小的重构任务。一个很好的用例，例如，是自动迁移到更高的 PHP 版本：*PHP
    CS Fixer* 随附迁移规则集，可以将一些新的语言特性引入到您的代码库中。'
- en: 'For example, with PHP 8.0, it is possible to use the `class` keyword instead
    of the `get_class()` function. *PHP CS Fixer* can scan your code and replace certain
    lines – for example, see the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 PHP 8.0 中，可以使用 `class` 关键字代替 `get_class()` 函数。*PHP CS Fixer* 可以扫描您的代码并替换某些行——例如，请参见以下内容：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It can replace the preceding line with this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以将前面的行替换为以下内容：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The migration rulesets are separated into non-risky and risky ones. Risky rulesets
    can potentially cause side effects, while non-risky ones usually do not cause
    any problems. A good example of a risky change is the `declare_strict_types` rule
    we discussed previously. Be sure to test your application thoroughly after applying
    them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移规则集被分为无风险和有风险两类。有风险的规则集可能会引起副作用，而无风险的规则集通常不会引起任何问题。一个有风险的更改的例子是我们之前讨论过的 `declare_strict_types`
    规则。在应用它们之后，务必彻底测试您的应用程序。
- en: The capabilities of these migrations are limited – your code will not suddenly
    include all new PHP version features.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些迁移的能力有限——您的代码不会突然包含所有新的 PHP 版本特性。
- en: Code fixers cannot fix syntax errors for us. For example, the `Example` class
    that we checked with PHP’s built-in linter in the previous section would still
    require the developer to manually fix it first.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码修复器不能为我们修复语法错误。例如，我们在上一节中用 PHP 内置的代码检查器检查的 `Example` 类仍然需要开发者先手动修复。
- en: Linting
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查
- en: '*PHP CS Fixer* checks the files that you want to have sniffed for syntax errors
    as the very first step and will not apply any changes in case it finds syntax
    errors. This means that you do not have to run the PHP built-in linter as an additional
    step.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*PHP CS Fixer* 将检查您希望进行语法检查的文件，这是第一步，如果发现语法错误，将不会应用任何更改。这意味着您不需要作为额外步骤运行 PHP
    内置的代码检查器。'
- en: A recap of PHP CS Fixer
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP CS Fixer 概述
- en: A code sniffer such as *PHP CS Fixer* should be part of every serious PHP project.
    The ability to fix rule violations automatically will save you many hours of work.
    If you chose not to apply any risky fixes, it will hardly cause any problems at
    all.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 代码嗅探器，如 *PHP CS Fixer*，应该是每个严肃的 PHP 项目的组成部分。自动修复规则违规的能力可以为您节省许多工作时间。如果您选择不应用任何有风险的修复，几乎不会引起任何问题。
- en: We have now learned how to ensure that our code is well-formatted and syntactically
    correct. While this is the foundation of any high-quality code, it does not help
    us to avoid bugs or maintainability issues. At this point, Static code analysis
    tools come into play.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何确保我们的代码格式良好且语法正确。虽然这是任何高质量代码的基础，但它并不能帮助我们避免错误或维护性问题。在这个时候，静态代码分析工具就派上用场了。
- en: Static Code Analysis
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态代码分析
- en: Static Code Analysis means that the only source of information is the code itself.
    Just by scanning the source code, these tools will find issues and problems that
    even the most senior developer in your team would miss during a code review.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析意味着唯一的信息来源是代码本身。仅通过扫描源代码，这些工具就能发现即使是团队中最资深的开发者也可能在代码审查中遗漏的问题和问题。
- en: 'These are the tools we would like to introduce you to in the next sections:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将在下一节中向您介绍的工具：
- en: phpcpd
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: phpcpd
- en: PHPMD
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHPMD
- en: PHPStan
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHPStan
- en: Psalm
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诗篇
- en: phpcpd – the copy and paste detector
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: phpcpd – 复制粘贴检测器
- en: Copy and paste programming can be anything from simply annoying to a real threat
    to your projects. Bugs, security issues, and bad practices will get copied around
    and thus become harder to fix. Think of it as though it were a plague spreading
    through your code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 复制粘贴编程可能从简单的烦恼到对项目构成的真实威胁。错误、安全问题和不规范的做法会被复制并因此变得更加难以修复。把它想象成一种通过你的代码传播的瘟疫。
- en: This form of programming is quite common, especially among less experienced
    developers, or in projects where the deadlines are very tight. Luckily, our clean
    code toolkit offers a remedy – the **PHP copy and paste detector** (**phpcpd**).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程形式相当常见，尤其是在经验较少的开发者中，或者在截止日期非常紧张的项目中。幸运的是，我们的清洁代码工具包提供了一种补救措施——**PHP复制粘贴检测器**（**phpcpd**）。
- en: Installation and usage
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装和使用
- en: 'This tool can only be downloaded as *a self-containing PHP archive* (`phar`),
    so we will not use Composer to install it this time:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具只能作为*自包含的PHP存档*（`phar`）下载，因此这次我们不会使用Composer来安装它：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Handling phar files
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 处理phar文件
- en: In [*Chapter 9*](B19050_09.xhtml#_idTextAnchor115), *Organizing PHP Quality
    Tools*, we will learn how to keep `phar` files organized. For now, it’s enough
    to just download it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B19050_09.xhtml#_idTextAnchor115)“组织PHP质量工具”中，我们将学习如何保持`phar`文件的组织。现在，只需下载它就足够了。
- en: 'Once downloaded, *phpcpd* can be used immediately without further configuration.
    It just requires the path of the target directory as a parameter. The following
    example shows how to scan the `src` directory for so-called “clones” (i.e., code
    that has been copied multiple times). Let’s execute it with the default settings
    first:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，*phpcpd*可以立即使用，无需进一步配置。它只需要目标目录的路径作为参数。以下示例展示了如何使用默认设置扫描`src`目录中的所谓“克隆”（即被多次复制的代码）。让我们首先以默认设置执行它：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If *phpcpd* does not detect any clones, it is worth checking the two options,
    `min-lines` and `min-tokens`, that control its “pickiness”:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*phpcpd*没有检测到任何克隆，值得检查控制其“挑剔性”的两个选项，`min-lines`和`min-tokens`：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `min-lines` option allows us to set the minimum number of lines a piece
    of code needs to have until it is considered a clone.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`min-lines`选项允许我们设置一个代码片段需要具有的最小行数，直到它被视为克隆。'
- en: 'To understand the usage of `min-tokens`, we must clarify the meaning of a token
    in this context first: when you execute a script, PHP will internally use a so-called
    “tokenizer” to split the source code up into single tokens. A token is an independent
    component of your PHP program, such as a keyword, an operator, a constant, or
    a string. Think of them as words in human language. The `min-tokens` option therefore
    controls the number of instructions a piece of code contains before it is considered
    a clone.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`min-tokens`的用法，我们首先必须明确在这个上下文中“标记”的含义：当你执行脚本时，PHP会内部使用所谓的“标记化器”将源代码分割成单个标记。标记是PHP程序的一个独立组件，例如关键字、运算符、常量或字符串。把它们想象成人类语言中的单词。因此，`min-tokens`选项控制代码在被视为克隆之前包含的指令数量。
- en: You may want to play around with both parameters to find a good balance of “pickiness”
    for your code base. A certain amount of redundancy in your code is not automatically
    a problem and you also do not want to bother your fellow developers too much.
    Using the defaults to start with, therefore, is a good choice.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想尝试调整这两个参数，以找到适合你的代码库的“挑剔性”的良好平衡。代码中的某些冗余并不一定是问题，你也不想过多地打扰你的同事。因此，从默认设置开始是一个不错的选择。
- en: Further options
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步的选项
- en: 'There are two more options you should be aware of:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该了解两个额外的选项：
- en: '`--exclude <path>`: Excludes a path from the analysis. For example, unit tests
    often contain a lot of copy-and-paste code, so you want to exclude the `tests`
    folder. If you need to exclude multiple paths, the options can be given multiple
    times.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--exclude <path>`：从分析中排除一个路径。例如，单元测试通常包含大量的复制粘贴代码，所以你想排除`tests`文件夹。如果你需要排除多个路径，选项可以多次给出。'
- en: '`--fuzzy`: With this especially useful option, *phpcpd* will obfuscate the
    variable names when performing its check. This way, clones will be detected even
    if the variable names have been changed by a smart but lazy colleague.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--fuzzy`: 使用这个特别有用的选项，*phpcpd* 在执行检查时会混淆变量名。这样，即使变量名被一个聪明但懒惰的同事更改，也能检测到克隆。'
- en: Recap of phpcpd
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: phpcpd 概述
- en: Although *phpcpd* is easy to use, it is a significant help against the slow
    spread of copy and paste code in your projects. That is why we recommend adding
    it to your clean coder toolkit.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 *phpcpd* 使用简单，但它对项目中复制粘贴代码的缓慢传播具有重大帮助。这就是为什么我们建议将其添加到您的清洁编码工具包中。
- en: 'PHPMD: the PHP mess detector'
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHPMD：PHP 混乱检测器
- en: A mess detector will scan code for potential issues, also known as “code smells”
    – parts of code that can introduce bugs, unexpected behavior, or are, in general,
    harder to maintain. As with the code style, there are certain rules that should
    be followed to avoid problems. The mess detector applies those rules to our code.
    The standard tool in the PHP ecosystem for this is *PHPMD*, which we will show
    you in this section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 混乱检测器会扫描代码中的潜在问题，也称为“代码异味”——这些是可能导致错误、意外行为或通常更难维护的代码部分。与代码风格一样，有一些规则应该遵循以避免问题。混乱检测器将这些规则应用于我们的代码。PHP生态系统中的标准工具是
    *PHPMD*，我们将在本节中向您展示。
- en: Installation and usage
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装和使用
- en: 'Before we take a closer look at what this tool has to offer for us, let us
    install it first using Composer:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更详细地了解这个工具为我们提供的内容之前，让我们首先使用Composer安装它：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After the installation is complete, we can run *PHPMD* already on the command
    line. It requires three arguments:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以在命令行上运行 *PHPMD*。它需要三个参数：
- en: The filename or path to scan (e.g., `src`). Multiple locations can be comma-separated.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要扫描的文件名或路径（例如，`src`）。多个位置可以用逗号分隔。
- en: 'One of the following formats in which the report should be generated: `html`,
    `json`, `text`, or `xml`.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告应生成的以下格式之一：`html`、`json`、`text` 或 `xml`。
- en: One or more built-in rulesets or ruleset XML files (comma-separated).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个内置规则集或规则集XML文件（逗号分隔）。
- en: 'For a quick start, let’s scan the `src` folder, create the output as text,
    and use the built-in `cleancode` and `codesize` rulesets. We can do this by running
    the following command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速入门，让我们扫描 `src` 文件夹，创建文本输出，并使用内置的 `cleancode` 和 `codesize` 规则集。我们可以通过运行以下命令来完成此操作：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*PHPMD* writes all output to the standard output (`stdout`), which is on the
    command line. However, all output formats except `text` are not meant to be read
    there. If you want to get a first overview, you may want to use the `html` output,
    as it generates a nicely formatted and interactive report. To store the output
    in a file, we will redirect it to a file using the `>` operator as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*PHPMD* 将所有输出写入标准输出（`stdout`），这在命令行上。然而，除了 `text` 格式之外的所有输出格式都不适合在那里阅读。如果您想获得一个初步的概述，您可能想使用
    `html` 输出，因为它会生成格式良好且交互式的报告。要将输出存储在文件中，我们将使用以下方式将其重定向到文件：使用 `>` 操作符。'
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Simply open the HTML file on your browser and you will see a report similar
    to the one shown in *Figure 7.1*:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地打开您的浏览器上的HTML文件，您将看到类似于 *图7.1* 中所示的报告：
- en: '![Figure 7.1: A PHPMD HTML report in a browser](img/Figure_7.01_B19050.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：浏览器中的PHPMD HTML报告](img/Figure_7.01_B19050.jpg)'
- en: 'Figure 7.1: A PHPMD HTML report in a browser'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：浏览器中的PHPMD HTML报告
- en: The report is interactive, so make sure to click on buttons such as **Show details**
    or **Show code** to display all the information there is.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 报告是交互式的，所以请确保点击按钮，如**显示详细信息**或**显示代码**，以显示所有信息。
- en: Rules and rulesets
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则和规则集
- en: In the preceding example, we used the built-in `cleancode` and `codesize` rulesets.
    Firstly, the rulesets are named according to the problem domain the rules check
    – as in, for the `cleancode` rule, you will only find rules that help to keep
    the code base clean. However, you can still end up with huge classes with many
    complex functions. To avoid this, adding the `codesize` ruleset is necessary.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了内置的 `cleancode` 和 `codesize` 规则集。首先，规则集的命名是根据规则检查的问题域来命名的——例如，对于
    `cleancode` 规则，您将只能找到帮助保持代码库清洁的规则。然而，您仍然可能遇到具有许多复杂函数的大类。为了避免这种情况，添加 `codesize`
    规则集是必要的。
- en: 'The following table shows the available rulesets and their usage:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了可用的规则集及其用法：
- en: '| **Ruleset** | **Short name** | **Description** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **规则集** | **简称** | **描述** |'
- en: '| Clean code rules | `cleancode` | Enforces clean code in general |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 清洁代码规则 | `cleancode` | 强制执行一般清洁代码 |'
- en: '| Code size rules | `codesize` | Checks for long or complex code blocks |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 代码大小规则 | `codesize` | 检查长或复杂的代码块 |'
- en: '| Controversial rules | `controversial` | Checks for best and bad practices
    where there are controversial opinions about them |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 有争议的规则 | `controversial` | 检查存在争议意见的最佳和不良实践 |'
- en: '| Design rules | `design` | Helps find software design-related issues |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 设计规则 | `design` | 帮助发现与软件设计相关的问题 |'
- en: '| Naming rules | `naming` | Avoids names that are too long or short |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 命名规则 | `naming` | 避免过短或过长的名称 |'
- en: '| Unused code rules | `unused` | Detects unused code that can be deleted |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 未使用代码规则 | `unused` | 检测可以删除的未使用代码 |'
- en: 'Table 7.1: PHPMD rulesets'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1：PHPMD 规则集
- en: These built-in rules can simply be used by giving the aforementioned short names
    as arguments to the function call, as seen in the previous example.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内置规则可以通过将上述简短名称作为函数调用的参数来简单地使用，正如先前的例子所示。
- en: If you are lucky enough to start a project on the green (i.e., from scratch),
    you can and should enforce as many rules from the beginning as you can. This will
    keep your code base clean right from the beginning. For existing projects, the
    effort is a bit greater, as we will see in the next section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你足够幸运，可以从零开始（即从头开始）启动一个项目，那么你可以并且应该从一开始就尽可能多地强制执行规则。这将使你的代码库从一开始就保持清洁。对于现有项目，所需的努力会更大，我们将在下一节中看到。
- en: Using PHPMD in legacy projects
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在遗留项目中使用 PHPMD
- en: Often enough, you want to use *PHPMD* for an existing project, though. In this
    case, you will most likely be overwhelmed by the countless warnings that it will
    throw upon the first run. Do not give up – there are some options to help you!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你可能会想要在一个现有的项目中使用 *PHPMD*。在这种情况下，你可能会在第一次运行时被它抛出的无数警告所淹没。不要放弃——有一些选项可以帮助你！
- en: Adjusting rulesets
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调整规则集
- en: If you plan to add *PHPMD* to an existing project, going all-in with the rulesets
    will surely lead to frustration because of how many issues are reported. You may
    want to concentrate on one or two rulesets at a time instead.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划将 *PHPMD* 添加到现有项目中，一次性使用所有规则集肯定会因为报告的问题数量而让你感到沮丧。你可能一次只想集中在一到两个规则集上。
- en: It is also highly likely that you will end up with rules that you find annoying
    or counter-productive at first – for example, the `ElseExpression` rule, which
    forbids the usage of `else` in an `if` expression. Leaving the discussion about
    the usefulness of this rule aside, the effort of rewriting countless statements
    that are working fine is not worth it. So, if you don’t want to use that rule
    in your project, you need to create your own ruleset.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你也很可能最终会得到一些你一开始觉得烦人或反生产力的规则——例如，`ElseExpression` 规则，它禁止在 `if` 表达式中使用 `else`。抛开这个规则是否有用的讨论，重写无数运行良好的语句的努力是不值得的。所以，如果你不想在你的项目中使用那个规则，你需要创建自己的规则集。
- en: 'Rulesets are configured via XML files, which specify the rules that belong
    in them. Each rule is basically a PHP class that contains the rule logic. The
    following XML file defines a custom ruleset that just includes the `cleancode`
    and `codesize` rulesets:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 规则集通过 XML 文件进行配置，这些文件指定了属于它们的规则。每个规则基本上是一个包含规则逻辑的 PHP 类。以下 XML 文件定义了一个自定义规则集，它仅包括
    `cleancode` 和 `codesize` 规则集：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: XML seems to be a bit out of fashion nowadays, but it still serves its purpose
    well. You usually do not need to worry about all the attributes of the `<ruleset>`
    tag – just make sure that they are present. The `<description>` tag can contain
    any text that you deem to be a good description for the ruleset.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 XML 似乎已经过时了，但它仍然很好地完成了它的任务。你通常不需要担心 `<ruleset>` 标签的所有属性——只需确保它们存在即可。《description>`
    标签可以包含任何你认为是对规则集的良好描述的文本。
- en: The `<rule>` tag is important for us. In the preceding example, we referenced
    both the `codesize` and `cleancode` rules.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`<rule>` 标签对我们来说很重要。在先前的例子中，我们引用了 `codesize` 和 `cleancode` 规则。'
- en: Tip
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: At this point, it is a good idea to dig through the built-in rule sets in the
    GitHub repository https://github[.com/phpmd/phpmd/tree/master/src/main/resources/rulesets](https://github.com/phpmd/phpmd/tree/master/src/main/resources/rulesets).
    Thanks to XML being a quite verbose file format, you will get familiar with it
    very quickly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，深入挖掘 GitHub 仓库 https://github[.com/phpmd/phpmd/tree/master/src/main/resources/rulesets](https://github.com/phpmd/phpmd/tree/master/src/main/resources/rulesets)
    中内置的规则集是个好主意。由于 XML 是一个非常冗长的文件格式，你将很快熟悉它。
- en: 'Imagine we want to remove the mentioned `ElseExpression` rule from our checks.
    To achieve this, you just need to add an `<exclude>` tag within the according
    `<rule>` tag as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要从检查中移除提到的`ElseExpression`规则。为了实现这一点，你只需在相应的`<rule>`标签内添加一个`<exclude>`标签，如下所示：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This way, you can exclude as many rules from a ruleset as necessary. If you
    just want to pick certain rules from different rulesets, you can also go the other
    way round and reference the desired rules directly. If you want your custom ruleset
    to only include the `StaticAccess` and `UndefinedVariable` rules, your XML file
    should contain the following two tags:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以从规则集中排除必要的规则。如果你只想从不同的规则集中选择某些规则，你也可以反过来直接引用所需的规则。如果你想让你的自定义规则集只包含`StaticAccess`和`UndefinedVariable`规则，你的XML文件应该包含以下两个标签：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: One last important thing to know about the XML configuration files is how to
    change the individual properties of a rule. Again, a good way to figure out all
    the properties is to check out the actual ruleset file. Alternatively, you can
    check out the actual PHP classes of each rule at [https://github.com/phpmd/phpmd/tree/master/src/main/php/PHPMD/Rule](https://github.com/phpmd/phpmd/tree/master/src/main/php/PHPMD/Rule).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 关于XML配置文件，还有最后一个重要的事情要知道，那就是如何更改规则的单个属性。同样，了解所有属性的一个好方法是查看实际的规则集文件。或者，你也可以查看每个规则的PHP类，具体可以在[https://github.com/phpmd/phpmd/tree/master/src/main/php/PHPMD/Rule](https://github.com/phpmd/phpmd/tree/master/src/main/php/PHPMD/Rule)找到。
- en: 'A typical example is to define exceptions for the `StaticAccess` rule. It is
    usually good practice to avoid static access, but often enough, you can’t avoid
    it. Let us say your team agreed on allowing static access for the `DateTime` and
    `DateTimezone` objects – you can simply configure this as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子是为`StaticAccess`规则定义异常。通常，避免静态访问是一个好的做法，但通常情况下，你无法避免。假设你的团队同意允许`DateTime`和`DateTimezone`对象使用静态访问，你可以简单地按照以下方式配置：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To use this custom ruleset in the future, simply save the preceding XML in
    a file (usually called `phpmd.xml`) and pass it over to *PHPMD* upon the next
    run:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要在未来使用此自定义规则集，只需将前面的XML保存到文件中（通常称为`phpmd.xml`），并在下一次运行*PHPMD*时传递它：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Location of the configuration file
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件的存储位置
- en: It is a common practice to place `phpmd.xml` with the rulesets you want to use
    in the `root` folder of your project and use it as the single source of configuration.
    If there are any modifications in the future, you only have to adjust one central
    file.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将`phpmd.xml`（包含你想要使用的规则集）放置在项目的`root`文件夹中，并将其用作配置的唯一来源，这是一种常见的做法。如果将来有任何修改，你只需要调整一个中央文件。
- en: Suppressing warnings
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 抑制警告
- en: Another useful tool for dealing with legacy code is the `@SuppressWarnings`
    DocBlock annotation. Let us assume one class in your project makes use of a static
    method call and that cannot be changed right now. By default, any static access
    will throw a warning. Since you do not want to use static access anywhere else
    in your code, but just in this class, removing the `StaticAccess` rule would be
    counterproductive.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 处理遗留代码的另一个有用工具是`@SuppressWarnings` DocBlock注解。假设你的项目中有一个类使用了静态方法调用，但目前无法更改。默认情况下，任何静态访问都会抛出警告。由于你不想在代码的其他地方使用静态访问，而只是在当前类中使用，因此移除`StaticAccess`规则将适得其反。
- en: 'In these cases, you can make use of the `@SuppressWarnings` annotation:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，你可以使用`@SuppressWarnings`注解：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can use multiple annotations in one DocBlock if required. Finally, if you
    want to suppress any warnings on a class, just use the `@SuppressWarnings(PHPMD)`
    annotation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你可以在一个DocBlock中使用多个注解。最后，如果你想在一个类上抑制任何警告，只需使用`@SuppressWarnings(PHPMD)`注解。
- en: Be aware that using the `Suppress` annotations should be your last resort. It
    is very tempting to just add it everywhere. However, it will silence the output,
    but it will not solve the problems.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`Suppress`注解应该是你的最后选择。它非常有诱惑力，可以随意添加。然而，它将使输出静音，但不会解决问题。
- en: Accepting violations
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接受违规
- en: Instead of suppressing warnings at the file level or excluding rules from rulesets,
    you can also decide to acknowledge existing violations. For example, when you
    want to use *PHPMD* on a legacy project, you can decide to ignore all violations
    that are already in the code for now. However, if new violations are introduced
    by a new class, they will be reported.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在文件级别抑制警告或从规则集中排除规则之外，你也可以选择承认现有的违规。例如，当你想在遗留项目中使用*PHPMD*时，你可以决定暂时忽略代码中已经存在的所有违规。然而，如果新的类引入了新的违规，它们将被报告。
- en: 'Luckily, *PHPMD* makes this task quite easy by providing a so-called baseline
    file, which it will generate for you automatically by running the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，*PHPMD* 通过提供一个所谓的基线文件，使得这项任务变得相当简单，该文件会通过运行以下命令自动为您生成：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding command, we expect that a `phpmd.xml` file already exists in
    the project `root` folder. Using the preceding command, *PHPMD* will now create
    a file called `phpmd.baseline.xml`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们期望在项目 `root` 文件夹中已经存在一个 `phpmd.xml` 文件。使用前面的命令，*PHPMD* 现在将创建一个名为 `phpmd.baseline.xml`
    的文件。
- en: 'Now, you may run the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以运行以下命令：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The next time, *PHPMD* will automatically detect the previously generated baseline
    file and use it to suppress all warnings accordingly. However, if a new rule violation
    is introduced in a new location, it will still be detected and reported as a violation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下次，*PHPMD* 将自动检测之前生成的基线文件，并使用它来抑制所有警告。然而，如果在新位置引入了新的规则违规，它仍然会被检测并报告为违规。
- en: 'A word of warning: as with the `@SuppressWarning` annotation, the baseline
    feature is not a tool that can be used once and safely ignored in the future.
    The problematic code blocks are still part of your project as technical debt with
    all the negative effects. That is why if you decide to go with the baseline feature,
    you should make sure you don’t forget about addressing these hidden problems in
    the future.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一个警告：与 `@SuppressWarning` 注解一样，基线功能不是一个可以用一次并安全忽略未来的工具。有问题的代码块仍然是您项目中的技术债务，带有所有负面效应。这就是为什么如果您决定使用基线功能，您应该确保您不会忘记在未来解决这些隐藏问题。
- en: 'We will discuss how to deal with these problems later in the book. For now,
    it is only important for you how to update the baseline file from time to time.
    Again, *PHPMD* makes this an easy task. Simply run the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面讨论如何处理这些问题。现在，对于您来说，重要的是如何定期更新基线文件。同样，*PHPMD* 使这项任务变得简单。只需运行以下命令：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: All violations that no longer exist in your code will be removed from the baseline
    file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中不再存在的所有违规将被从基线文件中删除。
- en: A recap on PHPMD
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHPMD 概述
- en: Unless you are starting a project on the green, the configuration of *PHPMD*
    will require a bit more time. Especially if you are working within a team, you
    will spend more time arguing about which rules to use and which to exclude. Once
    this is done, though, you have a powerful tool at your disposal that will help
    developers write high-quality, maintainable code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您是从零开始一个项目，否则 *PHPMD* 的配置将需要更多的时间。特别是如果您在一个团队中工作，您将花费更多的时间争论使用哪些规则以及排除哪些规则。不过，一旦完成，您将拥有一个强大的工具，它将帮助开发者编写高质量、可维护的代码。
- en: PHPStan – a static analyzer for PHP
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHPStan – PHP 静态分析器
- en: You might have noticed that *PHPMD*, which we looked at in the previous section,
    was not very PHP-specific but generally took care of the best coding practices.
    While this is, of course, very important, we want to use *PHPStan* to analyze
    our code with bad PHP practices in mind now.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们在上一节中讨论的 *PHPMD* 并非非常特定于 PHP，而是通常关注最佳编码实践。虽然这当然非常重要，但我们现在想使用 *PHPStan*
    来分析我们的代码，并考虑到不良的 PHP 实践。
- en: As with every static analysis tool, *PHPStan* can only work with the information
    it can get out of the code. Therefore, it works better with modern object-oriented
    code. If, for example, the code makes strong use of strict typing, the analyzer
    has additional information to process, and will therefore return more results.
    But for older projects, it will be of immense help as well, as we will see in
    the following section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个静态分析工具一样，*PHPStan* 只能使用从代码中获取的信息来工作。因此，它更适合现代面向对象代码。例如，如果代码大量使用严格类型，分析器将处理额外的信息，因此会返回更多结果。但对于旧项目，它也将非常有帮助，正如我们将在下一节中看到的那样。
- en: Installation and usage
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装和使用
- en: 'Installing *PHPStan* with Composer is just a one-liner again:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Composer 安装 *PHPStan* 仍然只需要一行命令：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As with most code quality tools, *PHPStan* can be installed using PHAR. However,
    only when using Composer can you also install extensions. We will have a look
    at those a bit later in this section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数代码质量工具一样，*PHPStan* 可以使用 PHAR 安装。然而，只有当使用 Composer 时，您才能安装扩展。我们将在本节的稍后部分探讨这些内容。
- en: 'Let us use the following simplified example and store it inside the `src` folder:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下简化的示例并将其存储在 `src` 文件夹中：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To execute a scan, you need to specify the `analyse` keyword, together with
    the path to scan, which is `src` in our case:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行扫描，您需要指定 `analyse` 关键字，以及扫描的路径，在我们的例子中是 `src`：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Figure 7.2* shows the output produced by *PHPStan*:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7.2* 展示了 *PHPStan* 生成的输出：'
- en: '![Figure 7.2: An example output of PHPStan'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2：PHPStan 的一个示例输出'
- en: '](img/Figure_7.02_B19050.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.02_B19050.jpg)'
- en: 'Figure 7.2: An example output of PHPStan'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：PHPStan 的一个示例输出
- en: When we execute the PHP script, it will output `100`. Unfortunately, this is
    not correct because adding 19% of taxes to the net price should return 119, and
    not 100\. So, there must be a bug somewhere. Let us see how *PHPStan* can help
    us here.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行 PHP 脚本时，它将输出 `100`。不幸的是，这是不正确的，因为将 19% 的税费加到净价上应该返回 119，而不是 100。所以，肯定哪里出了
    bug。让我们看看 *PHPStan* 如何在这里帮助我们。
- en: Rule levels
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则级别
- en: Unlike *PHPMD*, where you configure in detail which rules to apply, we will
    use different reporting levels here. These levels have been defined by the developers
    of *PHPStan*, starting from level 0 (just performing basic checks) to level 9
    (being very strict on issues). To not overwhelm users with errors at first, *PHPStan*
    by default will use level 0, which only executes very few checks.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *PHPMD* 不同，在 *PHPMD* 中你需要详细配置要应用哪些规则，我们在这里将使用不同的报告级别。这些级别是由 *PHPStan* 的开发者定义的，从级别
    0（仅执行基本检查）到级别 9（对问题非常严格）。为了不让用户一开始就被错误淹没，*PHPStan* 默认将使用级别 0，这只会执行非常少的检查。
- en: 'You can specify the level using the `level` (`-l|--level`) option. Let us try
    the next highest level:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `level`（`-l|--level`）选项来指定级别。让我们尝试下一个更高的级别：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Using the level approach, you can effortlessly increase the quality of your
    code step by step, as we will demonstrate using the following, made-up example.
    Levels 1 and 2 will not return any errors either, though. As we eventually reach
    level 3, however, we will finally find a problem:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用级别方法，你可以轻松地逐步提高代码的质量，正如我们将使用以下虚构的示例来展示。级别 1 和 2 也不会返回任何错误。然而，当我们最终达到级别 3 时，我们最终会找到一个问题：
- en: '![Figure 7.3: PHPStan reports one error with level 3'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3：PHPStan 报告了一个级别 3 的错误'
- en: '](img/Figure_7.03_B19050.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.03_B19050.jpg)'
- en: 'Figure 7.3: PHPStan reports one error with level 3'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：PHPStan 报告了一个级别 3 的错误
- en: 'Checking our code again, we can spot the problem quickly: the `getVat()` method
    returns a float number (0.19) but using the `int` return type casts it to 0\.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查我们的代码，我们可以快速发现问题：`getVat()` 方法返回一个浮点数（0.19），但使用 `int` 返回类型将其转换为 0。
- en: Strict typing
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 严格类型
- en: If we had used strict mode by adding the `declare(strict_types=1);` statement
    at the top of the example code, PHP would have thrown an error instead of silently
    casting the return value to `int`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在示例代码的顶部添加了 `declare(strict_types=1);` 语句来使用严格模式，PHP 将会抛出一个错误，而不是静默地将返回值转换为
    `int`。
- en: 'This demonstrates the beauty and power of Static Code Analysis: fixing this
    little bug will make our code work as expected and it takes us just a couple of
    seconds to do since we are still in our development environment. However, if this
    bug had reached the production environment, it would have taken us much longer
    to fix and left some angry customers behind.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了静态代码分析的魅力和力量：修复这个小 bug 将使我们的代码按预期工作，而且由于我们仍然处于开发环境中，我们只需几秒钟就能完成。然而，如果这个
    bug 已经到达了生产环境，修复它将花费我们更长的时间，并且会留下一些愤怒的客户。
- en: Configuration
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置
- en: You can use configuration files to make sure that the same level and the same
    folders are always checked. The configuration is written in NEON (https://ne[-on.org/](https://ne-on.org/)),
    a file format that is very similar to YAML; if you can read and write YAML, it
    will work out just fine.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用配置文件来确保始终检查相同的级别和相同的文件夹。配置是用 NEON（https://ne[-on.org/](https://ne-on.org/))
    编写的，这是一种与 YAML 非常相似的文件格式；如果你能读写 YAML，它就会正常工作。
- en: 'The basic configuration only contains the level and the folders to be scanned:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 基本配置只包含级别和要扫描的文件夹：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It is a good practice to save this configuration in a file named `phpstan.neon`
    in the `root` folder of your project. That is the location where *PHPStan* expects
    it to be by default. If you follow this convention, the next time you want to
    run it, you only need to specify the desired action:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 将此配置保存为名为 `phpstan.neon` 的文件，放在项目的 `root` 文件夹中是一个好习惯。这是 *PHPStan* 默认期望的位置。如果你遵循这个约定，下次你想运行它时，你只需要指定所需的操作：
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you used the above example configuration, *PHPStan* will now scan the `src`
    folder, using all rules from level 0 to level 4.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用了上面的示例配置，*PHPStan* 现在将扫描 `src` 文件夹，使用从级别 0 到级别 4 的所有规则。
- en: That is not everything you can configure here. In the next section, we will
    learn about some additional parameters.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是你可以在这里配置的所有内容。在下一节中，我们将了解一些额外的参数。
- en: Using PHPStan in legacy projects
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在遗留项目中使用PHPStan
- en: If you want to use *PHPStan* in existing projects of a certain age, you will
    most likely end up with hundreds if not thousands of errors, depending on the
    chosen level. Of course, you can decide to keep using a lower level; but that
    also means that the analyzer will miss more bugs, not only existing ones but also
    in new or modified code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在一定年龄的现有项目中使用*PHPStan*，你可能会遇到数百甚至数千个错误，具体取决于选择哪个级别。当然，你可以选择继续使用较低级别；但这也意味着分析器会错过更多的错误，不仅包括现有的错误，还包括新或修改的代码。
- en: In an ideal world, you would start with level 0, solve all errors, then continue
    with level 1, solve all new errors, and so on. This requires a lot of time, though,
    and, if no automated tests are available, a complete manual test run at the end
    would be necessary. You probably won’t have that much time, so let us see what
    other options we have.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，你会从0级开始，解决所有错误，然后继续到1级，解决所有新的错误，依此类推。然而，这需要很多时间，而且如果没有可用的自动化测试，最后还需要进行一次完整的手动测试运行。你可能没有那么多时间，所以让我们看看我们还有哪些其他选项。
- en: 'There are two ways that *PHPStan* can be told to ignore errors: firstly, using
    *PHPDocs* annotations, and secondly, using a special parameter in the configuration
    file.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以告诉*PHPStan*忽略错误：首先，使用*PHPDocs*注释，其次，使用配置文件中的特殊参数。
- en: Using PHPDocs annotations
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用PHPDocs注释
- en: 'To ignore a line of code, simply add a comment before or on the affected line,
    using the special `@phpstan-ignore-next-line` and `@phpstan-ignore-line` *PHPDocs*
    annotations:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要忽略一行代码，只需在受影响的行之前或之上添加一个注释，使用特殊的`@phpstan-ignore-next-line`和`@phpstan-ignore-line`
    *PHPDocs*注释：
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Both lines of code will not be scanned for errors anymore. It is up to you to
    choose the way you prefer. It is not possible to ignore bigger code blocks or
    even entire functions or classes, though (unless you want to add a comment to
    every line, that is).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行代码将不再被扫描错误。你可以选择你喜欢的任何方式。不过，无法忽略更大的代码块或整个函数或类（除非你想要在每一行添加注释）。
- en: Using ignoreErrors parameters
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用ignoreErrors参数
- en: The *PHPDocs* annotations are perfect for quick fixes in only a few locations,
    but you will need to touch many files if you wish to ignore numerous errors. Using
    the `ignoreErrors` parameter in the configuration file is not very comfortable,
    though, as you have to write a regular expression for every error you would like
    to ignore.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*PHPDocs* 注释非常适合在几个位置快速修复，但如果你希望忽略许多错误，你将需要修改许多文件。然而，在配置文件中使用`ignoreErrors`参数并不太方便，因为你必须为每个想要忽略的错误编写一个正则表达式。'
- en: 'The following example will explain how it works. Let’s assume we keep getting
    an error as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将解释它是如何工作的。让我们假设我们持续收到以下错误：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Although theoretically, this would be easy to fix, the team decides against
    adding a type hint so as not to risk any side effects. The `OrderPosition` class
    is awfully written and not covered with tests, yet still works as expected. Since
    it will be replaced soon anyway, we are not willing to take the risk and touch
    it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从理论上讲，这很容易修复，但团队决定不添加类型提示，以避免任何副作用风险。`OrderPosition`类写得非常糟糕，没有经过测试，但仍然按预期工作。由于它很快就会被替换，我们不愿意承担风险去修改它。
- en: 'To ignore this error, we need to add the `ignoreErrors` parameter to our `phpstan.neon`
    configuration file:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要忽略此错误，我们需要将`ignoreErrors`参数添加到我们的`phpstan.neon`配置文件中：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Instead of defining a rule or ruleset to ignore, we need to provide a regular
    expression here that matches the message of the error that should be ignored.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要定义一个规则或规则集来忽略，而是需要提供一个正则表达式，以匹配应该忽略的错误消息。
- en: Tip
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Writing regular expressions can be challenging. Luckily, the *PHPStan* website
    offers a very useful little tool to generate the necessary `phpstan.neon` part
    from the error message: [https://phpstan.org/user-guide/ignoring-errors#generate-an-ignoreerrors-entry](https://phpstan.org/user-guide/ignoring-errors#generate-an-ignoreerrors-entry).'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 编写正则表达式可能具有挑战性。幸运的是，*PHPStan*网站提供了一个非常有用的工具，可以从错误消息生成必要的`phpstan.neon`部分：[https://phpstan.org/user-guide/ignoring-errors#generate-an-ignoreerrors-entry](https://phpstan.org/user-guide/ignoring-errors#generate-an-ignoreerrors-entry)。
- en: Upon the next run, the error will no longer be displayed regardless of where
    it occurs, as it matches the regular expression here.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次运行时，无论错误出现在哪里，都不会再显示，因为它与这里的正则表达式匹配。
- en: '*PHPStan* does not inform you about the fact that errors are ignored. Do not
    forget to fix them at some point! However, if you improve your code further over
    time, *PHPStan* will let you know when errors that are set to be ignored are no
    longer matched. You can safely remove them from the list then.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*PHPStan* 不会告诉你错误被忽略了的事实。不要忘记在某个时候修复它们！然而，如果你随着时间的推移进一步改进你的代码，*PHPStan* 将会通知你那些被设置为忽略的错误不再匹配。那时你可以安全地从列表中移除它们。'
- en: 'If you want to ignore certain errors completely, but just in one or more files
    or paths, you can do so by using a slightly different notation:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要完全忽略某些错误，但只是在文件或路径中，你可以通过使用稍微不同的符号来实现：
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The path needs to be relative to the location of the `phpstan.neon` configuration
    file. When given, the error will only be ignored if it occurs in `OrderPosition.php`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 路径需要相对于 `phpstan.neon` 配置文件的位置是相对的。当给出时，只有当错误发生在 `OrderPosition.php` 中时，才会忽略该错误。
- en: Baseline
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基线
- en: 'As we just saw in the previous section, adding errors you want to be ignored
    manually to your configuration file is a cumbersome task. But there is an easier
    way: similar to *PHPMD*, it is possible to automatically add all the current errors
    to the list of ignored errors at once by executing the following command with
    the `--generate-baseline` option:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中看到的，手动将你想要忽略的错误添加到配置文件中是一个繁琐的任务。但有一个更简单的方法：类似于 *PHPMD*，你可以通过执行以下命令并使用
    `--generate-baseline` 选项一次性自动将所有当前错误添加到忽略错误列表中：
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The newly generated file, `phpstan-baseline.neon`, is in the same directory
    as the configuration file. PHPStan will not make use of it automatically, though.
    You have to include it manually in the `phpstan.neon` file as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 新生成的文件 `phpstan-baseline.neon` 与配置文件位于同一目录下。尽管如此，PHPStan 不会自动使用它。你必须手动将其包含在
    `phpstan.neon` 文件中，如下所示：
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The next time you run PHPStan now, any previously reported errors should not
    be reported anymore.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 下次你运行 PHPStan 时，之前报告的错误将不再被报告。
- en: Internally, the baseline file is nothing more than an automatically created
    list of the `ignoreErrors` parameters. Feel free to modify it to your needs. You
    can always regenerate it by executing `phpstan` using the `--generate-baseline`
    option again.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，基线文件不过是一个自动创建的 `ignoreErrors` 参数列表。请随意根据你的需求进行修改。你可以通过再次执行带有 `--generate-baseline`
    选项的 `phpstan` 命令来重新生成它。
- en: Extensions
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展
- en: It is possible to extend the functionality of *PHPStan*. The vivid community
    has already created a respectable number of useful extensions. For example, frameworks
    such as Symfony, Laminas, or Laravel often make use of magic methods (such as
    `__get()` and `__set()`), which cannot be analyzed automatically. There are extensions
    for these frameworks that provide the necessary information to *PHPStan*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 可以扩展 *PHPStan* 的功能。充满活力的社区已经创建了许多有用的扩展。例如，像 Symfony、Laminas 或 Laravel 这样的框架通常使用魔法方法（如
    `__get()` 和 `__set()`），这些方法无法自动分析。这些框架有针对 *PHPStan* 的扩展，为它提供必要的信息。
- en: 'While we cannot cover these extensions in this book, we encourage you to check
    out the extension library: [https://phpstan.org/user-guide/extension-library](https://phpstan.org/user-guide/extension-library).
    There are also extensions for PHPUnit, phpspec, and WordPress.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们无法在这本书中涵盖这些扩展，但我们鼓励你查看扩展库：[https://phpstan.org/user-guide/extension-library](https://phpstan.org/user-guide/extension-library)。还有针对
    PHPUnit、phpspec 和 WordPress 的扩展。
- en: A recap of PHPStan
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHPStan 概述
- en: '*PHPStan* is a powerful tool. We cannot cover all its functionality in just
    a few pages but we have given you a good idea of how to start using it. Once you
    are familiar with its basic usage, check out [https://phpstan.org](https://phpstan.org)
    to learn more!'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*PHPStan* 是一个强大的工具。我们无法在几页中涵盖其所有功能，但我们已经给你一个如何开始使用它的好主意。一旦你熟悉了其基本用法，请访问 [https://phpstan.org](https://phpstan.org)
    了解更多！'
- en: 'Psalm: A PHP static analysis linting machine'
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Psalm：一个 PHP 静态分析 linting 机器
- en: The next and last static code analyzer we want to introduce is *Psalm*. It will
    check our code base for so-called issues and report any violations. Furthermore,
    it can resolve some of these issues automatically. So, let us have a closer look.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要介绍的最后静态代码分析器是 *Psalm*。它将检查我们的代码库中的所谓问题，并报告任何违规行为。此外，它还可以自动解决其中的一些问题。让我们更深入地了解一下。
- en: Installation and usage
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装和使用
- en: 'Once again, installing *Psalm* with Composer is just a matter of a few keystrokes:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，使用 Composer 安装 *Psalm* 只需要几个按键：
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It is available as a `phar` file as well.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 它也以 `phar` 文件的形式提供。
- en: 'After installation, we cannot just start, though – rather, we need to set up
    a configuration file for the current project first. We can use the comfortable
    `--init` option to create it:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们并不能直接开始——相反，我们首先需要为当前项目设置一个配置文件。我们可以使用方便的`--init`选项来创建它：
- en: '[PRE43]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This command will write a configuration file called `psalm.xml` in the current
    directory, which should be the project root. During its creation, *Psalm* checks
    whether it can find any PHP code and decides which error level is suitable, to
    begin with. Running *Psalm* doesn’t require any more options:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在当前目录中写入一个名为`psalm.xml`的配置文件，这应该是项目根目录。在其创建过程中，*Psalm*会检查它是否可以找到任何PHP代码，并决定从哪个错误级别开始。运行*Psalm*不需要任何更多选项：
- en: '[PRE44]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Configuration
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置
- en: 'The configuration file was already created during the installation process
    and could, for example, look similar to this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件已经在安装过程中创建，例如，可能看起来像这样：
- en: '[PRE45]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let us have a look at the attributes of the `<psalm>` node. You do not need
    to worry about the schema- and namespace-related information, only about the following
    two things:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`<psalm>`节点的属性。你不需要担心与模式和相关信息的名称空间，只需关注以下两点：
- en: '`errorLevel`: The levels go from 8 (basic checks) to 1 (very strict). In other
    words, the lower the level, the more rules will be applied.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`errorLevel`：级别从8（基本检查）到1（非常严格）。换句话说，级别越低，应用的规则越多。'
- en: '`resolveFromConfigFile`: Setting this to `true` lets *Psalm* resolve all relative
    paths (such as `src` and `vendor`) from the location of the configuration file
    – so usually, from the project root.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resolveFromConfigFile`：将此设置为`true`允许*Psalm*从配置文件的位置解析所有相对路径（如`src`和`vendor`）——通常是从项目根目录。'
- en: Psalm documentation
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Psalm文档
- en: Psalm offers many more configuration options that we cannot cover in this book.
    As always, we recommend checking the documentation (https://psalm.dev/docs) to
    learn more about this tool.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Psalm提供了许多我们在这本书中无法涵盖的配置选项。一如既往，我们建议查看文档（https://psalm.dev/docs）以了解更多关于这个工具的信息。
- en: Inside the `<psalm>` node, you will find more settings. In the previous example,
    *Psalm* is told to only scan the `src` folder and ignore all the files in the
    `vendor` folder. Ignoring the `vendor` folder is important, as we don’t want to
    scan any third-party code.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<psalm>`节点内部，你可以找到更多设置。在上一个示例中，*Psalm*被指示只扫描`src`文件夹，并忽略`vendor`文件夹中的所有文件。忽略`vendor`文件夹很重要，因为我们不想扫描任何第三方代码。
- en: Using Psalm in legacy projects
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在遗留项目中使用Psalm
- en: 'We will now have a look at how we can adjust *Psalm* to deal with existing
    projects better. As with the previous tools, there are basically two ways to ignore
    issues: using the configuration file or docblock annotations.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨如何调整*Psalm*以更好地处理现有项目。与之前的工具一样，基本上有两种方式来忽略问题：使用配置文件或docblock注释。
- en: 'There are three code issue levels: `info`, `error`, and `suppress`. While `info`
    will just print info messages if minor issues have been found, issues that are
    at the level of an `error` type, on the other hand, require you to get active.
    An issue of the `suppress` type will not be shown at all.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种代码问题级别：`info`、`error`和`suppress`。当发现轻微问题时，`info`只会打印信息消息，而另一方面，处于`error`类型级别的问题则需要你采取行动。`suppress`类型的问题根本不会显示。
- en: Continuous Integration
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成
- en: The difference between `info` and `error` becomes more important when building
    a Continuous Integration pipeline. `info` issues would let the build pass, while
    `error` issues would break it. We will have a closer look at this topic later.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建持续集成管道时，`info`和`error`之间的区别变得更加重要。`info`问题会让构建通过，而`error`问题则会中断它。我们稍后会更详细地探讨这个话题。
- en: Docblock suppression
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Docblock抑制
- en: 'The `@psalm-suppress` annotation can be used either in a function docblock
    or a comment for the next line. The `Vat` class from the previous examples could
    look as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`@psalm-suppress`注释可以在函数docblock或下一行的注释中使用。前一个示例中的`Vat`类可能看起来如下：'
- en: '[PRE46]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Configuration file suppression
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置文件抑制
- en: 'If we want to suppress issues, we need to configure `issueHandler` for them,
    where we can set the type to suppress manually. This is done in the configuration
    file by adding an `<issueHandler>` node inside the `<psalm>` node:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要抑制问题，我们需要为它们配置`issueHandler`，其中我们可以手动设置抑制类型。这是通过在`<psalm>`节点内添加`<issueHandler>`节点来在配置文件中完成的：
- en: '[PRE47]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The preceding configuration would suppress all the `InvalidReturnType` and
    `InvalidReturnStatement` issues in the whole project. We can make this a bit more
    specific, though:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置将抑制整个项目中所有 `InvalidReturnType` 和 `InvalidReturnStatement` 问题。不过，我们可以使这个设置更加具体：
- en: '[PRE48]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the documentation ([https://psalm.dev/docs/running_psalm/dealing_with_code_issues/](https://psalm.dev/docs/running_psalm/dealing_with_code_issues/)),
    you will find even more ways to suppress issues – for example, by the variable
    name.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档中（[https://psalm.dev/docs/running_psalm/dealing_with_code_issues/](https://psalm.dev/docs/running_psalm/dealing_with_code_issues/)），你会发现更多抑制问题的方法——例如，通过变量名。
- en: Baseline
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基准
- en: 'As with the previous static code analyzers we discussed, *Psalm* also provides
    a feature to generate a baseline file, which will include all the current errors
    so that they will be ignored during the next run. Please note that the baseline
    feature only works for `error` issues, but not `info` issues. Let us create the
    file first:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前讨论的静态代码分析器一样，*Psalm* 也提供了一个生成基准文件的功能，该文件将包含所有当前错误，以便在下次运行时忽略它们。请注意，基准功能仅适用于
    `error` 问题，但不适用于 `info` 问题。让我们首先创建该文件：
- en: '[PRE49]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*Psalm* has no default name for this file, so you need to pass it as an option
    to the command:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*Psalm* 为此文件没有默认名称，因此你需要将其作为选项传递给命令：'
- en: '[PRE50]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can also add it as an additional attribute to the `<psalm>` node in the
    configuration file:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将其添加为配置文件中 `<psalm>` 节点的附加属性：
- en: '[PRE51]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, you can update the baseline file – for example, after you have made
    some improvements to the code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以更新基准文件——例如，在你对代码进行了一些改进之后：
- en: '[PRE52]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Fixing issues automatically
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动修复问题
- en: '*Psalm* will not only find the issue but it can also fix many of them automatically.
    It will let you know when this is the case and you can use the `--alter` option:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*Psalm* 不仅会找到问题，还可以自动修复其中许多问题。当这种情况发生时，它会通知你，你可以使用 `--alter` 选项：'
- en: '[PRE53]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let’s execute the command as *Psalm* suggests:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照 *Psalm* 建议执行命令：
- en: '[PRE54]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `--dry-run` option tells *Psalm* to only show you what it would change
    as `diff`, but not to apply the changes. This way, you can check whether the change
    is correct:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`--dry-run` 选项告诉 *Psalm* 只显示它将如何作为 `diff` 进行更改，但不会应用这些更改。这样，你可以检查更改是否正确：'
- en: '![Fig 7.4: Psalm showing proposed changes'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4：Psalm 显示建议的更改'
- en: '](img/Figure_7.04_B19050.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.04_B19050.jpg]'
- en: 'Fig 7.4: Psalm showing proposed changes'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：Psalm 显示建议的更改
- en: If you remove the `--dry-run` option, the changes will be applied.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你移除了 `--dry-run` 选项，更改将被应用。
- en: A recap on Psalm
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Psalm 概述
- en: '*Psalm* is a standard tool in the clean coder’s toolkit for good reason. It
    is fast, easy to use, and powerful. Additionally, the code manipulation feature
    will save you a lot of time. Of course, there are numerous similarities with *PHPStan*,
    but often enough, you will find both tools working together on the same code base
    without problems. At least, you should consider giving it a try.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '*Psalm* 是清洁编码者工具箱中的标准工具，原因有很多。它速度快，易于使用，功能强大。此外，代码操作功能将为您节省大量时间。当然，它与 *PHPStan*
    有许多相似之处，但通常，你会在没有问题的同一代码库上找到这两个工具共同工作。至少，你应该考虑尝试一下。'
- en: IDE extensions
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDE 扩展
- en: 'The tools we looked at so far share something in common: they need to be applied
    to our code after we have written it. Of course, this is much better than nothing,
    but wouldn’t it be great if the tools gave us their feedback immediately at the
    time that we wrote the code?'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止查看的工具有一个共同点：在我们编写代码之后，我们需要将它们应用到我们的代码上。当然，这比没有好得多，但如果工具能在我们编写代码时立即给我们反馈，那岂不是更好？
- en: 'That is what many other developers thought as well, so they created extensions
    for the most popular IDEs, which are currently **Visual Studio Code** (**VS Code**)
    and **PhpStorm**:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他开发者也有同样的想法，因此他们为最流行的 IDE 创建了扩展，目前是 **Visual Studio Code** （**VS Code**）和
    **PhpStorm**：
- en: '*PhpStorm* is an established, commercial IDE from JetBrains with several PHP-specific
    tools, checks, and built-in integrations for many of the code quality tools we
    discussed in this chapter. There are many useful extensions available for it as
    well. You can try it out for 30 days for free.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PhpStorm* 是来自 JetBrains 的一个成熟的商业 IDE，具有多个针对 PHP 的工具、检查和内置集成，用于我们本章讨论的许多代码质量工具。它也有许多有用的扩展可用。你可以免费试用
    30 天。'
- en: '*VS Code* is a highly flexible code editor from Microsoft with tons of third-party
    (partly commercial) extensions that can turn these tools into an IDE for virtually
    every relevant programming language today. Because the code editor itself is free,
    is it becoming more and more popular.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*VS Code* 是微软的一个高度灵活的代码编辑器，拥有大量的第三方（部分为商业）扩展，可以将这些工具变成适用于今天几乎所有相关编程语言的 IDE。由于代码编辑器本身是免费的，因此它变得越来越受欢迎。'
- en: Alternative PHP IDEs
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 PHP IDE
- en: '*PhpStorm* and *VS Code* are not the only IDEs that exist for PHP. Other alternatives
    are *NetBeans* ([https://netbeans.apache.org](https://netbeans.apache.org)), *Eclipse
    PDT* (https://www.eclipse.org), or *CodeLobster* ([https://www.codelobster.com](https://www.codelobster.com)).'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*PhpStorm* 和 *VS Code* 并不是唯一适用于 PHP 的 IDE。其他替代方案包括 *NetBeans* ([https://netbeans.apache.org](https://netbeans.apache.org))、*Eclipse
    PDT* ([https://www.eclipse.org](https://www.eclipse.org)) 或 *CodeLobster* ([https://www.codelobster.com](https://www.codelobster.com))。'
- en: 'In this section, we will introduce you to three extensions for these two IDEs:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您介绍这两个 IDE 的三个扩展：
- en: '**PHP Inspections** (EA Extended) for PhpStorm'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PHP 检查**（EA 扩展）for PhpStorm'
- en: '**Intelephense** for VS Code'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Intelephense** for VS Code'
- en: Code quality tool integration in PhpStorm
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: PhpStorm 中的代码质量工具集成
- en: 'PhpStorm offers seamless integration for the following tools that we have discussed:
    *PHP CS Fixer*, PHPMD, PHPStan, and Psalm. More information can be found here:
    [https://www.jetbrains.com/help/phpstorm/php-code-quality-tools.html](https://www.jetbrains.com/help/phpstorm/php-code-quality-tools.html).'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: PhpStorm 为我们讨论的以下工具提供了无缝集成：*PHP CS Fixer*、PHPMD、PHPStan 和 Psalm。更多信息请参阅此处：[https://www.jetbrains.com/help/phpstorm/php-code-quality-tools.html](https://www.jetbrains.com/help/phpstorm/php-code-quality-tools.html)。
- en: PHP Inspections (EA Extended)
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP 检查（EA 扩展）
- en: This plugin (https://github.com/kalessil/phpinspectionsea) is for PhpStorm.
    It will add even more types of inspections to the pool of already existing ones,
    covering topics such as code style, architecture, or possible bugs.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件（[https://github.com/kalessil/phpinspectionsea](https://github.com/kalessil/phpinspectionsea)）是为
    PhpStorm 设计的。它将为已有的检查类型增加更多种类，涵盖代码风格、架构或可能的错误等方面。
- en: IDE Inspections
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: IDE 检查
- en: Modern IDEs are already equipped with a lot of useful code checks. In PHPStorm,
    they are called *Inspections*. Some are already enabled by default – more can
    be activated manually (https://www.jetbrains.com/help/phpstorm/code-inspection.html#access-inspections-and-settings).
    For VS Code, you need to install an extension first. Check out the documentation
    (https://code.visualstudio.com/docs/languages/php) for more information.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现代IDE已经配备了大量的有用代码检查。在 PHPStorm 中，它们被称为 *检查*。一些默认启用，更多的可以通过手动激活（[https://www.jetbrains.com/help/phpstorm/code-inspection.html#access-inspections-and-settings](https://www.jetbrains.com/help/phpstorm/code-inspection.html#access-inspections-and-settings)）。对于
    VS Code，你首先需要安装一个扩展。查看文档（[https://code.visualstudio.com/docs/languages/php](https://code.visualstudio.com/docs/languages/php)）以获取更多信息。
- en: Installation
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装
- en: As with every PhpStorm plugin, the installation is done via the `File -> Settings
    -> Plugins` dialog. You will find detailed information on how to install a plugin
    on the vendor’s website ([https://www.jetbrains.com/help/phpstorm/managing-plugins.html](https://www.jetbrains.com/help/phpstorm/managing-plugins.html)).
    Simply search for `EA Extended`. Please note that there is a second version of
    this plugin, EA Ultimate, which you have to pay for. We will not cover it in this
    book.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 与每一个 PhpStorm 插件一样，安装是通过 `文件 -> 设置 -> 插件` 对话框完成的。你可以在供应商网站上找到有关如何安装插件的详细信息（[https://www.jetbrains.com/help/phpstorm/managing-plugins.html](https://www.jetbrains.com/help/phpstorm/managing-plugins.html)）。只需搜索
    `EA 扩展`。请注意，此插件还有一个名为 EA Ultimate 的第二个版本，你需要付费。本书中不会涉及它。
- en: 'After installation, not all the inspections are immediately active. Let us
    have a look at the PhpStorm inspections configuration, as shown in *Figure 7.4*:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，并非所有检查都立即激活。让我们看看 PHPStorm 检查配置，如图 *7.4* 所示：
- en: '![Figure 7.5: The Inspections configuration dialog in PhpStorm'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5：PHPStorm 中检查配置对话框'
- en: '](img/Figure_7.05_B19050.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.05_B19050.jpg](img/Figure_7.05_B19050.jpg)'
- en: 'Figure 7.5: The Inspections configuration dialog in PhpStorm'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：PHPStorm 中检查配置对话框
- en: All the inspections of this plugin can be found in the **Php Inspections (EA
    Extended)** section. The inspections that are not active by default can easily
    be activated by checking the checkbox next to them. We recommend reading the documentation
    (https://github.com/kalessil/phpinspectionsea/tree/master/docs) before activating
    any further inspections – otherwise, you might end up with too many rules. You
    can revisit them later.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 所有此插件的检查都可以在 **Php 检查（EA 扩展）** 部分找到。默认未激活的检查可以通过勾选旁边的复选框轻松激活。我们建议在激活任何进一步的检查之前阅读文档（https://github.com/kalessil/phpinspectionsea/tree/master/docs）——否则，你可能会结束时有太多的规则。你可以在以后重新访问它们。
- en: Usage
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用法
- en: '`if` clause on line 7:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 第 7 行的 `if` 子句：
- en: '![Figure 7.6: Example code with an issue found by PHP Inspections (EA Extended)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6：PHP 检查（EA 扩展）发现问题的示例代码'
- en: '](img/Figure_7.06_B19050.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.06_B19050.jpg)'
- en: 'Figure 7.6: Example code with an issue found by PHP Inspections (EA Extended)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6：PHP 检查（EA 扩展）发现问题的示例代码
- en: 'When you hover your mouse pointer over the highlighted area, PhpStorm will
    show a pop-up window with further instructions about the suggested improvement:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将鼠标指针悬停在突出显示的区域时，PhpStorm 将显示一个弹出窗口，其中包含有关建议改进的进一步说明：
- en: '![Figure 7.7: PHP Inspections (EA Extended) suggesting a code improvement'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.7：PHP 检查（EA 扩展）建议代码改进'
- en: '](img/Figure_7.07_B19050.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.07_B19050.jpg)'
- en: 'Figure 7.7: PHP Inspections (EA Extended) suggesting a code improvement'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7：PHP 检查（EA 扩展）建议代码改进
- en: 'You can choose to fix the issue directly by pressing *Alt + Shift + Enter*
    at the same time, or you can click on the highlighted area to show the Quick-Fix
    bubble. If you click on the bubble, you will see a menu with some more options.
    You can also invoke the following dialog by pressing *Alt + Enter*:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择直接按 *Alt + Shift + Enter* 同时修复问题，或者你可以点击突出显示的区域以显示快速修复气泡。如果你点击气泡，你将看到一个包含更多选项的菜单。你也可以通过按
    *Alt + Enter* 调用以下对话框：
- en: '![Figure 7.8: The Quick-Fix options menu'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.8：快速修复选项菜单'
- en: '](img/Figure_7.08_B19050.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.08_B19050.jpg)'
- en: 'Figure 7.8: The Quick-Fix options menu'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8：快速修复选项菜单
- en: 'PhpStorm offers you several fixes now. The first one, marked with `[EA]`, is
    a suggestion by the plugin. Another click will apply the fix:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: PhpStorm 现在为你提供了几个修复方案。第一个，标记为 `[EA]`，是由插件提出的建议。再点击一次将应用修复：
- en: '![Figure 7.9: The code after applying a Quick-Fix'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.9：应用快速修复后的代码'
- en: '](img/Figure_7.09_B19050.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.09_B19050.jpg)'
- en: 'Figure 7.9: The code after applying a Quick-Fix'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9：应用快速修复后的代码
- en: That’s it! Within just a few seconds, you made your code shorter and easier
    to read. **PHP Inspections (EA Extended)** is a great addition to PhpStorm, as
    it offers sensible inspections and integrates them seamlessly. If you are using
    this IDE, you should not hesitate to install it.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！仅仅几秒钟，你就使你的代码变得更短、更易于阅读。**PHP 检查（EA 扩展）** 是 PhpStorm 的一个很好的补充，因为它提供了合理的检查，并且无缝地整合了它们。如果你使用这个
    IDE，你不应该犹豫安装它。
- en: Inspections when working in a team
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 团队协作中的检查
- en: 'These inspections are a great way to improve your code and educate yourself
    on best practices. However, there is a huge drawback: how do you ensure that every
    developer working on your project has the same inspections activated? We will
    cover this topic in *Working in a Team*.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这些检查是改进你的代码并了解最佳实践的好方法。然而，有一个巨大的缺点：你如何确保每个在你项目上工作的开发者都激活了相同的检查？我们将在 *团队协作* 中讨论这个话题。
- en: Intelephense
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Intelephense
- en: The second extension we want to introduce is *Intelephense* for VS Code. It
    is the most frequently downloaded PHP extension for this editor and provides a
    lot of functionality (such as code completion and formatting), which turns VS
    Code into a fully capable PHP IDE. There is also a commercial, premium version
    of this extension that offers even more functionality. To install it, please follow
    the instructions on the Marketplace website for this plugin (https://marketplace.visualstudio.com/items?itemName=bmewburn.vscode-intelephense-client).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要介绍的第二个扩展是 VS Code 的 *Intelephense*。它是此编辑器中最常下载的 PHP 扩展，提供了许多功能（如代码补全和格式化），将
    VS Code 转换成了一个完全功能的 PHP IDE。此扩展还有一个商业的、高级版本，它提供了更多的功能。要安装它，请按照此插件的市场网站上的说明进行操作（https://marketplace.visualstudio.com/items?itemName=bmewburn.vscode-intelephense-client）。
- en: '*Intelephense* does not have the range of functionality that a full-grown,
    commercial IDE would offer by any means, yet for a free service, it is a perfect
    choice. It offers so-called Diagnostics (which are similar to Inspections in PhpStorm)
    that can be configured in the plugin settings screen, as shown in *Figure 7.9*:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '*Intelephense* 并没有像成熟的商业 IDE 那样提供广泛的功能，但对于一个免费服务来说，它是一个完美的选择。它提供了所谓的诊断功能（与
    PhpStorm 中的检查类似），可以在插件设置屏幕中进行配置，如图7.9所示：'
- en: '![Figure 7.10: The Intelephense settings screen'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.10: The Intelephense settings screen](img/Figure_7.10_B19050.jpg)'
- en: '](img/Figure_7.10_B19050.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.10_B19050.jpg](img/Figure_7.10_B19050.jpg)'
- en: 'Figure 7.10: The Intelephense settings screen'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：Intelephense 设置屏幕
- en: Usage
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用法
- en: 'The following figure shows Diagnostics in Intelephense in action:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 Intelephense 中的诊断功能：
- en: '![Figure 7.11: A sample class showing how Intelephense highlights issues'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.11: A sample class showing how Intelephense highlights issues](img/Figure_7.11_B19050.jpg)'
- en: '](img/Figure_7.11_B19050.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.11_B19050.jpg](img/Figure_7.11_B19050.jpg)'
- en: 'Figure 7.11: A sample class showing how Intelephense highlights issues'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：一个示例类，展示了 Intelephense 如何突出显示问题
- en: 'Two things can be seen here. Firstly, and more obviously, is the red line underneath
    `TestClass`. Hovering the mouse pointer over `TestClass` will show a pop-up window
    with an explanation: **Undefined type TestClass**. This makes sense since this
    class does not exist.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里可以看到两件事。首先，并且更为明显的是，在`TestClass`下面有一条红线。将鼠标指针悬停在`TestClass`上时，会弹出一个包含解释的窗口：**未定义类型
    TestClass**。这很合理，因为这个类不存在。
- en: 'Secondly, and more subtly, you will notice that `$ununsedAttribute` and `$testInstance`
    have a slightly darker color than the other variables. This indicates another
    issue, which can be revealed by hovering the mouse over one of the variables:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，并且更为微妙的是，你会注意到`$ununsedAttribute`和`$testInstance`的颜色比其他变量略深。这表明了另一个问题，可以通过将鼠标悬停在其中一个变量上来揭示：
- en: '![Figure 7.12: An info popup in Intelephense'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.12: An info popup in Intelephense](img/Figure_7.12_B19050.jpg)'
- en: '](img/Figure_7.12_B19050.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.12_B19050.jpg](img/Figure_7.12_B19050.jpg)'
- en: 'Figure 7.12: An info popup in Intelephense'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12：Intelephense 中的信息弹出窗口
- en: The popup tells us that `$unsuserAttribute` is not used elsewhere in the code.
    The same applies to `$testInstance` as well.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 弹窗告诉我们`$unsuserAttribute`在代码的其他地方没有被使用。同样也适用于`$testInstance`。
- en: Although it provides some basic issue detection rules and code formatting, it
    clearly can be said that, at the time of writing, the focus of this plugin is
    not on clean code. However, given the fact that VS Code and this plugin are freely
    available, you already have a decent PHP IDE on hand to start coding.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它提供了一些基本的错误检测规则和代码格式化功能，但可以明确地说，在撰写本文时，这个插件的重点并不在于编写干净的代码。然而，鉴于 VS Code 和这个插件都是免费提供的，你已经有了一个不错的
    PHP 集成开发环境来开始编码。
- en: Code quality tool integration in VS Code
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 中的代码质量工具集成
- en: As in PhpStorm, it is possible to integrate some common code quality tools into
    VS Code using plugins, such as for PHPStan ([https://marketplace.visualstudio.com/items?itemName=calsmurf2904.vscode-phpstan](https://marketplace.visualstudio.com/items?itemName=calsmurf2904.vscode-phpstan)),
    *PHP CS Fixer* ([https://marketplace.visualstudio.com/items?itemName=junstyle.php-cs-fixer](https://marketplace.visualstudio.com/items?itemName=junstyle.php-cs-fixer)),
    and PHPMD ([https://marketplace.visualstudio.com/items?itemName=ecodes.vscode-phpmd](https://marketplace.visualstudio.com/items?itemName=ecodes.vscode-phpmd)).
    So, if you want to code with VS Code, be sure to check Marketplace for new plugins
    every now and then.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 PhpStorm 中一样，可以通过插件将一些常见的代码质量工具集成到 VS Code 中，例如 PHPStan ([https://marketplace.visualstudio.com/items?itemName=calsmurf2904.vscode-phpstan](https://marketplace.visualstudio.com/items?itemName=calsmurf2904.vscode-phpstan))、*PHP
    CS Fixer* ([https://marketplace.visualstudio.com/items?itemName=junstyle.php-cs-fixer](https://marketplace.visualstudio.com/items?itemName=junstyle.php-cs-fixer))
    和 PHPMD ([https://marketplace.visualstudio.com/items?itemName=ecodes.vscode-phpmd](https://marketplace.visualstudio.com/items?itemName=ecodes.vscode-phpmd))。因此，如果你想用
    VS Code 编码，确保时不时地检查市场中的新插件。
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about state-of-the-art tools to assist you in creating
    high-quality PHP code. They will help you spot issues early in the **Software
    Development Life Cycle** (**SDLC**), which saves you vast amounts of time. The
    PHP community is still vivid and very productive, and we were not able to cover
    all the fantastic software that exists out there in this book. However, with the
    tools we introduced in this chapter, you are now well equipped for your journey
    towards clean code.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了最先进的技术来帮助你创建高质量的PHP代码。它们将帮助你尽早在**软件开发生命周期**（**SDLC**）中发现问题，这可以为你节省大量时间。PHP社区仍然充满活力且非常高效，我们在这本书中无法涵盖所有那些出色的软件。然而，通过本章中我们介绍的工具，你现在已经为你的清洁代码之旅做好了充分准备。
- en: In the next chapter, you will learn about how to evaluate code quality by using
    the established metrics and, of course, the necessary tools to gather them. See
    you there!
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何通过使用既定的指标以及当然必要的工具来收集它们来评估代码质量。那里见！
- en: Further reading
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you want to try out even more code quality tools, consider the following
    projects:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要尝试更多的代码质量工具，请考虑以下项目：
- en: '*Exakat* (https://www.exakat.io) – A tool that also covers security issues
    and performance, for example. It can fix issues automatically, too.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Exakat* (https://www.exakat.io) – 一个也涵盖安全问题和性能的工具，例如。它还可以自动修复问题。'
- en: '*Phan* (https://github.com/phan/phan) – A static code analyzer that you can
    try out immediately in your browser'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Phan* (https://github.com/phan/phan) – 一个你可以立即在浏览器中尝试的静态代码分析器'
- en: '*PHP Insights* (https://phpinsights.com/) – Another analyzer, yet with easy-to-use
    metrics in terms of the code, architecture, complexity, and style'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PHP Insights* (https://phpinsights.com/) – 另一个分析器，但在代码、架构、复杂性和风格方面提供了易于使用的指标'
