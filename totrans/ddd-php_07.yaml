- en: Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: When you place some classes together in a Module, you are telling the next developer
    who looks at your design to think about them together. If your model is telling
    a story, the Modules are chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在模块中将一些类放在一起时，你是在告诉下一个查看你设计的设计师将它们一起考虑。如果你的模型在讲述一个故事，模块就是章节。
- en: '[Domain-Driven Design:Tackling Complexity in the Heart of Software](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[《领域驱动设计：软件核心的复杂性处理》](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)'
- en: -Eric Evans
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -埃里克·埃文斯
- en: A common concern when building an Application following Domain-Driven Design
    is where to place the code. Specifically if you're using a PHP framework, it's
    important to know the recommended way to place the code, where to place Infrastructure
    code, and how the different concepts inside the model should be structured.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循领域驱动设计（Domain-Driven Design）构建应用程序时，一个常见的担忧是代码的放置位置。具体来说，如果你正在使用PHP框架，了解推荐的代码放置方式、基础设施代码的放置位置以及模型内部不同概念应该如何结构化是很重要的。
- en: 'In Domain-Driven Design, there''s a tactical pattern for this: **modules**.
    Nowadays, everyone structures code in modules. All languages have some sort of
    tool to group classes and language definitions together. Java has packages. Ruby
    has modules. **PHP has namespaces**.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域驱动设计中，有一个战术模式用于此：**模块**。如今，每个人都以模块的形式结构化代码。所有语言都有某种工具可以将类和语言定义分组在一起。Java有包。Ruby有模块。**PHP有命名空间**。
- en: Domain-Driven Design goes one step further toward packaging and grouping your
    classes together and gives semantic meaning to these building blocks. Indeed,
    **it treats modules as a part of the model**. As part of the model, it's important
    to find the best naming, group together Domain objects that are close to each
    other, and keep the Domain objects that aren't related decoupled. **Modules should
    not be treated as a way to separate code but as a way to separate meaningful concepts
    in the model**.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计更进一步，将你的类打包和分组，并给这些构建块赋予语义意义。确实，**它将模块视为模型的一部分**。作为模型的一部分，找到最佳命名、将彼此接近的领域对象分组在一起，以及保持不相关的领域对象解耦是很重要的。**模块不应被视为分离代码的方式，而应被视为在模型中分离有意义概念的方式**。
- en: General Overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: As explained in the [chapter 1](01c59205-81b3-469b-b35a-5b7c82e681a3.xhtml), *Getting
    Started with Domain-Driven Design*, our Domain is organized internally into Subdomains.
    Each Subdomain is ideally modeled and implemented by one Bounded Context, but
    sometimes more than one is needed. If well designed, each Bounded Context is an
    independent system that will be developed and managed by a team. Our suggestion
    is to implement each Bounded Context with a whole Application. This means that
    two Bounded Contexts won't live in the same code Repository. As such, they can
    be deployed independently, have a different development cycle, or even be developed
    using different languages. Inside your Bounded Contexts, you'll use modules to
    group Domain objects that hold a strong relation to one another.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](01c59205-81b3-469b-b35a-5b7c82e681a3.xhtml)“领域驱动设计入门”中所述，我们的领域在内部组织为子领域。每个子领域理想情况下由一个边界上下文（Bounded
    Context）建模和实现，但有时可能需要多个。如果设计得当，每个边界上下文都是一个独立的系统，将由一个团队开发和维护。我们的建议是使用整个应用程序来实现每个边界上下文。这意味着两个边界上下文不会生活在同一个代码仓库中。因此，它们可以独立部署，有不同的开发周期，甚至可以使用不同的语言进行开发。在你的边界上下文中，你会使用模块来分组彼此之间有强关系的领域对象。
- en: Leverage Modules in PHP
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用PHP中的模块
- en: Until PHP 5.3, modules weren't fully supported. But since the introduction of
    PHP 5.3, we can use PHP namespaces to implement the module pattern. For historical
    reasons, we're going to present how namespaces were used before PHP 5.3, but you
    should strive to use a PHP version that supports PHP namespaces. The best choice
    is always going to be the latest stable version of PHP.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 直到PHP 5.3，模块没有得到完全支持。但自从PHP 5.3的引入以来，我们可以使用PHP命名空间来实现模块模式。出于历史原因，我们将展示在PHP 5.3之前如何使用命名空间，但你应努力使用支持PHP命名空间的PHP版本。最佳选择始终是PHP的最新稳定版本。
- en: First-Level Namespacing
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一级命名空间
- en: A common approach is to use a first-level namespace that identifies your company.
    This will help in avoiding conflicts with third-party libraries. If you're using
    PSR-0, you'll have a real folder for the namespace; if you're using PSR-4, you
    don't need it. We'll go deeper into this shortly. But first, let's take a look
    at the PHP namespacing conventions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的方法是使用一级命名空间来标识您的公司。这将有助于避免与第三方库发生冲突。如果您使用 PSR-0，您将有一个真实的文件夹用于命名空间；如果您使用 PSR-4，则不需要。我们稍后会深入探讨这个问题。但首先，让我们看看
    PHP 命名空间的约定。
- en: PEAR-Style Namespacing
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PEAR 风格命名空间
- en: 'Before PHP 5.3, due to the lack of a namespace construction, PEAR-style namespaces
    were used. PEAR is an acronym for PHP Extension and Application Repository, and
    in the good old days, it was a Repository of reusable components. It''s still
    active, but it''s not very convenient, and not many people use it anymore — particularly
    since Composer and Packagist were introduced. PEAR, as a source of reusable components,
    needed a way to avoid class name collisions, so contributors started prefixing
    class names with namespaces. There are still projects that use this form of namespaces
    (*PHPUnit* and *Zend* Framework 1, to name a couple). An example of PEAR-style
    namespaces:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 5.3 之前，由于缺乏命名空间结构，使用了 PEAR 风格的命名空间。PEAR 是 PHP 扩展和应用仓库的缩写，在那些美好的日子里，它是一个可重用组件的仓库。它仍然活跃，但不是很方便，而且很少有人再使用它——尤其是在
    Composer 和 Packagist 引入之后。作为可重用组件的来源，PEAR 需要一种避免类名冲突的方法，因此贡献者开始将命名空间前缀添加到类名中。还有一些项目使用这种命名空间形式（例如
    *PHPUnit* 和 *Zend* 框架 1）。以下是一个 PEAR 风格命名空间的示例：
- en: 'The following would be an example of PEAR-style namespaces:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 PEAR 风格命名空间的示例：
- en: '![](img/1.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/1.png)'
- en: 'The class name for the Bill entity, using PEAR-style namespaces, would become
    `BuyIt_Billing_Domain_Model_Bill_Bill`. However, this is a bit ugly, and it doesn''t
    follow one of the main Domain-Driven Design mantras: every class name should be
    named in terms of the Ubiquitous Language. For this reason, we strongly discourage
    its use.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PEAR 风格命名空间，Bill 实体的类名将变为 `BuyIt_Billing_Domain_Model_Bill_Bill`。然而，这有点难看，并且它没有遵循领域驱动设计的主要原则之一：每个类名都应该用通用语言来命名。因此，我们强烈反对使用它。
- en: PSR-0 and PSR-4 Namespacing
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PSR-0 和 PSR-4 命名空间
- en: Namespaces entered the scene when *PHP 5.3* was introduced, along with other
    important features. This was a major shift, and a group of the most important
    framework collaborators emerged with [PHP-FIG](http://www.php-fig.org/), an acronym
    of PHP Framework Interop Group, in an attempt to standardize and unify common
    aspects of the framework and library creation. The first **PHP Standard Recommendation**
    (**PSR**) the group released was an autoloading standard that, in short, proposed
    a one-to-one relation between a class and a PHP file using namespaces. Today,
    [PSR-4](http://www.php-fig.org/psr/psr-4/) — a simplification of [PSR-0](http://www.php-fig.org/psr/psr-0/) that
    still maintains the relation between classes and physical PHP files — is the preferred
    and recommended way to structure code. We believe that this should be the one
    used to implement modules in a project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当 PHP 5.3 引入时，命名空间进入了场景，以及其他一些重要特性。这是一个重大转变，一些最重要的框架合作者组成了 [PHP-FIG](http://www.php-fig.org/)，即
    PHP 框架互操作性小组的缩写，试图标准化和统一框架和库创建的常见方面。该小组发布的第一个 **PHP 标准建议**（**PSR**）是一个自动加载标准，简而言之，它提出了一个类与
    PHP 文件之间的一对一关系，使用命名空间。今天，[PSR-4](http://www.php-fig.org/psr/psr-4/) —— 这是 [PSR-0](http://www.php-fig.org/psr/psr-0/)
    的简化版本，仍然保持了类与物理 PHP 文件之间的关系 —— 是结构代码的首选和推荐方式。我们相信，这应该是用于在项目中实现模块的方式。
- en: Referring back to the same folder structure shown in the previous section, let's
    see what changes with PSR-0\. The class name for the Bill Entity, using namespaces
    and PSR-0, would simply become Bill, and the fully qualified class name would
    be `BuyIt\Billing\Domain\Model\Bill\Bill`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾上一节中显示的相同文件夹结构，让我们看看 PSR-0 会有什么变化。使用命名空间和 PSR-0，Bill 实体的类名将简单地成为 Bill，完全限定类名将是
    `BuyIt\Billing\Domain\Model\Bill\Bill`。
- en: 'As you can see, this enables us to name Domain objects in terms of the Ubiquitous
    Language, and this is the preferred way to structure and organize code. If you''re
    using Composer, as you should be doing, you need to set some autoloading configurations
    in your `composer.json` file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这使我们能够用通用语言命名域对象，这是组织和结构代码的首选方式。如果您使用 Composer（您应该这样做），您需要在您的 `composer.json`
    文件中设置一些自动加载配置：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you''re not using PSR-4 or you haven''t migrated from PSR-0 yet, we strongly
    recommend doing so. You can get rid of the first-level namespace folder, and your
    code structure will better match the Ubiquitous Language:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有使用PSR-4或尚未从PSR-0迁移，我们强烈建议这样做。你可以去掉一级命名空间文件夹，你的代码结构将更好地匹配通用语言：
- en: '![](img/2.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2.png)'
- en: 'However, in order to avoid the collision with third-party libraries, it''s
    still recommended to add the first-level namespace in your `composer.json` file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了避免与第三方库冲突，仍然建议在`composer.json`文件中添加一级命名空间：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you prefer to have a first-level namespace but use PSR-4, there are some
    small changes to make:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用一级命名空间但使用PSR-4，需要做一些小的修改：
- en: '![](img/New3.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/New3.png)'
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you may have noticed in the examples, we split the `src` and `tests` folders.
    This was done in order to optimize the autoloading file generated by Composer,
    and it will reduce the memory needed to store the classmap. It will also help
    you set up whitelisting and blacklisting options when generating your unit testing
    code coverage reports. If you want to know more about Composer's autoloading configuration,
    take a look at the [documentation](https://getcomposer.org/doc/04-schema.md#autoload).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能在示例中注意到的，我们拆分了`src`和`tests`文件夹。这样做是为了优化Composer生成的自动加载文件，这将减少存储类映射所需的内存。它还将帮助你设置在生成单元测试代码覆盖率报告时的白名单和黑名单选项。如果你想了解更多关于Composer自动加载配置的信息，请查看[文档](https://getcomposer.org/doc/04-schema.md#autoload)。
- en: What about PHAR files?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，PHAR文件怎么办？
- en: They could also be used, however, we don't recommend this. As an exercise, make
    a list of pros and cons for using PHAR files to model modules.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以被使用，但我们不建议这样做。作为一个练习，列出使用PHAR文件来建模模块的优缺点列表。
- en: Bounded Contexts and Applications
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边界上下文和应用程序
- en: If we take the example of a fictional company called `BuyIt`, which deals with
    an e-commerce Domain, it may make sense to create a different application for
    each of the different Bounded Contexts solving specific Domain areas.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以一家名为“BuyIt”的虚构公司为例，该公司从事电子商务领域，为解决特定的领域区域，为每个不同的边界上下文创建不同的应用程序可能是有意义的。
- en: 'If some of the different Bounded Contexts are Order Management, Payment Management,
    Catalog Management, and Inventory Management, we recommend having an application
    for each one:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一些不同的边界上下文是订单管理、支付管理、目录管理和库存管理，我们建议为每个一个创建一个应用程序：
- en: '![](img/3.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3.png)'
- en: Each application exposes any set of delivery mechanisms needed. With the microservices
    trend, more and more people build Bounded Contexts that end up exposing REST APIs
    to the outside world. However, a Bounded Context is more than just an API. Remember
    that an API is just one of many delivery mechanisms; a Bounded Context can provide
    a web interface to interact with too.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都公开任何所需的交付机制。随着微服务趋势的兴起，越来越多的人构建最终向外界暴露REST API的边界上下文。然而，边界上下文不仅仅是API。记住，API只是许多交付机制之一；边界上下文还可以提供一个用于交互的Web界面。
- en: Can Two Bounded Contexts Be in the Same Application? What about the Other Way
    Around?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 两个边界上下文能否在同一个应用程序中？反过来呢？
- en: The best option is one Subdomain, one Bounded Context, and one application.
    If we have a Bounded Context implemented with two applications, the maintenance
    and the deployment get a bit tricky. And in the case of an application implementing
    two Bounded Contexts, the deployment process, the time for running the tests,
    and merging issues can slow down the development.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳选择是一个子域，一个边界上下文，一个应用程序。如果我们有一个使用两个应用程序实现的边界上下文，维护和部署会变得有些棘手。如果一个应用程序实现了两个边界上下文，部署过程、运行测试的时间和合并问题可能会减慢开发速度。
- en: 'Beware that each Bounded Context name represents a meaningful concept in our
    e-commerce Domain and is named in terms of the Ubiquitous Language:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个边界上下文名称代表我们电子商务领域中的一个有意义的概念，并且是以通用语言命名的：
- en: '**Catalog** to hold all the code related to the product descriptions, product
    combinations, and so on.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录**用于存放所有与产品描述、产品组合等相关代码。'
- en: '**Inventory** to hold all the code related to the management of product stocks.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库存**用于存放所有与产品库存管理相关的代码。'
- en: '**Orders** to hold all the code related to the order processing systems. It
    will contain the finite-state machine in charge of processing orders.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订单**用于存放所有与订单处理系统相关的代码。它将包含负责处理订单的有限状态机。'
- en: '**Payments** to hold all the code related to payments, bills, and waybills.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Payments** 用于存放所有与支付、账单和运单相关的代码。'
- en: Structuring Code in Modules
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模块中组织代码
- en: 'Let''s dig a bit further into one of the Bounded Contexts. Take, for example,
    the Orders context and examine the structure details. As its name suggests, this
    Bounded Context is responsible for representing all the flows that an order passes
    — from its creation up to delivering to the customer who has purchased it. Furthermore,
    it''s an independent Application, so it contains a source code folder and a tests
    folder. The source code folder contains all the code necessary for this Bounded
    Context to work: the Domain code, the Infrastructure code, and the Application
    layer.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨其中一个边界上下文。以订单上下文为例，并检查结构细节。正如其名称所暗示的，这个边界上下文负责表示订单所经过的所有流程——从其创建到交付给购买者的过程。此外，它是一个独立的应用程序，因此包含源代码文件夹和测试文件夹。源代码文件夹包含使此边界上下文正常工作所需的所有代码：领域代码、基础设施代码和应用层。
- en: 'The following diagram should illustrate the organization:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表应说明组织结构：
- en: '![](img/4.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4.png)'
- en: 'All the code is prefixed with a vendor namespace named in terms of the organization
    name (`BuyIt`, in this case), and contains two subfolders: **Domain** holds all
    the Domain code, and **Infrastructure** holds the Infrastructure layer, thereby
    isolating all the Domain logic from the details of the Infrastructure layer. Following
    this structure, we''re making it clear that we''re going to use Hexagonal Architecture
    as a foundational architecture. Below is an example of an alternative structure
    that could be used:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码都以前缀为组织名称（在这种情况下为 `BuyIt`）的供应商命名空间命名，并包含两个子文件夹：**Domain** 包含所有领域代码，**Infrastructure**
    包含基础设施层，从而将所有领域逻辑与基础设施层的细节隔离开来。遵循此结构，我们明确表示我们将使用六边形架构作为基础架构。以下是一个可用的替代结构示例：
- en: '![](img/5.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5.png)'
- en: The above style of structure uses an additional subfolder to store the Services
    defined inside the Domain Model. While this organization may make sense, our preference
    here is to not use it, since this way of separating code tends to be more focused
    on the architectural elements rather than the relevant concepts in the model.
    We believe this style could easily lead to some sort of Service layer on top of
    the Domain Model, which isn't necessarily a bad thing. Remember that Domain Services
    are used to describe operations in the Domain that don't belong to Entities or
    Value Objects. So from now on, we'll stick with the previous code organization.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述结构风格使用一个额外的子文件夹来存储在领域模型中定义的服务。虽然这种组织方式可能是有意义的，但我们的偏好是不要使用它，因为这种分离代码的方式往往更关注于架构元素，而不是模型中的相关概念。我们相信这种风格很容易导致在领域模型之上出现某种服务层，这并不一定是一件坏事。记住，领域服务用于描述不属于实体或值对象的领域中的操作。因此，从现在起，我们将坚持使用之前的代码组织方式。
- en: It's possible to place code directly inside the `Domain/Model` subfolder. For
    example, it may be customary to place common interfaces and Services, like the
    `DomainEventPublisher` or the `DomainEventSubscriber`, in it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 可以直接在 `Domain/Model` 子文件夹中放置代码。例如，可能习惯于在其中放置常见的接口和服务，如 `DomainEventPublisher`
    或 `DomainEventSubscriber`。
- en: 'If we had to model an Order Management context, we''d probably have an `Order`
    Entity with its Repository and all the state information. So our first attempt
    would be to place all those elements directly into the `Domain/Model` subfolder.
    At first glance, this may seem like the simplest way:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须对订单管理上下文进行建模，我们可能会有一个 `Order` 实体及其存储库和所有状态信息。因此，我们的第一次尝试可能是直接将这些元素放置在
    `Domain/Model` 子文件夹中。乍一看，这似乎是最简单的方法：
- en: '![](img/6.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6.png)'
- en: Design Guidelines
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计指南
- en: 'Consider some basic rules and typical issues to pay attention to when implementing
    modules:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一些基本规则和典型问题，在实现模块时要注意：
- en: Namespaces should be named in terms of Ubiquitous Language.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间应使用通用语言命名。
- en: Don't name your namespaces based on patterns or building blocks (Value Objects,
    Services, Entities, and so on).
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要根据模式或构建块（值对象、服务、实体等）来命名你的命名空间。
- en: Create namespaces so that what's inside is as loosely coupled with other namespaces
    as possible.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建命名空间，使得其内部内容尽可能松散地与其他命名空间耦合。
- en: Refactor namespaces the same way as your code. Move them, rename them, group
    them, extract them, and so on.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以与你的代码相同的方式重构命名空间。移动它们、重命名它们、分组它们、提取它们，等等。
- en: Don't use commercial product names, as they can change. Stick to the Ubiquitous
    Language.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用商业产品名称，因为它们可能会改变。坚持使用通用语言。
- en: 'We''ve placed the Order and the `OrderLine` Entities, the `OrderLineWasAdded`
    and the `OrderWasCreated` Event, and the `OrderRepository` into the same subfolder
    `Domain/Model`. This structure may be fine, but that''s because we still have
    a simple model. What about the `Bill` Entity and its Repository? Or the `Waybill`
    Entity and its respective Repository? Let''s add all those elements and see how
    they fit into the actual code structure:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将订单和`OrderLine`实体、`OrderLineWasAdded`和`OrderWasCreated`事件以及`OrderRepository`放入同一个子文件夹`Domain/Model`中。这种结构可能很好，但这是因为我们仍然有一个简单的模型。那么`Bill`实体及其仓库呢？或者`Waybill`实体及其相应的仓库？让我们添加所有这些元素，看看它们如何适应实际的代码结构：
- en: '![](img/7-1.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7-1.png)'
- en: While this style of code organization could be fine, it can become non-practical
    and rather unmaintainable in the long run. Every time we iterate and add new features,
    the model will become even bigger, and the subfolder will be eating even more
    code. We need to split the code in a way that give us a perspective of the model
    at a glance. No technical concerns, just Domain concerns. To reach this, we can
    split the model using the Ubiquitous Language, by finding meaningful concepts
    that help us group elements logically in terms of the Domain.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种代码组织风格可能很好，但从长远来看，它可能变得不切实际且难以维护。每次我们迭代并添加新功能时，模型都会变得更大，子文件夹将消耗更多的代码。我们需要以某种方式拆分代码，以便我们可以一眼看出模型的全貌。没有技术问题，只有领域问题。为了达到这个目标，我们可以使用通用语言来拆分模型，通过找到有助于我们在领域内逻辑地分组元素的有意义的概念。
- en: 'To do this, we could try the following approach:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可以尝试以下方法：
- en: '![](img/8.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8.png)'
- en: This way, the code is more organized, conceptually speaking. And as Eric Evans
    points out in [the Blue Book](http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215),
    modules are a way to communicate, as they provide us with insights about how the
    Domain Model works internally, along with helping us increase the cohesion and
    decrease the coupling between the concepts. If we look at the previous example,
    we can see that the concepts `Order` and `OrderLine `are strongly related, so
    they live in the same module. On the other hand, Order and Waybill, although sharing
    the same context, are different concepts, so they live in different modules. Modules
    are not just a way to group related concepts in the model, but also a way to express
    part of the design of the model.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，代码在概念上更加有序。正如埃里克·埃文斯在[《蓝皮书》](http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)中指出的，模块是沟通的一种方式，因为它们为我们提供了关于领域模型内部工作方式的见解，同时帮助我们增加概念之间的内聚性并减少耦合性。如果我们看看之前的例子，我们可以看到概念`Order`和`OrderLine`之间有很强的关联，所以它们位于同一个模块中。另一方面，订单和运单，尽管共享相同的环境，但它们是不同的概念，所以它们位于不同的模块中。模块不仅仅是将模型中的相关概念分组的一种方式，也是表达模型设计部分的一种方式。
- en: Should We Place Repositories, Factories, Domain Events, and Services in Their
    Own Subfolders?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否应该将仓库、工厂、领域事件和服务放在各自的子文件夹中？
- en: Effectively, they could be placed into their own subfolders, but it's strongly
    discouraged. In doing so, we would be mixing technical concerns and Domain concerns
    — remember that the module's main interest is to group related concepts from the
    Domain model and decouple them from non-related concepts. Modules don't separate
    code but instead separate meaningful concepts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它们可以被放入它们自己的子文件夹中，但强烈建议不要这样做。这样做，我们会混淆技术问题和领域问题——记住，模块的主要兴趣是分组来自领域模型的相关概念，并将它们与不相关的概念解耦。模块不是分离代码，而是分离有意义的概念。
- en: Modules in the Infrastructure Layer
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施层的模块
- en: Thus far, we've been discussing how we structure and organize code in the Domain
    layer, but we've said almost nothing about the Infrastructure layer. And since
    we're using Hexagonal Architecture to inverse the dependency between the Domain
    layer and the Infrastructure layer, we'll need a place where we can put all the
    implementations of the interfaces defined in the Domain layer. Returning to the
    example of the billing context, we need a place for the implementations of `BillRepository`,
    `OrderRepository`, and `WaybillRepository`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在讨论如何在领域层中结构和组织代码，但我们几乎没有提到基础设施层。由于我们正在使用六边形架构来反转领域层和基础设施层之间的依赖关系，我们需要一个可以放置所有在领域层中定义的接口实现的地方。回到计费上下文的例子，我们需要一个放置`BillRepository`、`OrderRepository`和`WaybillRepository`实现的地方。
- en: 'It''s clear that they should be placed into the Infrastructure folder, but
    where? Suppose we decided to use Doctrine ORM to implement the persistence layer.
    How do we put the Doctrine implementations of our Repositories into the Infrastructure
    folder? Let''s do it directly and see how it looks:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，它们应该放在基础设施文件夹中，但具体在哪里？假设我们决定使用 Doctrine ORM 来实现持久性层。我们如何将我们的存储库的 Doctrine
    实现放入基础设施文件夹？让我们直接操作并看看效果：
- en: '![](img/9.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片9](img/9.png)'
- en: 'We could leave this as is, but as we saw in the Domain layer, this structure
    and organization will rot fast and become a mess within a few model iterations.
    Each time the model grows, it''ll probably need even more Infrastructure, and
    we''ll end up mixing different technical concerns such as persistence, messaging,
    logging, and more. Our first attempt to avoid a tangled mess of Infrastructure
    implementations is to define a module for each technical concern in the Bounded
    Context:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以保持现状，但正如我们在领域层看到的，这种结构和组织会很快腐烂，并在几个模型迭代后变得混乱。每次模型增长，可能需要更多的基础设施，我们最终会混合不同的技术问题，如持久性、消息传递、日志记录等。我们第一次尝试避免基础设施实现混乱的方法是为每个技术问题在边界上下文中定义一个模块：
- en: '![](img/10.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片10](img/10.png)'
- en: 'This looks much better and is a lot more maintainable in the long term than
    our first attempt. However, our namespaces are lacking some sort of relation to
    the Ubiquitous Language. Let''s consider a variation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来要好得多，并且从长远来看，比我们的第一次尝试更容易维护。然而，我们的命名空间缺少某种与通用语言的关系。让我们考虑一种变化：
- en: '![](img/11.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片11](img/11.png)'
- en: Much better. It matches our Domain Model organization, but inside the Infrastructure
    layer — plus everything seems easier to find. If you know beforehand that you'll
    always have a single persistence mechanism, you can stick with this structure
    and organization. It's rather simple and easy to maintain.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这要好得多。它与我们的领域模型组织相匹配，但位于基础设施层——而且似乎一切都更容易找到。如果你事先知道你将始终只有一个持久性机制，你可以坚持这种结构和组织。它相当简单且易于维护。
- en: 'But what about when you have to play with several persistence mechanisms? Nowadays,
    it''s quite common to have a relational persistence mechanism and some kind of
    shared in-memory persistence like Redis or Riak, or to have some sort of local
    in-memory implementation to be able to test the code. Let''s see how this fits
    into the actual approach:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但当你必须与几种持久性机制打交道时怎么办？如今，拥有关系型持久性机制和一些共享内存持久性（如 Redis 或 Riak）或拥有某种本地内存实现以便能够测试代码是很常见的。让我们看看这如何与实际方法相匹配：
- en: '![](img/12.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片12](img/12.png)'
- en: 'We recommend the above. However, all the Repository implementations are living
    in the same module. This could seem a bit odd when having so many different technologies.
    In case you find it interesting, you can create an additional module in order
    to group the related implementations by their underlying technology:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐上述方法。然而，所有存储库实现都生活在同一个模块中。当有这么多不同的技术时，这可能会显得有些奇怪。如果你对此感兴趣，你可以创建一个额外的模块来按其底层技术分组相关实现：
- en: '![](img/13.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片13](img/13.png)'
- en: This approach is similar to the unit testing organization. However, there are
    classes, configurations, templates, and so on. that can't be matched with the
    Domain Model. That's why you may have additional modules inside the Infrastructure
    one that are related to specific technologies.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与单元测试组织类似。然而，有一些类、配置、模板等无法与领域模型匹配。这就是为什么你可能在基础设施模块内部有额外的模块，它们与特定技术相关。
- en: Where should you place Doctrine mapping files or Twig templates?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该把 Doctrine 映射文件或 Twig 模板放在哪里？
- en: '![](img/14.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片14](img/14.png)'
- en: 'As you can see, in order to make Doctrine work, we need an `EntityManagerFactory`
    and all the mapping files. We may also include any other Infrastructure objects
    needed as base classes. Because they''re not directly related to our Domain Model,
    it''s better to place these resources in a different module. The same things happen
    with the Delivery Mechanisms (API, Web, Console Commands, and so on.). In fact,
    you can be using different PHP frameworks or libraries for each delivery mechanism:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，为了使 Doctrine 工作，我们需要一个 `EntityManagerFactory` 和所有映射文件。我们还可以包括任何其他作为基类的所需基础设施对象。因为它们与我们的领域模型没有直接关系，所以将这些资源放在不同的模块中会更好。同样的事情也发生在交付机制（API、Web、控制台命令等）上。实际上，您可以为每个交付机制使用不同的
    PHP 框架或库：
- en: '![](img/15.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片15](img/15.png)'
- en: In the previous example, we were using the Laravel Framework for serving the
    API, the Symfony Console Component as the entry point for the command line, and
    Silex and Slim for the web delivery mechanism. Regarding the `User` Interface,
    you should place it inside each delivery mechanism. However, if there's any chance
    to share the UI between different delivery mechanisms, you can create a module
    called UI at the same level as Persistence or Delivery. In general, our suggestion
    is struggling with how the frameworks tell you to organize your code. Frameworks
    should obey you, and not the other way around.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了Laravel框架来提供API服务，使用Symfony Console组件作为命令行的入口点，使用Silex和Slim作为Web交付机制。关于`用户界面`，你应该将其放置在每个交付机制内部。然而，如果有可能在不同交付机制之间共享UI，你可以在持久化或交付同一级别创建一个名为UI的模块。一般来说，我们的建议是努力按照框架指示的方式来组织代码。框架应该服从你，而不是反过来。
- en: Mixing Different Technologies
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合不同技术
- en: In large business-critical applications, it's quite common to have a mix of
    several technologies. For example, in read-intensive web applications, you usually
    have some sort of denormalized data source (Solr, Elasticsearch, Sphinx, and so
    on.) that provides all the reads of the application, while a traditional RDBMS
    like MySQL or Postgres is mainly responsible for handling all the writes. When
    this occurs, one of the concerns that normally arises is whether we can have read
    operations go with the search engine and write operations go with the traditional
    RDBMS data source. Our general advice here is that these kind of situations are
    a smell for CQRS, since we need to scale the reads and the writes of the application
    independently. So if you can go with CQRS, that's likely the best choice.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型业务关键型应用中，混合使用几种技术是很常见的。例如，在读取密集型的Web应用中，通常会有某种去规范化数据源（如Solr、Elasticsearch、Sphinx等），它提供应用的所有读取操作，而传统的RDBMS如MySQL或Postgres主要负责处理所有写入操作。当这种情况发生时，通常会出现的一个问题是，我们是否可以让读取操作与搜索引擎一起进行，而写入操作与传统的RDBMS数据源一起进行。我们在这里的一般建议是，这类情况是CQRS的信号，因为我们需要独立扩展应用的读取和写入。所以，如果您能采用CQRS，那可能是最佳选择。
- en: 'But if for any reason you can''t go with CQRS, an alternative approach is needed.
    In this situation, the use of the Proxy pattern from the *Gang of Four* comes
    in handy. We can define an implementation of a Repository in terms of the Proxy
    pattern:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您由于任何原因不能采用CQRS，则需要另一种方法。在这种情况下，使用来自*四人帮*的代理模式很有用。我们可以根据代理模式定义一个仓库的实现：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This example provides a naive implementation using the `DoctrineOrderRepository`
    and the Elastica client, a client to interact with an Elasticsearch server. Note
    that for some operations, we're using the RDBMS datasource, and for others, we're
    using the Elastica client. Also note that the add operation consists of two parts.
    The first one attempts to store the Order to the Elasticsearch index, and the
    second one attempts to store the Order into the relational database, delegating
    the operation to the Doctrine implementation. Take into account that this is just
    an example and a way to do it. It can probably be improved — for example, now
    the whole add operation is synchronous. We could instead enqueue the operation
    to some sort of messaging middleware that stores the Order in Elasticsearch, for
    example. There are a lot of possibilities and improvements, depending on your
    needs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本例提供了一个使用`DoctrineOrderRepository`和Elastica客户端的简单实现，Elastica客户端是一个用于与Elasticsearch服务器交互的客户端。请注意，对于某些操作，我们使用RDBMS数据源，而对于其他操作，我们使用Elastica客户端。此外，请注意，添加操作由两部分组成。第一部分尝试将订单存储到Elasticsearch索引中，第二部分尝试将订单存储到关系型数据库中，并将操作委托给Doctrine实现。请记住，这只是一个示例和一种做法。它可能需要改进——例如，现在整个添加操作是同步的。我们可以将操作入队到某种消息中间件中，例如，以便将订单存储在Elasticsearch中。有很多可能性，具体取决于您的需求。
- en: Modules in the Application Layer
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用层中的模块
- en: We've seen Domain and Infrastructure modules, so now let's take a look at the
    Application layer. In Domain-Driven Design, we suggest using Application Services
    as a way of decoupling the client from both the Domain Model and the necessary
    knowledge on how to interact with it. As you'll see in [Chapter 11](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml),
     *Application*, an Application Service is built with its dependencies, is executed
    with a DTO request, and returns a DTO response.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了领域和基础设施模块，现在让我们看看应用程序层。在领域驱动设计中，我们建议使用应用程序服务作为从客户端解耦领域模型及其交互所需必要知识的一种方式。正如你将在[第11章](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml)中看到的，*应用程序*，一个应用程序服务与其依赖项一起构建，使用DTO请求执行，并返回DTO响应。
- en: 'It can also use an output dependency to return the result:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以使用输出依赖项来返回结果：
- en: '![](img/16.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/16.png)'
- en: Our suggestion is to create modules around Application Services. Each module
    will hold its request and response. If you're using the Data Transformer as an
    output dependency, follow the Infrastructure approach as you would with the UI.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的建议是围绕应用程序服务创建模块。每个模块将包含其请求和响应。如果你使用数据转换器作为输出依赖项，就像处理UI一样，遵循基础设施方法。
- en: Wrap-Up
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Modules are a way of grouping and separating concepts in our application. Modules
    should be named following the Ubiquitous Language. We shouldn't forget that modules
    are a way to communicate high-level concepts, which aids us in keeping coupling
    low and cohesion high. We've seen that we could create meaningful modules even
    in old versions of PHP by using prefixes. Nowadays, it's easy to build our modules
    following the PSR-0 and PSR-4 namespacing conventions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是我们应用中分组和分离概念的一种方式。模块的命名应遵循通用语言。我们不应忘记模块是传达高级概念的一种方式，这有助于我们保持耦合度低、内聚度高。我们已看到，通过使用前缀，即使在旧版本的PHP中，我们也能创建有意义的模块。如今，遵循PSR-0和PSR-4命名空间约定来构建模块变得很容易。
