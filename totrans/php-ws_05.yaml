- en: 5\. Object-Oriented Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to declare classes with constants,
    attributes, and methods; instantiate a class; work with constructors and destructors;
    implement class inheritance, access modifiers, static fields, and methods; use
    class type hinting as dependency injection; use attribute and method overriding;
    apply attribute and method overloading via magic methods; use final classes and
    methods; autoload classes; and use traits and apply namespacing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, we will have a look at **Object-Oriented Programming** (**OOP**)
    concepts that can be leveraged to write modular code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to understand the **Object-Oriented Programming** (**OOP**) approach,
    we should start by discussing the procedural-oriented programming approach first.
    The procedural approach is the conventional way of writing code in high-level
    languages where a problem is considered a sequence of things to be performed,
    such as walking, eating, reading, and so on. A number of functions can be written
    to accomplish such tasks. The procedural approach organizes a set of computer
    instructions into groups called procedures – also known as functions. Therefore,
    functions are first-class citizens in your code. When we focus that much on functions,
    consequently, the data gets less attention.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: In a multi-function program, despite the fact that functions can house local
    data, a lot of important data is defined as global data. Several functions might
    operate on such global data and, therefore, the data might become vulnerable.
    Also, such an approach might not establish a secure way of interacting with data
    using functions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows you how functions operate on global data and how
    they interact with each other:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Data and functions in the procedural-oriented approach'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_05_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.1: Data and functions in the procedural-oriented approach'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the object-oriented approach comes with a number of different ways to
    secure your data by tying the data more closely to the functions so that accidental
    modifications to the data from external functions can be prevented. The approach,
    by nature, allows us to decompose a large problem into smaller entities called
    objects and bundles the data and functions into such objects. The following figure
    shows how data and functions are organized into objects:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: Data and functions in the object-oriented approach'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_05_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.2: Data and functions in the object-oriented approach'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: A programming approach should address major concerns, such as how we represent
    real-life problem entities in a program, how to design a program with standard
    interfaces to interact with functions, how to organize a program into a number
    of modules so that we can reuse and extend them later, how to add new features
    to such modules, and much more. The object-oriented approach was developed to
    address such issues.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The Object-Oriented Approach
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象方法
- en: In programming, a thing that is describable and has a certain set of actions
    can be referred to as an object. An object might represent a real-life entity
    with a certain number of actions to perform. A dog can be described by using certain
    states, such as color, breed, age, and so on, and performs certain actions, such
    as barking, running, wagging its tail, and so on. A table fan can be described
    by color, speed, direction, and so on, and perform actions such as changing speed,
    changing direction, rotating, and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，一个可描述的事物，具有一组特定的动作，可以被称为对象。一个对象可能代表一个具有一定数量动作执行的现实生活实体。可以用某些状态来描述狗，如颜色、品种、年龄等，并执行某些动作，如吠叫、奔跑、摇尾巴等。台式风扇可以用颜色、速度、方向等来描述，并执行改变速度、改变方向、旋转等动作。
- en: In OOP, data and code are bundled together into an entity, which is known as
    an object. Objects interact with each other. Consider a teacher object and a student
    object. The teacher might have certain subjects to offer and the student might
    enroll in these subjects. Hence, if we consider enrolling as an action of the
    student, then the student object might need to interact with the teacher object
    regarding the available subjects and register for one or more subjects. Simply
    put, an object is data that performs actions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，数据和代码被捆绑成一个实体，称为对象。对象之间相互交互。考虑一个教师对象和一个学生对象。教师可能有一些科目可以提供，学生可能注册这些科目。因此，如果我们考虑注册是学生的一个动作，那么学生对象可能需要与教师对象就可用科目进行交互，并注册一个或多个科目。简单来说，对象是执行动作的数据。
- en: Bundling code into objects has its own benefits, such as your code base becoming
    modular, which means you can maintain, reuse, and debug your code individually
    against objects. The implementation of an object (code) remains hidden from the
    outside world, which means we can hide our data and internal complexities and
    can interact with the object via a standard set of procedures. For example, in
    order to use a table fan, you don't need to learn about AC motors or electronic
    circuitry; rather, you can use the table fan via the provided actions, such as
    the speed control buttons or rotation control. Hence, hiding such information
    is another important aspect of OOP.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码打包成对象有其自身的好处，例如你的代码库变得更加模块化，这意味着你可以单独针对对象进行维护、重用和调试。对象的实现（代码）对外界是隐藏的，这意味着我们可以隐藏我们的数据和内部复杂性，并且可以通过一套标准的程序与对象交互。例如，为了使用台式风扇，你不需要了解交流电机或电子电路；相反，你可以通过提供的行为来使用台式风扇，例如速度控制按钮或旋转控制。因此，隐藏此类信息是面向对象编程的另一个重要方面。
- en: Such code bundling also differentiates OOP from procedural programming. An object
    simply contains attributes, also known as data, and a bunch of methods to communicate
    with that object. These methods are the functions of procedural programming. In
    OOP, some of these methods can be used to interact with that object, and these
    methods therefore make up its interface.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码打包也区分了面向对象编程和过程式编程。一个对象简单地包含属性，也称为数据，以及一些与该对象通信的方法。这些方法是过程式编程的功能。在面向对象编程中，这些方法中的一些可以用来与该对象交互，因此这些方法构成了它的接口。
- en: There are a good number of famous programming languages, such as C++, Java,
    PHP, Python, C#, JavaScript, Ruby, Dart, Swift, Objective-C, and so on, that support
    OOP. Since the introduction of PHP to its most recent version, PHP supports the
    complete set of object-oriented models. PHP supports class-based object initiation,
    constructors and destructors, inheritance, property visibility, polymorphism,
    abstract and final classes, static fields and methods, anonymous classes, interfaces,
    namespaces, magic methods, object cloning, object comparisons, type hinting, traits,
    and much more interesting OOP techniques and tools. We will be discussing them
    in this chapter and will practice the concepts of OOP using different examples.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多著名的编程语言支持面向对象编程，例如C++、Java、PHP、Python、C#、JavaScript、Ruby、Dart、Swift、Objective-C等等。自从PHP引入其最新版本以来，PHP支持完整的面向对象模型。PHP支持基于类的对象初始化、构造函数和析构函数、继承、属性可见性、多态、抽象和最终类、静态字段和方法、匿名类、接口、命名空间、魔术方法、对象克隆、对象比较、类型提示、特性等许多有趣的面向对象技术和工具。我们将在本章中讨论它们，并使用不同的示例来实践面向对象编程的概念。
- en: OOP Concepts
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象概念
- en: 'The object-oriented approach addresses programming problems using the generalized
    concepts given in the following list. In this chapter, we are going to discuss
    these concepts in detail and practice them using a number of exercises so that,
    by the end of the chapter, we''ll be used to working with these concepts:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的方法使用以下列表中给出的通用概念来解决编程问题。在本章中，我们将详细讨论这些概念，并通过一系列练习来实践它们，以便在章节结束时，我们将习惯于使用这些概念：
- en: Objects are entities with data and interfaces. They may represent a person,
    a vehicle, a table fan, or maybe a bank account that plays a role in our program.
    Data and functions (or methods) live together inside an object.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象是有数据和接口的实体。它们可能代表一个人、一辆车、一个电风扇，或者可能是一个在我们的程序中扮演角色的银行账户。数据和函数（或方法）共同存在于一个对象中。
- en: Classes are templates for object creation. Data is the description of an object,
    while functions are the behaviors of that object, so such definitions of data
    and methods can be written using a class. Classes can be referred to as custom
    data types.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是对象创建的模板。数据是对象的描述，而函数是那个对象的行为，因此可以使用类来编写数据和方法的定义。类可以被称为自定义数据类型。
- en: Data encapsulation is the wrapping up of data and functions into a single unit
    – that is, a class. Imagine an unbreachable capsule with data and functions encapsulated
    inside so that the outside world cannot access the data as long as we don't expose
    methods for them. Such insulation of the data from direct access by the program
    is called data hiding. In short, declaring a class is the encapsulation of data.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据封装是将数据和函数封装成一个单一单元——即类。想象一个不可穿透的胶囊，其中封装着数据和函数，这样外部世界就不能访问数据，除非我们为它们提供访问方法。这种将数据从程序直接访问中隔离出来的过程称为数据隐藏。简而言之，声明一个类就是数据的封装。
- en: Data abstraction is the act of representing essential properties and features
    without giving details. So, the entire entity description remains abstract and
    the responsibility of detailing the entity can be done via the entity creation
    process or inheritance. Such abstraction enables everyone to "follow the guidelines
    and do it your way."
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据抽象是不提供细节而表示基本属性和特征的行为。因此，整个实体描述保持抽象，详细描述实体的责任可以通过实体创建过程或继承来完成。这种抽象使得每个人都可以“遵循指南，按自己的方式行事。”
- en: Inheritance is the process of acquiring properties and behaviors of another
    class so that common properties and behaviors can be reused in a hierarchical
    manner.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承是获取另一个类的属性和行为的过程，这样就可以以分层的方式重用共同的属性和行为。
- en: Polymorphism is the concept of using the same definition for multiple purposes.
    For example, flying is a polymorphic behavior, as birds and airplanes have their
    own different ways of flying.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态是使用相同定义进行多个目的的概念。例如，飞行是一种多态行为，因为鸟类和飞机有它们自己不同的飞行方式。
- en: Dynamic binding is the linking of a function call to the code that will be executed
    in response to the function call. With this concept, the code associated with
    the given function is unknown until the call is made at runtime. Say that multiple
    objects implemented the same function differently and at runtime, the code matching
    the object being referenced would be called.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态绑定是将函数调用与响应函数调用的代码链接起来的过程。有了这个概念，与给定函数关联的代码在运行时调用之前是未知的。比如说，多个对象以不同的方式实现了同一个函数，在运行时，与被引用的对象匹配的代码会被调用。
- en: Message passing is the way that objects interact with each other. It involves
    specifying the object name, the name of the methods, and the information to be
    sent. For example, if a car is an object, changing speed is a method on it, and
    speed in kilometers per hour is the speed parameter to be passed. The outside
    world will use the car object to send the "change speed" message to that parameter.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息传递是对象之间交互的方式。它涉及指定对象名称、方法名称和要发送的信息。例如，如果一辆车是一个对象，改变速度是它上面的一个方法，每小时千米数是传递的速度参数。外部世界将使用汽车对象将“改变速度”的消息发送给该参数。
- en: '*Figure 5.3* depicts the preceding concepts using a vehicle analogy:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.3* 使用车辆类比来展示前面的概念：'
- en: '![Figure 5.3: Vehicle property inheritance diagram'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3：车辆属性继承图'
- en: '](img/C14196_05_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_05_03.jpg)'
- en: 'Figure 5.3: Vehicle property inheritance diagram'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：车辆属性继承图
- en: There are many different types of vehicles, such as cars, buses, motorcycles,
    airplanes, and many more. Vehicles have general properties such as make, model,
    color, wheels, engine size, and so on. These are the common properties found in
    vehicle subtypes or classes too. Since cars, buses, motorcycles, and so on share
    a common list of properties, those common properties and behaviors come from the
    parent class, and each subclass adds its very own properties and behaviors. For
    example, cars have four wheels and motorcycles are two-wheelers, cars have more
    passenger capacity than a motorcycle, and so on. Therefore, such deviations of
    vehicle types should be placed into their own vehicle subclasses. Thus, we can
    inherit common properties and gradually add our own properties using object-oriented
    concepts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同类型的车辆，例如汽车、公共汽车、摩托车、飞机等等。车辆具有一般属性，如制造商、型号、颜色、车轮、发动机大小等。这些是车辆子类型或类中常见的属性。由于汽车、公共汽车、摩托车等共享一个共同的属性列表，这些共同的属性和行为来自父类，每个子类都添加它自己的属性和行为。例如，汽车有四个车轮，摩托车是两轮车，汽车比摩托车有更多的乘客容量，等等。因此，这种车辆类型的偏差应该放置在其自己的车辆子类中。因此，我们可以继承共同的属性，并逐步添加我们自己的属性，使用面向对象的概念。
- en: Classes
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: A class is a blueprint of an object. What data an object should contain and
    what methods are needed to access that data can be described using a class. A
    class acts as a template for object creation. Consider a car designed using a
    blueprint as a guide. Vehicle type, make, model, engine size, color, and so on
    are defined in the `Car` class along with the methods to retrieve this information,
    such as get the model name, start the engine, and so on.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 类是对象的蓝图。一个对象应该包含哪些数据以及需要哪些方法来访问这些数据可以使用类来描述。类充当对象创建的模板。考虑使用蓝图作为指南设计的汽车。车辆类型、制造商、型号、发动机大小、颜色等都在
    `Car` 类中定义，以及检索这些信息的方法，例如获取型号名称、启动发动机等。
- en: A class begins with the `class` keyword followed by the given name and the body
    enclosed in a pair of curly braces. The body of the class houses class members
    and they are variables, constants, functions, class variables (also known as class
    properties or class attributes), and the functions that belong to the class, known
    as class methods.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类以 `class` 关键字开始，后跟给定的名称，并用一对花括号括起来的主体。类的主体包含类成员，它们是变量、常量、函数、类变量（也称为类属性或类属性），以及属于类的函数，称为类方法。
- en: 'Check out the following class declaration:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下类声明：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A class name starts with letters or underscores followed by any number of alphanumeric
    characters and underscores. PHP's predefined class names, constants, and reserved
    keywords – for example, `break`, `else`, `function`, `for`, `new`, and so on –
    cannot be used as a class name.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 类名以字母或下划线开头，后跟任意数量的字母数字字符和下划线。PHP 的预定义类名、常量和保留关键字（例如，`break`、`else`、`function`、`for`、`new`
    等）不能用作类名。
- en: The list of reserved words in PHP can be found at [https://packt.live/2M3QL1d](https://packt.live/2M3QL1d).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 中保留字列表可以在 [https://packt.live/2M3QL1d](https://packt.live/2M3QL1d) 找到。
- en: In the PHP Standards Recommendations, PSR-1 recommends that a class name is
    declared in `CamelizedClassName` and class methods are declared in `camelizedMethodName`.
    Note the camel case of *class name* and the use of lowercase at the start of the
    method names.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 标准建议中，PSR-1 建议类名以 `CamelizedClassName` 声明，类方法以 `camelizedMethodName` 声明。注意
    *类名* 的驼峰式命名和在每个方法名开头使用小写字母。
- en: 'To learn more about PSR-1: Basic Coding Standard, visit [https://packt.live/2IBLprS](https://packt.live/2IBLprS).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 PSR-1：基本编码标准的信息，请访问 [https://packt.live/2IBLprS](https://packt.live/2IBLprS)。
- en: 'Let''s check out the following simple `Person` class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看以下简单的 `Person` 类：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `class Person {…}` is the `Person` class declaration. A single attribute
    has been added with the line `public $name = 'John Doe';`, and the body also contains
    the `sayHello()` member method, which prints a simple string.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`class Person {…}` 是 `Person` 类的声明。通过添加一行 `public $name = 'John Doe';` 添加了一个属性，并且主体还包含了
    `sayHello()` 成员方法，该方法会打印一个简单的字符串。
- en: In the next section, we will be discussing how we should instantiate a class
    and what happens in memory when we perform such an instantiation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论我们应该如何实例化一个类，以及当我们执行此类实例化时内存中会发生什么。
- en: Instantiating a Class
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化一个类
- en: 'An object is an instance of a class, so instantiating a class means creating
    a new object using the class. We can instantiate a class using the `new` keyword,
    as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象是一个类的实例，因此实例化一个类意味着使用该类创建一个新的对象。我们可以使用`new`关键字来实例化一个类，如下所示：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With the instantiation, an object is created in memory with copies of its own
    attributes. Here, the `$object` variable doesn't hold the actual object; rather,
    it points to the object. Just to be clear here, the `$object` variable is a pointer
    to the object and doesn't hold a reference to the object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化过程中，一个对象在内存中创建，并包含其自身的属性副本。在这里，`$object`变量并不持有实际的对象；相反，它指向该对象。为了明确起见，`$object`变量是对象的指针，并不持有对象的引用。
- en: The `$object` variable should be of the `MySimpleClass` type as classes are
    often called as custom data types. Then, the constructor method gets called automatically
    if one is declared. A class constructor and destructor are two special kinds of
    methods; for example, `__construct()` and `__destruct()`, which are called automatically
    with object creation and deletion, respectively.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`$object`变量应该是`MySimpleClass`类型，因为类通常被称为自定义数据类型。然后，如果声明了构造方法，构造方法会自动调用。类构造器和析构器是两种特殊的方法；例如，`__construct()`和`__destruct()`，它们分别在对象创建和删除时自动调用。'
- en: 'To access an object''s properties and methods, we can use the `->` object operator,
    as in the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问对象的属性和方法，我们可以使用`->`对象操作符，如下所示：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, object creation involves memory allocation followed by the constructor method
    being called automatically. We are going to discuss constructor and destructor
    methods in later sections.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对象的创建涉及内存分配，然后自动调用构造方法。我们将在后面的章节中讨论构造方法和析构方法。
- en: Class Attributes
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类属性
- en: As we have already seen, class attributes and variables hold data. To write
    a class attribute in PHP, we need to start with the `public`, `private`, or `protected`
    keyword, then the rest is the general PHP variable assignment statement. In the
    previous example, in the `Person` class, the `public $name = 'John Doe';` line
    was used to assign a person's name; here, the `public` keyword is an access modifier
    or class member visibility keyword and it has been used so that the attribute
    can be accessed outside of the class. We will be discussing access modifiers in
    detail in later sections.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，类的属性和变量持有数据。要在PHP中编写类属性，我们需要从`public`、`private`或`protected`关键字开始，然后是其余的一般PHP变量赋值语句。在先前的`Person`类示例中，`public
    $name = 'John Doe';`这一行被用来分配一个人的名字；在这里，`public`关键字是一个访问修饰符或类成员可见性关键字，它已经被用来确保属性可以在类外部被访问。我们将在后面的章节中详细讨论访问修饰符。
- en: 'Note that the class structure is compiled before the PHP file execution. Regarding
    value assignment in class attributes, the value should be static, meaning the
    value must not be dependent on the runtime. For example, the following class attributes
    won''t work:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类结构在PHP文件执行之前被编译。关于类属性的值赋值，值应该是静态的，这意味着值不能依赖于运行时。例如，以下类属性将不会工作：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the attributes are dependent on the `getdate()` function's return and
    an arithmetic expression evaluation, respectively, as function calling and the
    arithmetic expression evaluation won't be performed during the class' compile
    time and can be evaluated at runtime, so such variable initialization won't work
    in the case of class attributes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，属性分别依赖于`getdate()`函数的返回值和算术表达式评估，分别作为函数调用和算术表达式评估，这些都不会在类的编译时执行，而可以在运行时评估，因此这样的变量初始化在类属性的情况下不会工作。
- en: 'So, class attributes that do not involve in runtime information should be considered
    a good attribute, such as the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不涉及运行时信息的类属性应该被视为好的属性，例如以下内容：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the preceding variables can be evaluated at compile time rather than at
    runtime.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，前面的变量可以在编译时而不是在运行时评估。
- en: 'Non-static class attributes—for example, the `public`, `private`, and `protected`
    attributes—can be accessed by using the `$this` object context referrer variable
    with the `->` object operator, as in the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 非静态类属性——例如，`public`、`private`和`protected`属性——可以通过使用`$this`对象上下文引用变量和`->`对象操作符来访问，如下所示：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, static properties can be written with the `static` keyword at the start
    of the variable declaration and can be accessed using the `self` keyword followed
    by the `::` (double colon) operator. The double colon is also called the scope
    operator:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，静态属性可以用 `static` 关键字在变量声明开始处编写，并且可以使用 `self` 关键字后跟 `::`（双冒号）操作符来访问。双冒号也称为范围操作符：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: More on access modifiers and static properties can be found in later sections.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于访问修饰符和静态属性的更多内容可以在后面的章节中找到。
- en: Class Constants
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类常量
- en: 'Class-specific constants (fixed values that do not change throughout the program)
    can be written inside a class, as in the following examples:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 类特定的常量（在整个程序中不改变的固定值）可以写在类内部，如下面的示例所示：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that class constants do not use `$` as it is used in variable declaration
    and are all the letters are in uppercase. The default visibility of the constant
    is `public` and they can be accessed with the `::` scope operator from outside
    of the class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类常量不使用 `$` 符号，就像变量声明中使用的那样，并且所有字母都是大写。常量的默认可见性是 `public`，并且可以从类外部使用 `::`
    范围操作符来访问。
- en: Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: According to the PHP Standards Recommendations, PSR-1, "Class constants MUST
    be declared in all upper case with underscore separators." You can read more at
    [https://packt.live/2IBLprS](https://packt.live/2IBLprS).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 PHP 标准建议，PSR-1，“类常量必须全部大写，使用下划线分隔。”你可以在 [https://packt.live/2IBLprS](https://packt.live/2IBLprS)
    上了解更多信息。
- en: Class constants are allocated memory for a single class and not for every class
    instance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 类常量只为单个类分配内存，而不是为每个类实例分配。
- en: 'Also, you can use such constants using `self::` inside a class, as in the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以在类内部使用 `self::` 来使用此类常量，如下所示：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `self::` operator can be used only inside a class. Since PHP 5.6.0, the
    constant expression has been added as in the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`self::` 操作符只能在类内部使用。自 PHP 5.6.0 版本以来，已添加了常量表达式，如下所示：'
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Class constants also support access modifiers; for example, `public`, `private`,
    and so on, which will be demonstrated in the *Access Modifiers* section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 类常量也支持访问修饰符；例如，`public`、`private` 等，这些将在 *访问修饰符* 部分进行演示。
- en: You can use such constants in PHP interfaces, which are another OOP tool to
    establish a common interface or the standards that classes should implement.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 PHP 接口中使用此类常量，这是另一种面向对象编程工具，用于建立公共接口或类应该实现的规范。
- en: The $this Variable
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`$this` 变量'
- en: '`$this` is the pseudo variable that is available when class member variables
    or methods are called within an object context. `$this` works when we have instantiated
    a class and can be used to access the corresponding object''s members. So, to
    access an attribute in an object context, we use `$this->attribute_name`, and
    to access a method, we use `$this->methodName()`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`$this` 是在对象上下文中调用类成员变量或方法时可用的一个伪变量。当实例化一个类后，`$this` 就可以使用来访问相应对象的成员。因此，在对象上下文中访问一个属性时，我们使用
    `$this->attribute_name`，访问方法时使用 `$this->methodName()`。'
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For example, a `$name` attribute declared in the class should be accessed with
    `$this->name`, not with `$this->$name`. Mind the `$` here.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在类中声明的 `$name` 属性应该使用 `$this->name` 来访问，而不是使用 `$this->$name`。请注意这里的 `$` 符号。
- en: Class Methods
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类方法
- en: Class methods are just functions and act like wrappers on the class data assigned
    to attributes. Getter and setter are the two most common ways of fetching and
    assigning data, respectively. Both of these methods simply return and assign data
    from and to member variables. We might want to prefix the getter and setter methods
    with `get` and `set` followed by a quick descriptive method name of our choice;
    for example, `getMyValue()` or `setMyValue()`. Although this is not necessary,
    this practice improves code readability.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法只是函数，并且像包装器一样作用于分配给属性的类数据。获取器和设置器是分别获取和分配数据的两种最常见方式。这两种方法只是简单地从和向成员变量返回和分配数据。我们可能希望使用
    `get` 和 `set` 前缀以及我们选择的快速描述性方法名称来前缀获取器和设置器方法；例如，`getMyValue()` 或 `setMyValue()`。尽管这不是必需的，但这种做法可以提高代码的可读性。
- en: 'Check out the following getter and setter methods example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下获取器和设置器方法示例：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the key concept of such member methods is to provide a wrapper around
    the data available in an object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，此类成员方法的关键概念是为对象中可用的数据提供一个包装器。
- en: 'Along with these, another type of method can often be used that performs certain
    actions or executions based on the available data within the object:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，还可以使用另一种类型的方法，它根据对象内部可用的数据执行某些操作或执行：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, the `sayGreetings()` method could be an example of a member method that
    implements an algorithm to identify the current hour and load a greetings string
    into a local variable, and later on prints the greetings string with the given
    attribute value assigned at `$name`. The method works for printing greetings –
    for example, '`Good Morning John Doe`', '`Good Afternoon John Doe`', and '`Good
    Evening John Doe`' – based on the current hour in 24-hour format, returned by
    the `date('G')` function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sayGreetings()` 方法可以是实现识别当前小时并将问候字符串加载到局部变量的成员方法的示例，然后稍后使用分配给 `$name` 的给定属性值打印问候字符串。该方法用于打印问候语——例如，`'Good
    Morning John Doe'`、`'Good Afternoon John Doe'` 和 `'Good Evening John Doe'`——基于由
    `date('G')` 函数返回的 24 小时制当前小时。
- en: We also have some manager methods, such as constructor and destructor, to initiate
    properties of an object and clean up the memory utilized by an object, respectively.
    In later sections, we will be discussing them in detail.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些管理方法，如构造函数和析构函数，分别用于初始化对象的属性和清理对象使用的内存。在后面的章节中，我们将详细讨论它们。
- en: 'Exercise 5.1: Using the Getter and Setter Methods'
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.1：使用获取和设置方法
- en: 'In the following exercise, you will declare a `Vehicle` class with attributes
    such as make, model, color, and number of wheels. Also, to access and work on
    those given attributes, we will be declaring some methods, such as to get the
    model name, get the engine number, get the number of the wheels, and so on:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，你将声明一个具有型号、型号、颜色和轮子数量等属性的 `Vehicle` 类。此外，为了访问和操作这些给定的属性，我们将声明一些方法，例如获取型号名称、获取发动机编号、获取轮子数量等：
- en: 'Create a PHP file named `Vehicle.php` and declare the `Vehicle` class with
    the following attributes:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Vehicle.php` 的 PHP 文件，并声明具有以下属性的 `Vehicle` 类：
- en: '[PRE13]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A `Vehicle` object is described using a make, model, color, number of wheels,
    and engine number. Here, we have added this data about the vehicle in terms of
    class attributes. As different types of data can be bundled together inside a
    class, our `Vehicle` class can act as a custom data type. Just like the preceding
    class, we can enclose a lot of metadata about an object, as per OOP concepts.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用型号、型号、颜色、轮子数量和发动机编号来描述 `Vehicle` 对象。在这里，我们将有关车辆的数据添加为类属性。由于不同类型的数据可以打包在类内部，我们的
    `Vehicle` 类可以充当自定义数据类型。就像前面的类一样，我们可以根据面向对象的概念封装大量关于对象的元数据。
- en: Note that the values that have been assigned to the class attributes do not
    depend on runtime; they can easily be assigned at compile time. All of them are
    clearly different types of data and are accessible or visible from outside the
    class as they use a public access modifier.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，分配给类属性的值不依赖于运行时；它们可以轻松地在编译时分配。所有这些都是不同类型的数据，并且由于它们使用公共访问修饰符，因此可以从类外部访问或可见。
- en: 'Now it is time to add member methods to the class. As per our exercise goal,
    we need to know information such as the number of wheels the vehicle has, the
    engine number, and the make, model, and color. In order to obtain that information,
    we are going to add the following five methods after the attributes section:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候向类添加成员方法了。根据我们的练习目标，我们需要了解有关车辆轮子数量、发动机编号、型号和颜色等信息。为了获取这些信息，我们将在属性部分之后添加以下五个方法：
- en: '[PRE14]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we have added five getter methods: `getMake()` returns the company name/make,
    `getModel()` returns the model name, `getColor()` returns the color name, `getNoOfWheels()`
    returns the number of wheels the vehicle has, and `getEngineNumber()` returns
    the engine number. All of these methods are pretty straightforward to execute,
    and they access the attributes using `$this` to return the values.'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们添加了五个获取方法：`getMake()` 返回公司名称/型号，`getModel()` 返回型号名称，`getColor()` 返回颜色名称，`getNoOfWheels()`
    返回车辆拥有的轮子数量，而 `getEngineNumber()` 返回发动机编号。所有这些方法执行起来都很简单，它们使用 `$this` 访问属性以返回值。
- en: 'To set the vehicle make, model, color, number of wheels, and engine number,
    we need setter methods. Now, let''s add the corresponding setter methods after
    the preceding five getters:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置车辆的型号、型号、颜色、轮子数量和发动机编号，我们需要设置方法。现在，让我们在前面五个获取方法之后添加相应的设置方法：
- en: '[PRE15]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we have added the five setter methods to set our appropriate class attributes.
    The `setMake($make)` method accesses the class attribute for `$make` using `$this->make`
    and assigns the `$make` argument to it. The same goes for `setModel($model)`,
    `setColor($color)`, `setNoOfWheels($wheels)`, and `setEngineNumber($engineNo)`.
    All of them access the corresponding class attributes to assign the passed parameter
    to them. Hence, we can set class attributes using setter methods.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们添加了五个设置器方法来设置适当的类属性。`setMake($make)` 方法使用 `$this->make` 访问类属性 `$make`
    并将 `$make` 参数分配给它。对于 `setModel($model)`、`setColor($color)`、`setNoOfWheels($wheels)`
    和 `setEngineNumber($engineNo)` 也是同样的情况。所有这些方法都访问相应的类属性，将传递的参数分配给它们。因此，我们可以使用设置器方法设置类属性。
- en: 'Finally, our class looks like the following:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们的类看起来如下所示：
- en: '[PRE16]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s instantiate the class as follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下方式实例化类：
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the class has been instantiated to create an object of the `Vehicle` class.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，类已经被实例化以创建 `Vehicle` 类的对象。
- en: 'Set the class attributes using the setter methods, as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用设置器方法设置类属性，如下所示：
- en: '[PRE18]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we have assigned the make, model, color, number of wheels, and engine
    number class attributes via the class member methods; that is, setter methods.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们通过类成员方法（即设置器方法）分配了制造、型号、颜色、车轮数量和发动机号类属性；也就是说，设置器方法。
- en: 'To access the data stored in the `Vehicle` object handler, `$object`, we need
    to use getter methods, as in the following:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问存储在 `Vehicle` 对象处理程序 `$object` 中的数据，我们需要使用获取器方法，如下所示：
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the `Vehicle.php` file using the `Vehicle.php` PHP command. The preceding
    code should output the following:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Vehicle.php` PHP 命令运行 `Vehicle.php` 文件。前面的代码应该输出以下内容：
- en: '![Figure 5.4: Vehicle object''s setter and getter methods'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4：车辆对象的设置器和获取器方法'
- en: '](img/C14196_05_04.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_05_04.jpg)'
- en: 'Figure 5.4: Vehicle object''s setter and getter methods'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：车辆对象的设置器和获取器方法
- en: So, we have a `Vehicle` class that describes a particular type of vehicle with
    different attributes associated to vehicle, and the getter and setter methods
    to work on the attributes. From now on, we will be working with this `Vehicle`
    class to exercise our OOP understanding.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个 `Vehicle` 类，它描述了具有与车辆相关联的不同属性的特定类型的车辆，以及用于操作这些属性的设置器和获取器方法。从现在开始，我们将使用这个
    `Vehicle` 类来练习我们的面向对象理解。
- en: Just to summarize, the exercise we walked through is all about defining a class,
    so the key learning here is that we have to add class attributes that sufficiently
    describe the particular type of object and write methods to set and fetch data
    from those attributes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 简要来说，我们刚才进行的练习完全是关于定义一个类，所以这里的关键学习是，我们必须添加足够描述特定类型对象的类属性，并编写设置和从这些属性获取数据的方法。
- en: In the next section, we will discuss how constructor and destructor methods
    fit a role in a class structure and walk through an exercise on how to instantiate
    the `Vehicle` class.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论构造函数和析构函数方法在类结构中的作用，并介绍一个关于如何实例化 `Vehicle` 类的练习。
- en: Constructor
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: A constructor, such as `__construct()`, is a special kind of method that is
    invoked automatically when instantiating a class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数，如 `__construct()`，是一种特殊的方法，在实例化类时自动调用。
- en: 'The syntax of a class constructor is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数的语法如下：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s add a `__construct()` method in our previously discussed `Person` class
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在之前讨论的 `Person` 类中添加一个 `__construct()` 方法，如下所示：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The key idea behind using a `__construct()` method is to perform the initial
    set of executions that need to be done immediately upon object creation. In the
    preceding simple approach, a `__construct()` method performs attribute assignment(s).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `__construct()` 方法的核心思想是在对象创建后立即执行需要执行的一组初始操作。在前面的简单方法中，`__construct()` 方法执行属性分配。
- en: 'Hence, we can create instances of the `Person` class like the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以创建 `Person` 类的实例，如下所示：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, the `MySimpleClass` constructor, `__construct()`, takes an argument, `$username`,
    and assigns it to the `$name` attribute by accessing it with `$this->name`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MySimpleClass` 构造函数 `__construct()` 接收一个参数 `$username`，并通过 `$this->name`
    访问它，将其分配给 `$name` 属性。
- en: Apart from the initial value assignment, a constructor method might hold a database
    connection, set cookies, hold an HTTP client, accept dependencies as arguments,
    and much more.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了初始值分配之外，构造函数方法可能包含数据库连接、设置cookie、持有HTTP客户端、接受依赖项作为参数等。
- en: A constructor method must not have a return statement, it can accept arguments,
    and the name should always be `__construct()`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Destructor
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The destructor method, `__destruct()`, is invoked automatically when an object
    is destroyed. When we remove an object or perhaps a PHP script ends its execution
    and releases the memory utilized by the variables, then `__destruct()` gets called.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of a class destructor is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s add a `__destruct()` method to our previously discussed `Person` class,
    as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, as an example, the `__destruct()` method can be added for log-keeping
    purposes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'If we `unset()` the object handler variable to destroy the object instance,
    as follows, the destructor should be called automatically:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Also, the destructor method is invoked automatically if no object is found
    in the memory, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Apart from the preceding manual object destruction, when the script execution
    ends, all the `__destruct()` methods within different objects are invoked automatically
    and PHP will start to release the memory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: A destructor method does not take arguments.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Just to summarize, so far, we have learned about class declaration with attributes
    and methods, the instantiation of a class, and constructor and destructor methods.
    Hence, we should walk through the next exercise to apply these concepts.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.2: Instantiating the Class and Printing the Details'
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following exercise, you will learn how to instantiate the `Vehicle`
    class that we created in the previous exercise. We will introduce a constructor
    to it so that we can assign attributes via the constructor''s parameters instead
    of assigning the values during the class declaration. We should be able to print
    that information using the corresponding getters:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Vehicle` class file, `Vehicle.php`, and you should see the attributes
    as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have a better way of assigning the values of these attributes using a constructor
    method.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify the attributes as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we have taken out the default values assigned to the attributes.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `__construct` method after the attributes section as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we have added the default values of the constructor's parameters as the
    default values for the attributes if no values were passed.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The constructor method will be invoked automatically with the instantiation
    of the `Vehicle` class. If we can pass parameters with the new object creation,
    they are received inside the constructor.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Within the `__construct()` method, assign the parameters to the corresponding
    attributes, as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we have assigned the attributes obtained from the constructor arguments.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Erase or comment out the following lines for the `Vehicle` class initialization
    and the use of setters and getters from `Vehicle.php`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We have erased these lines as we are going to include the `Vehicle.php` file
    in another file that will take care of the `Vehicle` initialization. So far, we
    have the `Vehicle` class ready to use in the next steps.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new PHP file called `vehicle-objects.php` in the same directory and
    add the following lines to require the `Vehicle` class:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the `vehicle-objects.php` script, we have added the `Vehicle` class using
    the `require_once` command, which will add the file if it's not already added
    or produce a fatal error in the event that the file is not found. For the next
    steps, we will be working on this file.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, it''s time to instantiate the class. Create an object without passing
    any arguments to the constructor as follows, after requiring the `Vehicle` class:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we have created an object of the `Vehicle` type with the `new` keyword
    and the constructor should be called after the memory allocation for the copy
    of the object's own attributes.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we have getter methods written already to access the preceding attributes,
    we should try to print the attribute information.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Print the attribute information with the following:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As all of the `Vehicle` member methods are public, we can access the vehicle
    data via the interface of the instantiated `$vehicle` object.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Also, all of the `Vehicle` attributes are public, so we can access the attributes
    using the `$vehicle` object handler outside of the class. So, the following code
    should output the same as the preceding:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The standard way to access object attributes is via the object's member methods.
    When we apply restrictions on object attributes, accessing them should be performed
    via object interfaces or methods only.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'From the terminal or console, run `vehicle-objects.php` using the `php vehicle-objects.php`
    command. The preceding code outputs the following:![Figure 5.5: Vehicle object''s
    default attributes'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_05_05.jpg)'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.5: Vehicle object''s default attributes'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we haven't passed arguments to the class constructor, so the default parameter
    values have been assigned to the attributes.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we will create another object with parameters passed to the constructor
    after the lines in *step 7*, like the following:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Rerun `Vehicle.php` using the `php vehicle-objects.php` command. The portion
    of code in *step 9* outputs the following:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6: Printing the details on the terminal'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_05_06.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.6: Printing the details on the terminal'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: So, the attributes' initial values can be settled via the constructor parameters.
    Regardless of the constructor parameters, attributes can be assigned using setter
    methods when you want to prevent direct access to your attributes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement the idea of reusability, we need to learn the process of acquiring
    the properties of objects of one class (the parent class) using the objects of
    another class (the child class). Hence, inheritance is the process of deriving
    one class from a base class (the parent class) and the derived class (a child
    class or subclass).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance supports the flow of information in a hierarchical way to the derived
    objects so that, along with the inherited properties, the derived class can add
    its own properties. Again, such a derived class can be inherited by another and
    so on. Bundled data and actions can be reused in an organized manner to add additional
    features to derived classes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Inheritance allows us to implement the idea of hierarchical classification
    as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: Inheritance diagram'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_05_07.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.7: Inheritance diagram'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: As the preceding diagram shows, the `Car` and `Motorcycle` classes can be derived
    from the base `Vehicle` class to reuse the attributes, constructors, and methods.
    Hence, the derived classes inherit the members from the base class and are allowed
    to add their own members for example, `Car` adds four doors — or modify inherited
    members — motorcycle modifies the number of wheels to two, and so on.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: With the derived classes, you can keep and reuse the members of the parent class.
    Also, you can override the parent's properties and methods to tailor your demands
    in the derived classes. Modifying inherited members in derived classes is called
    overriding, which is another OOP paradigm. We will look at a detailed example
    of method overriding in later sections.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: In short, inheritance allows us to share common characteristics and behaviors
    through generations of classes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP uses the `extends` keyword to inherit from a parent class. The syntax of
    PHP class inheritance is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: PHP supports single inheritance, meaning a class can inherit from a single class;
    not like Java, where you can inherit from multiple classes at a time.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to access a parent class'' member attributes and methods, write the
    following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So, the properties from the parent class can be reused in the derived object.
    Normally, in order to share common properties and behaviors, we establish a base
    class so that the subclasses don't need to add the same properties and behaviors
    repetitively. Thus, the data and the code operating on that data can be reused
    and the size of the code base remains minimal.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, while deriving, you can add your additional members and use the parent
    members as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, `MyNewClass` adds its own `$addedProperty` attribute and the `addedMethodName()`
    method.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: You can access and work with the parent's members using the `parent` keyword
    followed by the scope operator, `::`; for example, `parent::`. In the preceding
    example, the `MyNewClass` child class adds its own `addedMethodName()` member
    method, which accesses the parent's `methodName()` method in it by using `parent::methodName()`
    and prints the '`I am an added method`' string. Hence, `$object->addedMethodName()`
    prints '`I am a base method. I am an added method.`'.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: A child class can't access or inherit the private properties or members of a
    parent class since something that's private is meant to remain private.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.3: Implementing Inheritance'
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now is the time to classify different vehicle types and leverage the `Vehicle`
    class to derive new types of vehicles, such as car, bus, truck, motorcycle, and
    so on. In order to produce new types of vehicle objects, we will extend the `Vehicle`
    class to derive newer classes such as `Car` and `Motorcycle`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you will learn how to derive classes from the `Vehicle` class.
    We will create `Car` and `Motorcycle` subclasses and add new attributes in them,
    and print the `Car` and `Motorcycle` attributes by instantiating corresponding
    objects:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `Car` class file, `Car.php`, in the same directory and add the
    following lines to include the `Vehicle` class:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `Car` class extends the `Vehicle` class. Add the following content after
    the `require` command:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `Car` class inherits all the attributes and methods from the parent class.
    Now it's time to add new attributes or properties into the `Car` class so that
    a car object can be distinguished among other types of vehicles.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A car should have doors, passenger capacity, a steering wheel, transmission,
    and so on and inherit the default four wheels along with other properties. Add
    the following attributes into the `Car` class:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Hence, the `Car` class itself is a vehicle so it possesses all the given characteristics
    of a vehicle and adds its own set of characteristics.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, it''s time to leverage the beauty of inheritance. We will be using the
    inherited constructor from the `Vehicle` class. We can set the car''s attributes
    by passing them as constructor parameters. We can instantiate the `Car` class
    and access the `Vehicle` class'' members using the object of the `Car` class,
    as follows:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, alongside additional car properties, we can access the inherited features
    of the base class. The `get_class()` returns the class name that we have used
    to obtain the `Vehicle` type as a class name. Note that we are accessing the inherited
    methods using the child object's handler.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run `Car.php` from the terminal with the `php Car.php` command. The preceding
    code outputs the following:![Figure 5.8: Printing the details of the car'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_05_08.jpg)'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.8: Printing the details of the car'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, let''s create another type of vehicle type here. Create a `Motorcycle`
    class by extending the `Vehicle` class. Create a `Motorcycle.php` file in the
    same directory with the following content:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Again, this specific type of vehicle adds its new attributes. This is how inheritance
    enables your object to move forward with the newer characteristics while reusing
    the existing features. Note that `$noOfWheels` and `$stroke` can also be set in
    the constructor, but we also override these values here, in case the `Motorcycle`
    class is instantiated with the default empty constructor.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s instantiate the derived `Motorcycle` class, and access the inherited
    and added properties as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So, a two-wheeler type of vehicle should have the `$noOfWheels` attribute as
    a value of `2`. Note that `$noOfWheels` has been overridden here with `2` and
    an additional `$stroke` attribute, which is the stroke type of `Motorcyle`. The
    default is `4`.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the `Motorcycle.php` file from the terminal with the `php Motorcycle.php`
    command. The preceding code outputs the following:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/C14196_05_09.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: Inherited and added attributes of the motorcycle object'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have derived `Car` and `Motorcycle` by extending the `Vehicle` class,
    added new properties into derived classes, and accessed parent attributes and
    methods in a straightforward manner since all of them are publicly accessible.
    Inheritance lets you implement your objects in a hierarchical way. You might be
    adding new features or reusing existing ones throughout the system to keep your
    code modular. In the exercise, we noticed that accessing parent members is easy
    and there are no restrictions to prevent you from accessing their data.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: In order to enforce a specific data access policy on the class attributes, we
    will need the Access Modifiers before the class attributes and method declaration.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Access Modifiers
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two core concepts sitting at the heart of OOP are modularity (which allows for
    reusability) and encapsulation (which bundles data and methods, in order to hide
    information). It is important to establish access guidelines for data and interfacing
    among objects so that who can access what and to what extent is defined. Access
    modifiers provide access protection for object constants, attributes, and methods.
    The concept is to secure the object's members so that we can declare public, protected,
    and private member constants, attributes, and methods for the object. The `public`,
    `protected`, and `private` keywords are also known as visibility keywords in PHP.
    The `public` keyword can be used before a member to access the member from outside
    via the object. The `protected` keyword can be used to access a member from the
    derived class but not from outside. The `private` keyword can be used to restrict
    the access of a member to its own class only and for it to not be accessible via
    derivation or from outside.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of the `public`, `protected`, and `private` keywords
    applied to class members:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To elaborate on the class members with the new access modifiers prefixed, check
    out the following table for the `public`, `protected`, and `private` access modifiers:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: Scope of the access modifiers'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_05_10.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.10: Scope of the access modifiers'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: All public members can be accessed from outside of their own object or derived
    object using an object handler such as `$object->publicAttribute` or `$object->publicMethod()`,
    and to access them from inside their own object or derived object we need to use
    the special `$this` variable.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: All protected members can be accessed only from inside their own object or derived
    object using `$this-> protectedAttribute` or `$this->protectedMethod()`. Accessing
    them using the `$object->protectedAttribute` object handler will produce a `FATAL`
    error. Hence, an access modifier can be used when we allow data and behaviors
    to be reused via derivation only.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Private members are exclusively private to their own objects and are non-accessible
    via inheritance. The whole idea with this access modifier is that class-specific
    data and behaviors cannot be reused:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: Access modifiers diagra'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_05_11.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.11: Access modifiers diagram'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The diagram shows who can access what data and which methods. Outsiders can
    access an object's public data and methods only via the object's handler. An outsider's
    access is restricted to protected and private areas. Access is allowed to protected
    areas only by means of derivation and private areas are meant to be private for
    the class. Therefore, the restricted areas of a class can be accessed by its own
    methods and the world is set to access those restricted areas indirectly if and
    only if the class declares those methods that access their own restricted areas
    as public.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: If no access modifiers are mentioned before a method, then it will be considered
    public by default.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to apply access modifiers to the `Vehicle` class. Let's walk through
    an exercise. In the `Vehicle` class, the number of wheels should be available
    for the different types of vehicles to be implemented, the engine number should
    be confidential, and the other information should not be confidential.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.4: Applying Access Modifiers'
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we need to apply access modifiers before the `Vehicle` class
    attributes so that we can ensure the hiding of the data for the engine number
    variable, `$engineNumber`. The engine number can be obtained only via the getter
    `getEngineNumber()` member method. Also, the number of wheels should not be available
    outside the class; rather, it should be available to derived classes to implement
    their own number of wheels and the rest of the attributes can be accessed outside
    the class:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Vehicle.php` file and update the access modifiers of the `$noOfWheels`
    attribute as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we have protected the `$noOfWheels` data as this needs to be available
    to the child classes to implement their own number of wheels and should not be
    available outside of the class. We have modified the `$noOfWheels` attribute from
    `public` to `protected`.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Also, the engine number should be private to different vehicle types. Update
    the `$engineNumber` visibility from `public` to `private` as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, due to a visibility change for the `$engineNumber` attribute, the attribute
    should remain private to its own class and should not be available to the derived
    classes or outside of the class. One way to access such private attributes is
    to write a public getter method for outsiders or a protected getter method for
    derived classes only.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Some vehicle types might need to modify the number of wheels and we won''t
    be allowing outsiders to make that modification; hence, we declare the `$noOfWheels`
    attribute as `protected`. What if the number of wheels is set as `public`? It
    might get modified directly (read: bizarrely): a car might have two wheels, or
    a motorcycle might be modified to have 100 wheels. That''s why we wanted the attribute
    to be modified only in subclasses and not by outsiders.'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, the first three attributes are publicly visible, meaning these are the
    common attributes of any vehicle types and such information can be accessed directly
    via the object if anyone wants to do that.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, we are able to deliver restrictions on class attributes using the `visibility`
    keyword. Let's try accessing the attributes with updated visibility by instantiating
    the class.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new `vehicle-visibility.php` file and instantiate the `Vehicle` class
    as follows:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Try to access the member attributes outside of the class using the object handler,
    just the same as earlier:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that we are trying to access `$noOfWheels` and `$engineNumber` outside
    the class using the `$vehicle` object handler with an object operator. Both should
    produce a `FATAL` error.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'From the terminal or console, run `vehicle-visibility.php` using the `php -d
    display_errors=on vehicle-visibility.php` command. Using the `–d` flag with `display_errors=on`
    should override the default `display_erros=off` from `php-cli`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The preceding command outputs the following:'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.12: Accessing a protected property of the vehicle object'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_05_12.jpg)'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.12: Accessing a protected property of the vehicle object'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s take out the line with `$vehicle->noOfWheels` and try to rerun the previous
    command:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We need to alter our approach for accessing such restricted attributes. We
    need to use the `getNoOfWheels()` and `getEngineNumber()` object interface, as
    follows:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'So, if we rerun the script, we should see that all the expected values have
    been printed as follows:![Figure 5.13: Accessing private and protected properties
    via methods of the vehicle object'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_05_13.jpg)'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.13: Accessing private and protected properties via methods of the
    vehicle object'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we should try accessing the modified visibility attributes from the child
    class to see the differences.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's try accessing the modified visibility attributes from the child class.
    Open `Car.php` and locate the line with `$car->getNoOfWheels()`. The protected
    `$noOfWheels` attribute is inherited by the `$car` object and is available only
    via the `getNoOfWheels()` standard interface.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try to run `Car.php` using the `php -d display_errors=on Car.php` command.
    The command prints the following:'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.14: Accessing the parent''s attributes via inheritance'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_05_14.jpg)'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.14: Accessing the parent''s attributes via inheritance'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is how access modifiers ensure data protection throughout child classes.
    If we try accessing the protected attribute using `$car->noOfWheels`, it will
    produce a fatal error.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s try to access the private property of the parent class of `Car.php`
    and add the following line:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Remember, although a car is a vehicle and is inherited from the `Vehicle` class,
    the attribute should remain private to the `Vehicle` class and is unknown to the
    `Car` object.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Try to rerun the previous command and it will raise a `Notice` message (a PHP
    interpreter''s message) as the property is unknown to the `$car` object:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: PHP will raise a `Notice` message only because the property is completely unknown
    to the object. So, this is how visibility keywords can be applied before class
    members in order to ensure the hiding of data and protection through inheritance.
    Note that a `Notice` message is information about wrongdoing by the interpreter
    and would not halt the program execution, while an error should halt the program
    execution and must be resolved in order to execute the program.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In summary, access modifiers allow us to establish control over our data and
    behaviors and provide guidelines for how data should be communicated via standard
    methods. Hence, we have learned how to protect, privatize, and publicize data
    when we need to establish secure data communication between objects.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Static Fields and Methods
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When class instances or objects want to have the same data among them, the class
    needs to have such data declared as static. Each instance might have its own copy
    of data, but we use static members to have a certain portion of data and behavior
    that should be the same instance-wide.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Static fields or attributes and methods are just attributes and methods declared
    with the `static` keyword after the access modifiers and serve the special purpose
    that you can access static attributes, constants, and methods without instantiating
    the class. So far, we have accessed members that are declared inside a class from
    the object context. In the case of accessing class members without an object,
    we declare them as static members and access them with the `::` scope operator
    (double colon).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax looks like the following:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To access static properties or methods from their own class, check out the
    following example:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: So, static members can be accessed outside of the class using the class name
    and the `::` scope operator. Also, to access the static members inside the class,
    we can use the `self` keyword followed by the `::` scope operator.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'To access static properties or methods from subclasses, we use the `parent`
    keyword followed by the `::` scope operator. Check out the following example:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Also, static methods are available in the object context:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Static attributes and members are global variables and functions, except they
    live inside a class that is accessible from anywhere via the class name. Static
    members should be public; otherwise, accessing them from outside using the class
    name would produce a fatal error.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'parent:: and self::'
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`self::` refers to the current class and can be used to access static attributes,
    constants, and methods.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, `parent::` refers to the parent class and can be used inside subclasses
    in order to access parent's member attributes, constants, and methods.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.5: Applying a Static Member'
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will walk through an interesting use case for static members.
    We will be adding a static attribute to the `Vehicle` class and will increment
    the attribute inside the constructor so that the static member gets increased
    with each object creation:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Vehicle.php` and add a static property in the class, as follows:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, we have added a `$counter` static property and initiated the counter with
    `0`.
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, just add a line in the constructor to increment `$counter` by using `self::$counter++`
    as follows:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, the counter gets incremented with each object creation as we know the
    constructor method gets called while instantiating the class. In our case, the
    `Car` and `Motorcycle` subclasses don't have a `__construct()` method declared
    in them so they should be using the parent class' constructor via inheritance.
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, open `Car.php` and create `Car` objects multiple times, as follows. Print
    the `$counter` static variable using `Car::$counter`:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, the static attribute inherited by the derived `Car` class contains the
    number of the objects created at any particular point in time. So, we get to know
    the number of cars available in the application. The preceding should print `Available
    cars are 4`. Note that we are reusing the static counter in the constructor of
    the parent `Vehicle` class, meaning the derived `Car` objects share the same counter.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, to count `Motorcycle` objects, just create some objects and print the
    `$counter` static variable using `Motorcycle::$counter`:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The preceding should print `Available motorcycles are 3`. So, we have declared
    a static counter in the parent class and created objects and accessed the `static`
    attribute using child class names to get the number of objects created. This is
    how we can implement so many interesting features with the `static` property and
    methods.
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Class Abstraction
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In OOP, class abstraction is the way to define the common behaviors of objects
    so that derived classes can implement those behaviors in their own way to achieve
    different purposes. Just take the vehicle analogy: both cars and motorcycles have
    engines in common, but you know the engines are completely different for each
    type of vehicle. So, the class abstraction should provide an abstract engine for
    both types of vehicles. To match an exact common definition of an engine, the
    engine should start, the engine should stop, and we might want to know the status
    of the engine — whether it is running or not.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'Each type of vehicle should implement its way to start the engine. For example,
    we could start a car engine by using a key in the ignition, whereas a motorcycle
    might need us to kick-start the engine:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15: A simple abstract engine diagram'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_05_15.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.15: A simple abstract engine diagram'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: PHP supports abstract classes and methods and they can be written with the `abstract`
    keyword at the start. An abstract class cannot be instantiated; rather, it can
    be inherited to achieve common behaviors among objects. A class must contain at
    least an abstract method to be an abstract class. Using such a class, we deliver
    common methods to subclasses. In an abstract class, the common methods could be
    abstract because they only have the signatures and the subclasses implement those
    methods in their own way. A method declared as an abstract method must not have
    the implementation written in it.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following syntax:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: An abstract class can have some implemented methods in it, along with abstract
    methods. Generally, we leave those methods as abstract, which should have a different
    implementation in different child classes.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: As well as the abstract method implementation, the child class must add all
    the arguments given in the abstract method and optionally can add extra arguments.
    Say the abstract method comes with two parameters, then the child class must add
    both of the given parameters and can optionally add its own parameters.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, we will be adding basic engine functionality to cars
    and motorcycles so that the engine can be turned on and off.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.6: Implementing an Abstract Class'
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be converting the `Vehicle` class into an abstract
    class so that we can deliver the engine-start action in an abstract manner and
    each subclass can implement its own way of starting the engine. We can add an
    abstract engine start method so that `Car` and `Motorcycle` can inherit the engine
    action to implement it and start the vehicle in their own way. The whole idea
    of this exercise is to practice and understand how abstraction helps us to achieve
    certain scenarios. In order to provide an abstract engine start to each vehicle
    type, we will declare the `Vehicle` class as abstract by simply adding the `abstract`
    keyword in front of it and adding an abstract engine-start method. Since `Car`
    and `Motorcycle` extended the `Vehicle` class, they will be forced to implement
    the `abstract` method.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: PSR Naming Conventions
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class name must be prefixed by `abstract`; for example, `AbstractTest`.
    You can take a look at [https://packt.live/2IEkR9k](https://packt.live/2IEkR9k).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at the steps:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Vehicle.php` class and add the `abstract` keyword before the `class`
    keyword, as follows:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: So, the `Vehicle` class became an abstract class, as discussed.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Also, prefix the class name with `Abstract`:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Rename the `Vehicle.php` file to `AbstractVehicle.php`.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `Car.php` file with the abstract `AbstractVehicle` class name and
    the `AbstractVehicle.php` filename, as follows:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'And for `Motorcycle.php`, add the following:'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We need to add an attribute to the `AbstractVehicle` class to store the engine
    status – whether it is started or stopped, so let''s add a protected `$engineStatus`
    attribute as a Boolean type so that it holds the status of the running engine
    as `true` or `false`:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, we have added an `$engineStatus` attribute that is false by default, so
    we can confirm that the engine is not running.
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: According to our abstract class concept, we will add some implemented methods
    that will be the same in each vehicle type and some non-implemented abstract methods
    that will be implemented differently in each vehicle type. The engine starting
    is different in a car and a motorcycle so this method should be abstract, but
    stopping the engine or getting the engine's status should be the same for both.
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following abstract method signature in the abstract `Vehicle` class,
    which should be implemented differently (read: behave differently) in `Car` and
    `Motorcycle`:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, both vehicle subclasses will be enforced to add an implementation of this
    method in their own classes.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Also, we will be delivering common functionalities in terms of the implemented
    method so that the subclasses can avail them. Add the following two methods in
    the `AbstractVehicle` class:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, in order to stop the engine and get the engine's status, we have added
    the `stop()` and `getEngineStatus()` methods. So, these two should be the same
    in `Car` and `Motorcycle`.
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, the abstract `AbstractVehicle` class with a single abstract method
    looks like the following:'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, it''s time to implement the abstract `start()` method in the subclasses.
    A car has its own way of starting its engine — you need to place the key in the
    ignition. In `Car.php`, add a private property, `$hasKeyinIgnition`, along with
    the `start()` implementation, as follows:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: So, a car implements the engine start with the key in the ignition. `$this->hasKeyinIgnition`
    should be `true` to set the `$engineStatus` variable to `start` or `true`.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can create a `Car` object and start/stop the engine as follows:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Run `Car.php` with the `php Car.php` command. The preceding code should output
    the following:![Figure 5.16: Abstract method implementation on the car objec'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_05_16.jpg)'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.16: Abstract method implementation on the car objec'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A motorcycle needs a key to unlock the vehicle and a kick on the corresponding
    lever to start the engine. The term "kickstart" was coined from this particular
    type of vehicle. Open `Motorcycle.php` to simulate the key being in place and
    a kickstart taking place. Let''s add two private attributes, `$hasKey` and `$hasKicked`,
    and implement the `start()` method as follows:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Here, in the `start()` method, we have checked that both elements for starting
    a motorcycle engine are present and started the engine by setting `$engineStatus`
    to `true`.
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, we can create a `Motorcycle` object and start/stop the engine as
    follows:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Run `Motorcycle.php` with the `php Motorcycle.php` command. The preceding code
    should output the following:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.17: Abstract method implementation on the motorcycle object'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_05_17.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.17: Abstract method implementation on the motorcycle object'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: So, different behaviors of the same action among the children should come from
    the parent in an abstract way.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed how an abstract class can come up with common and abstract
    methods. In an abstract class, we keep the methods abstract that should be different
    in derived classes. What if we want a full set of abstract functionalities? Or,
    what if we want to settle a standard of functionality? Maybe we want to establish
    a standard set of methods to communicate with the object? This is why we need
    an interface. An interface groups similar abstract methods so that it can express
    an abstract feature and different classes that need that feature can implement
    the interface. For example, the `Flight` feature is implemented by `Birds` and
    `Aeroplanes`. Hence, the `Flight` interface has to be fully abstract so that `Birds`
    and `Aeroplanes` can implement completely different flight techniques.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'An interface can be similar to a class without the `class` keyword and without
    all the method''s body. Therefore, an interface is a collection of method signatures
    to be implemented like the following syntax:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: An interface cannot be extended but rather implemented; classes use the `implements`
    keyword to inherit the given interfaces so that they can implement them. PHP supports
    constants in interfaces so that implementing classes have those constants automatically
    defined. A class that implements an interface should implement every method and
    if any method remains unimplemented, then it will produce a fatal error.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'A class can implement multiple interfaces:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'And an interface can extend multiple interfaces:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: So, a class can extend a single class and can implement multiple interfaces,
    and an interface can extend multiple interfaces. But implementing/extending interfaces
    should not have methods with the same name, which creates interface clashing.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing methods are always public and you can't declare access modifiers
    for method prototypes in their declaration.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Interface constants can be accessed similarly to class constants but they cannot
    be overridden through inheritance by classes or interfaces.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a representation of the `Drive` interface:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18: Drive interface diagram'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_05_18.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.18: Drive interface diagram'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Referring to the preceding diagram, consider the vehicle analogy again. Cars
    and Motorcycles both can be driven so they need their own drive interfaces. While
    driving, they should change their speed, change gear, apply breaks, and so on.
    We can see that driving behavior is common and the necessary actions are the same
    in both types of vehicles. The thing is, despite the same actions, their way of
    dealing with those actions is different. This is where we need an interface. We
    might want to declare a `Drive` interface with the `changeGear()`, `changeSpeed()`,
    and `applyBreak()` abstract methods.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, an interface focuses on functionality, rather than being a template
    (of an abstract class) for an object. And this is the main difference between
    the interface and class abstraction.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: We can add a simple drive interface for `Car` and `Motorcycle` so that the vehicle
    can change speed, change gear, and apply the brake. If the vehicle hasn't implemented
    the brake, then a fatal error will be displayed.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Let's add the driving feature as an interface in the following exercise.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.7: Implementing an Interface'
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will practice working with the object interfaces and learn
    how an interface can settle a standard way of implementing behaviors for objects.
    We will create an interface with the necessary driving guidelines, such as the
    ability to change speed and gear, or the ability to apply the brakes when needed:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: As per PSR naming conventions, an interface name must be suffixed by `interface`;
    for example, `TestInterface` ([https://packt.live/2IEkR9k](https://packt.live/2IEkR9k)).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following Drive interface and save the file as `DriveInterface.php`:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here, we have declared the `Drive` interface with a minimal set of method signatures.
    Remember, no implementation should be available here; rather, the implementation
    should be shifted to objects that implement such an interface.
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To change the speed, we have added the `changeSpeed($speed)` method signature,
    which accepts an argument for the speed to achieve. To change the gear, we have
    added the `changeGear($gear)` method signature, which accepts an argument for
    the gear number to be shifted to. To apply the brakes, we have added the `applyBreak()`
    method so that we can just simulate the "break" behavior whenever required.
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the interface to both the `Car` and `Motorcycle` classes as follows:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, the `Car` and `Motorcycle` class should implement the interface as follows
    and add their own implementations for `changeSpeed()`, `changeGear()`, and `applyBreak()`:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If we try to run `Car.php` or `Motorcycle.php`, it will produce a fatal error
    that the classes must contain three abstract methods and, therefore, be declared
    abstract or implement the remaining methods. Therefore, we need to add the implementation
    of those three interfaces or methods.
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the implementation of those three methods in the `Car` class as follows:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, `Car` has implemented the three methods from the `DriveInterface` interface.
    We can put the relevant implementation in them but, for the sake of learning,
    we have just printed a simple line in them.
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, instantiate the `Car` class as follows and start driving:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Here, we have accessed the driving methods to execute the operations implemented
    by `Car`.
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we try to run the `Car` script, with `php Car.php`, the preceding code should
    print the following:![Figure 5.19: The DriveInterface interface implemented by
    car'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_05_19.jpg)'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.19: The DriveInterface interface implemented by car'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Also, add the implementation of those three methods in the `Motorcycle` class,
    as follows:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Here, we have implemented the `DriveInterface` interface in the `Motorcycle`
    class. Just like that, you can come up with your own implementation and, here,
    for the sake of learning, we have printed different information in this `DriveInterface`
    implementation.
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, instantiate the `Motorcycle` class as follows and start driving:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here, we have accessed the driving methods to execute the operations implemented
    by `Motorcycle`.
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we try to run the `Motorcycle` script with `php Motorcycle.php`, the preceding
    code should print the following:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/C14196_05_20.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.20: The DriveInterface interface implemented by Motorcycle'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Hence, the vehicles can shift gears, change speed, and brake while driving.
    The `DriveInterface` interface described what should be the standard behaviors
    for vehicles for driving and their derived objects obeyed the formula of the standard
    feature. Moreover, the interface can add more functionalities so that the derived
    objects are forced to implement them.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: The declaration of implemented methods and interface methods must be compatible
    with each other; for example, the number of arguments or the signature should
    be exactly the same.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Classes versus Interfaces
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have learned how the concepts of class abstraction and object interfaces
    work nicely as added dimensions of inheritance to deliver common behaviors and
    standards for derived objects. There are frequent debates about when to use abstract
    classes and when to use interfaces. Although we have gone through the practical
    use cases of both via our exercises, the topic still needs discussion.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstract classes are meant to deliver common behaviors or actions via methods
    to extended objects while keeping vital room for common methods to be implemented
    differently by derived objects. In contrast, interfaces are for setting standard
    ways of interacting with objects. An abstract class must have at least one abstract
    method, whereas all the methods in an interface are abstract. Remember, this is
    not a concept of having one or more abstract methods versus all abstract methods.
    Both have their own use cases when it comes to inheritance: the abstract class
    delivers the common functionalities and allows us to implement our own functionalities,
    whereas the interface is not about sharing functionalities at all; rather, the
    interface is all about setting standards for certain actions.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Simple abstract classes can have implemented methods and attributes, whereas
    interfaces cannot as they contain constants and method signatures without bodies.
    Therefore, it is not possible to share code via interfaces.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: In previous exercises, the abstract class provided us with common engine functionalities
    and allowed us to deal with specific features of the engine in our own way. The
    interface showed us the standards to drive the car and we followed the guidelines
    accordingly to achieve our own goal of driving actions.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Class Type Hinting Plays a Role in Dependency Injection
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type hinting allows us to define the type of data to be passed as arguments
    into a function. PHP supports class type hints, which means that, in function
    arguments, you can mention which class type the passed argument object belongs
    to. For example, a `User` class might want to use a `Mailer` service to deliver
    email. The `Mailer` object can be passed to the `User` class and the `User` needs
    to make sure that nothing except a `Mailer` object is passed to it.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following example where the function argument was expected to
    be an instance of a specific class:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: If the object is not an instance of the expected class, then an exception is
    thrown with the message '`Only Objects of ClassName can be sent to this function.`'.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: An exception is a class that is throwable and catchable with an error message
    so that the catch block can catch the exception and work accordingly. *Chapter
    8, Error Handling,* discusses exceptions in detail.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding snippet is equivalent to the following class type hinting syntax:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: So, with class type hinting, we can enforce the function or method caller to
    pass the appropriate type of object. When class type hinting is applied, PHP automatically
    performs `instanceof` checking and produces an error if the object doesn't satisfy
    the class relationship.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '`user` object might need to send out emails and perform certain database operations;
    therefore, the user is dependent on the `mailer` object and the `database` object.
    We could supply such `mailer` and `database` objects to the `user` object as follows:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Here, while instantiating the `User` class, we have passed the name of the user,
    a `mailer` object, and a `database` object as arguments. The `Mailer` `$mailer`
    class type hint ensures that the only instance of the `Mailer` class can be supplied
    and the other class type hint at `Database $database` ensures that the only instance
    of the `Database` class can be supplied. We have added these two object dependencies
    in the user's constructor so that the object gets loaded with certain dependencies
    and any failure upon injecting dependencies will prevent object creation.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: The preceding technique is called **constructor injection**. You can inject
    dependencies using a setter method or you can use a dependency injection container.
    You could search for books or online resources to extend your learning about dependency
    injection even further.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to discuss two important aspects of polymorphism
    that serve the same purpose for different conditions.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Overriding
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overriding is the process of updating an existing implementation (an inherited
    implementation) with a new one; it can be redeclaring a class attribute in derived
    objects or it can be taking an inherited member method to update with a whole
    new function body. Overriding keeps the external interface the same while the
    internal
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: functionalities might be fully changed to suit your own objectives. In PHP,
    you can do both attribute and method overriding. Note that this overriding happens
    in new classes derived by inheritance.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: For example, an animal class might provide a common behavior; for example, eat.
    Such behavior is shared among the animal subclasses via inheritance. But the fact
    is, each animal subclass has its own way of eating. Like dogs and birds, they
    have redefined the behavior of eating in their own class. The idea of adding your
    own way of doing something is conceptualized as overriding.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: Attribute Overriding
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Attribute overriding is the process of replacing the parent''s class'' data
    in the subclass. We have already seen that the `Motorcycle` class overrides the
    inherited number of wheels from the parent `Vehicle` class to two as motorcycles
    are two-wheelers. So, in order to suit the derived class'' requirement, we have
    overridden the attribute:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Method Overriding
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Method overriding is necessary when we need to rewrite an inherited method.
    For example, to get the price of a vehicle, the class provides a getter method
    and the vehicle subclasses can avail the getter via inheritance. What if we want
    to tweak the returned price for a particular type of vehicle; for example, a discounted
    motorcycle price, and keep the getter intact for `Car`? We need to tweak the desired
    subclass price getter by overriding it.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following example of method overriding:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: So, we can override the inherited method and update the method with the new
    implementation.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Let's have some fun and sell our vehicles. So far, we have been adding technical
    features to our vehicles with the help of OOP. Now, let's add some commerce-related
    features to our vehicle types. In the following exercise, the price for the car
    and motorcycle should be returned using a common method. The price of a motorcycle
    should be returned after applying a 5% discount, and no discount is applicable
    to the car price.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.8: Overriding an Inherited Method'
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will practice method overriding by adding a simple `getPrice()`
    getter method to the parent `Vehicle` class and override the method from our child
    classes. If we add a getter method with the implementation of the method into
    the parent `Vehicle` class, then it should be available for all the subclasses
    to use. We are going to override the `getPrice()` method in the `Motorcycle` class
    since we need to handle the pricing in a different way in that subclass:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `AbstractVehicle.php` and add the following protected attribute in the
    attributes section:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Also, add the `getPrice()` and `setPrice()` price getter and setter methods
    in the methods section as follows:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Here, the `getPrice()` simply returns the price and `setPrice()` takes `$price`
    as an argument, assigns it to the `price` attribute of the vehicle, and both these
    methods should be available to the `Car` and `Motorcycle` objects so that we can
    set and get the prices of a car and a motorcycle, respectively.
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Imagine there is a discount of 5% on all kinds of motorcycles for a special
    occasion. Now, we need to apply the discount to the price of this particular vehicle
    type.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to handle prices differently, we need to override the `getPrice()`
    method in the `Motorcycle.php` class and add the `getPrice()` method into the
    class, as follows, and modify the price calculation:'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Here, we have deducted the discounted value from the original price. So, the
    motorcycle objects will return the discounted price and the car objects will return
    the original price.
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to test the discounted price, we should instantiate the `Motorcycle`
    class, set the price, and get the price to see whether a discount has been applied
    or not. Let''s do the following in `Motorcycle.php`:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Here, we have settled the original price as `5000` and tried to get the price
    using the `getPrice()` method.
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, if we run `Motorcycle.php` with the `php Motorcycle.php` command, the
    preceding code outputs the following:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: So, the discount mentioned has been applied to the motorcycle price and if we
    apply the getter and setter methods for the cars, we should get the car price
    equal to the original price that we set. This is why, when we need something to
    be delivered in a different manner by the child classes, we need an override.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Overloading
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important aspect of using the polymorphism concept of overloading relates
    to the use of the same thing defined differently or the same thing behaving differently
    on different occasions.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: Generally, among programming languages such as C++ and Java, method overloading
    or function polymorphism is just declaring the same function with different parameters;
    for example, `int add(int a, int b)`, `int add(int a, int b, int c)`, `double
    add( double a, double b, double c)`, and so on. These might have different implementations
    inside. In such a traditional way, the function name remains the same while the
    return type and the number of arguments and their types might be different. This
    also happens in statically typed programming languages (C++/Java) where type checking
    happens at compile time and function binding depends on the type of each parameter.
    Hence, for statically typed languages, each such function is different.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP, you could try to declare a function or method with the same name as
    the following:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This would produce a fatal error that you cannot redeclare a function or method
    with the same name.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP doesn''t support declaring same function multiple times. Still, you can
    achieve classical function overloading using the built-in `func_get_args()` function
    in order to enable the same function, taking a multiple number of arguments since
    PHP isn''t bothered about parameter types. Here''s an example for the sake of
    discussion here. Let''s use the following approach:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '`func_get_args()` can really turn your functions on to support multiple arguments.
    Also, if you are worried about parameter types, you can deal with type checking
    inside the function.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: So the preceding approach is not the approach we are going to talk about in
    this section on method overloading in OOP. PHP has a lot to offer flexibility-wise
    when it comes to overloading in OOP. Still, the approach is different from other
    languages and that might be why there is some controversy about the way it serves
    overloading compared to traditional overloading.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: The interpretation of overloading in PHP is different than most of the other
    object-oriented languages. Overloading allows you to have multiple methods with
    the same name but different signatures.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: PHP allows the overloading of attribute and method calls by implementing certain
    magic methods. These magic methods are invoked when trying to access the attributes
    and methods that are not declared or are not accessible in the current scope.
    Such special proxy methods are to create attributes and methods during runtime
    (dynamic attributes and methods), and we can implement magic methods easily in
    our class for numerous functionalities.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Attribute Overloading
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We might need to add data to our objects at runtime; for example, in our `Car`
    subclass, we haven't declared attributes such as model, year, owner name, and
    so on. But while running the program, we might want to welcome such attributes
    to be stored in our objects. PHP allows you to achieve such dynamic attribute
    addition at runtime in terms of attribute overloading. Hence, with such dynamic
    declaration, attributes become polymorphic enough in use and can be overloaded
    easily.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: 'For attribute or property overloading, PHP supports the following two magic
    methods:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '`public __get(string $attribute) : mixed`'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public __set(string $attribute, mixed $value)`'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__get()` is invoked when accessing or reading data from not declared or not
    accessible (protected or private) attributes and `__set()` is invoked when trying
    to write data to not declared or not accessible (protected or private) attributes.
    All we need to do is implement these two special methods in our class to avail
    the dynamic (created at runtime) attributes. `__set()` accepts any types (mixed)
    of data in the second parameter; `__get()` returns that type of data. Here, the
    `mixed` keyword has been used to explain that the method returns or accepts a
    type of data, such as integer, string, array, object, and so on.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the class here, which has these two method implementations:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Here, the private declared property, `$arr` , holds the dynamic attributes coming
    from the `__set()` setter magic method. The attribute has been used as an array
    key to store the passed value with the `$this->arr[$attribute] = $value` line.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Also, to return the settled attribute via the implemented getter magic method,
    `__get()`, we have checked that the attribute exists in the array using the `array_key_exists()`
    function. If it exists, then return the attribute value by accessing `$arr` with
    the attribute name as a key. Otherwise, print an error message.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: At the `$object->dynamicAttribute = 'I am magic';` line, we have accessed an
    attribute that is not declared anywhere within the `MyMagicClass` class. So, behind
    the scene, the magic method invoked `__set('dynamicAttribute', 'I am magic')`
    to store the attribute. The `__get('dynamicAttribute')` is invoked with the line
    `echo $object->dynamicAttribute . PHP_EOL;`.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: Thus, implementing such magic methods gives you a lot of flexibility to define
    your own attributes. Remember that attribute overloading works in object context
    and not in a static context.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: Now, the questions are, are we going to allow many attribute creation on the
    fly or should we apply some restrictions? Or is there any predefined set of attributes
    that we accept as overloaded. The answer is yes, we should predefine the set of
    attributes that we are going to overload. In the previous example, we should add
    a predefined list of overloadable attributes into an array and in `__set()`, the
    given dynamic attribute should be cross-checked with our predefined array to check
    whether it is allowed or not.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the following example:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Here, we have added an associative array in the `$arr` private property and
    when the `__set()` method triggers, we cross-check that the attribute is allowed
    in `$arr` using the `array_key_exists()` function; otherwise, we print an error
    message.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: 'We are flexible enough to come up with innovative implementations and restrictions
    of such special proxy methods. After the magical setter and getter implementations,
    we can implement the following two magic methods:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '`public __isset(string $attribute) : bool`'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public __unset(string $attribute): void`'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__isset()` one should be implemented if we want to check the attribute
    with `isset($attribute)` or the `empty($attribute)` function. Similarly, we should
    implement `__unset()` if we want to implement and unset the attribute with the
    `unset($attribute)` function. Without `__isset()` and `__unset()`, we won't be
    able to use native `isset()` and `unset()`.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: PHP's magic methods should not be declared as static since they trigger only
    in object context. The implemented magic methods must be declared as public. Also,
    pass by reference cannot be used as parameters in magic methods. The `__` notation
    is reserved for magic methods.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: Method Overloading
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Method overloading is all about doing extra work with the same method. For example,
    in our `Car` subclass, we haven't declared the `honking` behavior. What if we
    can avail the `honk()` method dynamically (at runtime) and can overload the normal
    `honking` behavior with honking loud? PHP supports such dynamic method declaration
    and we are allowed to overload those methods.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: 'For method overloading, PHP supports the following two magic methods:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '`public __call(string $method, array $arguments): mixed`'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public static __callStatic(string $method, array $arguments): mixed`'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the `__call()` invoked when the inaccessible method has been called
    in the object context and the `__callStatic()` invoked when the inaccessible method
    has been called in the static context. The second argument of these methods is
    `$arguments`, which is a numerically indexed array. The index 0 contains the first
    argument and so on.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the following implementations of these magic methods:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Here, with the `$object->showMagic('object context', 'second argument');` line,
    `showMagic()` is declared nowhere or is a non-accessible method to the object
    handler, so behind the scenes the `__call()` is invoked like `__call('showMagic',
    array('object context', 'second argument'))`. Also, you can see that the `showMagic()`
    method can interact with a different number of arguments.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, `__callStatic('showMagic', array(static context'))` works in the
    static context when `MyMagicMethodClass::showMagic('static context')` gets called.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.9: Implementing Attribute and Method Overloading'
  id: totrans-543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, let''s implement the overloading magic methods in `AbstractVehicle`
    so that both vehicle types should have the facility to define their dynamic attributes
    and methods at runtime. All we need to do is, go through our previously discussed
    implementation of the `__set()`,`__get()`, and `__call()` magic methods into the
    `AbstractVehicle` class. This will help the `Car` and `Motorcycle` objects avail
    such runtime properties and method creation:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `AbstractVehicle.php` and add the following private attribute, which holds
    dynamic time attributes:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Here, `$runtimeAttributes` should act as an associative array to store the runtime
    key-value pairs of the dynamic attributes. The attribute or property name should
    be the key with the associated value.
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we should add the magic setter, `__set()`, in the `AbstractVehicle` class,
    as follows:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Here, the `$attribute` name and `$value` are passed to the magic method via
    the `$attribute` and `$value` arguments. The `$value` runtime attribute has been
    stored in the associative array using the `$attribute` attribute name argument
    as key, so that, later, we can access the runtime attribute with `$this->runtimeAttributes[$attribute]`.
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s add the magic getter, `__get()`, as well:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Here, the magic method asks to return the runtime attribute value by passing
    the attribute name as an argument. The method checks whether the attribute name
    is available as a key in `$this->runtimeAttributes` using PHP's `array_key_exists()`
    function. If the attribute was set previously, then it should return it, else
    it will print the preceding error message.
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, try such attribute creation at runtime in the `Car.php` class. For example,
    we can add car properties such as `ownerName`, `make`, `year`, and so on, as follows:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Here, we haven't declared `$ownerName` and `$year` in the `Car` class. When
    an attribute is accessed via a `Car` object handler that is not declared or not
    accessible to the object, then PHP invokes magic methods in order to deliver you
    that attribute. Note that without assigning a value to such a runtime attribute,
    it won't be available or registered.
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since the `Car` class inherited the implemented magic methods and we have settled
    values on both the attributes using `$car->ownerName` and `$car->year`, they have
    been added into the `$runtimeAttributes` array, which is private to the parent
    `Vehicle` class.
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we try to run `Car.php` with the `php Car.php` command, the preceding code
    should be printed as follows:![Figure 5.21: Attribute overloading and non-existing
    attribute access of the car object'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_05_21.jpg)'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Here, we have added the implementation of the magic method with two arguments.
    The first argument, `$method`, is for the method name, and the latter one, `$arguments`,
    is a numerically indexed array of arguments to be passed when we invoke the given
    method.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, we can add our own styles or patterns as implementation, but now, for the
    sake of simplicity, we have just printed the method name inside the function.
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following line at the bottom of `Car.php`:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Here, we have called the `honk()` method to dynamically add the honking behavior
    to our `Car` objects.
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we run `Car.php` using the `php Car.php` command, it will output the following:![Figure
    5.22: Method overloading of car'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_05_22.jpg)'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.22: Method overloading of car'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now overload the `honk()` method easily by updating the `__call()` method
    at `AbstractVehicle.php` with the following content:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Here, we have added a switch case to accommodate different dynamic methods.
    We have added a case for the `honk()` method so that we can respond to it and
    perform steps for the `honk()` method. In the `honk()` case, for demo purposes,
    we have checked for supplied arguments, we have printed a message based on the
    first argument, and printed another message based on the second argument and so
    on. We can also handle the arguments differently.
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the bottom of `Car.php`, after the previous `$car->honk()` line, add the
    following two lines:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Here, we have overloaded the `honk()` method and the method became polymorphic.
    We can honk (default), we can honk gently, we can honk louder, and we can enable
    the siren in the event of an emergency. The whole idea of the honk analogy is
    to summarize how we can overload methods in PHP.
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we run `Car.php` using the `php Car.php` command, it will output the following:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.23: The honk method overloaded'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_05_23.jpg)'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.23: The honk method overloaded'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: This is how we can add dynamic properties and behaviors to our objects, and,
    yes, of course we can add attribute/method restrictions and cross-check them with
    a prebuilt checklist, implement patterns, and so on in such magic methods.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: Final Classes and Methods
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we finalize our class declaration by providing a standard set of attributes
    and methods to describe an object and we neither want the class to be modified
    nor an extension of that class, we need to declare it with the `final` keyword.
    For example, in a simple login process, we match the given password with the stored
    password to grant access to the user. We don't want this password matchmaker method
    to be modified so we need to declare the method as final or our user authentication
    class might have a standard set of methods that we don't want to be modified or
    extended so we need to declare the class as final.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: Final classes are written to not be inherited and final methods cannot be overridden.
    PHP uses the `final` keyword before the final class and final methods.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following example of the final class:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Here, if we try to extend the final class, `MyClass`, it will produce a fatal
    error that the `MyChildClass` class may not inherit from the final `MyClass` class.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, let''s have an example for the final methods:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The preceding will produce a fatal error as you cannot override a final method.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.10: Implementing a Final Class and Methods'
  id: totrans-589
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to practice implementing a final class and methods
    to understand what the consequences of finalizing methods and classes are. We
    will be applying a member method as final in the `Car` subclass and then we will
    be applying the `Car` class as final so that we can block any derivation (inheritance)
    from the `Car` class:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Car.php` and locate the `start()` method as follows:'
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: As you can see, `Car` checks that the key is in the ignition to turn on the
    engine. We need to make sure that the engine start involves checking for the key.
    In other words, we won't allow the overriding of this engine start procedure.
    Hence, we need to lock any possible overriding via derivation by using the `final`
    keyword before the access modifier of the `start()` method.
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `final` keyword before the `start()` method as follows:'
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Here, the `start()` method has been finalized and no override should be allowed.
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new `Car` subclass, `Van`, in a PHP file, `Van.php`, with the following
    content:'
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Here, `Van` is an offspring of the `Car` class and is ready to override any
    methods acquired from the parent.
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s try overriding the final method, `start()`, declared by the `Car` class:'
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Here, the `Van` class overrides the `Car` class' engine `start()` method, which
    is not permissible from the `Car` class.
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we run `Van.php` using the `php –d display_errors=on Van.php` command, we
    should see the following fatal error:![Figure 5.24: The Van subclass attempts
    to override the Car engine start method'
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_05_24.jpg)'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 5.24: The Van subclass attempts to override the Car engine start method'
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The override failed at the `Van` subclass. When we need to secure our methods
    from communicating with an object, we need to finalize those methods.
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s say we don''t need further derivation of the `Car` class and we
    have finalized the `Car` class, as follows, by adding the `final` keyword before
    the `Car` class keyword:'
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Again, if we run `Van.php` using the `php –d display_errors=on Van.php` command,
    we should see the following fatal error:'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.25: The Van subclass attempts to extend the Car class'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_05_25.jpg)'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.25: The Van subclass attempts to extend the Car class'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: This is how the `final` keyword can be used to prevent method overriding and
    class extending. In practice, methods that should not be overridden anyhow should
    be finalized and classes that should not be extendable should be finalized.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: Traits
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a single inheritance language such as PHP, we often feel that we could have
    extended another class to inherit some functionalities. For example, in our `Car`
    class, we have inherited all the generic vehicle functionalities and now we might
    be in need of adding some e-commerce functionalities. Again, the `Motorcycle`
    class might want to have such e-commerce functionalities. As e-commerce related
    methods do not belong to the `Vehicle` class, we need to think of an alternative
    approach to reuse such e-commerce behavior. Hence, when we need to add a group
    of behaviors to our objects, we group the behaviors in terms of methods with a
    `trait` and use the `trait` inside our classes. A trait is similar to a class
    but you can't instantiate it; rather, you can use traits inside classes. A trait
    can be used in a class context with the `use` keyword; for example, `use TraitName`.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following `trait` syntax:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Here, the `MyTraitName` trait helps to group multiple methods, `one()` and `two()`,
    and to reuse these methods, we can use the trait using `MyTraitName;`. Hence,
    the trait methods become available to `MyClass{…}` and can be called using the
    `MyClass{…}` object handler, as in the preceding code.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use multiple traits as follows:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Again, the member inserted by a trait overrides an inherited member. Let''s
    check out the following example:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Here, `MyClass` extends class `A`, which has a method named `say()`, since `MyClass`
    avails the trait method `say()`. Then, we can consider the `MyClass` member `say()`
    as overriding the `say()` parent. In order to call the original parent method,
    `say()`, the trait supports `parent::` to access the parent's methods. Trait is
    all about delivering methods to your class that are assumed to be a useful part
    of your class.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: 'Current class members can override the members added by traits. Again, if we
    extend the preceding example, we can derive the following example:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Notice that the `say()` method gets overridden according to the sequence. Trait
    methods override inherited methods and class members override trait methods. Hence,
    `say()` from parent class `A` gets overridden by the `say()` method of trait `T`,
    and then, finally, `say()` in `MyClass` overrides the trait's `say()` method.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: A trait is a way of adding functionalities and additions to inheritance. A trait
    enables you to add more features horizontally without the need to inherit another
    class.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.11: Implementing Trait'
  id: totrans-628
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create a new trait named `PriceTrait` and shift the
    price setter and getter methods from the `AbstractVehicle` class to this trait.
    Since price-related methods should not belong to core vehicle features but to
    e-commerce features, we will add all sorts of price methods into the new price-related
    trait. The whole idea of shifting price-related methods into `PriceTrait` is to
    conceptualize how traits should come into the scenario and group logically related
    methods under a name.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: As per the PSR naming conventions, the Trait name must be suffixed by Trait;
    for example, `TestTrait` ([https://packt.live/2IEkR9k](https://packt.live/2IEkR9k)).
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: Open `AbstractVehicle.php` and locate the `getPrice()` and `setPrice()` methods.
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new PHP file called `PriceTrait.php` with the following trait:'
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Cut the `getPrice()` and `setPrice()` methods from the `Vehicle` class and
    paste them into the `PriceTrait` trait as follows:'
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Here, we have added the `PriceTrait` body with the `getPrice()` and `setPrice()`
    methods shifted from the `AbstractVehicle` class. Note that the methods still
    contain the original lines that use `$this` (the object instance variable), though,
    traits cannot be instantiated, meaning that these methods are intended to be accessed
    by the objects of classes that are going to use `PriceTrait`.
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we need to require the `PriceTrait.php` file in the `AbstractVehicle` class,
    as follows, so that the `AbstractVehicle` class can use the trait:'
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Use `PriceTrait` from the `Vehicle` class, as follows:'
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Here, in the line `use PriceTrait`, the `AbstractVehicle` class acquired the
    `PriceTrait` trait that comes with two methods for price set and get. Hence, the
    `Car` and `Motorcycle` classes inherited these two methods, which was our intention,
    to add features horizontally like this. Note that we have kept the `$price` attribute
    intact at the `AbstractVehicle` class to access it via the setter and getter of
    the derived vehicles.
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are no changes in the `Car` and `Motorcycle` subclasses as they should
    avail the trait methods automatically. As the parent `Vehicle` class uses `PriceTrait`,
    the trait methods become members of the `Vehicle` class and the subclasses can
    override such inherited methods. The `Car` class doesn''t override price methods
    but the `Motorcycle` class overrides the `getPrice()` method to apply a 5% discount
    to the given price. Locate the `getPrice()` method in the `Motorcycle` class:'
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Here, after trait, such an override works for the subclass and no change should
    be required here.
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In order to test the discounted price, we should instantiate the `Motorcycle`
    class, set the price, and get the price to see whether a discount has been applied
    or not, which was previously done in `Motorcycle.php`. Locate the following content
    in the `Motorcycle.php` file:'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Now, if we run `Motorcycle.php` with the `php Motorcycle.php` command, the
    preceding code outputs the following:'
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.26: The trait method overridden by Motorcycle'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_05_26.jpg)'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.26: The trait method overridden by Motorcycle'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, traits can be used to add member methods of a class, can override
    any existing member methods of the same name, and can be overridden via inheritance.
    Alternatively, we could have used `PriceTrait` in the `Car` and `Motorcycle` classes
    directly instead of the `Vehicle` class by adding the trait in them. Our intention
    is to share the common characteristics of vehicles via the parent `Vehicle` class,
    that's why we have used the trait in the mother class.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: Class Autoloading
  id: totrans-653
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may skip this section if you choose to use Composer. Consider class auto
    loading for legacy PHP projects who can't use Composer.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: With the addition of PHP's package manager, Composer, you can leverage Composer's
    autoloader to load classes, libraries, and so on. See [https://packt.live/2MrJG9u](https://packt.live/2MrJG9u)
    for more details. *Chapter 9*, *Composer* is dedicated to discussing **Composer**
    and **Autoloading** in detail.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: To use a class inside a file that is located in another file, we have to include
    the corresponding file that contains the class in the current file. This approach
    ends up including a good number of files in any PHP script. Hence, we need something
    that automatically includes our required class files.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: In order to load your class automatically, PHP comes with the `spl_autoload_register()`
    function. With that function, we can register any number of autoloaders so that
    we can load classes and interfaces on demand. Yes – on-demand. That means the
    autoloading is lazy – it loads the classes or interfaces only when they are called.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following simple code snippet:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Preceding snippet is equivalent to the following:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: So, in the preceding code snippet, you can see that we have passed an anonymous
    PHP function to the `spl_autoload_register()` function. This anonymous function
    accepts the class or interface name and tries to include/require the corresponding
    file. With the `spl_autoload_register` function, we can register our own such
    autoloader functions and we can do all sorts of operations to load the file, such
    as setting the file path/directory, checking whether the file exists or not, throwing
    an exception, and so on. Hence, we can avoid a larger list of file inclusion statements.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: 'Say, for `Car.php` and `Motorcycle.php`, we can just replace the following
    two lines with the `spl_autoload_register()` function:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The preceding snippet can be replaced with the following:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'So, like the following, when the `Car` class extends the `AbstractVehicle`
    class and implements the `DriveInterface` interface, the autoloader is invoked
    to load the corresponding class file and interface file:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Here, the registered autoloader is invoked to load the file when the class or
    interface has been used.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: To autoload PSR-4 classes, follow the guidelines at [https://packt.live/314fBCj](https://packt.live/314fBCj).
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: The `spl_autoload_register()` function specification can be found at [https://packt.live/2B1PLEu](https://packt.live/2B1PLEu).
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  id: totrans-674
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, a namespace provides naming and scoping, therefore, a
    namespace is another way of encapsulating items. We can call a named scope, a
    namespace can house related constants, functions, classes, abstract classes, traits,
    and interfaces in a group with a name, and they can be accessed using the name.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: As an analogy, consider the naming of people. People are given unique names
    in a family in order to identify them and call them by. Beyond family, what if
    there are two people with the same name? There could be one John Doe in the computer
    science department and another John Doe in the electrical department. Coincidentally,
    they end up in the varsity's football team, so they can be called John Doe of
    computer science and John Doe of the electrical department. Surely, the team doesn't
    want to pass the football to the wrong John Doe.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 'The same goes for computer filesystems: there are directories and subdirectories.
    Inside a directory, there could be other directories and there can''t be two directories
    with the same name. Again, files with the same name can exist in two different
    directories; for example, `/usr/home/readme.md` and `/var/projects/readme.md`.'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: In programming, a namespace solves problems such as name collisions where classes
    or libraries have the same name so that they can be utilized under a different
    name. Surely, we don't want to write a class that pollutes the global scope by
    conflicting with another class's name. Also, the namespace provides aliasing –
    we can shorten a long name, so that code readability improves.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP supports the namespace with the `namespace` keyword, as follows:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The namespace should be the first statement you declare in your script. Although,
    you can write code without using a namespace.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: If we don't define a namespace, our code stays in the global namespace. That's
    why the global namespace can be easily polluted by producing name collisions.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternative syntax for declaring a namespace is as follows:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'We can declare multiple namespaces within a single file as follows:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: It is strongly discouraged to put multiple namespaces into the same file in
    order to promote good coding practices. A general use case for an example of having
    multiple namespaces in the same file is including multiple PHP files in the same
    file.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare subnamespaces to achieve a hierarchy of namespaces, as
    follows:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'We can import a namespace using the `use` keyword and, optionally, we can alias
    the namespace with the `as` keyword as follows:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The `file2.php` will be as follows:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Here, at the `use MyNamespaceA\MyClass as A;` line, `MyClass` and `MyNamespaceA`
    are imported inside `MyNamespaceB` and, while importing, we aliased the class
    name to `A` so that we can instantiate the `MyClass` class as class `A` with `$object
    = new A();`.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: The same goes for other imports. We can import a function from another namespace,
    such as using the `MyNamespaceA\myFunction;` function and alias it by using the
    `MyNamespaceA\myFunction as func;` function.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: That way, we can call the function using the `func()` alias name. Also, we can
    do the same while importing constants. With the `use const MyNamespaceA\MYCONST;`
    line, we have imported the constant.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: 'Combining multiple importing is also possible:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Here, we have imported a class and a method together in the `use MyNamespaceA\MyClass
    as A, MyNamespaceA\myFunction;` line and aliased the class name as `A`. Normally,
    bringing in the necessary classes or functions from a namespace is the purpose
    of such importing instead of importing the whole namespace.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: PHP namespaces have so much to offer and there are more use cases and aspects
    that can be learned at [https://packt.live/2AYilqj](https://packt.live/2AYilqj).
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.12: Implementing Namespaces'
  id: totrans-701
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will apply namespaces to our vehicle-related classes,
    traits, and interfaces. We will apply a common namespace to the `AbstractVehicle`
    class, `DriveInterface`, `Car`, and `Motorcycle` classes. Also, for the traits,
    we will apply a different namespace so that we can keep the traits out of the
    common namespace:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Vehicle` directory to relocate `AbstractVehicle.php` and `DriveInterface.php`
    in it.
  id: totrans-703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Relocate `AbstractVehicle.php` and `DriveInterface.php` in the vehicle subdirectory,
    under your current working directory.
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another directory, `Traits`, for relocating the `PriceTrait.php` file
    and future traits.
  id: totrans-705
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The directory structure looks like the following:'
  id: totrans-706
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Fig 5.27: Namespaced directory structure'
  id: totrans-707
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_05_27.jpg)'
  id: totrans-708
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Fig 5.27: Namespaced directory structure'
  id: totrans-709
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now it''s time to apply namespaces to our classes and traits. Open the `PriceTrait.php`
    file and add the `Traits` namespace at the beginning, as follows:'
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-711
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Here, we have declared the `Traits` namespace at the beginning of `PriceTrait`.
    Our intention is to add different trait files in future, under the same namespace;
    for example, `namespace Traits` (at the beginning of any new trait files). The
    whole idea is to apply the `Traits` namespace across multiple trait files so that
    we can pick the right trait via the namespace. Hence, we can use `PriceTrait`
    like we use `\Traits\PriceTrait` in different classes.
  id: totrans-712
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `AbstractVehicle.php` file and remove the following line:'
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-714
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Since we are going to autoload the classes and trait files, we don't need to
    manually require files.
  id: totrans-715
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following namespace before the `AbstractVehicle` class:'
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-717
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Here, the `Vehicle` namespace will be our common namespace to share across vehicle
    subclasses and interfaces.
  id: totrans-718
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `use PriceTrait` using the namespace, as follows:'
  id: totrans-719
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-720
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Here, the `use \Traits\PriceTrait;` line tells the autoloader to load `PriceTrait`
    from the `Traits` directory located in your code base root.
  id: totrans-721
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `Vehicle` namespace before the `DriveInterface` interface, as follows:'
  id: totrans-722
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-723
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Here, `DriveInterface` shares the `Vehicle` namespace, so the interface is accessible
    via the same namespace.
  id: totrans-724
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `Car.php` file to eliminate the following manual file inclusion:'
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-726
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Replace the `Vehicle` namespace with the following:'
  id: totrans-727
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-728
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Here, `Car` shares the same namespace, `Vehicle`. So, in the class line, `Car`
    extends `AbstractVehicle` and implements `DriveInterface`, `AbstractVehicle`,
    and `DriveInterface` to resolve the current namespace, which is `Vehicle`. This
    is similar to the `Car` class extending to `Vehicle\AbstractVehicle` and implementing
    `Vehicle\DriveInterface`.
  id: totrans-729
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, add the `spl_autoload_register()` function before the `Car` class as follows:'
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-731
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Hence, the autoloader function should load the `AbstractVehicle` class and the
    `DriveInterface` interface from the `Vehicle` directory as it supports class loading
    from a namespaced directory.
  id: totrans-732
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Do the same for the `Motorcycle.php`, as follows:'
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-734
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Here, the `Motorcycle` class also shares the same namespace, `Vehicle`, to avail
    `AbstractVehicle` and `DriveInterface`.
  id: totrans-735
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At `Car.php`, add the following `Car` instance to test the `AbstractVehicle`
    and `DriveInterface` implementation:'
  id: totrans-736
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-737
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Here, just to test the extended class and the implemented interface, we have
    instantiated the `Car` class and accessed different member methods using the object
    handler.
  id: totrans-738
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The preceding code will produce the following output if we run the `Car.php`
    script with the `php Car.php` command:![Fig 5.28: Namespace applied to Car'
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_05_28.jpg)'
  id: totrans-740
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Fig 5.28: Namespace applied to Car'
  id: totrans-741
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can see that the `Car` class can access the namespace applied to the abstract
    class and the interface.
  id: totrans-742
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, to `Motorcycle.php`, add the following `Motorcycle` instance to test the
    `AbstractVehicle` and `DriveInterface` implementation:'
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-744
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The preceding code will produce the following output if we run the `Motorcycle.php`
    script with the `php Motorcycle.php` command:'
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Fig 5.29: Namespace applied to Motorcycle'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_05_29.jpg)'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: 'Fig 5.29: Namespace applied to Motorcycle'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding exercise, we saw that the `Vehicle` namespace encapsulated
    all the relevant items, such as the abstract class, the interface, and the subclasses.
    Thus, a namespace can be shared across multiple files among relevant code components.
    Also, we can subnamespace internal libraries, plugins, utility files, and so on.
    The idea of the namespace is to assemble your project under a unique and relevant
    name so that none of your code components conflict when you integrate third-party
    code components.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5.1: Building a Student and Professor Object Relationship'
  id: totrans-750
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will implement OOP concepts to create `Student` and `Professor`
    classes with parameterized constructors, attributes, and member methods. We will
    instantiate both classes and establish a relationship between the objects. A professor
    might have a certain number of students enrolled in their class. The list of students
    should be printed using a member method of the `Professor` object.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to be performed are as follows:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory named `activity1` to put all our activity content in it.
    This should be our working directory (you can `cd` to the directory).
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a script file called `activity-classes.php`.
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `Professor` and `Student` classes in separate directories with the following
    functionalities.
  id: totrans-755
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both use their own namespacing to load the classes automatically.
  id: totrans-756
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Both take the name as the first argument in the constructor; the `Professor`
    class accepts the second argument as a list of students – the list will be filtered
    for instances of `Student` only.
  id: totrans-757
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Both will have the title property, which, by default, for the `Professor` class
    is `Prof.` and for the `Student` class is `student`.
  id: totrans-758
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a function that will print the Professor's title, name, the student count,
    and the list of students.
  id: totrans-759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Professor` instance, providing a name and a list of students – instances
    of `Student` with a name in the constructor.
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a random amount of `Student` instances to the `Professor` instance.
  id: totrans-761
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the title of the professor to `Dr.`.
  id: totrans-762
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the output by invoking the function with the `Professor` instance.
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output should look like the following:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Note
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 515.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-768
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked with object-oriented concepts and took note of how
    each of those concepts fitted into different scenarios. Encapsulation, inheritance,
    polymorphism, data abstraction, dynamic binding, and message passing all added
    new dimensions to our program. Note that these concepts can be adopted when they
    fit your particular scenario; until then, there's no need to complicate the program.
    We have seen that the misuse of OOP principles is common, and, down the road,
    that adds a burden of complexity.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependencies should be injected from outside rather than being hardcoded inside.
    Abstractions should not depend on details; hide your data appropriately, hide
    your complexities, and expose simplicity when message passing. Overall, the mapping
    of the objects in your program with the problem domain should be taken care of.
    Remember this simple statement: "If you can''t reuse it, then it doesn''t possess
    value."'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will describe request handling, storing local data,
    and file uploads.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
