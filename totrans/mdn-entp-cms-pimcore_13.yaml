- en: '*Chapter 13*: Implementing Master Data Management'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 13 章*：实施主数据管理'
- en: In the previous chapter, you learned about the concept of **Product Information
    Management** (**PIM**), and how to properly create a Pimcore class to represent
    products. Through some coding examples, you learned how to create product variants
    and bundle products, and how to define different types of products by extending
    the defined class with Objectbricks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了 **产品信息管理**（PIM）的概念，以及如何正确创建 Pimcore 类来表示产品。通过一些编码示例，您学习了如何创建产品变体和捆绑产品，以及如何通过扩展定义的类使用
    Objectbricks 来定义不同类型的产品。
- en: 'In this chapter, we will present the concept of **Master Data Management**
    (**MDM**), and how to expose Pimcore objects to third-party applications using
    the **Datahub** Pimcore bundle. The chapter is organized as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 **主数据管理**（MDM）的概念，以及如何使用 **Datahub** Pimcore 扩展将 Pimcore 对象暴露给第三方应用程序。本章的组织结构如下：
- en: Turning Pimcore into MDM
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Pimcore 转换为 MDM
- en: Activating the Pimcore Datahub bundle
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活 Pimcore Datahub 扩展包
- en: Exposing entities
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露实体
- en: Using mutation queries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用突变查询
- en: Creating a custom mutation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义突变
- en: Defining custom reports
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义自定义报告
- en: Starting with a definition of **Master Data Management**, we will see how to
    turn Pimcore into MDM. Then, we will present the Pimcore Datahub bundle and explain
    how to install it. After that, we will see how to expose created objects, how
    to use mutation queries to create new objects, and how to create custom mutations.
    Last but not least, we will see how to define custom reports.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从 **主数据管理**的定义开始，我们将看到如何将 Pimcore 转换为 MDM。然后，我们将介绍 Pimcore Datahub 扩展包并解释如何安装它。之后，我们将看到如何暴露创建的对象，如何使用突变查询创建新对象，以及如何创建自定义突变。最后但同样重要的是，我们将看到如何定义自定义报告。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As you have done in previous chapters, all you need to do to run the demo connected
    with this chapter is to navigate to the `13\. Implementing Master Data Management`
    folder in the official book repository and start a Docker environment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在之前的章节中所做的那样，要运行与本章相关的演示，您只需导航到官方书籍仓库中的 `13\. 实施主数据管理` 文件夹并启动 Docker 环境。
- en: 'To do so, just follow these instructions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，只需遵循以下说明：
- en: 'Run Docker with the following command:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行 Docker：
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, to restore all the settings on your local machine, just open a new shell
    and type the following command:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为了恢复您本地机器上的所有设置，只需打开一个新的 shell 并输入以下命令：
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Navigate to http://localhost/admin and log in with your admin/pimcore credentials.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 http://localhost/admin 并使用您的 admin/pimcore 凭据登录。
- en: 'You can access the official book repository to get the source code through
    the following link:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下链接访问官方书籍仓库以获取源代码：
- en: '[https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/13.%20Implementing%20Master%20Data%20Management](https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/13.%20Implementing%20Master%20Data%20Management)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/13.%20Implementing%20Master%20Data%20Management](https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/13.%20Implementing%20Master%20Data%20Management)'
- en: Now you are ready to navigate through the demo to discover all aspects related
    to this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好导航演示，以发现与本章相关的所有方面。
- en: Turning Pimcore into MDM
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Pimcore 转换为 MDM
- en: In [*Chapter 1*](B17073_01_ePub_RK.xhtml#_idTextAnchor014), *Introducting Pimcore*,
    we briefly introduced the concept of Master Data Management. MDM is a fundamental
    process used to manage, centralize, organize, categorize, locate, synchronize,
    and enrich critical data based on your company's sales, marketing, and operational
    strategies. In this section, we will explain this concept better to let you understand
    how easily you can put into practice the learnings from the previous chapters
    to turn Pimcore into an MDM system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 1 章*](B17073_01_ePub_RK.xhtml#_idTextAnchor014)，*介绍 Pimcore* 中，我们简要介绍了主数据管理（MDM）的概念。MDM
    是一个基本流程，用于根据公司的销售、营销和运营策略来管理、集中、组织、分类、定位、同步和丰富关键数据。在本节中，我们将更好地解释这个概念，以便您了解如何轻松地将前几章的学习应用到将
    Pimcore 转换为 MDM 系统中。
- en: 'We have already seen in [*Chapter 12*](B17073_12_ePub_RK.xhtml#_idTextAnchor211),
    *Implementing Product Information Management,* the potential that Pimcore has
    in terms of data management, but it has one big limitation: it''s strictly related
    to the concept of products.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [*第 12 章*](B17073_12_ePub_RK.xhtml#_idTextAnchor211)，*实施产品信息管理* 中看到了 Pimcore
    在数据管理方面的潜力，但它有一个很大的限制：它与产品的概念紧密相关。
- en: In many company scenarios, products are not the only kind of data that needs
    to be defined, managed, and shared through the company users or distributed in
    different channels. For example, if we think in terms of e-commerce purposes,
    we may want to store orders and customers or define the details of our physical
    shops to create a store locator page on an e-commerce site.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多公司场景中，产品并不是唯一需要通过公司用户定义、管理和共享，或在不同渠道分发的数据类型。例如，如果我们从电子商务的角度来考虑，我们可能希望存储订单和客户信息，或者定义我们实体店铺的详细信息，以便在电子商务网站上创建一个店铺定位页面。
- en: To provide a completely different example, the classes created in [*Chapter
    9*](B17073_09_ePub_RK.xhtml#_idTextAnchor166), *Configuring Entities and Rendering
    Data**,* to store articles and categories can be intended, in a certain sense,
    as a possible implementation of MDM.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个完全不同的例子，[*第九章*](B17073_09_ePub_RK.xhtml#_idTextAnchor166)，*配置实体和渲染数据*中创建的类，用于存储文章和分类，在某种意义上可以被视为MDM的可能实现。
- en: That said, the first step that we must do to turn Pimcore into an MDM system
    is to create a class for each concept that we need to represent, and we can easily
    do this through the Pimcore class-definition interface. This alone is not sufficient,
    but think about how easy it is to create Pimcore classes through the out-of-the-box
    interface, as you learned in [*Chapter 5*](B17073_05_ePub_RK.xhtml#_idTextAnchor093),
    *Exploring Objects and Classes*, and how this produces a strong and easy-to-maintain
    structure without writing a single line of code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们将Pimcore转变为MDM系统的第一步是创建一个代表每个概念的类，我们可以通过Pimcore类定义界面轻松地做到这一点。仅此还不够，但想想通过即插即用的界面创建Pimcore类是多么容易，正如你在[*第五章*](B17073_05_ePub_RK.xhtml#_idTextAnchor093)，*探索对象和类*中学习到的，以及这如何在不写一行代码的情况下产生一个强大且易于维护的结构。
- en: Since you have already learned how to create Pimcore classes in the previous
    chapter, we will not repeat the process in this chapter as well. If you followed
    the instructions provided in the *Technical requirements* section, you should
    find some already defined classes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经在上一章中学习了如何创建Pimcore类，所以我们不会在本章中重复这个过程。如果你遵循了*技术要求*部分提供的说明，你应该会找到一些已经定义好的类。
- en: 'Once the structure is defined, we can take advantage of Pimcore potentials
    to implement the data management processes, among which we can cite the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了结构，我们就可以利用Pimcore的潜力来实现数据管理流程，其中我们可以引用以下内容：
- en: '**Data validation**: For class attributes, we can define a few validation rules—for
    example, we can decide whether each attribute is mandatory for a class and, for
    text attributes, add a regular expression to validate the content. This can be
    useful, but it does not permit defined complex validation scenarios such as (for
    example) cross-attribute validation. This can be done by implementing event listeners,
    as you learned in the previous chapter.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据验证**：对于类属性，我们可以定义一些验证规则——例如，我们可以决定每个属性是否对类是必需的，对于文本属性，我们可以添加一个正则表达式来验证内容。这可能很有用，但它不允许定义复杂的验证场景，例如（例如）跨属性验证。这可以通过实现事件监听器来完成，正如你在上一章中学到的。'
- en: '**Data quality**: Data quality consists of a set of tools and processes needed
    to give qualitative and quantitative consistency to our data—for example, we may
    want to check whether translations for our objects are complete or not. We can
    accomplish this by creating specific kinds of attributes that are **Calculated
    Value** and **Dynamic Text Label** attributes (we will see an example of these
    in the next section).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据质量**：数据质量包括一组工具和流程，用于为我们提供数据的质量和数量一致性——例如，我们可能想检查我们的对象翻译是否完整。我们可以通过创建特定类型的属性来实现这一点，这些属性是**计算值**和**动态文本标签**属性（我们将在下一节中看到这些属性的示例）。'
- en: '**Versioning**: One of the main characteristics of **PIM**, **DAM**, and **MDM**
    is the possibility to share objects. Every user that has write permission can
    edit products and other objects, and different users may access and save the same
    object. For this reason, it''s important to keep track of object versions to have
    a clear view of which user has made changes.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**：PIM、DAM和MDM的主要特征之一是共享对象的可能性。任何具有写权限的用户都可以编辑产品和其它对象，不同的用户可能访问并保存相同的对象。因此，跟踪对象版本以清楚地了解哪个用户进行了更改是很重要的。'
- en: Now that we have defined the main characteristics of an MDM system, let's see
    an example of a Data Quality implementation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了MDM系统的主要特征，让我们看看一个数据质量实现的例子。
- en: Implementing Data Quality
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现数据质量
- en: In the previous section, we introduced the definition of Master Data Management,
    and you learned what the main characteristics of an MDM system are.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前节中，我们介绍了主数据管理的定义，并学习了MDM系统的主要特征。
- en: In this section, through an example, we will see how to implement **data quality**.
    As we mentioned in the previous section, we can accomplish this using two different
    kinds of attributes, which are **Calculated Value** and **Dynamic Text Label**
    attributes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，通过一个示例，我们将看到如何实现**数据质量**。正如我们在前节中提到的，我们可以使用两种不同的属性来完成这项工作，即**计算值**和**动态文本标签**属性。
- en: 'These particular kinds of attributes require the development of a **PHP: Hypertext
    Preprocessor** (**PHP**) class whose methods are automatically called when an
    object is opened. Once this class is developed, we must write the class namespace
    in the attribute configuration, as you can see in the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特定的属性需要开发一个**PHP：超文本预处理器**（**PHP**）类，其方法在对象打开时自动调用。一旦这个类开发完成，我们必须在属性配置中写入类命名空间，如下面的截图所示：
- en: '![Figure 13.1: Calculated value configuration'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.1：计算值配置'
- en: '](img/Figure_13.01_B17073.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_13.01_B17073.jpg)'
- en: 'Figure 13.1: Calculated value configuration'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：计算值配置
- en: As you can see in the previous screenshot, we can put the class namespace in
    the **Calculator class** input in the attribute configuration. Once the input
    is filled, you can click on the **Save** button to apply the changes to the class.
    The same configuration can be done for the **Dynamic Text Label** attributes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，我们可以在属性配置中将类命名空间放入**计算器类**输入框中。一旦输入完成，你可以点击**保存**按钮将更改应用到类上。同样的配置也可以应用于**动态文本标签**属性。
- en: 'Now that we have seen how to configure the attributes, in the following code
    snippet, we will see how to implement the `Calculator` class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何配置属性，在接下来的代码片段中，我们将看到如何实现`Calculator`类：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the previous code snippet, you can see how to realize a PHP class suitable
    for `CalculatorClassInterface` interface, which involves implementing the following
    two methods:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可以看到如何实现一个适合`CalculatorClassInterface`接口的PHP类，这涉及到实现以下两个方法：
- en: The `compute` method is called on the object save, to store the calculated value
    in the database.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象保存时调用`compute`方法，以将计算值存储在数据库中。
- en: The `getCalculatedValueForEditMode` method is invoked to display the value in
    the object edit modal.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCalculatedValueForEditMode`方法被调用以在对象编辑模态中显示值。'
- en: These two functions are typically expected to return the same value, so it's
    a best practice to let one function return the value of the other one to avoid
    code duplication.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数通常预期返回相同的值，因此最佳实践是让一个函数返回另一个函数的值，以避免代码重复。
- en: These functions take the object instance and the attribute context as input
    that contains useful information such as the `fieldname` attribute. For localized
    fields, the current language is defined in the `position` property of the context.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数接受对象实例和包含有用信息的属性上下文作为输入，例如`fieldname`属性。对于本地化字段，当前语言定义在上下文的`position`属性中。
- en: In this specific example, we first check whether the object is a product, which
    is the class for which we have set the **Calculated Value** attribute. Then, we
    check whether for each language all the localized fields are empty or not.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定示例中，我们首先检查对象是否是产品，这是我们为它设置了**计算值**属性的那个类。然后，我们检查对于每种语言，所有本地化字段是否都为空。
- en: 'In the following code snippet, we will see how to implement a method needed
    to render the dynamic text label:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们将看到如何实现渲染动态文本标签所需的方法：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see in the previous code snippet, the class is similar to the previously
    created one. To render the dynamic text label, the class must implement the `DynamicTextLabelInterface`
    interface. This interface presents the `renderLayoutText` method, which we must
    implement.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个代码片段所示，该类与之前创建的类相似。为了渲染动态文本标签，该类必须实现`DynamicTextLabelInterface`接口。该接口提供了`renderLayoutText`方法，我们必须实现它。
- en: In the `renderLayoutText` method, we can return **HyperText Markup Language**
    (**HTML**) text that will be rendered in the label. In this specific example,
    we have realized a simple HTML table that shows whether the localized fields are
    completed for each language, using the previously created calculated value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`renderLayoutText`方法中，我们可以返回将在标签中渲染的**超文本标记语言**（**HTML**）文本。在这个特定示例中，我们实现了一个简单的HTML表格，显示了每种语言本地化字段是否已完成，使用了之前创建的计算值。
- en: 'In the following screenshot, you can see what these attributes look like:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，您可以查看这些属性的外观：
- en: '![Figure 13.2: Calculated values result'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.2：计算值结果'
- en: '](img/Figure_13.02_B17073.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.02_B17073.jpg)'
- en: 'Figure 13.2: Calculated values result'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：计算值结果
- en: As you can see in the previous screenshot, the dynamic text label shows the
    completeness status for each language, while the calculated value shows whether
    the selected language fields have been completed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在上一张屏幕截图中所见，动态文本标签显示了每种语言的完整性状态，而计算值显示了所选语言字段是否已完成。
- en: To summarize, in this section, you learned about the concept of **Master Data
    Management** (**MDM**), and how you can take advantage of Pimcore potentials to
    implement the data management processes, turning Pimcore into an MDM system. Later,
    you learned how to implement calculated values to realize data quality.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，您了解了**主数据管理**（**MDM**）的概念，以及如何利用Pimcore潜力来实现数据管理流程，将Pimcore转变为MDM系统。稍后，您学习了如何实现计算值以实现数据质量。
- en: In the following section, you will learn how to activate the Pimcore Datahub
    bundle that you can use to expose Pimcore objects to third-party applications.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何激活Pimcore Datahub Bundle，该Bundle可用于将Pimcore对象公开给第三方应用程序。
- en: Activating the Pimcore Datahub bundle
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激活Pimcore Datahub Bundle
- en: In the previous section, you learned how to implement data management processes,
    such as the data quality process. These processes, the name of what? unclear,
    are key aspects of the MDM concept. Another fundamental feature for MDM systems
    is the possibility to expose entities to third-party applications and sites.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您学习了如何实现数据管理流程，如数据质量流程。这些流程，名称？不清楚，是MDM概念的关键方面。MDM系统的另一个基本功能是向第三方应用程序和站点公开实体。
- en: In this section, you will learn how to activate the Pimcore **Datahub** bundle
    and how to configure that bundle properly. Later in this chapter, you will learn
    how to use this bundle to expose Pimcore objects and let external applications
    create new objects.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何激活Pimcore **Datahub** Bundle，以及如何正确配置该Bundle。在本章的后面部分，您将学习如何使用此Bundle公开Pimcore对象，并允许外部应用程序创建新对象。
- en: 'As you learned in the *Installing a Bundle* section of [*Chapter 7*](B17073_07_ePub_RK.xhtml#_idTextAnchor129),
    *Administrating Pimcore Sites*, Pimcore bundles can be downloaded through the
    `composer` package manager; to download the Datahub bundle, you just need to follow
    these instructions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[*第7章*](B17073_07_ePub_RK.xhtml#_idTextAnchor129)的[*“安装Bundle”*](B17073_07_ePub_RK.xhtml#_idTextAnchor129)部分所学的，*管理Pimcore站点*，Pimcore
    Bundle可以通过`composer`包管理器下载；要下载Datahub Bundle，您只需遵循以下说明：
- en: Open a shell and point to the chapter folder of the book source code.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个shell并指向书籍源代码的章节文件夹。
- en: 'Run the following command to jump inside the Docker container:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以进入Docker容器：
- en: '[PRE4]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the following command to download the Datahub bundle:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以下载Datahub Bundle：
- en: '[PRE5]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the bundle is downloaded, it must be enabled and installed to be able
    to use it. You can do this through the **Tools** | **Bundles** menu, as shown
    in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完Bundle后，必须启用并安装才能使用。您可以通过**工具** | **Bundle**菜单来完成此操作，如下面的屏幕截图所示：
- en: '![Figure 13.3: Datahub Bundle Installation'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.3：Datahub Bundle安装'
- en: '](img/Figure_13.03_B17073.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.03_B17073.jpg)'
- en: 'Figure 13.3: Datahub Bundle Installation'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：Datahub Bundle安装
- en: As you can see in the previous screenshot, the Datahub bundle must first be
    enabled and then installed. The installation of the bundle will create additional
    tables inside the database structure.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在上一张屏幕截图中所见，必须首先启用Datahub Bundle，然后才能安装。Bundle的安装将在数据库结构内部创建额外的表。
- en: 'These operations can be accomplished alternatively through the following Bash
    commands:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作可以通过以下Bash命令以不同的方式完成：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Please note that running these commands is just an alternative to the operations
    made through the extension manager interface; only one method should be used.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，运行这些命令只是通过扩展管理器界面进行的操作的一个替代方案；应只使用一种方法。
- en: Now that you have learned how to install the Datahub bundle, let's see how to
    create Datahub configuration models.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何安装 Datahub 包，让我们看看如何创建 Datahub 配置模型。
- en: Creating a Datahub configuration
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Datahub 配置
- en: In the previous section, you learned how to install and activate the Pimcore
    Datahub bundle. In this section, you will learn how to create configurations for
    Datahub. These configurations will govern how third-party applications can interact
    with Pimcore to retrieve, create, or update objects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何安装和激活 Pimcore Datahub 包。在本节中，你将学习如何为 Datahub 创建配置。这些配置将决定第三方应用程序如何与
    Pimcore 交互以检索、创建或更新对象。
- en: 'To open the Datahub configuration panel, just go through **Settings** | **Datahub
    Config** in the Pimcore menu. To create a new configuration, just follow the next
    instructions:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开 Datahub 配置面板，只需在 Pimcore 菜单中通过 **Settings**（设置）| **Datahub Config**（Datahub
    配置）进行。要创建新的配置，只需遵循以下说明：
- en: Click on the **Add Configuration** button.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Add Configuration**（添加配置）按钮。
- en: Write the configuration name inside the window that appears.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的窗口中写下配置名称。
- en: Click on the **OK** button to confirm the creation.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **OK** 按钮以确认创建。
- en: 'In the following screenshot, you can see a representation of the previous instructions:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，你可以看到前述指令的表示：
- en: '![Figure 13.4: Creating a Datahub configuration'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.4：创建 Datahub 配置'
- en: '](img/Figure_13.04_B17073.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.04_B17073.jpg)'
- en: 'Figure 13.4: Creating a Datahub configuration'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4：创建 Datahub 配置
- en: As you can see in the previous screenshot, once the configuration is created
    it is visible in the left-side menu. If you click on the created configuration,
    the configuration will open in the edit mode. The setup of the configuration can
    be made through three different panels, as we are about to see.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，一旦配置创建完成，它就会在左侧菜单中可见。如果您点击创建的配置，配置将以编辑模式打开。配置的设置可以通过三个不同的面板进行，正如我们即将看到的。
- en: 'The **General** panel contains general information about the configuration,
    such as the configuration name. We can see what this panel looks like in the following
    screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**General**（通用）面板包含有关配置的一般信息，例如配置名称。我们可以在下面的屏幕截图中看到这个面板的样子：'
- en: '![Figure 13.5: General panel'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.5：通用面板'
- en: '](img/Figure_13.05_B17073.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.05_B17073.jpg)'
- en: 'Figure 13.5: General panel'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5：通用面板
- en: 'Let''s now describe each property that we see in the preceding screenshot,
    as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将描述在前面的屏幕截图中看到的每个属性，如下所述：
- en: '**Active**: If enabled, the configuration is active and can be exposed to external
    applications.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Active**: 如果启用，配置是激活的，并且可以被外部应用程序访问。'
- en: '**Type**: The configuration type. In the current version, only the GraphQL
    typology exists.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Type**: 配置类型。在当前版本中，只有 GraphQL 类型存在。'
- en: '**Name**: The configuration name, defined during the configuration creation.
    This may not be changed.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Name**: 配置名称，在配置创建期间定义。这可能无法更改。'
- en: '**Description**: This lets you write a textual description for the configuration.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Description**: 这允许你为配置编写文本描述。'
- en: '**SQL Condition**: In this property, you can add a **Structured Query Language**
    (**SQL**) condition that will be used to do a pre-filtering of all the queries.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL Condition**: 在这个属性中，你可以添加一个 **Structured Query Language**（结构化查询语言，SQL）条件，该条件将用于对所有查询进行预过滤。'
- en: 'In the **Schema Definition** panel, we can define which classes are enabled
    for queries and mutations. We can see what this panel looks like in the following
    screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Schema Definition**（模式定义）面板中，我们可以定义哪些类被启用用于查询和突变。我们可以在下面的屏幕截图中看到这个面板的样子：
- en: '![Figure 13.6: Schema Definition panel'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.6：Schema Definition 面板'
- en: '](img/Figure_13.06_B17073.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.06_B17073.jpg)'
- en: 'Figure 13.6: Schema Definition panel'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6：Schema Definition 面板
- en: 'Let''s now describe each property that we see in the preceding screenshot,
    as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将描述在前面的屏幕截图中看到的每个属性，如下所述：
- en: '**Query Schema**: In this section, we can select one or more classes, with
    objects that will be available for queries. For each selected class, it''s possible
    to define which attributes must be exposed in queries. We will see this concept
    in the *Exposing entities* section.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Query Schema**: 在这个部分，我们可以选择一个或多个类，其中包含可用于查询的对象。对于每个选定的类，可以定义在查询中必须公开哪些属性。我们将在
    *Exposing entities*（公开实体）部分看到这个概念。'
- en: '**Mutation Schema**: Similar to the **Query Schema** section, in this section
    we can select classes that could be available for mutation queries. For each class,
    we can define whether objects can be created, updated, and deleted. We will see
    more on mutation queries later in this chapter, in the *Using mutation queries*
    section.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**突变模式**：类似于 **查询模式** 部分，在本节中我们可以选择可能用于突变查询的类。对于每个类，我们可以定义是否可以创建、更新和删除对象。我们将在本章后面的
    *使用突变查询* 部分了解更多关于突变查询的内容。'
- en: '**Generic Types**: Here, we can define whether assets, documents, and folders
    must be exposed for queries and mutations. For example, if we enable the **Read**
    option for object folders, we can retrieve all the objects that are contained
    in one folder.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用类型**：在这里，我们可以定义是否必须公开资产、文档和文件夹以进行查询和突变。例如，如果我们为对象文件夹启用 **读取** 选项，我们就可以检索一个文件夹中包含的所有对象。'
- en: 'In the **Security Definition** panel, we can manage authentication rules and
    restrict the visibility of entities to specific folders. We can see what this
    panel looks like in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **安全定义** 面板中，我们可以管理身份验证规则并限制实体对特定文件夹的可见性。我们可以在以下屏幕截图中看到这个面板的外观：
- en: '![Figure 13.7: Security Definition panel'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.7：安全定义面板]'
- en: '](img/Figure_13.07_B17073.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_13.07_B17073.jpg]'
- en: 'Figure 13.7: Security Definition panel'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7：安全定义面板
- en: 'Let''s now describe each property that we see in the preceding screenshot,
    as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们描述在前面的屏幕截图中看到的每个属性，如下所示：
- en: '**Method**: The authentication method. In the current version, only authentication
    through an **Application Programming Interface** (**API**) key is available.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：身份验证方法。在当前版本中，只有通过 **应用程序编程接口**（**API**）密钥进行身份验证的方式可用。'
- en: '**Datahub API Key**: The API key that will be required for authentication.
    This can be generated by clicking on the lightning bolt icon on the right.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Datahub API 密钥**：用于身份验证所需的 API 密钥。可以通过点击右侧的闪电图标来生成。'
- en: '**Skip Permission Check**: If enabled, the check for mandatory fields'' completeness
    is skipped when performing a mutation query.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跳过权限检查**：如果启用，则在执行突变查询时将跳过对必填字段的完整性的检查。'
- en: '**Workspaces**: In this section, we must specify specific **Documents**, **Assets**,
    and **Objects** folders to which we want to expose queries and mutations.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作空间**：在本节中，我们必须指定特定的 **文档**、**资产** 和 **对象** 文件夹，我们希望公开查询和突变。'
- en: Once you have completed the configuration, click on the **Save** button to apply
    the changes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 完成配置后，点击 **保存** 按钮以应用更改。
- en: 'After the configuration is saved, queries can be tested in two different ways,
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置保存后，可以通过两种不同的方式测试查询，如下所示：
- en: Through an integrated `Iframe`), which could be opened in a new panel in the
    Pimcore interface by clicking the **Open** in **Iframe** button
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过集成的 `Iframe`（可以通过点击 Pimcore 界面中的 **在 Iframe 中打开** 按钮在新面板中打开）
- en: In a new browser tab, which could be opened by clicking the **Open in Tab**
    button
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新的浏览器标签页中，可以通过点击 **在新标签页中打开** 按钮打开
- en: 'For third-party applications, queries can be made by performing **HyperText
    Transfer Protocol** (**HTTP**) calls to the following endpoint:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三方应用程序，可以通过对以下端点执行 **超文本传输协议**（**HTTP**）调用来进行查询：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the previous endpoint, you can see that the configuration name and the API
    key are variables, so you must substitute the placeholders with the values defined
    in the configuration.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的端点中，你可以看到配置名称和 API 密钥是变量，因此你必须用配置中定义的值替换占位符。
- en: 'All the defined configurations are stored in a `var/config/Datahub-configurations.php`
    file. If you want to share the same configuration between different environments,
    you can commit this file in the code base and rebuild the Datahub configurations
    running the following Bash command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的定义配置都存储在 `var/config/Datahub-configurations.php` 文件中。如果你想在不同的环境中共享相同的配置，可以将此文件提交到代码库，并运行以下
    Bash 命令来重建 Datahub 配置：
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To summarize, in this section, you have learned how to download and activate
    the Pimcore Datahub bundle and how to create a configuration for that bundle.
    In the following section, you will learn how to expose entities and how to perform
    queries on Datahub, testing them through the integrated Iframe.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，你学习了如何下载和激活 Pimcore Datahub 包以及如何为该包创建配置。在下一节中，你将学习如何公开实体以及如何在 Datahub
    上执行查询，并通过集成的 Iframe 进行测试。
- en: Exposing entities
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公开实体
- en: In the previous section, you learned how to activate a Datahub bundle and how
    to create a new configuration. In this section, you will learn how to set up the
    configuration to expose entities and how to perform queries on Datahub.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您学习了如何激活Datahub捆绑包以及如何创建新的配置。在本节中，您将学习如何设置配置以公开实体以及如何在Datahub上执行查询。
- en: As we mentioned in the previous section, in the **Schema Definition** panel
    of the Datahub configurations, we must select which classes should be available
    for queries, and add them in the **Query Schema** section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中提到的，在Datahub配置的**模式定义**面板中，我们必须选择哪些类应该可用于查询，并在**查询模式**部分添加它们。
- en: 'For each class, we must define which fields can be exposed for queries. This
    can be done by clicking on the **Settings** icon for each added class. In the
    following screenshot, you can see how to select the fields to expose:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个类，我们必须定义哪些字段可以公开用于查询。这可以通过点击每个添加的类的**设置**图标来完成。在下面的屏幕截图中，您可以查看如何选择要公开的字段：
- en: '![Figure 13.8: Query Schema fields'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.8：查询模式字段'
- en: '](img/Figure_13.08_B17073.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.08_B17073.jpg)'
- en: 'Figure 13.8: Query Schema fields'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8：查询模式字段
- en: As you can see in the previous screenshot, on the left side you can find a list
    of the class fields. If you double-click one of these fields or drag and drop
    a field on the right column, that field will be exposed and will be available
    for queries. Once you have selected all the fields you want to expose, just click
    on the **Apply** button to confirm your choice.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一张屏幕截图中看到的，在左侧您可以找到一个类字段的列表。如果您双击这些字段之一或将在右侧列中的字段拖放到右侧，该字段将被公开并可用于查询。一旦您选择了所有要公开的字段，只需点击**应用**按钮确认您的选择。
- en: Now we have learned how to configure a query schema, in the following section,
    you will see how to perform GraphQL queries on Datahub.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何配置查询模式，在接下来的部分，您将看到如何在Datahub上执行GraphQL查询。
- en: Performing GraphQL queries
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行GraphQL查询
- en: In the previous section, you learned how to expose classes and fields to let
    them be queryable. In this section, you will learn how to perform queries for
    your created configurations, seeing some query examples.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您学习了如何公开类和字段以使它们可查询。在本节中，您将学习如何为您创建的配置执行查询，并查看一些查询示例。
- en: As we previously mentioned in the *Creating a Datahub configuration* section,
    the only supported configuration type is GraphQL. GraphQL is a query language
    for building APIs and a tool for serving these APIs with real data. GraphQL provides
    a complete and understandable description of your API data, giving clients the
    power to request only what they need and nothing else. This allows easy integration
    with external software and allows you to easily maintain and evolve the APIs over
    time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*创建Datahub配置*部分之前提到的，唯一支持的配置类型是GraphQL。GraphQL是构建API的查询语言和用于用真实数据提供这些API的工具。GraphQL提供了对API数据的完整和可理解的描述，使客户端能够请求他们所需的数据，而不需要其他数据。这允许轻松集成外部软件，并允许您轻松维护和随着时间的推移发展API。
- en: GraphQL queries always return a predictable result, and therefore applications
    that use GraphQL are fast and reliable because they are in control of the data
    they require, not the server.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL查询总是返回可预测的结果，因此使用GraphQL的应用程序快速且可靠，因为它们控制着所需的数据，而不是服务器。
- en: GraphQL queries, in addition to accessing the data of a resource, can follow
    references with other entities. This eventually allows you to retrieve all the
    data needed by an application in a single call, unlike a typical **REpresentational
    State Transfer** (**REST**) API, which typically requires multiple calls to get
    data.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了访问资源的数据外，GraphQL查询还可以跟随其他实体的引用。这最终允许您在单个调用中检索应用程序所需的所有数据，与典型的**表示状态传输**（**REST**）API不同，后者通常需要多个调用才能获取数据。
- en: GraphQL APIs are therefore organized in terms of types and not endpoints; all
    data can be accessed with a single endpoint and the use of types ensures that
    external applications can only request what is allowed, which allows you to provide
    clear and useful error messages.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，GraphQL API是根据类型而不是端点组织的；所有数据都可以通过单个端点访问，使用类型确保外部应用程序只能请求允许的内容，这允许您提供清晰且有用的错误信息。
- en: 'Now that we have introduced what GraphQL is, let''s have a look at the Pimcore
    Datahub Iframe environment. In the following screenshot, you can see what this
    environment looks like:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了什么是GraphQL，让我们看看Pimcore Datahub Iframe环境。在下面的屏幕截图中，您可以查看这个环境的外观：
- en: '![Figure 13.9: Datahub Iframe Environment'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.9：Datahub Iframe 环境'
- en: '](img/Figure_13.09_B17073.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.9：Datahub Iframe 环境](img/Figure_13.09_B17073.jpg)'
- en: 'Figure 13.9: Datahub Iframe Environment'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9：Datahub Iframe 环境
- en: As you can see in the previous screenshot, the Iframe is divided into two panels.
    In the left panel, we can write a query that we want to run, while in the right
    panel, the query results are shown. As you can see, in the left panel, suggestions
    are shown when we write field names, giving the possibility to have auto-completeness.
    Once a query is ready, you can run it by clicking the **Play** button.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，Iframe 被分为两个面板。在左侧面板中，我们可以编写我们想要运行的查询，而在右侧面板中，则显示查询结果。如您所见，在左侧面板中，当我们编写字段名时，会显示建议，提供了自动完成的可能。一旦查询准备就绪，您可以通过点击**播放**按钮来运行它。
- en: Now that we have seen how to perform queries, let's have a look at some query
    examples that cover the various field types.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何执行查询，让我们看看一些涵盖各种字段类型的查询示例。
- en: Getting an Object Listing
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取对象列表
- en: 'In this example, you will learn how to perform object listing. In the following
    code snippet, you can see how a listing query is formed:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，您将学习如何执行对象列表操作。在下面的代码片段中，您可以查看如何形成列表查询：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see in the previous code snippet, the query statement is composed
    of a `get` prefix, the class name, and a `Listing` suffix. The listing function
    has the following input attributes:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个代码片段所示，查询语句由`get`前缀、类名和`Listing`后缀组成。列表函数具有以下输入属性：
- en: '`first`: The number of results to retrieve.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first`：要检索的结果数量。'
- en: '`after`: The number of objects to skip. Combined with the previous parameter,
    this can be used to perform pagination.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after`：要跳过的对象数量。与前面的参数结合使用，这可以用于执行分页。'
- en: '`ids`: A list of the **identifiers** (**IDs**) of objects to retrieve. If omitted,
    all products that respect the other filters are retrieved.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ids`：要检索的对象的**标识符**（**ID**）列表。如果省略，则检索所有符合其他过滤条件的商品。'
- en: '`fullpaths`: Similarly to the previous property, we can specify the paths of
    the objects to retrieve.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fullpaths`：类似于前面的属性，我们可以指定要检索的对象的路径。'
- en: '`filter`: One or more composed filters that will be applied to filter the objects
    to retrieve.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`：一个或多个将应用于过滤要检索对象的组合过滤器。'
- en: '`published`: Specify whether the query must include unpublished objects.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`published`：指定查询是否必须包含未发布对象。'
- en: '`defaultLanguage`: Specify the default language for localized fields.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultLanguage`：指定本地化字段的默认语言。'
- en: '`sortBy`: The field to sort the results by.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sortBy`：用于排序结果的字段。'
- en: '`sortOrder`: The sorting order for the specified field.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sortOrder`：指定字段的排序顺序。'
- en: The query content consists of an `edges` component, in which you can specify
    a list of fields to retrieve for each `node`, and a `totalCount` component, which
    always retrieves the total number of results despite the current page parameters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 查询内容由一个`edges`组件组成，其中您可以指定为每个`node`检索的字段列表，以及一个`totalCount`组件，它总是检索总结果数，而不考虑当前页面的参数。
- en: In the following examples, we will see how to retrieve a single object and how
    to retrieve values for different kinds of fields.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将看到如何检索单个对象以及如何检索不同类型字段的值。
- en: Getting a single object
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检索单个对象
- en: 'In this example, we will see how to retrieve a single object. You can see how
    to perform this query in the following code snippet:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将看到如何检索单个对象。您可以在下面的代码片段中查看如何执行此查询：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see in the previous code snippet, the query statement is composed
    of the `get` prefix and the class name. In the query function, we must define
    the object `id` or the object `fullpath`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个代码片段所示，查询语句由`get`前缀和类名组成。在查询函数中，我们必须定义对象的`id`或对象的`fullpath`。
- en: Then, we can optionally define the default language for localized fields. In
    the query content, you can see that for localized fields we can define a different
    language despite the default one.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以可选地定义本地化字段的默认语言。在查询内容中，您可以看到对于本地化字段，我们可以定义与默认语言不同的语言。
- en: In this example, you can also see how to query for `QuantityValue` fields. As
    you can see in the previous code snippet, you can require the field value, the
    unit of measure, and the composition of value and unit by the `toString` property.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，您还可以看到如何查询`QuantityValue`字段。如前一个代码片段所示，您可以通过`toString`属性要求字段值、度量单位以及值和单位的组合。
- en: In the following example, you will learn how to retrieve details of object relations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，您将学习如何检索对象关系的详细信息。
- en: Getting relation details
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following code snippet, you can see how to get details for standard
    relations and advanced relations:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see in the previous code snippet, for standard relations, as category
    one, we must specify the related class. In GraphQL syntax, this can be made by
    adding three dots, followed by the `on object_` keyword and the class name. For
    the related class, you can specify the fields to retrieve.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: For advanced relations, in the `element` component, you can specify the fields
    to retrieve for the related object, while in the `metadata` component, you can
    retrieve the name and the value for each relation metadata.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, you will learn how to retrieve values for Fieldcollections
    and how to require image details.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Getting Image Details
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, we will see how the same syntax can be used for **Fieldcollections**,
    and you will learn how to retrieve image details. In the following code snippet,
    you can see how to perform this kind of query:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see in the previous code snippet, the syntax is quite similar to
    the previous one that we have seen for object relations. For each image, we can
    require image details such as filename and file size, but we also can get Base64
    image content by the `data` attribute.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Getting Object Variants
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, you will learn how to get object variants. In the following
    code snippet, you can see how to get object children:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see in the previous code snippet, you can retrieve the object variants
    using the `getChildren` function. To get variants, you must specify that you require
    them by using the `objectTypes` property.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, you learned how to expose entities for Datahub
    configurations. After having seen what an integrated Iframe looks like, through
    some query examples you learned how to perform queries to retrieve object listing
    and details for different kinds of attributes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will learn how to perform mutation queries to
    create, update, and delete objects.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Using mutation queries
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned how to expose entities for Datahub configurations
    and how to perform queries to retrieve object data. In this section, you will
    learn how to expose entities for mutations and how to perform queries to create,
    update, and delete objects.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the *Activating the Pimcore Datahub bundle* section, in the
    **Schema Definition** panel of Datahub configurations, we must select which classes
    should be available for mutations and add them to the **Mutation Schema** section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: As we did for classes in the **Query Schema** section, we can define which fields
    can be exposed for mutation queries by clicking on the **Settings** icon for each
    added class. Besides, for each class, we can decide whether we want to make it
    available for creation, update, or deletion.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this section, we will learn how to perform mutation queries for creating,
    updating, and deleting objects.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Creating Objects
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, you will learn how to perform a mutation query to create a
    new object. In the following code snippet, you will see the query syntax for mutation
    queries, and a specific one that creates a new object:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see in the previous snippet, all mutation queries must start with
    the `mutation` keyword. Then, the query function is composed of the desired operation
    as a prefix, which is one of `create`, `update`, or `delete`, followed by the
    name of the class.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'In the function arguments, you can specify the following attributes:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '`key`: The key of the object. This will be shown in the object tree.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: The path in which the object is created. This could be a folder or
    a parent product.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parentId`: This can be used as an alternative to the `path` argument to define
    the parent folder or object.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`published`: If `false`, a product is created in the unpublished status.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`omitMandatoryCheck`: If `true`, an object is created even if all the mandatory
    fields are not filled.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: We can specify if a created object must be an object or a variant.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input`: In this attribute, we can specify the field values for an object that
    we want to create.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The query content consists of three components, outlined as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '`success`: A Boolean flag that will be `true` if the query runs successfully
    and `false` otherwise.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message`: A successful message if the query runs successfully.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output`: If an object is created successfully, this will show the object fields
    requested in the query.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running the previously defined query will return the following result:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see in the previous code snippet, if the object is created correctly,
    the object `id` is returned. This can be used to perform queries to update or
    delete an object.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to create a new object, let's see how to perform a
    query to update a previously created object.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Updating objects
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you learned how to create new objects using mutation
    queries. In this section, you will learn how to update previously created objects.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, you can see the syntax for an update mutation
    query:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see in the previous code snippet, the mutation query function starts
    with the `update` keyword. The object `id` must be passed as a function argument,
    and an error message will be returned if an object with the provided `id` does
    not exist.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to update a previously created object, let's see how
    to perform a query to delete that object.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Objects
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you learned how to update objects using mutation queries.
    In this section, you will learn how to delete an object.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, you can see the syntax for a delete mutation
    query:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see in the previous code snippet, the mutation query function starts
    with the `delete` keyword. The object `id` must be passed as a function argument,
    and an error message will be returned if an object with the provided `id` does
    not exist.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, you learned the syntax of mutation queries. In
    particular, we have seen how to create, update, and delete objects through specific
    queries. In the following section, you will learn how to create a custom mutation
    query function.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom mutation
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned how to use mutation queries to create,
    update, and delete objects. These kinds of queries work well for simple scenarios
    but present some limitations in terms of the kinds of attributes that we can update
    or for the interdependence of multiple attributes. For example, on standard mutation
    queries, the `QuantityValue` fields cannot be filled.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to create a custom mutation function and
    how to use that to update values that cannot be updated through standard mutation
    queries.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: To create a new custom mutation function, we need to add a function definition
    to the Datahub configuration schema. This can be made by implementing a listener
    for the `pimcore.Datahub.graphql.mutation.preBuild` event.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 12*](B17073_12_ePub_RK.xhtml#_idTextAnchor211), *Implementing
    Product Information Management*, you learned how to implement an **EventListener**.
    In the following code snippet, you will see an example that will show how to implement
    a listener that will affect the Datahub configuration schema:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the previous code snippet, we have implemented a simple function that will
    set the product price. As you can see in the example, the listener function has
    an input argument of type `MutationTypeEvent`. That event variable has a `config`
    property that contains the Datahub configuration schema. To add a new mutation
    function, we must add a new operation to this configuration.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to create an object of type `InputObjectType`. This object
    must contain a `fields` property, which has to be an array that must define the
    name and the type for each property that must be filled in the `input` argument
    of the mutation query function.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: We must then create an array that will define a new operation. This array must
    contain the operation arguments, such as the object `id` and the previously defined
    `input` argument, and must define a `resolve` function that, in our case, will
    set up the product price given the price value and unit.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have defined this operation, you must add that to the configuration
    attribute. As a result, the created function will be selectable in the Iframe,
    as you can see in the following screenshot:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10: Custom Mutation Query'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.10_B17073.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.10: Custom Mutation Query'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, in the left panel you can select
    the previously defined function and fill in the value and the unit for the product
    price. In the right panel, you can see the result message that was defined for
    the mutation query.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, you learned how to create a custom mutation query.
    This can be useful to set up object attributes for complex scenarios. As an example,
    you learned how to implement an event listener to create a custom mutation query
    that will set the product price.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to define custom reports to create tabular
    or chart reports with filtering and export functionalities.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Defining custom reports
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Custom Reports** is a report engine that is integrated directly into Pimcore.
    These reports are based on direct SQL queries on the database, and it''s possible
    to render them both as tables and charts. To define or generate a new custom report,
    follow these steps:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: To create a new report, go to the **Marketing** menu and click on the **Custom
    Reports** menu option.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, click on the **Add** button and insert the report name. After having
    created the report, you can start configuring it. In the following screenshot,
    you can see how to set up a report''s general settings:![Figure 13.11: General
    settings'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_13.11_B17073.jpg)'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.11: General settings'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, the report **Name** is the one that
    was inserted before.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, add a user-friendly label and eventually group the reports in folders.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create Shortcut in Menu** checkbox, and the report will be directly
    available in the **Marketing** menu.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After having configured the general settings, the next step is to configure
    the data source. This can be done by directly defining an SQL query, as you can
    see in the following screenshot:![Figure 13.12: Source definition'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_13.12_B17073.jpg)'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.12: Source definition'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, you can add a direct SQL query as
    a source definition. This gives you the possibility to design complex scenarios
    but requires advanced knowledge of the database structure. In this specific example,
    we want to count the number of products per category.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After having defined a data source, define how to render data. You can see
    how to manage the column configuration in the following screenshot:![Figure 13.13:
    Managing the Column Configuration'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_13.13_B17073.jpg)'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.13: Managing the Column Configuration'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, if a query is well formed, the columns
    are automatically detected. For each column, we can specify whether the column
    must be shown in the report and whether the column can be exported and sorted.
    Then, we can also define whether each column can be filterable, along with the
    filter type to apply, and then specify the width and the label for them. If a
    column contains an object `id`, we can also specify an **Open Object** action.
    As we will see in the next step, this will add a button that lets you open the
    corresponding object by the report table.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After having defined the column configuration, you can define the chart type,
    choosing from **Pie Chart**, **Bar Chart**, and **Line Chart**. For pie charts,
    you must then specify which column must be used to define the values list, and
    which one contains the data count.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the configuration is completed, go to the **Marketing** | **Reports**
    menu to see how the report is rendered. You can see what a defined example looks
    like in the following screenshot:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.14: Report Visualization'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.14_B17073.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.14: Report Visualization'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, the report is shown as a pie chart
    as we defined, with categories' names, a list of the different values, and a count
    of the products that form the pie slices.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom, you can see the report in a tabular version. In particular, you
    can see the **Open** button, which lets you open the linked category object. If
    you don't specify a chart type, only the tabular version is shown. The report
    table can be exported in a **comma-separated values** (**CSV**) file.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, you learned how to configure and render reports
    using the **Custom Reports** engine. Starting from the general settings, you learned
    how to configure a data source and how to properly render data in the report.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the concept of Master Data Management and how to
    expose Pimcore objects to third-party applications using the Datahub Pimcore bundle.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: After having defined that concept, you have seen an example of how to implement
    the concept of data quality, which is a key feature of MDM systems.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Later in the chapter, you learned how to activate a Datahub Pimcore Bundle and
    how to create a configuration for that bundle, and how to set up the configuration
    to expose objects and other entities with external applications.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: After having introduced the GraphQL query language, you learned how to perform
    queries to retrieve object data through some query examples, as well as how to
    create, update, and delete objects through mutation queries. Then, you learned
    how to implement a custom mutation query function, which is useful for defining
    complex scenarios.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, you learned how to configure and render custom reports,
    which let you present and export the data.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to perform Data Integration in Pimcore,
    with a specific focus on how to import and export objects and on when the standard
    functionalities are supposed to be used, and otherwise when they have limitations
    that make the implementation of a custom solution necessary.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何在Pimcore中执行数据集成，特别关注如何导入和导出对象，以及何时应该使用标准功能，以及在其他情况下，当它们存在限制需要实施自定义解决方案时。
