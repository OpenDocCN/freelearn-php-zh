- en: '*Chapter 13*: Implementing Master Data Management'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about the concept of **Product Information
    Management** (**PIM**), and how to properly create a Pimcore class to represent
    products. Through some coding examples, you learned how to create product variants
    and bundle products, and how to define different types of products by extending
    the defined class with Objectbricks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will present the concept of **Master Data Management**
    (**MDM**), and how to expose Pimcore objects to third-party applications using
    the **Datahub** Pimcore bundle. The chapter is organized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Turning Pimcore into MDM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activating the Pimcore Datahub bundle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using mutation queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom mutation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining custom reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with a definition of **Master Data Management**, we will see how to
    turn Pimcore into MDM. Then, we will present the Pimcore Datahub bundle and explain
    how to install it. After that, we will see how to expose created objects, how
    to use mutation queries to create new objects, and how to create custom mutations.
    Last but not least, we will see how to define custom reports.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have done in previous chapters, all you need to do to run the demo connected
    with this chapter is to navigate to the `13\. Implementing Master Data Management`
    folder in the official book repository and start a Docker environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, just follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run Docker with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, to restore all the settings on your local machine, just open a new shell
    and type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Navigate to http://localhost/admin and log in with your admin/pimcore credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can access the official book repository to get the source code through
    the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/13.%20Implementing%20Master%20Data%20Management](https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/13.%20Implementing%20Master%20Data%20Management)'
  prefs: []
  type: TYPE_NORMAL
- en: Now you are ready to navigate through the demo to discover all aspects related
    to this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Turning Pimcore into MDM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B17073_01_ePub_RK.xhtml#_idTextAnchor014), *Introducting Pimcore*,
    we briefly introduced the concept of Master Data Management. MDM is a fundamental
    process used to manage, centralize, organize, categorize, locate, synchronize,
    and enrich critical data based on your company's sales, marketing, and operational
    strategies. In this section, we will explain this concept better to let you understand
    how easily you can put into practice the learnings from the previous chapters
    to turn Pimcore into an MDM system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen in [*Chapter 12*](B17073_12_ePub_RK.xhtml#_idTextAnchor211),
    *Implementing Product Information Management,* the potential that Pimcore has
    in terms of data management, but it has one big limitation: it''s strictly related
    to the concept of products.'
  prefs: []
  type: TYPE_NORMAL
- en: In many company scenarios, products are not the only kind of data that needs
    to be defined, managed, and shared through the company users or distributed in
    different channels. For example, if we think in terms of e-commerce purposes,
    we may want to store orders and customers or define the details of our physical
    shops to create a store locator page on an e-commerce site.
  prefs: []
  type: TYPE_NORMAL
- en: To provide a completely different example, the classes created in [*Chapter
    9*](B17073_09_ePub_RK.xhtml#_idTextAnchor166), *Configuring Entities and Rendering
    Data**,* to store articles and categories can be intended, in a certain sense,
    as a possible implementation of MDM.
  prefs: []
  type: TYPE_NORMAL
- en: That said, the first step that we must do to turn Pimcore into an MDM system
    is to create a class for each concept that we need to represent, and we can easily
    do this through the Pimcore class-definition interface. This alone is not sufficient,
    but think about how easy it is to create Pimcore classes through the out-of-the-box
    interface, as you learned in [*Chapter 5*](B17073_05_ePub_RK.xhtml#_idTextAnchor093),
    *Exploring Objects and Classes*, and how this produces a strong and easy-to-maintain
    structure without writing a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Since you have already learned how to create Pimcore classes in the previous
    chapter, we will not repeat the process in this chapter as well. If you followed
    the instructions provided in the *Technical requirements* section, you should
    find some already defined classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the structure is defined, we can take advantage of Pimcore potentials
    to implement the data management processes, among which we can cite the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data validation**: For class attributes, we can define a few validation rules—for
    example, we can decide whether each attribute is mandatory for a class and, for
    text attributes, add a regular expression to validate the content. This can be
    useful, but it does not permit defined complex validation scenarios such as (for
    example) cross-attribute validation. This can be done by implementing event listeners,
    as you learned in the previous chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data quality**: Data quality consists of a set of tools and processes needed
    to give qualitative and quantitative consistency to our data—for example, we may
    want to check whether translations for our objects are complete or not. We can
    accomplish this by creating specific kinds of attributes that are **Calculated
    Value** and **Dynamic Text Label** attributes (we will see an example of these
    in the next section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning**: One of the main characteristics of **PIM**, **DAM**, and **MDM**
    is the possibility to share objects. Every user that has write permission can
    edit products and other objects, and different users may access and save the same
    object. For this reason, it''s important to keep track of object versions to have
    a clear view of which user has made changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have defined the main characteristics of an MDM system, let's see
    an example of a Data Quality implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Data Quality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we introduced the definition of Master Data Management,
    and you learned what the main characteristics of an MDM system are.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, through an example, we will see how to implement **data quality**.
    As we mentioned in the previous section, we can accomplish this using two different
    kinds of attributes, which are **Calculated Value** and **Dynamic Text Label**
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'These particular kinds of attributes require the development of a **PHP: Hypertext
    Preprocessor** (**PHP**) class whose methods are automatically called when an
    object is opened. Once this class is developed, we must write the class namespace
    in the attribute configuration, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1: Calculated value configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.01_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.1: Calculated value configuration'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, we can put the class namespace in
    the **Calculator class** input in the attribute configuration. Once the input
    is filled, you can click on the **Save** button to apply the changes to the class.
    The same configuration can be done for the **Dynamic Text Label** attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen how to configure the attributes, in the following code
    snippet, we will see how to implement the `Calculator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code snippet, you can see how to realize a PHP class suitable
    for `CalculatorClassInterface` interface, which involves implementing the following
    two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `compute` method is called on the object save, to store the calculated value
    in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getCalculatedValueForEditMode` method is invoked to display the value in
    the object edit modal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two functions are typically expected to return the same value, so it's
    a best practice to let one function return the value of the other one to avoid
    code duplication.
  prefs: []
  type: TYPE_NORMAL
- en: These functions take the object instance and the attribute context as input
    that contains useful information such as the `fieldname` attribute. For localized
    fields, the current language is defined in the `position` property of the context.
  prefs: []
  type: TYPE_NORMAL
- en: In this specific example, we first check whether the object is a product, which
    is the class for which we have set the **Calculated Value** attribute. Then, we
    check whether for each language all the localized fields are empty or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we will see how to implement a method needed
    to render the dynamic text label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous code snippet, the class is similar to the previously
    created one. To render the dynamic text label, the class must implement the `DynamicTextLabelInterface`
    interface. This interface presents the `renderLayoutText` method, which we must
    implement.
  prefs: []
  type: TYPE_NORMAL
- en: In the `renderLayoutText` method, we can return **HyperText Markup Language**
    (**HTML**) text that will be rendered in the label. In this specific example,
    we have realized a simple HTML table that shows whether the localized fields are
    completed for each language, using the previously created calculated value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see what these attributes look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2: Calculated values result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.02_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.2: Calculated values result'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, the dynamic text label shows the
    completeness status for each language, while the calculated value shows whether
    the selected language fields have been completed.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, you learned about the concept of **Master Data
    Management** (**MDM**), and how you can take advantage of Pimcore potentials to
    implement the data management processes, turning Pimcore into an MDM system. Later,
    you learned how to implement calculated values to realize data quality.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will learn how to activate the Pimcore Datahub
    bundle that you can use to expose Pimcore objects to third-party applications.
  prefs: []
  type: TYPE_NORMAL
- en: Activating the Pimcore Datahub bundle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned how to implement data management processes,
    such as the data quality process. These processes, the name of what? unclear,
    are key aspects of the MDM concept. Another fundamental feature for MDM systems
    is the possibility to expose entities to third-party applications and sites.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to activate the Pimcore **Datahub** bundle
    and how to configure that bundle properly. Later in this chapter, you will learn
    how to use this bundle to expose Pimcore objects and let external applications
    create new objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you learned in the *Installing a Bundle* section of [*Chapter 7*](B17073_07_ePub_RK.xhtml#_idTextAnchor129),
    *Administrating Pimcore Sites*, Pimcore bundles can be downloaded through the
    `composer` package manager; to download the Datahub bundle, you just need to follow
    these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a shell and point to the chapter folder of the book source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command to jump inside the Docker container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to download the Datahub bundle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the bundle is downloaded, it must be enabled and installed to be able
    to use it. You can do this through the **Tools** | **Bundles** menu, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3: Datahub Bundle Installation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.03_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.3: Datahub Bundle Installation'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, the Datahub bundle must first be
    enabled and then installed. The installation of the bundle will create additional
    tables inside the database structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'These operations can be accomplished alternatively through the following Bash
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Please note that running these commands is just an alternative to the operations
    made through the extension manager interface; only one method should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to install the Datahub bundle, let's see how to
    create Datahub configuration models.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Datahub configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you learned how to install and activate the Pimcore
    Datahub bundle. In this section, you will learn how to create configurations for
    Datahub. These configurations will govern how third-party applications can interact
    with Pimcore to retrieve, create, or update objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To open the Datahub configuration panel, just go through **Settings** | **Datahub
    Config** in the Pimcore menu. To create a new configuration, just follow the next
    instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Add Configuration** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the configuration name inside the window that appears.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **OK** button to confirm the creation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see a representation of the previous instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4: Creating a Datahub configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.04_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.4: Creating a Datahub configuration'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, once the configuration is created
    it is visible in the left-side menu. If you click on the created configuration,
    the configuration will open in the edit mode. The setup of the configuration can
    be made through three different panels, as we are about to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **General** panel contains general information about the configuration,
    such as the configuration name. We can see what this panel looks like in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5: General panel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.05_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.5: General panel'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now describe each property that we see in the preceding screenshot,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Active**: If enabled, the configuration is active and can be exposed to external
    applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type**: The configuration type. In the current version, only the GraphQL
    typology exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name**: The configuration name, defined during the configuration creation.
    This may not be changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: This lets you write a textual description for the configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQL Condition**: In this property, you can add a **Structured Query Language**
    (**SQL**) condition that will be used to do a pre-filtering of all the queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the **Schema Definition** panel, we can define which classes are enabled
    for queries and mutations. We can see what this panel looks like in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6: Schema Definition panel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.06_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.6: Schema Definition panel'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now describe each property that we see in the preceding screenshot,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Query Schema**: In this section, we can select one or more classes, with
    objects that will be available for queries. For each selected class, it''s possible
    to define which attributes must be exposed in queries. We will see this concept
    in the *Exposing entities* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutation Schema**: Similar to the **Query Schema** section, in this section
    we can select classes that could be available for mutation queries. For each class,
    we can define whether objects can be created, updated, and deleted. We will see
    more on mutation queries later in this chapter, in the *Using mutation queries*
    section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generic Types**: Here, we can define whether assets, documents, and folders
    must be exposed for queries and mutations. For example, if we enable the **Read**
    option for object folders, we can retrieve all the objects that are contained
    in one folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the **Security Definition** panel, we can manage authentication rules and
    restrict the visibility of entities to specific folders. We can see what this
    panel looks like in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7: Security Definition panel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.07_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.7: Security Definition panel'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now describe each property that we see in the preceding screenshot,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Method**: The authentication method. In the current version, only authentication
    through an **Application Programming Interface** (**API**) key is available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Datahub API Key**: The API key that will be required for authentication.
    This can be generated by clicking on the lightning bolt icon on the right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Skip Permission Check**: If enabled, the check for mandatory fields'' completeness
    is skipped when performing a mutation query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Workspaces**: In this section, we must specify specific **Documents**, **Assets**,
    and **Objects** folders to which we want to expose queries and mutations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have completed the configuration, click on the **Save** button to apply
    the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the configuration is saved, queries can be tested in two different ways,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Through an integrated `Iframe`), which could be opened in a new panel in the
    Pimcore interface by clicking the **Open** in **Iframe** button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a new browser tab, which could be opened by clicking the **Open in Tab**
    button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For third-party applications, queries can be made by performing **HyperText
    Transfer Protocol** (**HTTP**) calls to the following endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the previous endpoint, you can see that the configuration name and the API
    key are variables, so you must substitute the placeholders with the values defined
    in the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the defined configurations are stored in a `var/config/Datahub-configurations.php`
    file. If you want to share the same configuration between different environments,
    you can commit this file in the code base and rebuild the Datahub configurations
    running the following Bash command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To summarize, in this section, you have learned how to download and activate
    the Pimcore Datahub bundle and how to create a configuration for that bundle.
    In the following section, you will learn how to expose entities and how to perform
    queries on Datahub, testing them through the integrated Iframe.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned how to activate a Datahub bundle and how
    to create a new configuration. In this section, you will learn how to set up the
    configuration to expose entities and how to perform queries on Datahub.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the previous section, in the **Schema Definition** panel
    of the Datahub configurations, we must select which classes should be available
    for queries, and add them in the **Query Schema** section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each class, we must define which fields can be exposed for queries. This
    can be done by clicking on the **Settings** icon for each added class. In the
    following screenshot, you can see how to select the fields to expose:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8: Query Schema fields'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.08_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.8: Query Schema fields'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, on the left side you can find a list
    of the class fields. If you double-click one of these fields or drag and drop
    a field on the right column, that field will be exposed and will be available
    for queries. Once you have selected all the fields you want to expose, just click
    on the **Apply** button to confirm your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have learned how to configure a query schema, in the following section,
    you will see how to perform GraphQL queries on Datahub.
  prefs: []
  type: TYPE_NORMAL
- en: Performing GraphQL queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you learned how to expose classes and fields to let
    them be queryable. In this section, you will learn how to perform queries for
    your created configurations, seeing some query examples.
  prefs: []
  type: TYPE_NORMAL
- en: As we previously mentioned in the *Creating a Datahub configuration* section,
    the only supported configuration type is GraphQL. GraphQL is a query language
    for building APIs and a tool for serving these APIs with real data. GraphQL provides
    a complete and understandable description of your API data, giving clients the
    power to request only what they need and nothing else. This allows easy integration
    with external software and allows you to easily maintain and evolve the APIs over
    time.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL queries always return a predictable result, and therefore applications
    that use GraphQL are fast and reliable because they are in control of the data
    they require, not the server.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL queries, in addition to accessing the data of a resource, can follow
    references with other entities. This eventually allows you to retrieve all the
    data needed by an application in a single call, unlike a typical **REpresentational
    State Transfer** (**REST**) API, which typically requires multiple calls to get
    data.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL APIs are therefore organized in terms of types and not endpoints; all
    data can be accessed with a single endpoint and the use of types ensures that
    external applications can only request what is allowed, which allows you to provide
    clear and useful error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have introduced what GraphQL is, let''s have a look at the Pimcore
    Datahub Iframe environment. In the following screenshot, you can see what this
    environment looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9: Datahub Iframe Environment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.09_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.9: Datahub Iframe Environment'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, the Iframe is divided into two panels.
    In the left panel, we can write a query that we want to run, while in the right
    panel, the query results are shown. As you can see, in the left panel, suggestions
    are shown when we write field names, giving the possibility to have auto-completeness.
    Once a query is ready, you can run it by clicking the **Play** button.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to perform queries, let's have a look at some query
    examples that cover the various field types.
  prefs: []
  type: TYPE_NORMAL
- en: Getting an Object Listing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, you will learn how to perform object listing. In the following
    code snippet, you can see how a listing query is formed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the previous code snippet, the query statement is composed
    of a `get` prefix, the class name, and a `Listing` suffix. The listing function
    has the following input attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`first`: The number of results to retrieve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`after`: The number of objects to skip. Combined with the previous parameter,
    this can be used to perform pagination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ids`: A list of the **identifiers** (**IDs**) of objects to retrieve. If omitted,
    all products that respect the other filters are retrieved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fullpaths`: Similarly to the previous property, we can specify the paths of
    the objects to retrieve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter`: One or more composed filters that will be applied to filter the objects
    to retrieve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`published`: Specify whether the query must include unpublished objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultLanguage`: Specify the default language for localized fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sortBy`: The field to sort the results by.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sortOrder`: The sorting order for the specified field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The query content consists of an `edges` component, in which you can specify
    a list of fields to retrieve for each `node`, and a `totalCount` component, which
    always retrieves the total number of results despite the current page parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In the following examples, we will see how to retrieve a single object and how
    to retrieve values for different kinds of fields.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a single object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, we will see how to retrieve a single object. You can see how
    to perform this query in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous code snippet, the query statement is composed
    of the `get` prefix and the class name. In the query function, we must define
    the object `id` or the object `fullpath`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can optionally define the default language for localized fields. In
    the query content, you can see that for localized fields we can define a different
    language despite the default one.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you can also see how to query for `QuantityValue` fields. As
    you can see in the previous code snippet, you can require the field value, the
    unit of measure, and the composition of value and unit by the `toString` property.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, you will learn how to retrieve details of object relations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting relation details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following code snippet, you can see how to get details for standard
    relations and advanced relations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous code snippet, for standard relations, as category
    one, we must specify the related class. In GraphQL syntax, this can be made by
    adding three dots, followed by the `on object_` keyword and the class name. For
    the related class, you can specify the fields to retrieve.
  prefs: []
  type: TYPE_NORMAL
- en: For advanced relations, in the `element` component, you can specify the fields
    to retrieve for the related object, while in the `metadata` component, you can
    retrieve the name and the value for each relation metadata.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, you will learn how to retrieve values for Fieldcollections
    and how to require image details.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Image Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, we will see how the same syntax can be used for **Fieldcollections**,
    and you will learn how to retrieve image details. In the following code snippet,
    you can see how to perform this kind of query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous code snippet, the syntax is quite similar to
    the previous one that we have seen for object relations. For each image, we can
    require image details such as filename and file size, but we also can get Base64
    image content by the `data` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Object Variants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, you will learn how to get object variants. In the following
    code snippet, you can see how to get object children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous code snippet, you can retrieve the object variants
    using the `getChildren` function. To get variants, you must specify that you require
    them by using the `objectTypes` property.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, you learned how to expose entities for Datahub
    configurations. After having seen what an integrated Iframe looks like, through
    some query examples you learned how to perform queries to retrieve object listing
    and details for different kinds of attributes.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will learn how to perform mutation queries to
    create, update, and delete objects.
  prefs: []
  type: TYPE_NORMAL
- en: Using mutation queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned how to expose entities for Datahub configurations
    and how to perform queries to retrieve object data. In this section, you will
    learn how to expose entities for mutations and how to perform queries to create,
    update, and delete objects.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the *Activating the Pimcore Datahub bundle* section, in the
    **Schema Definition** panel of Datahub configurations, we must select which classes
    should be available for mutations and add them to the **Mutation Schema** section.
  prefs: []
  type: TYPE_NORMAL
- en: As we did for classes in the **Query Schema** section, we can define which fields
    can be exposed for mutation queries by clicking on the **Settings** icon for each
    added class. Besides, for each class, we can decide whether we want to make it
    available for creation, update, or deletion.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this section, we will learn how to perform mutation queries for creating,
    updating, and deleting objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, you will learn how to perform a mutation query to create a
    new object. In the following code snippet, you will see the query syntax for mutation
    queries, and a specific one that creates a new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous snippet, all mutation queries must start with
    the `mutation` keyword. Then, the query function is composed of the desired operation
    as a prefix, which is one of `create`, `update`, or `delete`, followed by the
    name of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the function arguments, you can specify the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`key`: The key of the object. This will be shown in the object tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: The path in which the object is created. This could be a folder or
    a parent product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parentId`: This can be used as an alternative to the `path` argument to define
    the parent folder or object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`published`: If `false`, a product is created in the unpublished status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`omitMandatoryCheck`: If `true`, an object is created even if all the mandatory
    fields are not filled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: We can specify if a created object must be an object or a variant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input`: In this attribute, we can specify the field values for an object that
    we want to create.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The query content consists of three components, outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`success`: A Boolean flag that will be `true` if the query runs successfully
    and `false` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message`: A successful message if the query runs successfully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output`: If an object is created successfully, this will show the object fields
    requested in the query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running the previously defined query will return the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous code snippet, if the object is created correctly,
    the object `id` is returned. This can be used to perform queries to update or
    delete an object.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to create a new object, let's see how to perform a
    query to update a previously created object.
  prefs: []
  type: TYPE_NORMAL
- en: Updating objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you learned how to create new objects using mutation
    queries. In this section, you will learn how to update previously created objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, you can see the syntax for an update mutation
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous code snippet, the mutation query function starts
    with the `update` keyword. The object `id` must be passed as a function argument,
    and an error message will be returned if an object with the provided `id` does
    not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how to update a previously created object, let's see how
    to perform a query to delete that object.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you learned how to update objects using mutation queries.
    In this section, you will learn how to delete an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, you can see the syntax for a delete mutation
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous code snippet, the mutation query function starts
    with the `delete` keyword. The object `id` must be passed as a function argument,
    and an error message will be returned if an object with the provided `id` does
    not exist.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, you learned the syntax of mutation queries. In
    particular, we have seen how to create, update, and delete objects through specific
    queries. In the following section, you will learn how to create a custom mutation
    query function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom mutation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned how to use mutation queries to create,
    update, and delete objects. These kinds of queries work well for simple scenarios
    but present some limitations in terms of the kinds of attributes that we can update
    or for the interdependence of multiple attributes. For example, on standard mutation
    queries, the `QuantityValue` fields cannot be filled.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to create a custom mutation function and
    how to use that to update values that cannot be updated through standard mutation
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: To create a new custom mutation function, we need to add a function definition
    to the Datahub configuration schema. This can be made by implementing a listener
    for the `pimcore.Datahub.graphql.mutation.preBuild` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 12*](B17073_12_ePub_RK.xhtml#_idTextAnchor211), *Implementing
    Product Information Management*, you learned how to implement an **EventListener**.
    In the following code snippet, you will see an example that will show how to implement
    a listener that will affect the Datahub configuration schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, we have implemented a simple function that will
    set the product price. As you can see in the example, the listener function has
    an input argument of type `MutationTypeEvent`. That event variable has a `config`
    property that contains the Datahub configuration schema. To add a new mutation
    function, we must add a new operation to this configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to create an object of type `InputObjectType`. This object
    must contain a `fields` property, which has to be an array that must define the
    name and the type for each property that must be filled in the `input` argument
    of the mutation query function.
  prefs: []
  type: TYPE_NORMAL
- en: We must then create an array that will define a new operation. This array must
    contain the operation arguments, such as the object `id` and the previously defined
    `input` argument, and must define a `resolve` function that, in our case, will
    set up the product price given the price value and unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have defined this operation, you must add that to the configuration
    attribute. As a result, the created function will be selectable in the Iframe,
    as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10: Custom Mutation Query'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.10_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.10: Custom Mutation Query'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, in the left panel you can select
    the previously defined function and fill in the value and the unit for the product
    price. In the right panel, you can see the result message that was defined for
    the mutation query.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, you learned how to create a custom mutation query.
    This can be useful to set up object attributes for complex scenarios. As an example,
    you learned how to implement an event listener to create a custom mutation query
    that will set the product price.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to define custom reports to create tabular
    or chart reports with filtering and export functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Defining custom reports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Custom Reports** is a report engine that is integrated directly into Pimcore.
    These reports are based on direct SQL queries on the database, and it''s possible
    to render them both as tables and charts. To define or generate a new custom report,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To create a new report, go to the **Marketing** menu and click on the **Custom
    Reports** menu option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, click on the **Add** button and insert the report name. After having
    created the report, you can start configuring it. In the following screenshot,
    you can see how to set up a report''s general settings:![Figure 13.11: General
    settings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_13.11_B17073.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.11: General settings'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, the report **Name** is the one that
    was inserted before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, add a user-friendly label and eventually group the reports in folders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create Shortcut in Menu** checkbox, and the report will be directly
    available in the **Marketing** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After having configured the general settings, the next step is to configure
    the data source. This can be done by directly defining an SQL query, as you can
    see in the following screenshot:![Figure 13.12: Source definition'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_13.12_B17073.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.12: Source definition'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, you can add a direct SQL query as
    a source definition. This gives you the possibility to design complex scenarios
    but requires advanced knowledge of the database structure. In this specific example,
    we want to count the number of products per category.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After having defined a data source, define how to render data. You can see
    how to manage the column configuration in the following screenshot:![Figure 13.13:
    Managing the Column Configuration'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_13.13_B17073.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.13: Managing the Column Configuration'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, if a query is well formed, the columns
    are automatically detected. For each column, we can specify whether the column
    must be shown in the report and whether the column can be exported and sorted.
    Then, we can also define whether each column can be filterable, along with the
    filter type to apply, and then specify the width and the label for them. If a
    column contains an object `id`, we can also specify an **Open Object** action.
    As we will see in the next step, this will add a button that lets you open the
    corresponding object by the report table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After having defined the column configuration, you can define the chart type,
    choosing from **Pie Chart**, **Bar Chart**, and **Line Chart**. For pie charts,
    you must then specify which column must be used to define the values list, and
    which one contains the data count.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the configuration is completed, go to the **Marketing** | **Reports**
    menu to see how the report is rendered. You can see what a defined example looks
    like in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.14: Report Visualization'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.14_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.14: Report Visualization'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, the report is shown as a pie chart
    as we defined, with categories' names, a list of the different values, and a count
    of the products that form the pie slices.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom, you can see the report in a tabular version. In particular, you
    can see the **Open** button, which lets you open the linked category object. If
    you don't specify a chart type, only the tabular version is shown. The report
    table can be exported in a **comma-separated values** (**CSV**) file.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, you learned how to configure and render reports
    using the **Custom Reports** engine. Starting from the general settings, you learned
    how to configure a data source and how to properly render data in the report.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the concept of Master Data Management and how to
    expose Pimcore objects to third-party applications using the Datahub Pimcore bundle.
  prefs: []
  type: TYPE_NORMAL
- en: After having defined that concept, you have seen an example of how to implement
    the concept of data quality, which is a key feature of MDM systems.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the chapter, you learned how to activate a Datahub Pimcore Bundle and
    how to create a configuration for that bundle, and how to set up the configuration
    to expose objects and other entities with external applications.
  prefs: []
  type: TYPE_NORMAL
- en: After having introduced the GraphQL query language, you learned how to perform
    queries to retrieve object data through some query examples, as well as how to
    create, update, and delete objects through mutation queries. Then, you learned
    how to implement a custom mutation query function, which is useful for defining
    complex scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, you learned how to configure and render custom reports,
    which let you present and export the data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to perform Data Integration in Pimcore,
    with a specific focus on how to import and export objects and on when the standard
    functionalities are supposed to be used, and otherwise when they have limitations
    that make the implementation of a custom solution necessary.
  prefs: []
  type: TYPE_NORMAL
