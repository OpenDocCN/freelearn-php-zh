- en: Chapter 10. XML and JSON
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章：XML和JSON
- en: So far, we have been using HTML everywhere. It is the format for web pages,
    so we have used it to create static web pages. As a consequence, HTML is the format
    of the data that is exchanged between the server and the client during the page
    load of the **.html** file.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用HTML。它是网页的格式，因此我们用它来创建静态网页。因此，HTML是服务器和客户端在**.html**文件页面加载期间交换的数据的格式。
- en: When we create web pages dynamically, our PHP code will compose lines of HTML
    by the time data is sent across, which will be the true data that is exchanged,
    not the original content of your **.php** file. When we used Ajax, we did not
    specify a data format as a parameter in our jQuery Ajax methods, `.post()` or
    `.ajax()`, because it was implicitly understood that it would be HTML.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们动态创建网页时，我们的PHP代码会在数据发送时组合HTML行，这将是我们真正交换的数据，而不是你**.php**文件的原始内容。当我们使用Ajax时，我们没有在我们的jQuery
    Ajax方法`.post()`或`.ajax()`中指定数据格式作为参数，因为这被隐含地理解为将是HTML。
- en: In this chapter, we introduce two different data formats, XML and JSON. In web
    development, we can use them in different ways. First, they can be an alternative
    to your database. For simple projects, your data can be stored in a text file,
    rather than in a full blown database. You could even store it as plain text.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了两种不同的数据格式，XML和JSON。在网络开发中，我们可以以不同的方式使用它们。首先，它们可以成为你数据库的替代品。对于简单的项目，你的数据可以存储在文本文件中，而不是完整的数据库中。你甚至可以将其存储为纯文本。
- en: The next, and better, level up would be to use an XML file or JSON for your
    data. They are plain text as well, but formatted in a special way. Data stored
    in that format can be easily converted to HTML, bringing us back to the previous
    scenario.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个，也是更好的水平，将是使用XML文件或JSON作为你的数据。它们同样是纯文本，但以特殊的方式格式化。以该格式存储的数据可以轻松转换为HTML，这使我们回到了之前的场景。
- en: On the other hand, we can first send the data to the client and then process
    it there to create the content of our pages. We will cover both scenarios in this
    chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以首先将数据发送到客户端，然后在客户端进行处理以创建我们页面的内容。在本章中，我们将涵盖这两种场景。
- en: XML
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML
- en: '**eXtensible Markup Language** (**XML**) is a format that has been widely adopted
    to exchange information between companies, documents, and programs. It has a notation
    similar to HTML, using tags. As a matter of fact, HTML is a special case of XML.
    With HTML, tags have meanings and are meant to be interpreted by a browser. In
    XML, tags can mean anything or nothing at all, but the rules are stricter. Of
    course, if you are the creator of the XML file, we hope that the tags have some
    meaning to you.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展标记语言** (**XML**) 是一种被广泛采用的格式，用于公司、文档和程序之间交换信息。它使用与HTML类似的标记符号。实际上，HTML是XML的一个特例。在HTML中，标签具有意义，并且旨在由浏览器进行解释。在XML中，标签可以代表任何东西，也可以什么都不代表，但规则更为严格。当然，如果你是XML文件的创建者，我们希望标签对你来说有一定的意义。'
- en: 'You, as a web developer, may never use XML, but it is important that you know
    that it exists. It has been created to be a data format that is both machine readable
    and human readable. Humans will be able to read the content that is inside, as
    XML files are basically text files; computer programs can read them because they
    are well structured. There are several areas where the XML format is applied.
    We only mention a few of them here:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名网络开发者，你可能永远不会使用XML，但了解它的存在很重要。它被创建成一种既适合机器读取又适合人类阅读的数据格式。人类将能够阅读其中的内容，因为XML文件基本上是文本文件；计算机程序可以读取它们，因为它们结构良好。XML格式在多个领域得到应用。我们在这里只提及其中的一些：
- en: '**Web services**: Some people or companies give access to information from
    their database by providing a web service. How to create web services is beyond
    the scope of this book. What web services typically offer you is the ability to
    go to a certain web address, with a query string indicating the kind of information
    you are seeking. The result of visiting this (virtual) site is an output stream
    in the XML format, which you can then process. We will teach you how to do the
    processing, not the creation of the service.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络服务**：有些人或公司通过提供网络服务来允许访问他们的数据库中的信息。如何创建网络服务超出了本书的范围。网络服务通常提供给你的能力是能够访问一个特定的网络地址，其中查询字符串表明你正在寻找的信息类型。访问这个（虚拟）网站的结果是XML格式的输出流，然后你可以对其进行处理。我们将教你如何进行处理，而不是创建服务。'
- en: '**Alternative to a database**: For simple applications, or parts thereof, using
    a full blown database might be overkill. As we have mentioned, you could use a
    plain text file or, as often occurs, a `.csv` file. It is far better to use an
    XML file for this, as it has more structure and it may well be the structure that
    the customer wants from you.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库的替代方案**：对于简单的应用程序或其部分，使用完整的数据库可能有些过度。正如我们提到的，你可以使用纯文本文件，或者更常见的是 `.csv`
    文件。使用 XML 文件来做这件事会更好，因为它有更多的结构，而且很可能正是客户想要的那个结构。'
- en: XML format
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML 格式
- en: 'The format of an XML file is actually quite simple. It is a text file than
    begins with a line like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: XML 文件的格式实际上非常简单。它是一个以类似以下行开始的文本文件：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This line mentions the version of XML, and so far this is only 1.0 or 1.1\.
    The rules are so simple that there is hardly room for changes and encoding. This
    is called the **XML declaration**. Everything that follows is the actual XML document,
    which consists of tags, or elements, a closing tag for each opening tag, and text
    in between them. Look at this first example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这行提到了 XML 的版本，到目前为止只有 1.0 或 1.1。规则如此简单，几乎没有空间进行更改和编码。这被称为**XML 声明**。随后的所有内容都是实际的
    XML 文档，它由标签或元素组成，每个开标签都有一个对应的闭标签，以及它们之间的文本。看看这个第一个例子：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can tell, there is a closing tag for each opening tag, and one tag, `<californiapeople>`
    appears first and only once. This is the **root**. Tags can have tags in between
    them, but they must be properly nested. I have given the first person tag an **attribute**
    and I have also included an **empty** tag there. Just like the `<br/>` tag in
    HTML, `<picture/>` is a shorthand notation for `<picture></picture>`. Such an
    element is called **self-closing**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个开标签都有一个对应的闭标签，并且有一个标签 `<californiapeople>` 首次出现且仅出现一次。这是**根标签**。标签之间可以有其他标签，但它们必须正确嵌套。我已经给第一个人的标签添加了一个**属性**，并且还包含了一个**空标签**。就像
    HTML 中的 `<br/>` 标签一样，`<picture/>` 是 `<picture></picture>` 的缩写表示。这样的元素被称为**自闭合元素**。
- en: Because I use XML from time to time, I have a habit of always using a closing
    tag in HTML files, even where it is not mandatory, for example in HTML5\. Other
    noticeable differences are that in an XML file, white space is not truncated and
    names of elements are case sensitive, so `<Person>` is not the same as `<person>`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我时不时地使用 XML，我养成了在 HTML 文件中始终使用闭标签的习惯，即使在不强制的情况下也是如此，例如在 HTML5 中。其他明显的区别是，在
    XML 文件中，空白不会截断，元素名称的大小写敏感，所以 `<Person>` 与 `<person>` 不同。
- en: 'Finally, as can be expected, there are a number of characters you cannot use
    inside the text of your XML file: `<` and `&`. XML is going to think it reached
    the beginning of an opening tag. If you need the `<` sign , use `&lt;` instead.
    You should remember this from when we discussed HTML entities a few chapters ago.
    Other entities used in XML are `&amp`, which solves the chicken and egg problem,
    that if `&lt;` means `<`, then using `&` by itself cannot be allowed either. `&gt;`,
    `&apos;`, and `&quot;` can be used as well, even though `>`, `''`, and `"` are
    legal characters. If you need them as part of your text, we recommend that you
    use the entities instead. Oh, by the way, did you notice that the syntax for comments
    is also the same as in HTML? There are more similarities, and we can even style
    an XML file!'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如预期的那样，有一些字符你不能在 XML 文件的文本中使用：`<` 和 `&`。XML 会认为它已经到达了开标签的开始。如果你需要 `<` 符号，请使用
    `&lt;` 代替。你应该记得我们在几章前讨论 HTML 实体时提到的这一点。XML 中使用的其他实体还有 `&amp`，它解决了“先有鸡还是先有蛋”的问题，即如果
    `&lt;` 表示 `<`，那么单独使用 `&` 也是不允许的。`&gt;`、`&apos;` 和 `&quot;` 也可以使用，尽管 `>`、`'` 和
    `"` 是合法字符。如果你需要它们作为文本的一部分，我们建议你使用实体。顺便说一句，你注意到注释的语法也与 HTML 相同吗？还有更多相似之处，我们甚至可以给
    XML 文件添加样式！
- en: Displaying XML files
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示 XML 文件
- en: The first time you look at an XML file, you may not see what you expect. The
    best way to display an XML file is to use a browser, and the browser will treat
    the file as it does HTML files; therefore, you will not see the tags, only the
    text in between them. This is another reason why I like to use Firefox as a browser.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次查看 XML 文件时，你可能看不到你期望的内容。显示 XML 文件的最佳方式是使用浏览器，浏览器会像处理 HTML 文件一样处理该文件；因此，你将看不到标签，只能看到它们之间的文本。这也是我喜欢使用
    Firefox 作为浏览器的原因之一。
- en: Firefox and Chrome display the entire XML file, including the tags. The tag
    names are in a different color and everything is nicely indented. Firefox will
    also check to see whether it is a well-formed XML file and, if it is not, produce
    a meaningful error message pointing you to the offending line in the file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox 和 Chrome 会显示整个 XML 文件，包括标签。标签名称以不同的颜色显示，并且所有内容都进行了适当的缩进。Firefox 还会检查它是否是一个格式良好的
    XML 文件，如果不是，会生成一个有意义的错误消息，指向文件中的问题行。
- en: 'Sometimes Firefox displays: "This XML file does not appear to have any style
    information associated with it. The document tree is shown below." Well, this
    Firefox message suggests that there can be a stylesheet for an XML file, does
    it not? Could that even be a CSS file? Yes it could. Just add the following line
    after the XML declaration:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有时 Firefox 会显示：“此 XML 文件似乎没有与之关联的任何样式信息。以下显示文档树。”嗯，这个 Firefox 消息暗示了 XML 文件可能有样式表，不是吗？那甚至可能是一个
    CSS 文件吗？是的，可以。只需在 XML 声明之后添加以下行：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then, create a CSS file with the following content. Firefox will now display
    only the contents of your file, not the tags, using some funky colors. Later in
    this chapter, you will learn that there can be other style sheets that are not
    CSS files.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个包含以下内容的 CSS 文件。现在，Firefox 将仅显示您文件的正文，而不是标签，并使用一些奇特的颜色。在本章的后面部分，您将了解到可能存在其他不是
    CSS 文件的样式表。
- en: 'Due to the nature of XML, all the code examples that follow are rather long.
    You may want to consider going to the online pages for this book on Packt Publishing''s
    website and picking them up there:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 XML 的特性，以下的所有代码示例都相当长。您可能需要考虑访问 Packt Publishing 网站上本书的在线页面，并在那里获取它们：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: XML editors
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML 编辑器
- en: As XML files are text files, you can use any text editor to create and edit
    them. **Textastic** is a fantastic editor that only costs a few bucks, which I
    like using, and there is a version for MacOS, as well as iOS. **Dreamweaver**
    users will benefit from its feature of validating XML files for the correct syntax.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 XML 文件是文本文件，你可以使用任何文本编辑器来创建和编辑它们。**Textastic**是一个出色的编辑器，只需花费几美元，我很喜欢使用，同时也有适用于
    MacOS 和 iOS 的版本。**Dreamweaver**用户将受益于其验证 XML 文件正确语法的功能。
- en: However, in the world of XML, validation can be done beyond simple syntax.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 XML 的世界里，验证可以超越简单的语法。
- en: XML Schema
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML Schema
- en: Imagine you are working with several customers that need to provide you with
    data, employee records, for example, and you request that they do so using XML
    as the format. You have just requested yourself a big mess! As data comes in,
    you realize that one customer used the element `<name>` for the last name, whereas
    another one decided to go with `<last>`. Not only that, they probably used a different
    order and mix of things.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在与几个需要向您提供数据的客户合作，例如员工记录，您要求他们使用 XML 格式来这样做。您已经给自己找了一个大麻烦！随着数据的到来，您意识到一个客户使用了`<name>`元素来表示姓氏，而另一个客户则决定使用`<last>`。不仅如此，他们可能使用了不同的顺序和组合。
- en: What you should have done first was to give them a definition of how you wanted
    the XML file to look. Then, you could have already started to write your application
    that will process the data before you even received that data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先应该做的是给出您希望 XML 文件看起来是什么样的定义。然后，您就可以开始编写应用程序，在您收到数据之前处理这些数据。
- en: There are several conventions used to define the structure of an XML file. One
    is called **Document Type Definition** (**DTD**) and another one is **XML Schema**.
    The nice thing about the XML Schema format is that the file that describes the
    structure of your XML file is also an XML file. Teaching you about either method
    is beyond the scope of this book. A few examples of XML Schema files are provided
    however.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义 XML 文件结构时，使用了几个约定。其中一个被称为**文档类型定义**（**DTD**），另一个则是**XML 模式**。XML 模式格式的优点在于，描述你的
    XML 文件结构的文件本身也是一个 XML 文件。本书的范围不包括介绍这两种方法。不过，这里提供了一些 XML 模式文件的示例。
- en: 'As a start, here is the XML Schema definition for XML files that are structured
    like the one in our previous example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开始，这里是我们之前示例中结构相似的 XML 模式定义：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can probably decipher, this is a description of all the elements that
    can be inside the XML file, which attributes they can have, in which order they
    should occur, and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经推断出的，这是对 XML 文件中可以包含的所有元素的描述，它们可以有哪些属性，它们应该以何种顺序出现，等等。
- en: SimpleXML
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SimpleXML
- en: Assume we have an XML file on the server containing data that we want to use
    to dynamically generate a web page, as was done previously by extracting the data
    from a MySQL database in a PHP program. How can this be done?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在服务器上有一个包含我们想要用于动态生成网页的数据的 XML 文件，就像之前在 PHP 程序中从 MySQL 数据库中提取数据一样。这该如何实现？
- en: There are several ways. In this example, **SimpleXML** is used. It consists
    of a few PHP classes with several methods to process existing XML files, or create
    new ones. The following example is taken from an older version of my website,
    which contains many galleries of photographs. The information about the photographs
    was stored in an XML file, one for each gallery. Each time a photograph had to
    be added to the site, all that needed to be done was to add a `node` to the appropriate
    XML file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法。在这个例子中，使用了 **SimpleXML**。它由几个 PHP 类组成，具有处理现有 XML 文件或创建新文件的方法。以下示例取自我的网站的一个旧版本，其中包含许多照片画廊。照片信息存储在一个
    XML 文件中，每个画廊一个。每次需要将照片添加到网站上时，只需向适当的 XML 文件中添加一个 `node` 即可。
- en: I have abbreviated the text inside the XML file, otherwise this part of the
    chapter would have turned into a travel guide.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经简化了 XML 文件内的文本，否则这部分章节就会变成一本旅行指南。
- en: The XML file
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这是 XML 文件
- en: 'Use your favorite editor and create `practical.xml`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你喜欢的编辑器创建 `practical.xml`：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The XML Schema file
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XML 架构文件
- en: 'This is the XML Schema file `photocollection.xs`, in case you are interested
    what it will look like:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 XML 架构文件 `photocollection.xs`，如果你对它的样子感兴趣的话：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The CSS file
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSS 文件
- en: 'This is `practical.css`, the style sheet for the HTML that will be generated
    from the XML file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `practical.css`，用于从 XML 文件生成的 HTML 的样式表：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The PHP file
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP 文件
- en: 'This is the PHP file to generate the HTML of a small picture gallery with as
    many photographs as there are referenced in the XML:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成包含与 XML 中引用的照片数量一样多的照片的小图片画廊的 HTML 的 PHP 文件：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As the name suggests, SimpleXML is simple to use. `simplexml_load_file()` returns
    an object that contains the entire XML tree of the file that is passed as an argument.
    There is a companion method, called `simplexml_load_string()`, which takes a string
    that contains XML as argument. Every element inside this tree can be accessed
    using a simple syntax.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，SimpleXML 使用简单。`simplexml_load_file()` 函数返回一个包含传递给参数的文件整个 XML 树的对象。还有一个配套的方法，称为
    `simplexml_load_string()`，它接受一个包含 XML 的字符串作为参数。这个树中的每个元素都可以使用简单的语法进行访问。
- en: To access the collection of all photo nodes, the **xpath()** method was used.
    It supports the syntax of XPath, a query language for XML files. All you need
    to remember here is the meaning of `//photo`. It gives us all photo nodes back,
    even if they are not in the top level of the tree.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问所有照片节点集合，使用了 **xpath()** 方法。它支持 XPath 语法，这是一种用于 XML 文件的查询语言。你在这里需要记住的是 `//photo`
    的含义。它返回所有照片节点，即使它们不在树的顶层。
- en: Creating XML files with SimpleXML
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SimpleXML 创建 XML 文件
- en: You can also use SimpleXML to create XML files from within a program. You start
    with the root element as a string, and then build up your XML file by adding nodes
    using the `addChild()` method, which takes one or two arguments. The first one
    is the name of the node, and the optional second one, its value. When you are
    all done, you finish it off with the `asXML()` method, which will return a string
    containing all the XML, or store it into a file if you give it an argument. In
    the example that follows, we call it `xmlfiles/new.xml`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 SimpleXML 在程序内部创建 XML 文件。你从一个字符串形式的根元素开始，然后通过使用 `addChild()` 方法添加节点来构建你的
    XML 文件，该方法接受一个或两个参数。第一个是节点的名称，可选的第二个参数是它的值。当你完成所有操作后，使用 `asXML()` 方法结束，它将返回包含所有
    XML 的字符串，或者如果你提供了参数，它会将其存储到文件中。在下面的示例中，我们将其称为 `xmlfiles/new.xml`。
- en: 'To conclude this section on SimpleXML, here is a tiny program that recreates
    our XML file, but with only one photo node, and saves it as `xmlfiles/new.xml`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结 SimpleXML 这一部分，这里有一个小程序，它重新创建我们的 XML 文件，但只包含一个照片节点，并将其保存为 `xmlfiles/new.xml`：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Generating our HTML on the client side
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在客户端生成我们的 HTML
- en: It is not necessary to always generate the final HTML on the server and then
    send it to the client when we use XML or JSON as the data format and use Ajax
    calls. As more and more powerful devices are used to access the web and run a
    browser inside them, generating the HTML code might as well be done inside the
    client.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 XML 或 JSON 作为数据格式并使用 Ajax 调用时不一定需要始终在服务器上生成最终的 HTML 并将其发送到客户端。随着越来越多的强大设备被用来访问网络并在其中运行浏览器，生成
    HTML 代码也可以在客户端完成。
- en: We could use the `.post()` jQuery Ajax call and execute a PHP program, with
    SimpleXML, to pass the entire XML file as a string and then process it. Even that
    part is not necessary because the jQuery Ajax methods know what XML and JSON are
    all about. We can simply specify the path of the XML file to the `.ajax()` method,
    and jQuery will take care of the rest. This is a great candidate to use the `.get()`
    method, as we only have to retrieve data, our XML, from the server, and not send
    any data to it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `.post()` jQuery Ajax 调用来执行 PHP 程序，使用 SimpleXML 将整个 XML 文件作为字符串传递，然后进行处理。即使这部分也不是必需的，因为
    jQuery Ajax 方法已经知道 XML 和 JSON 是什么。我们只需将 XML 文件的路径指定给 `.ajax()` 方法，jQuery 就会处理剩下的部分。这是一个非常适合使用
    `.get()` 方法的例子，因为我们只需要从服务器检索数据，即我们的 XML，而不需要向其发送任何数据。
- en: 'The following example will generate the exact same photo gallery but it is
    all done with Ajax and JavaScript, no PHP code is involved. The HTML file is:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将生成完全相同的相册，但它全部是通过 Ajax 和 JavaScript 实现的，没有涉及任何 PHP 代码。HTML 文件如下：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The JavaScript file is:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 文件如下：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: XSLT
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XSLT
- en: Hang on in there just a little longer. JSON is just around the corner. Only
    one more XML technology to add to our arsenal!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 稍等一下。JSON 就在眼前。只需再添加一种 XML 技术，就可以充实我们的工具库！
- en: 'Imagine two banks that create a lot of data, as banks do. Both banks use XML,
    and both have crafted an XML Schema file so that the formats of the XML files
    are extremely well defined. Now, imagine that one bank acquires the other one
    and inherits all that data that is in the other XML format: this is a disaster
    in the making. Not to worry, XSLT to the rescue!'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 想象两家银行，它们像银行一样产生大量数据。两家银行都使用 XML，并且都制作了一个 XML Schema 文件，以确保 XML 文件的格式定义得非常严格。现在，想象一家银行收购了另一家，并继承了所有其他
    XML 格式的数据：这正在酝酿一场灾难。不用担心，XSLT 来拯救！
- en: '**eXtensible Stylesheet Language Transformation** (**XSLT**) is a language
    that can be used to translate an XML file into another XML file. What is required
    is an XSLT engine and an XSL file, which describes how the one file has to be
    transformed into the other. All kinds of calculations can occur in the process
    of transforming as it is a full blown programming language. The thickest book
    I have on a single web development topic is an XSLT guide.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展样式表语言转换**（**XSLT**）是一种可以将 XML 文件转换为另一个 XML 文件的编程语言。所需的是一个 XSLT 引擎和一个 XSL
    文件，该文件描述了如何将一个文件转换成另一个文件。在转换过程中可以发生各种计算，因为它是一个完整的编程语言。我关于单一网络开发主题最厚的书是一本 XSLT
    指南。'
- en: 'XSL files are referred to as stylesheets. They are not CSS files, but the term
    stylesheet is not misplaced at all. If we take an XML file and transform it to
    an HTML file, then we actually created a view for the XML file that goes beyond
    what we can do with only a CSS file. Rather than creating an XSL file for the
    `california.xml` example, here is an XSL stylesheet that translates the `practical.xml`
    file into the exact same HTML as the SimpleXML example. If you analyze what is
    inside, you could dissect it into three parts: which parts of the file to apply
    a rule (template) to, what the rules are, and inside all that, plain HTML.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: XSL 文件被称为样式表。它们不是 CSS 文件，但“样式表”这个术语一点也不错。如果我们将一个 XML 文件转换成 HTML 文件，那么我们实际上为
    XML 文件创建了一个视图，这超出了仅使用 CSS 文件所能做到的。而不是为 `california.xml` 示例创建一个 XSL 文件，这里有一个将 `practical.xml`
    文件转换为与 SimpleXML 示例完全相同的 HTML 的 XSL 样式表。如果你分析其内部内容，你可以将其分解为三个部分：哪些文件部分要应用规则（模板），规则是什么，以及所有这些规则中，纯
    HTML。
- en: 'Here is an XSLT example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 XSLT 示例：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is the PHP file to handle the transformation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理转换的 PHP 文件：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: JSON
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: '**JavaScript Object Notation** (**JSON**) is the other data interchange format
    discussed in this chapter. Like XML, it is text-based and human readable, but
    it also more lightweight than its counterpart. Data sent in the JSON format will
    take up a lot less bandwidth when data is sent over a network connection. It is
    used more and more in web applications today. XML files are heavier - just notice
    how many pages we needed to provide some examples, and requires a parser of some
    sort to process the data.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript 对象表示法**（**JSON**）是本章讨论的另一种数据交换格式。像 XML 一样，它是基于文本的，可读性强，但它比其对应物更轻量。以
    JSON 格式发送的数据在网络连接中传输时将占用更少的带宽。它在当今的 Web 应用程序中越来越受欢迎。XML 文件更重——只需注意我们提供了多少页的例子，并且需要某种类型的解析器来处理数据。'
- en: 'JSON is derived from JavaScript, and JSON code looks a lot like JavaScript
    objects, but there are subtle differences. However, JavaScript can be used to
    process JSON data, so you would not need a separate parser, as is the case with
    XML. Here is the same data from the `california.xml` example, but in the JSON
    format:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 是从 JavaScript 衍生出来的，JSON 代码看起来很像 JavaScript 对象，但也有一些细微的差别。然而，JavaScript
    可以用来处理 JSON 数据，所以你不需要一个单独的解析器，就像处理 XML 那样。这里是从 `california.xml` 示例中相同的资料，但以 JSON
    格式呈现：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice first of all how much easier to read this is compared to its XML counterpart.
    It looks like an array of JavaScript objects containing key:value pairs, and that
    is almost what this is. In the discussion on objects in [Chapter 4](ch04.html
    "Chapter 4. JavaScript"), *JavaScript*, we had an example with the name of John
    Williams in it, and a hint to the JSON format. The key difference (*key* being
    a key word here) is that, in JSON, the keys also have to be surrounded by double
    quotes. So, in the land of JSON, `name:"Williams"` would be incorrect. Let's go
    over the simple structure of the JSON data format. You may want to take a piece
    of paper and draw a little diagram for each rule.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，与它的 XML 对应物相比，这要容易阅读得多。它看起来像是一个包含键：值对的 JavaScript 对象数组，这几乎就是它所代表的。在
    [第 4 章](ch04.html "第 4 章。JavaScript") 中关于对象的讨论中，我们有一个包含 John Williams 名字的例子，以及对
    JSON 格式的提示。关键的区别（这里的 *key* 是一个关键词）是，在 JSON 中，键也必须被双引号包围。所以，在 JSON 的领域中，`name:"Williams"`
    是不正确的。让我们回顾一下 JSON 数据格式的简单结构。你可能想要拿一张纸，为每条规则画一个小图。
- en: JSON syntax
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON 语法
- en: 'JSON data is plain text. JSON text consists of a sequence of characters that
    is encoded in Unicode and that conforms to the **JSON value syntax**. So, simply
    said, every piece of JSON data has to be a valid JSON value. There are six tokens
    that have a special meaning in JSON: `[`, `{`, `]`, `}` , `:`, and`,`. There are
    also three name tokens that have a special meaning to JSON: `true`, `false`, and
    `null`. These tokens are use to compose correct JSON values.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 数据是纯文本。JSON 文本由一系列字符组成，这些字符以 Unicode 编码，并符合 **JSON 值语法**。所以简单地说，每条 JSON
    数据都必须是一个有效的 JSON 值。在 JSON 中有六个具有特殊意义的令牌：`[`、`{`、`]`、`}`、`:` 和 `,`。还有三个具有特殊意义的名称令牌：`true`、`false`
    和 `null`。这些令牌用于组成正确的 JSON 值。
- en: JSON values
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON 值
- en: A JSON **value** can be an object, array, number, or string or one of true,
    false, or null. These are the building blocks of well-formatted JSON data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 JSON **值** 可以是一个对象、数组、数字或字符串，或者是 true、false 或 null 之一。这些都是格式良好的 JSON 数据的构建块。
- en: JSON objects
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON 对象
- en: A JSON **object** begins with a left curly brace and ends with a right curly
    brace. Inside, there will be zero or more key:value pairs, separated by commas.
    The key or name is a JSON string. There is a semicolon in between the key and
    the value. The value itself can be any valid JSON value.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 JSON **对象** 以左花括号开始，以右花括号结束。在其内部，将有零个或多个由逗号分隔的键：值对。键或名称是一个 JSON 字符串。键和值之间有一个分号。值本身可以是任何有效的
    JSON 值。
- en: JSON strings
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON 字符串
- en: A JSON **string** begins and ends with double quotes. Single quotes cannot be
    used to delimit strings. However, you could have a single quote in the middle
    of a string. If you need a double quote, you will have to escape it with a backslash
    ( `\` ). Other two-character escape sequences are, inevitably, `\\`, `\/`, `\b`,
    `\f`, `\n`, `\r`, and `\t`. You can also use a 4-digit Unicode code of any character
    by having it preceded by `\u`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 JSON **字符串** 以双引号开始和结束。不能使用单引号来界定字符串。然而，字符串中间可以有一个单引号。如果需要双引号，你必须用反斜杠（`\`）转义它。其他两个字符的转义序列不可避免地是
    `\\`、`\/`、`\b`、`\f`、`\n`、`\r` 和 `\t`。你也可以使用任何字符的 4 位 Unicode 码，只需在该字符前加上 `\u`。
- en: JSON arrays
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON 数组
- en: A JSON **array** is a pair of square brackets surrounding zero or more values,
    separated by a comma. The example seen previously is actually a JSON array that
    contains four JSON objects, in turn containing four key:value pairs each.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 的 **数组** 是一对方括号，包围着零个或多个值，这些值由逗号分隔。之前看到的例子实际上是一个包含四个 JSON 对象的 JSON 数组，每个对象又包含四个键值对。
- en: JSON numbers
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON 数字
- en: A JSON **number** is always decimal without a leading zero. There can be a minus
    sign in front and a `.` as the floating point. It may have an exponent of ten,
    prefixed by `e` or `E`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 的 **数字** 总是十进制，没有前导零。前面可以有一个负号和一个作为浮点数的 `.`。它可以有一个十的指数，前面有 `e` 或 `E`。
- en: JSON and PHP
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON 和 PHP
- en: 'If you use PHP on the server side, for example, to retrieve your data from
    a MySQL database, and you would like to convert the data to the JSON format, this
    can be done easily. Simply create a PHP array containing the data. A very convenient
    function, `json_encode()`, is available, which takes a PHP array and converts
    it into a string that contains JSON data (notice I did not write a JSON string).
    There is also a function that does the opposite and translates JSON data into
    a PHP array: `json_decode()`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 PHP 在服务器端，例如，从 MySQL 数据库中检索数据，并且你想将数据转换为 JSON 格式，这可以很容易地完成。只需创建一个包含数据的
    PHP 数组。有一个非常方便的函数 `json_encode()`，它接受一个 PHP 数组并将其转换为包含 JSON 数据的字符串（注意我没有写 JSON
    字符串）。还有一个函数执行相反的操作，将 JSON 数据转换为 PHP 数组：`json_decode()`。
- en: 'Here is some sample PHP code that will convert a PHP array into a PHP string
    that contains the same JSON array as the one in our `californiapeople` example.
    If this is part of a `.php` file you access from a jQuery Ajax call, you can process
    it as JSON on the client side. Just make sure you specify `json` as the datatype:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例 PHP 代码，它将 PHP 数组转换为包含与我们的 `californiapeople` 示例中相同的 JSON 数组的 PHP 字符串。如果这是从
    jQuery Ajax 调用访问的 `.php` 文件的一部分，你可以在客户端将其作为 JSON 处理。只需确保指定 `json` 作为数据类型：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: JSON with Ajax and jQuery
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ajax 和 jQuery 的 JSON
- en: To conclude this chapter, we will recreate our photo gallery example that we
    used to demonstrate how XML can be processed on the client site to dynamically
    generate HTML. This time, we will use JSON as the data format. Let's start with
    our meaner and leaner data, which will reside on the server as `practical.json`.
    Note that it consists of a JSON object with a single key:value pair, with another
    object as the value with four key:value pairs, of which the last one is an array.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一章，我们将重新创建我们之前用来演示如何在客户端动态生成 HTML 的照片库示例。这次，我们将使用 JSON 作为数据格式。让我们从我们的更简单、更精简的数据开始，这些数据将驻留在服务器上的
    `practical.json` 文件中。请注意，它包含一个具有单个键值对的 JSON 对象，其值是另一个具有四个键值对的对象，其中最后一个是一个数组。
- en: 'Once again, this is easier to read than its XML counterpart:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这比它的 XML 对应物更容易阅读：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The HTML file for this is the same as for the XML example: we only need to
    change what is inside the JavaScript file. Here we will use a convenient jQuery
    function, `.getJSON()`, another shortcut of `.ajax()`. It returns a JSON object,
    which we can can in turn process with regular JavaScript, making the code itself
    simpler:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 HTML 文件与 XML 示例相同：我们只需要更改 JavaScript 文件中的内容。这里我们将使用一个方便的 jQuery 函数 `.getJSON()`，它是
    `.ajax()` 的另一个快捷方式。它返回一个 JSON 对象，我们可以用常规 JavaScript 进一步处理，从而使代码本身更简单：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Rather than using the jQuery `.each()` function, we could also have used a
    plain JavaScript `for` loop:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用 jQuery 的 `.each()` 函数，我们也可以使用普通的 JavaScript `for` 循环：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Two useful JSON methods
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 两个有用的 JSON 方法
- en: To conclude, we will mention two JavaScript methods that are part of the JSON
    object, and are supported by most browsers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们将提到两个属于 JSON 对象的 JavaScript 方法，并且大多数浏览器都支持这些方法。
- en: 'To convert a JSON string into a JavaScript object, you simply pass the JSON
    string into the `JSON.parse()` method, like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JSON 字符串转换为 JavaScript 对象，你只需将 JSON 字符串传递给 `JSON.parse()` 方法，如下所示：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`JSON.stringify()` can be used to do the opposite and convert a JavaScript
    object into a JSON string. In our example, we could have used the following, which
    is handy for debugging purposes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON.stringify()` 可以用来执行相反的操作，将 JavaScript 对象转换为 JSON 字符串。在我们的例子中，我们可以使用以下代码，这对于调试很有用：'
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced two data formats that are used in web development.
    XML is used throughout in the industry to exchange data in a format that both
    humans and computers can read. We can use an XML file as a small database and
    several XML-based technologies exist to assist us, such as XML Schema, to firmly
    define the structure of an XML file, and XSLT to create a stylesheet to convert
    an XML file into another XML file, which might well be a web page. XML files can
    also be processed and created in PHP using SimpleXML.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了两种在网页开发中使用的数据格式。XML 在整个行业中用于交换人类和计算机都能读取的数据格式。我们可以将 XML 文件用作小型数据库，并且存在一些基于
    XML 的技术来帮助我们，例如 XML Schema，它可以用来严格定义 XML 文件的结构，以及 XSLT，它可以创建样式表将 XML 文件转换为另一个
    XML 文件，这可能是网页。使用 SimpleXML，我们还可以在 PHP 中处理和创建 XML 文件。
- en: JSON is the leaner and meaner format in vogue with web developers. It requires
    less bandwidth than XML, which is extremely beneficial when the amount of data
    increases. As JSON data can be processed like JavaScript objects, no additional
    processing code or engine is required when JSON is used.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 是当前网页开发者中流行的更简洁、更高效的格式。它所需的带宽比 XML 少，当数据量增加时这一点极为有益。由于 JSON 数据可以像 JavaScript
    对象一样处理，所以在使用 JSON 时不需要额外的处理代码或引擎。
- en: Now, wouldn't it be nice if our data could be stored on the server in JSON as
    well, so none of these conversions from one format to another are needed? Yes,
    it would. Can we do this? Yes, we can. Just go to the next chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们的数据也能以 JSON 格式存储在服务器上，那么就无需进行这些从一种格式到另一种格式的转换，这不是很好吗？是的，这样很好。我们能这样做吗？是的，我们可以。只需翻到下一章。
