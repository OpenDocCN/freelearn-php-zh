- en: Chapter 10. XML and JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been using HTML everywhere. It is the format for web pages,
    so we have used it to create static web pages. As a consequence, HTML is the format
    of the data that is exchanged between the server and the client during the page
    load of the **.html** file.
  prefs: []
  type: TYPE_NORMAL
- en: When we create web pages dynamically, our PHP code will compose lines of HTML
    by the time data is sent across, which will be the true data that is exchanged,
    not the original content of your **.php** file. When we used Ajax, we did not
    specify a data format as a parameter in our jQuery Ajax methods, `.post()` or
    `.ajax()`, because it was implicitly understood that it would be HTML.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we introduce two different data formats, XML and JSON. In web
    development, we can use them in different ways. First, they can be an alternative
    to your database. For simple projects, your data can be stored in a text file,
    rather than in a full blown database. You could even store it as plain text.
  prefs: []
  type: TYPE_NORMAL
- en: The next, and better, level up would be to use an XML file or JSON for your
    data. They are plain text as well, but formatted in a special way. Data stored
    in that format can be easily converted to HTML, bringing us back to the previous
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we can first send the data to the client and then process
    it there to create the content of our pages. We will cover both scenarios in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**eXtensible Markup Language** (**XML**) is a format that has been widely adopted
    to exchange information between companies, documents, and programs. It has a notation
    similar to HTML, using tags. As a matter of fact, HTML is a special case of XML.
    With HTML, tags have meanings and are meant to be interpreted by a browser. In
    XML, tags can mean anything or nothing at all, but the rules are stricter. Of
    course, if you are the creator of the XML file, we hope that the tags have some
    meaning to you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You, as a web developer, may never use XML, but it is important that you know
    that it exists. It has been created to be a data format that is both machine readable
    and human readable. Humans will be able to read the content that is inside, as
    XML files are basically text files; computer programs can read them because they
    are well structured. There are several areas where the XML format is applied.
    We only mention a few of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web services**: Some people or companies give access to information from
    their database by providing a web service. How to create web services is beyond
    the scope of this book. What web services typically offer you is the ability to
    go to a certain web address, with a query string indicating the kind of information
    you are seeking. The result of visiting this (virtual) site is an output stream
    in the XML format, which you can then process. We will teach you how to do the
    processing, not the creation of the service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alternative to a database**: For simple applications, or parts thereof, using
    a full blown database might be overkill. As we have mentioned, you could use a
    plain text file or, as often occurs, a `.csv` file. It is far better to use an
    XML file for this, as it has more structure and it may well be the structure that
    the customer wants from you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The format of an XML file is actually quite simple. It is a text file than
    begins with a line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This line mentions the version of XML, and so far this is only 1.0 or 1.1\.
    The rules are so simple that there is hardly room for changes and encoding. This
    is called the **XML declaration**. Everything that follows is the actual XML document,
    which consists of tags, or elements, a closing tag for each opening tag, and text
    in between them. Look at this first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can tell, there is a closing tag for each opening tag, and one tag, `<californiapeople>`
    appears first and only once. This is the **root**. Tags can have tags in between
    them, but they must be properly nested. I have given the first person tag an **attribute**
    and I have also included an **empty** tag there. Just like the `<br/>` tag in
    HTML, `<picture/>` is a shorthand notation for `<picture></picture>`. Such an
    element is called **self-closing**.
  prefs: []
  type: TYPE_NORMAL
- en: Because I use XML from time to time, I have a habit of always using a closing
    tag in HTML files, even where it is not mandatory, for example in HTML5\. Other
    noticeable differences are that in an XML file, white space is not truncated and
    names of elements are case sensitive, so `<Person>` is not the same as `<person>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, as can be expected, there are a number of characters you cannot use
    inside the text of your XML file: `<` and `&`. XML is going to think it reached
    the beginning of an opening tag. If you need the `<` sign , use `&lt;` instead.
    You should remember this from when we discussed HTML entities a few chapters ago.
    Other entities used in XML are `&amp`, which solves the chicken and egg problem,
    that if `&lt;` means `<`, then using `&` by itself cannot be allowed either. `&gt;`,
    `&apos;`, and `&quot;` can be used as well, even though `>`, `''`, and `"` are
    legal characters. If you need them as part of your text, we recommend that you
    use the entities instead. Oh, by the way, did you notice that the syntax for comments
    is also the same as in HTML? There are more similarities, and we can even style
    an XML file!'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying XML files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first time you look at an XML file, you may not see what you expect. The
    best way to display an XML file is to use a browser, and the browser will treat
    the file as it does HTML files; therefore, you will not see the tags, only the
    text in between them. This is another reason why I like to use Firefox as a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Firefox and Chrome display the entire XML file, including the tags. The tag
    names are in a different color and everything is nicely indented. Firefox will
    also check to see whether it is a well-formed XML file and, if it is not, produce
    a meaningful error message pointing you to the offending line in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes Firefox displays: "This XML file does not appear to have any style
    information associated with it. The document tree is shown below." Well, this
    Firefox message suggests that there can be a stylesheet for an XML file, does
    it not? Could that even be a CSS file? Yes it could. Just add the following line
    after the XML declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Then, create a CSS file with the following content. Firefox will now display
    only the contents of your file, not the tags, using some funky colors. Later in
    this chapter, you will learn that there can be other style sheets that are not
    CSS files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the nature of XML, all the code examples that follow are rather long.
    You may want to consider going to the online pages for this book on Packt Publishing''s
    website and picking them up there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: XML editors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As XML files are text files, you can use any text editor to create and edit
    them. **Textastic** is a fantastic editor that only costs a few bucks, which I
    like using, and there is a version for MacOS, as well as iOS. **Dreamweaver**
    users will benefit from its feature of validating XML files for the correct syntax.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the world of XML, validation can be done beyond simple syntax.
  prefs: []
  type: TYPE_NORMAL
- en: XML Schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you are working with several customers that need to provide you with
    data, employee records, for example, and you request that they do so using XML
    as the format. You have just requested yourself a big mess! As data comes in,
    you realize that one customer used the element `<name>` for the last name, whereas
    another one decided to go with `<last>`. Not only that, they probably used a different
    order and mix of things.
  prefs: []
  type: TYPE_NORMAL
- en: What you should have done first was to give them a definition of how you wanted
    the XML file to look. Then, you could have already started to write your application
    that will process the data before you even received that data.
  prefs: []
  type: TYPE_NORMAL
- en: There are several conventions used to define the structure of an XML file. One
    is called **Document Type Definition** (**DTD**) and another one is **XML Schema**.
    The nice thing about the XML Schema format is that the file that describes the
    structure of your XML file is also an XML file. Teaching you about either method
    is beyond the scope of this book. A few examples of XML Schema files are provided
    however.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a start, here is the XML Schema definition for XML files that are structured
    like the one in our previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can probably decipher, this is a description of all the elements that
    can be inside the XML file, which attributes they can have, in which order they
    should occur, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: SimpleXML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assume we have an XML file on the server containing data that we want to use
    to dynamically generate a web page, as was done previously by extracting the data
    from a MySQL database in a PHP program. How can this be done?
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways. In this example, **SimpleXML** is used. It consists
    of a few PHP classes with several methods to process existing XML files, or create
    new ones. The following example is taken from an older version of my website,
    which contains many galleries of photographs. The information about the photographs
    was stored in an XML file, one for each gallery. Each time a photograph had to
    be added to the site, all that needed to be done was to add a `node` to the appropriate
    XML file.
  prefs: []
  type: TYPE_NORMAL
- en: I have abbreviated the text inside the XML file, otherwise this part of the
    chapter would have turned into a travel guide.
  prefs: []
  type: TYPE_NORMAL
- en: The XML file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use your favorite editor and create `practical.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The XML Schema file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the XML Schema file `photocollection.xs`, in case you are interested
    what it will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The CSS file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is `practical.css`, the style sheet for the HTML that will be generated
    from the XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The PHP file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the PHP file to generate the HTML of a small picture gallery with as
    many photographs as there are referenced in the XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As the name suggests, SimpleXML is simple to use. `simplexml_load_file()` returns
    an object that contains the entire XML tree of the file that is passed as an argument.
    There is a companion method, called `simplexml_load_string()`, which takes a string
    that contains XML as argument. Every element inside this tree can be accessed
    using a simple syntax.
  prefs: []
  type: TYPE_NORMAL
- en: To access the collection of all photo nodes, the **xpath()** method was used.
    It supports the syntax of XPath, a query language for XML files. All you need
    to remember here is the meaning of `//photo`. It gives us all photo nodes back,
    even if they are not in the top level of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Creating XML files with SimpleXML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use SimpleXML to create XML files from within a program. You start
    with the root element as a string, and then build up your XML file by adding nodes
    using the `addChild()` method, which takes one or two arguments. The first one
    is the name of the node, and the optional second one, its value. When you are
    all done, you finish it off with the `asXML()` method, which will return a string
    containing all the XML, or store it into a file if you give it an argument. In
    the example that follows, we call it `xmlfiles/new.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude this section on SimpleXML, here is a tiny program that recreates
    our XML file, but with only one photo node, and saves it as `xmlfiles/new.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Generating our HTML on the client side
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not necessary to always generate the final HTML on the server and then
    send it to the client when we use XML or JSON as the data format and use Ajax
    calls. As more and more powerful devices are used to access the web and run a
    browser inside them, generating the HTML code might as well be done inside the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: We could use the `.post()` jQuery Ajax call and execute a PHP program, with
    SimpleXML, to pass the entire XML file as a string and then process it. Even that
    part is not necessary because the jQuery Ajax methods know what XML and JSON are
    all about. We can simply specify the path of the XML file to the `.ajax()` method,
    and jQuery will take care of the rest. This is a great candidate to use the `.get()`
    method, as we only have to retrieve data, our XML, from the server, and not send
    any data to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will generate the exact same photo gallery but it is
    all done with Ajax and JavaScript, no PHP code is involved. The HTML file is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript file is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: XSLT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hang on in there just a little longer. JSON is just around the corner. Only
    one more XML technology to add to our arsenal!
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine two banks that create a lot of data, as banks do. Both banks use XML,
    and both have crafted an XML Schema file so that the formats of the XML files
    are extremely well defined. Now, imagine that one bank acquires the other one
    and inherits all that data that is in the other XML format: this is a disaster
    in the making. Not to worry, XSLT to the rescue!'
  prefs: []
  type: TYPE_NORMAL
- en: '**eXtensible Stylesheet Language Transformation** (**XSLT**) is a language
    that can be used to translate an XML file into another XML file. What is required
    is an XSLT engine and an XSL file, which describes how the one file has to be
    transformed into the other. All kinds of calculations can occur in the process
    of transforming as it is a full blown programming language. The thickest book
    I have on a single web development topic is an XSLT guide.'
  prefs: []
  type: TYPE_NORMAL
- en: 'XSL files are referred to as stylesheets. They are not CSS files, but the term
    stylesheet is not misplaced at all. If we take an XML file and transform it to
    an HTML file, then we actually created a view for the XML file that goes beyond
    what we can do with only a CSS file. Rather than creating an XSL file for the
    `california.xml` example, here is an XSL stylesheet that translates the `practical.xml`
    file into the exact same HTML as the SimpleXML example. If you analyze what is
    inside, you could dissect it into three parts: which parts of the file to apply
    a rule (template) to, what the rules are, and inside all that, plain HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an XSLT example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the PHP file to handle the transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON**) is the other data interchange format
    discussed in this chapter. Like XML, it is text-based and human readable, but
    it also more lightweight than its counterpart. Data sent in the JSON format will
    take up a lot less bandwidth when data is sent over a network connection. It is
    used more and more in web applications today. XML files are heavier - just notice
    how many pages we needed to provide some examples, and requires a parser of some
    sort to process the data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON is derived from JavaScript, and JSON code looks a lot like JavaScript
    objects, but there are subtle differences. However, JavaScript can be used to
    process JSON data, so you would not need a separate parser, as is the case with
    XML. Here is the same data from the `california.xml` example, but in the JSON
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice first of all how much easier to read this is compared to its XML counterpart.
    It looks like an array of JavaScript objects containing key:value pairs, and that
    is almost what this is. In the discussion on objects in [Chapter 4](ch04.html
    "Chapter 4. JavaScript"), *JavaScript*, we had an example with the name of John
    Williams in it, and a hint to the JSON format. The key difference (*key* being
    a key word here) is that, in JSON, the keys also have to be surrounded by double
    quotes. So, in the land of JSON, `name:"Williams"` would be incorrect. Let's go
    over the simple structure of the JSON data format. You may want to take a piece
    of paper and draw a little diagram for each rule.
  prefs: []
  type: TYPE_NORMAL
- en: JSON syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSON data is plain text. JSON text consists of a sequence of characters that
    is encoded in Unicode and that conforms to the **JSON value syntax**. So, simply
    said, every piece of JSON data has to be a valid JSON value. There are six tokens
    that have a special meaning in JSON: `[`, `{`, `]`, `}` , `:`, and`,`. There are
    also three name tokens that have a special meaning to JSON: `true`, `false`, and
    `null`. These tokens are use to compose correct JSON values.'
  prefs: []
  type: TYPE_NORMAL
- en: JSON values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A JSON **value** can be an object, array, number, or string or one of true,
    false, or null. These are the building blocks of well-formatted JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: JSON objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A JSON **object** begins with a left curly brace and ends with a right curly
    brace. Inside, there will be zero or more key:value pairs, separated by commas.
    The key or name is a JSON string. There is a semicolon in between the key and
    the value. The value itself can be any valid JSON value.
  prefs: []
  type: TYPE_NORMAL
- en: JSON strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A JSON **string** begins and ends with double quotes. Single quotes cannot be
    used to delimit strings. However, you could have a single quote in the middle
    of a string. If you need a double quote, you will have to escape it with a backslash
    ( `\` ). Other two-character escape sequences are, inevitably, `\\`, `\/`, `\b`,
    `\f`, `\n`, `\r`, and `\t`. You can also use a 4-digit Unicode code of any character
    by having it preceded by `\u`.
  prefs: []
  type: TYPE_NORMAL
- en: JSON arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A JSON **array** is a pair of square brackets surrounding zero or more values,
    separated by a comma. The example seen previously is actually a JSON array that
    contains four JSON objects, in turn containing four key:value pairs each.
  prefs: []
  type: TYPE_NORMAL
- en: JSON numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A JSON **number** is always decimal without a leading zero. There can be a minus
    sign in front and a `.` as the floating point. It may have an exponent of ten,
    prefixed by `e` or `E`.
  prefs: []
  type: TYPE_NORMAL
- en: JSON and PHP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you use PHP on the server side, for example, to retrieve your data from
    a MySQL database, and you would like to convert the data to the JSON format, this
    can be done easily. Simply create a PHP array containing the data. A very convenient
    function, `json_encode()`, is available, which takes a PHP array and converts
    it into a string that contains JSON data (notice I did not write a JSON string).
    There is also a function that does the opposite and translates JSON data into
    a PHP array: `json_decode()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some sample PHP code that will convert a PHP array into a PHP string
    that contains the same JSON array as the one in our `californiapeople` example.
    If this is part of a `.php` file you access from a jQuery Ajax call, you can process
    it as JSON on the client side. Just make sure you specify `json` as the datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: JSON with Ajax and jQuery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To conclude this chapter, we will recreate our photo gallery example that we
    used to demonstrate how XML can be processed on the client site to dynamically
    generate HTML. This time, we will use JSON as the data format. Let's start with
    our meaner and leaner data, which will reside on the server as `practical.json`.
    Note that it consists of a JSON object with a single key:value pair, with another
    object as the value with four key:value pairs, of which the last one is an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, this is easier to read than its XML counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML file for this is the same as for the XML example: we only need to
    change what is inside the JavaScript file. Here we will use a convenient jQuery
    function, `.getJSON()`, another shortcut of `.ajax()`. It returns a JSON object,
    which we can can in turn process with regular JavaScript, making the code itself
    simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than using the jQuery `.each()` function, we could also have used a
    plain JavaScript `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Two useful JSON methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To conclude, we will mention two JavaScript methods that are part of the JSON
    object, and are supported by most browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert a JSON string into a JavaScript object, you simply pass the JSON
    string into the `JSON.parse()` method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`JSON.stringify()` can be used to do the opposite and convert a JavaScript
    object into a JSON string. In our example, we could have used the following, which
    is handy for debugging purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced two data formats that are used in web development.
    XML is used throughout in the industry to exchange data in a format that both
    humans and computers can read. We can use an XML file as a small database and
    several XML-based technologies exist to assist us, such as XML Schema, to firmly
    define the structure of an XML file, and XSLT to create a stylesheet to convert
    an XML file into another XML file, which might well be a web page. XML files can
    also be processed and created in PHP using SimpleXML.
  prefs: []
  type: TYPE_NORMAL
- en: JSON is the leaner and meaner format in vogue with web developers. It requires
    less bandwidth than XML, which is extremely beneficial when the amount of data
    increases. As JSON data can be processed like JavaScript objects, no additional
    processing code or engine is required when JSON is used.
  prefs: []
  type: TYPE_NORMAL
- en: Now, wouldn't it be nice if our data could be stored on the server in JSON as
    well, so none of these conversions from one format to another are needed? Yes,
    it would. Can we do this? Yes, we can. Just go to the next chapter.
  prefs: []
  type: TYPE_NORMAL
