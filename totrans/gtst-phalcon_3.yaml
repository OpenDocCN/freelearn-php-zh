- en: Chapter 3. Using Phalcon Models, Views, and Controllers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：使用 Phalcon 模型、视图和控制器
- en: Now we will start building a functional blog application. Using Phalcon Developer
    Tools, we will generate our models, controllers, and views, and then examine the
    code in sufficient detail so that we can write it ourselves if we have to. We
    will also learn about forms in Phalcon, which are in the arsenal of view helpers
    that are components we can use repeatedly in our application. There is no need
    to reinvent the wheel here. We will also look at the Volt template engine, which
    is built into Phalcon.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始构建一个功能性的博客应用程序。使用 Phalcon 开发者工具，我们将生成我们的模型、控制器和视图，然后详细检查代码，以便我们可以在需要时自己编写它。我们还将了解
    Phalcon 中的表单，这些表单是视图辅助工具的一部分，是我们可以在应用程序中重复使用的组件。这里没有必要重新发明轮子。我们还将查看内置在 Phalcon
    中的 Volt 模板引擎。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The basics of the Model-View-Controller pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Model-View-Controller 模式的基础
- en: Creating a Phalcon model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Phalcon 模型
- en: Creating a Phalcon controller
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Phalcon 控制器
- en: Creating a Phalcon view
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Phalcon 视图
- en: Using the Volt template engine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Volt 模板引擎
- en: Using Phalcon view helpers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Phalcon 视图辅助工具
- en: Introducing MVC
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 MVC
- en: PHP has changed a lot over the years. In the beginning, it wasn't even object-oriented.
    But that was added in PHP 3, and has improved in the PHP versions since then.
    These changes led the way for PHP-based frameworks. And most of these frameworks
    use the MVC pattern, which was made popular by both Python's Django and Ruby's
    Ruby on Rails, for use in web frameworks. Let's briefly review each part of the
    MVC pattern.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 在这些年里发生了很大的变化。最初，它甚至不是面向对象的。但PHP 3中添加了这一点，并且从那时起在PHP版本中得到了改进。这些变化为基于PHP的框架铺平了道路。而且，这些框架中的大多数都使用MVC模式，这个模式由Python的Django和Ruby的Ruby
    on Rails共同推广，用于Web框架。让我们简要回顾MVC模式的每个部分。
- en: View
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: The view outputs the user interface. This is its only job. Sometimes, a view
    includes a template engine such as Smarty or Phalcon's own built-in template engine,
    Volt. We will be using Volt in our blog project. But the truth is that since you
    can mix `PHP` and `HTML` in the same file, PHP itself acts like a template engine.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 视图输出用户界面。这是它的唯一任务。有时，视图包括一个模板引擎，如Smarty或Phalcon自带的内置模板引擎Volt。在我们的博客项目中，我们将使用Volt。但事实是，由于你可以在同一文件中混合`PHP`和`HTML`，PHP本身就像一个模板引擎。
- en: Controller
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: Controllers are the switchboard operators of our application. The actions in
    a controller pass parameters to the view to display and respond to user input.
    When we fill out a blog form in our application and click on the **Save** button,
    the data we posted is sent through our controller. As we are creating a blog post,
    the controller uses its `createAction` function to create a new post instance
    in our model. When this is done, it sends a message back to our view stating that
    our post was successful.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是我们应用程序的总机操作员。控制器中的操作将参数传递给视图以显示并响应用户输入。当我们在我们应用程序中填写博客表单并点击**保存**按钮时，我们发布的数据将通过我们的控制器发送。当我们创建博客文章时，控制器使用其`createAction`函数在我们模型中创建一个新的文章实例。当完成这项工作后，它向我们的视图发送一条消息，说明我们的文章发布成功。
- en: Model
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: Most of the logic of our application should reside in the model. It should know
    that each one of our blog posts has a user that posted it, and that these two
    things are related. It should also know that each blog post can have one or many
    tags. If we have a database connected to our application, the model should handle
    the changes to the database. When we create a new post in our application, our
    controller simply passes the data we posted in our form to the correct action.
    Our model should handle the creation of the new post's record in the database
    as well as any records that relate to the user who posted it or the tags we added
    to it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的大部分逻辑应该位于模型中。它应该知道我们每篇博客文章都有一个发布它的用户，并且这两者之间是相关的。它还应该知道每篇博客文章可以有一个或多个标签。如果我们有一个连接到我们应用程序的数据库，模型应该处理对数据库的更改。当我们在我们应用程序中创建一篇新文章时，我们的控制器只需将我们在表单中发布的数据传递给正确的操作。我们的模型应该处理在数据库中创建新文章记录以及与发布该文章的用户或我们添加到其中的标签相关的任何记录。
- en: Creating a database
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库
- en: Before we can get Phalcon Developer Tools to generate any more files for us,
    we need a database. The project skeleton was the easy part. We now need to generate
    the model, controller, and view files. So, let's create our database. For the
    purpose of this book, I am going to give examples using raw SQL queries, so you
    can execute them via the command line or your chosen database tool, and examples
    using phpMyAdmin, which can be downloaded for free from [http://www.phpmyadmin.net](http://www.phpmyadmin.net).
    This also requires that you have MySQL installed on your machine, which can be
    downloaded for free from [http://www.mysql.com](http://www.mysql.com).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以让Phalcon开发者工具为我们生成更多文件之前，我们需要一个数据库。项目骨架是容易的部分。我们现在需要生成模型、控制器和视图文件。所以，让我们创建我们的数据库。为了本书的目的，我将给出使用原始SQL查询的示例，您可以通过命令行或您选择的数据库工具执行它们，以及使用phpMyAdmin的示例，可以从[http://www.phpmyadmin.net](http://www.phpmyadmin.net)免费下载。这也要求您在机器上安装MySQL，可以从[http://www.mysql.com](http://www.mysql.com)免费下载。
- en: 'First we need our database. The following is the command to create the database
    we need for our project:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要我们的数据库。以下是我们项目所需的数据库创建命令：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In phpMyAdmin, you could just click on the **Databases** tab, enter `phalconblog`
    in the **Create new database** section of the page, and click on the **Create**
    button, as shown in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在phpMyAdmin中，您只需点击**数据库**标签，在页面的**创建新数据库**部分输入`phalconblog`，然后点击**创建**按钮，如图所示：
- en: '![Creating a database](img/7673OS_03_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![创建数据库](img/7673OS_03_01.jpg)'
- en: 'Now, we just need to create the table for our blog posts. We will worry about
    the other tables later. The following is the SQL code for our blog `posts` table:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要创建我们的博客文章表格。我们稍后再处理其他表格。以下是我们博客`posts`表的SQL代码：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you are using phpMyAdmin, browse to your `phalconblog` database, click on
    the **SQL** tab, and paste the previous SQL code. Then click on the **Go** button
    and your table will be ready.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用phpMyAdmin，浏览到您的`phalconblog`数据库，点击**SQL**标签，粘贴之前的SQL代码。然后点击**执行**按钮，您的表就准备好了。
- en: '![Creating a database](img/7673OS_03_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![创建数据库](img/7673OS_03_02.jpg)'
- en: We now have a simple table to hold our blog posts. It has a unique ID that autoincrements
    a title field for the title of our post, a body field to hold the body, an excerpt
    field to hold the summary of our post for pages such as our home page and category
    pages, a published date field, an updated date field, and two fields to hold the
    ping status of our post.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个简单的表格来存储我们的博客文章。它有一个唯一的ID，用于自动增加标题字段，以存储我们文章的标题，一个正文字段来存储正文，一个摘要字段来存储我们文章的摘要，用于主页和分类页面等，一个发布日期字段，一个更新日期字段，以及两个字段来存储我们文章的ping状态。
- en: Now that we have a table in place, we can use Phalcon Developer Tools to create
    a model file for our blog posts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个表格了，我们可以使用Phalcon开发者工具为我们的博客文章创建一个模型文件。
- en: Creating a model
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'Open `http://localhost/phalconBlog/webtools.php` in your browser if that is
    where your project is running. If not, browse to the index page of your project
    and add `/webtools.php` to the URL. The `webtools.php` file is located in the
    same folder as the bootstrap file. You should see a page in your browser that
    looks something like the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的项目正在运行在`http://localhost/phalconBlog/webtools.php`，请在浏览器中打开它。如果不是，浏览到您项目的首页，并将`/webtools.php`添加到URL中。`webtools.php`文件位于引导文件相同的文件夹中。您应该在浏览器中看到一个类似于以下截图的页面：
- en: '![Creating a model](img/7673OS_03_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![创建模型](img/7673OS_03_03.jpg)'
- en: We are going to generate a model file for our `posts` table. Phalcon Developer
    Tools connect to our database using the setting we put in our `Ini` file and then
    load all the table names in the **Table name** select list. So, select the `posts`
    table from the select list and click on the **Generate** button. You also have
    the options to add setters and getters to your class, set foreign keys for related
    tables, and define relations. You can also force web tools to generate the model
    file even if it already exists.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的`posts`表生成一个模型文件。Phalcon开发者工具使用我们在`Ini`文件中设置的设置连接到我们的数据库，然后加载**表名**选择列表中的所有表名。因此，从选择列表中选择`posts`表，然后点击**生成**按钮。您还可以选择为您的类添加设置器和获取器，为相关表设置外键，并定义关系。您还可以强制网络工具生成模型文件，即使它已经存在。
- en: 'The other option is to use the command-line developer tools. You will need
    to open a terminal instance, navigate to your `phalconBlog` project folder, and
    type the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用命令行开发者工具。您需要打开一个终端实例，导航到您的`phalconBlog`项目文件夹，并输入以下命令：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, `posts` is the name of the table for which a model file is being generated.
    The command line in the Phalcon Developer Tools also has options. In fact, there
    are more options available here than on the web interface. You can list all these
    options by calling the command without a table name, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`posts`是正在生成模型文件的表的名称。Phalcon开发者工具的命令行也有选项。实际上，这里提供的选项比Web界面上的更多。您可以通过不输入表名来调用命令来列出所有这些选项，如下所示：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The previous command should print out options as shown in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令应该会像以下截图所示打印出选项：
- en: '![Creating a model](img/7673OS_03_04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![创建模型](img/7673OS_03_04.jpg)'
- en: Any one of the commands will print out a similar list of options if called without
    any options.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不输入任何选项调用任何命令，都会打印出一个类似选项的列表。
- en: 'Once this is done, we should find the `Posts.php` file in our `models` folder
    in `app`, and we will find the following code in it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们应该在`app`文件夹中的`models`文件夹中找到`Posts.php`文件，并在其中找到以下代码：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We went through all of that and really didn't get much, but it was better than
    typing out all these variables manually. Phalcon extracted the column names out
    of our `posts` table, created a `Posts model` class, and turned these names into
    member variables in our class. It's a start. We can also create a controller using
    web tools.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经历了所有这些，但并没有得到太多，但比手动输入所有这些变量要好。Phalcon从我们的`posts`表中提取了列名，创建了一个`Posts model`类，并将这些名称转换为我们的类中的成员变量。这是一个开始。我们也可以使用Web工具创建控制器。
- en: Creating a controller
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建控制器
- en: 'You can also create your controller with web tools. Just click on the **Controllers**
    tab on the Phalcon web tools menu and then enter your controller name in the **Controller
    name** field of the form, which in our case is `Posts`, as shown in the following
    screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用Web工具创建控制器。只需在Phalcon Web工具菜单中点击**Controllers**标签，然后在表单的**Controller name**字段中输入您的控制器名称，在我们的例子中是`Posts`，如下截图所示：
- en: '![Creating a controller](img/7673OS_03_05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![创建控制器](img/7673OS_03_05.jpg)'
- en: 'As with the model we created, we can use the following command-line tools to
    create our controller:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们创建的模型一样，我们可以使用以下命令行工具来创建我们的控制器：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The result of this will be a new `PostsController.php` file located at `app/controllers`
    as shown in the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个位于`app/controllers`的新`PostsController.php`文件，如下代码所示：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is not much to this file, just our `PostsController` class with one `indexAction`
    function. But things are about to get a lot more interesting. Let's build the
    CRUD functions for our Posts model.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件内容不多，只是我们的`PostsController`类中有一个`indexAction`函数。但接下来事情会变得更有趣。让我们为我们的`Posts`模型构建CRUD函数。
- en: Creating CRUD scaffolding
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CRUD脚手架
- en: 'CRUD stands for create, read, update, and delete, which are the four basic
    functions our application should do with our blog post records. Phalcon web tools
    will also help us to get these built. Click on the **Scaffold** tab on the web
    tools page and you will see a page as shown in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD代表创建、读取、更新和删除，这是我们的应用程序应该对博客文章记录执行的四个基本功能。Phalcon Web工具也会帮助我们构建这些功能。在Web工具页面上点击**Scaffold**标签，您将看到一个如下截图所示的页面：
- en: '![Creating CRUD scaffolding](img/7673OS_03_06.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![创建CRUD脚手架](img/7673OS_03_06.jpg)'
- en: Select `posts` from the **Table name** list and `volt` from the **Template engine**
    list, and check **Force** this time, because we are going to force our new files
    to overwrite the old model and controller files that we just generated. Click
    on the **Generate** button and some magic should happen.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从**Table name**列表中选择`posts`，从**Template engine**列表中选择`volt`，并这次勾选**Force**，因为我们打算强制新文件覆盖我们刚刚生成的旧模型和控制器文件。点击**Generate**按钮，一些魔法应该会发生。
- en: 'Browse to `http://localhost/phalconBlog/posts` and you will see a page like
    the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到`http://localhost/phalconBlog/posts`，您将看到一个如下截图所示的页面：
- en: '![Creating CRUD scaffolding](img/7673OS_03_07.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![创建CRUD脚手架](img/7673OS_03_07.jpg)'
- en: We finally have some functionality we can use. We have no posts, but we can
    create some. Click on the **Create posts** link and you will see a page similar
    to the one we were just at. The form will look nearly the same, but it will have
    a **Create posts** heading. Fill out the **Title**, **Body**, and **Excerpt**
    fields and click on the **Save** button. The form will post, and you will get
    a message stating that the post was created successfully.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于有一些可以使用的功能了。我们没有帖子，但我们可以创建一些。点击 **创建帖子** 链接，你会看到一个类似于我们刚才所在的页面。表单看起来几乎一样，但它会有一个
    **创建帖子** 标题。填写 **标题**、**正文** 和 **摘要** 字段，然后点击 **保存** 按钮。表单将提交，你会得到一个消息，表明帖子已成功创建。
- en: 'This will take you back to the post''s index page. Now you should be able to
    search for and find the post you just created. If you forgot what you posted,
    you can click on **Search** without entering anything in the fields, and you should
    see a page like the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带你回到帖子索引页面。现在你应该能够搜索并找到你刚刚创建的帖子。如果你忘记了你的帖子内容，你可以点击 **搜索** 而不输入任何字段，你应该会看到一个类似于以下截图的页面：
- en: '![Creating CRUD scaffolding](img/7673OS_03_08.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![创建 CRUD 框架](img/7673OS_03_08.jpg)'
- en: This is not a very pretty or user-friendly blog application. But it got us started,
    and that's all we need. The next time we start a Phalcon project, it should only
    take a few minutes to go through these steps. Now we will look over our generated
    code, and as we do, modify it to make it more blog-like.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个非常漂亮或用户友好的博客应用程序。但它让我们开始了，这正是我们所需要的。下次我们开始一个 Phalcon 项目时，只需几分钟就可以完成这些步骤。现在我们将查看生成的代码，并在查看过程中对其进行修改，使其更像博客。
- en: Examining our Posts model
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查我们的 Posts 模型
- en: If you open up `Posts.php` file located at `app/model`, you may notice that
    it has not changed since we generated it the first time. Even with our new CRUD
    scaffolding, it still just contains our Posts model class and our database column
    names as member variables. There is no SQL involved on the PHP side.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开位于 `app/model` 的 `Posts.php` 文件，你可能会注意到自从我们第一次生成它以来，它并没有发生变化。即使我们有新的 CRUD
    框架，它仍然只包含我们的 Posts 模型类和作为成员变量的数据库列名。在 PHP 端没有涉及任何 SQL 代码。
- en: The `Phalcon\MVC\Model` path is the base class of all models that your application
    will use. All the SQL code that is involved happens inside of the Phalcon PHP
    extension. There will be times when we have to make SQL queries, but for now,
    we have given our Posts model CRUD capabilities, search capabilities, and the
    ability to relate to other models without even knowing what database software
    our application is going to use. We could modify our `services.php` file located
    at `app/config` to use another database adapter if we decide that we no longer
    want to use MySQL and want to use Oracle instead. The code for our application
    would work the same as long as our database tables are structured the same.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Phalcon\MVC\Model` 路径是应用程序将使用到的所有模型的基础类。所有涉及的 SQL 代码都发生在 Phalcon PHP 扩展内部。有时我们不得不进行
    SQL 查询，但到目前为止，我们已经为我们的 Posts 模型提供了 CRUD 功能、搜索功能和与其他模型关联的能力，而无需知道我们的应用程序将要使用什么数据库软件。如果我们决定不再使用
    MySQL 而想使用 Oracle，我们可以修改位于 `app/config` 的 `services.php` 文件来使用另一个数据库适配器。只要我们的数据库表结构相同，我们的应用程序代码将保持不变。'
- en: Our Posts model currently does everything we need it to do with minimum code,
    so we won't be modifying it in this chapter. Now let's look at our controller.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Posts 模型目前以最少的代码完成了我们需要的所有功能，所以我们不会在本章中对其进行修改。现在让我们看看我们的控制器。
- en: Examining our Posts controller
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查我们的 Posts 控制器
- en: 'Now let''s open `PostsController.php` file located at `app/controllers` in
    our editor. There is definitely a lot going on in this file. There are seven methods
    in our `PostsController` class suffixed with actions. Each of these actions handles
    requests and creates responses in our application. Each corresponds to a URI in
    our application: `http://localhost/phalconBlog/[model]/[action]`. When we browse
    to `http://www.localhost/phalconBlog/posts/`, by default, the `indexAction` function
    is called.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的编辑器中打开位于 `app/controllers` 的 `PostsController.php` 文件。这个文件中确实有很多内容。在我们的
    `PostsController` 类中有七个以 actions 后缀的方法。这些方法中的每一个都处理请求并创建响应。每个方法对应于我们应用程序中的一个 URI：`http://localhost/phalconBlog/[model]/[action]`。当我们浏览到
    `http://www.localhost/phalconBlog/posts/` 时，默认情况下会调用 `indexAction` 函数。
- en: Let's take a look at each of these actions and modify them if we need to.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看这些操作，并在需要时进行修改。
- en: Create
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建
- en: Let's take a look at the `createAction` function, which saves our new blog posts
    for us.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `createAction` 函数，它为我们保存新的博客帖子。
- en: First, we should learn a little about `Phalcon\Mvc\Dispatcher`. The dispatcher
    is another one of the services that was loaded in our Dependency Injection container.
    The dispatcher takes the request object and instantiates a controller based on
    the attributes of that object. When a controller is instantiated, it acts as a
    listener for dispatcher events. Since everything in the Dependency Injection container
    can be accessed as a property of the controller, we can access the dispatcher
    in a controller with `$this->dispatcher`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该稍微了解一下`Phalcon\Mvc\Dispatcher`。调度器是我们依赖注入容器中加载的服务之一。调度器接收请求对象并根据该对象的属性实例化一个控制器。当控制器被实例化时，它充当调度器事件的监听器。由于依赖注入容器中的所有内容都可以作为控制器的一个属性访问，因此我们可以在控制器中使用`$this->dispatcher`来访问调度器。
- en: 'Another object in our Dependency Injection container that we should know about
    is the request object, which stores details about the HTTP request and is passed
    between the dispatcher and the controller. The code is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们依赖注入容器中我们还应该了解的一个对象是请求对象，它存储有关HTTP请求的详细信息，并在调度器和控制器之间传递。代码如下：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, our method checks if the request is a post by querying the request object
    from our dispatcher container. If the request is not a post, `$this->dispatcher->forward`
    is called, and our dispatcher forwards the requests to the `indexAction` function
    in our posts controller, where the dispatch loop starts up again.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的方法通过从我们的调度器容器中查询请求对象来检查请求是否为POST。如果请求不是POST，则调用`$this->dispatcher->forward`，我们的调度器将请求转发到我们文章控制器中的`indexAction`函数，在那里调度循环再次启动。
- en: 'If we are posting a new blog post, then the method continues executing and
    a post object is created. We can access the data we posted in our form with `$this->request->getPost()`,
    and our code assigns each parameter from this request object to an attribute of
    our `$post` instance. In many cases, it would be easier to replace this series
    of assignments with one line of code as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在发布一篇新的博客文章，那么该方法将继续执行，并创建一个文章对象。我们可以通过`$this->request->getPost()`访问我们在表单中发布的资料，并且我们的代码将把请求对象中的每个参数分配给我们的`$post`实例的属性。在许多情况下，用一行代码替换这一系列赋值会更简单，如下所示：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: But we will be setting some of these variables in our controller later in the
    book, so we will leave them as they are. Since Phalcon is handling all the details
    about our database behind the scenes, we can just call `$this->post->save()` to
    save our post to the database; there is no need for SQL.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们将在本书的后面部分在我们的控制器中设置一些这些变量，所以我们将它们保持原样。由于Phalcon在幕后处理我们数据库的所有细节，我们只需调用`$this->post->save()`将文章保存到数据库；不需要SQL。
- en: 'Next, the code checks if our post has been saved, and if it hasn''t, it uses
    the flashing messages'' service that is embedded in Phalcon to store the error
    message with `$this->flash->error`, while the application forwards us back to
    the form. If the post was successfully created, we are forwarded to the index
    with a successful message as `$this->flash->success`. The flashing messages''
    service provides our application with the ability to give users notification of
    the status of their actions. There are four message types in the flashing messages''
    services:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码检查我们的文章是否已保存，如果没有，它使用Phalcon内嵌的闪存消息服务，通过`$this->flash->error`存储错误消息，同时应用程序将我们转发回表单。如果文章成功创建，我们将被转发到索引，并带有成功消息`$this->flash->success`。闪存消息服务为我们应用程序提供了向用户提供操作状态通知的能力。闪存消息服务中有四种消息类型：
- en: Error
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Success
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功
- en: Notice
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意
- en: Warning
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警告
- en: 'If we want to set custom classes for our messages when they are served by our
    view, we can add the following code to the `services.php` file in `config`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在视图服务我们的消息时为它们设置自定义类，我们可以在`config`目录下的`services.php`文件中添加以下代码：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From then on, any error message served by our application will be given both
    the alert and alert-error classes. The `Phalcon\Flash\Direct` is a variant of
    `Phalcon\Flash`, which immediately outputs the messages passed to it. Another
    variant is `Phalcon\Flash\Session`, which temporarily stores the messages in the
    user's session to be output in the next request.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，我们应用程序提供的任何错误消息都将同时具有alert和alert-error类。`Phalcon\Flash\Direct`是`Phalcon\Flash`的一个变体，它立即输出传递给它的消息。另一个变体是`Phalcon\Flash\Session`，它将消息暂时存储在用户的会话中，以便在下一个请求中输出。
- en: Search
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索
- en: 'Now let''s take a look at our `searchAction` function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们的`searchAction`函数：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At the beginning of our function, we set a `$numberPage` variable to `1`. This
    is because we use the Phalcon paginator that we loaded into our Phalcon services
    container in our bootstrap file. We will be using that variable to tell the paginator
    what page of results will be loaded, and if there is no `page` parameter, then
    we want to load the first page of results.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们函数的开始处，我们设置一个`$numberPage`变量为`1`。这是因为我们使用我们在引导文件中加载到Phalcon服务容器中的Phalcon分页器。我们将使用这个变量来告诉分页器要加载哪一页的结果，如果没有`page`参数，那么我们希望加载结果的第一页。
- en: After that, our code checks if there is a POST request, and if there is, we
    use the `fromInput` function in `Phalcon\Mvc\Model\Criteria` to change the parameters
    in our post into an array that we can use to query our Posts model. We persist
    the parameters in the session by creating a variable parameter in `$this->persist`,
    which is a Phalcon class that persists variables between sessions. This enables
    our code to load a second page of results from a search query without adding parameters
    to the URL. The only parameter needed to load a second page of search results
    is `page`. If there is no post, we set the `$numberPage` variable to the `page`
    parameter from the GET request with `getQuery`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们的代码检查是否有POST请求，如果有，我们使用`Phalcon\Mvc\Model\Criteria`中的`fromInput`函数将我们的帖子参数更改为一个我们可以用来查询我们的Posts模型的数组。我们通过在`$this->persist`中创建一个变量参数来在会话中持久化这些参数，`$this->persist`是一个在会话之间持久化变量的Phalcon类。这使得我们的代码能够在不向URL添加参数的情况下从搜索查询中加载第二页的结果。加载搜索结果第二页所需的唯一参数是`page`。如果没有帖子，我们将`$numberPage`变量设置为GET请求中的`page`参数，使用`getQuery`。
- en: Then, we set a local `$parameters` variable to our persistent parameters, and
    we will use this variable to query our Posts model using the `find` function,
    storing the results in `$posts`. Then, the code checks if the post has any results
    and sets a flash message to tell us when there are no posts in our `posts` table.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置一个本地的`$parameters`变量来存储我们的持久化参数，我们将使用这个变量通过`find`函数查询我们的Posts模型，并将结果存储在`$posts`中。然后，代码检查是否有帖子结果，并设置一个闪存消息来告诉我们当我们的`posts`表中没有帖子时。
- en: Then, we finally get to the paginator we mentioned at the beginning of this
    section. We create it by setting the `data` parameter to the `$posts` variable,
    setting the `limit` parameter to the count of records we want for each page, which
    in this case is `10`, and then set the `page` parameter to our `$numberPage` variable.
    Then, we set the `page` variable of our `view` object to the `page` object that
    our paginator returns, which holds the paginated blog post's results.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们终于到达了本节开头提到的分页器。我们通过将`data`参数设置为`$posts`变量，将`limit`参数设置为每页我们想要的记录数，在这个例子中是`10`，然后设置`page`参数为我们的`$numberPage`变量来创建它。然后，我们将我们的`view`对象的`page`变量设置为分页器返回的`page`对象，该对象包含分页博客文章的结果。
- en: Index
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引
- en: 'Our `indexAction` function currently doesn''t do much. The index view shows
    the user a search form. We are going to change that because we want it to show
    a list of our most recent posts, as shown in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的`indexAction`函数没有做太多。索引视图向用户显示一个搜索表单。我们将改变这一点，因为我们希望它显示我们最新的文章列表，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We are going to change it to the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把它改为以下代码：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You will notice a difference in the `PostsController` class that we generated
    compared to the one we wrote from scratch at the beginning of the chapter. Phalcon
    Developer Tools generated a `ControllerBase` class for us so that we can add universal
    variables and functionality to it. We can then extend this class to create the
    controllers for our application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们生成的`PostsController`类与我们本章开头从头开始编写的类有所不同。Phalcon开发者工具为我们生成一个`ControllerBase`类，这样我们就可以向其中添加通用变量和功能。然后我们可以扩展这个类来创建我们应用程序的控制器。
- en: Here, we are using part of the functionality we saw in the `searchAction` function.
    We set the page number for the paginator by using the `getQuery` function of `Phalcon\Http\Request`.
    The first `page` parameter is the GET variable we want, the second parameter is
    the type we expect this parameter to be, for example, an integer, and the third
    parameter is the default value, which we set to `1` for the first page. Then,
    we instantiate the paginator and set the `view page` variable to the results from
    our paginator. But we use the static `query` function from `Phalcon\MVC\Model`
    to execute our query in an object-oriented manner, ordering our posts by the published
    date (which we have not yet set, but we will do so). We will learn more about
    interacting with Phalcon models and databases in the next chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了我们在`searchAction`函数中看到的部分功能。我们使用`Phalcon\Http\Request`的`getQuery`函数设置分页器的页面编号。第一个`page`参数是我们想要的GET变量，第二个参数是我们期望此参数的类型，例如整数，第三个参数是默认值，我们将它设置为第一页的`1`。然后，我们实例化分页器并将`view
    page`变量设置为我们的分页器的结果。但我们使用`Phalcon\MVC\Model`的静态`query`函数以面向对象的方式执行我们的查询，按发布日期（我们尚未设置，但我们将这样做）对帖子进行排序。我们将在下一章中了解更多关于与Phalcon模型和数据库交互的内容。
- en: New
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新增
- en: 'There is nothing in the new action method, literally. The action is still called
    and the view that holds our new post form will be served:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 新的动作方法中实际上没有任何内容。动作仍然被调用，包含我们的新帖子表单的视图将被提供：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Edit
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑
- en: 'The next method we will examine is our `editAction` function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的下一个方法是我们的`editAction`函数：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You will notice the `$id` parameter in this function. Any additional URI parameters
    after the parameter for the action are action parameters. They are assigned in
    the same order that the route passes them in. First, our action checks if the
    request was a post. If not, it skips the rest of the functionality and loads the
    view. If it is a post, we create an instance of our Posts object and use its `findFirstByid`
    method to load our blog post into the `$post` variable. We check if our `$post`
    variable contains data and then set our view's ID variable to the ID of the blog
    post. If we want, we can also replace these multiple assignments that Phalcon
    Developer Tools generated for us with the following loop.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这个函数中的`$id`参数。在动作参数之后的任何附加URI参数都是动作参数。它们按照路由传递它们的顺序分配。首先，我们的动作检查请求是否为POST。如果不是，它跳过其余的功能并加载视图。如果是POST，我们创建我们的帖子对象的一个实例，并使用它的`findFirstByid`方法将我们的博客帖子加载到`$post`变量中。我们检查我们的`$post`变量是否包含数据，然后设置我们视图的ID变量为博客帖子的ID。如果我们愿意，我们也可以用以下循环替换Phalcon开发者工具为我们生成的这些多个赋值。
- en: The `Phalcon\Tag` is a view helper class that will generate HTML for our application.
    By calling `$this->tag->setDefault` in our action, we can set the default value
    of a form element with the attribute of the same name. So, by calling `$this->tag->setDefault("id",
    $post->id)`, we set the default ID form input to the ID of our post instance.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Phalcon\Tag`是一个视图辅助类，它将为我们的应用程序生成HTML。通过在我们的动作中调用`$this->tag->setDefault`，我们可以设置具有相同名称属性的表单元素的默认值。所以，通过调用`$this->tag->setDefault("id",
    $post->id)`，我们将默认ID表单输入设置为我们的帖子实例的ID。'
- en: Save
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存
- en: 'Now, let''s check out our `saveAction` function using the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下代码检查我们的`saveAction`函数：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method is very similar to the create method. This one is called when we
    are saving a post that we are editing. This is another place where, if we wish,
    we can replace the multiple lines of assignments with a loop, like we did in the
    `createAction` function. The only real difference in this method is that when
    a post is not saved successfully, we pick the view that we want to show using
    `$this->view->pick()`, and then we set the `$post` variable in the view to the
    one just created. This way, the content is still saved in the browser if the new
    post fails to save. If we were to simply forward it to the `editAction` function,
    it would again look up the post by its `id` and wipe out our changes. We use the
    same view, we just bypass the action.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与创建方法非常相似。当我们在保存正在编辑的帖子时，会调用这个方法。这也是一个地方，如果我们愿意，我们可以用循环来替换多个赋值行，就像我们在`createAction`函数中所做的那样。这个方法唯一的真正区别在于，当帖子没有成功保存时，我们使用`$this->view->pick()`选择我们想要显示的视图，然后我们将视图中的`$post`变量设置为刚刚创建的那个。这样，如果新的帖子保存失败，内容仍然会保存在浏览器中。如果我们简单地将它转发到`editAction`函数，它将再次通过`id`查找帖子并清除我们的更改。我们使用相同的视图，只是绕过了动作。
- en: Delete
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除
- en: 'The following function is the `deleteAction` function in our controller:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们控制器中的`deleteAction`函数：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There's nothing fancy happening here. The method tries to delete the post by
    calling `$post->delete`, and gives us an error message if it wasn't deleted and
    a success message if it was.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里并没有什么特别的事情发生。该方法尝试通过调用`$post->delete`来删除帖子，如果没有删除则给出错误消息，如果删除了则给出成功消息。
- en: Show
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示
- en: 'We are going to have to add an action to our controller to view each post by
    itself. This will be easy because our `editAction` function does some of the same
    things that we need our `showAction` function to do. We need our controller to
    pass a post instance to our view based on a post ID. The following is our code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不在我们的控制器中添加一个动作来单独查看每个帖子。这将很容易，因为我们的`editAction`函数做了一些我们需要的`showAction`函数要做的事情。我们需要我们的控制器根据帖子ID将帖子实例传递给我们的视图。以下是我们的代码：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There is not really much to this method. It takes in our post ID and checks
    if our post is valid. If it is, we set the `view` variable's post to our `$post`
    object so we can use it in our view. But if there is no post, we want to at least
    set a 404 status code. So, we create a new instance of `Phalcon\Http\Response`
    and set the status code, and with that same response, we are redirected back to
    the index of our posts. Notice that instead of using `$this->flash`, we are using
    `$this->flashSession`, because we are using a true HTTP redirect rather than an
    internal forward, so we need to store the message in the user's session.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法实际上并没有太多内容。它接收我们的帖子ID并检查我们的帖子是否有效。如果是，我们将`view`变量的帖子设置为我们的`$post`对象，以便我们可以在视图中使用它。但是如果没有帖子，我们至少要设置一个404状态码。因此，我们创建了一个新的`Phalcon\Http\Response`实例并设置了状态码，然后使用相同的响应，我们将被重定向回帖子索引。请注意，我们不是使用`$this->flash`，而是使用`$this->flashSession`，因为我们使用的是真正的HTTP重定向而不是内部转发，所以我们需要在用户的会话中存储消息。
- en: Now that our controller is doing everything we want it to do, let's take a look
    at our views.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然我们的控制器正在做我们想要它做的事情，让我们来看看我们的视图。
- en: Examining our Post views
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查我们的帖子视图
- en: Well, we didn't do any manual edits on our model, and we only made a few changes
    to our controller. But we are going to make a lot of changes to our views. They
    need a lot of work. So, we are not going to compare much of our generated code
    with our final code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们没有在我们的模型上做任何手动编辑，我们只对我们的控制器做了一些修改。但是，我们将对我们的视图进行大量的修改。它们需要很多工作。因此，我们不会将生成的代码与最终代码比较太多。
- en: Fortunately, when we installed Phalcon web tools in our application, it installed
    Twitter Bootstrap for us. And as it is already there, we are going to use it.
    As this is a book on the Phalcon framework and not Twitter Bootstrap, I won't
    be explaining much of what we are doing with it. We will just use it. Twitter
    Bootstrap is a frontend framework that makes styling easier. You can read more
    about it at [http://getbootstrap.com/](http://getbootstrap.com/).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，当我们在应用中安装Phalcon网络工具时，它为我们安装了Twitter Bootstrap。由于它已经存在，我们将使用它。由于这是一本关于Phalcon框架的书，而不是Twitter
    Bootstrap，我不会过多解释我们用它做了什么。我们只是使用它。Twitter Bootstrap是一个前端框架，它使样式化更容易。您可以在[http://getbootstrap.com/](http://getbootstrap.com/)上了解更多关于它的信息。
- en: 'We know from [Chapter 2](ch02.html "Chapter 2. Setting Up a Phalcon Project"),
    *Setting Up a Phalcon Project*, that every request in our application uses the
    `index.volt` file located at `app/views` to wrap the content returned from our
    views. If we want to add JavaScript or CSS globally to our application, this would
    be where we would want to include it. The code is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从[第二章](ch02.html "第二章。设置Phalcon项目")，*设置Phalcon项目*中了解到，我们应用中的每个请求都使用位于`app/views`的`index.volt`文件来包装从视图返回的内容。如果我们想在应用中全局添加JavaScript或CSS，这就是我们想要包含它的地方。代码如下：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Well, we added quite a bit of markup to support Twitter Bootstrap. We included
    the `css` files that we need in order to use Bootstrap in the header and the JavaScript
    in the footer. In the `navbar` div, we have links to the main parts of our site.
    We have a search form in the sidebar that currently searches only the body field,
    but we will be changing that later. Then, we output our content. We now have a
    responsive layout for our blog using Phalcon's own built-in Volt template engine.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们添加了很多标记来支持Twitter Bootstrap。我们在页眉中包含了我们需要使用Bootstrap的`css`文件，并在页脚中包含了JavaScript。在`navbar`
    div中，我们有指向我们网站主要部分的链接。我们在侧边栏中有一个搜索表单，目前它只搜索正文字段，但我们将稍后更改它。然后，我们输出我们的内容。我们现在使用Phalcon自带的内置Volt模板引擎为我们的博客提供了一个响应式布局。
- en: Volt uses {{…}} to print variables to the template, and {%...%} to assign variables
    or execute loops. The variables and function calls in Volt are very similar to
    the underlying PHP code, only without dollar signs. In the main part of our page,
    we use `content()`, which is a template tag for `$this->getContent()`. This tag
    is used here in the main layout. But you will also notice it in the controller
    layout as well as in the action views. The output of each view is served by the
    next one in the hierarchy using this variable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Volt使用{{…}}将变量打印到模板中，使用{%…%}分配变量或执行循环。Volt中的变量和函数调用与底层PHP代码非常相似，只是没有美元符号。在我们的页面主体部分，我们使用`content()`，这是一个代表`$this->getContent()`的模板标签。这个标签在这里用于主布局。但您也会在控制器布局以及动作视图中注意到它。每个视图的输出都通过层次结构中的下一个视图来提供，使用这个变量。
- en: There are three levels in this view hierarchy. The action view only renders
    when the action of a specific controller is called. The controller layout view
    will be shown for every action in the controller. And finally, the main layout
    view will be shown for every controller and action in the application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个视图层次结构中，有三个级别。动作视图仅在调用特定控制器的动作时渲染。控制器布局视图将在控制器的每个动作中显示。最后，主布局视图将在应用程序的每个控制器和动作中显示。
- en: For the links, we use the `link_to()` tag, which represents the `linkTo` view
    helper function of `Phalcon\Tag`. The first parameter is the path in our application,
    and the second is the anchor text we will use for the link.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于链接，我们使用`link_to()`标签，它代表`Phalcon\Tag`的`linkTo`视图助手函数。第一个参数是我们应用程序中的路径，第二个参数是我们将用于链接的锚文本。
- en: For the search form, we use the `form()` template tag, which builds the first
    HTML form tag for our form thanks to Phalcon's view helpers. To close the form,
    we use Volt's `end_form()` template tag. The first parameter we pass to this tag
    is the action attribute. The second parameter is the set of key-value pairs that
    translate into attributes in the HTML form tag. We add the `input-medium` class
    to our field to apply Twitter Bootstrap styles.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于搜索表单，我们使用`form()`模板标签，它利用Phalcon的视图助手构建了我们表单的第一个HTML表单标签。为了关闭表单，我们使用Volt的`end_form()`模板标签。我们传递给这个标签的第一个参数是action属性。第二个参数是一组键值对，这些键值对将转换为HTML表单标签的属性。我们给我们的字段添加了`input-medium`类来应用Twitter
    Bootstrap样式。
- en: For the search form field, we again use another Volt tag that represents a Phalcon
    view helper. The `text_field()` tag accepts the name of our field as its first
    parameter. And the second parameter is again a key-value pair that translates
    to HTML tag attributes. We add the `btn` class to our submit button.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于搜索表单字段，我们再次使用另一个代表Phalcon视图助手的Volt标签。`text_field()`标签接受我们字段的名称作为其第一个参数。第二个参数再次是一个键值对，它转换为HTML标签属性。我们给我们的提交按钮添加了`btn`类。
- en: Posts layout
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Posts布局
- en: 'The layout that wraps the results of every action in the Posts controller is
    loacted in the `posts.volt` file at `app/views/layouts`. There is not much in
    this file. If we wanted to add markup to every view that our Posts model uses,
    we would do it here. We are going to remove the `align="center"` attribute from
    the `div`, so it looks like the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 包裹Posts控制器中每个动作结果的布局位于`app/views/layouts`目录下的`posts.volt`文件中。这个文件中内容不多。如果我们想为我们的Posts模型使用的每个视图添加标记，我们就会在这里做。我们将从`div`中移除`align="center"`属性，使其看起来像以下代码：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Index action view
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引动作视图
- en: 'The view for index action is in the `index.volt` file located at `app/views/posts`.
    This page originally held a search form. But we changed the `indexAction` function
    in our controller to list the most recent blog posts. We are going to have to
    make a lot of changes to this file, which will actually result in less overall
    markup as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 索引动作视图位于`app/views/posts`目录下的`index.volt`文件中。这个页面最初包含一个搜索表单。但我们将控制器中的`indexAction`函数更改为列出最新的博客文章。我们将不得不对这个文件进行很多修改，这实际上将导致整体标记更少，如下所示：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In Volt, we use {%...%} to represent loops and control structures. In this view,
    we wrap everything in an `if` tag, which checks if our `page` object generated
    by the paginator in our controller contains any items. The results in the `page`
    object are stored in this `item` variable. If we have items, we loop through them,
    setting the `post` object to what we find. We can access the variables in this
    `post` object using the dot syntax. To print out the post excerpt, we use `post.excerpt`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Volt中，我们使用{%...%}来表示循环和控制结构。在这个视图中，我们将一切包裹在一个`if`标签中，该标签检查我们控制器中分页器生成的`page`对象是否包含任何项目。`page`对象中的结果存储在这个`item`变量中。如果有项目，我们就遍历它们，将`post`对象设置为找到的内容。我们可以使用点符号访问这个`post`对象中的变量。要打印帖子摘要，我们使用`post.excerpt`。
- en: And finally, we have the paginator part of our paginator. Along with the items,
    our paginator object contains details about the results. We can use `page.before`
    to access the page number of the current page, `page.next` for the next page number,
    and `past.last` for the last page. At the end of the links, we print the current
    page number and the total number of pages.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有了分页器的分页部分。除了项目外，我们的分页器对象还包含有关结果的信息。我们可以使用`page.before`来访问当前页的页码，`page.next`用于下一页的页码，`past.last`用于最后一页。在链接的末尾，我们打印当前页码和总页数。
- en: Search action view
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索动作视图
- en: 'Now, we will take a look at the view for the search action in the `search.volt`
    file located at `app/views/posts`. The code is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看位于`app/views/posts`目录下的`search.volt`文件中的搜索动作视图。代码如下：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we have much of what we have seen in the other views. The form has more
    fields, so that each field in our posts can be searched. Then, we have a loop
    to print out the results of our searches, similar to the index action view, and
    at the end, we have our pager to browse the results.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了在其他视图中看到的大部分内容。表单有更多的字段，这样我们就可以搜索我们帖子中的每个字段。然后，我们有一个循环来打印搜索结果，类似于索引动作视图，最后，我们有我们的分页器来浏览结果。
- en: Edit action view
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑动作视图
- en: Next, we have the view for the edit action in the `edit.volt` file located at
    `app/views/posts`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有位于`app/views/posts`目录下的`edit.volt`文件中的编辑动作视图。
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we again have the `content` tag and `form` tags for all the fields that
    we need to edit in our post. And at the end, we have our submit button; everything
    that we will need to edit a post.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次有`content`标签和`form`标签，用于编辑我们帖子中需要编辑的所有字段。最后，我们有我们的提交按钮；我们将需要编辑帖子的一切。
- en: New action view
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新动作视图
- en: 'Last but not least, the view for the new action in the `new.volt` file located
    at `app/views/posts` which uses the same template tags we covered in the other
    action views. The code for our view is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，位于`app/views/posts`目录下的`new.volt`文件中的新动作视图，它使用了我们在其他动作视图中介绍过的相同模板标签。我们视图的代码如下：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we worked on the model, view, and controller for the posts
    in our blog. To do this, we used Phalcon web tools to generate our CRUD scaffolding
    for us. Then, we modified this generated code so it would do what we need it to
    do. We can now add posts. We also learned about the Volt template engine.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们为博客中的帖子工作在模型、视图和控制器。为此，我们使用Phalcon网络工具为我们生成CRUD脚手架。然后，我们修改了生成的代码，使其能够完成我们需要的任务。我们现在可以添加帖子。我们还了解了Volt模板引擎。
- en: In the next chapter, we will create more models and take a look at the various
    ways Phalcon handles data, including session data, relationships between models,
    filtering and sanitizing data, PHQL, and Phalcon's Object-Document Mapper.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建更多模型，并查看Phalcon处理数据的各种方式，包括会话数据、模型之间的关系、数据过滤和清理、PHQL以及Phalcon的对象-文档映射器。
