- en: Chapter 3. Using Phalcon Models, Views, and Controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will start building a functional blog application. Using Phalcon Developer
    Tools, we will generate our models, controllers, and views, and then examine the
    code in sufficient detail so that we can write it ourselves if we have to. We
    will also learn about forms in Phalcon, which are in the arsenal of view helpers
    that are components we can use repeatedly in our application. There is no need
    to reinvent the wheel here. We will also look at the Volt template engine, which
    is built into Phalcon.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of the Model-View-Controller pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Phalcon model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Phalcon controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Phalcon view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Volt template engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Phalcon view helpers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP has changed a lot over the years. In the beginning, it wasn't even object-oriented.
    But that was added in PHP 3, and has improved in the PHP versions since then.
    These changes led the way for PHP-based frameworks. And most of these frameworks
    use the MVC pattern, which was made popular by both Python's Django and Ruby's
    Ruby on Rails, for use in web frameworks. Let's briefly review each part of the
    MVC pattern.
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The view outputs the user interface. This is its only job. Sometimes, a view
    includes a template engine such as Smarty or Phalcon's own built-in template engine,
    Volt. We will be using Volt in our blog project. But the truth is that since you
    can mix `PHP` and `HTML` in the same file, PHP itself acts like a template engine.
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Controllers are the switchboard operators of our application. The actions in
    a controller pass parameters to the view to display and respond to user input.
    When we fill out a blog form in our application and click on the **Save** button,
    the data we posted is sent through our controller. As we are creating a blog post,
    the controller uses its `createAction` function to create a new post instance
    in our model. When this is done, it sends a message back to our view stating that
    our post was successful.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the logic of our application should reside in the model. It should know
    that each one of our blog posts has a user that posted it, and that these two
    things are related. It should also know that each blog post can have one or many
    tags. If we have a database connected to our application, the model should handle
    the changes to the database. When we create a new post in our application, our
    controller simply passes the data we posted in our form to the correct action.
    Our model should handle the creation of the new post's record in the database
    as well as any records that relate to the user who posted it or the tags we added
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can get Phalcon Developer Tools to generate any more files for us,
    we need a database. The project skeleton was the easy part. We now need to generate
    the model, controller, and view files. So, let's create our database. For the
    purpose of this book, I am going to give examples using raw SQL queries, so you
    can execute them via the command line or your chosen database tool, and examples
    using phpMyAdmin, which can be downloaded for free from [http://www.phpmyadmin.net](http://www.phpmyadmin.net).
    This also requires that you have MySQL installed on your machine, which can be
    downloaded for free from [http://www.mysql.com](http://www.mysql.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need our database. The following is the command to create the database
    we need for our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In phpMyAdmin, you could just click on the **Databases** tab, enter `phalconblog`
    in the **Create new database** section of the page, and click on the **Create**
    button, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a database](img/7673OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we just need to create the table for our blog posts. We will worry about
    the other tables later. The following is the SQL code for our blog `posts` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you are using phpMyAdmin, browse to your `phalconblog` database, click on
    the **SQL** tab, and paste the previous SQL code. Then click on the **Go** button
    and your table will be ready.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a database](img/7673OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have a simple table to hold our blog posts. It has a unique ID that autoincrements
    a title field for the title of our post, a body field to hold the body, an excerpt
    field to hold the summary of our post for pages such as our home page and category
    pages, a published date field, an updated date field, and two fields to hold the
    ping status of our post.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a table in place, we can use Phalcon Developer Tools to create
    a model file for our blog posts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open `http://localhost/phalconBlog/webtools.php` in your browser if that is
    where your project is running. If not, browse to the index page of your project
    and add `/webtools.php` to the URL. The `webtools.php` file is located in the
    same folder as the bootstrap file. You should see a page in your browser that
    looks something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a model](img/7673OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are going to generate a model file for our `posts` table. Phalcon Developer
    Tools connect to our database using the setting we put in our `Ini` file and then
    load all the table names in the **Table name** select list. So, select the `posts`
    table from the select list and click on the **Generate** button. You also have
    the options to add setters and getters to your class, set foreign keys for related
    tables, and define relations. You can also force web tools to generate the model
    file even if it already exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other option is to use the command-line developer tools. You will need
    to open a terminal instance, navigate to your `phalconBlog` project folder, and
    type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `posts` is the name of the table for which a model file is being generated.
    The command line in the Phalcon Developer Tools also has options. In fact, there
    are more options available here than on the web interface. You can list all these
    options by calling the command without a table name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command should print out options as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a model](img/7673OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Any one of the commands will print out a similar list of options if called without
    any options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, we should find the `Posts.php` file in our `models` folder
    in `app`, and we will find the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We went through all of that and really didn't get much, but it was better than
    typing out all these variables manually. Phalcon extracted the column names out
    of our `posts` table, created a `Posts model` class, and turned these names into
    member variables in our class. It's a start. We can also create a controller using
    web tools.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also create your controller with web tools. Just click on the **Controllers**
    tab on the Phalcon web tools menu and then enter your controller name in the **Controller
    name** field of the form, which in our case is `Posts`, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a controller](img/7673OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As with the model we created, we can use the following command-line tools to
    create our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this will be a new `PostsController.php` file located at `app/controllers`
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There is not much to this file, just our `PostsController` class with one `indexAction`
    function. But things are about to get a lot more interesting. Let's build the
    CRUD functions for our Posts model.
  prefs: []
  type: TYPE_NORMAL
- en: Creating CRUD scaffolding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CRUD stands for create, read, update, and delete, which are the four basic
    functions our application should do with our blog post records. Phalcon web tools
    will also help us to get these built. Click on the **Scaffold** tab on the web
    tools page and you will see a page as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating CRUD scaffolding](img/7673OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select `posts` from the **Table name** list and `volt` from the **Template engine**
    list, and check **Force** this time, because we are going to force our new files
    to overwrite the old model and controller files that we just generated. Click
    on the **Generate** button and some magic should happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browse to `http://localhost/phalconBlog/posts` and you will see a page like
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating CRUD scaffolding](img/7673OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We finally have some functionality we can use. We have no posts, but we can
    create some. Click on the **Create posts** link and you will see a page similar
    to the one we were just at. The form will look nearly the same, but it will have
    a **Create posts** heading. Fill out the **Title**, **Body**, and **Excerpt**
    fields and click on the **Save** button. The form will post, and you will get
    a message stating that the post was created successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will take you back to the post''s index page. Now you should be able to
    search for and find the post you just created. If you forgot what you posted,
    you can click on **Search** without entering anything in the fields, and you should
    see a page like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating CRUD scaffolding](img/7673OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is not a very pretty or user-friendly blog application. But it got us started,
    and that's all we need. The next time we start a Phalcon project, it should only
    take a few minutes to go through these steps. Now we will look over our generated
    code, and as we do, modify it to make it more blog-like.
  prefs: []
  type: TYPE_NORMAL
- en: Examining our Posts model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you open up `Posts.php` file located at `app/model`, you may notice that
    it has not changed since we generated it the first time. Even with our new CRUD
    scaffolding, it still just contains our Posts model class and our database column
    names as member variables. There is no SQL involved on the PHP side.
  prefs: []
  type: TYPE_NORMAL
- en: The `Phalcon\MVC\Model` path is the base class of all models that your application
    will use. All the SQL code that is involved happens inside of the Phalcon PHP
    extension. There will be times when we have to make SQL queries, but for now,
    we have given our Posts model CRUD capabilities, search capabilities, and the
    ability to relate to other models without even knowing what database software
    our application is going to use. We could modify our `services.php` file located
    at `app/config` to use another database adapter if we decide that we no longer
    want to use MySQL and want to use Oracle instead. The code for our application
    would work the same as long as our database tables are structured the same.
  prefs: []
  type: TYPE_NORMAL
- en: Our Posts model currently does everything we need it to do with minimum code,
    so we won't be modifying it in this chapter. Now let's look at our controller.
  prefs: []
  type: TYPE_NORMAL
- en: Examining our Posts controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s open `PostsController.php` file located at `app/controllers` in
    our editor. There is definitely a lot going on in this file. There are seven methods
    in our `PostsController` class suffixed with actions. Each of these actions handles
    requests and creates responses in our application. Each corresponds to a URI in
    our application: `http://localhost/phalconBlog/[model]/[action]`. When we browse
    to `http://www.localhost/phalconBlog/posts/`, by default, the `indexAction` function
    is called.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at each of these actions and modify them if we need to.
  prefs: []
  type: TYPE_NORMAL
- en: Create
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at the `createAction` function, which saves our new blog posts
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: First, we should learn a little about `Phalcon\Mvc\Dispatcher`. The dispatcher
    is another one of the services that was loaded in our Dependency Injection container.
    The dispatcher takes the request object and instantiates a controller based on
    the attributes of that object. When a controller is instantiated, it acts as a
    listener for dispatcher events. Since everything in the Dependency Injection container
    can be accessed as a property of the controller, we can access the dispatcher
    in a controller with `$this->dispatcher`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another object in our Dependency Injection container that we should know about
    is the request object, which stores details about the HTTP request and is passed
    between the dispatcher and the controller. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, our method checks if the request is a post by querying the request object
    from our dispatcher container. If the request is not a post, `$this->dispatcher->forward`
    is called, and our dispatcher forwards the requests to the `indexAction` function
    in our posts controller, where the dispatch loop starts up again.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are posting a new blog post, then the method continues executing and
    a post object is created. We can access the data we posted in our form with `$this->request->getPost()`,
    and our code assigns each parameter from this request object to an attribute of
    our `$post` instance. In many cases, it would be easier to replace this series
    of assignments with one line of code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: But we will be setting some of these variables in our controller later in the
    book, so we will leave them as they are. Since Phalcon is handling all the details
    about our database behind the scenes, we can just call `$this->post->save()` to
    save our post to the database; there is no need for SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the code checks if our post has been saved, and if it hasn''t, it uses
    the flashing messages'' service that is embedded in Phalcon to store the error
    message with `$this->flash->error`, while the application forwards us back to
    the form. If the post was successfully created, we are forwarded to the index
    with a successful message as `$this->flash->success`. The flashing messages''
    service provides our application with the ability to give users notification of
    the status of their actions. There are four message types in the flashing messages''
    services:'
  prefs: []
  type: TYPE_NORMAL
- en: Error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Success
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we want to set custom classes for our messages when they are served by our
    view, we can add the following code to the `services.php` file in `config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: From then on, any error message served by our application will be given both
    the alert and alert-error classes. The `Phalcon\Flash\Direct` is a variant of
    `Phalcon\Flash`, which immediately outputs the messages passed to it. Another
    variant is `Phalcon\Flash\Session`, which temporarily stores the messages in the
    user's session to be output in the next request.
  prefs: []
  type: TYPE_NORMAL
- en: Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s take a look at our `searchAction` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of our function, we set a `$numberPage` variable to `1`. This
    is because we use the Phalcon paginator that we loaded into our Phalcon services
    container in our bootstrap file. We will be using that variable to tell the paginator
    what page of results will be loaded, and if there is no `page` parameter, then
    we want to load the first page of results.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our code checks if there is a POST request, and if there is, we
    use the `fromInput` function in `Phalcon\Mvc\Model\Criteria` to change the parameters
    in our post into an array that we can use to query our Posts model. We persist
    the parameters in the session by creating a variable parameter in `$this->persist`,
    which is a Phalcon class that persists variables between sessions. This enables
    our code to load a second page of results from a search query without adding parameters
    to the URL. The only parameter needed to load a second page of search results
    is `page`. If there is no post, we set the `$numberPage` variable to the `page`
    parameter from the GET request with `getQuery`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we set a local `$parameters` variable to our persistent parameters, and
    we will use this variable to query our Posts model using the `find` function,
    storing the results in `$posts`. Then, the code checks if the post has any results
    and sets a flash message to tell us when there are no posts in our `posts` table.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we finally get to the paginator we mentioned at the beginning of this
    section. We create it by setting the `data` parameter to the `$posts` variable,
    setting the `limit` parameter to the count of records we want for each page, which
    in this case is `10`, and then set the `page` parameter to our `$numberPage` variable.
    Then, we set the `page` variable of our `view` object to the `page` object that
    our paginator returns, which holds the paginated blog post's results.
  prefs: []
  type: TYPE_NORMAL
- en: Index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `indexAction` function currently doesn''t do much. The index view shows
    the user a search form. We are going to change that because we want it to show
    a list of our most recent posts, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to change it to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You will notice a difference in the `PostsController` class that we generated
    compared to the one we wrote from scratch at the beginning of the chapter. Phalcon
    Developer Tools generated a `ControllerBase` class for us so that we can add universal
    variables and functionality to it. We can then extend this class to create the
    controllers for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are using part of the functionality we saw in the `searchAction` function.
    We set the page number for the paginator by using the `getQuery` function of `Phalcon\Http\Request`.
    The first `page` parameter is the GET variable we want, the second parameter is
    the type we expect this parameter to be, for example, an integer, and the third
    parameter is the default value, which we set to `1` for the first page. Then,
    we instantiate the paginator and set the `view page` variable to the results from
    our paginator. But we use the static `query` function from `Phalcon\MVC\Model`
    to execute our query in an object-oriented manner, ordering our posts by the published
    date (which we have not yet set, but we will do so). We will learn more about
    interacting with Phalcon models and databases in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: New
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is nothing in the new action method, literally. The action is still called
    and the view that holds our new post form will be served:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Edit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next method we will examine is our `editAction` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You will notice the `$id` parameter in this function. Any additional URI parameters
    after the parameter for the action are action parameters. They are assigned in
    the same order that the route passes them in. First, our action checks if the
    request was a post. If not, it skips the rest of the functionality and loads the
    view. If it is a post, we create an instance of our Posts object and use its `findFirstByid`
    method to load our blog post into the `$post` variable. We check if our `$post`
    variable contains data and then set our view's ID variable to the ID of the blog
    post. If we want, we can also replace these multiple assignments that Phalcon
    Developer Tools generated for us with the following loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `Phalcon\Tag` is a view helper class that will generate HTML for our application.
    By calling `$this->tag->setDefault` in our action, we can set the default value
    of a form element with the attribute of the same name. So, by calling `$this->tag->setDefault("id",
    $post->id)`, we set the default ID form input to the ID of our post instance.
  prefs: []
  type: TYPE_NORMAL
- en: Save
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s check out our `saveAction` function using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This method is very similar to the create method. This one is called when we
    are saving a post that we are editing. This is another place where, if we wish,
    we can replace the multiple lines of assignments with a loop, like we did in the
    `createAction` function. The only real difference in this method is that when
    a post is not saved successfully, we pick the view that we want to show using
    `$this->view->pick()`, and then we set the `$post` variable in the view to the
    one just created. This way, the content is still saved in the browser if the new
    post fails to save. If we were to simply forward it to the `editAction` function,
    it would again look up the post by its `id` and wipe out our changes. We use the
    same view, we just bypass the action.
  prefs: []
  type: TYPE_NORMAL
- en: Delete
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following function is the `deleteAction` function in our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing fancy happening here. The method tries to delete the post by
    calling `$post->delete`, and gives us an error message if it wasn't deleted and
    a success message if it was.
  prefs: []
  type: TYPE_NORMAL
- en: Show
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to have to add an action to our controller to view each post by
    itself. This will be easy because our `editAction` function does some of the same
    things that we need our `showAction` function to do. We need our controller to
    pass a post instance to our view based on a post ID. The following is our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There is not really much to this method. It takes in our post ID and checks
    if our post is valid. If it is, we set the `view` variable's post to our `$post`
    object so we can use it in our view. But if there is no post, we want to at least
    set a 404 status code. So, we create a new instance of `Phalcon\Http\Response`
    and set the status code, and with that same response, we are redirected back to
    the index of our posts. Notice that instead of using `$this->flash`, we are using
    `$this->flashSession`, because we are using a true HTTP redirect rather than an
    internal forward, so we need to store the message in the user's session.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our controller is doing everything we want it to do, let's take a look
    at our views.
  prefs: []
  type: TYPE_NORMAL
- en: Examining our Post views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, we didn't do any manual edits on our model, and we only made a few changes
    to our controller. But we are going to make a lot of changes to our views. They
    need a lot of work. So, we are not going to compare much of our generated code
    with our final code.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, when we installed Phalcon web tools in our application, it installed
    Twitter Bootstrap for us. And as it is already there, we are going to use it.
    As this is a book on the Phalcon framework and not Twitter Bootstrap, I won't
    be explaining much of what we are doing with it. We will just use it. Twitter
    Bootstrap is a frontend framework that makes styling easier. You can read more
    about it at [http://getbootstrap.com/](http://getbootstrap.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'We know from [Chapter 2](ch02.html "Chapter 2. Setting Up a Phalcon Project"),
    *Setting Up a Phalcon Project*, that every request in our application uses the
    `index.volt` file located at `app/views` to wrap the content returned from our
    views. If we want to add JavaScript or CSS globally to our application, this would
    be where we would want to include it. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Well, we added quite a bit of markup to support Twitter Bootstrap. We included
    the `css` files that we need in order to use Bootstrap in the header and the JavaScript
    in the footer. In the `navbar` div, we have links to the main parts of our site.
    We have a search form in the sidebar that currently searches only the body field,
    but we will be changing that later. Then, we output our content. We now have a
    responsive layout for our blog using Phalcon's own built-in Volt template engine.
  prefs: []
  type: TYPE_NORMAL
- en: Volt uses {{…}} to print variables to the template, and {%...%} to assign variables
    or execute loops. The variables and function calls in Volt are very similar to
    the underlying PHP code, only without dollar signs. In the main part of our page,
    we use `content()`, which is a template tag for `$this->getContent()`. This tag
    is used here in the main layout. But you will also notice it in the controller
    layout as well as in the action views. The output of each view is served by the
    next one in the hierarchy using this variable.
  prefs: []
  type: TYPE_NORMAL
- en: There are three levels in this view hierarchy. The action view only renders
    when the action of a specific controller is called. The controller layout view
    will be shown for every action in the controller. And finally, the main layout
    view will be shown for every controller and action in the application.
  prefs: []
  type: TYPE_NORMAL
- en: For the links, we use the `link_to()` tag, which represents the `linkTo` view
    helper function of `Phalcon\Tag`. The first parameter is the path in our application,
    and the second is the anchor text we will use for the link.
  prefs: []
  type: TYPE_NORMAL
- en: For the search form, we use the `form()` template tag, which builds the first
    HTML form tag for our form thanks to Phalcon's view helpers. To close the form,
    we use Volt's `end_form()` template tag. The first parameter we pass to this tag
    is the action attribute. The second parameter is the set of key-value pairs that
    translate into attributes in the HTML form tag. We add the `input-medium` class
    to our field to apply Twitter Bootstrap styles.
  prefs: []
  type: TYPE_NORMAL
- en: For the search form field, we again use another Volt tag that represents a Phalcon
    view helper. The `text_field()` tag accepts the name of our field as its first
    parameter. And the second parameter is again a key-value pair that translates
    to HTML tag attributes. We add the `btn` class to our submit button.
  prefs: []
  type: TYPE_NORMAL
- en: Posts layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The layout that wraps the results of every action in the Posts controller is
    loacted in the `posts.volt` file at `app/views/layouts`. There is not much in
    this file. If we wanted to add markup to every view that our Posts model uses,
    we would do it here. We are going to remove the `align="center"` attribute from
    the `div`, so it looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Index action view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The view for index action is in the `index.volt` file located at `app/views/posts`.
    This page originally held a search form. But we changed the `indexAction` function
    in our controller to list the most recent blog posts. We are going to have to
    make a lot of changes to this file, which will actually result in less overall
    markup as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In Volt, we use {%...%} to represent loops and control structures. In this view,
    we wrap everything in an `if` tag, which checks if our `page` object generated
    by the paginator in our controller contains any items. The results in the `page`
    object are stored in this `item` variable. If we have items, we loop through them,
    setting the `post` object to what we find. We can access the variables in this
    `post` object using the dot syntax. To print out the post excerpt, we use `post.excerpt`.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we have the paginator part of our paginator. Along with the items,
    our paginator object contains details about the results. We can use `page.before`
    to access the page number of the current page, `page.next` for the next page number,
    and `past.last` for the last page. At the end of the links, we print the current
    page number and the total number of pages.
  prefs: []
  type: TYPE_NORMAL
- en: Search action view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will take a look at the view for the search action in the `search.volt`
    file located at `app/views/posts`. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have much of what we have seen in the other views. The form has more
    fields, so that each field in our posts can be searched. Then, we have a loop
    to print out the results of our searches, similar to the index action view, and
    at the end, we have our pager to browse the results.
  prefs: []
  type: TYPE_NORMAL
- en: Edit action view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we have the view for the edit action in the `edit.volt` file located at
    `app/views/posts`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we again have the `content` tag and `form` tags for all the fields that
    we need to edit in our post. And at the end, we have our submit button; everything
    that we will need to edit a post.
  prefs: []
  type: TYPE_NORMAL
- en: New action view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Last but not least, the view for the new action in the `new.volt` file located
    at `app/views/posts` which uses the same template tags we covered in the other
    action views. The code for our view is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked on the model, view, and controller for the posts
    in our blog. To do this, we used Phalcon web tools to generate our CRUD scaffolding
    for us. Then, we modified this generated code so it would do what we need it to
    do. We can now add posts. We also learned about the Volt template engine.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create more models and take a look at the various
    ways Phalcon handles data, including session data, relationships between models,
    filtering and sanitizing data, PHQL, and Phalcon's Object-Document Mapper.
  prefs: []
  type: TYPE_NORMAL
