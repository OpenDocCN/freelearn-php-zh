- en: Drupal 8 Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing secure code is an important aspect of any web application. Preventing
    ever-so-creative hacking techniques can be really daunting, and this is partly
    the reason why we, as developers, sometimes choose a well-established framework
    with solid and up-to-date security measures baked right in.
  prefs: []
  type: TYPE_NORMAL
- en: Drupal is a CMS that takes security very seriously. The community has a dedicated
    security team that is always on the lookout for vulnerabilities and advises core
    contributors and module developers on ways to fix potential vectors of attack.
    It is also responsible for the fast mitigation of any such issue and disseminating
    the correct information to the affected parties.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to out-of-the-box installation, Drupal 8 has come a long way in
    addressing many security concerns present in previous versions, to the point where
    much of what Drupal 7 developers had to worry about can now be taken for granted.
    For this reason, in this annex, we will talk about some of the most prominent
    security features that Drupal 8 comes with out of the box and that are directly
    related to our work as module developers. Moreover, we will take a look at some
    tips for ensuring that the modules we write respect the security standards Drupal
    prides itself on.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Scripting (XSS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drupal 7 was not inherently vulnerable to XSS attacks but made it easy for novice
    developers to open such vulnerabilities. The PHP-based templating system, in particular,
    made it easy for developers to forget to properly sanitize user input and any
    other kind of data before outputting it. Moreover, it allowed novice developers
    to perform all kinds of business logic directly in the template. Apart from not
    keeping a separation of concerns (business logic versus presentation), this also
    meant that third-party themes were much more difficult to validate and could easily
    include security holes.
  prefs: []
  type: TYPE_NORMAL
- en: Most of these concerns have been addressed in Drupal 8, in principal with the
    adoption of Twig as the templating system. There are two main consequences of
    this adoption. The first one addresses the need for separating presentation from
    business logic. In other words, themers and developers can no longer directly
    access Drupal's APIs, nor can they run SQL queries from templates. To expose any
    such functionality, Twig extensions and filters can be used, but they require
    the logic to be encapsulated inside a module.
  prefs: []
  type: TYPE_NORMAL
- en: The second consequence is in the form of Twig auto-escaping. This means that
    any string not specifically marked as safe will be escaped by Twig using the native
    PHP `htmlspecialchars()` function. This provides a level of safety that previously
    had to be actively sought manually by themers and developers using functions such
    as `check_plain()`.
  prefs: []
  type: TYPE_NORMAL
- en: Sanitization methods in Drupal 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Twig auto-escapes any string that is output using the normal notation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, there are cases in which the variable has already been marked safe,
    and Twig no longer escapes it. This is usually in the case of `MarkupInterface`
    objects, such as `FilteredMarkup` or `FormattableMarkup`. In these cases, Twig
    assumes that the strings they wrap have already been sanitized and that they can
    be output as they are. Of course, it is then up to us, as module developers, to
    ensure that we don't use any such objects with strings that contain unsanitized
    user input.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a popular example of such an object we use all the time, and then
    we will talk about the different ways we can sanitize our user input.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember, throughout this book we used the `t()` function (and the `StringTranslationTrait`
    method) which returns a `TranslatableMarkup` object used for translating strings.
    Printing such an object inside Twig will prevent auto-escaping because Twig already
    considers it safe. Moreover, if you remember, this applies to the main string
    only, as any placeholders we use do get escaped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if there were no security implications, we should not be passing user
    input or variables to `TranslatableMarkup`, as that hinders the actual purpose
    of these objects—to translate the string. However, for other `MarkupInterface`
    objects, there are a few ways we can treat user input or strings of a dubious
    origin in order to prepare them for Twig:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Drupal\Component\Utility\Html::escape()`: This is the strictest sanitization
    function used to print plain text. It uses PHP''s `htmlspecialchars()` to convert
    special characters to HTML entities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Drupal\Component\Utility\Xss::filter()`: This filters HTML to prevent XSS
    attacks. It allows a few basic HTML elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Drupal\Component\Utility\Xss::filterAdmin()`: This is a very permissive XSS
    filter that allows through most HTML elements apart from things like `<script>`
    or `<style>`. It should be used only for known and safe sources of input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Drupal\Component\Utility\UrlHelper::filterBadProtocol()`: This strips dangerous
    protocols from URLs. It should be used before printing the HTML attribute value
    when the URLs are obtained from user input or unsafe sources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, depending on the case, using one of the previous sanitization methods will
    prevent XSS attacks when dealing with markup that Twig doesn't escape.
  prefs: []
  type: TYPE_NORMAL
- en: Double escaping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since Twig already does much of the work for us, it''s also important not to
    go overboard with escaping. Veteran Drupal 7 developers may have a tendency to
    escape things like there is no tomorrow, but this can have unintended consequences.
    For example, imagine the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Twig is auto-escaping, the following string will be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So there is no visible change as the string was safe. However, imagine that
    we were overzealous with our sanitization and did this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we would get the following title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That is because the first time it is escaped, Drupal turns the apostrophe into
    an HTML entity (`'`). However, the browser renders it correctly, so we don't actually
    see it. The second escaping turns the individual characters from that HTML entity
    into *their* respective HTML entities. In this case, the `&` character gets turned
    into `&amp;`. So, the entire string is no longer properly readable by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: I now draw your attention for a moment to [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml),
    *Theming*. In that chapter, we saw that the `#markup` and `#plain_text` properties
    already serve to sanitize the user input passed through them. The first uses the
    `Xss::filterAdmin()` method, whereas the latter uses the `Html::escape()` method.
    So, keep in mind that if you use those as part of your render arrays, you may
    not need further sanitization.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL Injection still remains a very popular vector attack on vulnerable applications
    that incorrectly make use of database drivers. Luckily, by using the Drupal 8
    database abstraction layer, we go a long way toward ensuring protection against
    such vulnerabilities. All we have to do is use it correctly.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to Entity queries, there isn't much we can do wrong. However,
    when using the Database API directly, as we did in [Chapter 8](c20b297a-3a37-46ff-a80c-bf83a21bbd5d.xhtml),
    *The Database API*, we have to pay attention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, vulnerabilities have to do with improper placeholder management.
    For example, we should never do things like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is regardless of what `$variable` is—direct user input or otherwise. Because
    by using that direct concatenation, malicious users may inject their own instructions
    and complete the statement in a different way than intended. Instead, we should
    use code like we did in [Chapter 8](c20b297a-3a37-46ff-a80c-bf83a21bbd5d.xhtml),
    *The Database API*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In other words, use placeholders that will then be sanitized by the API to ensure
    that no characters are allowed to form malicious statements.
  prefs: []
  type: TYPE_NORMAL
- en: Drupal 8 comes with an additional security improvement when it comes to SQL
    injection vulnerabilities—single statement executions. Up until recently, the
    PHP PDO driver (which Drupal extended since Drupal 7) did not have a flag in place
    to inform MySQL to execute only a single statement at a time. Theoretically, vulnerabilities
    caused by appending multiple statements were possible (with one painful example
    of an attack that marked the Drupal community forever—SA-CORE-2014-005). However,
    this has been changed, and Drupal now sends this flag via PDO to the database
    engine to prevent multiple statements from being executed at once. So, we get
    this extra bit of protection.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Request Forgery (CSRF)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CSRF attacks are another popular way that applications can be overtaken, by
    forcing a user with elevated privileges to execute unwanted actions on their own
    site. Usually this happens when certain URLs on the application trigger a process
    simply by being accessed through the browser (and by being authenticated): for
    example, deleting a resource.'
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing to consider in this respect is to never have such actions
    happening simply by accessing a URL. To help with this, we have the powerful Form
    API, which already had token-based CSRF protection embedded from previous versions
    of Drupal. So basically you can create forms whose submit handlers perform the
    potentially damaging actions (as we learned in [Chapter 2](601b4dd0-c521-459e-9342-2645a109642c.xhtml),
    *Creating Your First Module*) or even add a second layer using a confirmation
    form (as we saw in [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml), *Data
    Modeling and Storage*, and [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml),
    *Your Own Custom Entity and Plugin Types*, when talking about entities). The latter
    is actually recommended for when the action is irreversible or has greater implications.
  prefs: []
  type: TYPE_NORMAL
- en: Although the Form API should account for most use cases, we may also encounter
    the need to declare a callback URL that directly handles the process. And, to
    protect ourselves from CSRF attacks, we can use the CSRF token system as we saw
    in [Chapter 10](bb49e98d-7db0-4969-95fc-a2bad6d4f1db.xhtml), *Access Control*,
    when we talked about the various types of access control. I recommend that you
    check out that chapter for more information on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drupal 8 has come a long way with locking down its APIs to attack vulnerabilities.
    Of course, this does not mean it's perfect, nor that a bad developer cannot create
    security holes. For this reason, it's extremely important to pay attention to
    the security implications of all the code you write, follow the standards (including
    the OWASP checklist), and be aware of what contributed modules you use (to at
    least be covered by the Drupal security team). Moreover, it's also very important
    to keep up to date with security announcements from the Drupal security team as
    new vulnerabilities may be discovered and updates required to remedy them. These
    are more time-sensitive in some cases than others, but it's always good to stay
    up to date as quickly as possible (by following the communication from the Drupal
    security team). Luckily, though, historically speaking, Drupal has not had many
    security crises—at least not compared to other open source frameworks out there.
    So from a security standpoint, it has a good reputation. However, do not take
    this to mean that you, as a module developer, are unburdened by the heavy responsibility
    for keeping your application safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed three transitional vulnerabilities web applications
    usually face, how Drupal 8 stands against these, and what we as module developers
    can, and should, do to protect ourselves from them: XSS, SQL Injection, and CSRF.
    Of course, there are many more things that we can do from an application and server
    maintenance point of view. However, these fall outside the scope of what this
    book focuses on. I strongly encourage you, though, to read all the available documentation
    on security in Drupal 8 and keep yourself informed.'
  prefs: []
  type: TYPE_NORMAL
- en: Wow. Can you believe you just finished the last chapter of this book and you
    can finally go play ping pong? Yes, do take that needed break as it was not an
    easy journey, although I hope a productive one. Once you are done, and back in
    front of the keyboard, I strongly encourage you to revisit the sections that seemed
    more complicated to you. Do this while checking and navigating the Drupal core
    code to understand and see for yourself the concepts in action. No resource will
    ever be better than the code itself, and the main goal of this book was to point
    you in the right directions. There are so many more cool things to learn and this
    process never stops. If you are interested, you will learn every day. I do.
  prefs: []
  type: TYPE_NORMAL
