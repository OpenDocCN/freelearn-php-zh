- en: Chapter 8. Frontend Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Frontend development is a term most commonly tied to producing HTML, CSS, and
    JavaScript for a website or web application. Interchangeably, it addresses accessibility,
    usability, and performance toward reaching a satisfying user experience. Various
    levels of customization we want to apply to our web store require different development
    skill levels. We can make relatively simple changes to our store using just CSS.
    These would be the changes where we accept the structure of the store and focus
    only on visuals like changing colors and images. This might be a good starting
    point for less experienced developers and those new to the Magento platform. A
    more involved approach would be to make changes to the output generated by Magento
    modules. This usually means tiny bits of PHP knowledge, mostly *copy-paste-modify*
    of existing code fragments. A skill level above this one would imply knowledge
    of making structural changes to our store. This usually means mastering Magento's
    moderately sophisticated layout engine, where we make changes through XML definitions.
    The final and highest skill level for Magento frontend development implies the
    modification of existing or new custom functionality development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we will take a deep dive through the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block architecture and life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Themes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Magento application entry point is its `index.php` file. All of the HTTP
    requests go through it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze the (trimmed) version of the `index.php` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`PART-1-1` of the preceding code simply includes `/app/bootstrap.php` into
    the code. What happens inside the bootstrap is the inclusion of `app/autoload.php`
    and `app/functions.php`. The functions file contains a single `__()` function,
    used for translation purposes, returning an instance of the `\Magento\Framework\Phrase`
    object. Without going into the details of the auto-load file, it is suffice to
    say it handles the auto-loading of all our class files across Magento.'
  prefs: []
  type: TYPE_NORMAL
- en: '`PART-1-2` is simply a static create method call to obtain the instance of
    the `\Magento\Framework\App\Bootstrap` object, storing it into the `$bootstrap`
    variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '`PART-1-3` is calling the `createApplication` method on the `$bootstrap` object.
    What is happening within `createApplication` is nothing more than using object
    manager to create and return the object instance of the class we are passing to
    it. Since we are passing the `\Magento\Framework\App\Http` class name to the `createApplication`
    method, our `$app` variable becomes the instance of that class. What this means,
    effectively, is that our web store app is an instance of `Magento\Framework\App\Http`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`PART-1-4` is calling the run method on the `$bootstrap` object, passing it
    the instance of the `Magento\Framework\App\Http` class. Although it looks like
    a simple line of code, this is where things get complicated, as we will soon see.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze the (trimmed) version of the `\Magento\Framework\App\Bootstrap`
    `->` `run` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `PART-2-1` handles the sort of housekeeping bits. It
    initializes the custom error handler, initializes the object manager, checks if
    our application is in maintenance mode, and checks that it is installed.
  prefs: []
  type: TYPE_NORMAL
- en: '`PART-2-2` looks like a simple line of code. Here, we are calling the `launch`
    method on `$application`, which is the `Magento\Framework\App\Http` instance.
    Without going into the inner workings of the `launch` method for the moment, let''s
    just say it returns the instance of the `Magento\Framework\App\Response\Http\Interceptor`
    class defined under `var/generation/Magento/Framework/App/Response/Http/Interceptor.php`.
    Note that this is an automatically generated wrapper class, extending the `\Magento\Framework\App\Response\Http`
    class. Effectively, ignoring `Interceptor`, we can say that `$response` is an
    instance the `\Magento\Framework\App\Response\Http` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `PART-2-3` calls the `sendResponse` method on `$response`. Though `$response`
    is an instance of the `\Magento\Framework\App\Response\Http` class, the actual
    `sendResponse` method is found further down the parent tree on the `\Magento\Framework\HTTP\PhpEnvironment\Response`
    class. The `sendResponse` method calls another parent class method called `send`.
    The `send` method can be found under the `Zend\Http\PhpEnvironment\Response` class.
    It triggers the `sendHeaders` and `sendContent` methods. This is where the actual
    output gets sent to the browser, as the `sendHeaders` method is using PHP's `header`
    function and `echo` construct to push the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reiterate on the preceding, the flow of execution as we understand it comes
    down to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.php`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\App\Bootstrap` `->` `run`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\App\Http` `->` `launch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\App\Response\Http` `->` `sendResponse`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though we have just made it to the end of the bootstrap's `run` method, it would
    be unfair to say we covered the rendering flow, as we barely touched it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to take a step back and take a detailed look at `PART-2-2`, the inner
    workings of the `launch` method. Let''s take a look at the (trimmed) version of
    the `\Magento\Framework\App\Http` `->` `launch` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`PART-3-1` creates the instance of the object whose class conforms to `\Magento\Framework\App\FrontControllerInterface`.
    If we look under `app/etc/di.xml`, we can see there is a preference for `FrontControllerInterface`
    in favor of the `\Magento\Framework\App\FrontController` class. However, if we
    were to debug the code and check for the actual instance class, it would show
    `Magento\Framework\App\FrontController\Interceptor`. This is Magento adding an
    interceptor wrapper that then extends `\Magento\Framework\App\FrontController`,
    which we expected from the `di.xml` preference entry.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the real class behind the `$frontController` instance, we know
    where to look for the `dispatch` method. The `dispatch` method is another important
    step in understanding the rendering flow process. We will look into its inner
    workings in a bit more detail later on. For now, let's focus back on the `$result`
    variable of `PART-3-2`. If we were to debug the variable, the direct class behind
    it would show as `Magento\Framework\View\Result\Page\Interceptor`, defined under
    the dynamically created `var/generation/Magento/Framework/View/Result/Page/Interceptor.php`
    file. `Interceptor` is the wrapper for the `\Magento\Framework\View\Result\Page`
    class. Thus, it is safe to say that our `$result` variable is an instance of the
    `Page` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `Page` class extends `\Magento\Framework\View\Result\Layout`, which further
    extends `\Magento\Framework\Controller\AbstractResult` and implements `\Magento\Framework\Controller\ResultInterface`.
    Quite a chain we have here, but it is important to understand it.
  prefs: []
  type: TYPE_NORMAL
- en: Notice `PART-3-3`. Since our `$result` is an instance of `\Magento\Framework\Controller\ResultInterface`,
    we fall into the first `if` condition that calls the `renderResult` method. The
    `renderResult` method itself is declared within the `\Magento\Framework\View\Result\Layout`
    class. Without going into the details of `renderResult`, suffice to say that it
    adds HTTP headers, and content to the `$this->_response` object passed to it.
    That same response object is what the `launch` method returns, as we described
    before in `PART-2-2`.
  prefs: []
  type: TYPE_NORMAL
- en: Though `PART-3-3` does not depict any return value, the expression `$result->renderResult($this->_response)`
    does not do any output on its own. It modifies `$this->_response` that we finally
    return from the `launch` method as shown in `PART-3-4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reiterate on the preceding, the flow of execution as we understand it comes
    down to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.php`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\App\Bootstrap` `->` `run`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\App\Http` `->` `launch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\App\FrontController` `->` `dispatch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\View\Result\Page` `->` `renderResult`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\App\Response\Http` `->` `sendResponse`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we mentioned while explaining `PART-3-2`, the `dispatch` method is another
    important step in the rendering flow process. Let''s take a look at the (trimmed)
    version of the `\Magento\Framework\App\FrontController` `->` `dispatch` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`PART-4-1` and `PART-4-2` in the preceding code shows (almost) the entire `dispatch`
    method body contained within a loop. The loop does 100 iterations, further looping
    through all available router types, thus giving each router 100 times to find
    a route `match`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The router list loop includes routers of the following class types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Magento\Framework\App\Router\Base`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Magento\UrlRewrite\Controller\Router`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Magento\Cms\Controller\Router`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Magento\Framework\App\Router\DefaultRouter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the listed routers implement `\Magento\Framework\App\RouterInterface`,
    making them all have the implementation of the `match` method.
  prefs: []
  type: TYPE_NORMAL
- en: A module can further define new routers if they choose so. As an example, imagine
    if we are developing a `Blog` module. We would want our module catching all requests
    on a URL that starts with a `/blog/` part. This can be done by specifying the
    custom router, which would then show up on the preceding list.
  prefs: []
  type: TYPE_NORMAL
- en: '`PART-4-3` shows the `$actionInstance` variable storing the result of the router
    `match` method call. As per `RouterInterface` requirements, the `match` method
    is required to return an instance whose class implements `\Magento\Framework\App\ActionInterface`.
    Let''s imagine we are now hitting the URL `/foggyline_office/test/crud/` from
    the module we wrote in [Chapter 4](part0028_split_000.html#QMFO2-818f5224668745eb9070ddf1d85e6bfa
    "Chapter 4. Models and Collections"), *Models and Collections*. In this case,
    our `$router` class would be `\Magento\Framework\App\Router\Base` and our `$actionInstance`
    would be of the class `\Foggyline\Office\Controller\Test\Crud\Interceptor`. Magento
    automatically adds `Interceptor`, through the dynamically generated `var/generation/Foggyline/Office/Controller/Test/Crud/Interceptor.php`
    file. This `Interceptor` class further extends our module `\Foggyline\Office\Controller\Test\Crud`
    class file. The `Crud` class extends `\Foggyline\Office\Controller\Test`, which
    further extends `\Magento\Framework\App\Action\Action`, which implements `\Magento\Framework\App\ActionInterface`.
    After a lengthy parent-child tree, we finally got to `ActionInterface`, which
    is what our `match` method is required to return.'
  prefs: []
  type: TYPE_NORMAL
- en: '`PART-4-4` shows the `dispatch` method being called on `$actionInstance`. This
    method is implemented within `\Magento\Framework\App\Action\Action`, and is expected
    to return an object that implements `\Magento\Framework\App\ResponseInterface`.
    Internal to `dispatch`, the `execute` method is called, thus running the code
    within our `Crud` controller action `execute` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming our `Crud` controller action execute method does not return nothing,
    the `$result` object becomes an instance of `Magento\Framework\App\Response\Http\Interceptor`,
    which is wrapped around `\Magento\Framework\App\Response\Http`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine our `Crud` class has been defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Debugging the `$result` variable now shows it's an instance of `\Magento\Framework\View\Result\Page\Interceptor`.
    This `Interceptor` gets dynamically generated by Magento under `var/generation/Magento/Framework/View/Result/Page/Interceptor.php`
    and is merely a wrapper for `\Magento\Framework\View\Result\Page`. This `Page`
    class further extends the `\Magento\Framework\View\Result\Layout` class, and implements
    `\Magento\Framework\App\ResponseInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `PART-4-4` shows the `$result` object of type `\Magento\Framework\View\Result\Page`
    being returned from the `FrontController` `dispatch` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reiterate on the preceding, the flow of execution as we understand it comes
    down to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.php`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\App\Bootstrap` `->` `run`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\App\Http` `->` `launch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\App\FrontController` `->` `dispatch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\App\Router\Base` `->` `match`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\App\Action\Action` `->` `dispatch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\View\Result\Page` `->` `renderResult`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\App\Response\Http` `->` `sendResponse`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a nutshell, what we as frontend developers should know is that returning
    the Page type object from our controller action will automatically call the `renderResult`
    method on that object. `Page` and `Layout` is where all the theme translations,
    layout, and template loading are triggering.
  prefs: []
  type: TYPE_NORMAL
- en: View elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Magento's primary view elements are its UI Components, containers, and blocks.
    The following is a brief overview of each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Ui components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Under the `vendor/magento/framework/View/Element/` folder, we can find `UiComponentInterface`
    and `UiComponentFactory`. The full set of `Ui` components is located under the
    `vendor/magento/framework/View/Element/` directory. Magento implements `UiComponent`
    through a separate module called `Magento_Ui`. Thus, the components themselves
    are located under the `vendor/magento/module-ui/Component/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Components implement `UiComponentInterface`, which is defined under the `vendor/magento/framework/View/Element/UiComponentInterface.php`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how `BlockInterface` extends `BlockInterface`, whereas `BlockInterface`
    defines only one method requirement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `Block` is an element of the interface, `UiComponent` can be looked at
    as an advanced block. Let''s take a quick look at the `_renderUiComponent` method
    of the `\Magento\Framework\View\Layout` class, (partially) defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that `UiComponent` is rendered in the same way as block, by calling
    the `toHtml` method on the component. The `vendor/magento/module-ui/view/base/ui_component/etc/definition.xml`
    file contains an extensive list of several `UiComponents` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dataSource`: `Magento\Ui\Component\DataSource`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`listing`: `Magento\Ui\Component\Listing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paging`: `Magento\Ui\Component\Paging`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filters`: `Magento\Ui\Component\Filters`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container`: `Magento\Ui\Component\Container`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`form`: `Magento\Ui\Component\Form`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`price`: `Magento\Ui\Component\Form\Element\DataType\Price`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image`: `Magento\Ui\Component\Form\Element\DataType\Media`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nav`: `Magento\Ui\Component\Layout\Tabs\Nav`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: … and many more
  prefs: []
  type: TYPE_NORMAL
- en: 'These components are mostly used to construct a listing and filters in the
    admin area. If we do a string search for `uiComponent` across the entire Magento,
    we would mostly find entries like the one in `vendor/magento/module-cms/view/adminhtml/layout/cms_block_index.xml`
    with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The value `cms_block_listing` of `uiComponent`'s `name` attribute refers to
    the name of the `vendor/magento/module-cms /view/adminhtml/ui_component/cms_block_listing.xml`
    file. Within the `cms_block_listing.xml` file, we have a listing component defined
    across more than a few hundreds lines of XML. Listing component then `dataSource`,
    `container`, `bookmark`, `filterSearch`, `filters`, and so on. We will not go
    into the details of these declarations, as our focus here is on more general frontend
    bits.
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Containers have no block classes related to them. Container renders all of its
    children automatically. They allow the configuration of some attributes. Simply
    attach any element to a container and it will render it automatically. With a
    container, we can define wrapping tags, CSS classes, and more.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot create instances of containers because they are an abstract concept,
    whereas we can create instances of blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Containers are rendered via the `_renderContainer` method of the `Magento\Framework\View\Layout`
    class, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Containers support the following extra attributes: `htmlTag`, `htmlClass`,
    `htmlId`, and `label`. To make a little demonstration of a container in action,
    let us make sure we have a module from [Chapter 4](part0028_split_000.html#QMFO2-818f5224668745eb9070ddf1d85e6bfa
    "Chapter 4. Models and Collections"), *Models and Collections* in place, and then
    create the `view/frontend/layout/foggyline_office_test_crud.xml` file within the
    module root folder `app/code/Foggyline/Office/` with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding XML defines a single container named `foobar`, and within the
    container there are two block elements named `foo` and `bar`. It should kick in
    when we open `http://{our-shop-url}/index.php/foggyline_office/test/crud/` in
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how the container itself is not nested within any other element, rather
    directly into the body. We could have easily nested into some other container
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Either way, we should see the strings **The Foo** and **The Bar** shown in
    the browser, with a full-page layout loaded, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Containers](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although containers determine the layout of the page, they do not contain actual
    content directly. Pieces that contain the content and are nested within containers
    are called **blocks**. Each block can contain any number of child content blocks
    or child containers. Thus, mostly every web page in Magento is formed as a mix
    of blocks and containers. Layout defines a sequence of blocks on the page, not
    their location. The look and feel of the blocks is determined by CSS and how the
    page is rendered. When we speak of blocks, we almost always implicitly refer to
    templates as well. Templates are the thing that actually draw elements within
    a page; blocks are the thing that contain the data. In other words, templates
    are PHTML or HTML files pulling data through variables or methods sent on a linked
    PHP block class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Magento defines the `Magento\Framework\View\Result\Page` type under `app/etc/di.xml`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the template argument is set to `Magento_Theme::root.phtml`. When `Page`
    gets initialized, it picks up the `vendor/magento/module-theme/view/base/templates/root.phtml`
    file. `root.phtml` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Variables within `root.phtml` are assigned during the `Magento\Framework\View\Result\Page`
    render method call as (partially) as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The expression `$this->assign` is what assigns variables like `layoutContent`
    to the `root.phtml` template. `layoutContent` is generated based on base layouts,
    together with all layout updates for the current page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whereas base layouts include the following XMLs within `vendor/magento/module-theme/view/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`base/page_layout/empty.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frontend/page_layout/1column.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frontend/page_layout/2columns-left.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frontend/page_layout/2columns-right.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frontend/page_layout/3columns.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression `$this->getLayout()->getOutput()` is what gets all blocks marked
    for output. It basically finds elements in a layout, renders them, and returns
    the string with its output. Along the way, the event `core_layout_render_element`
    gets fired, giving us one possible way of affecting the output result. At this
    point, most of the elements on the page are rendered. This is important because
    blocks play a big role here. The rendering system will take `empty.xml` into account,
    as it too consists of a list of containers, and every container has some blocks
    attached to it by other layout updates.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a nutshell, each container has blocks assigned to it. Each block usually
    (but not always) renders a template. The template itself may or may not call other
    blocks, and so on. Blocks are rendered when they are called from the template.
  prefs: []
  type: TYPE_NORMAL
- en: Block architecture and life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blocks are another one of the primary view elements in Magento. At the root
    of the parent tree structure, blocks extend from the `Magento\Framework\View\Element\AbstractBlock`
    class and implement `Magento\Framework\View\Element\BlockInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: '`BlockInterface` sets only one requirement, the implementation of the `toHtml`
    method. This method should return blocks HTML output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking inside `AbstractBlock`, we can see it has a number of methods declared.
    Among the most important ones are the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_prepareLayout`: Prepares a global layout. We can redefine this method in
    child classes for changing the layout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addChild`: Creates a new block, sets it as a child of the current block, and
    returns the newly created block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_toHtml`: Returns an empty string. We need to override this method in descendants
    to produce HTML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_beforeToHtml`: Returns `$this`. Executes before rendering HTML, but after
    trying to load a cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_afterToHtml`: Processing block HTML after rendering. Returns a HTML string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toHtml:` Produces and returns a block''s HTML output. This method should not
    be overridden. We can override the `_toHtml` method in descendants if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `AbstractBlock` execution flow can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_prepareLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toHtml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_beforeToHtml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_toHtml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_afterToHtml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It starts with `_prepareLayout` and flows through a set of methods until it
    reaches `_afterToHtml`. This is, in essence, what we need to know about block
    execution flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important block types are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Magento\Framework\View\Element\Text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Magento\Framework\View\Element\Text\ListText`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Magento\Framework\View\Element\Messages`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Magento\Framework\View\Element\Template`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these blocks are basically an implementation of an abstract block. Since
    the `_toHtml` method in `AbstractBlock` returns only an empty string, all of these
    descendants are implementing their own version of the `_toHtml` method.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the usage of these blocks, we can use our previously created
    `app/code/Foggyline/Office/view/frontend/layout/foggyline_office_test_crud.xml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Text` block has a `setText` method we can use to set its content. The
    way we instantiate the `Text` block and set its text value through the layout
    file is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ListText` block extends from `Text`. However, it does not really support
    the use of `setText` to set its content. This is obvious just by looking at its
    code, where the `$this->setText('''')` expression is immediately called within
    its `_toHtml` method implementation. Instead, what happens is that the `_toHtml`
    method loops through any child blocks it might have and calls the layout''s `renderElement`
    method on it. Basically, we might compare the `ListText` block to `container`,
    as it has nearly the same purpose. However, unlike container, block is a class
    so we can manipulate it from PHP. The following is an example of using `ListText`,
    containing a few child `Text` blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Messages` block supports four methods that we can use to add content to
    output: `addSuccess`, `addNotice`, `addWarning`, and `addError`. The following
    is an example instantiating the `Messages` block through the layout update file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example should be taken with caution, since calling these setter
    methods in layout is not the proper way to do it. The default `Magento_Theme`
    module already defines the `Messages` block that uses `vendor/magento/module-theme/view/frontend/templates/messages.phtml`
    for message rendering. Thus, for most of the part there is no need to define our
    own messages block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s look at the example of the `Template` block as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding XML will instantiate the `Template` type of block and render the
    content of the `view/frontend/templates/office/no4/template.phtml` file within
    the `app/code/Foggyline/Office/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: On the PHP level, instantiating a new block can be accomplished using the layout
    object, or directly through the object manager. The layout approach is the preferred
    way. With regard to the previous examples in XML, let's see their alternatives
    in PHP (assuming `$resultPage` is an instance of `\Magento\Framework\View\Result\PageFactory`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of instantiating the `Text` type of block and adding
    it as a child of the content container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ListText` version is done in PHP as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we first made an instance of the `ListText` block and assigned it
    as a child of an element named content. Then we created two individual `Text`
    blocks and assigned them as a child of an element named `example_2`, which is
    our `ListText`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s define the `Messages` block as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s look at the `Template` block type, which we initiate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Whenever possible, we should set our blocks using XML layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to utilize the most common types of Magento blocks, let's
    see how we can create our own block type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining our own `block` class is as simple as creating a custom class file
    that extends `Template`. This `block` class should be placed under our module
    `Block` directory. Using our `Foggyline_Office` module, let''s create a file,
    `Block/Hello.php`, with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code simply creates a new custom block class. We can then call
    this `block` class through our layout file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, within our module `app/code/Foggyline/Office/` directory, we create
    a template file, `view/frontend/templates/office/hello.phtml`, with content as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To further understand what is happening here within the template file, let's
    take a deeper look at templates themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Templates** are snippets of HTML mixed with PHP. The PHP part includes elements
    such as variables, expressions, and `class` method calls. Magento uses the PHTML
    file extension for template files. Templates are located under an individual module''s
    `view/{_area_}/templates/ directory`.'
  prefs: []
  type: TYPE_NORMAL
- en: In our previous example, we referred to our module template file with an expression
    like `Foggyline_Office::office/hello.phtml`. Since templates can belong to different
    modules, we should prepend the template with the module name as a best practice.
    This will help us locate template files and avoid file conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple naming formula goes like this: we type the name of the module, double
    single colon, and then the name. Thus making a template path like `office/hello.phtml`
    equaling to `Foggyline_Office::office/hello.phtml`.'
  prefs: []
  type: TYPE_NORMAL
- en: Within the PHTML template file we often have various PHP expressions like `$block->helloPublic()`.
    Notice the block class `Foggyline\Office\Block\Hello` in the preceding XML. An
    instance of this block class becomes available to us in `hello.phtml` through
    the `$block` variable. Thus, an expression like `$block->helloPublic()` is effectively
    calling the `helloPublic` method from an instance of the `Hello` class. The `Hello`
    class is not one of the Magento core classes, but it does extend `\Magento\Framework\View\Element\Template`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `hello.phtml` template also has two more expressions: `$block->helloProtected()`
    and `$block->helloPrivate()`. However, these are not executed as template files
    can only see public methods from their `$block` instances.'
  prefs: []
  type: TYPE_NORMAL
- en: The `$this` variable is also available within the PHTML template as an instance
    of the `Magento\Framework\View\TemplateEngine\Php` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding template code example, we could have easily replaced `$block->helloPublic()`
    with the `$this->helloPublic()` expression. The reason why this would work lies
    in the template engine `Php` class, (partially) defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Given that templates are included in the context of the engine rather than in
    the context of the block, `__call` redirects methods calls to the current block.
    Similarly, `__isset` redirects `isset` calls to the current block and `__get`
    allows read access to properties of the current block.
  prefs: []
  type: TYPE_NORMAL
- en: Though we can use both `$block` and `$this` for the same purpose within the
    template file, we should really opt for using `$block`.
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect of templates is their fallback mechanism. Fallback
    is the process of defining a full template path given only its relative path.
    For example, `office/hello.phtml` falls back to the `app/code/Foggyline/Office/view/frontend/templates/office/hello.phtml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Path resolution starts from the _`toHtml` method defined on the `Magento\Framework\View\Element\Template`
    class. The _`toHtml` method then calls `getTemplateFile` within the same class,
    which in turn calls `getTemplateFileName` on `resolver`, which is an instance
    of `\Magento\Framework\View\Element\Template\File\Resolver`. Looking further,
    resolver's `getTemplateFileName` further calls `getTemplateFileName` on `_viewFileSystem`,
    which is an instance of `\Magento\Framework\View\FileSystem`. The method `getFile`
    is further called on an instance of `\Magento\Framework\View\Design\FileResolution\Fallback\TemplateFile`.
    `getFile` further triggers the resolve method on the `Magento\Framework\View\Design\FileResolution\Fallback\Resolver\Simple`
    instance, which further calls the `getRule` method on the `Magento\Framework\View\Design\Fallback\RulePool`
    instance. The `RulePoll` class is the final class in the chain here. `getRule`
    finally calls the `createTemplateFileRule` method, which creates the rule that
    detects where the file is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'While running the `getRule` method, Magento checks against the following types
    of fallback rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`file`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`locale`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worth spending some time to study the inner workings of the `RulePool`
    class, as it showcases detailed fallbacks for the listed rules.
  prefs: []
  type: TYPE_NORMAL
- en: Layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up to this point, we briefly touched on layout XMLs. Layout XML is a tool to
    build the pages of the Magento application in a modular and flexible manner. It
    enables us to describe the page layout and content placement. Looking at XML root
    nodes, we differentiate two types of layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`layout`: XML wrapped in `<layout>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page`: XML wrapped in `<page>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Page` layouts represent a full page in HTML, whereas `layout` layouts represent
    a part of a page. The `layout` type is a subset of the `page` layout type. Both
    types of layout XML files are validated by the XSD schema found under the `vendor/magento/framework/View/Layout/etc/`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`layout` – `layout_generic.xsd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page` – `page_configuration.xsd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the application components that provide `<layout>` and `<page>` elements
    , we can further section them as base and theme layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The base layouts are provided by the modules, usually at the following locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<module_dir>/view/frontend/layout`: page configuration and generic layout
    files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<module_dir>/view/frontend/page_layout`: page layout files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The theme layouts are provided by the themes, usually at the following locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<theme_dir>/<Namespace>_<Module>/layout`: page configuration and generic layout
    files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<theme_dir>/<Namespace>_<Module>/page_layout`: page layout files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Magento will load and merge all module and theme XML files on the appropriate
    page. Once files are merged and XML instructions are processed, the result is
    rendered and sent to the browser for display. Having two different layout XML
    files, where both reference the same block, means that the second one with the
    same name in the sequence will replace the first one.
  prefs: []
  type: TYPE_NORMAL
- en: When the XML files are loaded, Magento applies an inheritance theme at the same
    time. We can apply a theme and it will look for the parent until a theme without
    a parent is reached.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the merging of files from each module, layout files from within
    module directories can also be extended or overridden by themes. Overriding layout
    XML is not a good practice, but it might be necessary sometimes.
  prefs: []
  type: TYPE_NORMAL
- en: To *override* the base layout files provided by the module within the `<module_dir>/view/frontend/layout/`directory.
  prefs: []
  type: TYPE_NORMAL
- en: We need to create an XML file with the same name in the `app/design/frontend/<vendor>/<theme>/<Namespace_Module>/layout/override/base/`directory.
  prefs: []
  type: TYPE_NORMAL
- en: To *override* the theme layout files provided by the parent theme within the
    <`parent_theme_dir>/<Namespace>_<Module>/layout/`directory.
  prefs: []
  type: TYPE_NORMAL
- en: We need to create an XML file with the same name in the `app/design/frontend/<vendor>/<theme
    >/<Namespace_Module>/layout/override/theme/<Parent_Vendor>/<parent_theme>/`directory.
  prefs: []
  type: TYPE_NORMAL
- en: Layouts can be both overridden and extended.
  prefs: []
  type: TYPE_NORMAL
- en: The recommended way to customize layout is to extend it through a custom theme.
    We can do so by simply adding a custom XML layout file with the same name in the
    `app/design/frontend/{vendorName}/{theme}/{vendorName}_{moduleName}/layout/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Layouts, as we saw in previous examples, support a large number of directives:
    page page, head, block, and so on. The practical use of these directives and how
    they mix together is a challenge on its own. Giving full details on each and every
    directive is beyond the scope of this book. However, what we can do is to show
    how to figure out the use of an individual directive, which we might need at a
    given time. For that purpose, it is highly recommended to use an IDE environment
    like **NetBeans PHP** or **PhpStorm** that provide autocomplete on XMLs that include
    XSD.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of defining an external schema to PhpStorm, where
    we are simply saying that the `urn:magento:framework:View/Layout/etc/page_configuration.xsd`
    alias belongs to the `vendor/magento/framework/View/Layout/etc/page_configuration.xsd`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layouts](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This way, PhpStorm will know how to provide autocomplete while we type around
    XML files.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s take a look at how we could use the `css` directive to
    add an external CSS file to our page. With an IDE that supports autocomplete as
    soon as we type the `css` directive within the `page` | `head` element, autocomplete
    might throw out something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layouts](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A list of available attributes is shown, such as `src`, `sizes`, `ie_condtion`,
    `src_type`, and so on. IDEs like PhpStorm will allow us to right-click an element
    or its attribute and *go to the definition*. Looking into the definition for the
    `src` attribute gets us into the `vendor/magento/framework/View/Layout/etc/head.xsd`
    file that defines the `css` element as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'All of these are attributes we can set on the `css` element, and as such get
    their autocomplete as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layouts](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Although it is not required to use a robust IDE with Magento, it certainly helps
    to have one that understands XML and XSD files to the level of providing autocomplete
    and validation.
  prefs: []
  type: TYPE_NORMAL
- en: Themes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, Magento comes with two themes, named `Blank` and `Luma`. If we
    log in to the Magento admin area, we can see a list of available themes under
    the **Content** | **Design** | **Themes** menu, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Themes](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Magento themes support a parent-child relationship, something we noted previously,
    that is visible on the preceding image within the **Parent Theme** column.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new theme
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following steps outline the process of creating our own theme:'
  prefs: []
  type: TYPE_NORMAL
- en: Under `{Magento` `root` `directory}/app/design/frontend`, create a new directory
    bearing our vendor name, `Foggyline`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `vendor` directory, create a new directory bearing the theme name,
    `jupiter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the `jupiter` directory, create the `registration.php` file with content
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy `vendor/magento/theme-frontend-blank/theme.xml` into our theme, `app/design/frontend/Foggyline/jupiter/theme.xml`,
    changing the content as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the `app/design/frontend/Foggyline/jupiter/media/preview.jpg` image file
    to serve as the theme preview image (the one used in the admin area).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Optionally, create separate directories for static files such as styles, fonts,
    JavaScript, and images. These are stored within the `web` subdirectory of our
    theme `app/design/frontend/Foggyline/jupiter/` folder like follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`web/css/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web/css/source/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web/css/source/components/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web/images/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web/js/`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the theme `web` directory, we store general theme static files. If our
    theme contains module-specific static files, these are stored under the corresponding
    `vendor` module subdirectories, like `app/design/frontend/Foggyline/jupiter/{vendorName_moduleName}/web/`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Optionally, we can create the theme `logo.svg` image under our theme `web/images/`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we are done with the preceding steps, looking back into the admin area
    under the **Content** | **Design** | **Themes** menu, we should now see our theme
    listed as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new theme](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Whereas clicking on the row in the table next to our theme name would open
    a screen like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new theme](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how the previous two screens do not show any options to apply the theme.
    They are only listing out available themes and some basic information next to
    each theme. Our custom theme shows an interesting relationship, where a parent
    and a child theme can belong to different vendors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying the theme requires the following extra steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure our theme appears in the theme list, under the **Content** | **Design**
    | **Themes** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Stores** | **Settings** | **Configuration** | **General** | **Design**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Store View** drop-down field, we select the store view where we want
    to apply the theme, as shown in the upper-left corner of the following image:![Creating
    a new theme](img/00060.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Design Theme** tab, we select our newly created theme in the **Design
    Theme** drop-down, as shown on the right-hand side of the preceding image. Click
    **Save Config**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **System** | **Tools** | **Cache Management**, select and refresh the
    invalid cache types and click on the **Flush Catalog Images Cache**, **Flush JavaScript/CSS
    Cache**, and **Flush Static Files Cache** buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, to see our changes applied, reload the storefront pages in the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is a lot more to be said about themes that can fit in a book of its own.
    However, we will move on to the other important bits.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Magento makes use of quite a large number of JavaScript libraries, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Knockout: [http://knockoutjs.com](http://knockoutjs.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ext JS: [https://www.sencha.com/products/extjs/](https://www.sencha.com/products/extjs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'jQuery: [https://jquery.com/](https://jquery.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'jQuery UI: [https://jqueryui.com/](https://jqueryui.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'modernizr: [http://www.modernizr.com/](http://www.modernizr.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prototype: [http://www.prototypejs.org/](http://www.prototypejs.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RequireJS: [http://requirejs.org/](http://requirejs.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'script.aculo.us: [http://script.aculo.us/](http://script.aculo.us/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'moment.js: [http://momentjs.com/](http://momentjs.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Underscore.js: [http://underscorejs.org/](http://underscorejs.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'gruntjs: [http://gruntjs.com/](http://gruntjs.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AngularJS: [https://angularjs.org/](https://angularjs.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'jasmine: [http://jasmine.github.io/](http://jasmine.github.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: … and a few others
  prefs: []
  type: TYPE_NORMAL
- en: Though a frontend developer is not required to know the ins and outs of every
    library, it is recommended to at least have a basic insight into most of them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is worth running `find` `{MAGENTO-DIR}/` `-name` `\*.js` `>` `js-list.txt`
    on the console to get a full list of each and every JavaScript file in Magento.
    Spending a few minutes glossing over the list might serve as a nice future memo
    when working with JavaScript bits in Magento.
  prefs: []
  type: TYPE_NORMAL
- en: The RequireJS and jQuery libraries are probably the *most interesting* ones,
    as they often step into the spotlight during frontend development. RequireJS plays
    a big role in Magento, as it loads other JavaScript files. Using a modular script
    loader like RequireJS improves the speed of code. Speed improvement comes from
    removing JavaScript from the header and asynchronously or lazy loading JavaScript
    resources in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript resources can be specified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Library level for all libraries in the Magento code base (`lib/web`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module level for all libraries in a module (`app/code/{vendorName}/{moduleName}/view/{area}/web`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theme for all libraries in a theme (`app/design/{area}/{vendorName}/{theme}/{vendorName}_{moduleName}/web`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All libraries in a theme (`app/design/{area}/{vendorName}/{theme}/web`). Though
    possible, it is not recommended using this level to specify JavaScript resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended to specify JavaScript resources in the templates rather than
    in the layout updates. This way, we ensure processing of the resources through
    RequireJS.
  prefs: []
  type: TYPE_NORMAL
- en: To work with the RequireJS library, specify the mapping of JavaScript resources;
    that is, assign the aliases to resources. Use `requires-config.js` to create the
    mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our configurations more precise and specific for different modules/themes,
    we can identify mapping in the `requires-config.js` file at several levels depending
    on our needs. Configurations are collected and executed in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Library configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurations at the module level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurations at the theme module level for the ancestor themes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurations at the theme module level for a current theme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurations at the theme level for the ancestor themes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurations at the theme level for the current theme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we speak of JavaScript in Magento, we can hear various terms like component
    and widget. We can easily divide those terms by describing the type of JavaScript
    in Magento as per the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript component (JS component)**: This can be any single JavaScript
    file decorated as an **AMD** (short for **Asynchronous Module Definition**) module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ui component**: A JavaScript component located in the `Magento_Ui` module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jQuery UI widget**: A JavaScript component/widget provided by the jQuery
    UI library used in Magento'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jQuery widget**: A custom widget created using jQuery UI Widget Factory and
    decorated as an AMD module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two ways we can initialize a JavaScript component in template files:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `data-mage-init` attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `<script>` tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `data-mage-init` attribute is parsed on a DOM ready event. Since it is
    initialized on a certain element, the script is called only for that particular
    element, and is not automatically initialized for other elements of the same type
    on the page. An example of `data-mage-init` usage would be something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<script>` tag initialization is done without relation to any specific
    element, or in relation to a specific element but no direct access to the element.
    The script tag has to have an attribute, `type="text/x-magento-init"`. An example
    of `<script>` tag initialization would be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the situation and desired level of expressiveness, we can either
    opt for usage of `data-mage-init` or attribute or `<script>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom JS component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s go through a practical example of creating a JS component within our
    `Foggyline_Office` module in a form of the jQuery widget as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add our entry to `app/code/Foggyline/Office/view/frontend/requirejs-config.js`,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add the actual JavaScript `app/code/Foggyline/Office/view/frontend/web/js/foggyline-hello.js`
    with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we call our JavaScript component within some PHTML template, let''s
    say `app/code/Foggyline/Office/view/frontend/templates/office/hello.phtml`, as
    show:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Once we refresh the frontend, we should see the result of `alert(this.options)`
    in the browser showing `myVar1` and `myVar2`.
  prefs: []
  type: TYPE_NORMAL
- en: The `data-mage-init` part basically triggers as soon as the page loads. It is
    not triggered via some click or similar event on top of the `div` element; it
    is triggered on page load.
  prefs: []
  type: TYPE_NORMAL
- en: If we don't see the desired result in the browser, we might need to fully clear
    the cache in the admin area.
  prefs: []
  type: TYPE_NORMAL
- en: CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Magento uses a PHP port of the official LESS processor to parse the `.less`
    files into `.css` files. LESS is a CSS preprocessor that extends the CSS language
    by adding various features to it, like variables, mixins, and functions. All of
    this makes CSS more maintainable, extendable, and easier to theme. Frontend developers
    are thus expected to write LESS files that Magento then converts to appropriate
    CSS variants.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is worth running `find` `{MAGENTO-DIR}/` `-name` `\*.less` `>` `less-list.txt`
    on the console to get a full list of each and every LESS file in Magento. Spending
    a few minutes glossing over the list might serve as a nice future memo when working
    with style sheet bits in Magento.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can customize the storefront look and feel through one of the following
    approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: Override the default LESS files – only if our theme inherits from the default
    or any other theme, in which case we can override the actual LESS files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create our own LESS files using the built-in LESS preprocessor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create our own CSS files, optionally having compiled them using a third-party
    CSS preprocessor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within the individual frontend theme directory, we can find style sheets at
    the following locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{vendorName}_{moduleName}/web/css/source/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{vendorName}_{moduleName}/web/css/source/module/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web/css/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web/css/source/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CSS files can be included in a page through templates and layout files. A recommended
    way is to include them through layout files. If we want our style sheets to be
    available through all pages on the frontend, we can add using the `default_head_blocks.xml`
    file. If we look at the `blank` theme, it uses `vendor/magento/theme-frontend-blank/Magento_Theme/layout/default_head_blocks.xml`
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: All it takes is for us to copy this file in the same location under our custom
    theme; assuming it's the `jupiter` theme from the preceding examples, that would
    be `app/design/frontend/Foggyline/jupiter/Magento_Theme/layout/default_head_blocks.xml`.
    Then we simply modify the file to include our CSS.
  prefs: []
  type: TYPE_NORMAL
- en: When run, Magento will try to find the included CSS files. If a CSS file is
    not found, it then searches for the same filenames with a `.less` extension. This
    is part of the built-in preprocessing mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we started off by looking into the three aspects of the rendering
    flow process: the view, result object, and pages. Then we took a detailed look
    at three primary view elements: `ui-components`, `containers`, and `blocks`. We
    further studied blocks in depth, looking into their architecture and life cycle.
    We moved on to templates, looking into their locations, rendering, and fallback.
    Then came XML layouts, as the glue between blocks and templates. All of this gave
    us a foundation for further looking into theme structure, JavaScript components,
    and CSS. Along the way, we did a little bit of hands-on with a custom theme and
    JavaScript components creation. CSS and JavaScript is merely a fragment of what
    the Magento frontend is all about. Technology-wise, having a solid understanding
    of XML and even some PHP is more of a requirement than an exception for frontend-related
    development.'
  prefs: []
  type: TYPE_NORMAL
- en: The following chapter will introduce us to Magento's web API where we will learn
    how to authenticate, make API calls, and even build our own APIs.
  prefs: []
  type: TYPE_NORMAL
