- en: Chapter 8. Frontend Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 前端开发
- en: Frontend development is a term most commonly tied to producing HTML, CSS, and
    JavaScript for a website or web application. Interchangeably, it addresses accessibility,
    usability, and performance toward reaching a satisfying user experience. Various
    levels of customization we want to apply to our web store require different development
    skill levels. We can make relatively simple changes to our store using just CSS.
    These would be the changes where we accept the structure of the store and focus
    only on visuals like changing colors and images. This might be a good starting
    point for less experienced developers and those new to the Magento platform. A
    more involved approach would be to make changes to the output generated by Magento
    modules. This usually means tiny bits of PHP knowledge, mostly *copy-paste-modify*
    of existing code fragments. A skill level above this one would imply knowledge
    of making structural changes to our store. This usually means mastering Magento's
    moderately sophisticated layout engine, where we make changes through XML definitions.
    The final and highest skill level for Magento frontend development implies the
    modification of existing or new custom functionality development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前端开发是一个与生产网站或Web应用程序的HTML、CSS和JavaScript紧密相关的术语。它可以互换地涉及可访问性、可用性和性能，以达到令人满意的用户体验。我们想要应用到我们的网店的各种定制级别需要不同的开发技能水平。我们可以仅使用CSS对我们的网店进行相对简单的更改。这些更改将是我们接受网店结构，仅关注视觉上的更改，如更改颜色和图像。这可能是一个对经验较少的开发者和新接触Magento平台的人来说的好起点。更复杂的方法是对由Magento模块生成的输出进行更改。这通常意味着需要一点PHP知识，主要是对现有代码片段的*复制-粘贴-修改*。高于这个技能水平意味着我们需要了解如何对我们的网店进行结构性的更改。这通常意味着掌握Magento的相对复杂的布局引擎，通过XML定义进行更改。Magento前端开发的最终和最高技能水平意味着对现有或新的自定义功能进行修改。
- en: 'Throughout this chapter, we will take a deep dive through the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入以下部分：
- en: Rendering flow
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染流程
- en: View elements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图元素
- en: Block architecture and life cycle
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块架构和生命周期
- en: Templates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板
- en: XML layouts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML布局
- en: Themes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题
- en: JavaScript
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: CSS
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS
- en: Rendering flow
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染流程
- en: The Magento application entry point is its `index.php` file. All of the HTTP
    requests go through it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Magento应用程序的入口点是它的`index.php`文件。所有的HTTP请求都通过它进行。
- en: 'Let''s analyze the (trimmed) version of the `index.php` file as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式分析`index.php`文件的（裁剪）版本：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`PART-1-1` of the preceding code simply includes `/app/bootstrap.php` into
    the code. What happens inside the bootstrap is the inclusion of `app/autoload.php`
    and `app/functions.php`. The functions file contains a single `__()` function,
    used for translation purposes, returning an instance of the `\Magento\Framework\Phrase`
    object. Without going into the details of the auto-load file, it is suffice to
    say it handles the auto-loading of all our class files across Magento.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中的`PART-1-1`只是将`/app/bootstrap.php`包含到代码中。在引导过程中发生的事情是包含`app/autoload.php`和`app/functions.php`。函数文件包含一个`__()`函数，用于翻译目的，返回`\Magento\Framework\Phrase`对象的实例。不深入自动加载文件的细节，只需说它处理了所有我们的类文件在Magento中的自动加载。
- en: '`PART-1-2` is simply a static create method call to obtain the instance of
    the `\Magento\Framework\App\Bootstrap` object, storing it into the `$bootstrap`
    variable.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`PART-1-2`只是一个静态的创建方法调用，用于获取`\Magento\Framework\App\Bootstrap`对象的实例，并将其存储到`$bootstrap`变量中。'
- en: '`PART-1-3` is calling the `createApplication` method on the `$bootstrap` object.
    What is happening within `createApplication` is nothing more than using object
    manager to create and return the object instance of the class we are passing to
    it. Since we are passing the `\Magento\Framework\App\Http` class name to the `createApplication`
    method, our `$app` variable becomes the instance of that class. What this means,
    effectively, is that our web store app is an instance of `Magento\Framework\App\Http`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`PART-1-3`在`$bootstrap`对象上调用`createApplication`方法。在`createApplication`内部发生的事情不过是使用对象管理器创建并返回我们传递给它的类的对象实例。由于我们将`\Magento\Framework\App\Http`类的名称传递给`createApplication`方法，我们的`$app`变量就变成了该类的实例。这意味着，实际上，我们的网店应用是`Magento\Framework\App\Http`类的实例。'
- en: '`PART-1-4` is calling the run method on the `$bootstrap` object, passing it
    the instance of the `Magento\Framework\App\Http` class. Although it looks like
    a simple line of code, this is where things get complicated, as we will soon see.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`PART-1-4` 正在调用 `$bootstrap` 对象的 `run` 方法，并传递 `Magento\Framework\App\Http`
    类的实例。尽管这看起来像一行简单的代码，但正如我们很快将看到的，事情变得复杂起来。'
- en: 'Let''s analyze the (trimmed) version of the `\Magento\Framework\App\Bootstrap`
    `->` `run` method as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式分析 `\Magento\Framework\App\Bootstrap` 的 `->` `run` 方法的（裁剪）版本：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, `PART-2-1` handles the sort of housekeeping bits. It
    initializes the custom error handler, initializes the object manager, checks if
    our application is in maintenance mode, and checks that it is installed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`PART-2-1` 处理了一些家务事。它初始化了自定义错误处理器，初始化了对象管理器，检查我们的应用程序是否处于维护模式，并检查它是否已安装。
- en: '`PART-2-2` looks like a simple line of code. Here, we are calling the `launch`
    method on `$application`, which is the `Magento\Framework\App\Http` instance.
    Without going into the inner workings of the `launch` method for the moment, let''s
    just say it returns the instance of the `Magento\Framework\App\Response\Http\Interceptor`
    class defined under `var/generation/Magento/Framework/App/Response/Http/Interceptor.php`.
    Note that this is an automatically generated wrapper class, extending the `\Magento\Framework\App\Response\Http`
    class. Effectively, ignoring `Interceptor`, we can say that `$response` is an
    instance the `\Magento\Framework\App\Response\Http` class.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`PART-2-2` 看起来像一行简单的代码。在这里，我们正在调用 `$application` 的 `launch` 方法，而 `$application`
    是 `Magento\Framework\App\Http` 实例。暂时不深入探讨 `launch` 方法的内部工作原理，我们只需说它返回了在 `var/generation/Magento/Framework/App/Response/Http/Interceptor.php`
    下定义的 `Magento\Framework\App\Response\Http\Interceptor` 类的实例。请注意，这是一个自动生成的包装类，它扩展了
    `\Magento\Framework\App\Response\Http` 类。实际上，忽略 `Interceptor`，我们可以这样说，`$response`
    是 `\Magento\Framework\App\Response.Http` 类的实例。'
- en: Finally, `PART-2-3` calls the `sendResponse` method on `$response`. Though `$response`
    is an instance of the `\Magento\Framework\App\Response\Http` class, the actual
    `sendResponse` method is found further down the parent tree on the `\Magento\Framework\HTTP\PhpEnvironment\Response`
    class. The `sendResponse` method calls another parent class method called `send`.
    The `send` method can be found under the `Zend\Http\PhpEnvironment\Response` class.
    It triggers the `sendHeaders` and `sendContent` methods. This is where the actual
    output gets sent to the browser, as the `sendHeaders` method is using PHP's `header`
    function and `echo` construct to push the output.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`PART-2-3` 调用了 `$response` 的 `sendResponse` 方法。尽管 `$response` 是 `\Magento\Framework\App\Response.Http`
    类的实例，但实际的 `sendResponse` 方法是在父类树中的 `\Magento\Framework\HTTP\PhpEnvironment\Response`
    类中找到的。`sendResponse` 方法调用另一个父类方法，即 `send` 方法。`send` 方法可以在 `Zend\Http\PhpEnvironment\Response`
    类下找到。它触发了 `sendHeaders` 和 `sendContent` 方法。这是实际输出被发送到浏览器的地方，因为 `sendHeaders` 方法使用了
    PHP 的 `header` 函数和 `echo` 构造来推送输出。
- en: 'To reiterate on the preceding, the flow of execution as we understand it comes
    down to the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重申前面的内容，我们理解的执行流程归结如下：
- en: '`index.php`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.php`'
- en: '`\Magento\Framework\App\Bootstrap` `->` `run`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\App\Bootstrap` `->` `run`'
- en: '`\Magento\Framework\App\Http` `->` `launch`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\App\Http` `->` `launch`'
- en: '`\Magento\Framework\App\Response\Http` `->` `sendResponse`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\App\Response\Http` `->` `sendResponse`'
- en: Though we have just made it to the end of the bootstrap's `run` method, it would
    be unfair to say we covered the rendering flow, as we barely touched it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经到达了引导的 `run` 方法的末尾，但如果我们说我们已经涵盖了渲染流程，那是不公平的，因为我们几乎没触及它。
- en: 'We need to take a step back and take a detailed look at `PART-2-2`, the inner
    workings of the `launch` method. Let''s take a look at the (trimmed) version of
    the `\Magento\Framework\App\Http` `->` `launch` method as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要退后一步，详细查看 `PART-2-2`，即 `launch` 方法的内部工作原理。让我们看一下 `\Magento\Framework\App\Http`
    `->` `launch` 方法的（裁剪）版本如下：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`PART-3-1` creates the instance of the object whose class conforms to `\Magento\Framework\App\FrontControllerInterface`.
    If we look under `app/etc/di.xml`, we can see there is a preference for `FrontControllerInterface`
    in favor of the `\Magento\Framework\App\FrontController` class. However, if we
    were to debug the code and check for the actual instance class, it would show
    `Magento\Framework\App\FrontController\Interceptor`. This is Magento adding an
    interceptor wrapper that then extends `\Magento\Framework\App\FrontController`,
    which we expected from the `di.xml` preference entry.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`PART-3-1` 创建了一个符合 `\Magento\Framework\App\FrontControllerInterface` 类的对象实例。如果我们查看
    `app/etc/di.xml`，我们可以看到对 `FrontControllerInterface` 的偏好设置是为了 `\Magento\Framework\App\FrontController`
    类。然而，如果我们调试代码并检查实际的实例类，它将显示为 `Magento\Framework\App\FrontController\Interceptor`。这是
    Magento 添加了一个拦截器包装器，然后扩展了 `\Magento\Framework\App\FrontController`，这是我们根据 `di.xml`
    偏好条目所期望的。'
- en: Now that we know the real class behind the `$frontController` instance, we know
    where to look for the `dispatch` method. The `dispatch` method is another important
    step in understanding the rendering flow process. We will look into its inner
    workings in a bit more detail later on. For now, let's focus back on the `$result`
    variable of `PART-3-2`. If we were to debug the variable, the direct class behind
    it would show as `Magento\Framework\View\Result\Page\Interceptor`, defined under
    the dynamically created `var/generation/Magento/Framework/View/Result/Page/Interceptor.php`
    file. `Interceptor` is the wrapper for the `\Magento\Framework\View\Result\Page`
    class. Thus, it is safe to say that our `$result` variable is an instance of the
    `Page` class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了 `$frontController` 实例背后的真实类，我们知道在哪里查找 `dispatch` 方法。`dispatch` 方法是理解渲染流程过程中的另一个重要步骤。我们将在稍后更详细地探讨其内部工作原理。现在，让我们回到
    `PART-3-2` 的 `$result` 变量。如果我们调试这个变量，直接在其背后的类将显示为 `Magento\Framework\View\Result\Page\Interceptor`，定义在动态创建的
    `var/generation/Magento/Framework/View/Result/Page/Interceptor.php` 文件中。`Interceptor`
    是 `\Magento\Framework\View\Result\Page` 类的包装器。因此，可以说我们的 `$result` 变量是 `Page` 类的实例。
- en: The `Page` class extends `\Magento\Framework\View\Result\Layout`, which further
    extends `\Magento\Framework\Controller\AbstractResult` and implements `\Magento\Framework\Controller\ResultInterface`.
    Quite a chain we have here, but it is important to understand it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Page` 类扩展了 `\Magento\Framework\View\Result\Layout`，它进一步扩展了 `\Magento\Framework\Controller\AbstractResult`
    并实现了 `\Magento\Framework\Controller\ResultInterface`。这里有一个相当长的链，但理解它很重要。'
- en: Notice `PART-3-3`. Since our `$result` is an instance of `\Magento\Framework\Controller\ResultInterface`,
    we fall into the first `if` condition that calls the `renderResult` method. The
    `renderResult` method itself is declared within the `\Magento\Framework\View\Result\Layout`
    class. Without going into the details of `renderResult`, suffice to say that it
    adds HTTP headers, and content to the `$this->_response` object passed to it.
    That same response object is what the `launch` method returns, as we described
    before in `PART-2-2`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `PART-3-3`。由于我们的 `$result` 是 `\Magento\Framework\Controller\ResultInterface`
    的实例，我们进入了第一个 `if` 条件，调用了 `renderResult` 方法。`renderResult` 方法本身是在 `\Magento\Framework\View\Result\Layout`
    类中声明的。不深入探讨 `renderResult` 的细节，只需说它添加了 HTTP 头和内容到传递给它的 `$this->_response` 对象。正如我们在
    `PART-2-2` 中所描述的，相同的响应对象是 `launch` 方法返回的。
- en: Though `PART-3-3` does not depict any return value, the expression `$result->renderResult($this->_response)`
    does not do any output on its own. It modifies `$this->_response` that we finally
    return from the `launch` method as shown in `PART-3-4`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `PART-3-3` 没有描绘任何返回值，但表达式 `$result->renderResult($this->_response)` 本身并不进行任何输出。它修改了
    `$this->_response`，这是我们最终从 `launch` 方法返回的，正如我们在 `PART-3-4` 中所展示的。
- en: 'To reiterate on the preceding, the flow of execution as we understand it comes
    down to the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重申前面的内容，我们理解的执行流程归结如下：
- en: '`index.php`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.php`'
- en: '`\Magento\Framework\App\Bootstrap` `->` `run`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\App\Bootstrap` `->` `run`'
- en: '`\Magento\Framework\App\Http` `->` `launch`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\App\Http` `->` `launch`'
- en: '`\Magento\Framework\App\FrontController` `->` `dispatch`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\App\FrontController` `->` `dispatch`'
- en: '`\Magento\Framework\View\Result\Page` `->` `renderResult`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\View\Result\Page` `->` `renderResult`'
- en: '`\Magento\Framework\App\Response\Http` `->` `sendResponse`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\App\Response\Http` `->` `sendResponse`'
- en: 'As we mentioned while explaining `PART-3-2`, the `dispatch` method is another
    important step in the rendering flow process. Let''s take a look at the (trimmed)
    version of the `\Magento\Framework\App\FrontController` `->` `dispatch` method
    as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在解释 `PART-3-2` 时提到的，`dispatch` 方法是渲染流程过程中的另一个重要步骤。让我们看一下 `\Magento\Framework\App\FrontController`
    的 `->` `dispatch` 方法的（裁剪）版本，如下所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`PART-4-1` and `PART-4-2` in the preceding code shows (almost) the entire `dispatch`
    method body contained within a loop. The loop does 100 iterations, further looping
    through all available router types, thus giving each router 100 times to find
    a route `match`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的 `PART-4-1` 和 `PART-4-2` 展示了（几乎）整个 `dispatch` 方法体包含在一个循环中。循环进行了 100 次迭代，进一步遍历所有可用的路由器类型，从而给每个路由器
    100 次找到路由匹配的机会。
- en: 'The router list loop includes routers of the following class types:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 路由列表循环包括以下类类型的路由器：
- en: '`Magento\Framework\App\Router\Base`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Magento\Framework\App\Router\Base`'
- en: '`Magento\UrlRewrite\Controller\Router`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Magento\UrlRewrite\Controller\Router`'
- en: '`Magento\Cms\Controller\Router`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Magento\Cms\Controller\Router`'
- en: '`Magento\Framework\App\Router\DefaultRouter`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Magento\Framework\App\Router\DefaultRouter`'
- en: All of the listed routers implement `\Magento\Framework\App\RouterInterface`,
    making them all have the implementation of the `match` method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的列表路由器都实现了 `\Magento\Framework\App\RouterInterface`，这使得它们都具有 `match` 方法的实现。
- en: A module can further define new routers if they choose so. As an example, imagine
    if we are developing a `Blog` module. We would want our module catching all requests
    on a URL that starts with a `/blog/` part. This can be done by specifying the
    custom router, which would then show up on the preceding list.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块选择这样做，可以进一步定义新的路由器。例如，如果我们正在开发一个 `Blog` 模块，我们希望我们的模块捕获所有以 `/blog/` 部分开始的
    URL 请求。这可以通过指定自定义路由器来实现，然后它将出现在前面的列表中。
- en: '`PART-4-3` shows the `$actionInstance` variable storing the result of the router
    `match` method call. As per `RouterInterface` requirements, the `match` method
    is required to return an instance whose class implements `\Magento\Framework\App\ActionInterface`.
    Let''s imagine we are now hitting the URL `/foggyline_office/test/crud/` from
    the module we wrote in [Chapter 4](part0028_split_000.html#QMFO2-818f5224668745eb9070ddf1d85e6bfa
    "Chapter 4. Models and Collections"), *Models and Collections*. In this case,
    our `$router` class would be `\Magento\Framework\App\Router\Base` and our `$actionInstance`
    would be of the class `\Foggyline\Office\Controller\Test\Crud\Interceptor`. Magento
    automatically adds `Interceptor`, through the dynamically generated `var/generation/Foggyline/Office/Controller/Test/Crud/Interceptor.php`
    file. This `Interceptor` class further extends our module `\Foggyline\Office\Controller\Test\Crud`
    class file. The `Crud` class extends `\Foggyline\Office\Controller\Test`, which
    further extends `\Magento\Framework\App\Action\Action`, which implements `\Magento\Framework\App\ActionInterface`.
    After a lengthy parent-child tree, we finally got to `ActionInterface`, which
    is what our `match` method is required to return.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`PART-4-3` 展示了 `$actionInstance` 变量存储了路由器 `match` 方法调用的结果。根据 `RouterInterface`
    的要求，`match` 方法必须返回一个实现了 `\Magento\Framework\App\ActionInterface` 的类的实例。让我们想象一下，我们现在正在从我们在
    [第 4 章](part0028_split_000.html#QMFO2-818f5224668745eb9070ddf1d85e6bfa "第 4 章。模型和集合")
    中编写的模块中访问 URL `/foggyline_office/test/crud/`，*模型和集合*。在这种情况下，我们的 `$router` 类将是
    `\Magento\Framework\App\Router\Base`，我们的 `$actionInstance` 将是 `\Foggyline\Office\Controller\Test\Crud\Interceptor`
    类。Magento 自动通过动态生成的 `var/generation/Foggyline/Office/Controller/Test/Crud/Interceptor.php`
    文件添加 `Interceptor`。这个 `Interceptor` 类进一步扩展了我们的模块 `\Foggyline\Office\Controller\Test\Crud`
    类文件。`Crud` 类扩展了 `\Foggyline\Office\Controller\Test`，它进一步扩展了 `\Magento\Framework\App\Action\Action`，它实现了
    `\Magento\Framework\App\ActionInterface`。经过一段漫长的父子树，我们最终到达了 `ActionInterface`，这正是我们的
    `match` 方法需要返回的。'
- en: '`PART-4-4` shows the `dispatch` method being called on `$actionInstance`. This
    method is implemented within `\Magento\Framework\App\Action\Action`, and is expected
    to return an object that implements `\Magento\Framework\App\ResponseInterface`.
    Internal to `dispatch`, the `execute` method is called, thus running the code
    within our `Crud` controller action `execute` method.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`PART-4-4` 展示了在 `$actionInstance` 上调用 `dispatch` 方法。这个方法在 `\Magento\Framework\App\Action\Action`
    中实现，并期望返回一个实现了 `\Magento\Framework\App\ResponseInterface` 的对象。在 `dispatch` 内部，调用
    `execute` 方法，从而运行我们 `Crud` 控制器动作 `execute` 方法中的代码。'
- en: Assuming our `Crud` controller action execute method does not return nothing,
    the `$result` object becomes an instance of `Magento\Framework\App\Response\Http\Interceptor`,
    which is wrapped around `\Magento\Framework\App\Response\Http`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的`Crud`控制器操作执行方法没有返回任何内容，`$result`对象将变为`Magento\Framework\App\Response\Http\Interceptor`的实例，它围绕`\Magento\Framework\App\Response\Http`进行包装。
- en: 'Let''s imagine our `Crud` class has been defined as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们的`Crud`类已经定义如下：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Debugging the `$result` variable now shows it's an instance of `\Magento\Framework\View\Result\Page\Interceptor`.
    This `Interceptor` gets dynamically generated by Magento under `var/generation/Magento/Framework/View/Result/Page/Interceptor.php`
    and is merely a wrapper for `\Magento\Framework\View\Result\Page`. This `Page`
    class further extends the `\Magento\Framework\View\Result\Layout` class, and implements
    `\Magento\Framework\App\ResponseInterface`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调试`$result`变量显示它是一个`\Magento\Framework\View\Result\Page\Interceptor`的实例。这个`Interceptor`由Magento在`var/generation/Magento/Framework/View/Result/Page/Interceptor.php`下动态生成，并且仅仅是`\Magento\Framework\View\Result\Page`的包装器。这个`Page`类进一步扩展了`\Magento\Framework\View\Result\Layout`类，并实现了`\Magento\Framework\App\ResponseInterface`。
- en: Finally, `PART-4-4` shows the `$result` object of type `\Magento\Framework\View\Result\Page`
    being returned from the `FrontController` `dispatch` method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`PART-4-4`展示了从`FrontController`的`dispatch`方法返回的`$result`对象，其类型为`\Magento\Framework\View\Result\Page`。
- en: 'To reiterate on the preceding, the flow of execution as we understand it comes
    down to the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调前面提到的，我们理解的执行流程如下：
- en: '`index.php`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.php`'
- en: '`\Magento\Framework\App\Bootstrap` `->` `run`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\App\Bootstrap` `->` `run`'
- en: '`\Magento\Framework\App\Http` `->` `launch`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\App\Http` `->` `launch`'
- en: '`\Magento\Framework\App\FrontController` `->` `dispatch`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\App\FrontController` `->` `dispatch`'
- en: '`\Magento\Framework\App\Router\Base` `->` `match`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\App\Router\Base` `->` `match`'
- en: '`\Magento\Framework\App\Action\Action` `->` `dispatch`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\App\Action\Action` `->` `dispatch`'
- en: '`\Magento\Framework\View\Result\Page` `->` `renderResult`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\View\Result\Page` `->` `renderResult`'
- en: '`\Magento\Framework\App\Response\Http` `->` `sendResponse`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\App\Response\Http` `->` `sendResponse`'
- en: In a nutshell, what we as frontend developers should know is that returning
    the Page type object from our controller action will automatically call the `renderResult`
    method on that object. `Page` and `Layout` is where all the theme translations,
    layout, and template loading are triggering.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，作为前端开发者，我们应该知道，从我们的控制器操作中返回页面类型对象将自动调用该对象上的`renderResult`方法。`Page`和`Layout`是所有主题翻译、布局和模板加载触发的地方。
- en: View elements
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图元素
- en: Magento's primary view elements are its UI Components, containers, and blocks.
    The following is a brief overview of each of them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Magento的主要视图元素是其UI组件、容器和块。以下是对每个元素的简要概述。
- en: Ui components
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ui组件
- en: Under the `vendor/magento/framework/View/Element/` folder, we can find `UiComponentInterface`
    and `UiComponentFactory`. The full set of `Ui` components is located under the
    `vendor/magento/framework/View/Element/` directory. Magento implements `UiComponent`
    through a separate module called `Magento_Ui`. Thus, the components themselves
    are located under the `vendor/magento/module-ui/Component/` directory.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vendor/magento/framework/View/Element/`文件夹下，我们可以找到`UiComponentInterface`和`UiComponentFactory`。完整的`Ui`组件集合位于`vendor/magento/framework/View/Element/`目录下。Magento通过一个名为`Magento_Ui`的独立模块实现了`UiComponent`。因此，组件本身位于`vendor/magento/module-ui/Component/`目录下。
- en: 'Components implement `UiComponentInterface`, which is defined under the `vendor/magento/framework/View/Element/UiComponentInterface.php`
    file as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 组件实现`UiComponentInterface`，该接口定义在`vendor/magento/framework/View/Element/UiComponentInterface.php`文件中，如下所示：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice how `BlockInterface` extends `BlockInterface`, whereas `BlockInterface`
    defines only one method requirement as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`BlockInterface`如何扩展`BlockInterface`，而`BlockInterface`只定义了一个方法要求，如下所示：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since `Block` is an element of the interface, `UiComponent` can be looked at
    as an advanced block. Let''s take a quick look at the `_renderUiComponent` method
    of the `\Magento\Framework\View\Layout` class, (partially) defined as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Block`是界面元素的一部分，`UiComponent`可以被视为一个高级块。让我们快速查看`\Magento\Framework\View\Layout`类中的`_renderUiComponent`方法，部分定义如下：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This shows that `UiComponent` is rendered in the same way as block, by calling
    the `toHtml` method on the component. The `vendor/magento/module-ui/view/base/ui_component/etc/definition.xml`
    file contains an extensive list of several `UiComponents` as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 `UiComponent` 与块以相同的方式渲染，通过在组件上调用 `toHtml` 方法。`vendor/magento/module-ui/view/base/ui_component/etc/definition.xml`
    文件包含了一个广泛的 `UiComponents` 列表，如下所示：
- en: '`dataSource`: `Magento\Ui\Component\DataSource`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dataSource`: `Magento\Ui\Component\DataSource`'
- en: '`listing`: `Magento\Ui\Component\Listing`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`listing`: `Magento\Ui\Component\Listing`'
- en: '`paging`: `Magento\Ui\Component\Paging`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paging`: `Magento\Ui\Component\Paging`'
- en: '`filters`: `Magento\Ui\Component\Filters`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filters`: `Magento\Ui\Component\Filters`'
- en: '`container`: `Magento\Ui\Component\Container`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container`: `Magento\Ui\Component\Container`'
- en: '`form`: `Magento\Ui\Component\Form`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`form`: `Magento\Ui\Component\Form`'
- en: '`price`: `Magento\Ui\Component\Form\Element\DataType\Price`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`price`: `Magento\Ui\Component\Form\Element\DataType\Price`'
- en: '`image`: `Magento\Ui\Component\Form\Element\DataType\Media`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`: `Magento\Ui\Component\Form\Element\DataType\Media`'
- en: '`nav`: `Magento\Ui\Component\Layout\Tabs\Nav`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nav`: `Magento\Ui\Component\Layout\Tabs\Nav`'
- en: … and many more
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: …以及更多
- en: 'These components are mostly used to construct a listing and filters in the
    admin area. If we do a string search for `uiComponent` across the entire Magento,
    we would mostly find entries like the one in `vendor/magento/module-cms/view/adminhtml/layout/cms_block_index.xml`
    with content as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件主要用于在管理区域构建列表和过滤器。如果我们对整个 Magento 进行 `uiComponent` 的字符串搜索，我们通常会找到类似 `vendor/magento/module-cms/view/adminhtml/layout/cms_block_index.xml`
    中的条目，内容如下：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The value `cms_block_listing` of `uiComponent`'s `name` attribute refers to
    the name of the `vendor/magento/module-cms /view/adminhtml/ui_component/cms_block_listing.xml`
    file. Within the `cms_block_listing.xml` file, we have a listing component defined
    across more than a few hundreds lines of XML. Listing component then `dataSource`,
    `container`, `bookmark`, `filterSearch`, `filters`, and so on. We will not go
    into the details of these declarations, as our focus here is on more general frontend
    bits.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`uiComponent` 的 `name` 属性的值 `cms_block_listing` 指的是 `vendor/magento/module-cms/view/adminhtml/ui_component/cms_block_listing.xml`
    文件的名字。在 `cms_block_listing.xml` 文件中，我们定义了一个跨越数百行 XML 的列表组件。列表组件然后是 `dataSource`、`container`、`bookmark`、`filterSearch`、`filters`
    等等。我们不会深入这些声明的细节，因为我们的重点是更通用的前端部分。'
- en: Containers
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器
- en: Containers have no block classes related to them. Container renders all of its
    children automatically. They allow the configuration of some attributes. Simply
    attach any element to a container and it will render it automatically. With a
    container, we can define wrapping tags, CSS classes, and more.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 容器没有与之相关的块类。容器会自动渲染其所有子元素。它们允许配置一些属性。只需将任何元素附加到容器上，它就会自动渲染。使用容器，我们可以定义包装标签、CSS
    类等。
- en: We cannot create instances of containers because they are an abstract concept,
    whereas we can create instances of blocks.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能创建容器的实例，因为它们是一个抽象概念，而我们可以创建块实例。
- en: 'Containers are rendered via the `_renderContainer` method of the `Magento\Framework\View\Layout`
    class, defined as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是通过 `Magento\Framework\View\Layout` 类的 `_renderContainer` 方法渲染的，定义如下：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Containers support the following extra attributes: `htmlTag`, `htmlClass`,
    `htmlId`, and `label`. To make a little demonstration of a container in action,
    let us make sure we have a module from [Chapter 4](part0028_split_000.html#QMFO2-818f5224668745eb9070ddf1d85e6bfa
    "Chapter 4. Models and Collections"), *Models and Collections* in place, and then
    create the `view/frontend/layout/foggyline_office_test_crud.xml` file within the
    module root folder `app/code/Foggyline/Office/` with content as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 容器支持以下额外属性：`htmlTag`、`htmlClass`、`htmlId` 和 `label`。为了演示容器在实际操作中的效果，让我们确保我们有一个来自
    [第 4 章](part0028_split_000.html#QMFO2-818f5224668745eb9070ddf1d85e6bfa "第 4 章。模型和集合")，*模型和集合*
    的模块，并在模块根目录 `app/code/Foggyline/Office/` 中创建 `view/frontend/layout/foggyline_office_test_crud.xml`
    文件，内容如下：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding XML defines a single container named `foobar`, and within the
    container there are two block elements named `foo` and `bar`. It should kick in
    when we open `http://{our-shop-url}/index.php/foggyline_office/test/crud/` in
    the browser.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 XML 定义了一个名为 `foobar` 的单个容器，容器内有两个名为 `foo` 和 `bar` 的块元素。当我们在浏览器中打开 `http://{我们的商店网址}/index.php/foggyline_office/test/crud/`
    时，它应该会启动。
- en: 'Notice how the container itself is not nested within any other element, rather
    directly into the body. We could have easily nested into some other container
    as shown:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意容器本身并没有嵌套在任何其他元素中，而是直接嵌入到主体中。我们本可以轻松地嵌套到其他容器中，如下所示：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Either way, we should see the strings **The Foo** and **The Bar** shown in
    the browser, with a full-page layout loaded, as shown in the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，我们都应该在浏览器中看到 **The Foo** 和 **The Bar** 这两个字符串，以及加载了全页布局，如下截图所示：
- en: '![Containers](img/00053.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![容器](img/00053.jpeg)'
- en: Blocks
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块
- en: Although containers determine the layout of the page, they do not contain actual
    content directly. Pieces that contain the content and are nested within containers
    are called **blocks**. Each block can contain any number of child content blocks
    or child containers. Thus, mostly every web page in Magento is formed as a mix
    of blocks and containers. Layout defines a sequence of blocks on the page, not
    their location. The look and feel of the blocks is determined by CSS and how the
    page is rendered. When we speak of blocks, we almost always implicitly refer to
    templates as well. Templates are the thing that actually draw elements within
    a page; blocks are the thing that contain the data. In other words, templates
    are PHTML or HTML files pulling data through variables or methods sent on a linked
    PHP block class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管容器决定了页面的布局，但它们并不直接包含实际内容。包含内容并嵌套在容器内的部分被称为 **块**。每个块可以包含任意数量的子内容块或子容器。因此，几乎每个
    Magento 中的网页都是由块和容器的混合体构成的。布局定义了页面上块的顺序，而不是它们的位置。块的外观和感觉由 CSS 和页面的渲染方式决定。当我们提到块时，我们几乎总是隐含地指模板。模板是实际在页面内绘制元素的东西；块是包含数据的东西。换句话说，模板是
    PHTML 或 HTML 文件，通过变量或方法从链接的 PHP 块类中提取数据。
- en: 'Magento defines the `Magento\Framework\View\Result\Page` type under `app/etc/di.xml`
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Magento 在 `app/etc/di.xml` 中定义了 `Magento\Framework\View\Result\Page` 类型，如下所示：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice the template argument is set to `Magento_Theme::root.phtml`. When `Page`
    gets initialized, it picks up the `vendor/magento/module-theme/view/base/templates/root.phtml`
    file. `root.phtml` is defined as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意模板参数设置为 `Magento_Theme::root.phtml`。当 `Page` 被初始化时，它会选择 `vendor/magento/module-theme/view/base/templates/root.phtml`
    文件。`root.phtml` 定义如下：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Variables within `root.phtml` are assigned during the `Magento\Framework\View\Result\Page`
    render method call as (partially) as shown:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `root.phtml` 中的变量在 `Magento\Framework\View\Result\Page` 渲染方法调用期间分配（部分）如下：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The expression `$this->assign` is what assigns variables like `layoutContent`
    to the `root.phtml` template. `layoutContent` is generated based on base layouts,
    together with all layout updates for the current page.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `$this->assign` 用于将变量如 `layoutContent` 分配给 `root.phtml` 模板。`layoutContent`
    是基于基本布局生成的，包括当前页面的所有布局更新。
- en: 'Whereas base layouts include the following XMLs within `vendor/magento/module-theme/view/`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 基础布局包括以下 XML 文件在 `vendor/magento/module-theme/view/` 目录下：
- en: '`base/page_layout/empty.xml`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base/page_layout/empty.xml`'
- en: '`frontend/page_layout/1column.xml`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frontend/page_layout/1column.xml`'
- en: '`frontend/page_layout/2columns-left.xml`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frontend/page_layout/2columns-left.xml`'
- en: '`frontend/page_layout/2columns-right.xml`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frontend/page_layout/2columns-right.xml`'
- en: '`frontend/page_layout/3columns.xml`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frontend/page_layout/3columns.xml`'
- en: The expression `$this->getLayout()->getOutput()` is what gets all blocks marked
    for output. It basically finds elements in a layout, renders them, and returns
    the string with its output. Along the way, the event `core_layout_render_element`
    gets fired, giving us one possible way of affecting the output result. At this
    point, most of the elements on the page are rendered. This is important because
    blocks play a big role here. The rendering system will take `empty.xml` into account,
    as it too consists of a list of containers, and every container has some blocks
    attached to it by other layout updates.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `$this->getLayout()->getOutput()` 用于获取所有标记为输出的块。它基本上在布局中查找元素，渲染它们，并返回带有输出的字符串。在这个过程中，会触发
    `core_layout_render_element` 事件，这为我们影响输出结果提供了一种可能的方式。此时，页面上的大多数元素都已渲染。这很重要，因为块在这里扮演着重要角色。渲染系统会考虑
    `empty.xml`，因为它也由一个容器列表组成，每个容器都通过其他布局更新附加了一些块。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In a nutshell, each container has blocks assigned to it. Each block usually
    (but not always) renders a template. The template itself may or may not call other
    blocks, and so on. Blocks are rendered when they are called from the template.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，每个容器都分配了相应的块。每个块通常（但不总是）渲染一个模板。模板本身可能调用也可能不调用其他块，依此类推。块在从模板调用时被渲染。
- en: Block architecture and life cycle
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块架构和生命周期
- en: Blocks are another one of the primary view elements in Magento. At the root
    of the parent tree structure, blocks extend from the `Magento\Framework\View\Element\AbstractBlock`
    class and implement `Magento\Framework\View\Element\BlockInterface`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 块是 Magento 中主要的视图元素之一。在父树结构的根处，块从 `Magento\Framework\View\Element\AbstractBlock`
    类扩展并实现 `Magento\Framework\View\Element\BlockInterface`。
- en: '`BlockInterface` sets only one requirement, the implementation of the `toHtml`
    method. This method should return blocks HTML output.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockInterface` 只设置了一个要求，即实现 `toHtml` 方法。此方法应返回块的 HTML 输出。'
- en: 'Looking inside `AbstractBlock`, we can see it has a number of methods declared.
    Among the most important ones are the following methods:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看 `AbstractBlock` 的内部结构时，我们可以看到它声明了许多方法。其中最重要的方法如下：
- en: '`_prepareLayout`: Prepares a global layout. We can redefine this method in
    child classes for changing the layout.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_prepareLayout`：准备全局布局。我们可以在子类中重新定义此方法以更改布局。'
- en: '`addChild`: Creates a new block, sets it as a child of the current block, and
    returns the newly created block.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addChild`：创建一个新的块，将其设置为当前块的子块，并返回新创建的块。'
- en: '`_toHtml`: Returns an empty string. We need to override this method in descendants
    to produce HTML.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_toHtml`：返回一个空字符串。我们需要在子类中重写此方法以生成 HTML。'
- en: '`_beforeToHtml`: Returns `$this`. Executes before rendering HTML, but after
    trying to load a cache.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_beforeToHtml`：返回 `$this`。在渲染 HTML 之前执行，但在尝试加载缓存之后。'
- en: '`_afterToHtml`: Processing block HTML after rendering. Returns a HTML string.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_afterToHtml`：在渲染后处理块 HTML。返回一个 HTML 字符串。'
- en: '`toHtml:` Produces and returns a block''s HTML output. This method should not
    be overridden. We can override the `_toHtml` method in descendants if needed.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toHtml:` 生成并返回一个块的 HTML 输出。此方法不应被重写。如果需要，我们可以在子类中重写 `_toHtml` 方法。'
- en: 'The `AbstractBlock` execution flow can be described as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractBlock` 的执行流程可以描述如下：'
- en: '`_prepareLayout`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_prepareLayout`'
- en: '`toHtml`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toHtml`'
- en: '`_beforeToHtml`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_beforeToHtml`'
- en: '`_toHtml`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_toHtml`'
- en: '`_afterToHtml`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_afterToHtml`'
- en: It starts with `_prepareLayout` and flows through a set of methods until it
    reaches `_afterToHtml`. This is, in essence, what we need to know about block
    execution flow.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 它从 `_prepareLayout` 开始，通过一系列方法直到达到 `_afterToHtml`。本质上，这是我们关于块执行流程需要了解的内容。
- en: 'The most important block types are:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的块类型是：
- en: '`Magento\Framework\View\Element\Text`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Magento\Framework\View\Element\Text`'
- en: '`Magento\Framework\View\Element\Text\ListText`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Magento\Framework\View\Element\Text\ListText`'
- en: '`Magento\Framework\View\Element\Messages`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Magento\Framework\View\Element\Messages`'
- en: '`Magento\Framework\View\Element\Template`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Magento\Framework\View\Element\Template`'
- en: All of these blocks are basically an implementation of an abstract block. Since
    the `_toHtml` method in `AbstractBlock` returns only an empty string, all of these
    descendants are implementing their own version of the `_toHtml` method.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些块基本上都是抽象块的实现。由于 `AbstractBlock` 中的 `_toHtml` 方法仅返回一个空字符串，因此所有这些子类都实现了它们自己的
    `_toHtml` 方法。
- en: To demonstrate the usage of these blocks, we can use our previously created
    `app/code/Foggyline/Office/view/frontend/layout/foggyline_office_test_crud.xml`
    file.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这些块的使用，我们可以使用之前创建的 `app/code/Foggyline/Office/view/frontend/layout/foggyline_office_test_crud.xml`
    文件。
- en: 'The `Text` block has a `setText` method we can use to set its content. The
    way we instantiate the `Text` block and set its text value through the layout
    file is shown as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Text` 块有一个 `setText` 方法，我们可以使用它来设置其内容。我们通过布局文件实例化 `Text` 块并设置其文本值的示例如下：'
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ListText` block extends from `Text`. However, it does not really support
    the use of `setText` to set its content. This is obvious just by looking at its
    code, where the `$this->setText('''')` expression is immediately called within
    its `_toHtml` method implementation. Instead, what happens is that the `_toHtml`
    method loops through any child blocks it might have and calls the layout''s `renderElement`
    method on it. Basically, we might compare the `ListText` block to `container`,
    as it has nearly the same purpose. However, unlike container, block is a class
    so we can manipulate it from PHP. The following is an example of using `ListText`,
    containing a few child `Text` blocks:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListText` 块从 `Text` 类扩展而来。然而，它实际上并不支持使用 `setText` 来设置其内容。这仅从其代码中就可以明显看出，在其
    `_toHtml` 方法的实现中，`$this->setText('''')` 表达式立即被调用。相反，实际上发生的情况是 `_toHtml` 方法遍历它可能拥有的任何子块，并在其上调用布局的
    `renderElement` 方法。基本上，我们可以将 `ListText` 块与 `container` 进行比较，因为它们具有几乎相同的目的。然而，与容器不同，块是一个类，因此我们可以从
    PHP 中操作它。以下是一个使用 `ListText` 的示例，其中包含几个子 `Text` 块：'
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `Messages` block supports four methods that we can use to add content to
    output: `addSuccess`, `addNotice`, `addWarning`, and `addError`. The following
    is an example instantiating the `Messages` block through the layout update file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Messages` 块支持四种我们可以用来向输出添加内容的方法：`addSuccess`、`addNotice`、`addWarning` 和 `addError`。以下是通过布局更新文件实例化
    `Messages` 块的示例：'
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding example should be taken with caution, since calling these setter
    methods in layout is not the proper way to do it. The default `Magento_Theme`
    module already defines the `Messages` block that uses `vendor/magento/module-theme/view/frontend/templates/messages.phtml`
    for message rendering. Thus, for most of the part there is no need to define our
    own messages block.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例应谨慎对待，因为在布局中调用这些设置方法不是正确的方式。默认的 `Magento_Theme` 模块已经定义了使用 `vendor/magento/module-theme/view/frontend/templates/messages.phtml`
    进行消息渲染的 `Messages` 块。因此，在大多数情况下，没有必要定义我们自己的消息块。
- en: 'Finally, let''s look at the example of the `Template` block as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看以下 `Template` 块的示例：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding XML will instantiate the `Template` type of block and render the
    content of the `view/frontend/templates/office/no4/template.phtml` file within
    the `app/code/Foggyline/Office/` directory.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 XML 将实例化 `Template` 类型的块，并在 `app/code/Foggyline/Office/` 目录下渲染 `view/frontend/templates/office/no4/template.phtml`
    文件的内容。
- en: On the PHP level, instantiating a new block can be accomplished using the layout
    object, or directly through the object manager. The layout approach is the preferred
    way. With regard to the previous examples in XML, let's see their alternatives
    in PHP (assuming `$resultPage` is an instance of `\Magento\Framework\View\Result\PageFactory`).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 层面上，使用布局对象或直接通过对象管理器实例化一个新的块可以完成。布局方法是首选方法。关于之前在 XML 中的示例，让我们看看它们的 PHP
    替代方案（假设 `$resultPage` 是 `\Magento\Framework\View\Result\PageFactory` 的一个实例）。
- en: 'The following is an example of instantiating the `Text` type of block and adding
    it as a child of the content container:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个实例化 `Text` 类型的块并将其添加到内容容器中的示例：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `ListText` version is done in PHP as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListText` 版本在 PHP 中的实现如下：'
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how we first made an instance of the `ListText` block and assigned it
    as a child of an element named content. Then we created two individual `Text`
    blocks and assigned them as a child of an element named `example_2`, which is
    our `ListText`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们首先创建了一个 `ListText` 块的实例，并将其分配给名为 `content` 的元素作为子元素。然后我们创建了两个单独的 `Text`
    块，并将它们分配给名为 `example_2` 的元素作为子元素，即我们的 `ListText`。
- en: 'Next, let''s define the `Messages` block as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义以下 `Messages` 块：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, let''s look at the `Template` block type, which we initiate as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如何初始化 `Template` 块类型，如下所示：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Whenever possible, we should set our blocks using XML layouts.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，我们应该使用 XML 布局来设置我们的块。
- en: Now that we know how to utilize the most common types of Magento blocks, let's
    see how we can create our own block type.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何利用最常用的 Magento 块类型，让我们看看我们如何创建自己的块类型。
- en: 'Defining our own `block` class is as simple as creating a custom class file
    that extends `Template`. This `block` class should be placed under our module
    `Block` directory. Using our `Foggyline_Office` module, let''s create a file,
    `Block/Hello.php`, with content as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 定义我们自己的 `block` 类就像创建一个扩展 `Template` 的自定义类文件一样简单。这个 `block` 类应该放在我们的模块 `Block`
    目录下。使用我们的 `Foggyline_Office` 模块，让我们创建一个文件，`Block/Hello.php`，内容如下：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code simply creates a new custom block class. We can then call
    this `block` class through our layout file as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码仅仅创建了一个新的自定义块类。然后我们可以通过布局文件调用这个 `block` 类，如下所示：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, within our module `app/code/Foggyline/Office/` directory, we create
    a template file, `view/frontend/templates/office/hello.phtml`, with content as
    follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的模块 `app/code/Foggyline/Office/` 目录中，我们创建一个模板文件，`view/frontend/templates/office/hello.phtml`，内容如下：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To further understand what is happening here within the template file, let's
    take a deeper look at templates themselves.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步了解模板文件中的情况，让我们深入了解一下模板本身。
- en: Templates
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: '**Templates** are snippets of HTML mixed with PHP. The PHP part includes elements
    such as variables, expressions, and `class` method calls. Magento uses the PHTML
    file extension for template files. Templates are located under an individual module''s
    `view/{_area_}/templates/ directory`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板**是混合了 HTML 和 PHP 的代码片段。PHP 部分包括变量、表达式和 `class` 方法调用等元素。Magento 使用 PHTML
    文件扩展名作为模板文件。模板位于单个模块的 `view/{_area_}/templates/` 目录下。'
- en: In our previous example, we referred to our module template file with an expression
    like `Foggyline_Office::office/hello.phtml`. Since templates can belong to different
    modules, we should prepend the template with the module name as a best practice.
    This will help us locate template files and avoid file conflicts.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们使用类似于 `Foggyline_Office::office/hello.phtml` 的表达式来引用我们的模块模板文件。由于模板可能属于不同的模块，我们应该将模板名称作为前缀来使用，这是一个最佳实践。这将帮助我们定位模板文件并避免文件冲突。
- en: 'A simple naming formula goes like this: we type the name of the module, double
    single colon, and then the name. Thus making a template path like `office/hello.phtml`
    equaling to `Foggyline_Office::office/hello.phtml`.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的命名公式是这样的：我们输入模块的名称，然后是双冒号，接着是名称。这样，模板路径 `office/hello.phtml` 就等于 `Foggyline_Office::office/hello.phtml`。
- en: Within the PHTML template file we often have various PHP expressions like `$block->helloPublic()`.
    Notice the block class `Foggyline\Office\Block\Hello` in the preceding XML. An
    instance of this block class becomes available to us in `hello.phtml` through
    the `$block` variable. Thus, an expression like `$block->helloPublic()` is effectively
    calling the `helloPublic` method from an instance of the `Hello` class. The `Hello`
    class is not one of the Magento core classes, but it does extend `\Magento\Framework\View\Element\Template`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHTML 模板文件中，我们经常有各种 PHP 表达式，如 `$block->helloPublic()`。注意前面 XML 中的块类 `Foggyline\Office\Block\Hello`。这个块类的实例通过
    `$block` 变量在 `hello.phtml` 中对我们可用。因此，像 `$block->helloPublic()` 这样的表达式实际上是调用 `Hello`
    类的 `helloPublic` 方法。`Hello` 类不是 Magento 核心类之一，但它扩展了 `\Magento\Framework\View\Element\Template`。
- en: 'Our `hello.phtml` template also has two more expressions: `$block->helloProtected()`
    and `$block->helloPrivate()`. However, these are not executed as template files
    can only see public methods from their `$block` instances.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `hello.phtml` 模板还有另外两个表达式：`$block->helloProtected()` 和 `$block->helloPrivate()`。然而，这些表达式不会被执行，因为模板只能看到它们
    `$block` 实例的公共方法。
- en: The `$this` variable is also available within the PHTML template as an instance
    of the `Magento\Framework\View\TemplateEngine\Php` class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`$this` 变量在 PHTML 模板中也是可用的，它是 `Magento\Framework\View\TemplateEngine\Php` 类的一个实例。'
- en: 'In the preceding template code example, we could have easily replaced `$block->helloPublic()`
    with the `$this->helloPublic()` expression. The reason why this would work lies
    in the template engine `Php` class, (partially) defined as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板代码示例中，我们可以轻松地将 `$block->helloPublic()` 替换为 `$this->helloPublic()` 表达式。这样做的原因在于模板引擎
    `Php` 类，部分定义如下：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Given that templates are included in the context of the engine rather than in
    the context of the block, `__call` redirects methods calls to the current block.
    Similarly, `__isset` redirects `isset` calls to the current block and `__get`
    allows read access to properties of the current block.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模板是在引擎的上下文中而不是在块的上下文中包含的，`__call` 将方法调用重定向到当前块。同样，`__isset` 将 `isset` 调用重定向到当前块，而
    `__get` 允许读取当前块的属性。
- en: Though we can use both `$block` and `$this` for the same purpose within the
    template file, we should really opt for using `$block`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在模板文件中为同一目的使用 `$block` 和 `$this`，但我们实际上应该选择使用 `$block`。
- en: Another important aspect of templates is their fallback mechanism. Fallback
    is the process of defining a full template path given only its relative path.
    For example, `office/hello.phtml` falls back to the `app/code/Foggyline/Office/view/frontend/templates/office/hello.phtml`
    file.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的重要方面之一是它们的回退机制。回退是指仅给定相对路径时定义完整模板路径的过程。例如，`office/hello.phtml` 会回退到 `app/code/Foggyline/Office/view/frontend/templates/office/hello.phtml`
    文件。
- en: Path resolution starts from the _`toHtml` method defined on the `Magento\Framework\View\Element\Template`
    class. The _`toHtml` method then calls `getTemplateFile` within the same class,
    which in turn calls `getTemplateFileName` on `resolver`, which is an instance
    of `\Magento\Framework\View\Element\Template\File\Resolver`. Looking further,
    resolver's `getTemplateFileName` further calls `getTemplateFileName` on `_viewFileSystem`,
    which is an instance of `\Magento\Framework\View\FileSystem`. The method `getFile`
    is further called on an instance of `\Magento\Framework\View\Design\FileResolution\Fallback\TemplateFile`.
    `getFile` further triggers the resolve method on the `Magento\Framework\View\Design\FileResolution\Fallback\Resolver\Simple`
    instance, which further calls the `getRule` method on the `Magento\Framework\View\Design\Fallback\RulePool`
    instance. The `RulePoll` class is the final class in the chain here. `getRule`
    finally calls the `createTemplateFileRule` method, which creates the rule that
    detects where the file is located.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 路径解析从定义在`Magento\Framework\View\Element\Template`类上的`_toHtml`方法开始。然后`_toHtml`方法在同一类中调用`getTemplateFile`，它反过来在`resolver`上调用`getTemplateFileName`，`resolver`是`\Magento\Framework\View\Element\Template\File\Resolver`的一个实例。进一步查看，`resolver`的`getTemplateFileName`进一步在`_viewFileSystem`上调用`getTemplateFileName`，`_viewFileSystem`是`\Magento\Framework\View\FileSystem`的一个实例。在`\Magento\Framework\View\Design\FileResolution\Fallback\TemplateFile`的一个实例上进一步调用`getFile`方法。`getFile`进一步触发`Magento\Framework\View\Design\FileResolution\Fallback\Resolver\Simple`实例上的resolve方法，该实例进一步在`Magento\Framework\View\Design\Fallback\RulePool`实例上调用`getRule`方法。`RulePoll`类是链中的最后一个类。`getRule`最终调用`createTemplateFileRule`方法，该方法创建检测文件位置的规则。
- en: 'While running the `getRule` method, Magento checks against the following types
    of fallback rules:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`getRule`方法时，Magento会检查以下类型的回退规则：
- en: '`file`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file`'
- en: '`locale`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locale`'
- en: '`template`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`'
- en: '`static`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static`'
- en: '`email`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`'
- en: It is worth spending some time to study the inner workings of the `RulePool`
    class, as it showcases detailed fallbacks for the listed rules.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 值得花些时间研究`RulePool`类的内部工作原理，因为它展示了所列规则的详细回退。
- en: Layouts
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局
- en: 'Up to this point, we briefly touched on layout XMLs. Layout XML is a tool to
    build the pages of the Magento application in a modular and flexible manner. It
    enables us to describe the page layout and content placement. Looking at XML root
    nodes, we differentiate two types of layouts:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们简要介绍了布局XML。布局XML是一种工具，以模块化和灵活的方式构建Magento应用程序的页面。它使我们能够描述页面布局和内容放置。查看XML根节点，我们可以区分两种类型的布局：
- en: '`layout`: XML wrapped in `<layout>`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout`: 包裹在`<layout>`中的XML'
- en: '`page`: XML wrapped in `<page>`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page`: 包裹在`<page>`中的XML'
- en: '`Page` layouts represent a full page in HTML, whereas `layout` layouts represent
    a part of a page. The `layout` type is a subset of the `page` layout type. Both
    types of layout XML files are validated by the XSD schema found under the `vendor/magento/framework/View/Layout/etc/`
    directory:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`Page`布局代表一个完整的HTML页面，而`layout`布局代表页面的一部分。`layout`类型是`page`布局类型的子集。这两种类型的布局XML文件都由位于`vendor/magento/framework/View/Layout/etc/`目录下的XSD模式进行验证：'
- en: '`layout` – `layout_generic.xsd`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout` – `layout_generic.xsd`'
- en: '`page` – `page_configuration.xsd`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page` – `page_configuration.xsd`'
- en: Based on the application components that provide `<layout>` and `<page>` elements
    , we can further section them as base and theme layouts.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 根据提供`<layout>`和`<page>`元素的应用程序组件，我们可以进一步将它们分为基础布局和主题布局。
- en: 'The base layouts are provided by the modules, usually at the following locations:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 基础布局由模块提供，通常位于以下位置：
- en: '`<module_dir>/view/frontend/layout`: page configuration and generic layout
    files'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<module_dir>/view/frontend/layout`: 页面配置和通用布局文件'
- en: '`<module_dir>/view/frontend/page_layout`: page layout files'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<module_dir>/view/frontend/page_layout`: 页面布局文件'
- en: 'The theme layouts are provided by the themes, usually at the following locations:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 主题布局由主题提供，通常位于以下位置：
- en: '`<theme_dir>/<Namespace>_<Module>/layout`: page configuration and generic layout
    files'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<theme_dir>/<Namespace>_<Module>/layout`: 页面配置和通用布局文件'
- en: '`<theme_dir>/<Namespace>_<Module>/page_layout`: page layout files'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<theme_dir>/<Namespace>_<Module>/page_layout`: 页面布局文件'
- en: Magento will load and merge all module and theme XML files on the appropriate
    page. Once files are merged and XML instructions are processed, the result is
    rendered and sent to the browser for display. Having two different layout XML
    files, where both reference the same block, means that the second one with the
    same name in the sequence will replace the first one.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Magento将在适当的页面上加载并合并所有模块和主题XML文件。一旦文件合并并处理了XML指令，结果将被渲染并发送到浏览器进行显示。如果存在两个不同的布局XML文件，且两者都引用了相同的块，则序列中具有相同名称的第二个文件将替换第一个文件。
- en: When the XML files are loaded, Magento applies an inheritance theme at the same
    time. We can apply a theme and it will look for the parent until a theme without
    a parent is reached.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载XML文件时，Magento同时应用一个继承主题。我们可以应用一个主题，并且它将查找父主题，直到找到一个没有父主题的主题。
- en: In addition to the merging of files from each module, layout files from within
    module directories can also be extended or overridden by themes. Overriding layout
    XML is not a good practice, but it might be necessary sometimes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 除了合并每个模块的文件外，模块目录内的布局文件也可以被主题扩展或覆盖。覆盖布局XML不是一种好的做法，但有时可能是必要的。
- en: To *override* the base layout files provided by the module within the `<module_dir>/view/frontend/layout/`directory.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要**覆盖**在`<module_dir>/view/frontend/layout/`目录内由模块提供的基布局文件。
- en: We need to create an XML file with the same name in the `app/design/frontend/<vendor>/<theme>/<Namespace_Module>/layout/override/base/`directory.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`app/design/frontend/<vendor>/<theme>/<Namespace_Module>/layout/override/base/`目录中创建一个具有相同名称的XML文件。
- en: To *override* the theme layout files provided by the parent theme within the
    <`parent_theme_dir>/<Namespace>_<Module>/layout/`directory.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要**覆盖**在`<parent_theme_dir>/<Namespace>_<Module>/layout/`目录内由父主题提供的主题布局文件。
- en: We need to create an XML file with the same name in the `app/design/frontend/<vendor>/<theme
    >/<Namespace_Module>/layout/override/theme/<Parent_Vendor>/<parent_theme>/`directory.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`app/design/frontend/<vendor>/<theme>/<Namespace_Module>/layout/override/theme/<Parent_Vendor>/<parent_theme>/`目录中创建一个具有相同名称的XML文件。
- en: Layouts can be both overridden and extended.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 布局既可以被覆盖也可以被扩展。
- en: The recommended way to customize layout is to extend it through a custom theme.
    We can do so by simply adding a custom XML layout file with the same name in the
    `app/design/frontend/{vendorName}/{theme}/{vendorName}_{moduleName}/layout/` directory.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 定制布局的推荐方法是通过对自定义主题进行扩展。我们可以通过在`app/design/frontend/{vendorName}/{theme}/{vendorName}_{moduleName}/layout/`目录中添加一个具有相同名称的自定义XML布局文件来实现这一点。
- en: 'Layouts, as we saw in previous examples, support a large number of directives:
    page page, head, block, and so on. The practical use of these directives and how
    they mix together is a challenge on its own. Giving full details on each and every
    directive is beyond the scope of this book. However, what we can do is to show
    how to figure out the use of an individual directive, which we might need at a
    given time. For that purpose, it is highly recommended to use an IDE environment
    like **NetBeans PHP** or **PhpStorm** that provide autocomplete on XMLs that include
    XSD.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，布局支持大量指令：页面、头部、块等。这些指令的实际用途以及它们如何混合在一起本身就是一个挑战。详细说明每个指令超出了本书的范围。然而，我们可以展示如何确定某个特定指令的使用，这可能在我们某个特定时刻需要。为此，强烈建议使用像**NetBeans
    PHP**或**PhpStorm**这样的IDE环境，这些环境为包含XSD的XML提供自动完成功能。
- en: 'The following is an example of defining an external schema to PhpStorm, where
    we are simply saying that the `urn:magento:framework:View/Layout/etc/page_configuration.xsd`
    alias belongs to the `vendor/magento/framework/View/Layout/etc/page_configuration.xsd`
    file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个为PhpStorm定义外部架构的示例，我们只是简单地说`urn:magento:framework:View/Layout/etc/page_configuration.xsd`别名属于`vendor/magento/framework/View/Layout/etc/page_configuration.xsd`文件：
- en: '![Layouts](img/00054.jpeg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![布局](img/00054.jpeg)'
- en: This way, PhpStorm will know how to provide autocomplete while we type around
    XML files.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当我们在XML文件周围键入时，PhpStorm将知道如何提供自动完成功能。
- en: 'As an example, let''s take a look at how we could use the `css` directive to
    add an external CSS file to our page. With an IDE that supports autocomplete as
    soon as we type the `css` directive within the `page` | `head` element, autocomplete
    might throw out something like the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看我们如何使用`css`指令将外部CSS文件添加到我们的页面中。使用支持自动完成的IDE，当我们开始在`page` | `head`元素中键入`css`指令时，自动完成可能会抛出以下内容：
- en: '![Layouts](img/00055.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![布局](img/00055.jpeg)'
- en: 'A list of available attributes is shown, such as `src`, `sizes`, `ie_condtion`,
    `src_type`, and so on. IDEs like PhpStorm will allow us to right-click an element
    or its attribute and *go to the definition*. Looking into the definition for the
    `src` attribute gets us into the `vendor/magento/framework/View/Layout/etc/head.xsd`
    file that defines the `css` element as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了可用的属性列表，例如 `src`、`sizes`、`ie_condition`、`src_type` 等。像PhpStorm这样的IDE将允许我们右键单击一个元素或其属性，并
    *转到定义*。查看 `src` 属性的定义将带我们进入 `vendor/magento/framework/View/Layout/etc/head.xsd`
    文件，该文件定义了 `css` 元素如下：
- en: '[PRE27]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'All of these are attributes we can set on the `css` element, and as such get
    their autocomplete as shown:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是我们可以设置在 `css` 元素上的属性，因此它们会显示自动完成，如下所示：
- en: '![Layouts](img/00056.jpeg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![布局](img/00056.jpeg)'
- en: Although it is not required to use a robust IDE with Magento, it certainly helps
    to have one that understands XML and XSD files to the level of providing autocomplete
    and validation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用强大的IDE不是使用Magento的必需条件，但拥有一个能够理解XML和XSD文件并提供自动完成和验证功能的IDE当然是有帮助的。
- en: Themes
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主题
- en: 'By default, Magento comes with two themes, named `Blank` and `Luma`. If we
    log in to the Magento admin area, we can see a list of available themes under
    the **Content** | **Design** | **Themes** menu, as shown in the following screenshot:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Magento附带两个主题，分别命名为 `Blank` 和 `Luma`。如果我们登录到Magento管理区域，我们可以在 **内容** |
    **设计** | **主题** 菜单下看到可用的主题列表，如下截图所示：
- en: '![Themes](img/00057.jpeg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![主题](img/00057.jpeg)'
- en: Magento themes support a parent-child relationship, something we noted previously,
    that is visible on the preceding image within the **Parent Theme** column.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Magento主题支持父子关系，这是我们之前提到的，在上一张图片的 **父主题** 列表中可以看到。
- en: Creating a new theme
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新主题
- en: 'The following steps outline the process of creating our own theme:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了创建我们自己的主题的过程：
- en: Under `{Magento` `root` `directory}/app/design/frontend`, create a new directory
    bearing our vendor name, `Foggyline`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `{Magento` `根` `目录}/app/design/frontend` 下，创建一个以我们供应商名称命名的新的目录，名为 `Foggyline`。
- en: Within the `vendor` directory, create a new directory bearing the theme name,
    `jupiter`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `vendor` 目录下，创建一个以主题名称命名的新的目录，名为 `jupiter`。
- en: 'Within the `jupiter` directory, create the `registration.php` file with content
    as follows:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `jupiter` 目录下，创建 `registration.php` 文件，内容如下：
- en: '[PRE28]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Copy `vendor/magento/theme-frontend-blank/theme.xml` into our theme, `app/design/frontend/Foggyline/jupiter/theme.xml`,
    changing the content as follows:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `vendor/magento/theme-frontend-blank/theme.xml` 复制到我们的主题中，`app/design/frontend/Foggyline/jupiter/theme.xml`，并按以下内容修改：
- en: '[PRE29]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Create the `app/design/frontend/Foggyline/jupiter/media/preview.jpg` image file
    to serve as the theme preview image (the one used in the admin area).
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `app/design/frontend/Foggyline/jupiter/media/preview.jpg` 图像文件作为主题预览图像（在管理区域中使用的图像）。
- en: 'Optionally, create separate directories for static files such as styles, fonts,
    JavaScript, and images. These are stored within the `web` subdirectory of our
    theme `app/design/frontend/Foggyline/jupiter/` folder like follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，为静态文件如样式、字体、JavaScript和图像创建单独的目录。这些文件存储在我们的主题 `app/design/frontend/Foggyline/jupiter/`
    文件夹的 `web` 子目录中，如下所示：
- en: '`web/css/`'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web/css/`'
- en: '`web/css/source/`'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web/css/source/`'
- en: '`web/css/source/components/`'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web/css/source/`'
- en: '`web/images/`'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web/images/`'
- en: '`web/js/`'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web/js/`'
- en: Within the theme `web` directory, we store general theme static files. If our
    theme contains module-specific static files, these are stored under the corresponding
    `vendor` module subdirectories, like `app/design/frontend/Foggyline/jupiter/{vendorName_moduleName}/web/`.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在主题 `web` 目录下，我们存储通用的主题静态文件。如果我们的主题包含特定模块的静态文件，这些文件将存储在相应的 `vendor` 模块子目录下，例如
    `app/design/frontend/Foggyline/jupiter/{vendorName_moduleName}/web/`。
- en: Optionally, we can create the theme `logo.svg` image under our theme `web/images/`
    folder.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，我们可以在主题 `web/images/` 文件夹下创建主题 `logo.svg` 图像。
- en: 'Once we are done with the preceding steps, looking back into the admin area
    under the **Content** | **Design** | **Themes** menu, we should now see our theme
    listed as shown in the following screenshot:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 完成前面的步骤后，回顾到管理区域下的 **内容** | **设计** | **主题** 菜单，我们现在应该可以看到我们的主题列在以下截图所示：
- en: '![Creating a new theme](img/00058.jpeg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![创建新主题](img/00058.jpeg)'
- en: 'Whereas clicking on the row in the table next to our theme name would open
    a screen like the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 而点击表格中我们主题名称旁边的行将打开如下屏幕：
- en: '![Creating a new theme](img/00059.jpeg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![创建新主题](img/00059.jpeg)'
- en: Notice how the previous two screens do not show any options to apply the theme.
    They are only listing out available themes and some basic information next to
    each theme. Our custom theme shows an interesting relationship, where a parent
    and a child theme can belong to different vendors.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前两个屏幕没有显示任何应用主题的选项。它们只是列出可用的主题以及每个主题旁边的一些基本信息。我们的自定义主题显示了有趣的父子关系，其中父主题和子主题可以属于不同的供应商。
- en: 'Applying the theme requires the following extra steps:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 应用主题需要以下额外步骤：
- en: Make sure our theme appears in the theme list, under the **Content** | **Design**
    | **Themes** menu.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保我们的主题出现在 **内容** | **设计** | **主题** 菜单下的主题列表中。
- en: Go to **Stores** | **Settings** | **Configuration** | **General** | **Design**.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **商店** | **设置** | **配置** | **常规** | **设计**。
- en: In the **Store View** drop-down field, we select the store view where we want
    to apply the theme, as shown in the upper-left corner of the following image:![Creating
    a new theme](img/00060.jpeg)
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **商店视图** 下拉字段中，我们选择要应用主题的商店视图，如以下图片的左上角所示：![创建新主题](img/00060.jpeg)
- en: On the **Design Theme** tab, we select our newly created theme in the **Design
    Theme** drop-down, as shown on the right-hand side of the preceding image. Click
    **Save Config**.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **设计主题** 选项卡中，我们在 **设计主题** 下拉列表中选择我们新创建的主题，如前一张图片的右侧所示。点击 **保存配置**。
- en: Under **System** | **Tools** | **Cache Management**, select and refresh the
    invalid cache types and click on the **Flush Catalog Images Cache**, **Flush JavaScript/CSS
    Cache**, and **Flush Static Files Cache** buttons.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **系统** | **工具** | **缓存管理** 下，选择并刷新无效的缓存类型，然后点击 **清除目录图片缓存**、**清除 JavaScript/CSS
    缓存** 和 **清除静态文件缓存** 按钮。
- en: Finally, to see our changes applied, reload the storefront pages in the browser.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了看到我们的更改已应用，请在浏览器中重新加载店面页面。
- en: There is a lot more to be said about themes that can fit in a book of its own.
    However, we will move on to the other important bits.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 关于主题还有很多可以说的，可以写成一本书。然而，我们将继续讨论其他重要部分。
- en: JavaScript
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript
- en: 'Magento makes use of quite a large number of JavaScript libraries, such as:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Magento 使用了相当多的 JavaScript 库，例如：
- en: 'Knockout: [http://knockoutjs.com](http://knockoutjs.com)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Knockout: [http://knockoutjs.com](http://knockoutjs.com)'
- en: 'Ext JS: [https://www.sencha.com/products/extjs/](https://www.sencha.com/products/extjs/)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ext JS: [https://www.sencha.com/products/extjs/](https://www.sencha.com/products/extjs/)'
- en: 'jQuery: [https://jquery.com/](https://jquery.com/)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'jQuery: [https://jquery.com/](https://jquery.com/)'
- en: 'jQuery UI: [https://jqueryui.com/](https://jqueryui.com/)'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'jQuery UI: [https://jqueryui.com/](https://jqueryui.com/)'
- en: 'modernizr: [http://www.modernizr.com/](http://www.modernizr.com/)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'modernizr: [http://www.modernizr.com/](http://www.modernizr.com/)'
- en: 'Prototype: [http://www.prototypejs.org/](http://www.prototypejs.org/)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Prototype: [http://www.prototypejs.org/](http://www.prototypejs.org/)'
- en: 'RequireJS: [http://requirejs.org/](http://requirejs.org/)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'RequireJS: [http://requirejs.org/](http://requirejs.org/)'
- en: 'script.aculo.us: [http://script.aculo.us/](http://script.aculo.us/)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'script.aculo.us: [http://script.aculo.us/](http://script.aculo.us/)'
- en: 'moment.js: [http://momentjs.com/](http://momentjs.com/)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'moment.js: [http://momentjs.com/](http://momentjs.com/)'
- en: 'Underscore.js: [http://underscorejs.org/](http://underscorejs.org/)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Underscore.js: [http://underscorejs.org/](http://underscorejs.org/)'
- en: 'gruntjs: [http://gruntjs.com/](http://gruntjs.com/)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'gruntjs: [http://gruntjs.com/](http://gruntjs.com/)'
- en: 'AngularJS: [https://angularjs.org/](https://angularjs.org/)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'AngularJS: [https://angularjs.org/](https://angularjs.org/)'
- en: 'jasmine: [http://jasmine.github.io/](http://jasmine.github.io/)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'jasmine: [http://jasmine.github.io/](http://jasmine.github.io/)'
- en: … and a few others
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: …以及一些其他库
- en: Though a frontend developer is not required to know the ins and outs of every
    library, it is recommended to at least have a basic insight into most of them.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前端开发者不需要了解每个库的细节，但至少对其中大多数有一个基本的了解是推荐的。
- en: Tip
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is worth running `find` `{MAGENTO-DIR}/` `-name` `\*.js` `>` `js-list.txt`
    on the console to get a full list of each and every JavaScript file in Magento.
    Spending a few minutes glossing over the list might serve as a nice future memo
    when working with JavaScript bits in Magento.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 值得在控制台运行 `find` `{MAGENTO-DIR}/` `-name` `\*.js` `>` `js-list.txt` 来获取 Magento
    中每个 JavaScript 文件的全列表。花几分钟浏览这个列表，可能会在将来处理 Magento 中的 JavaScript 时作为一个不错的备忘录。
- en: The RequireJS and jQuery libraries are probably the *most interesting* ones,
    as they often step into the spotlight during frontend development. RequireJS plays
    a big role in Magento, as it loads other JavaScript files. Using a modular script
    loader like RequireJS improves the speed of code. Speed improvement comes from
    removing JavaScript from the header and asynchronously or lazy loading JavaScript
    resources in the background.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript resources can be specified as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Library level for all libraries in the Magento code base (`lib/web`).
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module level for all libraries in a module (`app/code/{vendorName}/{moduleName}/view/{area}/web`).
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theme for all libraries in a theme (`app/design/{area}/{vendorName}/{theme}/{vendorName}_{moduleName}/web`).
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All libraries in a theme (`app/design/{area}/{vendorName}/{theme}/web`). Though
    possible, it is not recommended using this level to specify JavaScript resources.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended to specify JavaScript resources in the templates rather than
    in the layout updates. This way, we ensure processing of the resources through
    RequireJS.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: To work with the RequireJS library, specify the mapping of JavaScript resources;
    that is, assign the aliases to resources. Use `requires-config.js` to create the
    mapping.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our configurations more precise and specific for different modules/themes,
    we can identify mapping in the `requires-config.js` file at several levels depending
    on our needs. Configurations are collected and executed in the following order:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Library configurations
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurations at the module level
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurations at the theme module level for the ancestor themes
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurations at the theme module level for a current theme
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurations at the theme level for the ancestor themes
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurations at the theme level for the current theme
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we speak of JavaScript in Magento, we can hear various terms like component
    and widget. We can easily divide those terms by describing the type of JavaScript
    in Magento as per the following list:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript component (JS component)**: This can be any single JavaScript
    file decorated as an **AMD** (short for **Asynchronous Module Definition**) module'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ui component**: A JavaScript component located in the `Magento_Ui` module'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jQuery UI widget**: A JavaScript component/widget provided by the jQuery
    UI library used in Magento'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jQuery widget**: A custom widget created using jQuery UI Widget Factory and
    decorated as an AMD module'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two ways we can initialize a JavaScript component in template files:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Using the `data-mage-init` attribute
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `<script>` tag
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `data-mage-init` attribute is parsed on a DOM ready event. Since it is
    initialized on a certain element, the script is called only for that particular
    element, and is not automatically initialized for other elements of the same type
    on the page. An example of `data-mage-init` usage would be something like the
    following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `<script>` tag initialization is done without relation to any specific
    element, or in relation to a specific element but no direct access to the element.
    The script tag has to have an attribute, `type="text/x-magento-init"`. An example
    of `<script>` tag initialization would be something like the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`<script>`标签的初始化与任何特定元素无关，或者与特定元素相关但无法直接访问该元素。脚本标签必须有一个属性，`type="text/x-magento-init"`。一个`<script>`标签初始化的例子可能如下所示：'
- en: '[PRE31]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Depending on the situation and desired level of expressiveness, we can either
    opt for usage of `data-mage-init` or attribute or `<script>` tag.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 根据具体情况和所需的表达程度，我们可以选择使用`data-mage-init`属性或`<script>`标签。
- en: Creating a custom JS component
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义JS组件
- en: 'Let''s go through a practical example of creating a JS component within our
    `Foggyline_Office` module in a form of the jQuery widget as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个实际例子来创建`Foggyline_Office`模块中的JS组件，形式如下jQuery小部件：
- en: 'First, we add our entry to `app/code/Foggyline/Office/view/frontend/requirejs-config.js`,
    as shown:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将条目添加到`app/code/Foggyline/Office/view/frontend/requirejs-config.js`中，如下所示：
- en: '[PRE32]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then we add the actual JavaScript `app/code/Foggyline/Office/view/frontend/web/js/foggyline-hello.js`
    with content as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加实际的JavaScript文件`app/code/Foggyline/Office/view/frontend/web/js/foggyline-hello.js`，内容如下：
- en: '[PRE33]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we call our JavaScript component within some PHTML template, let''s
    say `app/code/Foggyline/Office/view/frontend/templates/office/hello.phtml`, as
    show:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在某个PHTML模板中调用我们的JavaScript组件，例如`app/code/Foggyline/Office/view/frontend/templates/office/hello.phtml`，如下所示：
- en: '[PRE34]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Once we refresh the frontend, we should see the result of `alert(this.options)`
    in the browser showing `myVar1` and `myVar2`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新前端后，我们应该在浏览器中看到`alert(this.options)`的结果，显示`myVar1`和`myVar2`。
- en: The `data-mage-init` part basically triggers as soon as the page loads. It is
    not triggered via some click or similar event on top of the `div` element; it
    is triggered on page load.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`data-mage-init`部分基本上在页面加载时触发。它不是通过在`div`元素上的一些点击或类似事件触发的；它是在页面加载时触发的。'
- en: If we don't see the desired result in the browser, we might need to fully clear
    the cache in the admin area.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中没有看到期望的结果，我们可能需要在管理区域完全清除缓存。
- en: CSS
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS
- en: Magento uses a PHP port of the official LESS processor to parse the `.less`
    files into `.css` files. LESS is a CSS preprocessor that extends the CSS language
    by adding various features to it, like variables, mixins, and functions. All of
    this makes CSS more maintainable, extendable, and easier to theme. Frontend developers
    are thus expected to write LESS files that Magento then converts to appropriate
    CSS variants.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Magento使用官方LESS处理器的PHP端口将`.less`文件解析为`.css`文件。LESS是一个CSS预处理器，通过向CSS语言添加各种功能来扩展它，如变量、混合和函数。所有这些使得CSS更易于维护、扩展和主题化。因此，前端开发者应编写LESS文件，然后由Magento转换为适当的CSS变体。
- en: Tip
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is worth running `find` `{MAGENTO-DIR}/` `-name` `\*.less` `>` `less-list.txt`
    on the console to get a full list of each and every LESS file in Magento. Spending
    a few minutes glossing over the list might serve as a nice future memo when working
    with style sheet bits in Magento.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 值得在控制台中运行`find `{MAGENTO-DIR}/` `-name` `\*.less` `>` `less-list.txt`来获取Magento中每个LESS文件的全列表。花几分钟浏览这个列表可能会在处理Magento中的样式表片段时作为一个很好的未来备忘录。
- en: 'We can customize the storefront look and feel through one of the following
    approaches:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方法之一来定制店面外观和感觉：
- en: Override the default LESS files – only if our theme inherits from the default
    or any other theme, in which case we can override the actual LESS files
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖默认的LESS文件——只有当我们的主题继承自默认主题或任何其他主题时，我们才能覆盖实际的LESS文件
- en: Create our own LESS files using the built-in LESS preprocessor
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置的LESS预处理器创建我们自己的LESS文件
- en: Create our own CSS files, optionally having compiled them using a third-party
    CSS preprocessor
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们自己的CSS文件，可选地使用第三方CSS预处理器编译它们
- en: 'Within the individual frontend theme directory, we can find style sheets at
    the following locations:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在单独的前端主题目录中，我们可以在以下位置找到样式表：
- en: '`{vendorName}_{moduleName}/web/css/source/`'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{vendorName}_{moduleName}/web/css/source/`'
- en: '`{vendorName}_{moduleName}/web/css/source/module/`'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{vendorName}_{moduleName}/web/css/source/module/`'
- en: '`web/css/`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web/css/`'
- en: '`web/css/source/`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web/css/source/`'
- en: 'CSS files can be included in a page through templates and layout files. A recommended
    way is to include them through layout files. If we want our style sheets to be
    available through all pages on the frontend, we can add using the `default_head_blocks.xml`
    file. If we look at the `blank` theme, it uses `vendor/magento/theme-frontend-blank/Magento_Theme/layout/default_head_blocks.xml`
    defined as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 文件可以通过模板和布局文件包含在页面中。一种推荐的方法是通过布局文件包含它们。如果我们想让我们的样式表在前端的所有页面上都可用，我们可以通过添加
    `default_head_blocks.xml` 文件来实现。如果我们查看 `blank` 主题，它使用 `vendor/magento/theme-frontend-blank/Magento_Theme/layout/default_head_blocks.xml`，如下定义：
- en: '[PRE35]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All it takes is for us to copy this file in the same location under our custom
    theme; assuming it's the `jupiter` theme from the preceding examples, that would
    be `app/design/frontend/Foggyline/jupiter/Magento_Theme/layout/default_head_blocks.xml`.
    Then we simply modify the file to include our CSS.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的只是将此文件复制到我们自定义主题的相同位置；假设它是前面示例中的 `jupiter` 主题，那么就是 `app/design/frontend/Foggyline/jupiter/Magento_Theme/layout/default_head_blocks.xml`。然后我们只需修改文件以包含我们的
    CSS。
- en: When run, Magento will try to find the included CSS files. If a CSS file is
    not found, it then searches for the same filenames with a `.less` extension. This
    is part of the built-in preprocessing mechanism.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时，Magento 将尝试查找包含的 CSS 文件。如果找不到 CSS 文件，它将搜索具有 `.less` 扩展名的同名文件。这是内置的预处理机制的一部分。
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we started off by looking into the three aspects of the rendering
    flow process: the view, result object, and pages. Then we took a detailed look
    at three primary view elements: `ui-components`, `containers`, and `blocks`. We
    further studied blocks in depth, looking into their architecture and life cycle.
    We moved on to templates, looking into their locations, rendering, and fallback.
    Then came XML layouts, as the glue between blocks and templates. All of this gave
    us a foundation for further looking into theme structure, JavaScript components,
    and CSS. Along the way, we did a little bit of hands-on with a custom theme and
    JavaScript components creation. CSS and JavaScript is merely a fragment of what
    the Magento frontend is all about. Technology-wise, having a solid understanding
    of XML and even some PHP is more of a requirement than an exception for frontend-related
    development.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先探讨了渲染流程过程的三个方面：视图、结果对象和页面。然后我们详细研究了三个主要视图元素：`ui-components`、`containers`
    和 `blocks`。我们进一步深入研究了块，探讨了它们的架构和生命周期。然后我们转向模板，探讨了它们的定位、渲染和回退。接下来是 XML 布局，它是块和模板之间的粘合剂。所有这些都为我们进一步研究主题结构、JavaScript
    组件和 CSS 奠定了基础。在这个过程中，我们还进行了一些关于自定义主题和 JavaScript 组件创建的动手实践。CSS 和 JavaScript 只是
    Magento 前端的一部分。从技术角度来看，对 XML 的扎实理解，甚至一些 PHP，对于前端相关开发来说，更多的是一种要求而不是例外。
- en: The following chapter will introduce us to Magento's web API where we will learn
    how to authenticate, make API calls, and even build our own APIs.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍 Magento 的 Web API，我们将学习如何进行身份验证、进行 API 调用，甚至构建我们自己的 API。
