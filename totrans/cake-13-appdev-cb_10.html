<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Testing</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up the test framework</li><li class="listitem" style="list-style-type: disc">Creating fixtures and testing model methods</li><li class="listitem" style="list-style-type: disc">Testing controller actions and their views</li><li class="listitem" style="list-style-type: disc">Using mocks to test controllers</li><li class="listitem" style="list-style-type: disc">Running tests from the command line</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec01"/>Introduction</h1></div></div></div><p>This chapter covers one of the most interesting areas of application programming: unit testing through CakePHP's built-in tools, which offers a complete and powerful unit testing framework.</p><p>The first recipe shows how to set up the test framework so that we can create our own test cases. The second recipe shows how to create test data (fixtures) and use that data to test model methods. The third and fourth recipes show how to test controller actions, and how to test that our views are showing what we expect. The last recipe shows how to run the test in a non-ordinary fashion.</p></div></div>
<div class="section" title="Setting up the test framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec02"/>Setting up the test framework</h1></div></div></div><p>In this recipe, we will learn how to prepare our CakePHP application with all the elements needed to create our own unit tests, setting up the foundation for the rest of the recipes in this chapter.<a id="id346" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec01"/>Getting ready</h2></div></div></div><p>To go through the recipes included in this chapter, we need some data to work with. Create the following tables by issuing these SQL statements:<a id="id347" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">CREATE TABLE `articles`(
`id`INT UNSIGNED NOT NULL AUTO_INCREMENT,
`title` VARCHAR(255) NOT NULL,
`body` TEXT NOT NULL,
PRIMARY KEY(`id`)
);
CREATE TABLE `users`(
`id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
`username` VARCHAR(255) NOT NULL,
PRIMARY KEY(`id`)
);
CREATE TABLE `votes`(
`id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
`article_id` INT NOT NULL,
`user_id` INT NOT NULL,
`vote` INT UNSIGNED NOT NULL,
PRIMARY KEY(`id`),
FOREIGN KEY `votes__articles`(`article_id`) REFERENCES `articles`(`id`),
FOREIGN KEY `votes__users`(`user_id`) REFERENCES `users`(`id`)
);
</pre></div><p>Create a controller in a file named<code class="literal"> articles_controller.php</code> and place it in your<code class="literal"> app/controllers</code> folder, with the following contents:</p><div class="informalexample"><pre class="programlisting">&lt;?php
class ArticlesController extends AppController {
public function vote($id) {
if (!empty($this-&gt;data)) {
if ($this-&gt;Article-&gt;vote($id, $this-&gt;data)) {
$this-&gt;Session-&gt;setFlash('Vote placed');
return $this-&gt;redirect(array('action'=&gt;'index'));
} else {
$this-&gt;Session-&gt;setFlash('Please correct the errors');
}
}
}
public function view($id) {
$article = $this-&gt;Article-&gt;get($id);
if (empty($article)) {
$this-&gt;Session-&gt;setFlash('Article not found');
return $this-&gt;redirect(array('action' =&gt; 'index'));
}
$this-&gt;set(compact('article'));
}
}
?&gt;
</pre></div><p>Create a file named<code class="literal"> article.php</code> and place it in your<code class="literal"> app/models</code> folder, with the following contents:<a id="id348" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
class Article extends AppModel
{
public $hasMany = array('Vote');
public function get($id)
{
return $this-&gt;find('first', array( 'fields' =&gt; array( 'Article.*', 'AVG(Vote.vote) AS vote' ),
'joins' =&gt; array(
array(
'type' =&gt; 'LEFT',
'table' =&gt; $this-&gt;Vote-&gt;getDataSource()- &gt;fullTableName($this-&gt;Vote-&gt;table),
'alias' =&gt; 'Vote',
'conditions' =&gt; array(
'Vote.article_id = Article.id'
)
)
),
'conditions' =&gt; array('Article.id' =&gt; $id),
'group' =&gt; array(
'Article.id'
),
'recursive' =&gt; -1
));
}
public function vote($id, $data = array()) {
if (empty($data) || empty($data['Vote'])) {
throw new Exception("No data specified");
}
$data['Vote']['article_id'] = $id;
$this-&gt;Vote-&gt;create($data);
if (!$this-&gt;Vote-&gt;validates()) {
return false;
}
$conditions = array(
'Vote.user_id' =&gt; $data['Vote']['user_id'],
'Vote.article_id' =&gt; $data['Vote']['article_id']
);
if ($this-&gt;Vote-&gt;hasAny($conditions)) {
return false;
}
return ($this-&gt;Vote-&gt;save($data) !== false);
}
}
?&gt;
</pre></div><p>Create a file named<code class="literal"> vote.php</code> and place it in your<code class="literal"> app/models</code> folder with the following contents:<a id="id349" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
class Vote extends AppModel {
public $belongsTo = array('Article', 'User');
public $validate = array(
'article_id' =&gt; array('required' =&gt; true, 'rule' =&gt; 'notEmpty'),
'user_id' =&gt; array('required' =&gt; true, 'rule' =&gt; 'notEmpty'),
'vote' =&gt; array(
'required' =&gt; array('required' =&gt; true, 'rule' =&gt; 'notEmpty'),
'range' =&gt; array(
'rule' =&gt; array('range', 0, 6),
'allowEmpty' =&gt; true
)
)
);
}
?&gt;
</pre></div><p>Create a folder named<code class="literal"> articles</code> and place it in your<code class="literal"> app/views</code> folder. Create a file named<code class="literal"> view.ctp</code> and place it in your<code class="literal"> app/views/articles</code> folder, with the following contents:<a id="id350" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;h1&gt;&lt;?php echo $article['Article']['title']; ?&gt;&lt;/h1&gt;
Vote: &lt;span id="vote"&gt;&lt;?php echo number_format($article[0]['vote'], 1); ?&gt;&lt;/span&gt;
&lt;p&gt;&lt;?php echo $article['Article']['body']; ?&gt;&lt;/p&gt;
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec02"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download the 1.0.1 SimpleTest release from <a class="ulink" href="http://https://sourceforge.net/projects/simpletest/files/simpletest/simpletest_1.0.1/simpletest_1.0.1.tar.gz/download">https://sourceforge.net/projects/simpletest/files/simpletest/simpletest_1.0.1/simpletest_1.0.1.tar.gz/download</a>. Uncompress the downloaded file into your<code class="literal"> app/vendors</code> folder. You should now have a folder named<code class="literal"> simpletest</code> in<code class="literal"> app/vendors</code>.</li><li class="listitem">If you now browse to<code class="literal"> http://localhost/test.php</code>, you should see the list of test groups available in CakePHP as shown in the next screenshot:<div class="mediaobject"><img src="graphics/1926OS_10_01.jpg" alt="How to do it..."/></div></li><li class="listitem">Clicking on any of these groups would execute the appropriate unit tests. For example, if you click on the<span class="strong"><strong> acl</strong></span> test group, you should see a green bar indicating that all tests for the selected group succeeded, as shown in the next screenshot:<a id="id351" class="indexterm"/><div class="mediaobject"><img src="graphics/1926OS_10_02.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec03"/>How it works...</h2></div></div></div><p>CakePHP uses the SimpleTest library as the backbone of its unit testing framework. Unless we have installed SimpleTest on our application, we will be unable to run any unit test. Installing the library is as simple as downloading the appropriate version and extracting its contents into our<code class="literal"> app/vendors</code> folder.<a id="id352" class="indexterm"/>
</p><p>The framework includes a broad set of unit tests that cover almost every functionality implemented in the core. These unit tests allow the developer to report bugs against core functionality, have them solved, and make sure those bugs do not reappear in future releases.</p></div></div>
<div class="section" title="Creating fixtures and testing model methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec03"/>Creating fixtures and testing model methods</h1></div></div></div><p>In this recipe, we will learn how to create test data that we can use to test our application without altering real data, and how to create our own unit tests to cover model functionality.<a id="id353" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec04"/>Getting ready</h2></div></div></div><p>To go through this recipe, we need a basic application skeleton to work with and have the SimpleTest library installed. Go through the entire recipe,<span class="emphasis"><em> Setting up the test framework</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec05"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a file named<code class="literal"> article_fixture.php</code> and place it in your<code class="literal"> app/tests/fixtures</code> folder with the following contents:<a id="id354" class="indexterm"/><div class="informalexample"><pre class="programlisting">&lt;?php
class ArticleFixture extends CakeTestFixture {
public $import = 'Article';
public $records = array(
array(
'id' =&gt; 1,
'title' =&gt; 'Article 1',
'body' =&gt; 'Body for Article 1'
),
array(
'id' =&gt; 2,
'title' =&gt; 'Article 2',
'body' =&gt; 'Body for Article 2'
)
);
}
?&gt;
</pre></div></li><li class="listitem">Create a file named<code class="literal"> user_fixture.php</code> and place it in your<code class="literal"> app/tests/fixtures</code> folder with the following contents:<div class="informalexample"><pre class="programlisting">&lt;?php
class UserFixture extends CakeTestFixture {
public $table = 'users';
public $import = array('table' =&gt; 'users');
public $records = array(
array(
'id' =&gt; 1,
'username' =&gt; 'john.doe'
),
array(
'id' =&gt; 2,
'username' =&gt; 'jane.doe'
),
array(
'id' =&gt; 3,
'username' =&gt; 'mark.doe'
)
);
}
?&gt;
</pre></div></li><li class="listitem">Create a file named<code class="literal"> vote_fixture.php</code> and place it in your<code class="literal"> app/tests/fixtures</code> folder, with the following contents:<div class="informalexample"><pre class="programlisting">&lt;?php
class VoteFixture extends CakeTestFixture {
public $import = 'Vote';
public $records = array(
array(
'article_id' =&gt; 1,
'user_id' =&gt; 1,
'vote' =&gt; 4
),
array(
'article_id' =&gt; 1,
'user_id' =&gt; 3,
'vote' =&gt; 5
),
array(
'article_id' =&gt; 1,
'user_id' =&gt; 2,
'vote' =&gt; 4
),
array(
'article_id' =&gt; 2,
'user_id' =&gt; 2,
'vote' =&gt; 3
),
array(
'article_id' =&gt; 2,
'user_id' =&gt; 3,
'vote' =&gt; 4
)
);
}
?&gt;
</pre></div></li><li class="listitem">Create a file named<code class="literal"> article.test.php</code> and place it in your<code class="literal"> app/tests/cases/models</code> folder with the following contents:<a id="id357" class="indexterm"/><div class="informalexample"><pre class="programlisting">&lt;?php
class ArticleTestCase extends CakeTestCase {
public $fixtures = array('app.article', 'app.user', 'app.vote');
public function startTest($method) {
parent::startTest($method);
$this-&gt;Article = ClassRegistry::init('Article');
}
public function endTest($method) {
parent::endTest($method);
ClassRegistry::flush();
}
public function testGet() {
$article = $this-&gt;Article-&gt;get(1);
$this-&gt;assertTrue(!empty($article) &amp;&amp; !empty($article['Article']));
$this-&gt;assertTrue(!empty($article[0]) &amp;&amp; !empty($article[0]['vote']));
$this-&gt;assertEqual(number_format($article[0]['vote'], 1), 4.3);
$article = $this-&gt;Article-&gt;get(2);
$this-&gt;assertTrue(!empty($article) &amp;&amp; !empty($article['Article']));
$this-&gt;assertTrue(!empty($article[0]) &amp;&amp; !empty($article[0]['vote']));
$this-&gt;assertEqual(number_format($article[0]['vote'], 1), 3.5);
}
public function testVote() {
$result = $this-&gt;Article-&gt;vote(2, array('Vote' =&gt; array(
'user_id' =&gt; 2
)));
$this-&gt;assertFalse($result);
$this-&gt;assertTrue(!empty($this-&gt;Article-&gt;Vote-&gt;validationErrors['vote']));
$result = $this-&gt;Article-&gt;vote(2, array('Vote' =&gt; array(
'user_id' =&gt; 2,
'vote' =&gt; 6
)));
$this-&gt;assertFalse($result);
$this-&gt;assertEqual($this-&gt;Article-&gt;Vote-&gt;validationErrors['vote'], 'range');
$result = $this-&gt;Article-&gt;vote(2, array('Vote' =&gt; array(
'user_id' =&gt; 2,
'vote' =&gt; 1
)));
$this-&gt;assertFalse($result);
$result = $this-&gt;Article-&gt;vote(2, array('Vote' =&gt; array(
$result = $this-&gt;Article-&gt;vote(2, array('Vote' =&gt; array(
'user_id' =&gt; 1,
'vote' =&gt; 1
)));
$this-&gt;assertTrue($result);
$article = $this-&gt;Article-&gt;get(2);
$this-&gt;assertTrue(!empty($article[0]) &amp;&amp; !empty($article[0]['vote']));
$this-&gt;assertEqual(number_format($article[0]['vote'], 1), 2.7);
$this-&gt;expectException();
$this-&gt;Article-&gt;vote(2);
}
}
?&gt;
</pre></div></li></ol></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec06"/>How it works...</h3></div></div></div><p>When looking to test model methods, it is very important to know what data is used during testing. Even when it is perfectly possible to test models using real application data, it is often safer (and thus recommendable) to specify the data that will be used for testing. This way, any modification to real data should not affect our tests, and consequently running those tests should not affect real data.<a id="id359" class="indexterm"/>
</p><p>For this very purpose, CakePHP offers the concept of fixtures, which are no more than PHP classes that define the table structure and data used for testing models. These fixtures should have the same name as the model they are providing data for, should extend the base class<code class="literal"> CakeTestFixture</code>, and should end with the word<code class="literal"> Fixture</code>. The file name should be the underscored version of the class name, and should be placed in the<code class="literal"> app/tests/fixtures</code> directory. A fixture may define the following properties:<a id="id360" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">name</code>: The name of the fixture, used to determine the name of the table this fixture creates. If the table name can be determined by other means, such as by setting the<code class="literal"> table</code> property, or by importing the structure from a model, then this property is optional.<a id="id361" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">table</code>: The table this fixture creates. If the fixture imports the structure from an existing model, or if the<code class="literal"> name</code> property is specified, then this property is optional.<a id="id362" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">import</code>: This property is optional and allows the structure, and/or data, to be imported from an existing source. If this property is set to a string, then it is a model name from where to import the structure (not the records.) Otherwise, it should be an array that consists of the following settings:<a id="id363" class="indexterm"/><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">records</code>: An optional Boolean setting. If set to<code class="literal"> true</code>, then all records will be imported from the specified source. Defaults to<code class="literal"> false</code>.<a id="id364" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">model</code>: The model from where to import the structure, and/or data. If specified, this model must exist.<a id="id365" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">table</code>: The table from where to import the structure, and/or data. If the<code class="literal"> model</code> setting is specified, this setting is ignored and thus is optional.<a id="id366" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">fields</code>: If<code class="literal"> import</code> is not defined, then this property is mandatory. It should be an array where each key is a field name, and each value the definition of the field, containing settings such as:<code class="literal"> type, length, null, default</code>, and<code class="literal"> key</code>. For more information about these settings, see <a class="ulink" href="http://book.cakephp.org/view/1203/Creating-fixtures">http://book.cakephp.org/view/1203/Creating-fixtures</a>.<a id="id367" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">records</code>: An array of records, each record itself being an array where the keys are the field names, and the values their respective values.</li></ul></div></li></ul></div><p>We start by creating the following fixtures:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ArticleFixture</code>: It imports its structure from the<code class="literal"> Article</code> model, and defines two records.<a id="id368" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">UserFixture</code>: It imports its structure from the<code class="literal"> users</code> table and defines three records (Notice how we import from a table instead of a model, as we did not create a<code class="literal"> User</code> model).<a id="id369" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">VoteFixture</code>: It imports its structure from the<code class="literal"> Vote</code> model, and defines five records.<a id="id370" class="indexterm"/></li></ul></div><p>After creating the fixtures, we proceed to build the test case. A test case is a PHP class without naming restrictions that contains unit tests. It extends from<code class="literal"> CakeTestCase</code>, and is saved in a file ending with the suffix<code class="literal"> .test.php</code> and placed in an appropriate subdirectory of the<code class="literal"> app/tests/cases</code> folder. A unit test is a method of a test case class, but only methods with names starting with the word<code class="literal"> test</code> are considered unit tests and thus run when the test case is executed.</p><p>Our test case is named<code class="literal"> ArticleTestCase</code>, and defines the<code class="literal"> fixtures</code> property to specify which fixtures are utilized by the test case. These names should match the fixture file name, without the<code class="literal"> _fixture.php</code> suffix. By means of these fixtures, we provide test data for the models used throughout our test case.</p><p>Whenever you instantiate models from a unit test, and unless you specify otherwise through settings sent to the<code class="literal"> ClassRegistry::init()</code> method, CakePHP will automatically set the model's database configuration to be<code class="literal"> test_suite</code>, not only for the directly instantiated models, but for any models instantiated as a result of a binding definition.</p><p>The<code class="literal"> test_suite</code> database configuration, unless specifically changed by the developer, will use the same database configuration as defined in the<code class="literal"> default</code> configuration, and will also set<code class="literal"> test_suite_</code> as a table prefix to avoid overwriting existing tables. This means that any models that are instantiated, together with their bindings (including bindings of bindings, and so on) should have a matching fixture, and those fixtures should be added to the test case. If you want to avoid defining fixtures for models you do not intend to test, see the section<span class="emphasis"><em> Extending models to avoid testing unneeded bindings</em></span> in this recipe.</p><p>The first two methods in<code class="literal"> ArticleTestCase</code> are implementations of callbacks offered by the parent class<code class="literal"> CakeTestCase</code>. There are four callbacks available:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">startCase()</code>: It executed before the first unit test method is run. This method is executed once per test case.<a id="id371" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">endCase()</code>: It executed after the last unit test method was run. This method is executed once per test case.<a id="id372" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">startTest()</code>: It executed before each unit test method is run. It receives a single argument, which is the name of the test method that is about to be executed.<a id="id373" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">endTest()</code>: It executed after each unit test method was run. It receives a single argument, which is the name of the test method.<a id="id374" class="indexterm"/></li></ul></div><p>We use the<code class="literal"> startTest()</code> callback to instantiate the model we intend to test (Article in this case), and the<code class="literal"> endTest()</code> callback to clean up the registry, a step that is not needed for this particular test case but that serves useful in many other scenarios.</p><p>We then define two unit test methods:<code class="literal"> testGet()</code> and<code class="literal"> testVote()</code>. The first one is meant to provide testing for the<code class="literal"> Article::get()</code> method, while the later tests the creation of votes through the<code class="literal"> Article::vote()</code> method. In these tests, we issue different calls to the model method we are testing, and then use some of the test case assertion methods to evaluate these calls:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">assertTrue()</code>: Asserts that the provided argument evaluates to<code class="literal"> true</code>.<a id="id375" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertFalse()</code>: Asserts that the provided argument evaluates to<code class="literal"> false</code>.<a id="id376" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertEqual()</code>: Asserts that the first argument is equal to the second argument.<a id="id377" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">expectException()</code>: Expects the next call to produce an exception. Because of the way exceptions are handled, this assertion should be made last in the test method, as any code within that unit test method that should be executed after the exception is thrown will be ignored. Another approach to avoid this limitation is to use a try-catch block, and manually issue a call to the<code class="literal"> fail()</code> or<code class="literal"> pass()</code> method as a result.<a id="id378" class="indexterm"/></li></ul></div><p>There are other assertion methods that are useful in other scenarios, such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">assertIsA()</code>: Asserts that the first argument is an object of the type provided in the second argument.<a id="id379" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertNull()</code>: Asserts that the provided argument is<code class="literal"> null</code>.<a id="id380" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertPattern()</code>: Asserts that the second argument matches the regular expression pattern defined in the first argument.<a id="id381" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">assertTags()</code>: Asserts that the first argument matches the HTML tags provided in the second argument, without consideration to the order of tag attributes. See recipe<span class="emphasis"><em> Testing views</em></span> for an example use of this assertion method.<a id="id382" class="indexterm"/></li></ul></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec07"/>There's more...</h3></div></div></div><p>This recipe has shown us how to easily create fixtures. However, when there are lots of models in our application this can become quite a tedious task. Fortunately, CakePHP's<code class="literal"> bake</code> command offers a task to automatically create fixtures:<code class="literal"> fixture</code>.</p><p>It can run in interactive mode where its questions guide us through the steps required, or by using command line parameters. If we wanted to create a fixture for our<code class="literal"> Article</code> model with up to two records, we would do:</p><p>On a GNU Linux / Mac / Unix system:</p><div class="informalexample"><pre class="programlisting">../cake/console/cake bake fixture article -count 2
</pre></div><p>On Microsoft Windows:</p><div class="informalexample"><pre class="programlisting">..\cake\console\cake.bat fixture article -count 2
</pre></div><p>This would generate the<code class="literal"> article_fixture.php</code> file in its correct location, with two sample records ready to be used.</p><div class="section" title="Extending models to avoid testing unneeded bindings"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec01"/>Extending models to avoid testing unneeded bindings</h4></div></div></div><p>In this recipe, we tested code that affects the<code class="literal"> Article</code> and<code class="literal"> Vote</code> models, but none of the functionality that was covered by these unit tests had to interact with the<code class="literal"> User</code> model. Why did we then need to add the<code class="literal"> user</code> fixture? Simply removing this fixture from the<code class="literal"> fixtures</code> property will make CakePHP complain about a missing table (specifically,<code class="literal"> test_suite_users</code>).</p><p>To avoid creating fixtures for models we are not testing, we can create modified versions of our model classes by extending them and re-defining their bindings, leaving in only those we intend to test. Let us modify our test case to avoid using the<code class="literal"> user</code> fixture.<a id="id383" class="indexterm"/>
</p><p>Add the following to the beginning of your<code class="literal"> app/tests/cases/models/article.test.php</code> file:</p><div class="informalexample"><pre class="programlisting">App::import('Model', array('Article', 'Vote'));
class TestArticle extends Article {
public $belongsTo = array();
public $hasOne = array();
public $hasMany = array(
'Vote' =&gt; array('className' =&gt; 'TestVote')
);
public $hasAndBelongsToMany = array();
public $alias = 'Article';
public $useTable = 'articles';
public $useDbConfig = 'test_suite';
}
class TestVote extends Vote {
public $belongsTo = array();
public $hasOne = array();
public $hasMany = array();
public $hasAndBelongsToMany = array();
public $alias = 'Vote';
public $useTable = 'votes';
public $useDbConfig = 'test_suite';
}
</pre></div><p>While still editing the<code class="literal"> article.test.php file</code>, change the<code class="literal"> fixtures</code> property of the<code class="literal"> ArticleTestCase</code> class so that the user fixture is no longer loaded:</p><div class="informalexample"><pre class="programlisting">public $fixtures = array('app.article', 'app.vote');
</pre></div><p>Finally, change the instantiation of the<code class="literal"> Article</code> model so that it uses<code class="literal"> TestArticle</code> instead, by making the following changes to the<code class="literal"> startTest()</code> method of the<code class="literal"> ArticleTestCase</code> class:<a id="id384" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">public function startTest($method)
{
parent::startTest($method);
$this-&gt;Article = ClassRegistry::init('TestArticle');
}
</pre></div></div><div class="section" title="Analyzing code coverage"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec02"/>Analyzing code coverage</h4></div></div></div><p>If you have<span class="strong"><strong> Xdebug</strong></span> installed (information about it is available at <a class="ulink" href="http://xdebug.org">http://xdebug.org</a>) you can find out how much of your application code is covered by your unit tests. This information is a great tool for understanding which parts of your application need more testing.<a id="id385" class="indexterm"/>
</p><p>Once you have run a test case, you will notice a link entitled<span class="strong"><strong> Analyze Code Coverage</strong></span>. After running our test case, click on this link. CakePHP will inform us that we have fully covered (<span class="strong"><strong>100%</strong></span> coverage) our code. If you now comment out the unit test method called<code class="literal"> testVote()</code>, and then run the code coverage analysis, you will notice that this number drops to<span class="strong"><strong> 47.62%</strong></span>, and CakePHP also shows us which part of our code has not been covered by unit tests, as shown in the next screenshot:</p><div class="mediaobject"><img src="graphics/1926OS_10_03.jpg" alt="Analyzing code coverage"/></div><p>When you achieve<span class="strong"><strong> 100%</strong></span> code coverage, you are not guaranteeing that your code is bug-free, but that all lines of your application code have been reached by at least one unit test.<a id="id386" class="indexterm"/>
</p><p>The more code left out of the reach of unit tests, the more prone to bugs your application becomes.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec08"/>See also</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Testing controller actions and their views</em></span></li></ul></div></div></div></div>
<div class="section" title="Testing controller actions and their views"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec04"/>Testing controller actions and their views</h1></div></div></div><p>In this recipe, we will learn how to test controller actions and ensure that their views produce the result we expect.<a id="id387" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec09"/>Getting ready</h2></div></div></div><p>To go through this recipe we need a basic application skeleton to work with, and have the SimpleTest library installed. Go through the entire recipe<span class="emphasis"><em> Setting up the test framework</em></span>.</p><p>We also need test data. Go through the creation of fixtures described in the recipe<span class="emphasis"><em> Creating fixtures and testing model methods</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec10"/>How to do it...</h2></div></div></div><p>Create a file named<code class="literal"> articles_controller.test.php</code> and place it in your<code class="literal"> app/tests/cases/controllers</code> folder, with the following contents:</p><div class="informalexample"><pre class="programlisting">&lt;?php
class ArticlesControllerTestCase extends CakeTestCase {
public $fixtures = array('app.article', 'app.user', 'app.vote');
public function testView() {
$result = $this-&gt;testAction('/articles/view/1', array('return'=&gt;'vars'));
$expected = array(
'Article' =&gt; array(
'id' =&gt; 1,
'title' =&gt; 'Article 1',
'body' =&gt; 'Body for Article 1'
),
0 =&gt; array(
'vote' =&gt; 4.3333
)
);
$this-&gt;assertTrue(!empty($result['article']));
$this-&gt;assertEqual($result['article'], $expected);
$result = $this-&gt;testAction('/articles/view/1', array('return'=&gt;'view'));
$this-&gt;assertTags($result, array(
array('h1' =&gt; array()),
'Article 1',
'/h1',
'Vote:',
array('span' =&gt; array('id'=&gt;'vote')),
'4.3',
'/span',
array('p' =&gt; array()),
'Body for Article 1',
'/p'
));
}
?&gt;
</pre></div><p>If you now browse to <code class="literal">http://localhost/test.php</code>, click on the<span class="strong"><strong> Test Cases</strong></span> option under the<span class="strong"><strong> App</strong></span> section in the left menu, and then click on the<span class="strong"><strong> controllers / ArticlesController</strong></span> test case, you should see our unit test succeeding, as shown in the next screenshot:<a id="id388" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/1926OS_10_04.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec11"/>How it works...</h2></div></div></div><p>We start by creating the test case in a class named<code class="literal"> ArticlesControllerTestCase</code>, and save it in its proper location (<code class="literal">app/tests/cases/controllers</code>), using the right filename (<code class="literal">articles_controller.test.php</code>). In this class, we specify which fixtures we need to load, which, just as it was shown in the recipe<span class="emphasis"><em> Creating fixtures and testing model methods</em></span>, consists of fixtures for all the loaded models.<a id="id389" class="indexterm"/>
</p><p>Our test case includes a single unit test method:<code class="literal"> testView(),</code> which intends to unit test the<code class="literal"> ArticlesController::view()</code> action. In this unit test we use the<code class="literal"> testAction()</code> method that is available to all test cases. This method takes two arguments:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">url</code>: This is either a string or an array containing the URL to the controller action we intend to test. If it is an array, it should be in the same format as the format used by CakePHP once a string-based URL has been parsed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">parameters</code>: This is a set of optional parameters, which can be any of the following:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">connection</code>: If<code class="literal"> fixturize</code> is set to<code class="literal"> true</code>, it defines the connection from where to import data.</li><li class="listitem" style="list-style-type: disc"><code class="literal">data</code>: It is the data to post to the controller.</li><li class="listitem" style="list-style-type: disc"><code class="literal">fixturize</code>: If this is set to<code class="literal"> true</code>, then all data from the connection defined in the<code class="literal"> connection</code> setting will be imported into fixtures for all the used models. Defaults to<code class="literal"> false</code>.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">method</code>: This is the method to use when posting the data specified in the<code class="literal"> data</code> setting. Can either be<code class="literal"> get</code> or<code class="literal"> post</code>. Defaults to<code class="literal"> post</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">return</code>: This specifies the type of result that should be returned as a result of a<code class="literal"> testAction()</code> call. If it is set to<code class="literal"> result</code>, which is the default, it will return whatever the controller action returns. If it is set to<code class="literal"> vars</code>, it will return the view variables assigned from the action. If it is<code class="literal"> view</code>, it will return the rendered view without the layout. Finally, if it is set to<code class="literal"> contents</code>, it will return the rendered view within its layout.</li><li class="listitem" style="list-style-type: disc"><code class="literal">testView()</code>: The<code class="literal"> testView()</code> method calls the<code class="literal"> view()</code> action with a proper ID, and tells the<code class="literal"> testAction()</code> method to return the view variables created in the controller action. We make sure that this variable is set to the proper article information. We then finalize with a call to<code class="literal"> testAction()</code>, using the same URL, but specifying that we want to obtain the rendered view.</li></ul></div><p>To assert that the view has the proper content, we use the<code class="literal"> assertTags()</code> method, which offers a flexible way to check HTML tags. This method takes an array of elements, each element being either a string that represents a static string or a closing tag if the string starts with a forward slash, or an array, where the key is an HTML tag name, and the value is itself an array of attributes (keys being the attribute names, and values being their respective values).</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec12"/>There's more...</h2></div></div></div><p>We have seen how, by using<code class="literal"> testAction()</code>, we can easily test our controller actions and make assertions on either the action's return value, the view variables, or the view content. However, we have not covered how to test actions that might redirect the user away from the current action, or how to test for session operations. The next recipe shows how to add more complex tests to the unit tests we have just built.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec13"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using mocks to test controllers</em></span></li></ul></div></div></div>
<div class="section" title="Using mocks to test controllers"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec05"/>Using mocks to test controllers</h1></div></div></div><p>In this recipe we will learn how to extend what we have covered in the previous recipe by using mocks, an indispensable tool for building powerful test cases.<a id="id390" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec14"/>Getting ready</h2></div></div></div><p>To go through this recipe, we need unit tests already in place. Go through the previous recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec15"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Edit your<code class="literal"> app/tests/cases/controllers/articles_controller.test.php</code> file and place the following code at the beginning, right before the declaration of the class<code class="literal"> ArticlesControllerTestCase</code>:<div class="informalexample"><pre class="programlisting">App::import('Controller', 'Articles');
class TestArticlesController extends ArticlesController {
public $name = 'Articles';
public $testRedirect = false;
public function __construct() {
parent::__construct();
Configure::write('controllers.'.$this-&gt;name, $this);
}
public function beforeFilter() {
if (isset($this-&gt;Session)) {
App::import('Component', 'Session');
Mock::generate('SessionComponent');
$this-&gt;Session = new MockSessionComponent();
}
parent::beforeFilter();
}
public function redirect($url, $status = null, $exit = true) {
$this-&gt;testRedirect = compact('url', 'status', 'exit');
if ($exit) {
$this-&gt;autoRender = false;
}
}
}
</pre></div></li><li class="listitem">While still editing the<code class="literal"> articles_controller.test.php</code> file, add the following code at the beginning of the<code class="literal"> ArticlesControllerTestCase</code> class, right below the declaration of the<code class="literal"> fixtures</code> property:<a id="id391" class="indexterm"/><div class="informalexample"><pre class="programlisting">public function testAction($url, $params = array()) {
$url = preg_replace('/^\/articles\//', '/test_articles/', $url);
$result = parent::testAction($url, $params);
$this-&gt;Articles = Configure::read('controllers.Articles');
return $result;
}
</pre></div></li><li class="listitem">Add the following code at the beginning of the<code class="literal"> testView()</code> method:<a id="id392" class="indexterm"/><div class="informalexample"><pre class="programlisting">$result = $this-&gt;testAction('/articles/view/0');
$this-&gt;assertTrue(!empty($this-&gt;Articles-&gt;testRedirect));
$this-&gt;assertEqual($this-&gt;Articles-&gt;testRedirect['url'], array('action' =&gt; 'index'));
</pre></div></li><li class="listitem">Finally, add the following method to the end of the<code class="literal"> ArticlesControllerTestCase</code> class:<div class="informalexample"><pre class="programlisting">public function testVote() {
$result = $this-&gt;testAction('/articles/vote/2', array(
'data' =&gt; array(
'Vote' =&gt; array(
'user_id' =&gt; 1,
'vote' =&gt; 1
)
)
));
$this-&gt;assertTrue(!empty($this-&gt;Articles-&gt;testRedirect));
$this-&gt;assertEqual($this-&gt;Articles-&gt;testRedirect['url'], array('action' =&gt; 'index'));
$this-&gt;Articles-&gt;Session-&gt;expectOnce('setFlash', array('Vote placed'));
$article = $this-&gt;Articles-&gt;Article-&gt;get(2);
$this-&gt;assertTrue(!empty($article) &amp;&amp; !empty($article['Article']));
$this-&gt;assertTrue(!empty($article[0]) &amp;&amp; !empty($article[0]['vote']));
$this-&gt;assertEqual(number_format($article[0]['vote'], 1), 2.7);
}
</pre></div></li></ol></div><p>If you now browse to <code class="literal">http://localhost/test.php</code>, click on the<span class="strong"><strong> Test Cases</strong></span> option under the<span class="strong"><strong> App</strong></span> section in the left menu, and then click on the<span class="strong"><strong> controllers / ArticlesController</strong></span> test case, you should see our unit test succeeding, as shown in the next screenshot:<a id="id393" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/1926OS_10_05.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec16"/>How it works...</h2></div></div></div><p>We start by extending the controller we intend to test so we can override its<code class="literal"> redirect()</code> method, so that when that method is executed as part of our unit test, the browser is not redirected and we can instead use the redirect information to make our assertions.<a id="id394" class="indexterm"/>
</p><p>If<code class="literal"> redirect()</code> is called, we store the destination in a property named<code class="literal"> testRedirect</code>, and instead of aborting the execution (which would abort the test case) we avoid the view from being rendered. This works properly because every time we called<code class="literal"> redirect()</code> from our<code class="literal"> ArticlesController</code> class, we stopped the action execution by issuing a return statement.<a id="id395" class="indexterm"/>
</p><p>As there is no direct way to get the instance of the controller that was executed from our test case (see the section<span class="emphasis"><em> There's more</em></span> in this recipe for an alternative approach), we need to keep a reference of the controller instance. We use CakePHP's<code class="literal"> Configure</code> class to store the reference, so that it can then be easily obtained.</p><p>We also want to avoid using real session data as a result of our unit test. This means that we need to find a way to let CakePHP think that when a controller interacts with its<code class="literal"> Session</code> component, everything behaves as expected, while still not really interacting with the browser session. We also want to be able to assert when a particular method in that component is executed.</p><p>Mocks provide a way for us to mimic the way a real object behaves, without actually performing the object's underlying logic. With the following lines of code in the controller's<code class="literal"> beforeFilter</code> callback:<a id="id396" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">if (isset($this-&gt;Session)) {
App::import('Component', 'Session');
Mock::generate('SessionComponent');
$this-&gt;Session = new MockSessionComponent();
}
</pre></div><p>We are replacing the instance of CakePHP's<code class="literal"> Session</code> component with a mocked version. This mocked version will allow the controller to use all the component's available methods (such as<code class="literal"> setFlash()</code>) without actually performing the underlying call.<code class="literal"> Mock::generate()</code> will by default generate a fully mocked object (all its underlying functionality will be ignored.) If we wanted to mock only parts of an object, we would need to generate a partial mock. For example, if we only wanted to mock the<code class="literal"> setFlash()</code> method of the<code class="literal"> Session</code> component while still maintaining the rest of its original methods, we would do:<a id="id397" class="indexterm"/>
</p><p>
<code class="literal">Mock::generatePartial('SessionComponent', false, array('setFlash'))</code>;</p><p>Once we have a mocked object and a way to access it from our unit tests, we can use any of the following mock assertions methods to test if a method of a mocked object is called as expected:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">expectAtLeastOnce()</code>: Its first argument is the name of the method we expect to have executed, while the second optional argument is an array of parameters we expect that method to have received. This is used when the expected method is to be called at least once, but can still be executed more times.<a id="id398" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">expectNever()</code>: Its first mandatory argument is the name of a method that we intend to ensure has not been executed on the mocked object.<a id="id399" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">expectOnce()</code>: It behaves exactly as<code class="literal"> expectAtLeastOnce()</code>, but makes sure the method is executed only once.<a id="id400" class="indexterm"/></li></ul></div><p>We proceed by overriding<code class="literal"> CakeTestCase's testAction()</code> method so that whenever an URL for the<code class="literal"> ArticlesController</code> class is requested, we change that URL to use our extended<code class="literal"> TestArticlesController</code> class. Once the proper action is executed, we obtain the instance of the controller class and keep it in a property of the unit test named<code class="literal"> Articles</code> so we can then refer to it.</p><p>We are now ready to test. We start by modifying the<code class="literal"> testView()</code> method so we can test a<code class="literal"> redirect()</code> call, by building a test to force an invalid record ID, and asserting that the controller's<code class="literal"> testRedirect</code> property is set to the<code class="literal"> index</code> action.</p><p>We finalize the recipe by implementing the<code class="literal"> testVote()</code> method, which gives us a chance to test posting data (using the second argument of the<code class="literal"> testAction()</code> method as described in the previous recipe), and asserting that the mocked<code class="literal"> Session</code> class receives a call to its<code class="literal"> setFlash()</code> method, with the right arguments.</p><p>The last part of this unit test uses the main model of our controller to fetch the created article, and make sure that it matches our posted data.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec17"/>There's more...</h2></div></div></div><p>While the method shown in this recipe is quite powerful, it is definitely not the only way to test controllers. We can also perform direct calls on the controller actions we intend to test by instantiating the controller class and making a manual call to the action.</p><p>However, this is not a straightforward operation, since it would require a proper initialization of our controller by following the same steps than those defined by CakePHP's<code class="literal"> Dispatcher</code> class. Mark Story has produced a thorough article describing this approach at <a class="ulink" href="http://mark-story.com/posts/view/testing-cakephp-controllers-the-hard-way">http://mark-story.com/posts/view/testing-cakephp-controllers-the-hard-way</a>.</p><p>Mark Story has also published a follow-up article on manual testing of controllers, where he introduces mocks. It is definitely a good read, and it is available at <a class="ulink" href="http://mark-story.com/posts/view/testing-cakephp-controllers-mock-objects-edition">http://mark-story.com/posts/view/testing-cakephp-controllers-mock-objects-edition</a>.</p></div></div>
<div class="section" title="Running tests from the command line"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec06"/>Running tests from the command line</h1></div></div></div><p>In this recipe, we will learn how to run our unit tests from the command line, which opens the possibility for automated test reporting.<a id="id401" class="indexterm"/>
</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec18"/>Getting ready</h2></div></div></div><p>To go through this recipe we need a basic application skeleton to work with, which should have its own set of unit tests. Go through the entire recipe<span class="emphasis"><em> Creating fixtures and testing model methods</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec19"/>How to do it...</h2></div></div></div><p>Using your operating system console, switch to your application directory, and run:</p><p>If you are on a GNU Linux / Mac / Unix system:</p><div class="informalexample"><pre class="programlisting">../cake/console/cake testsuite app case models/article
</pre></div><p>If you are on Microsoft Windows:</p><div class="informalexample"><pre class="programlisting">..\cake\console\cake.bat testsuite app case models/article</pre></div><p>The shell should now run the specified unit test and inform us that all unit tests succeeded, as shown in the next screenshot:</p><div class="mediaobject"><img src="graphics/1926OS_10_06.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec20"/>How it works...</h2></div></div></div><p>CakePHP's<code class="literal"> testsuite</code> shell allows us to execute any test case, or group of test cases, from the command line. It offers several ways to specify which unit test to execute by specifying a minimum of two arguments.<a id="id402" class="indexterm"/>
</p><p>The first argument can either be<code class="literal"> app, core</code>, or a plugin name. Use<code class="literal"> app</code> when intending to execute a unit test, or group of tests, from your application directory. Use<code class="literal"> core</code> if you wish to run CakePHP's core tests. Finally, if you wish to run tests from a plugin, use the plugin name as the first argument to the<code class="literal"> testsuite</code> shell.</p><p>The second argument should specify what type of unit test to run. It can be set to<code class="literal"> all</code>, which runs all tests;<code class="literal"> group</code>, which runs the test group specified in the third argument; or<code class="literal"> case</code>, which runs the test case defined in the third argument.</p></div></div></body></html>