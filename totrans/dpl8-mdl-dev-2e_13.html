<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Internationalization and Languages</h1>
                </header>
            
            <article>
                
<p>Even though there have been great advancements across the board, Drupal 8 has a couple of almost revolutionary developments compared to its predecessor. Notable among these are the configuration API and the caching system, which are both lightyears ahead of what was capable in Drupal 7. Another one is the multilingual initiative that sought to make Drupal fully multilingual out of the box, rather than having to use 20 contributed modules to achieve results that don't even come close. This also includes the internationalization (i18n: <a href="https://www.w3.org/standards/webdesign/i18n">https://www.w3.org/standards/webdesign/i18n</a>) aspect that allows sites to be translated into any of the installed languages.</p>
<p>In this chapter, we are going to talk about internationalization and multilingual features in Drupal 8 from the point of view of a module developer. Many of the built-in capabilities of this system are oriented toward site builders—enabling languages, translating content and configuration entities, as well as the Drupal interface (for administrators and visitors alike). Our focus will be what we as module developers need to do programmatically to ensure that site builders and editors can use the aforementioned features. To that end, this chapter will be more of a reference guide with various tips, techniques, and even rules we need to follow when writing our code. Notwithstanding, we will also talk a bit about how we can work with languages programmatically.</p>
<p>First, however, we will start with an introduction to the multilingual ecosystem that comes out of the box and the modules responsible for various parts of it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to the multilingual ecosystem</h1>
                </header>
            
            <article>
                
<p>The multilingual and internationalization system is based on four Drupal core modules. Let's quickly go through them and see what they do:</p>
<ul>
<li>Language</li>
<li>Content translation</li>
<li>Configuration translation</li>
<li>Interface translation</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Language</h1>
                </header>
            
            <article>
                
<p>The <em>Language</em> module is responsible for dealing with the available languages on the site. Site builders can choose to install one or more languages from a wide selection. They can even create their own custom language if necessary. The installed languages can then be added to things such as entities and menu links in order to control their visibility, depending on the current language. Apart from the installed ones, Drupal 8 comes with two extra special languages as well: <em>Not Specified</em> and <em>Not Applicable</em>.</p>
<p>The module also handles the contextual language selection based on various criteria, as well as provides a language switcher to change the current language of the site<span><span>:</span></span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/15d12bfe-952a-4c61-9de8-b23d469a41c8.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Content translation</h1>
                </header>
            
            <article>
                
<p>The <em>Content</em> t<em>ranslation</em> module is responsible for the functionality that allows users to translate content. Content entities are the principal vehicle for content, and with this module, the data inside can be translated (and granularly configured for it at field level). In other words, users can control which fields and which entity type bundles should be translatable<span><span>:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/82a51594-f8fa-4c65-a3ff-1f2bcec4ce72.png" style="width:42.92em;height:27.58em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration translation</h1>
                </header>
            
            <article>
                
<p>The <em>Configuration</em> t<em>ranslation</em> module is responsible for providing the interface via which users can translate configuration values. These can be from simple configuration objects or configuration entities. We've already seen how we can ensure that our configuration values can be translated in previous chapters, so we won't dive into that again here.</p>
<p>I recommend you reference the section on configuration schemas from <a href="77cab458-5612-468c-8010-12385708eb81.xhtml">Chapter 6</a>, <em>Data Modeling and Storage<span><span>:</span></span></em></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/cbf6c83c-e965-4246-9a3c-7a17a70e8ad9.png" style="width:35.17em;height:14.42em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interface translation</h1>
                </header>
            
            <article>
                
<p>The <em>Interface translation</em> module is responsible for providing an interface that allows users to translate any string or text output on the website, in all the languages that are installed. Moreover, it provides a connection to the <a href="https://localize.drupal.org/">localize.drupal.org</a> platform from which it can download translations for many languages of the more common interface strings that come with Drupal<span><span>:</span></span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/6350111a-129b-46dd-9ad4-3bfc94e9961b.png" style="width:39.58em;height:24.33em;"/></div>
<p>These four modules are not alone in the multilingual system but rely on a cross-application standard of ensuring that all the written code works well with it. In other words, the entire Drupal code base is intertwined with the multilingual system at various levels, and is written in such a way that anything that should be translatable or localizable can be. This means that all the code we write needs to respect the same standard.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Internationalization</h1>
                </header>
            
            <article>
                
<p>The idea behind internationalization is to ensure that everything that gets output on the site can be translated into the enabled languages through a common mechanism—in this case, using the Interface translation module. This refers to content, visible configuration values, and the strings and texts that come out of modules and themes. But there are many different ways this can happen, so let's see how in each of these cases we would ensure that our information can be translated.</p>
<p>A principal <em>rule</em> when writing Drupal modules or themes is to always use English as the code language. This is to ensure consistency and keep open the possibility that other developers will work on the same code base, who may not speak a particular language. This is also the case for text used to be displayed in the UI. It should not be the responsibility of the code to output the translated text, but rather to always keep it consistent, that is, in English.</p>
<p>Of course, this is dependent on it being done right, in order to allow it to be translated via interface translation. There are multiple ways this can be ensured, depending on the circumstances.</p>
<p>The most common scenario we need to be aware of is when we have to print out to the user a PHP string of text. Drupal 7 developers should already be familiar with the <kbd>t()</kbd> function through which these strings are run. This function still exists and should be used whenever we are not inside a class context:</p>
<pre>return t('The quick brown fox'); </pre>
<p>However, when we are inside a class, we should check whether any of the parents are using the <kbd>StringTranslationTrait</kbd>. If not, we should use it in our class and then we'll be able to do this instead:</p>
<pre>return $this-&gt;t('The quick brown fox'); </pre>
<p>Even better still, we should inject the <kbd>TranslationManager</kbd> service into our class because the abovementioned trait makes use of it.</p>
<p>None of the examples given before should be new to us as we've been using these throughout the code we've been writing in this book. But what actually happens behind the scenes?</p>
<p>The <kbd>t()</kbd> and <kbd>StringTranslationTrait::t()</kbd> functions both create and return an instance of <kbd>TranslatableMarkup</kbd> (essentially delegating to its constructor), which, upon rendering (being cast to a string), will return the formatted and translated string. The responsibility of the actual translation is delegated to the <kbd>TranslationManager</kbd> service. This process has two parts. Static analyzers pick up on these text strings and add them to the database in the list of strings that need to be localized. These can then be translated by users via the user interface. Second, at runtime, the strings get formatted and the translated version is shown, depending on the current language context. And because of the first part, we should never do something like this:</p>
<pre>return $this-&gt;t($my_text); </pre>
<p>The reason is that static analyzers can no longer pick up on the strings that need to be translated. Moreover, if the text is coming from user input, it can lead to XSS attacks if not properly sanitized before.</p>
<p>That being said, we can still have dynamic, that is, formatted, text output using this method, and we've seen this in action as well:</p>
<pre>$count = 5; 
return $this-&gt;t('The quick brown fox jumped @count times', ['@count' =&gt; $count]);  </pre>
<p>In this case, we have a dynamic variable that will be used to replace the <kbd>@count</kbd> placeholder from the text. Drupal takes care of sanitizing the variable before outputting the string to the user. Alternatively, we can also use the <kbd>%</kbd> prefix to define a placeholder we want Drupal to wrap with <kbd>&lt;em class="placeholder"&gt;</kbd>. The cool thing is that, when performing translations, users can shift the placeholder in the sentence to accommodate language specificity.</p>
<p>One of the intended consequences of the static analyzer picking out and storing the strings that need to be translated is that, by default, each individual string is only translated once. This is good in many cases but also poses some problems when the same English string has different meanings (which map to different translations in other languages). To counter this issue, we can specify a context to the string that needs to be translated so that we can identify which meaning we actually want to translate. This is where the third parameter of the <kbd>t()</kbd> function (and method) we saw in the previous paragraphs comes into play.</p>
<p>For example, let's consider the word <em>Book</em>, which is translated by default in its meaning as a noun. But we may have a submit button on a form that has the value Book, which clearly has a different meaning as a call to action. So in the latter case, we could do it like this:</p>
<pre>t('Book', [], ['context' =&gt; 'The verb "to book"']);  </pre>
<p>Now in the interface translation, we will have both versions available<span><span>:</span></span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4866bc01-cbc0-4e73-9d13-b911464bfa20.png"/></p>
<p>Another helpful tip is that we can also account for plurals in the string translations. The <kbd>StringTranslationTrait::formatPlural()</kbd> method helps with this by creating a <kbd>PluralTranslatableMarkup</kbd> object similar to <kbd>TranslatableMarkup</kbd>, but with some extra parameters to account for differences when it comes to plurals. This comes in very handy in our previous example with the brown fox jumping a number of times, because if the fox jumps only once, the resulting string would no longer be grammatically correct. So instead, we can do the following:</p>
<pre>$count = 5; 
return $this-&gt;formatPlural($count, 'The quick brown fox jumped 1 time', 'The quick brown fox jumped @count times')];  </pre>
<p>The first parameter is the actual count (the differentiator between singular and plural). The second and third parameters are the singular and plural versions, respectively. You'll also notice that since we specified the count already, we don't have to specify it again in the arguments array. It's important to note that the placeholder name inside the string needs to be <kbd>@count</kbd> if we want the renderer to understand its purpose.</p>
<p>The string translation techniques we discussed so far also work in other places—not just in PHP code. For example, in JavaScript we would do something like this:</p>
<pre>Drupal.t('The quick brown fox jumped @count times', {'@count': 5}); 
Drupal.formatPlural(5, 'The quick brown fox jumped 1 time', 'The quick brown fox jumped @count times');  </pre>
<p>So, based on this knowledge, I encourage you to go back and fix our incorrect use of the string output in JavaScript in the previous chapter.</p>
<p>In Twig, we'd have something like this (for simple translations):</p>
<pre>{{ 'Hello World.'|trans }} 
{{ 'Hello World.'|t }}  </pre>
<p>Both of the above lines do the same thing. To handle plurals (and placeholders), we can use the <kbd>{% trans %}</kbd> block:</p>
<pre>{% set count = 5 %} 
{% trans %} 
  The quick brown fox jumped 1 time. 
{% plural count %} 
  The quick brown fox jumped {{ count }} times. 
{% endtrans %}  </pre>
<p>Finally, the string context is also possible like so:</p>
<pre>{% trans with {'context': 'The verb "to book"'} %} 
  Book 
{% endtrans %} </pre>
<p>In annotations, we have the <kbd>@Translation()</kbd> wrapper, as we've seen already a few times when creating plugins or defining entity types.</p>
<p>Finally, in YAML files, some of the strings are translatable by default (so we don't have to do anything):</p>
<ul>
<li>Module names and descriptions in <kbd>.info.yml</kbd> files</li>
<li>The <kbd>_title</kbd> (together with the optional <kbd>_title_context</kbd>) key values under the defaults section of <kbd>.routing.yml</kbd> files</li>
<li>The <kbd>title</kbd> (together with the optional <kbd>title_context</kbd>) key values in <kbd>.links.action.yml</kbd>, <kbd>.links.task.yml</kbd> and <kbd>.links.contextual.yml</kbd> files</li>
</ul>
<p>Dates are also potentially problematic when it comes to localization, as different locales show dates differently. Luckily, Drupal provides the <kbd>DateFormatter</kbd> service, which handles this for us. For example:</p>
<pre>\Drupal::service('date.formatter')-&gt;format(time(), 'medium'); </pre>
<p>The first parameter of this formatter is the UNIX timestamp of the date we want to format. The second parameter indicates the format to use (either one of the existing formats or <kbd>custom</kbd>). Drupal comes with a few predefined date formats, but site builders can define others as well as, which can be used here. However, if the format is custom, the third parameter is a a PHP date format string suitable for input to <kbd>date()</kbd>. The fourth parameter is a time zone identifier we want to format the date in, and the final parameter can be used to specify the language to localize to directly (regardless of the current language of the site).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Content entities and the Translation API</h1>
                </header>
            
            <article>
                
<p>So far in this chapter, we've mostly talked about how to ensure that our modules output only text that can also be translated. The Drupal best practice is to always use these techniques regardless of whether the site is multilingual. You never know if you'll ever need to add a new language.</p>
<p>In this section, we are going to talk a bit about how we can interact with the language system programmatically and work with entity translations.</p>
<p>A potentially important thing you'll often want to do is check the current language of the site. Depending on the language negotiation in place, this can either be determined by the browser language, a domain, a URL prefix, or others. The <kbd>LanguageManager</kbd> is the service we use to figure this out. We can inject it using the <kbd>language_manager</kbd> key or use it via the static shorthand:</p>
<pre>$manager = \Drupal::languageManager();  </pre>
<p>To get the current language, we do this:</p>
<pre>$language = $manager-&gt;getCurrentLanguage();  </pre>
<p>Where <kbd>$language</kbd> is an instance of the <kbd>Language</kbd> class that holds some information about the given language (such as the language code and name). The language code is probably the most important as it is used everywhere to indicate what language a given <em>thing</em> is.</p>
<p>There are other useful methods with this service that you can use. For example, we can get a list of all the installed languages with <kbd>getLanguages()</kbd> or the site default language with <kbd>getDefaultLanguage()</kbd>. I encourage you to check out the <kbd>LanguageManager</kbd> for all the available API methods.</p>
<p>When it comes to content entities, there is an API we can use to interact with the data inside them in different languages. So, for example, we have figured out the current language with the previous method, so we can now get some field values in that language. The way this works is that we ask for a <em>copy</em> of the entity in the respective language:</p>
<pre>$translation = $node-&gt;getTranslation($language-&gt;getId());  </pre>
<p><kbd>$translation</kbd> is now almost the same as <kbd>$node</kbd>, but with the default language set to the one we requested. From there, we can access field values normally. However, not all nodes have to have a translation, so it's better to first check whether one exists:</p>
<pre>if ($node-&gt;hasTranslation($language-&gt;getId())) { 
  $translation = $node-&gt;getTranslation($language-&gt;getId()); 
} </pre>
<p>Since we can configure entity translatability at the field level (allowing only the fields that make sense to be translated), we can also check which of these fields can have translated values:</p>
<pre>$fields = $node-&gt;getTranslatableFields(); </pre>
<p>Finally, we can also check which languages there are translations for:</p>
<pre>$languages = $node-&gt;getTranslationLanguages();  </pre>
<p>Since it's up to the editors to add translations to an entity, we cannot guarantee in code that one exists.</p>
<p>Programmatically, we can also create a translation to an entity really easily. For example, let's imagine we want to translate a Node entity and specify its title to be in French:</p>
<pre>$node-&gt;addTranslation('fr', ['title' =&gt; 'The title fr']); </pre>
<p>The second parameter is an array of values that needs to map to the entity fields just like when creating a new entity. Now the respective node has the original language (let's say EN) but also a French translation. <span><span>It should be noted </span></span>that the values of all the other fields apart from the title, even in the French translation, remain in the original language because we did not pass any translated values when creating the translation.</p>
<p>And just as we add a translation, we can also remove one:</p>
<pre>$node-&gt;removeTranslation('fr');  </pre>
<p>If we want to persist the addition or removal of a translation, we need to save the entity like we are used to. Otherwise, it's stored only in memory. And with Drupal 8.3, content entities implement the <kbd>Drupal\Core\TypedData\TranslationStatusInterface</kbd> which allows us to inspect the status of the translations. So for example, we can do this:</p>
<pre>$status = $node-&gt;getTranslationStatus('fr');</pre>
<p>Where <kbd>$status</kbd> is the value of one of three constants from the <kbd>TranslationStatusInterface</kbd> class:</p>
<ul>
<li><kbd>TRANSLATION_REMOVED</kbd></li>
<li><kbd>TRANSLATION_EXISTING</kbd></li>
<li><kbd>TRANSLATION_CREATED</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this short chapter, we talked about the Drupal 8 multilingual and internationalization system from a module developer perspective. We started with an introduction to the four main modules responsible for languages and translating content, configuration entities as well as interface text.</p>
<p>Then, we focused on the rules and techniques we need to respect in order to ensure that our output text can be translated. We saw how we can do this in PHP code, Twig, and YAML files, and even in JavaScript. Finally, we looked a bit at the language manager and Translation API to see how we can work with content entities that have been translated.</p>
<p>The main takeaway from this chapter should be that languages are important in Drupal 8 even if our site is only in one language. So, in developing modules, especially if we want to contribute them back to the community, we need to ensure that our functionality can be translated as needed.</p>
<p>In the next chapter, we are going to talk about data processing using batches and queues, as well as the cron system that comes with Drupal.</p>


            </article>

            
        </section>
    </body></html>