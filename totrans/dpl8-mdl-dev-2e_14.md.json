["```php\n/** \n * Update all the players to mark them as retired. \n */ \nfunction sports_update_8002(&$sandbox) { \n  $database = \\Drupal::database(); \n\n  if (empty($sandbox)) { \n    $results = $database->query(\"SELECT id FROM {players}\")->fetchAllAssoc('id'); \n    $sandbox['progress'] = 0; \n    $sandbox['ids'] = array_keys($results); \n    $sandbox['max'] = count($results); \n  } \n\n  $id = $sandbox['ids'] ? array_shift($sandbox['ids']) : NULL; \n\n  $player = $database->query(\"SELECT * FROM {players} WHERE id = :id\", [':id' => $id])->fetch(); \n  $data = $player->data ? unserialize($player->data) : []; \n  $data['retired'] = TRUE; \n  $database->update('players') \n   ->fields(['data' => serialize($data)]) \n   ->condition('id', $id) \n   ->execute(); \n  $sandbox['progress']++; \n  $sandbox['#finished'] = $sandbox['progress'] / $sandbox['max']; \n} \n```", "```php\n$batch_builder = (new BatchBuilder()) \n  ->setTitle($this->t('Importing products')) \n  ->setFinishCallback([$this, 'importProductsFinished']); \n\n$batch_builder->addOperation([$this, 'clearMissing'], [$products]); \n$batch_builder->addOperation([$this, 'importProducts'], [$products]); \nbatch_set($batch_builder->toArray());  \n```", "```php\nuse Drupal\\Core\\Batch\\BatchBuilder;  \n```", "```php\nif (PHP_SAPI == 'cli') {\n  drush_backend_batch_process();\n}\n```", "```php\n/** \n * Batch operation to remove the products which are no longer in the list of \n * products coming from the JSON file. \n * \n * @param $products \n * @param $context \n */ \npublic function clearMissing($products, &$context) { \n  if (!isset($context['results']['cleared'])) { \n    $context['results']['cleared'] = []; \n  } \n\n  if (!$products) { \n    return; \n  } \n\n  $ids = []; \n  foreach ($products as $product) { \n    $ids[] = $product->id; \n  } \n\n  $ids = $this->entityTypeManager->getStorage('product')->getQuery() \n    ->condition('remote_id', $ids, 'NOT IN') \n    ->execute(); \n  if (!$ids) { \n    $context['results']['cleared'] = []; \n    return; \n  } \n\n  $entities = $this->entityTypeManager->getStorage('product')->loadMultiple($ids); \n\n  /** @var \\Drupal\\products\\Entity\\ProductInterface $entity */ \n  foreach ($entities as $entity) { \n    $context['results']['cleared'][] = $entity->getName(); \n  } \n  $context['message'] = $this->t('Removing @count products', ['@count' => count($entities)]); \n  $this->entityTypeManager->getStorage('product')->delete($entities); \n}  \n```", "```php\n/** \n * Batch operation to import the products from the JSON file. \n * \n * @param $products \n * @param $context \n */ \npublic function importProducts($products, &$context) { \n  if (!isset($context['results']['imported'])) { \n    $context['results']['imported'] = []; \n  } \n\n  if (!$products) { \n    return; \n  } \n\n  $sandbox = &$context['sandbox']; \n  if (!$sandbox) { \n    $sandbox['progress'] = 0; \n    $sandbox['max'] = count($products); \n    $sandbox['products'] = $products; \n  } \n\n  $slice = array_splice($sandbox['products'], 0, 3); \n  foreach ($slice as $product) { \n    $context['message'] = $this->t('Importing product @name', ['@name' => $product->name]); \n    $this->persistProduct($product); \n    $context['results']['imported'][] = $product->name; \n    $sandbox['progress']++; \n  } \n\n  $context['finished'] = $sandbox['progress'] / $sandbox['max']; \n} \n```", "```php\n/** \n * Callback for when the batch processing completes. \n * \n * @param $success \n * @param $results \n * @param $operations \n */ \npublic function importProductsFinished($success, $results, $operations) { \n  if (!$success) { \n    drupal_set_message($this->t('There was a problem with the batch'), 'error'); \n    return; \n  } \n\n  $cleared = count($results['cleared']); \n  if ($cleared == 0) { \n    drupal_set_message($this->t('No products had to be deleted.')); \n  } \n  else { \n    drupal_set_message($this->formatPlural($cleared, '1 product had to be deleted.', '@count products had to be deleted.')); \n  } \n\n  $imported = count($results['imported']); \n  if ($imported == 0) { \n    drupal_set_message($this->t('No products found to be imported.')); \n  } \n  else { \n    drupal_set_message($this->formatPlural($imported, '1 product imported.', '@count products imported.')); \n  } \n}  \n```", "```php\nuse DependencySerializationTrait;  \n```", "```php\ndrush cron  \n```", "```php\n/** \n * Implements hook_cron(). \n */ \nfunction sports_cron() { \n  $database = \\Drupal::database(); \n  $result = $database->query(\"SELECT id FROM {teams} WHERE id NOT IN (SELECT team_id FROM {players} WHERE team_id IS NOT NULL)\")->fetchAllAssoc('id'); \n  if (!$result) { \n    return; \n  } \n\n  $ids = array_keys($result); \n  $database->delete('teams') \n    ->condition('id', $ids, 'IN') \n    ->execute(); \n}  \n```", "```php\n/** @var \\Drupal\\Core\\Queue\\QueueFactory $queue_factory */ \n$queue_factory = \\Drupal::service('queue');  \n```", "```php\n/** @var \\Drupal\\Core\\Queue\\QueueInterface $queue */ \n$queue = $queue_factory->get('team_cleaner');  \n```", "```php\n$queue = \\Drupal::queue('team_cleaner');  \n```", "```php\n$item = new \\stdClass(); \n$item->id = $team_id; \n$queue->createItem($item);  \n```", "```php\nnamespace Drupal\\sports\\Plugin\\QueueWorker; \n\nuse Drupal\\Core\\Database\\Connection; \nuse Drupal\\Core\\Plugin\\ContainerFactoryPluginInterface; \nuse Drupal\\Core\\Queue\\QueueWorkerBase; \nuse Symfony\\Component\\DependencyInjection\\ContainerInterface; \n\n/** \n * A worker plugin that removes a team from the database. Normally used to clear \n * teams that have run out of players. \n * \n * @QueueWorker( \n *   id = \"team_cleaner\", \n *   title = @Translation(\"Team Cleaner\"), \n *   cron = {\"time\" = 10} \n * ) \n */ \nclass TeamCleaner extends QueueWorkerBase implements ContainerFactoryPluginInterface { \n\n  /** \n   * @var \\Drupal\\Core\\Database\\Connection \n   */ \n  protected $database; \n\n  /** \n   * Constructs a TeamCleaner worker. \n   * \n   * @param array $configuration \n   * @param string $plugin_id \n   * @param mixed $plugin_definition \n   * @param \\Drupal\\Core\\Database\\Connection $database \n   */ \n  public function __construct(array $configuration, $plugin_id, $plugin_definition, Connection $database) { \n    parent::__construct($configuration, $plugin_id, $plugin_definition); \n    $this->database = $database; \n  } \n\n  /** \n   * {@inheritdoc} \n   */ \n  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) { \n    return new static( \n      $configuration, \n      $plugin_id, \n      $plugin_definition, \n      $container->get('database') \n    ); \n  } \n\n  /** \n   * {@inheritdoc} \n   */ \n  public function processItem($data) { \n    $id = isset($data->id) && $data->id ? $data->id : NULL; \n    if (!$id) { \n      throw new \\Exception('Missing team ID'); \n      return; \n    } \n\n    $this->database->delete('teams') \n      ->condition('id', $id) \n      ->execute(); \n  } \n}  \n```", "```php\ncron = {\"time\" = 10}\n```", "```php\ndrush queue-run team_cleaner\n```", "```php\n$queue = \\Drupal::queue('team_cleaner'); \n/** @var \\Drupal\\Core\\Queue\\QueueWorkerInterface $queue_worker */ \n$queue_worker = \\Drupal::service('plugin.manager.queue_worker')->createInstance('team_cleaner'); \n\nwhile($item = $queue->claimItem()) { \n  try { \n    $queue_worker->processItem($item->data); \n    $queue->deleteItem($item); \n  } \n  catch (SuspendQueueException $e) { \n    $queue->releaseItem($item); \n    break; \n  } \n  catch (\\Exception $e) { \n    // Log the exception. \n  } \n}  \n```", "```php\nif (!$this->lock->acquire($plugin->getPluginId())) { \n  $this->logger()->log('notice', t('The plugin @plugin is already running.', ['@plugin' => $plugin->getPluginDefinition()['label']])); \n  return; \n}  \n```", "```php\n$this->lock->release($plugin->getPluginId());  \n```", "```php\nif (!$this->lock->acquire($plugin->getPluginId())) { \n  $this->logger()->log('notice', t('The plugin @plugin is already running. Waiting for it to finish.', ['@plugin' => $plugin->getPluginDefinition()['label']])); \n  if ($this->lock->wait($plugin->getPluginId())) { \n    $this->logger()->log('notice', t('The wait is killing me. Giving up.')); \n    return; \n  } \n}  \n```"]