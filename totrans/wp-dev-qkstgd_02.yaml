- en: Managing Database Structure, Storage, and Retrieval
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The database is the primary location for storing application data. WordPress
    provides a built-in database with pre-defined tables, compared to traditional
    web applications, where the database is designed from scratch. Getting used to
    the pros and cons of the existing database table is the key to developing quality
    themes and plugins.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn the power and limitations of the existing database
    tables in Wordpress. You will get an overview of existing database tables and
    their role, while understanding how data is managed in common functions such as
    post creation, user creation, media uploads, and so on. You will also learn the
    uses of custom tables in development, and using the query functions to retrieve
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the role of default database tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking and understanding database usage of primary features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and managing custom tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing CRUD operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief overview of the multisite database structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have the necessary knowledge to maximize
    the use of existing database tables in development, while using custom tables
    for advanced use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the WordPress database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of planning and designing a database is one of the most critical
    phases of any project. A well-planned database design eases the process for future
    growth while increasing performance in data storage and retrieval. Usually, it's
    the responsibility of the development team to identify the entities and relationships
    between these entities. WordPress, on the other hand, is a CMS and hence offers
    an existing database to handle core features. So, the process of planning a database
    is not part of the responsibility as a developer in most scenarios. Instead, developers
    have a tougher task of understanding the core tables and managing the data needs
    with its limitations. Of course, you can create and use your own database tables
    for any requirement. But, doing so eliminates the whole purpose of developing
    on top of WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: The WordPress database currently supports MySQL and MariaDB, with MariaDB being
    the most preferred choice. However, most of the existing WordPress sites still
    use MySQL. On successful installation, WordPress will create eleven database tables
    to cater for the core functionality. Since its inception, backward compatibility
    was one of the top priorities of the WordPress team. Therefore, you may not see
    major changes in these eleven tables in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the role of built-in database tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The WordPress database structure is designed to store a minimum amount of data
    required for core features. Therefore, developers need to have a thorough understanding
    of the existing tables in order to use them effectively to build flexible websites.
    Let''s take a look at the entity relationship diagram of the latest WordPress
    versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/936a56ee-be42-4989-925b-6c807c7e327f.png)'
  prefs: []
  type: TYPE_IMG
- en: As may notice, all the existing tables don't have more than one or two relationships
    with other tables, and hence understanding and working with the database becomes
    a simpler task. Now, we are going to look at each database table with important
    columns, its role, and how it works with other tables. You need to refer to the
    preceding diagram to visualize the points in our discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Posts-related database tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three database tables are directly involved with posts and six tables handle
    posts-related data. Many of the existing WordPress sites are either basic sites
    with a few pages, or blogs with hundreds of posts. So, the data of the majority
    of the sites are managed by these six database tables. Let's take a look at the
    two tables directly related to posts.
  prefs: []
  type: TYPE_NORMAL
- en: wp_posts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the primary data storage location of many WordPress sites and applications.
    This table consists of the main data for posts, pages, and custom post types.
    This table consists of twenty-three columns. Let''s identify some of the most
    important columns in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `post_author` | This is where you find the ID of the user who created the
    post or page. This column is used to form the relationship with the `wp_users` table.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `post_content` | The complete content of the post/page is stored in this
    column. So, the data in this column can range from a few words to thousands of
    words and images. |'
  prefs: []
  type: TYPE_TB
- en: '| `post_title` | The title of the post/page is stored in this column. It''s
    used to identify the page in the backend as well as highlight the title in the
    frontend. |'
  prefs: []
  type: TYPE_TB
- en: '| `post_excerpt` | The data in this column is optional and used for keeping
    a summary of the post/page. Usually, this is used in post lists (archive) pages
    to show a glimpse of what the post is about, and encourage users to read the entire
    post. |'
  prefs: []
  type: TYPE_TB
- en: '| `post_status` | WordPress-specific post statuses are stored in this column.
    These statuses defines a step in the life cycle of a post. Default statuses include
    publish, pending, private, future, inherit, trash, draft, and auto-draft. Most
    of these statuses are self-explanatory. However, you may need explanations on
    the  inherit and auto-draft statuses. WordPress provides the ability to store
    revisions of posts in the database. When we update a post, the previous post data
    in the database automatically becomes a revision with the status marked as **inherit**.
    Also, WordPress automatically saves posts at certain time intervals, and those
    revisions are marked as **auto-draft**. |'
  prefs: []
  type: TYPE_TB
- en: '| `post_password` | This stores the password of password-protected posts or
    pages. |'
  prefs: []
  type: TYPE_TB
- en: '| `post_parent` | This column stores the ID of the parent post. WordPress supports
    child posts for attachments, pages, and post revisions. |'
  prefs: []
  type: TYPE_TB
- en: '| `guid`  | The complete URL of the post/page is stored in this column. |'
  prefs: []
  type: TYPE_TB
- en: '| `post_type`  | This stores the type post with a unique key. Default post
    types includes post, page, revision, attachment, and `nav_menu_item`. Apart from
    these types, you can create any new type using custom post types. |'
  prefs: []
  type: TYPE_TB
- en: Usually, this table is intended for built-in types such as posts, pages, menus,
    and attachments. With the introduction of custom post types, this table is used
    widely for storing data such as products, forum topics, properties, and anything
    that you can think of.
  prefs: []
  type: TYPE_NORMAL
- en: wp_postmeta
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the secondary storage for posts where optional data related to posts
    and pages are stored. This table consists of four columns. Let''s identify some
    of the most important columns in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `post_id` | This is where you find the ID of the post for these additional
    data. This column is used to form the relationship with the `wp_posts` table.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `meta_key` | All the additional post data is saved as key-value pairs. This
    column defines the identification for post data. A unique key should be used for
    this column with alpha numeric characters, underscores, and dashes. By default,
    WordPress stores **edit lock** info for posts and pages. As you add data to posts
    or create menus, you will see more keys stored with underscore prefixes. This
    is different to what we have used as developers, where we store such data in a
    different table with these keys as columns. |'
  prefs: []
  type: TYPE_TB
- en: '| `meta_value` | This column contains the posts-related data for the specified
    meta keys. Usually, these values are stored as plain text or serialized values.
    |'
  prefs: []
  type: TYPE_TB
- en: Usually, this table is used to store administration-level values and custom
    fields added from the post edit screen. In large sites with custom post types,
    this table becomes crucial. In such sites, we can store data such as product options
    in an online store, property details in real-estate sites, and job details in
    a job management site.
  prefs: []
  type: TYPE_NORMAL
- en: Terms-related tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can find four tables in this section, targeted for handling post-specific
    categorization. We use the term *taxonomoy* in WordPress for these categorizations.
    By default, we have two taxonomies called categories and tags. These tables are
    capable of handling these two taxonomy types as well as your own taxonomy types.
    Let's take a look at each of these four tables in detail.
  prefs: []
  type: TYPE_NORMAL
- en: wp_terms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is used to store the choices for taxonomies. You should be aware of categories
    and tags in WordPress posts. We call those types taxonomies. The choice inside
    a taxonomy is called a term. **Category** is a taxonomy and choices we create
    such as Health, Sports, and Travel are considered terms. This table consists of
    four columns. Let''s identify some of the most important columns in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `name` | Stores the title of the term that displays on the frontend of the
    site |'
  prefs: []
  type: TYPE_TB
- en: '| `slug` | Stores the unique identifier for the term |'
  prefs: []
  type: TYPE_TB
- en: Initial WordPress installation generates two taxonomies, called category and
    post tag. However, no terms are created by default and only contains **Uncategorized**
    as a term. We can use this table to create post tags or category choices. Also,
    we can use this in custom scenarios for creating terms such as WordPress, PHP,
    and jQuery for job skills in a job management site.
  prefs: []
  type: TYPE_NORMAL
- en: wp_termmeta
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the secondary location for storing data for terms. This table consists
    of four columns and works similar to other metadata tables using key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: By default, this table is not used frequently. You may use this table to store
    additional details of your own terms. Assume you have terms for articles such
    as sports, health, travel. You want to display the archive pages of each of these
    categories using a different design. In such a scenario, you can store the CSS,
    images, templates in a term metatable and use this info to load the design.
  prefs: []
  type: TYPE_NORMAL
- en: wp_term_relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This used to form the relationship between posts and terms. This table consists
    of three columns and only IDs are used as data. Let''s identify some of the most
    important columns in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `object_id` | Stores the ID of the post or custom post type that connects
    with the taxonomy |'
  prefs: []
  type: TYPE_TB
- en: '| `term_taxonomy_id` | Stores the ID of the taxonomy |'
  prefs: []
  type: TYPE_TB
- en: This is purely an associative table, which connects two tables using IDs. As
    a developer, you just need to assign the relationship, and this table doesn't
    have different uses based on the type of the site.
  prefs: []
  type: TYPE_NORMAL
- en: wp_term_taxonomy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This table stores the type of categorizations called taxonomies. This table
    consists of six columns. Let''s identify some of the most important columns in
    this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `term_id` | This is the ID of the term and is used to form the connection
    with the `wp_terms` table. |'
  prefs: []
  type: TYPE_TB
- en: '| `taxonomy` | This is the unique slug for the taxonomy. Default taxonomies
    are category and `post_tag`. |'
  prefs: []
  type: TYPE_TB
- en: '| `parent` | Stores the parent term when using sub-terms in your site. |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | Stores the number of posts and custom post types that belong to
    this taxonomy. |'
  prefs: []
  type: TYPE_TB
- en: This table contains default taxonomies for category and `post_tag`, to be used
    in normal WordPress posts. We can create custom taxonomies such as job skills
    in a job management site, product types in an online store, property features
    in a real-estate site, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: User-related tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User data is managed using two tables in the existing database. By default,
    we have very basic details about users stored in these tables. Modern sites bring
    the concept of personalized content, and hence user management is becoming more
    and more important. So, you see extensive use of these tables in many websites.
    Let's take a look at each of these two tables in detail.
  prefs: []
  type: TYPE_NORMAL
- en: wp_users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the primary storage location for users, consisting of ten columns.
    Let''s identify some of the most important columns in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `user_login` | Used as the username for the site. You can allow users to
    change it using your own implementations. However, this value needs to be unique.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `user_pass` | Stores the encrypted password for the user. |'
  prefs: []
  type: TYPE_TB
- en: '| `user_email` | Used as the email of the user. Since WordPress allows users
    to login with email, this value needs to be unique for each user. |'
  prefs: []
  type: TYPE_TB
- en: '| `user_registered` | Stores the registration date and is often used to sort
    the list of users or assign the membership period on membership-based sites. |'
  prefs: []
  type: TYPE_TB
- en: The data in this table doesn't change based on the type of site you are developing,
    and hence you only need to have knowledge on inserting, updating, and deleting
    users in this table.
  prefs: []
  type: TYPE_NORMAL
- en: wp_usermeta
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Used as the secondary location for user data. By default, it keeps track of
    names, descriptions, capabilities, and so on. This table consists of four columns.
    Let''s identify some of the most important columns in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `user_id` | This is where you find the ID of the user that this data belongs
    to. This column is used to form the relationship with the `wp_users` table. |'
  prefs: []
  type: TYPE_TB
- en: '| `meta_key` | All the additional user data is saved as key-value pairs. This
    column defines the identification for user data. A unique key should be used for
    this column with alpha numeric characters, underscores, and dashes. This is different
    to what we have used as developers, where we store such data in a different table
    with these keys as columns. |'
  prefs: []
  type: TYPE_TB
- en: '| `meta_value` | This column contains the user-related data for the specified
    metakeys. Usually, these values are stored as plain text or serialized values.
    |'
  prefs: []
  type: TYPE_TB
- en: Apart from default options, we can use this table to store simple custom user
    data such as date of birth, country, city, and advanced user data such as interests,
    and profile pictures.
  prefs: []
  type: TYPE_NORMAL
- en: Options and comments tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section consists of three tables used for configurations and comments.
    Let's take a look at these tables in detail.
  prefs: []
  type: TYPE_NORMAL
- en: wp_options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This stores all the built-in and custom settings for WordPress. This is another
    table similar to `wp_postmeta` and `wp_usermeta`, where key-value pairs are used
    for keeping data. Default options in this table include the site URL, site description,
    date format, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Developers can use this table to store settings for their themes or plugins.
    Usually, plugin or theme settings are stored as a single row in this table as
    a serialized value. However, you can store as many options based on your preference.
  prefs: []
  type: TYPE_NORMAL
- en: wp_comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This stores comments for posts, pages, and custom post types. This table consists
    of fifteen columns. Let''s identify some of the most important in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `comment_post_ID` | Stores the post, page, or custom post type ID where the
    comment belongs. |'
  prefs: []
  type: TYPE_TB
- en: '| `comment_author` | Keeps the name of the user who created this comment. |'
  prefs: []
  type: TYPE_TB
- en: '| `comment_content` | Used to keep the comment added by the user. This column
    can contain plain text values as well as HTML depending on the allowed options
    in the site. |'
  prefs: []
  type: TYPE_TB
- en: '| `comment_approved` | In most sites, a comment needs to be approved before
    it appears for public. This column stores Boolean status on whether a comment
    is approved or pending approval. |'
  prefs: []
  type: TYPE_TB
- en: '| `comment_type` | Stores the type of comment. Default comment types includes
    comment, pingbacks, and trackbacks. We can also use custom comment types. |'
  prefs: []
  type: TYPE_TB
- en: '| `user_id` | ID of the user who created the comment. This column is used to
    form the connection with the `wp_users` table. |'
  prefs: []
  type: TYPE_TB
- en: Usually, this table is used for basic comments of posts, pages, and custom post
    types. However, we can think beyond the convention by using comments in innovative
    ways. We can use comments for features such as answers of a question-based site
    such as stackoverflow, user messages in a forum topic, or reviews in an online
    product marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: wp_commentmeta
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is used as the secondary location for storing additional comment data.
    This table consists of four columns and works similar to other metadata tables
    in WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: There are no default usages of this table. We can use this table to store additional
    data such as ratings in a product review site, verified status in a question-answer
    site, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we looked at all eleven default database tables in WordPress
    and their role in development. You have to understand each and every column of
    these tables with the possible values, as most of the WordPress development is
    done on top of the core features.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the importance of database usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's world, many of the developers doesn't have in-depth knowledge of
    WordPress core features and yet, capable of turning your requirement into a working
    solution. However, these solutions are often based on assumptions, rather than
    knowing the exact process and data usage under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tracking database usage and knowing the exact data needs of any given process
    is crucial for building flexible and extendable solutions that integrate perfectly
    with other parts of the site. Let''s identify some of the use cases where you
    need perfect knowledge of data usage in WordPress features:'
  prefs: []
  type: TYPE_NORMAL
- en: Building existing features on the frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WordPress offers a powerful backend with many features for administration-level
    users. Post creation and user management are some of the top features in backend.
    Comparatively, existing WordPress frontend features are less powerful and mainly
    focus on displaying data. So, it’s a common requirement to transfer these backend
    features to the frontend, allowing users with lesser permissions to create content
    from the frontend without giving access to the backend.
  prefs: []
  type: TYPE_NORMAL
- en: In such scenarios, we need to know the exact data used in the backend process,
    so that we can emulate it on the frontend process. Often, developers don't have
    necessary knowledge of all data stored in such a process. So, the frontend aspect
    of this feature works perfectly, but breaks the backend due to lack of data.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a simple scenario where you want to let users upload files using
    a form on your site, and store the files in a WordPress media library. At first
    glance, you will see that media files are stored in the `wp_posts` table and contains
    the necessary data. So, you will save the data to the `wp_posts` table. However,
    you may not notice that additional metadata for files are stored in the `wp_postmeta`
    table. Therefore, your frontend implementation may break the core features or
    other plugins that rely on this data.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing existing plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use of other existing plugins is almost certain in WordPress site development.
    Often, these plugins don't fit directly for our needs, and hence the customization
    becomes an obvious choice. Understanding the use of data becomes even more crucial
    since some of these custom plugins lack documentation and code quality compared
    to core features. Customizing a plugin without knowing its data usage can lead
    to major conflicts compared to core features.
  prefs: []
  type: TYPE_NORMAL
- en: In such scenarios, we need a thorough examination of documentation to manually
    track database usage and when possible get the support of the developer to build
    custom solutions. Let me pick up and example from one of our own plugins. We have
    a user profile management plugin where we store additional user details in the
    `wp_usermeta` table. Since searching hundreds of rows per user in the `wp_usermeta`
    table is a cumbersome task, we also store all additional data in a single row
    as a search cache. We have seen many developers customizing the plugin to update
    user data, without knowing the need for a search cache value. Even though user
    data is updated, users don't appear in search results due to the missing search
    cache value. Such scenarios are common in plugin customizations and it's a must
    identify and avoid them using data tracking methods.
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at the most common situations where tracking and knowing the
    data usage becomes critical. You may find other less common situations where consistency
    of the data becomes essential.
  prefs: []
  type: TYPE_NORMAL
- en: How to track database usage in WordPress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We identified the importance of tracking and knowing the data needs of core
    features as well as custom features. The next question is how we can track and
    understand data to avoid potential conflicts. So, we need a method that logs/shows
    all queries run within a user request. There are numerous ways to track database
    queries, including premium enterprise tools and the command line. As you are beginning
    WordPress development, we are going to look at some of the simpler and useful
    methods that expand your knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Using MySQL/MariaDB log files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is one of the simpler and must-know methods as a developer. Both MySQL
    and MariaDB allow us to create a log file where we can track all the steps in
    connecting, initializing, and executing queries in a database. First, we need
    to add some configurations to the MySQL/MariaDB `ini` file. Since we are using
    WAMP for the development tasks of this book, you can click on the WAMP icon, go
    to the MySQL section, and open the `my.ini` file. You can use the same process
    for MAMP or any other tools that offer MySQL/MariaDB configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In Linux servers, the MySQL/MariaDB configuration file is often `/etc/mysql/my.cnf`;
    if you don't find it try to locate it using `sudo updatedb ; locate my.cnf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you can add the following lines to the end of the file to configure the
    log file output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In linux servers, you can use `/var/log/mysql/mysql-debug.log` instead of `C:/wamp/logs/general-query.log`
    for the log file path. After modifying, restart MySQL/MariaDB server like this:
    `/etc/init.d/mysql restart`.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the rules are added, you should save and restart the WAMP server. Now,
    you can refresh your WordPress site to test a user request.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that many of the hosting providers don't allow access to MySQL/MariaDB
    logs.
  prefs: []
  type: TYPE_NORMAL
- en: Then, open the log file in given location and you will see many queries executed
    within that request. So, you can use this method to track database changes by
    clearing the file, executing the request, and viewing the updated log file. The
    limitation of this method is that it shows all queries including numerous `SELECT`
    queries. Since we only want to track `INSERT`, `UPDATE`, and `DELETE` queries,
    it's not the perfect method.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing database backups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is one of the easier methods to compare the changes, instead of reviewing
    executed queries, and identify them. In this method, we take a database backup
    using `phpMyAdmin`, execute the user request, and take another database backup.
    Then, we can use a file compare tool like **MELD** ([http://meldmerge.org/](http://meldmerge.org/))
    to check how the database is changed within the request. The limitation of this
    process is that you need to manually take database backups, and comparing may
    become time-consuming for larger databases.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a manual query logger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the ideal method where we create our own query logger and specify which
    queries we need to track. Let''s look at the implementation of this method using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses WordPress **query** filter to filter all the queries
    that are executed in user request. A complete `sql` query is parsed as a parameter
    and we filter `INSERT`, `UPDATE`, and `DELETE` queries. Then, we can log the queries
    to a preferred file. Here, we are adding the queries to PHP error log for illustration
    purposes. You can check the expected queries using the log file at `wamp/logs/php_error.log`.
    You can include this code in the `functions.php` file of the theme, until we get
    into plugin development.
  prefs: []
  type: TYPE_NORMAL
- en: You can choose one of the preferred methods or an external database tool to
    track database usage for any user request, and understand the must-use data of
    different processes.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking database usage of common WordPress features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you should be able to configure and track database usage for
    both backend and frontend user requests. In this section, we will be looking at
    the usage of database in the most common WordPress features, and understand the
    need for storing the specified data.
  prefs: []
  type: TYPE_NORMAL
- en: Post creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Being the most frequently used feature in WordPress sites, you need thorough
    understanding of the database usage. First, you need to go to **Posts** | **Add
    New** section and clear the existing query logs. Then, you can add the data and
    publish a post to track the database usage. The Post creation screen offers wide
    range of features and hence database usage may vary based on the amount of options
    you use. Let''s track the queries by using the most common options in post creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The log file will contain a large amount of queries. Many of them are generated
    due to the WordPress autosaving process and temporary data storage for transients,
    cache, and admin-level options. We have omitted such queries and included the
    essential ones for understanding post creation.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, we have assigned existing categories, tags and custom fields,
    along with the main post content. As you can see, the process starts with a INSERT
    query to the `wp_posts` table, where all primary post-specific data is stored.
    This query is executed as soon as you load the post creation screen. Then, WordPress
    updates the already created post when you hit the Publish button. The next query
    adds the custom field data to the `wp_postmeta` table. If you have multiple custom
    fields, you will see multiple such queries, one for each field.
  prefs: []
  type: TYPE_NORMAL
- en: Next, two queries relate the post with the category and update the post count
    for that specific category. The remaining two queries use the same process for
    tags instead of category. Here, we have seen the use of four database tables in
    post creation. Instead of using existing categories and tags, we can create new
    ones to analyze the use of all six post related tables in post creation. I recommend
    you further track the database usage by changing post statuses, adding a featured
    image, changing post formats, and changing post visibility.
  prefs: []
  type: TYPE_NORMAL
- en: Page creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is similar to post creation process where we use **Pages** | **Add New**
    section to load the page creation screen. We have less options in page creation
    compared to post creation process. Therefore, we should notice a decrease in the
    number of queries executed in this process. Let''s take a look at the executed
    queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we anticipated, only two queries executed in this process. The first one
    creates the page on screen load and the next one updates the content when the
    user hits the **Publish** button. So, it's easier to manage pages as a developer,
    compared to posts.
  prefs: []
  type: TYPE_NORMAL
- en: User creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many websites consist of just one or two administrators, with the registration
    feature blocked for public. However, the need for user registrations is rising
    in modern websites due the need of personalized content, rather than same content
    for all users. So, frontend registration becomes a common implementation. Let''s
    track the database usage by creating user from the backend **Users** | **Add New**
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The process starts by inserting a new user to the `wp_users` table with primary
    details such as username, email, password, and registered date. The additional
    details of users goes to `wp_usermeta` table with key-value pairs. Again, this
    is different to what we have used as developers, where we store such data in a
    different table with these keys as columns. We can see many INSERT queries to
    store details such as names, description, language, and so on. Among these values,
    `locale` and `wp_capabilities` are crucial ones where we define the language for
    the user and maintain the user roles and capabilities. Developers can use the
    `wp_usermeta` table to store custom data required for their websites.
  prefs: []
  type: TYPE_NORMAL
- en: Media uploads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We rarely see only full text-based content in modern websites. Most posts and
    pages are designed to use images and videos. So, media manager becomes a must
    user feature for many site owners. Using and developing with the WordPress media
    uploader could be different compared to building file upload forms from scratch.
    Let''s review the use of database for media uploads using **Media** | **Add New**
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In conventional development, we use a separate table to store the uploaded file
    details. However, WordPress uses a different approach by considering media as
    a post type. It might not be the ideal implementation as a large amount of media
    files could affect the performance of loading important posts and pages. But,
    we need to get used to the process. So, the main media file details are stored
    in the `wp_posts` table. Apart from that, two metafields are created in the `wp_postmeta`
    table to handle path and metadata such as captions, width, height. As a developer,
    we can use the postmeta table to store many additional data required for media
    files in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: We used four of the most frequently used scenarios to track database usage.
    You might have already understood the importance of consistent data and use of
    database tracking to achieve it. Here, we have tracked the queries in a default
    WordPress installation. As we use more and more plugins, these scenarios becomes
    extremely complex. So, I recommend you use this technique to track data for the
    features of popular WordPress plugins, and understand how we can customize the
    features without breaking other parts.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the multisite database structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Multisite network is a feature that allows creation of multiple sites within
    the same WordPress installation, while sharing the available resources. Developers
    moving to WordPress from pure PHP development may be unfamiliar with this concept.
    The whole database structure changes in multisite in a way that we can''t anticipate.
    So, it''s important to get an idea of how multisite database works in case you
    are planning to develop multisite compatible plugins and themes. The following
    is a simple illustration of the changes in multisite compared to single site installations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f24dbb0b-bf0e-4167-8cd9-4c62cad3da06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, six new tables have been added to the database and the existing
    tables have increased. This image only illustrates how tables are connected in
    multisite environment. However, this not a precise relationship diagram between
    the tables. Let''s identify the role of six new tables in the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wp_site`: It is the main database table where all your network details are
    stored. WordPress allows you to create multiple networks in same installation.
    However, we rarely see real applications with more than one network in the same
    installation. This means this table will only have one record to store the network
    details, such as network domain and path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wp_sitemeta`: It stores the options and settings for networks and works similar
    to the `wp_options` table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wp_blogs`: It is the primary storage location for sites in network. Since
    you are running a multisite network, this table will contain two more records
    for site details including domain, path, created dates, and site-specific statuses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wp_blog_versions`: It stores current database version of the sites available
    in network. WordPress will require certain database versions for its version upgrades.
    In such cases, this table will be used to track the database version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wp_registration_log`: It stores the admin user details of each site in the
    network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wp_signups`: It stores the new users added through the registration process
    of WordPress with the metadata for the respective site. These are also stored
    in the `wp_users` table of the respective site.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We had a brief introduction to the multisite-specific tables. Let's see how
    other tables are connected in a multisite environment. Developers who are used
    to working with conventional database concepts such as normalization may find
    it tough to understand and get used the WordPress way of handling multisite. Usually,
    we design database tables with relationships between the necessary tables in way
    that everything is connected. However, in this scenario, we see some tables not
    connected with any other tables, while some tables are connected with other tables
    without table relationships. So, it's important to understand how these tables
    work within multisites.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of a multisite network is to share WordPress installation, themes,
    and plugins. However, we still need different database tables to handle data for
    each site in the network. WordPress creates multiple versions of the same database
    table in a multisite network. So, default tables are assigned to the first site
    of the multisite. The newly created sites in the network will have the same set
    of tables created with the prefix of `wp_2`, `wp_3`, and so on. The illustration
    shows that these core tables are connected with the `wp_blogs` table. However,
    there are no relationships between `wp_blogs` and other tables. Instead, when
    a site is loaded, WordPress identifies the loaded blog ID and then uses the tables
    with the prefix of the blog ID. Each site in the network shares WordPress installation,
    plugins, and themes while using separate database tables with the prefix of blog
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: In development, a multisite structure may not become a major issue unless you
    don't follow the recommended ways of accessing the database. However, understanding
    where the data is stored for each site is important to test and resolve conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and managing custom tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A default WordPress database can be extended by any number of custom tables
    to suit our project''s requirements. The only thing we have to consider is the
    creation of custom tables over existing ones. There are two major reasons for
    creating custom tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Difficulty of matching data to existing tables**: Existing database tables
    are flexible enough to handle many common requirements. However, we need to be
    wise enough to choose custom tables in certain scenarios. Assume we have a requirement
    where we need to store user''s previous job history. If we consider existing tables,
    we can only match this requirement to `wp_usermeta` table as key-value pairs.
    However, it''s extremely difficult to implement proper search for these data by
    using the same metakey with multiple values. In such requirements, we need a custom
    table to create predefined columns and make user job searching a simpler process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased data volume**: The posts table plays a major role in WordPress
    sites. When it comes to large-scale websites or applications with a sizeable amount
    of data, it''s not recommended to keep all the data in a posts table. Let''s assume
    that we are building a product catalog that creates millions of orders. Storing
    order details in the posts table as a custom post type is not the ideal implementation.
    In such circumstances, the posts table will go out of control due to the large
    dataset. The same theory applies to the existing meta tables as well. In these
    cases, it''s wise to separate different datasets into their own tables to improve
    performance and keep things manageable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can look at the process of working with custom database tables.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In pure PHP development, we create the database tables manually before moving
    onto the implementation phase. With the WordPress plugin-based architecture, it''s
    certain that we might need to create custom tables using plugins in the later
    stages of the projects. Creating custom tables through plugins involves certain
    predefined procedures recommended by WordPress. Since table creation is a one-time
    task, we should implement the process on plugin activation or installation. Let''s
    take a look at the code for creating custom database tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, we have to include the `upgrade.php` file to make use of the `dbDelta`
    function. The next most important thing is to use the prefix for database tables.
    By default, WordPress creates a prefix called `wp_` for all the tables. We should
    change the prefix in the installation process covered in [Chapter 1](205a9625-512c-4925-a3a8-bfe8a1784773.xhtml),
    *Introduction to WordPress Development*. It's important to use the existing prefix
    to maintain consistency and avoid issues in multisite scenarios. Next, we have
    to check the existence of a database table using the **show tables** query. Finally,
    you can define your table creation query and use the `dBDelta` function to implement
    it on the database.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the guidelines for creating a table creation query at [http://codex.wordpress.org/Creating_Tables_with_Plugins](http://codex.wordpress.org/Creating_Tables_with_Plugins),
    as the `dbDelta` function can be tricky in certain scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: We should only use plugin installation/uninstallation to create and delete custom
    tables to avoid unnecessary queries. Since we have not started plugin development
    yet, you need to wait for later sections of the book to understand how and where
    to use this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We looked at the necessity of custom tables in WordPress sites. Even though
    custom tables offer you more flexibility within WordPress, there will be a considerable
    number of limitations, as listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: WordPress default backups will not include custom tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no built-in functions for the accessing database. All the queries,
    filtering, and validation needs to be done from scratch using the existing `$wpdb`
    variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User interfaces for displaying these tables' data need to be created from scratch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, you should avoid creating custom tables in all possible circumstances,
    unless they would be advantageous in the context of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Executing basic CRUD operations on existing tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WordPress provides well-optimized built-in methods for accessing the existing
    database tables. Therefore, we don't need to write our own queries. Let's see
    how basic **Create, Read, Update, Delete** (**CRUD**) operations are executed
    on existing tables.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the existing tables contain a pre-built insert functions for creating new
    records. Some of these functions uses a predefined set of parameters while other
    functions accepts array of information for inserting the record. Let''s take a
    look at some of the frequently used insert functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `wp_insert_post` | Creates a new post or page in the `wp_posts` table. If
    this is used on an existing post, it will update the existing record. Accepts
    an array type parameter with all post details. |'
  prefs: []
  type: TYPE_TB
- en: '| `add_option` | Creates a new option in the `wp_options` table, if it doesn’t
    already exist. Accepts key and value as parameters. |'
  prefs: []
  type: TYPE_TB
- en: '| `wp_insert_user` | Creates a new user in the `wp_users` table. Accepts an
    array type parameter with all post details. |'
  prefs: []
  type: TYPE_TB
- en: Updating records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the existing tables contain a pre-built update method for updating existing
    records. The following list illustrates a few of the built-in update functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `update_post_meta` | This creates or updates additional details about posts
    in the `wp_postmeta` table. Accepts post ID, key, and value as parameters. |'
  prefs: []
  type: TYPE_TB
- en: '| `wp_update_term` | This updates existing terms in the `wp_terms` table. Accepts
    term ID and taxonomy as parameters. |'
  prefs: []
  type: TYPE_TB
- en: '| `update_user_meta` | This updates user meta details in the `wp_usermeta` table
    based on the user ID. Accepts user ID, key, and value as parameters. |'
  prefs: []
  type: TYPE_TB
- en: Deleting records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have similar methods for deleting records in each of the existing tables
    as we have for updating records. The following list illustrates a few of the built-in
    delete functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `delete_post_meta` | This deletes custom fields using the specified key in
    the `wp_postmeta` table. Accepts post ID, key, and value as parameters. |'
  prefs: []
  type: TYPE_TB
- en: '| `wp_delete_post` | This removes existing posts, pages, or attachments from
    the `wp_posts` table. Accepts post ID as parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| `delete_user_meta` | This removes the metadata matching criteria from a user
    from the `wp_usermeta` table. Accepts user ID, key, and value as parameters. |'
  prefs: []
  type: TYPE_TB
- en: Selecting records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, there is a set of built-in functions for selecting records from the
    existing tables. The following list contains a few of the data-selecting functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `get_posts` | This retrieves the posts as an array from the `wp_posts` table
    based on the passed arguments. Also, we can use the `WP_Query` class with the
    necessary arguments to get the post list from the OOP method. Accepts an array
    type parameter with all post details. |'
  prefs: []
  type: TYPE_TB
- en: '| `get_option` | This retrieves the option value of the given key from the `wp_options` table.
    Accepts a key parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| `get_users` | This retrieves a list of users as an array from the `wp_user` table.
    Accepts an array type parameter with all post details. |'
  prefs: []
  type: TYPE_TB
- en: Most of the database operations on exiting tables can be executed using these
    built-in functions, and you rarely find scenarios for creating your own queries.
  prefs: []
  type: TYPE_NORMAL
- en: Executing basic CRUD operations on custom tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WordPress provides a built-in class called `wpdb` for handling database queries.
    This class is located inside the `wp-includes` directory. The `wpdb` class will
    be available inside your plugins and themes as a global variable and provides
    access to all the tables inside the WordPress database, including custom tables.
    Using this class for queries adds an extra layer of security as well as optimizes
    the database queries.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `wpdb` class for CRUD operations is straightforward with its built-in
    methods. A complete guide for using the `wpdb` class can be found at [http://codex.wordpress.org/Class_Reference/wpdb](http://codex.wordpress.org/Class_Reference/wpdb).
  prefs: []
  type: TYPE_NORMAL
- en: Basically, there are no built-in methods for accessing custom tables using direct
    functions, so it's a must to use the `wpdb` class for handling custom tables.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `wpdb` class provides a built-in insert function to insert records to custom
    database tables. So, we need to use it for better performance, instead of writing
    `INSERT` queries from scratch. Let''s take look at the syntax of insert function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter takes the table name. You need to specify the custom table
    name with the WordPress database prefix. The next parameter uses an array of column
    names and respective values. The final parameter defines the correct format for
    the fields defined in the previous array. We can get number of affected rows on
    success and false as a return value on failure.
  prefs: []
  type: TYPE_NORMAL
- en: Updating and deleting records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These operations works similar to insert, by using the update and delete functions
    of the `wpdb` class. Let''s take a look at the syntaxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, clause conditions as an array for the third parameter and format
    of the columns in where clause as fifth parameter. Other parameters are exactly
    the same as the insert function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we only have to pass the delete conditions as an array and respective
    formats of the columns. The preceding query will delete the record with an ID
    equal to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can pass the query to various `wpdb` class functions such as `get_results`,
    `query`, and `get_var`, and get the result dataset. The following section illustrates
    the use of these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `$wpdb->get_results( ''select query'' )` | This can be used to select a set
    of records from any database table. |'
  prefs: []
  type: TYPE_TB
- en: '| `$wpdb->query(''query'')` | This can be used to execute any custom query.
    This is typically used to update and delete statements instead of select statements,
    as it only provides the affected rows count as the result. |'
  prefs: []
  type: TYPE_TB
- en: '| `$wpdb->get_row(''query'')` | This can be used to retrieve a single row from
    the database as an object, an associative array, or as a numerically indexed array.
    |'
  prefs: []
  type: TYPE_TB
- en: In this section, we had a brief overview of the techniques used for querying
    the database as well as built-in functions that simplify the database operations.
    In the upcoming chapters, we will be working with these functions as well as advanced
    query techniques while developing themes and plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this chapter was to understand the role of default database tables
    and how we can adapt them to our requirements. We started by analyzing the database
    relationship diagram and identifying connections between tables. We also looked
    at the role of each database table with commonly used data.
  prefs: []
  type: TYPE_NORMAL
- en: We identified the need for knowing proper database usage of core features, and
    explored various ways of tracking database usage for each feature. Then, we had
    a brief overview of database structure in multisites and how it varies from that
    of a single site database. Finally, we looked at various functions for querying
    both default tables and custom tables.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](94db5df8-bbb4-4e75-ae88-fa38a9aabe05.xhtml), *Designing Flexible
    Frontends with Theme Development*, we will be starting the development process
    by working with child themes, theme templates, and dynamic theme components.
  prefs: []
  type: TYPE_NORMAL
