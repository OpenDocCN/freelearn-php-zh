<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Summoning the Test Doubles"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Summoning the Test Doubles</h1></div></div></div><p>In this chapter, we are going to take a close look <a id="id260" class="indexterm"/>at test doubles in order to control our tests with more accuracy and avoid having to rely on interfaces we don't know anything about.</p><p>We're going to complete the work we started in the previous chapter and understand how to deal with external dependencies, particularly the difference between stubs and mocks.</p><p>We will then spend the rest of the chapter on understanding how to organize our tests to improve legibility and maintainability, using some BDD-oriented tools we've introduced earlier in the book, such as <a id="id261" class="indexterm"/>
<span class="strong"><strong>Specify</strong></span> and <a id="id262" class="indexterm"/>
<span class="strong"><strong>Verify</strong></span>.</p><p>On a high level, these are the topics that we will cover in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Dealing with external dependencies</li><li class="listitem" style="list-style-type: disc">Isolating components with stubs</li><li class="listitem" style="list-style-type: disc">Listening for calls with an observer</li><li class="listitem" style="list-style-type: disc">Writing maintainable unit tests</li></ul></div><div class="section" title="Dealing with external dependencies"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Dealing with external dependencies</h1></div></div></div><p>We left our suite<a id="id263" class="indexterm"/> of unit tests at an almost complete status. What we had left to cover with tests was the <code class="literal">validatePassword()</code> method from our <code class="literal">User</code> model class.</p><p>The problem that this method is giving us is that we are planning to use our beloved security component, kindly provided by Yii, to encrypt and decrypt the password and verify its correctness. This component is available throughout the life of the application via <code class="literal">Yii::$app-&gt;getSecurity()</code>.</p><p>The <code class="literal">yii\base\Security</code> class<a id="id264" class="indexterm"/> exposes a series of methods to help you strengthen your application. The use we will make of it is quite limited, but I would recommend reading a bit more about it on the official documentation available at <a class="ulink" href="http://www.yiiframework.com/doc-2.0/guide-security-authentication.html">http://www.yiiframework.com/doc-2.0/guide-security-authentication.html</a> and the following sections that will cover all aspects of authentication, encryption, and so forth.</p><p>Let's then define <a id="id265" class="indexterm"/>how we think our implementation should work for this method. The documented use for validating the password is the following:</p><div class="informalexample"><pre class="programlisting">public function testValidatePasswordReturnsTrueIfPasswordIsCorrect() {
    $expectedPassword = 'valid password';

    $this-&gt;_user-&gt;password = Yii::$app-&gt;getSecurity()-&gt;generatePasswordHash($expectedPassword);

    $this-&gt;assertTrue($this-&gt;_user-&gt;validatePassword($expectedPassword));
}</pre></div><p>This means that we will need to create the password hash first by using the aforementioned helper class, set it in the user, and then can use the <code class="literal">$user-&gt;validatePassword()</code> method to check whether the actual cleartext password that is passed matches the internal one. Some sort of encryption/decryption should happen behind the curtains, ideally by using <code class="literal">Security::validatePassword()</code> from the security component.</p><p>A possible implementation of <code class="literal">User::validatePassword()</code> in the user model can be the following:</p><div class="informalexample"><pre class="programlisting">// models/User.php

/**
 * Validates password
 *
 * @param  string  $password password to validate
 * @return boolean if password provided is valid for current user
 */
public function validatePassword($password)
{
    return Yii::$app-&gt;getSecurity()-&gt;validatePassword($password, $this-&gt;password);
}</pre></div><p>If we try to run the tests, this specific method will pass without problems.</p><p>This might be a good solution, but we need to be extremely conscious that this is not a true unit test; it's <a id="id266" class="indexterm"/>more of an integration test, as we still have the dependency on the security component.</p></div></div>
<div class="section" title="Isolating components with stubs"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec32"/>Isolating components with stubs</h1></div></div></div><p>The problem <a id="id267" class="indexterm"/>we are facing right now is that we don't really want to use the actual security component, as it's not part of the test itself. Keep in mind that we're working in a black box environment, and we don't know what other dependencies the security component might have in the future. We just need to ensure that our implemented method will behave correctly, given the interface of the (fake) object works as expected. We can later add an integration method to ensure that the security component actually works, but that's a completely different matter.</p><p>In order to do that, PHPUnit provides an interesting system for stubbing and mocking classes and injecting them into your application to provide a more controlled environment. Generically, these are normally called <span class="strong"><strong>test doubles</strong></span><a id="id268" class="indexterm"/> and the method used to create them is through the Mock Builder.</p><p>The latest versions of PHPUnit (4.x or above) suggest the use of the Mock Builder in order to configure the stub and behavior. Previously, this was done through a lengthy series of arguments to be passed to it. I won't indulge in saying that if you're working with PHPUnit 3.x or earlier versions, it might be time to upgrade!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Please note that the <code class="literal">final</code>, <code class="literal">private</code>, and <code class="literal">static</code> methods <span class="emphasis"><em>cannot</em></span> be stubbed or mocked as a PHPUnit test double functionality does not support this.</p></div></div><p>
<span class="strong"><strong>Stubbing</strong></span> in <a id="id269" class="indexterm"/>particular refers to the practice of replacing an object with a test double that might return configured values.</p><p>So, how are we doing this? I've decided to take the approach of using a separate private function to delegate the stubbing logic to a reusable piece of code:</p><div class="informalexample"><pre class="programlisting">/**
 * Mocks the Yii Security module,
 * so we can make it return what we need.
 *
 * @param string $expectedPassword the password used for encoding
 *                                 also used for validating if the
 *                                 second parameter is not set
 */
private function _mockYiiSecurity($expectedPassword)
{
    $security = $this-&gt;getMockBuilder(
'yii\base\Security')
        -&gt;getMock();</pre></div><p>We start by <a id="id270" class="indexterm"/>creating the stub of our security class by using <code class="literal">getMockBuilder()</code>. By default, the Mock Builder will replace all the class methods with test doubles that return <code class="literal">null</code>.</p><p>We can also decide selectively which ones are to be replaced by specifying them in an array and then passing it to <code class="literal">setMethods()</code>; for example: <code class="literal">setMethods(['validatePassword', 'generatePasswordHash'])</code>.</p><p>We can also pass <code class="literal">null</code> to it; we can avoid any method from having a test double, but without it, we won't be able to set any expectation.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>If the class you're mocking performs unneeded initializations in the <code class="literal">__constructor()</code> method, you can disable it by using <code class="literal">disableOriginalConstructor()</code> or passing custom arguments with <code class="literal">setConstructorArguments()</code>. There are more methods that can be applied to modify the behavior of the Mock Builder; refer<a id="id271" class="indexterm"/> to the following documentation: <a class="ulink" href="https://phpunit.de/manual/current/en/test-doubles.html#test-doubles.stubs">https://phpunit.de/manual/current/en/test-doubles.html#test-doubles.stubs</a>.</p></div></div><p>Any method that is a test double can be configured and be monitored with the use of <code class="literal">expects()</code>:</p><div class="informalexample"><pre class="programlisting">    $security-&gt;expects($this-&gt;any())
        -&gt;method('validatePassword')
        -&gt;with($expectedPassword)
        -&gt;willReturn(true);

    $security-&gt;expects($this-&gt;any())
        -&gt;method('generatePasswordHash')
        -&gt;with($expectedPassword)
        -&gt;willReturn($expectedPassword);

    Yii::$app-&gt;set('security', $security);
}</pre></div><p>This seems to be pretty much straightforward to read: any (<code class="literal">any()</code>) time the method (<code class="literal">method()</code>) '<code class="literal">validatePassword</code>' is invoked with (<code class="literal">with()</code>) the <code class="literal">$expectedPassword</code>, it will return (<code class="literal">willReturn()</code>) true.</p><p>There are a <a id="id272" class="indexterm"/>number of ways you can configure your replaced functions: having them return only once a certain value, or different values in consecutive calls, or throw exceptions, when invoked.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>Much more is available and documented in the official <a id="id273" class="indexterm"/>PHPUnit documentation available at <a class="ulink" href="https://phpunit.de/manual/current/en/test-doubles.html">https://phpunit.de/manual/current/en/test-doubles.html</a>.</p></div></div><p>We can then implement the negative test to cover a wrong password passed to <code class="literal">validatePassword()</code> with the logic we wanted:</p><div class="informalexample"><pre class="programlisting">/**
 * @expectedException yii\base\InvalidParamException
 */
public function testValidatePasswordThrowsInvalidParamExceptionIfPasswordIsIncorrect() {
    $password = 'some password';
    $wrongPassword = 'some other password';
    $this-&gt;_mockYiiSecurity($password, $wrongPassword);

    $this-&gt;_user-&gt;password = $password;
    $this-&gt;_user-&gt;validatePassword($wrongPassword);
}</pre></div><p>For this to happen, we will need to slightly refactor the private method we just implemented:</p><div class="informalexample"><pre class="programlisting">/**
 * Mocks the Yii Security module,
 * so we can make it returns what we need.
 *
 * @param string $expectedPassword the password used for encoding
 *                                 also used for validating if the
 *                                 second parameter is not set
 * @param mixed $wrongPassword  if passed, validatePassword will
 *                              throw an InvalidParamException
 *                              when presenting this string.
 */
private function _mockYiiSecurity($expectedPassword, $wrongPassword = false)
{
    $security = $this-&gt;getMockBuilder(
'yii\base\Security')
        -&gt;getMock()
    );
    if ($wrongPassword) {
        $security-&gt;expects($this-&gt;any())
            -&gt;method('validatePassword')
            -&gt;with($wrongPassword)
            -&gt;willThrowException(new InvalidParamException());
    } else {
        $security-&gt;expects($this-&gt;any())
            -&gt;method('validatePassword')
            -&gt;with($expectedPassword)
            -&gt;willReturn(true);
    }
    $security-&gt;expects($this-&gt;any())
        -&gt;method('generatePasswordHash')
        -&gt;with($expectedPassword)
        -&gt;willReturn($expectedPassword);

    Yii::$app-&gt;set('security', $security);
}</pre></div><p>Here, we can finally <a id="id274" class="indexterm"/>see how to configure our replaced method to throw the exception using <code class="literal">willThrowException()</code>. With it, we can ensure an exception is being thrown by a method; for this reason, tests that check for exceptions are to be separated from the others.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>The official <a id="id275" class="indexterm"/>documentation provides a more detailed explanation of the use of the Mock Builder API and it is available at <a class="ulink" href="https://phpunit.de/manual/current/en/test-doubles.html">https://phpunit.de/manual/current/en/test-doubles.html</a>.</p></div></div></div>
<div class="section" title="Listening for calls with an observer"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Listening for calls with an observer</h1></div></div></div><p>As <code class="literal">User::validatePassword()</code> is now using <code class="literal">Security::validatePassword()</code> in its implementation in <a id="id276" class="indexterm"/>a transparent way, we don't want to expose any of this when setting the password to whoever is going to use the User model.</p><p>So, we'd like to think that when setting the password, our implementation will use <code class="literal">Security::generatePasswordHash()</code> in some way, so that when calling <code class="literal">User::validatePassword()</code>, we close the circle and everything should work without having to worry too much about encryption schemes and what not.</p><p>An immediate, somewhat<a id="id277" class="indexterm"/> logical, but quite abused way to implement a test that could cover this bit is the following:</p><div class="informalexample"><pre class="programlisting">public function testSetPasswordEncryptsThePasswordCorrectly()
{
    $clearTextPassword = 'some password';
    $encryptedPassword = 'encrypted password';

    // <span class="strong"><strong>here, we need to stub our security component</strong></span>

    $this-&gt;_user-&gt;setPassword($clearTextPassword);

    $this-&gt;assertNotEquals(
        $clearTextPassword, $this-&gt;_user-&gt;password
    );
    $this-&gt;assertEquals(
        $encryptedPassword, $this-&gt;_user-&gt;password
    );
}</pre></div><p>Let's stop one second and understand what we're doing here: ideally we want to set a password and read it back encrypted, doing the related and needed assertions. This means that we are both testing the setter and the getter of the password in the same test, which, once again, defies the basic principle of doing unit testing.</p><p>As a side note, however we implement the stubbing of the security component, our logic won't look much different from the initial implementation we had at the beginning of this chapter.</p><div class="section" title="Introducing mocking"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec38"/>Introducing mocking</h2></div></div></div><p>Mocking refers <a id="id278" class="indexterm"/>to the act of replacing an object with a test double that verifies the expectations, for instance ensuring that a method has been called. This seems to meet our needs exactly.</p><p>In a proper black box scenario, we won't know what <code class="literal">setPassword()</code> does and we would need to rely on the code coverage purely to understand if we've covered any possible branch of the programming flow, as previously said in <a class="link" href="ch04.html" title="Chapter 4. Isolated Component Testing with PHPUnit">Chapter 4</a>, <span class="emphasis"><em>Isolated Component Testing with PHPUnit</em></span>.</p><p>Purely as an example <a id="id279" class="indexterm"/>for our purposes, we want to make sure that when calling <code class="literal">setPassword()</code>, we call <code class="literal">Security::generatePasswordHash()</code> at least once and that the argument is passed over to the method without any modification.</p><p>Let's try the following approach to test this:</p><div class="informalexample"><pre class="programlisting">public function testSetPasswordCallsGeneratePasswordHash()
{
    $clearTextPassword = 'some password';

    $security = $this-&gt;getMockBuilder(
'yii\base\Security')

        -&gt;getMock(
);
    $security-&gt;expects($this-&gt;once())
        -&gt;method('generatePasswordHash')
        -&gt;with($this-&gt;equalTo($clearTextPassword));
    Yii::$app-&gt;set('security', $security);

    $this-&gt;_user-&gt;setPassword($clearTextPassword);
}</pre></div><p>As you might have noticed, we don't have any specific assertion in this test. Our mocked class will just mark the test as passed once its method has been called with the specified value.</p><div class="section" title="Getting to know the Yii virtual attributes"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec09"/>Getting to know the Yii virtual attributes</h3></div></div></div><p>In the <a id="id280" class="indexterm"/>example we just discussed, it would have been great if we could have hidden the functionality of transforming the cleartext password into an hash from the user.</p><p>There are multiple reasons why this isn't happening, but the most important of them is that Yii already provides a quite interesting and well-done system for virtual attributes. This system is in place since Yii 1, and once you get used to it, you can achieve satisfying results.</p><p>By implementing a model that inherits from <code class="literal">yii\base\Component</code>, such as <code class="literal">ActiveRecord</code> or <code class="literal">Model</code>, you will also inherit the already implemented magic functions <code class="literal">__get()</code> and <code class="literal">__set()</code> that help you deal with virtual attributes. This ends up being particularly useful when you are in need of creating additional attributes without any effort.</p><p>Let's see a more practical example.</p><p>Let's assume that our <a id="id281" class="indexterm"/>User model had a first name and a last name field in the database, but we would need to create the full name attribute without adding a new column in the user table:</p><div class="informalexample"><pre class="programlisting">namespace app\models;

class User extends ActiveRecord
{
    /**
     * Getter for fullname
     */
    public function getFullname()
    {
        return $this-&gt;firstname . ' ' . $this-&gt;lastname;
    }

    // rest of the class
}</pre></div><p>So, we can access the field as if it was a normal attribute of the class:</p><div class="informalexample"><pre class="programlisting">public function testGetFullnameReturnsTheCorrectValue()
{
    $user = new User;
    $user-&gt;firstname = 'Rainer';
    $user-&gt;lastname = 'Wolfcastle';

    $this-&gt;assertEquals(
        $user-&gt;firstname . ' ' . $user-&gt;lastname,
        $user-&gt;fullname
    );
}</pre></div><p>Plain and simple public attributes work as you would expect them to. In the following snippets of code, I'm introducing a new class <code class="literal">Dog</code>, purely for example purposes, which extends from <code class="literal">Model</code>:</p><div class="informalexample"><pre class="programlisting">namespace app\models;

use Yii;
use yii\base\Model

class Dog extends Model
{
    public $age;
}</pre></div><p>Therefore, our tests<a id="id282" class="indexterm"/> would pass without problems:</p><div class="informalexample"><pre class="programlisting">public function testDogAgeIsRecordedCorrectly()
{
    $expectedAge = 7;
    $dog = new Dog;
    $dog-&gt;age = $expectedAge;

    $this-&gt;assertEquals($expectedAge, $dog-&gt;age);
}</pre></div><p>This shouldn't be a surprise to you at all, but let's see what happens if we have both:</p><div class="informalexample"><pre class="programlisting">namespace app\models;

class Dog extends ActiveRecord
{
    const AGE_MULTIPLIER = 7;
    public $age;

    public function setAge($age){
        // let's record it in dog years
        $this-&gt;age = $age * self::AGE_MULTIPLIER;
    }

    // rest of the class
}</pre></div><p>Now, we are expecting <code class="literal">setAge()</code> to be triggered on assignment, while reading directly the value of the public attribute:</p><div class="informalexample"><pre class="programlisting">public function testDogAgeIsRecordedInDogYears()
{

    $dog = new Dog;
    $dog-&gt;age = 8;

    $this-&gt;assertEquals(
        56, 
        $dog-&gt;age
    );
}</pre></div><p>However, running<a id="id283" class="indexterm"/> this test will only reveal the sad truth:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ../vendor/bin/codecept run unit models/DogTest.php</strong></span>

<span class="strong"><strong>1) tests\codeception\unit\models\DogTest::testAgeIsRecordedInDogYears</strong></span>
<span class="strong"><strong>Failed asserting that 8 matches expected 56.</strong></span>
</pre></div><p>Yes, the test is exactly the same.</p><p>Having getters and setters automatically handled by our classes comes at an expense. The sequence of checks that are performed by the magic setter can be summarized with the following:</p><div class="informalexample"><pre class="programlisting">BaseActiveRecord::__set($name, $value)
  if (BaseActiveRecord::hasAttribute($name))
      $this-&gt;_attributes[$name] = $value;
  else
      Component::__set($name, $value)
        if (method_exists($this, 'set'.$name))
            $this-&gt;'set'.$name($value);
        if (method_exist($this, 'get'.$name))
            throw new InvalidCallException(...);
        else
            throw new UnknownPropertyException(...);</pre></div><p>If you have implemented a model extending from <code class="literal">yii\base\ActiveRecord</code>, its base class will first check if the attribute is already available as a table column; otherwise, it will pass the call over to <code class="literal">Component::__set()</code>. This method is available not only for models extending from <code class="literal">yii\base\Model</code>, but also for any other that implicitly inherits from <code class="literal">yii\base\Component</code>, such as behaviors and events.</p><p>Following this, we can see that the setter will ensure that the <code class="literal">'set'.$name</code> method is available in our class, and if there's only a getter, then it will raise an exception.</p><p>In our initial definition of the <code class="literal">firstname</code> getter, we could have had the following additional test:</p><div class="informalexample"><pre class="programlisting">/**
 * @expectedException yii\base\InvalidCallException
 */
public function testSetFullnameThrowsException()
{
    $user = new User;
    $user-&gt;firstname = 'Fido';
    $user-&gt;lastname = 'Smith';

    // setter not available
    $user-&gt;fullname = 'Something Else';
}</pre></div><p>There are a <a id="id284" class="indexterm"/>couple or more things regarding events and behaviors done in the setter, but we won't touch them as of now.</p><p>So, going back to our <code class="literal">setPassword()</code> conundrum, we need to be aware that if we were to trigger the magic method by using <code class="literal">$user-&gt;password</code> for the left assignment, this won't trigger our method.</p><p>So, the best solution would ideally have been to call the stored password in a more declarative way, such as <code class="literal">password_hash</code>.</p></div></div></div>
<div class="section" title="Writing maintainable unit tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Writing maintainable unit tests</h1></div></div></div><p>As the last part, before<a id="id285" class="indexterm"/> leaving the unit tests behind, I wanted to show some additional features provided by Codeception that have been already introduced in <a class="link" href="ch01.html" title="Chapter 1. The Testing Mindset">Chapter 1</a>, <span class="emphasis"><em>The Testing Mindset</em></span>.</p><p>Codeception has been created with modularity and flexibility in mind, so anything else is your responsibility. In particular, you might have already noticed that our <code class="literal">UserTest</code> class has grown quite a bit.</p><p>So, what would happen if a change in the interface or in the way our model works breaks our tests?</p><p>It's quite clear, especially if you're working in a team or even more if your code gets handed over to other people to maintain, that you need clear rules so that everybody agrees on how to write the code, as a starter, and tests.</p><p>I've already highlighted in <a class="link" href="ch04.html" title="Chapter 4. Isolated Component Testing with PHPUnit">Chapter 4</a>, <span class="emphasis"><em>Isolated Component Testing with PHPUnit</em></span>, that one of the very basic things I've started doing with the teams I've worked with and with my own code, is to define precise and simple rules, which aim at the clarity and readability of the code. I've seen way too many "developer rockstars" that show off how good they are at writing compressed code, nesting variables, and hiding multiple assignments. Writing code that ends up being obfuscated might be fun if that code is a throwaway.</p><p>Code legibility ends <a id="id286" class="indexterm"/>up being one of the ways I've seen companies select candidates, and a very quick test is to have someone read your code and be able to get what it does without asking.</p><p>Tests shouldn't be treated with less care than your application code: if done properly, tests represent a way of documenting how things are supposed to be working and how they should be used. As soon as your class provides more and more functionality, your test classes will start to grow and you need to be prepared to face a refactor and introduce regression testing when a change in the application happens or a bug is introduced.</p><div class="section" title="Using BDD specification testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec39"/>Using BDD specification testing</h2></div></div></div><p>Codeception <a id="id287" class="indexterm"/>provides a nice and compact <a id="id288" class="indexterm"/>tool called <a id="id289" class="indexterm"/>
<span class="strong"><strong>Specify</strong></span>, which we have already introduced previously.</p><p>With PHPUnit alone, we only have methods to split our tests; using Specify, we have another layer of organization: The method becomes our <span class="emphasis"><em>story</em></span> and our specification blocks our <span class="emphasis"><em>scenarios</em></span>.</p><p>Just for documentation purposes, it should be noted that PHPUnit has its own BDD-compatible syntactic sugar with the <code class="literal">given()</code>, <code class="literal">when()</code> and <code class="literal">then()</code> methods, as explained at <a class="ulink" href="https://phpunit.de/manual/3.7/en/behaviour-driven-development.html">https://phpunit.de/manual/3.7/en/behaviour-driven-development.html</a>. You can still use this syntax, if you are more used to it.</p><p>As a clearer example, we can group all validation rules within the same test and split the definition of what we're doing by using Specify blocks, as follows:</p><div class="informalexample"><pre class="programlisting">use Specify;

public function testValidationRules()
{
    $this-&gt;specify(
        'user should not validate if no attribute is set',
        function () {
 verify_not($this-&gt;_user-&gt;validate());
 }
    );

    $this-&gt;specify(
        'user should validate if all attributes are set', 
        function () {
            $this-&gt;_user-&gt;attributes = [
                'username'=&gt;'valid username',
                'password'=&gt;'valid password',
                'authkey' =&gt;'valid authkey'
            ];
            verify_that($this-&gt;_user-&gt;validate());
        }
    );
}</pre></div><p>As we can see, we <a id="id290" class="indexterm"/>are now aggregating<a id="id291" class="indexterm"/> two of our previous tests within a single method and grouping them within two blocks of <code class="literal">specify()</code> calls.</p><p>Specify is defined as a trait; this is the reason why you need to both use the namespace in the outermost global scope and load it within the test class:</p><div class="informalexample"><pre class="programlisting">namespace tests\codeception\unit\models;

<span class="strong"><strong>use Codeception\Specify;</strong></span>
use yii\codeception\TestCase;
// other imported namespaces

class UserTest extends TestCase
{
    <span class="strong"><strong>use Specify;</strong></span>
    
    // our test methods will follow
    // we can now use $this-&gt;specify()
}</pre></div><p>As you can see <code class="literal">specify()</code> requires only two arguments: a simple description of the scenario that we are about to define, and an anonymous function that contains the assertions we want to do.</p><p>At this point, we can either use the PHPUnit classic assertions we've used until now or try to empower BDD style assertions. <span class="strong"><strong>Verify</strong></span>, a <a id="id292" class="indexterm"/>small and nifty package, will provide you this capability, allowing you to use methods such as <code class="literal">verify()</code>, <code class="literal">verify_that()</code>, and <code class="literal">verify_not()</code>.</p><p>From the earlier specified scenarios, consider the following line of code:</p><div class="informalexample"><pre class="programlisting">verify_not($this-&gt;_user-&gt;validate());</pre></div><p>This is exactly<a id="id293" class="indexterm"/> the same as using the PHPUnit assertion:</p><div class="informalexample"><pre class="programlisting">$this-&gt;assertFalse($this-&gt;_user-&gt;validate());</pre></div><p>In order to perform more <a id="id294" class="indexterm"/>elaborate assertions, we can instead use <code class="literal">verify()</code> in the following way:</p><div class="informalexample"><pre class="programlisting">$this-&gt;specify(
    'user with username too long should not validate',
    function () {
        $this-&gt;_user-&gt;username = 'this is a username longer than 24 characters';

        verify_not($this-&gt;_user-&gt;validate('username'));
        <span class="strong"><strong>verify($this-&gt;_user-&gt;getErrors('username'))-&gt;notEmpty();</strong></span>
    }
);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>There are plenty of other assertions that can<a id="id295" class="indexterm"/> be used and can be found at the project homepage at <a class="ulink" href="https://github.com/Codeception/Verify">https://github.com/Codeception/Verify</a>.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Summary</h1></div></div></div><p>In this chapter, we've covered the long-awaited mocks and stubs that will allow you to perform proper component tests. In the final part, we've taken a better look at code organization for your tests and a BDD-like way of writing them by using Specify and Verify.</p><p>In the following chapter, we're going to take a look at the next step of implementing the functional tests that should define the REST interface for our user.</p></div></body></html>