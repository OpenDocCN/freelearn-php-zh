<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Discovering Key Modules in Development</h1>
                </header>
            
            <article>
                
<p>Modern website interfaces are mostly built on the concept of blocks, where the site owners can drag and drop reusable components to build the interfaces. UI components and page builders play a major role in developing these interfaces. Therefore, it's important for developers to have the knowledge of integrating any third-party UI component to build amazing interfaces with interactivity. On the other hand, WordPress is chosen by many developers due to the existing CMS features that accelerate the development process. So, developers need thorough knowledge of using backend features as well as customizing the existing features for custom requirements.</p>
<p>In this chapter, we are going to focus on UI component integration as well as customization of common backend features. We begin the chapter by integrating a jQuery slider to WordPress while using menu pages to capture the data. Then, we will integrate another popular component called accordion by using custom post types to capture the data. After this, we will look at the basic steps of integrating any UI component using the two integrations for Image Slider and accordion. Also, we<span> will look at the importance of modern page builders in site development and discuss the basics of creating a custom component with any page builder. Finally, we will</span> look at the process of customizing backend features by creating a basic dashboard widget and modifying list tables to provide custom features. </p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Integrating UI components</li>
<li>Integrating jQuery image slider</li>
<li>Integrating jQuery accordion</li>
<li>Identifying the steps for integrating UI components</li>
<li>Understanding the use of page builders</li>
<li>Creating custom dashboard widgets</li>
<li>Customizing backend list tables</li>
</ul>
<p>By the end of this chapter, you will have the ability to customize backend admin features as well as integrate UI components into sites with the latest trending methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You will be required to have WordPress 4.9.8 installed to follow this procedure. Even if you<br/>
have a later version of WordPress, the described examples should work with no significant problems.</p>
<p class="mce-root">The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter08">https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter08</a></p>
<p class="mce-root">Check out the following video to see the code in action:<br/>
<a href="http://bit.ly/2yGYX03" target="_blank">http://bit.ly/2yGYX03</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UI components</h1>
                </header>
            
            <article>
                
<p>Modern websites are built on top of interactive UI elements. Many premium WordPress themes include a wide range of UI components with the support of open source JavaScript and CSS libraries. These UI components attract users to a site by simplifying the interfaces as well as providing large content in a limited space. Among hundreds of UI elements, we find image sliders and galleries, tabs being the most popular ones. As a developer, you need to use or build these components to keep up to date with rising UI requirements in modern development. So, it's important to understand the basic process of integrating any UI component into WordPress using plugins or themes. In this section, we are going to look at the integration of two UI components. Let’s get started.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating the jQuery image slider</h1>
                </header>
            
            <article>
                
<p>The image sliders and galleries are the most popular UI elements in WordPress sites. You can visit the <a href="http://wordpress.org" target="_blank">wordpress.org</a> plugin directory or a premium marketplace such as Codecanyon to understand the amount of downloads and purchases of such plugins. We can use these sliders for displaying a set of basic images, as well as to display advanced content and images to promote your products, services, and features.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In this section, we are going to use Basic jQuery Slider (<a href="http://basicslider.com/">http://basicslider.com/</a>) to explain the process of integrating an Image Slider. We will be creating a single Image Slider to display product images in the home page of the site or any other preferred location.</p>
<div class="packt_infobox">Image Slider plugins give you the ability to create multiple reusable sliders using custom post types or custom forms. In this scenario, we are only focusing on a single predefined slider.</div>
<p>Before starting the implementation, we have to create another plugin for this chapter. We are going to name it <kbd>WPQuick Key Modules</kbd> in a directory called <kbd>wpquick-key-modules</kbd>. We will be using this plugin for the implementation of most of the features discussed in this chapter. The plugin will have the same structure as the previous plugins, with a main class initializing all the other features and classes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a product image slider</h1>
                </header>
            
            <article>
                
<p>We can use sliders to display any type of content, with the common type of content being images. The first step of integrating any UI component is the process of capturing the data. In this scenario, the required data will be a set of images. So, we need to build an interface to let the administrator upload a set of images for the slider. We have two options for creating an interface for such requirements:</p>
<ul>
<li><strong>Menu pages</strong>: We can use the <kbd>add_menu_page</kbd> function to create a new menu page for the features of our plugin. This will be a top-level menu item in the WordPress admin menu with the ability to support sub menu pages. This is suitable when you need to highlight the menu of your plugin as well as create different menu pages for various features of the plugin. More details about the <span><kbd>add_menu_page</kbd> function are available at </span><a href="https://developer.wordpress.org/reference/functions/add_menu_page/">https://developer.wordpress.org/reference/functions/add_menu_page/</a>.</li>
<li><strong>Options pages</strong>: We can use the <kbd>add_options_page</kbd> function to createa new options page for custom settings. This function will create a sub-level menu item on the <span class="packt_screen">Settings</span> menu item. However, it doesn't support further levels, and hence it will be difficult to use for plugins that require multiple menu pages. This is useful for adding general site specific settings rather than plugin settings. More details about the <span><kbd>add_options_page</kbd> function</span> is available at <a href="https://developer.wordpress.org/reference/functions/add_options_page/">https://developer.wordpress.org/reference/functions/add_options_page/</a>.</li>
</ul>
<p>In this scenario, we are going to choose menu pages for the image uploading interface, as this is a plugin-specific custom requirement. Let's build a menu page to upload the images.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a plugin menu page</h1>
                </header>
            
            <article>
                
<p>WordPress provides built-in functions to add menu pages through plugins. We can add the interfaces as main- menu items or as sub-menu items. Create a class called <kbd>WQKM_UI_Components</kbd> inside the classes directory of our plugin. Then, we can do the usual file inclusion and object creation within the <kbd>includes</kbd> and <kbd>instance</kbd> functions of the main class of our plugin. Next, we can add the following line of code within  <kbd>admin_menu</kbd>  action to register a new menu page:</p>
<pre>add_menu_page( __('UI Component Settings', 'wqkm' ), __('UI Component Settings', 'wqkm' ),  'manage_options','wqkm-settings', array( &amp;$this,'ui_settings' ) );</pre>
<p>The first two parameters of this function define titles for the menu page and the menu item. The third parameter defines the capability to load this page. Here, we have used <kbd>manage_options</kbd> as the capability to restrict it to the administrator. You can change this capability based on the person responsible for using this interface. The fourth parameter defines a unique slug to access the menu item from the URL. The final parameter defines the callback function to generate the content for this interface. These are the main parameters used for this function. </p>
<p>Now we need to implement the callback function to display the necessary fields to upload the images to the slider. Let's take a look at the structure of the <kbd>ui_settings</kbd> function:</p>
<pre>public function ui_settings(){<br/>  // Define global variables<br/>  // Load template and return to browser<br/>}</pre>
<p>We have already discussed a callback function for template loading in the previous chapters, and hence we will not be discussing the code in detail. First, we define the global variables for holding the main instance of our plugin and passing the data to templates. Then, we load the custom template using the technique we used in the previous chapters, with the support of the custom template loader. You can refer to the source code for the complete implementation. Next, we have to build the custom template to upload files, as shown in the following code:</p>
<pre>&lt;?php<br/> global $wqkm_template_data;<br/> extract($wqkm_template_data);<br/>?&gt;<br/>&lt;form id="wqkm_slider_frm" action="" method="POST" &gt;<br/> &lt;div id="wqkm-slider-msg"&gt;&lt;/div&gt;<br/> &lt;table class="form-table"&gt;<br/>   &lt;tr&gt;<br/>     &lt;th&gt;&lt;label&gt;&lt;?php _e('Product Slider Images','wqkm'); ?&gt;*&lt;/label&gt;&lt;/th&gt;<br/>     &lt;td&gt; &lt;div id="wqkm-slider-images-panel"&gt;&lt;/div&gt;<br/>       &lt;input type="file" name="wqkm_slider_image" id="wqkm_slider_image" value="" /&gt;<br/>     &lt;/td&gt;<br/>   &lt;/tr&gt; <br/>   &lt;tr&gt;<br/>     &lt;th&gt;&amp;&lt;/th&gt;<br/>     &lt;td&gt;&lt;input name="wqkm_ui_submit" id="wqkm_ui_submit" type="button" value="&lt;?php _e('Add Image','wqkm'); ?&gt;" /&gt;&lt;/td&gt;<br/>   &lt;/tr&gt;<br/> &lt;/table&gt;<br/>&lt;/form&gt;</pre>
<p>Let’s understand the structure of this template for handling image uploads:</p>
<ol>
<li>First, we define the global variable to accept the template data passed from the <kbd>WQKM_UI_Components</kbd> class. Initially, this variable will be empty, as we don't have any template data or settings.</li>
<li>Then, we have to define a form to enable data submissions. Inside the form, we have an empty container called <kbd>wqkm-slider-msg</kbd> to handle the form error and success messages.</li>
<li>Next, we add a file input field to select and upload the images for the slider. We also added a DIV element called <kbd>wqkm-slider-images-panel</kbd>, inline with the file field to display the current images uploaded to the slider.</li>
<li>Finally, we add a button instead of a submit button, as we will be using AJAX to handle the form submission.</li>
</ol>
<p>Now the interface is prepared to upload images to the slider. You can access this interface by using the <kbd>UI Component Settings</kbd> menu item from the main menu.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Saving slider images using AJAX</h1>
                </header>
            
            <article>
                
<p>We can use normal post submissions as well as AJAX submissions, as this is a backend screen without any other dependencies. However, AJAX gives better user experience, and hence we will be submitting the form data through AJAX. First, we have to add a new script using the <kbd>load_admin_scripts</kbd> function to handle the AJAX request for saving slider images. We will be using the exact same code used for the <kbd>WooCommerce Product Files</kbd> plugin, and hence you can refer to the main file inside the source code directory for the implementation of the <kbd>load_admin_scripts</kbd> function.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Next, we have to handle the form submission process using AJAX. The code for the file form submission is available inside the <kbd>wqkm-admin.js</kbd> file of the source codes directory. The implementation will be the same as the one we used in the <kbd>wqwpf-admin.js</kbd> file of the <kbd>WQWPF Product Files</kbd> plugin, except for the following differences:</p>
<ul>
<li>In this case, we have get the custom form using the form ID, instead of using a built-in post-submission form</li>
<li>We use the <kbd>wqkm_save_slider_images</kbd> action instead of the <kbd>wqwpf_save_product_files</kbd></li>
<li>We remove the post-ID parameter, as we are not submitting a form related to a post</li>
</ul>
<p>Now we come to the final part of the image-saving process by uploading and capturing the file data. We have to begin by adding the following action to the constructor of the <kbd>WQKM_UI_Components</kbd> class:</p>
<pre>add_action( 'wp_ajax_wqkm_save_slider_images', array( $this, 'save_slider_images') );</pre>
<p>This process is only executed by the logged users, and hence we have omitted the <kbd>wp_ajax_nopriv</kbd> action. Let’s take a look at the implementation of the <kbd>save_slider_images</kbd> function:</p>
<pre>public function save_slider_images(){<br/> global $wpdb; <br/> $file_nonce = isset( $_POST['file_nonce'] ) ? ($_POST['file_nonce']) :'';<br/> $user_id = get_current_user_id();<br/><br/> if(check_ajax_referer( 'wqkm-private-admin', 'file_nonce',false )){<br/>   $result_upload = $this-&gt;process_file_upload();<br/>   if(isset($result_upload['status']) &amp;&amp; $result_upload['status'] == 'success' ){<br/>     $file_date = date("Y-m-d H:i:s"); <br/>     $uploaded_file_name = $result_upload['base_name'];<br/>     $slider_images = (array) get_option('wqkm_slider_images');<br/>     $slider_images[] = $result_upload['relative_file_path'];<br/>     update_option( 'wqkm_slider_images', $slider_images );<br/>     $upload_dir = wp_upload_dir();<br/>     $display_images = '';<br/>     foreach ($slider_images as $slider_image) {<br/>       if( $slider_image != '' )<br/>         $display_images .= '&lt;img src="' . $upload_dir['baseurl'] . $slider_image . '" style="width:100px;height:100px" /&gt;';<br/>     }<br/><br/>     $result = array( 'status' =&gt; 'success', 'msg' =&gt; $result_upload['msg'] , 'images' =&gt; $display_images );<br/>   }else{<br/>     $result = array( 'status' =&gt; 'error','msg'=&gt; $result_upload['msg']);<br/>   }<br/> }else{<br/>   $result = array( 'status' =&gt; 'error', 'msg' =&gt; __('Invalid file upload request.','wqkm') );<br/> }<br/> echo json_encode($result);exit;<br/>}</pre>
<p><span>Here's what the previous code does</span>:</p>
<ol>
<li>We begin the function by retrieving the nonce value from the POST request and assigning the ID of the logged-in user.</li>
<li>Then, we upload the images in the request using the <kbd>process_file_upload</kbd> function, after completing the nonce verification. We have made a copy of the <kbd>process_file_upload</kbd> function from the <strong>Post Attachments</strong> plugin developed earlier. The only difference is the use of image-specific file types instead of the document file types we used earlier.</li>
<li>Once the images are uploaded, we use the <kbd>get_option</kbd> function to retrieve the existing images. Then, we add the uploaded image and save the new image set using <kbd>update_option</kbd>. In this scenario, we have stored slider images in the <kbd>wp_options</kbd> table, as it was a predefined slider. In scenarios where we need multiple dynamic sliders, we have to use the <kbd>wp_posts</kbd> table or a custom table to store this data.</li>
<li>Finally, we traverse through the images list and generate the HTML for images to be sent as part of the response for an AJAX request. In the AJAX request, we have to use the necessary keys and display the existing images list inline with the image upload field.</li>
</ol>
<p>Now we have captured the necessary data required for our image slider component. The next step is to use this data along with the necessary scripts to generate the UI component.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing slider images</h1>
                </header>
            
            <article>
                
<p>We need to prepare the HTML code to include the slider images with the necessary containers. The element structure for each slider varies based on the library. Therefore, we need to refer to the documentation of the slider JavaScript library and find out the expected structure. So, we have to visit <a href="http://basicslider.com/">http://basicslider.com/</a> and go to the <span class="packt_screen">Markup</span> section. This section explains the required elements to implement the slider:</p>
<pre>&lt;div id="banner-fade"&gt;<br/> &lt;ul class="bjqs"&gt;<br/> &lt;li&gt;&lt;!-- Any content you like --&gt;&lt;/li&gt;<br/> &lt;/ul&gt;<br/>&lt;/div&gt;</pre>
<p>Now we have to use this structure and add the slider images inside <kbd>&lt;li&gt;</kbd> elements. We can directly add the HTML to a WordPress post or a page, to display a slider. However, we may need to reuse the slider, and hence it is always a good option to implement it as a shortcode or a widget. The shortcode is the perfect solution, as it can be also included within widgets. Let's start the implementation by adding a shortcode to the constructor of the <kbd>WQKM_UI_Components</kbd> class:</p>
<pre>add_shortcode( 'wqkm_product_slider', array( $this, 'product_slider') );</pre>
<p>Now we can implement the shortcode callback function to use the uploaded images and generate the HTML structure required for the slider. Consider the following code:</p>
<pre>public function product_slider( $atts, $content ){<br/> $sh_attr = shortcode_atts( array(<br/>   'width' =&gt; '520',<br/>   'height' =&gt; '320',<br/> ), $atts );<br/><br/> $slider_images = (array) get_option('wqkm_slider_images');<br/> $upload_dir = wp_upload_dir();<br/><br/> $display = '&lt;div id="banner-fade"&gt;&lt;ul class="bjqs"&gt;';<br/> foreach ($slider_images as $slider_image) {<br/>   if( $slider_image != '' )<br/>     $display .= '&lt;li&gt;&lt;img src="' . $upload_dir['baseurl'] . $slider_image . '" /&gt;&lt;/li&gt;';<br/> }<br/> $display .= ' &lt;/ul&gt;&lt;div&gt;';<br/> return $display;<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>We begin the function by defining the available shortcode attributes and their default values. Here, we have only used the <kbd>width</kbd> and the <kbd>height</kbd> of the slider as settings. You may need to define more settings depending on the image slider library of your choice. Then, we retrieve the list of slider images using the <kbd>get_option</kbd> function with the <kbd>wqkm_slider_images</kbd> key. Finally, we traverse through the images and add the image HTML within the <kbd>&lt;li&gt;</kbd> elements while using the main <kbd>&lt;ul&gt;</kbd> and <kbd>&lt;div&gt;</kbd> containers to initialize the slider.</p>
<p>Once the shortcode is added to a post or page, you will see a list of images as bullet points, without any sliding functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating jQuery slider</h1>
                </header>
            
            <article>
                
<p>This is the final part of the integration, where we apply the functionality of JavaScript or CSS libraries to initialize the features of the UI component. So, we need to understand the required library files and the order of inclusion. The required files are shown in the <strong>Usage</strong> section of <a href="http://basicslider.com/">http://basicslider.com/</a>. So, we have to download the necessary libraries and add them within our plugin. Once the files are added, we can use the following script and style registering code inside the <kbd>load_scripts</kbd> function of the main class:</p>
<pre>wp_register_style( 'wqkm-slider', WQKM_PLUGIN_URL . 'css/bjqs.css' );<br/>wp_register_style( 'wqkm-slider-demo', WQKM_PLUGIN_URL . 'css/demo.css' );<br/>wp_register_script( 'wqkm-slider', WQKM_PLUGIN_URL . 'js/bjqs-1.3.js', array('jquery') );<br/>wp_register_script('wqkm-front',WQKM_PLUGIN_URL .'js/wqkm-front.js', array('jquery','wqkm-slider') );</pre>
<p>We have included the <kbd>bjqs.css</kbd> and <kbd>demo.css</kbd> files for styles and the <kbd>bjqs-1.3.js</kbd> file for scripts with jQuery as a dependency. The third line registers a plugin-specific custom script to initialize the slider. So, we have to use both the jQuery and the slider library as dependencies.</p>
<p>Now we need to include these libraries to WordPress requests. We can use the <kbd>wp_enqueue_style</kbd> and the <kbd>wp_enqueue_script</kbd> functions along with registration code to include the files. However, it means these files will be included on every request, even when there are no image sliders in pages. As a solution, we can include them inside the shortcode function, just after the default values for the <span>shortcode attributes</span>. You can refer to the source code for the inclusion of these files.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Then, we come to the final step, where we initialize the component using the necessary scripts. You can refer to the <strong>Activation</strong> section of <a href="http://basicslider.com/">http://basicslider.com/</a> to understand the initialization process, as shown in the following code. This code should be added to the <kbd>wqkm-front.js</kbd> custom script file:</p>
<pre>jQuery(document).ready(function($) { <br/>  $('#banner-fade').bjqs({<br/>    animtype : 'slide',<br/>    height : WQKMFront.height,<br/>    width : WQKMFront.width,<br/>    responsive : true,<br/>    randomstart : true,<br/>    showmarkers   : false, <br/>  });<br/>});</pre>
<p>In this library, <kbd>bjqs</kbd> acts as the initialization function. We use it on the container with the ID <kbd>#banner-fade</kbd>. We have also assigned the shortcode attribute values for <kbd>width</kbd> and <kbd>height</kbd> using the data we added with the <kbd>wp_localize_script</kbd> function. Now you can refresh the browser and see an image slider, instead of the bullet list.</p>
<p>This is a very basic slider with basic functionality. You can find more advanced sliders with images, content, videos, and some amazing effects. You can try different sliders, as the process of integration is the same, regardless of the slider.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reusing the slider as a widget</h1>
                </header>
            
            <article>
                
<p>We had a brief introduction to widgets and their role in WordPress. Widgets was intended to add blocks of features to the sidebar of the site. However, with modern themes and widget areas, widgets can be considered as a reusable block of features similar to shortcodes. So, we are going to look at the process of building a frontend widget in WordPress. Let's start by adding a new file to the <kbd>classes</kbd> directory of our plugin with a class called <kbd>WQKM_Product_Slider_Widget</kbd>.</p>
<p>In this scenario, we will be building a widget to display the product slider created in the previous section. So, we can reuse the shortcode functionality for this widget. Let's take a look at the implementation of the widget, using the following code:</p>
<pre>class WQKM_Product_Slider_Widget extends WP_Widget {<br/>  public function __construct() {<br/>    parent::__construct( 'wqkm_product_slider', esc_html__( 'Product Slider', 'wqkm' ), array( 'description' =&gt; esc_html__( 'Main product slider', 'wqkm' ) ) );<br/>  }<br/><br/>  public function widget( $args, $instance ) {<br/>    echo $args['before_widget']; <br/>    echo do_shortcode('[wqkm_product_slider width="'.$instance['width'].'" height="'.$instance['height'].'" /]');<br/>    echo $args['after_widget'];<br/>  }<br/><br/>  public function form( $instance ) {<br/>    $width = ! empty($instance['width']) ? (int) $instance['width']: 640;<br/>    $height= ! empty($instance['height']) ? (int) $instance['height']:320;?&gt;<br/>    &lt;p&gt;<br/>      &lt;label&gt;&lt;?php esc_attr_e( 'Width:', 'wqkm' ); ?&gt;&lt;/label&gt;<br/>      &lt;input class="widefat" id="&lt;?php echo esc_attr( $this-&gt;get_field_id( 'width' ) ); ?&gt;" name="&lt;?php echo esc_attr( $this-&gt;get_field_name( 'width' ) ); ?&gt;" type="text" value="&lt;?php echo esc_attr( $width ); ?&gt;"&gt;<br/>    &lt;/p&gt;<br/>    &lt;p&gt;<br/>      &lt;label&gt;&lt;?php esc_attr_e( 'Height:', 'wqkm' ); ?&gt;&lt;/label&gt;<br/>      &lt;input class="widefat" id="&lt;?php echo esc_attr( $this-&gt;get_field_id( 'height' ) ); ?&gt;" name="&lt;?php echo esc_attr( $this-&gt;get_field_name( 'height' ) ); ?&gt;" type="text" value="&lt;?php echo esc_attr( $height ); ?&gt;"&gt;<br/>    &lt;/p&gt;<br/> &lt;?php  }<br/><br/>  public function update( $new_instance, $old_instance ) {<br/>    $instance = array();<br/>    $instance['width'] = ( ! empty( $new_instance['width'] ) ) ? (int)          $new_instance['width'] : '';<br/>    $instance['height'] = ( ! empty( $new_instance['height'] ) ) ? (int) $new_instance['height'] : '';<br/>    return $instance;<br/>  }<br/>}</pre>
<p>WordPress uses the <kbd>WP_Widget</kbd> class as the base for handling the widget functionality. All the widgets, including the core widgets, should extend this class to use the widget functionality. Therefore, we have extended this class in our custom <kbd>WQKM_Product_Slider_Widget</kbd> class declaration. Now we can go though the main functions of a widget using the following steps:</p>
<ol>
<li><kbd>constructor</kbd>: We have to use this function to call the constructor of the parent <kbd>WP_Widget</kbd> class, with the necessary parameters. In this case, we have used a unique ID, title, and a description.</li>
</ol>
<ol start="2">
<li><kbd>widget</kbd>: This function is used to generate the output of the widget in the frontend. Here, we have used <kbd>wqkm_product_slider</kbd> shortcode to generate the output for the widget. You can use a shortcode or call a function to generate the output. The <kbd>$instance</kbd> variable contains all the settings for the widget, added to the backend. So, we are using the width and height settings as attributes to the shortcode. You may also notice the use of the <kbd>$args['before_widget']</kbd> and the <kbd>$args['before_widget']</kbd> statements. These are a predefined set of arguments passed to the widget and the values of these arguments are specified when registering the widgets. These arguments are useful for adding common content before or after each widget.</li>
<li><kbd>form</kbd>: This function is used to display the form to capture the settings for the widget. We used width and height in the widget function, and hence we need settings to define those values. First, we get the existing values for the settings using the <kbd>$instance</kbd> variable passed automatically to this function. Then, we generate the input fields for the width and height settings. You may notice the use of the <kbd>get_field_id</kbd> and the <kbd>get_field_name</kbd> functions. These are functions defined in the core <kbd>WP_Widget</kbd> class to provide access to the widget details in a standard way. You should always use these functions without hard-coding names and IDs.</li>
<li><kbd>Update</kbd>: This function is used to save or update the settings data to the database. Once the <span class="packt_screen">Save</span> button of a widget is clicked, this function will be called with the old values, as well as the submitted new values. We have to make the necessary validations and assign the new values to the <kbd>$instance</kbd> variable with the respective keys. Then, the WordPress core widget class will automatically save the values in the <kbd>$instance</kbd> variable.</li>
</ol>
<p>This is the standard process for building any custom widget. Once the widget class is created, you have to use these four functions to generate the necessary settings and output for the widget. Even though we have completed creating the widget, it will not be visible in the <span class="packt_screen">Appearance</span> | <span class="packt_screen">Widgets</span> section. We have to register new widgets, before they appear in the widgets section. Let’s consider the following code for registering our widget:</p>
<pre>add_action( 'widgets_init', array( $this, 'register_product_slider_widget' ) );<br/>public function register_product_slider_widget() {<br/>  register_widget( 'WQKM_Product_Slider_Widget' );<br/>}</pre>
<p class="mce-root"/>
<p>First, we need to include the file inside the <kbd>includes</kbd> function of the main class. Then, we can add the <kbd>widgets_init</kbd> action to the constructor of the <kbd>WQKM_Admin_Features</kbd> class. Finally, we use <kbd>register_widget</kbd> with the class name of the widget inside the callback function to register the new widget. Now you should be able to use the new widget to add the product image slider to your sidebar.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating jQuery accordion</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to look at the integration of another popular UI component called <strong>Accordion</strong>. The accordion is a component that allows you to display a large amount of content within a limited space using collapsible sections. We have chosen the accordion component of the <strong>jQuery UI</strong> library (<a href="https://jqueryui.com/accordion/">https://jqueryui.com/accordion/</a>) as a basic solution. You can find many advanced accordion component libraries.</p>
<p>In the image sliders section, we used a menu page to capture data, and limited it to a single fixed-image slider. However, it’s also important to have the ability to use same component with different content in various places on the site. So, we are going to build accordions with the ability to create unlimited components with dynamic content. We can either use custom post types and store the data in a <kbd>wp_posts</kbd> table, or we can use a custom table. Since we are developing a UI element, we are going to use custom post types to simplify the process. Let’s get started.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an accordion model and capturing data</h1>
                </header>
            
            <article>
                
<p>We have chosen to use custom post types for accordions. Therefore, we need to register a new custom post type by using the <kbd>register_post_type</kbd> function with necessary settings. We already created a custom post type and discussed the process in previous chapters, while working with the property post type. Therefore, you can refer to the <kbd>WQKM_UI_Components</kbd> class inside the source code directory to understand the registration.</p>
<div class="packt_infobox">Unlike properties, accordions are not intended to be displayed as individual posts or to achieve page items. Instead, we use them to capture the data to be reused in UI elements within posts or pages. Therefore, we have to set the <kbd>public</kbd> attribute to <kbd>false</kbd> while creating the custom post type. This setting makes sure that the accordions are not publicly visible as an individual post type.</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Once the post type is registered, we need to use metaboxes to include the necessary fields and capture the data for accordions. The accordion has many sections with dynamic content. So, we need text area fields to capture the content for each section. Let's start by adding a metabox to accordions:</p>
<pre>public function add_accordion_meta_boxes() {<br/>  add_meta_box( 'wqkm-accordion-meta', __('Accordion Details','wqkm'), array( $this, 'display_accordion_meta_boxes' ), $this-&gt;post_type );<br/>}</pre>
<p>Here, we have registered a new meta box for the accordion post type. The <kbd>add_meta_boxes</kbd> action and the post type initialization can be found inside the constructor of the <kbd>WQKM_UI_Components</kbd> class. Now we need to implement the callback function using the following code:</p>
<pre>public function display_accordion_meta_boxes( $accordion ) {<br/> global $wqkm,$template_data;<br/> $template_data['accordion_post_type'] = $this-&gt;post_type;<br/> $template_data['accordion_nonce'] = wp_create_nonce('wqkm-accordion-meta');<br/> $template_data['wqkm_tab_1'] = get_post_meta( $accordion-&gt;ID, '_wqkm_tab_1', true );<br/><br/> ob_start();<br/> $wqkm-&gt;template_loader-&gt;get_template_part( 'accordion','meta');<br/> $display = ob_get_clean();<br/> echo $display;<br/>}</pre>
<p>We begin the function by defining the global variables and adding the post type and nonce to the global template data variable. Then, we get the existing data for the accordion sections using the <kbd>get_post_meta</kbd> function. Here, we have only included one section. You can find three sections in the source code.</p>
<div class="packt_infobox">We have fixed the accordion sections to three, to simplify the development. Ideally, we should allow administrators to dynamically add an unlimited number of sections for accordions.</div>
<p>Finally, we load a custom template for the input fields of the accordion sections. The template for the accordion meta boxes can be found inside the <kbd>accordion-meta.php</kbd> file in the <kbd>templates</kbd> directory.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This template is similar to the one used for the <kbd>Properties</kbd> post type, and hence it's self-explanatory. However, you may notice the use of the following line of code instead of the code for text areas:</p>
<pre>&lt;td&gt;&lt;?php wp_editor( $wqkm_tab_1, 'wqkm_tab_1' ); ?&gt;&lt;/td&gt;</pre>
<p>We could have used text area fields for the accordion section. However, these sections may contain a considerable amount of HTML, and hence using a text area can be difficult. As a solution, we used the <kbd>wp_editor</kbd> function that generates the WordPress content editor field with all the formatting. We have to pass the default content and the ID of the content editor. Now we can use the WordPress rich content editor to add content to the accordion sections.</p>
<p>We need to save the section data to complete the data capturing process for accordions. The saving process is implemented using the <kbd>save_post</kbd> action and the implementation is similar to the property details saving process. The only difference is the use of <kbd>wp_kses_post</kbd> function to filter the section content generated by the <kbd>wp_editor</kbd> function. You can refer to the source code for the implementation of the section saving process inside the <kbd>WQKM_UI_Components</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing accordion content</h1>
                </header>
            
            <article>
                
<p>We already identified the importance of shortcodes for adding UI elements to posts or pages. Therefore, we will be using another shortcode to prepare the content for the accordion. Let's add the following code to the implementation of the accordion shortcode:</p>
<pre>add_shortcode( 'wqkm_accordian', array( $this, 'display_accordian') ); <br/>public function display_accordian( $atts, $content ){<br/> $sh_attr = shortcode_atts( array( 'id' =&gt; '0' ), $atts );<br/> extract($sh_attr);<br/><br/> $display = '&lt;div id="accordion"&gt;';<br/> if( trim( get_post_meta( $id, '_wqkm_tab_1' , true ) ) != '' ){<br/>   $display .= '&lt;h3&gt;'.get_the_title( $id ).'&lt;/h3&gt;';<br/>   $display .= '&lt;div&gt;&lt;p&gt;'.get_post_meta( $id, '_wqkm_tab_1' , true ).' &lt;/p&gt; &lt;/div&gt;';<br/> }<br/><br/> // other fields<br/> $display .= '&lt;/div&gt;';<br/> return $display;<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span>Here's what the previous code does:</span></p>
<ol>
<li>We have added a new shortcode called <kbd>wqkm_accordian</kbd> to the constructor of the <kbd>WQKM_UI_Components</kbd> class. We used custom post types to allow the creation of unlimited accordions, and hence we need a way to identify each accordion. So, we use the post ID as a shortcode attribute to identify the accordion.</li>
<li>Next, we generate the content sections of accordion by loading the data using the ID attribute.</li>
<li>Here, we have used the section title and the section content for each section inside a main container. This is the required structure for the chosen accordion library. You will have to find the element structure in case you choose different library for the implementation.</li>
<li>Finally, we return the output from the shortcode with accordion sections.</li>
</ol>
<p>Now you can create and add an accordion to a post or page using the necessary ID. However, like the image slider, you will just see a bunch of HTML sections displayed on browser. To enable the accordion functionality, we need to register the necessary scripts and styles inside the <kbd>load_scripts</kbd> function of the main class, as shown in the following code:</p>
<pre>wp_register_style('wqkm-jquery-ui-style', WQKM_PLUGIN_URL . 'css/jquery-ui.css', false, null);<br/>wp_register_script( 'wqkm-accordion', WQKM_PLUGIN_URL . 'js/wqkm-accordion.js', array('jquery','jquery-ui-accordion') );</pre>
<p>First, we have downloaded and added the <kbd>jQuery UI CSS</kbd> file to our plugin, as it's not provided within the WordPress core. Then, we have added a custom script called <kbd>wqkm-accordion.js</kbd>, with jQuery and jQuery UI accordion scripts as dependencies. The jQuery UI component libraries are available within the WordPress core, and hence we can directly call the script handle instead of registering the script separately. Then, we can add the following code to the shortcode function to enqueue the files:</p>
<pre>wp_enqueue_style('wqkm-jquery-ui-style');<br/>wp_enqueue_script('wqkm-accordion');</pre>
<p>We have the accordion script and style included within the shortcode. Finally, we have to initialize the accordion by adding the following initialization code to the <kbd>wqkm-accordion.js</kbd> file:</p>
<pre>jQuery(document).ready(function($) {<br/>  $( "#accordion" ).accordion({ collapsible: true, active: false, heightStyle: "content"   }); <br/>});</pre>
<p>The accordion is initialized using the ID of the main container we created for the shortcode output. This may vary based on the accordion library of your choice. Now we have completed the accordion integration process, and your accordion should look similar to the following screenshot:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-263 image-border" src="assets/7b31dcb2-cbcf-4022-bbe7-055cb270108b.png" style="width:40.42em;height:20.17em;"/></div>
<p>As you can see, we can use these UI components in a limited space to display a large amount of contents.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Steps for integrating UI components</h1>
                </header>
            
            <article>
                
<p>Up to this point, we looked at two implementations for integrating the jQuery slider and accordion UI components using different data-capturing techniques. The implementation may vary based on the type of UI component and its functionality. However, the basic process is similar for most of the common UI components. So, let's summarize the keys for integrating any UI component with WordPress:</p>
<ol>
<li><strong>Identify component data</strong>: Each UI component works on existing data or elements. So, we need to identify the data needed to use each UI component and the method for storing this data.</li>
<li><strong>Generate component output</strong>: In this step, we have to use the captured data, process it, and generate the HTML output needed to enable the features of a UI component. Usually, we use a reusable component such as a shortcode or widget to add and generate the output for UI components. </li>
</ol>
<ol start="3">
<li><strong>Include component libraries</strong>: Most UI components generate their features by applying JavaScript or CSS to the generated output. These features of the component generally come as an open source library. So, in this step, we need to all the necessary scripts and styles for the component, along with the necessary settings. In this process, we use <kbd>wp_register_style</kbd> and <kbd>wp_register_script</kbd> functions to include these resources by adding them inside plugins or themes. Then, you can enqueue them conditionally within the main class or inside the UI component generation function.</li>
<li><strong>Passing script data</strong>: Some of the UI element libraries directly apples CSS or JavaScript features on the generated output. However, some element scripts require certain data or settings to initialize the element. In such cases, we have to pass the necessary data to necessary scripts using the <kbd>wp_localize_script</kbd> function.</li>
<li><strong>Initialize the element</strong>: Once necessary libraries and HTML output is ready, we can initialize the element by using the initialization function of these libraries. These initializations generally takes one to a few lines of code. Usually, we use a CSS class or HTML element ID on the generated output for this initialization.</li>
</ol>
<p>Once these steps are completed, you will see the interactive features or styles in your UI element. This is the general process for the most common UI elements. However, there may be exceptions that require a different process to initialize the UI element.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simplifying development with page builders</h1>
                </header>
            
            <article>
                
<p><strong>Page builder</strong> is a set of components that simplifies the process of content creation or building the features of the site. These components allow developers to build complex interfaces in super-quick time by choosing and configuring built-in components. Page builders were initially used for simplifying content creation with pre-built design elements. However, page builders have now evolved into a state where we can use the existing components to add advanced site features such as form management, searchable google maps, parallax images, and videos.</p>
<p>Until recently, developers used the page builders included in themes, as well as free and premium page builder plugins. WordPress has introduced a block-based content builder called<span> </span><strong>Gutenberg</strong>. At this stage, Gutenberg editor supports content editing with a basic set of elements. Currently, it's nowhere near the features offered by popular page builders such as Elementor, Beaver Builder, and Visual Composer. However, the future seems bright, as the WordPress team is backing the Gutenberg editor by making it a default core feature. So, we will soon see more powerful features of the Gutenberg editor, along with the features offered by other page builders.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the features of page builders</h1>
                </header>
            
            <article>
                
<p>As we discussed, page builders offer a wide range of components that can be dragged or assigned to any post, page, or custom post type. However, many of these page builders provide advanced features beyond using basic built-in components. So, it's important to understand these features to use the existing components, as well as making your solutions integrate with page builders. Let's take a look at the main features offered by modern page builders:</p>
<ul>
<li><strong>Backend and frontend editing</strong>: Usually, we edit or build the site interfaces using the backend content editor, and hence we have to switch to frontend to view the changes. Most page builders provide frontend editing, allowing previews in real time and adjusting them instantly. Also, there is a backend editor, if you want to work with other backend features.</li>
<li><strong>Built-in templates</strong>: Many page builders provide built-in template designs by using the existing components. So, the developers can use these templates designed for common requirements and adjust them as needed without writing a single line of code.</li>
<li><strong>Advanced styling</strong>: Each component allows various styling options such as margins, paddings, colors and so on. So, you can fine tune the design without going into the code.</li>
<li><strong>Responsive design</strong>: This is a must in modern development to cater for different devices, such as personal computers, mobiles, tabs, and so on. Usually, we have to spend lot of time making our designs fully responsive. Page builder structure and components are responsive by default. So, you don't have to do anything to make the content responsive as long as you follow the proper coding standards for your own elements.</li>
</ul>
<p>As you can see, page builder provides a lot of power for building the content and design of your site. However, these powerful features also come with some limitations. Some of these page builders are completely dependent on shortcodes, and hence you will be locked into the plugin. Also, you might experience performance issues when using some complex features of page builders. Therefore, you need to be responsible with choosing the proper page builder and the features.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing components for page builders</h1>
                </header>
            
            <article>
                
<p>Most popular page builders come with a wide range of built-in components as well as additional components using addons. So, we can use the existing components to build general purpose WordPress sites. However, when developing advanced applications or sites with custom requirements, the default functionality of these components may not be sufficient. In such cases, we have to build our own page builder components to provide the necessary functionality. We can always create shortcodes and ask the clients to use them inside the page builder components. But building our components simplifies the process considerably for the client, and hence we have to build components whenever necessary.</p>
<p>Major page builders provides an API or guide for developing components for their plugin. The technique varies for each page builder. So, you need to use the documentation to understand and develop a component for each page builder. Developing a component from scratch with the necessary explanations is beyond the scope of this chapter. However, we will explore the basic steps of component creation using the Elementor page builder as the example. Let's take a look at the main steps for building a page builder component:</p>
<ul>
<li>Each page builder identifies its components as modules, widgets, blocks, and so on. So, there should be a way to register new components for the page builder. Elementor uses<span> the </span><kbd>Widget_Base</kbd><span> </span>class and<span> </span><kbd>register_widget_type</kbd><span> </span>function to register new components. The other page builders offer similar techniques.</li>
<li>After registering the component, you need to specify the input fields for capturing component data. Most page builders provide different types of input fields to capture and save the data for the component. Elementor provides a function called<span> </span><kbd>add_control</kbd><span> </span>on the<span> </span><kbd>Widget_Base</kbd><span> </span>class, supporting over 30 different control types. The other page builders will have similar functions to add input fields to different field types, as well as different data-storing mechanisms.</li>
<li>Finally, we need to provide the output of the component by building the HTML code or executing an existing shortcode. Elementor provides a function called<span> </span><kbd>render</kbd><span> </span>for retrieving the saved component data and displaying the output. The other page builders should have a similar method, with a similar name.</li>
</ul>
<p>We have used these steps and built a slider component for the Elementor page builder. You can find the code for this addon inside the<span> </span><kbd>wpquick-elementor-components</kbd><span> </span>directory of the source code for this chapter. The following screenshot previews the component generated by the addon with settings:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-264 image-border" src="assets/09809233-6d65-4b42-adf3-e8d1dbd35719.png" style="width:103.83em;height:46.00em;"/></div>
<p>Elementor is one of the most popular and rising page builders at this stage. You can access the documentation at <a href="https://developers.elementor.com/creating-an-extension-for-elementor/">https://developers.elementor.com/creating-an-extension-for-elementor/</a> and use the addon code for understanding the step. The process for other page builders will be similar, with the support of plugin-specific component creation functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simplifying and customizing admin features</h1>
                </header>
            
            <article>
                
<p>We have to use the core features as much as possible to get the maximum benefits of using WordPress for site development. This includes the use of frontend theme features, as well as the existing backend features, that mainly focuses on post-related functionality. So, it's obvious that developers need to customize these features to suit the requirements of each website. In this section, we are going to look at several customizations of commonly used backend features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating custom dashboard widgets</h1>
                </header>
            
            <article>
                
<p>We had a brief introduction to the <strong>Dashboard Widget API</strong> in <a href="e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml" target="_blank">Chapter 6</a>, <em>Practical Usage of WordPress APIs</em>. Basically, a <em>dashboard</em> is a collection of widgets built for administration purposes. Unlike frontend theme widgets, we don't have an interface for adding or removing admin dashboard widgets. So, we have to build custom solutions to build new dashboard widgets as well as remove the existing ones. In this section, we are going to look at the process of creating a basic dashboard widget. </p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Registering and building dashboard widgets</h1>
                </header>
            
            <article>
                
<p>First, we have to register the dashboard widget by using the <kbd>wp_dashboard_setup</kbd> action, instead of the <kbd>widgets_init</kbd> we used on the frontend widgets. Consider the following code for the widget registration process:</p>
<pre>add_action( 'wp_dashboard_setup', array( $this, 'dashboard_widgets' ) );<br/>public function dashboard_widgets() {<br/>  wp_add_dashboard_widget( 'wqkm_post_attachments', __('Post Attachments','wqkm'), array( $this, 'post_attachments_widget' ) );<br/>}</pre>
<p>Inside the callback function, we use the <kbd>wp_add_dashboard_widget</kbd> function to register a new widget. The parameters for this function contain a unique widget ID, widget title, and the callback function. Then, we have to implement the function to display the content for the widget, as shown in the following code:</p>
<pre>public function post_attachments_widget() {<br/>  echo do_shortcode('[wpquick_attachment_posts]');<br/>}</pre>
<p>Here, we have simplified the process by using a shortcode we developed in earlier chapters. Basically, we have a dashboard widget in fewer than 10 lines of code. This process is simpler compared to the frontend dashboard widget creation process.</p>
<p>The default dashboard widgets are mostly suitable for blogs. In many circumstances, we have to remove the existing widgets and add custom widgets to cater for advanced site-specific business requirements. In custom sites, dashboard widgets are frequently used for displaying the site statistics, reports, or features that need to be executed on a regular basis, without visiting individual screens. You can try the existing plugins with dashboard widgets to understand the usage. WooCommerce, bbPress, and Easy Digital Downloads are some of the popular plugins with built-in custom dashboard widgets.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customizing backend list tables</h1>
                </header>
            
            <article>
                
<p>WordPress provides backend list tables for the main content types. We discussed the features of list tables in <a href="1a709b5f-c476-41f9-bc13-eb5f0541abaa.xhtml" target="_blank">Chapter 7</a>, <em>Managing Custom Post Types and Processing Forms</em>, on custom post types. The default features provide data list tables for posts, pages, users, and comments, as well as all the registered custom post types. Also, we can extend the core class used for list tables and create our own custom data list tables. So, it's important to know the existing features as well as customizable features of backend list tables. In this section, we are going to look at the some of the common customizations on the backend user list. Let's get started.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and executing custom bulk actions</h1>
                </header>
            
            <article>
                
<p>The WordPress list tables contains a dropdown called <span class="packt_screen">Bulk Actions</span> in the top left-hand section of the list. This feature is used to modify multiple records in the table with a single predefined event. We have to choose one or more records, select an action from the <span class="packt_screen">Bulk Actions</span> dropdown, and click the <span class="packt_screen">Apply</span> button to complete the process. This is a very useful feature when you want to modify bulk records for custom features.</p>
<p>The WordPress core actions can be used to modify the <span class="packt_screen">Bulk Actions</span> dropdown and to include custom actions for our projects. Let's add the following action to the constructor of the <kbd>WQKM_Admin_Features</kbd> class for understanding the process of using custom actions:</p>
<pre>add_filter( 'bulk_actions-users', array( $this, 'user_actions' ) );</pre>
<p>This action is used to filter the actions for the users list table. The filter consists of the <kbd>bulk_action</kbd>-prefix followed by the screen name. So, you can use the same action for other core list tables by replacing users with the screen name for the list. Let's take a look at the implementation of the custom action:</p>
<pre>public function user_actions($bulk_actions) { <br/>  $bulk_actions['wpquick_featured_user'] = __('Mark Featured Profile','wqkm'); <br/>  return $bulk_actions;<br/>}</pre>
<p>In this code, we are adding a custom action to the default backend user list by modifying the existing bulk actions list. We have to use a unique slug as the array key for this action and define the label as the array value. In this scenario, we are building an action that allows us to mark certain users as <span class="packt_screen">Featured Users</span>. Now you will see a new option in the <span class="packt_screen">Bulk Actions</span> dropdown for handling user-featured status.</p>
<p>Once the records and action is selected, we can click the <span class="packt_screen">Apply</span> button to make the modifications to the selected records. So, we need to implement the action by adding the following action to the constructor of the class:</p>
<pre>add_filter( 'handle_bulk_actions-users', array( $this,'users_page_loaded'),10,3);</pre>
<p>In this code, we have used <kbd>handle_bulk_actions-</kbd> filter followed by the screen name for user list table. So, let's take a look at the implementation of the custom action:</p>
<pre>public function users_page_loaded($redirect_to,$doaction,$featured_users ){<br/>  if ( $doaction !== 'wpquick_featured_user' ) {<br/>    return $redirect_to;<br/>  }<br/><br/>  foreach ($featured_users as $featured_user) {<br/>    update_user_meta($featured_user, 'wqkm_featured_status', 'ACTIVE');<br/>  }<br/><br/>  $redirect_to = add_query_arg( 'bulk_featured_users', count( $featured_users ), $redirect_to );<br/>  return $redirect_to;<br/>}</pre>
<p><span>Here's what the previous code does</span>:</p>
<ol>
<li>This function automatically receives three parameters for the redirect URL, the action name, and the list of IDs of the records to be modified.</li>
<li>First, we check the action and make sure our code executes only for the <kbd>wpquick_featured_user</kbd> action.</li>
<li>Next, we loop through the list of selected user IDs and modify the value to mark the user as a featured user. We can use a different action or toggle the same action to remove the featured status as well.</li>
<li>Finally, we redirect the user to the list by adding a custom argument to the URL called <kbd>bulk_featured_users</kbd>. This value will be used to filter the request and display a custom message using the <kbd>bulk_admin_notices</kbd> function in the source code.</li>
</ol>
<p>Now we have a working custom action for the user list. You can test the feature by adding featured status to some of the users and confirming it by checking the database values. This is a simple way of modifying or applying custom data to multiple records for custom requirements. We can't use input fields for these actions, and hence the action should have a fixed feature with predefined values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding custom list columns</h1>
                </header>
            
            <article>
                
<p>The data list tables contains default set of columns, and these columns vary based on the type of the list. In the previous section, we changed the featured status of the user. However, we had to use the database to check the value. Instead, we can display such important information on the data list table by using custom columns. So, in this section, we are going to look at the process of adding custom columns to the default users list as well as identifying the necessary hooks for other lists. Let's start by adding the following filter and action to the constructor of <kbd>WQKM_Admin_Features</kbd> class:</p>
<pre>add_filter( 'manage_users_columns', array( $this,'manage_user_custom_columns') );<br/>add_action( 'manage_users_custom_column', array( $this, 'manage_user_custom_column_values' ), 10, 3 );</pre>
<p class="mce-root"/>
<p>The <kbd>manage_users_columns</kbd> filter is used to modify or remove existing columns as well as to add new columns to the user list. The following code previews the implementation to include the featured status as a column:</p>
<pre>public function manage_user_custom_columns( $column ) {<br/> $column['featured_user_status'] = __('Featured Status','wqkm');<br/> return $column;<br/>}</pre>
<p>Now you should see an additional column in the user list without any data. The next step is to display the column data for each user. We have to use the <kbd>manage_users_custom_column</kbd> action to provide the data for our custom column. Let's take a look at the implementation of the callback function:</p>
<pre>public function manage_user_custom_column_values( $val, $column_name, $user_id) {<br/>  $featured_user_status = get_user_meta( $user_id ,'wqkm_featured_status', TRUE);<br/>  $featured_user_status = ( $featured_user_status == 'ACTIVE') ? __('ACTIVE','wqkm') : __('INACTIVE','wqkm');<br/> <br/>  switch ($column_name) {<br/>    case 'featured_user_status' :<br/>      return $featured_user_status;<br/>      break;<br/>    default:<br/>      return $val;<br/>      break;<br/>  }<br/>}</pre>
<p>This function accepts three parameters for the column value, column name, and the user ID. We can use these parameters to get the custom column value for the selected users. Here, we use <kbd>get_user_meta</kbd> function as we stored the data on <kbd>wp_usermeta</kbd> table. We can also store these values and display them using custom tables. Next, we use a <kbd>switch</kbd> statement to return the value based on the column. It's important to use the <kbd>default</kbd> case and return the default value, to be compatible with other plugins. Now you should see the custom column in the user list with the custom values for each user.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sorting custom column values</h1>
                </header>
            
            <article>
                
<p>The default list tables provides sorting capabilities for the first column and one or more from the remaining columns. However, these are built-in columns provided by the WordPress core features. So, we need the ability to sort custom column values to effectively use and filter the custom data. WordPress provides a built-in filter for specifying sortable columns. Let's consider the following filter and its implementation:</p>
<pre>add_filter('manage_users_sortable_columns', array($this,'users_sortable_columns'));<br/>public function users_sortable_columns( $columns ) {<br/>  $columns['featured_user_status'] = 'featured_user_status';<br/>  return $columns;<br/>}</pre>
<p>The filter needs to be added inside the constructor of the class. This filter accepts the list of existing sortable columns as a parameter. Here, we have added the key of our custom column to the sortable columns array and return the list. Now you should be able to see a link in custom column to change the sorting value. The final step of the process is to change the default query and enable sorting on the custom column. Let's consider the following action and its implementation:</p>
<pre>add_action( 'pre_user_query', array( $this, 'users_orderby_filters' ) );<br/>public function users_orderby_filters( $userquery ){<br/>  global $wpdb;<br/>  if( 'featured_user_status' == $userquery-&gt;query_vars['orderby'] ) {<br/>    $userquery-&gt;query_from .= " LEFT OUTER JOIN $wpdb-&gt;usermeta AS wpusermeta ON ($wpdb-&gt;users.ID = wpusermeta.user_id) ";<br/>    $userquery-&gt;query_where.= " AND wpusermeta.meta_key='featured_user_status' ";<br/>    $userquery-&gt;query_orderby = " ORDER BY wpusermeta.meta_value ".( $userquery-&gt;query_vars["order"] == "ASC" ? "asc " : "desc " ); <br/>  }<br/>}</pre>
<p>Let's understand the implementation of this function using the following steps:</p>
<ol>
<li>We can use <kbd>pre_user_query</kbd> action to modify the default query, just before the execution. The <kbd>WP_User_Query</kbd> object is passed as a parameter to this function.</li>
<li>Next, we check the <kbd>orderby</kbd> clause of the query using the <kbd>query_vars</kbd> array to make sure our custom code only executes on <kbd>featured_user_status</kbd> column.</li>
<li>Then, we have to modify the query, staring with the <kbd>join</kbd> statement on the <kbd>from</kbd> clause to include the <kbd>usermeta</kbd> table. The modified <kbd>where</kbd> clause makes sure that sorting is only applied to the values of the <kbd>featured_user_status</kbd> column.</li>
</ol>
<ol start="4">
<li>Finally, we change the <kbd>orderby</kbd> clause to order the list using meta values of the <kbd>featured_user_status</kbd> column.</li>
</ol>
<p>Now the process is complete, and you should be able to click the column title to sort the users in both ways using the featured status. The following screenshot previews the features we added to the user list:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-265 image-border" src="assets/4e0c602e-5cd3-4cd6-8786-a6ea8f46edf8.png" style="width:89.33em;height:37.17em;"/></div>
<p>You can follow this technique with the necessary filtering to manage more columns on the user list.</p>
<p>We looked at the list table customization for the backend user list. Similarly, we can apply the same technique to customize the columns of other WordPress list tables using necessary actions and filters. </p>
<div class="packt_infobox"><span>In most scenarios, we need to customize posts and custom post types lists to include custom columns. We have to use </span><kbd>manage_edit-{post_type}_columns</kbd><span> filter to define the custom columns and the </span><kbd>manage_{post_type}_posts_custom_column</kbd><span> filter to add the values for the custom columns. Then, we can use </span><kbd>manage_edit-{post_type}_sortable_columns</kbd><span> filter to define sortable columns and use </span><kbd>pre_get_posts</kbd><span> action to modify the query for sorting.</span></div>
<p>So, we need to use these actions and filters whenever necessary to display additional data in list tables and avoid the time-consuming visits to the edit section to check the values.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>The main purpose of using WordPress is to simplify the development process. So, we need to understand the process of customizing important backend features. Also it's important to use modern user interface components to provide all the important in limited space using attractive techniques. We began the chapter by understanding the importance of the integration of UI components. So, we integrated jQuery Slider and Accordion while using two different data-capturing methods. We also looked at the importance of page builders in modern development and the steps for developing custom components for page builders. Next, we moved on to customizing admin features by building a simple dashboard widget. Finally, we looked at the process of adding custom features to built-in WordPress list tables.</p>
<p>In <a href="1690ebbf-249c-4892-81db-098b6a9050f5.xhtml" target="_blank">Chapter 9</a>, <em>Enhancing Security, Performance, and Maintenance</em>, we will be completing the content for this book by looking at the non-functional aspects of development, such as security, performance, testing, and maintenance.</p>


            </article>

            
        </section>
    </body></html>