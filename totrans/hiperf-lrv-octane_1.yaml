- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Understanding the Laravel Web Application Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Laravel Web 应用程序架构
- en: This book is for **Laravel** developers who would like to make or design their
    Laravel web application in a more scalable way and make it more performant.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是为希望以更可扩展的方式设计和构建他们的 Laravel Web 应用程序，并使其更高效性能的 **Laravel** 开发者而写的。
- en: This book aims to provide you with knowledge, suggestions, and explanations
    on how to improve the software architecture of a web application, starting from
    a typical PHP web application architecture to a more scalable and performant architecture.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书旨在为您提供有关如何改进 Web 应用程序软件架构的知识、建议和解释，从典型的 PHP Web 应用程序架构到更可扩展和高效架构。
- en: It provides a 360-degree overview of what it takes to design and build a performant
    application with **Laravel Octane**. We’ll see why Laravel Octane is suitable
    for designing and building a performant application. The book also covers the
    different tools used by Laravel Octane, such as **Open Swoole** and **RoadRunner**,
    and lists and describes the various features and differentiating elements. But
    the most important thing is to enable you to understand why and when to use Open
    Swoole or RoadRunner.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了使用 **Laravel Octane** 设计和构建高性能应用程序所需的所有内容的 360 度概览。我们将看到为什么 Laravel Octane
    适合设计和构建高性能应用程序。这本书还涵盖了 Laravel Octane 使用的不同工具，例如 **Open Swoole** 和 **RoadRunner**，并列出并描述了各种功能和差异化元素。但最重要的是，它能够让你理解为什么以及何时使用
    Open Swoole 或 RoadRunner。
- en: But before starting, why use Laravel Octane?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但在开始之前，为什么使用 Laravel Octane？
- en: Laravel Octane is a tool that allows us to access some functionality and features
    exposed by the two application servers we just mentioned.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel Octane 是一个工具，允许我们访问我们刚才提到的两个应用程序服务器暴露的一些功能和特性。
- en: One of the benefits of Laravel Octane is the huge improvement in the response
    times to HTTP requests by clients such as web browsers. When we develop a Laravel
    application, we use an important software layer implemented by the framework.
    This software layer needs time and resources to start. Even if we talk about only
    a few resources and a short amount of time, this repeated action for each request,
    especially in a context where there are many requests, can be a problem. Or rather,
    its optimization could bring enormous benefits.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel Octane 的一个好处是显著提高了客户端（如网页浏览器）对 HTTP 请求的响应时间。当我们开发 Laravel 应用程序时，我们使用框架实现的一个重要软件层。这个软件层需要时间和资源来启动。即使我们只谈论少量资源和很短的时间，这种对每个请求的重复操作，尤其是在存在许多请求的环境中，也可能成为一个问题。或者更确切地说，它的优化可以带来巨大的好处。
- en: 'Laravel Octane, through application servers, does just that: optimizes the
    process of starting the framework, which typically happens for each individual
    request. We will see in detail how this is done; essentially, the objects and
    everything that the framework needs are started and allocated to the start of
    the application server, and then the instances are made available to the various
    workers. **Workers** are the processes that are initiated to serve the requests.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用程序服务器，Laravel Octane 正是这样做：优化了框架启动的过程，这通常发生在每个单独的请求中。我们将详细看到这是如何实现的；本质上，框架需要的对象和一切都被启动并分配到应用程序服务器的开始处，然后实例被提供给各个工作者。**工作者**是启动来服务请求的进程。
- en: Another reason why it is interesting to evaluate the adoption of Laravel Octane
    in your Laravel web application is that by using an application server such as
    Swoole, you can access those features implemented by Swoole.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的原因是评估在您的 Laravel Web 应用程序中采用 Laravel Octane，是因为通过使用像 Swoole 这样的应用程序服务器，您可以访问
    Swoole 实现的功能。
- en: The functions are, for example, the advanced mechanisms of the cache driver,
    shared storage for sharing information between the various workers, and the execution
    of tasks in parallel.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 功能，例如，缓存驱动程序的先进机制、在各个工作者之间共享信息的共享存储以及并行执行任务。
- en: This is a totally new concept to the classic PHP developer who typically does
    not have an immediate functionality available in the PHP core for the parallelization
    of processes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于典型的 PHP 开发者来说是一个全新的概念，他们通常没有在 PHP 核心中立即可用的功能来并行化进程。
- en: This chapter will introduce you to the Laravel ecosystem and explore what Laravel
    Octane is.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍 Laravel 生态系统，并探讨 Laravel Octane 是什么。
- en: This chapter aims to introduce you to the application server approach, in which
    more workers cooperate to manage multiple requests. Understanding the behavior
    under the hood allows the developer to avoid some mistakes, especially on shared
    resources (objects and global states) across the worker. This is important because
    the classical PHP approach is to have one dedicated thread to manage one request.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在向您介绍应用服务器方法，在这种方法中，更多的工作者协同工作以管理多个请求。了解底层的操作行为使开发者能够避免一些错误，尤其是在工作者之间共享资源（对象和全局状态）时。这很重要，因为经典的
    PHP 方法是使用一个专门的线程来管理一个请求。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring the Laravel ecosystem
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Laravel 生态系统
- en: Understanding the request lifecycle
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解请求生命周期
- en: Getting to know the application server
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解应用服务器
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to run the code and tools shown in this book, you must have the **PHP
    engine** installed on your machine. It is recommended that you have a recent version
    of PHP installed (at least *8.0*, released in November 2020).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行本书中展示的代码和工具，您必须在您的机器上安装 **PHP 引擎**。建议安装较新的 PHP 版本（至少 *8.0*，2020 年 11 月发布）。
- en: Also, in order to easily install additional tools, it is recommended that you
    have Homebrew installed if you use macOS. In the case of GNU/Linux systems, it
    will be sufficient to resort to using the package manager of the distribution
    used, and in the case of Windows systems, the advice is to have a virtual environment,
    for example, with Docker.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了方便安装额外的工具，如果你使用 macOS，建议安装 Homebrew。在 GNU/Linux 系统中，将足够使用所使用的发行版的包管理器，而在
    Windows 系统中，建议使用虚拟环境，例如 Docker。
- en: In the current chapter, some commands and source code will be shown, simply
    to share some concepts. In subsequent chapters, especially the second chapter
    about RoadRunner and the third chapter about Open Swoole, the installation of
    each package and tool will be addressed step by step.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将展示一些命令和源代码，只是为了分享一些概念。在随后的章节中，特别是关于 RoadRunner 的第二章和关于 Open Swoole 的第三章，将逐步介绍每个包和工具的安装。
- en: There are those who, regardless of their operating system, prefer to maintain
    a “clean” installation by resorting to using Docker regardless of the host operating
    system. Where the next chapters deal with the installation of operating system-dependent
    tools, the different methods will be highlighted depending on the system in use.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人，无论使用什么操作系统，都更喜欢通过使用 Docker 来维护一个“干净”的安装，无论主机操作系统是什么。在接下来的章节中，将处理操作系统依赖工具的安装，不同的方法将根据所使用的系统进行突出显示。
- en: 'The source code and the configuration files of the examples described in the
    current chapter are available here: [https://github.com/PacktPublishing/High-Performance-with-Laravel-Octane/tree/main/octane-ch01](https://github.com/PacktPublishing/High-Performance-with-Laravel-Octane/tree/main/octane-ch01)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当前章节中描述的示例的源代码和配置文件可在以下位置找到：[https://github.com/PacktPublishing/High-Performance-with-Laravel-Octane/tree/main/octane-ch01](https://github.com/PacktPublishing/High-Performance-with-Laravel-Octane/tree/main/octane-ch01)
- en: Exploring the Laravel ecosystem
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Laravel 生态系统
- en: Laravel is a great framework in the PHP ecosystem that helps developers to build
    web applications quickly and reliably.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 是 PHP 生态系统中的一个优秀框架，它帮助开发者快速、可靠地构建 Web 应用程序。
- en: It includes, as dependencies, some great tools from the PHP ecosystem, such
    as **Symfony** packages, and some other solid and mature packages such as **Monolog**
    for logging, **Flysystem** for accessing files and storage, and **CommonMark**
    for managing Markdown format.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括一些 PHP 生态系统的优秀工具作为依赖项，例如 **Symfony** 包，以及一些其他坚实且成熟的包，如用于日志记录的 **Monolog**，用于访问文件和存储的
    **Flysystem**，以及用于管理 Markdown 格式的 **CommonMark**。
- en: From the Symfony world, Laravel includes packages such as `Symfony/routing`
    to manage routing, and `http-foundation` and `http-kernel` to manage HTTP communication.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Symfony 世界来看，Laravel 包括用于管理路由的 `Symfony/routing` 包，以及用于管理 HTTP 通信的 `http-foundation`
    和 `http-kernel` 包。
- en: All this is just to say that Laravel uses the best parts of the PHP ecosystem,
    puts them together, and provides tools, helpers, classes, and methods to simplify
    the usage of all the tools from the developer’s perspective.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些只是为了说明 Laravel 使用了 PHP 生态系统的最佳部分，将它们组合在一起，并为开发者提供工具、辅助函数、类和方法，以简化所有工具的使用。
- en: In addition, Laravel is more than a framework. Laravel is an ecosystem.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Laravel 不仅仅是一个框架。Laravel 是一个生态系统。
- en: Laravel also provides applications and services that are integrated with the
    framework.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 还提供与框架集成的应用程序和服务。
- en: 'For example, Laravel provides the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Laravel 提供以下内容：
- en: '**Cashier**: For integration with **Stripe** and **Paddle** for the payment
    and subscription process.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收银员**：用于与 **Stripe** 和 **Paddle** 集成，处理支付和订阅流程。'
- en: '**Breeze**, **Jetstream**, **Sanctum**, and **Socialite**: For managing authorization,
    authentication, the social login integration process, and exposing protected APIs.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Breeze**、**Jetstream**、**Sanctum** 和 **Socialite**：用于管理授权、身份验证、社交登录集成流程和公开受保护的
    API。'
- en: '**Dusk** and **Pest**: For testing.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黄昏** 和 **害虫**：用于测试。'
- en: '**Echo**: For broadcasting events in real time.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Echo**：用于实时广播事件。'
- en: '**Envoyer**, **Forge**, and **Vapor**: For server or serverless management
    and to manage the deployment process.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Envoyer**、**Forge** 和 **Vapor**：用于服务器或无服务器管理和部署流程管理。'
- en: '**Mix**: For compiling **JavaScript** and **CSS** through a webpack configuration
    fully integrated with the Laravel frontend.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mix**：通过完全集成 Laravel 前端的 webpack 配置编译 **JavaScript** 和 **CSS**。'
- en: '**Horizon**: A web user interface for monitoring queues based on **Redis**.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Horizon**：基于 **Redis** 的队列监控的 Web 用户界面。'
- en: '**Nova**: An administrator panel builder for Laravel applications.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nova**：Laravel 应用程序的管理员面板构建器。'
- en: '**Sail**: A local development environment based on **Docker**.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sail**：基于 **Docker** 的本地开发环境。'
- en: '**Scout**: A full-text search engine, backed by providers such as **Algolia**,
    **Meilisearch**, or simply by the **MySQL** or **PostgreSQL** database.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Scout**：一个全文搜索引擎，由 **Algolia**、**Meilisearch** 或简单的 **MySQL** 或 **PostgreSQL**
    数据库提供支持。'
- en: '**Spark**: A boilerplate solution for managing billing/subscription in your
    application.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spark**：用于管理应用程序中的计费/订阅的样板解决方案。'
- en: '**Telescope**: UI module for showing debugging and insights.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Telescope**：用于显示调试和洞察的 UI 模块。'
- en: '**Valet**: A macOS-specific bundle of applications configured for running the
    PHP application. It has dependencies with **nginx**, **PHP**, and **Dnsmasq**.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Valet**：为运行 PHP 应用程序配置的 macOS 特定应用程序包。它依赖于 **nginx**、**PHP** 和 **Dnsmasq**。'
- en: '**Octane**: For improving performance and optimizing resources.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Octane**：用于提高性能和优化资源。'
- en: 'In this book, we will analyze the last tool in this list: Laravel Octane.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将分析此列表中的最后一个工具：Laravel Octane。
- en: 'We will go over the use of other tools within the Laravel ecosystem, such as
    Sail (for simplifying the installation process of a complete development environment),
    and Valet (for correctly setting up the local environment to run a web server
    and PHP). Also, Laravel Octane depends on important software that we will see
    in-depth throughout the book. Laravel Octane has strong requirements: it requires
    additional software such as Swoole or RoadRunner.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍 Laravel 生态系统内其他工具的使用，例如 Sail（用于简化完整开发环境的安装过程），以及 Valet（用于正确设置本地环境以运行 Web
    服务器和 PHP）。此外，Laravel Octane 依赖于本书中将深入探讨的重要软件。Laravel Octane 有严格的要求：它需要额外的软件，如
    Swoole 或 RoadRunner。
- en: But one step at a time.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但一步一个脚印。
- en: Before we delve into the tools and their configuration, it’s important to understand
    some basic mechanisms for managing **HTTP requests**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨工具及其配置之前，了解一些管理 **HTTP 请求** 的基本机制是很重要的。
- en: HTTP
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP
- en: HTTP is a protocol that defines rules, messages, and methods for fetching resources
    on the web, such as HTML documents (web pages) and assets. Clients (who require
    the resource) and servers (who serve the resource) communicate by exchanging messages.
    The client sends requests, and the server sends responses.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 是一种定义了在网络上获取资源（如 HTML 文档（网页）和资产）的规则、消息和方法的协议。客户端（需要资源的人）和服务器（提供资源的人）通过交换消息进行通信。客户端发送请求，服务器发送响应。
- en: One of the goals of the book is to empower you to improve the performance of
    your web applications by doing different things, starting with designing the architecture
    of the application, choosing and using the right tools, writing code, and finally,
    releasing the application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一个目标是通过做不同的事情来赋予你提升你网络应用程序性能的能力，从设计应用程序架构开始，选择并使用正确的工具，编写代码，最后发布应用程序。
- en: The tools we are going to analyze and use will do much of the work, but I think
    it is important to understand the underlying dynamics to have a good awareness
    of how the various tools work to enable you to configure, integrate, and use them
    to the best of their ability.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要分析和使用的工具将完成大部分工作，但我认为理解其背后的动态对于有一个良好的意识了解各种工具如何工作，以便您能够以最佳方式配置、集成和使用它们，这一点非常重要。
- en: Before we get deeper into the workings of Laravel Octane, let me take you through
    how servers typically deal with HTTP requests by explaining the HTTP request lifecycle.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨Laravel Octane的工作原理之前，让我通过解释HTTP请求的生命周期来向您展示服务器通常如何处理HTTP请求。
- en: Understanding the HTTP request lifecycle
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解HTTP请求生命周期
- en: 'There are a number of components involved in performing the HTTP request. The
    components are as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行HTTP请求的过程中涉及了许多组件。组件如下：
- en: '**Client**: This is where the request starts and the response ends (for example,
    the browser).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：这是请求开始和响应结束的地方（例如，浏览器）。'
- en: '**Network**: The requests and responses go through this and it connects the
    server and the client.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：请求和响应通过这个连接服务器和客户端。'
- en: '**Proxy**: This is an optional component that could perform some tasks before
    the request reaches the web server, such as caching, rewriting and/or altering
    the request, and forwarding the request to the right web server.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理（Proxy）**：这是一个可选组件，可以在请求到达Web服务器之前执行一些任务，例如缓存、重写和/或修改请求，并将请求转发到正确的Web服务器。'
- en: '**Web server**: This receives the request and is responsible for selecting
    the correct resource.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web服务器**：它接收请求并负责选择正确的资源。'
- en: '**PHP**: The language, or more generally in the case of server-side languages,
    the language-specific engine that is used and involved. In this case, the PHP
    interpreter is used. The PHP interpreter can be activated mainly in two ways:
    as a web server module or as a separate process. In the latter case, a technology
    called **FastCGI Process Manager** (**FPM**) is used. We will see how this mechanism
    works later in more detail. For now, it is useful to know that the web server
    somehow invokes the server-side language interpreter. By doing this, our server
    is able to interpret the language. If the invoked resource is a PHP-type file
    with the specific PHP syntax, the resource file requested is interpreted by the
    PHP engine. The output is sent back in the form of a response to the web server,
    the network, and then the browser.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PHP**：语言，或者更普遍地说，在服务器端语言的情况下，使用的特定语言引擎。在这种情况下，使用PHP解释器。PHP解释器可以通过两种主要方式激活：作为Web服务器模块或作为单独的进程。在后一种情况下，使用一种称为**FastCGI进程管理器（FPM）**的技术。我们将在稍后更详细地了解这种机制的工作原理。目前，了解Web服务器如何以某种方式调用服务器端语言解释器是有用的。通过这样做，我们的服务器能够解释语言。如果被调用的资源是具有特定PHP语法的PHP类型文件，则请求的资源文件将由PHP引擎解释。输出以响应的形式发送回Web服务器、网络，然后是浏览器。'
- en: '**Framework**: In the case that the application is written with PHP and a framework
    is used, as a developer, you can access classes, methods, and helpers to build
    your application faster.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架**：如果应用程序是用PHP编写的并且使用了框架，作为开发者，你可以访问类、方法和辅助工具来更快地构建你的应用程序。'
- en: The components are called sequentially in the HTTP request flow. The HTTP request
    starts from the browser, then goes through the network (optionally passing through
    via the proxy), until it reaches the web server that invokes the PHP engine and
    the framework is bootstrapped.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 组件在HTTP请求流中按顺序调用。HTTP请求从浏览器开始，然后通过网络（可选地通过代理），直到到达调用PHP引擎并引导框架的Web服务器。
- en: From a performance point of view, if you want to bring some improvement, you
    have to take some action or implement some solution depending on the elements
    of this architecture.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从性能的角度来看，如果你想要带来一些改进，你必须采取一些行动或根据这个架构的元素实现一些解决方案。
- en: For example, on the browser side, you could work on caching assets in the browser
    or on the optimization of your JavaScript code. On the networking side, one solution
    could be resource optimization, for example, reducing the weight of assets or
    introducing architectural elements such as a CDN. In the case of the web server,
    an effective first-level improvement could be to avoid loading the PHP engine
    for the static assets (non-PHP files).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在浏览器端，你可以处理浏览器中的缓存资源或优化你的JavaScript代码。在网络方面，一个解决方案可能是资源优化，例如，减少资源的重量或引入如CDN等架构元素。在Web服务器的情况下，一个有效的第一级改进可能是避免加载PHP引擎来处理静态资源（非PHP文件）。
- en: All such fine-tuning will be addressed in the final chapters, where we will
    deal with the configuration and optimization of production elements. Most of the
    book covers the optimization of the framework. For example, in *Chapters 2* and
    *3*, topics such as the use of Octane with tools such as Swoole and RoadRunner,
    which enable more efficient and effective loading of resources (shared objects
    and structures), are addressed. Other points of performance improvement on the
    framework side include the introduction of an asynchronous approach through the
    use of queuing systems (*Chapters 6* and *7*).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些微调将在最终章节中解决，我们将处理生产元素的配置和优化。本书的大部分内容涵盖了框架的优化。例如，在第2章和第3章中，讨论了使用Octane与Swoole和RoadRunner等工具，这些工具能够更高效、更有效地加载资源（共享对象和结构）。框架侧的性能改进点还包括通过使用队列系统引入异步方法（第6章和第7章）。
- en: Now that you have an idea of the components involved in an HTTP request, let’s
    look at the structure of an HTTP request.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了HTTP请求中涉及的组件，让我们看看HTTP请求的结构。
- en: The structure of an HTTP request
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP请求的结构
- en: To understand in detail what happens in a typical HTTP request, we start by
    analyzing what is sent from the browser to the server during a request. A request
    is mainly characterized by methods (`GET`, `POST`, `PUT`, and so on), the URL,
    and HTTP headers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解典型HTTP请求中发生的情况，我们首先分析在请求期间浏览器发送到服务器的数据。请求主要特征是方法（`GET`、`POST`、`PUT`等）、URL和HTTP头。
- en: The URL is visible in the browser’s address bar, whereas the headers are handled
    automatically by the browser and are not directly visible to the user.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: URL在浏览器的地址栏中可见，而头由浏览器自动处理，对用户不可见。
- en: 'The following describes the structure of an HTTP request:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下描述了HTTP请求的结构：
- en: 'The `GET` method: Reads and retrieves a resource'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`方法：读取和检索资源'
- en: 'The `POST` method: Creates a new resource'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`方法：创建新的资源'
- en: 'The `PUT` method: Replaces a resource'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`方法：替换资源'
- en: 'The `PATCH` method: Edits the resource'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`方法：编辑资源'
- en: 'The `DELETE` method: Deletes the resource'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`方法：删除资源'
- en: The **URL** identifies the resource. We’ll explain the URL structure in the
    next section (*Handling an* *HTTP request*).*   The **headers** include additional
    information that allows the server to understand how to handle the resource. This
    information can comprise authentication information, the required format of the
    resource, and so on.*   The **body payload** is additional data, for example,
    the data sent when a form is submitted to the server.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL**标识资源。我们将在下一节中解释URL结构（*处理HTTP请求*）。**头**包括允许服务器理解如何处理资源的信息。这些信息可以包括认证信息、资源所需的格式等。**体负载**是附加数据，例如，当表单提交到服务器时发送的数据。'
- en: Now that you have an idea of the structure of an HTTP request, let’s see how
    such requests are handled.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了HTTP请求的结构，让我们看看这样的请求是如何处理的。
- en: Handling an HTTP request
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理HTTP请求
- en: 'A URL is made up of the protocol, the hostname, the port, the path, and the
    parameters. A typical URL is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个URL由协议、主机名、端口、路径和参数组成。一个典型的URL如下所示：
- en: '`<``protocol>://<hostname>:<port>/<path>?<parameters>`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`<``protocol>://<hostname>:<port>/<path>?<parameters>`'
- en: 'For example, a URL could be the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个URL可以是以下形式：
- en: '`https://127.0.0.1:8000/home?cache=12345`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://127.0.0.1:8000/home?cache=12345`'
- en: 'Each part that makes up the HTTP request is used specifically by the various
    software involved in handling the HTTP request:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 构成HTTP请求的每一部分都由处理HTTP请求的各种软件专门使用：
- en: A protocol is used by the browser to determine the communication encryption
    (encrypted via HTTPS or non-encrypted via HTTP).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议由浏览器用来确定通信加密（通过HTTPS加密或通过HTTP非加密）。
- en: A hostname is used by the DNS to resolve the hostname into an IP address, and
    by the web server to involve the right virtual host.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS使用主机名解析主机名到IP地址，而Web服务器则用于涉及正确的虚拟主机。
- en: A port is used by the operating system of the server to access the right process.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口由服务器的操作系统用来访问正确的进程。
- en: A path is used by the web server to call the right resource and for the framework
    to activate the routing mechanism.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径被Web服务器用来调用正确的资源，并且用于框架激活路由机制。
- en: 'Parameters are used by the application to control the behavior of the logic
    (server-side for query parameters and client-side for the anchor parameters).
    For example, the query parameters are defined after the `?` character, and the
    anchor parameters are defined after the `#` character in the URL: `https://127.0.0.1:8000/?queryparam=1#anchorparam`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序使用参数来控制逻辑的行为（服务器端用于查询参数，客户端用于锚点参数）。例如，查询参数在URL中的`?`字符之后定义，而锚点参数在URL中的`#`字符之后定义：`https://127.0.0.1:8000/?queryparam=1#anchorparam`。
- en: First, the protocol (typically HTTP or HTTPS) is defined. Next, the hostname,
    which is useful for figuring out which server to contact, is specified. Then,
    there is a part that is not normally specified, which is the port number; typically,
    it is port `80` for HTTP and `443` for HTTPS. Also present is the path that identifies
    the resource we are requesting from the server. Finally, two other optional parts
    deal with parameters. The first concerns server-side parameters (query string),
    and the second concerns client-side or JavaScript parameters (parameters with
    anchors).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义了协议（通常是HTTP或HTTPS）。接下来，指定了主机名，这对于确定要联系哪个服务器是有用的。然后，有一个通常不指定的部分，即端口号；通常，HTTP的端口号是`80`，HTTPS的端口号是`443`。还包括标识我们请求的服务器资源的路径。最后，还有两个其他可选部分处理参数。第一个是关于服务器端参数（查询字符串），第二个是关于客户端或JavaScript参数（带有锚点的参数）。
- en: In addition to the URL, another characteristic element of the request is the
    HTTP header, which is very important for the server reached by the request to
    better understand how to handle the request.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了URL之外，请求的另一个特征元素是HTTP头部，这对于请求到达的服务器来说非常重要，以便更好地理解如何处理请求。
- en: HTTP headers are automatically handled by the browser based on some information
    and browsing state. Typically, the headers specify the format and other information
    about the resource; for example, they specify the MIME type, user agent, and so
    on.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP头部基于一些信息和浏览状态由浏览器自动处理。通常，头部指定了资源的格式和其他信息；例如，它们指定了MIME类型、用户代理等等。
- en: They also specify any access tokens in case the requested resource is protected.
    The elements to manage the state are also present in the headers as cookies and
    references for the session. This information is useful for the server to understand
    and relate consecutive requests.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求的资源受到保护，它们还指定了任何访问令牌。用于管理状态的头元素也以cookie和会话引用的形式存在于头部。这些信息对服务器理解并关联连续请求是有用的。
- en: Why is it so important to understand how a request is composed? Because in analyzing
    optimization elements regarding performance, the structure of the URL and the
    parts that make up the headers determine the behavior of different elements within
    the web architecture (browser, network, web server, server-side language, and
    framework).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么理解一个请求是如何组成的如此重要？因为在分析关于性能的优化元素时，URL的结构和组成头部的部分决定了网络架构（浏览器、网络、Web服务器、服务器端语言和框架）中不同元素的行为。
- en: For example, an element such as a hostname is useful to the DNS (network) to
    be able to resolve the hostname into the IP address. Knowing this is useful in
    deciding whether to do caching, for example, for name resolution.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，像主机名这样的元素对DNS（网络）来说是有用的，可以将主机名解析为IP地址。了解这一点对于决定是否进行缓存，例如，对于名称解析来说是有用的。
- en: Each element involved has its own characteristics that can be optimized to be
    able to get better performance.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个涉及的元素都有其自身的特性，可以通过优化来获得更好的性能。
- en: One of the characterizing elements of a typical request to a classic PHP application
    is that each request is independent of any other request. This means that if your
    PHP script instantiates an object, this operation is repeated with each request.
    This has little impact if your script is called only a few times and your script
    is simple.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的对经典PHP应用程序的请求的一个特征元素是每个请求都是相互独立的。这意味着如果您的PHP脚本实例化了一个对象，这个操作会随着每个请求而重复。如果您的脚本只被调用几次且脚本很简单，这几乎没有影响。
- en: Let’s try to think of a scenario in which we have a framework-based application,
    with the application having to deal with a high load of concurrent requests.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景，其中我们有一个基于框架的应用程序，该应用程序必须处理大量的并发请求。
- en: A framework-based application has numerous objects at its disposal, which must
    be instantiated and configured at startup. In the classic case of PHP, the startup
    of the framework corresponds to a request.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基于框架的应用程序拥有许多可供使用的对象，这些对象必须在启动时实例化和配置。在经典的 PHP 案例中，框架的启动对应于一个请求。
- en: Laravel Octane, on the other hand, introduces a new way of starting the application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Laravel Octane 引入了一种新的启动应用程序的方式。
- en: In a classic Laravel web application, it is sufficient to have a web server
    (such as nginx) or the internal web server provided by Laravel in the case of
    development on the developer’s local computer. A classic web server can handle
    requests without any kind of resource-sharing unless these resources are external
    resources such as a database or a cache manager.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的 Laravel 网络应用程序中，只需要一个网络服务器（如 nginx）或 Laravel 在开发者在本地计算机上进行开发时提供的内部网络服务器。一个经典网络服务器可以在没有任何类型的资源共享的情况下处理请求，除非这些资源是外部资源，如数据库或缓存管理器。
- en: In contrast to what happens with a classic web server, an application server
    has the task of starting and managing the executions of multiple workers. Each
    worker will be able to handle multiple requests by reusing objects and parts of
    the logic of your application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与经典网络服务器发生的情况相反，应用程序服务器有启动和管理多个工作进程执行的任务。每个工作进程将通过重用应用程序的对象和逻辑的一部分来处理多个请求。
- en: This has one benefit, which is that the actual startup of your application and
    the setting up of the various objects occur on the first request received from
    the worker and not on each individual request.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个好处，即你的应用程序的实际启动和设置各种对象是在从工作进程接收到的第一个请求上发生的，而不是在每个单独的请求上。
- en: HTTP requests and Laravel
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 请求和 Laravel
- en: From the Laravel application perspective, the parts involved directly in the
    HTTPS requests are typically routes and controllers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Laravel 应用程序的角度来看，直接参与 HTTPS 请求的部分通常是路由和控制器。
- en: 'Handling a request through a Laravel application typically means having to
    implement the routing part and implement the logic to manage the request in the
    controller. Routing allows us to define which code to execute within our Laravel
    application against a specific path in the URL. For example, we might want to
    define that the code of a method in a specific class such as `HomeController::home()`
    must be invoked against a request that has a `/home` path in the URL. In the classic
    Laravel definition, we would write something like this in the `routes/web.php`
    file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Laravel 应用程序处理请求通常意味着需要在控制器中实现路由部分和实现管理请求的逻辑。路由允许我们在 Laravel 应用程序中针对 URL
    中的特定路径定义要执行的代码。例如，我们可能想要定义，特定类（如 `HomeController::home()`）中的方法代码必须在具有 `/home`
    路径的请求中调用。在经典的 Laravel 定义中，我们会在 `routes/web.php` 文件中编写如下内容：
- en: '[PRE0]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we have to implement the logic to manage the request in the `HomeController`
    class (that we have to create) and implement the `home` method. So, in a new `app/Http/Controllers/HomeController.php`
    file, you have to implement the `HomeController` class extending the basic controller
    class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须在 `HomeController` 类（我们必须创建）中实现管理请求的逻辑，并实现 `home` 方法。因此，在一个新的 `app/Http/Controllers/HomeController.php`
    文件中，你必须实现扩展基本控制器类的 `HomeController` 类：
- en: '[PRE1]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that you have an understanding of how web servers handle requests, let us
    learn more about the application servers that Laravel Octane integrates with.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了网络服务器如何处理请求，那么让我们更多地了解 Laravel Octane 集成的应用程序服务器。
- en: Getting to know the application server for Laravel Octane
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Laravel Octane 的应用程序服务器
- en: In the PHP ecosystem, we have several application servers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 生态系统中，我们有几个应用程序服务器。
- en: 'Laravel Octane, which handles server configuration, startup, and execution,
    integrates mainly with two of them: Swoole and RoadRunner.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 处理服务器配置、启动和执行的 Laravel Octane 集成了其中两个：Swoole 和 RoadRunner。
- en: We will deal with the installation, configuration, and use of these two application
    servers in detail later on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后详细讨论这些两个应用程序服务器的安装、配置和使用。
- en: 'For now, it is enough for us to know that once the application servers are
    installed, Laravel Octane will take care of their management. Laravel Octane will
    also take care of their proper startup via the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，对于我们来说，知道一旦安装了应用程序服务器，Laravel Octane 将负责它们的管理就足够了。Laravel Octane 还将通过以下命令负责它们的正确启动：
- en: '[PRE2]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `octane:serve` command is added when Laravel Octane is installed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当Laravel Octane 安装时，会添加 `octane:serve` 命令。
- en: In other words, Laravel Octane has a strong dependency on application servers
    such as RoadRunner or Swoole.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Laravel Octane 对应用程序服务器（如RoadRunner或Swoole）有很强的依赖性。
- en: 'At startup, Laravel Octane via Swoole or RoadRunner activates some workers,
    as shown in the following figure:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，Laravel Octane 通过Swoole或RoadRunner激活了一些工作进程，如下面的图所示：
- en: '![Figure 1.1: The activation of workers](img/Figure_1.1_B17728.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1：工作进程的激活](img/Figure_1.1_B17728.jpg)'
- en: 'Figure 1.1: The activation of workers'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：工作进程的激活
- en: What are workers?
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作进程是什么？
- en: In Octane, a **worker** is a process that takes charge of handling the requests
    associated with it. A worker has the responsibility of starting the framework
    and initializing framework objects.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Octane中，**工作进程**是一个负责处理与其关联的请求的进程。工作进程有责任启动框架和初始化框架对象。
- en: This has an extremely positive impact from a performance standpoint. The framework
    is instantiated on the first request assigned to the worker. The second (and subsequent)
    requests assigned to that worker reuse the objects already instantiated. The side
    effect of this is that the worker shares instances of global objects and static
    variables between requests. This means that different calls to the controller
    can access the data structures that are shared between requests.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这从性能角度来看具有极其积极的影响。框架是在分配给工作进程的第一个请求上实例化的。分配给该工作进程的第二个（以及随后的）请求将重用已经实例化的对象。这种副作用是，工作进程在请求之间共享全局对象和静态变量的实例。这意味着不同的控制器调用可以访问请求之间共享的数据结构。
- en: To complicate matters, there is the fact that requests assigned to the same
    worker share a global state, but different workers are independent and have scope
    independent of each other. So, we can say that not all requests share the same
    global state. Requests share a global state when associated with the same worker.
    Two requests from two different workers share nothing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的是，分配给同一工作进程的请求共享一个全局状态，但不同的工作进程是独立的，并且它们的作用域相互独立。因此，我们可以这样说，并非所有请求都共享相同的全局状态。当请求与同一工作进程相关联时，请求才共享全局状态。来自两个不同工作进程的两个请求之间没有任何共享。
- en: In order to minimize the side effect, Laravel Octane has the responsibility
    of managing the reset of classes/objects owned directly by the framework across
    the requests.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化副作用，Laravel Octane 负责在请求之间管理框架直接拥有的类/对象的重置。
- en: However, Octane can’t manage and reset classes owned directly by the application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Octane 无法管理和重置应用程序直接拥有的类。
- en: That’s why the main thing to pay attention to when using Octane is the scope
    and lifecycle of variables and objects.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在使用Octane时，需要注意的主要是变量和对象的作用域和生命周期。
- en: To understand this better, I will give you a very basic example.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，我将给你一个非常基础的例子。
- en: Example with a shared variable
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享变量的示例
- en: 'This example, in the `routes/web.php` file, creates a route for `path /` and
    returns a human-readable timestamp. To simplify the explanation, we are going
    to write the logic directly into the route file instead of calling and delegating
    the logic to a controller:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在 `routes/web.php` 文件中创建了一个 `path /` 的路由，并返回一个可读的时间戳。为了简化解释，我们将直接将逻辑写入路由文件，而不是调用并将逻辑委派给控制器：
- en: '[PRE3]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the `routes/web.php` routing file (`web.php` is already stored in the `routes`
    directory in the Laravel root folder project), a `$myStartTime` variable is instantiated
    and assigned the current time expressed in milliseconds. This variable is then
    inherited by the `route/management` function via the `use` clause.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `routes/web.php` 路由文件（`web.php` 已经存储在Laravel根文件夹项目的 `routes` 目录中），实例化了一个 `$myStartTime`
    变量，并将其分配为以毫秒表示的当前时间。然后，该变量通过 `use` 子句由 `route/management` 函数继承。
- en: In the performance of the function associated with `route/`, the contents of
    the `$myStartTime` variable are returned and then displayed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 `route/` 相关的函数的性能中，返回 `$myStartTime` 变量的内容，然后显示。
- en: With the classic behavior of the Laravel application, at each invocation/execution,
    the variable is regenerated and reinitialized (each time with a new value).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Laravel 应用程序的经典行为中，每次调用/执行时，变量都会被重新生成和重新初始化（每次都带有新值）。
- en: 'To start the Laravel application in the classic mode, simply run the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要以经典模式启动 Laravel 应用程序，只需运行以下命令：
- en: '[PRE4]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the web server is started, go to the following URL via the browser: `http://127.0.0.1:8000`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动网络服务器，请通过浏览器访问以下 URL：`http://127.0.0.1:8000`
- en: By continuously reloading the page, a different value is displayed each time;
    basically, the timestamp is displayed with each request.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不断刷新页面，每次都会显示不同的值；基本上，每次请求都会显示时间戳。
- en: Instead of using the development web server provided by Laravel, you would use
    Laravel Octane and have a different result. At each page refresh (reloading of
    the web page), you would always see the same value. The value is relative to the
    timestamp of the first request served. This means that the variable is initialized
    with the first request and then the value is reused across the requests.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 Laravel 提供的开发网络服务器不同，您将使用 Laravel Octane 并得到不同的结果。在每次页面刷新（网页重新加载）时，您都会看到相同的值。该值相对于第一个请求的时间戳。这意味着变量是在第一个请求中初始化的，然后该值在请求之间被重复使用。
- en: If you try to refresh multiple times, in some cases, you could see a new value.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试多次刷新，在某些情况下，您可能会看到新值。
- en: If this happens, it means that the request was managed by the second (or a new)
    worker. This means that this behavior is quite unpredictable because Octane acts
    as a load balancer. When a request comes from the network, the application server
    will decide which worker (of those available) to assign the request to.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，这意味着请求是由第二个（或新的）工作者处理的。这意味着这种行为相当不可预测，因为 Octane 充当负载均衡器。当网络请求到来时，应用程序服务器将决定将请求分配给哪个工作者（那些可用的工作者之一）。
- en: In addition to this, another element that could cause a new value to be generated
    is when you hit the maximum number of requests managed by a single worker. We
    will see how to define the maximum number of requests later, and in general, we
    will have a deep dive session (in *Chapters 2* and *3*) into Laravel Octane configuration.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，另一个可能导致生成新值的情况是当您达到单个工作者管理的请求最大数量时。我们将在后面看到如何定义最大请求数量，通常，我们将在第 2 章和第 3 章中进行
    Laravel Octane 配置的深入探讨。
- en: The behavior whereby variables are shared across workers until the application
    server is restarted is valid only for global variables or objects stored in the
    application service container. The local variables (the variables for which the
    scope is limited to a function or a method) are not affected.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量在应用程序服务器重启之前在工作者之间共享的行为仅适用于全局变量或存储在应用程序服务容器中的对象。局部变量（其作用域仅限于函数或方法的变量）不受影响。
- en: 'For example, in the code previously shown, I’m going to declare a `$myLocalStartTime`
    variable in the function called by the routing mechanism. The scope of the `$myLocalStartTime`
    variable and its lifecycle is limited to the `Closure` function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面显示的代码中，我将在由路由机制调用的函数中声明一个 `$myLocalStartTime` 变量。`$myLocalStartTime` 变量的作用域及其生命周期仅限于
    `Closure` 函数：
- en: '[PRE5]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Execute the following command with the classic Laravel web server:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令执行经典 Laravel 网络服务器：
- en: '[PRE6]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You will see that both values will change on each new request. You can see that
    when you open a browser to `http://127.0.0.1:8000`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到每个新请求时这两个值都会改变。您可以通过打开浏览器到 `http://127.0.0.1:8000` 来看到这一点。
- en: 'Launch Octane as a server with the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令以服务器模式启动 Octane：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You will see, in your browser at `http://127.0.0.1:8000`, two different dates/times
    with milliseconds. If you refresh the page, you will see a change in just the
    second one (`$myLocalStartTime`).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中（`http://127.0.0.1:8000`），您将看到两个不同的日期/时间，带有毫秒数。如果您刷新页面，您将只看到第二个的变化（`$myLocalStartTime`）。
- en: You have to be aware of this behavior when you are building an application based
    on Octane.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当您基于 Octane 构建应用程序时，您必须注意这种行为。
- en: Another example to better understand this behavior is creating a class with
    a static property.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这种行为，我们可以创建一个具有静态属性的类作为另一个例子。
- en: Creating a class with a static property
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建具有静态属性的类
- en: In order to keep this example as simple as possible, I created a `MyClass` class
    in the `routes/web.php` file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个例子尽可能简单，我在 `routes/web.php` 文件中创建了一个 `MyClass` 类。
- en: I’m going to add new routes that call the `add()` method of the `MyClass` object
    and then call and return the value of the static property retrieved by the `get()`
    method.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我将添加新的路由，这些路由调用`MyClass`对象的`add()`方法，然后调用并返回由`get()`方法检索到的静态属性的值。
- en: 'In `routes/web.php`, add the following class:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`routes/web.php`中添加以下类：
- en: '[PRE8]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, in the `routes/web.php` file, declare the new route as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`routes/web.php`文件中，声明新的路由如下：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, you can launch Laravel in a classic way using the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以使用以下命令以经典方式启动Laravel：
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, if you access the URL `http://127.0.0.1:8000/static-class` multiple times,
    the value `1` will be shown. This is because, classically, for every request,
    the `MyClass` object is instanced from scratch.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你多次访问URL `http://127.0.0.1:8000/static-class`，将显示值`1`。这是因为，传统上，对于每个请求，`MyClass`对象都是从零开始实例化的。
- en: 'Launch Laravel Octane using the following command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动Laravel Octane：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you then access the URL `http://127.0.0.1:8000/static-class` multiple times,
    you will see the value `1` in the first request, `2` in the second, `3` in the
    third, and so on. This is because, with Octane, `MyClass` is instanced for every
    request, but the static values are kept in memory.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你多次访问URL `http://127.0.0.1:8000/static-class`，你将看到第一次请求的值为`1`，第二次为`2`，第三次为`3`，依此类推。这是因为，使用Octane，`MyClass`对象为每个请求实例化，但静态值保存在内存中。
- en: 'With a non-static property, we can see the difference as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非静态属性，我们可以看到以下差异：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After calling the page five times, the result shown in the browser will be
    as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用页面五次之后，浏览器中显示的结果如下：
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is quite simple but, in the end, good for understanding the behavior of
    static variables under the hood.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，但最终有助于理解静态变量在底层的行为。
- en: The use of static variables is not so unusual. Just think of singleton objects
    or the app container of Laravel.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 静态变量的使用并不罕见。只需想想单例对象或Laravel的应用容器。
- en: To avoid unexpected behavior – as in this specific example with static variables
    but more generally, with global objects (Laravel makes extensive use of them)
    – explicit re-initialization must be taken care of. In this case, the static variable
    is initialized in the constructor. My suggestion is to use explicit initialization
    of the properties in the constructor. This is because it is the developer’s responsibility
    to take care of the re-initialization of the variables in the case of global states
    (objects and variables).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免意外行为——就像在这个特定示例中静态变量的情况，但更普遍地，与全局对象（Laravel广泛使用它们）相关——必须注意显式重新初始化。在这种情况下，静态变量在构造函数中初始化。我的建议是在构造函数中显式初始化属性。这是因为在这种情况下，开发者有责任负责全局状态（对象和变量）的重新初始化。
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have seen just some very basic examples of the impact on the code if you
    are going to install and use Laravel Octane. The examples shown earlier were purposely
    very simple, but with the goal of being easy to understand. In the chapter where
    we will use Octane in a real scenario, we will cover more realistic examples.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些关于如果你要安装和使用Laravel Octane时对代码影响的非常基础的示例。前面展示的示例故意设计得非常简单，但目的是易于理解。在我们将在实际场景中使用Octane的章节中，我们将涵盖更现实的示例。
- en: Now we will analyze the impact on performance. So, by installing Octane, what
    kind of improvement could we have in terms of performance?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将分析对性能的影响。所以，通过安装Octane，我们在性能方面可能会有什么样的改进？
- en: Understanding performance measurement in Laravel Octane
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Laravel Octane中的性能测量
- en: We have said that introducing Laravel Octane in your application allows for
    a performance boost, mainly because the objects and the various instances of the
    classes used by the framework are no longer initialized at every single HTTP request
    but at the start of the application server. As a result, for each HTTP request,
    framework objects are reused. Reusing framework objects saves time in serving
    the HTTP request.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过，在你的应用程序中引入Laravel Octane可以提升性能，主要是因为框架使用的对象和类的各种实例不再在每个HTTP请求中初始化，而是在应用程序服务器启动时初始化。因此，对于每个HTTP请求，框架对象被重用。重用框架对象可以节省在处理HTTP请求中的时间。
- en: While, on a logical and understandable level, this can have a positive impact
    in terms of performance, the goal of this part is to get pragmatic feedback on
    this performance boost by trying to recover some metrics and values.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在逻辑和可理解层面上，这可能在性能方面产生积极影响，但本部分的目标是通过尝试恢复一些指标和值来获取这种性能提升的实用反馈。
- en: In order to provide a rough indication of the benefits and improved response
    time performance for a request, let us try to perform a simple performance test.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个关于请求的好处和改进响应时间性能的大致指示，让我们尝试进行一个简单的性能测试。
- en: To do this, we are going to install a tool to generate and execute some HTTP-concurrent
    requests. There are several such tools, one of which is **wrk** ([https://github.com/wg/wrk](https://github.com/wg/wrk)).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将安装一个工具来生成和执行一些 HTTP 并发请求。这类工具有很多，其中之一是 **wrk** ([https://github.com/wg/wrk](https://github.com/wg/wrk))。
- en: 'If you have a macOS environment, you could use the `brew` command (provided
    by Homebrew) to install the `wrk` tool. To install the tool, use `brew install`
    as shown:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个 macOS 环境，你可以使用 `brew` 命令（由 Homebrew 提供）来安装 `wrk` 工具。要安装该工具，请使用如下所示的 `brew
    install`：
- en: '[PRE15]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With `wrk`, you can generate concurrent requests for a defined amount of time.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `wrk`，你可以生成一定时间内的并发请求。
- en: 'We will conduct two tests for comparison: one test will be conducted with a
    classical web application on nginx (`http://octane.test`), and the other one with
    an application served by an application server on Laravel Octane (http://octane.test:8000).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行两次测试以进行比较：一次是在 nginx 上的经典 Web 应用程序上进行测试（`http://octane.test`），另一次是在 Laravel
    Octane 上的应用程序服务器上提供服务（http://octane.test:8000）。
- en: 'The two URLs are resolved as shown:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 URL 的解析如下所示：
- en: '`http://octane.test/` is resolved with local address `127.0.0.1` and will reply
    nginx'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://octane.test/` 使用本地地址 `127.0.0.1` 解析，并将回复 nginx'
- en: '`http://octane.test:8000/` is resolved with local address `127.0.0.1` and port
    `8000` is bound by Swoole'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://octane.test:8000/` 使用本地地址 `127.0.0.1` 解析，端口 `8000` 由 Swoole 绑定'
- en: The `wrk` execution will use 4 threads, open 20 connections, and take 10 seconds
    of tests.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrk` 执行将使用 4 个线程，打开 20 个连接，并持续 10 秒的测试。'
- en: 'So, to test NGINX, launch the `wrk` command with these arguments:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了测试 NGINX，使用以下参数启动 `wrk` 命令：
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You will see the following output:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To test Laravel Octane (RoadRunner), use the following command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 Laravel Octane（RoadRunner），请使用以下命令：
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You will see the following output:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This test is very basic because there are no special server-side logic or query
    databases involved, but it is good to run the test to understand the raw difference
    in bootstrapping basic objects for Laravel (application container, requests, etc.)
    and perceive their flavor.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试非常基础，因为没有涉及特殊的服务器端逻辑或查询数据库，但运行这个测试有助于理解 Laravel（应用程序容器、请求等）启动基本对象时的原始差异，并感知它们的味道。
- en: The difference is not so great (7,196 requests versus 5,612 requests) – around
    22% – but consider that this difference grows if you add new packages and libraries
    (more code to be bootstrapped for each request).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 差异并不大（7,196 个请求与 5,612 个请求），大约 22%，但考虑到如果你添加了新的包和库（每个请求都要启动更多的代码），这种差异会增长。
- en: Consider also that RoadRunner and Swoole provide other additional tools for
    improving performances such as enabling concurrency and executing concurrent tasks.
    The additional tools will be shown later in *Chapters 2* and *3*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 RoadRunner 和 Swoole 还提供了其他一些用于提高性能的工具，例如启用并发和执行并发任务。这些附加工具将在第 *2* 章和 *3*
    章中展示。
- en: To better explain why Laravel Octane allows you to achieve this improvement,
    let me demonstrate how and when service providers are instanced and loaded into
    a service container.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地解释为什么 Laravel Octane 允许你实现这种改进，让我演示一下服务提供者是如何和何时实例化并加载到服务容器中的。
- en: Typically, in a classic Laravel application service, providers are loaded in
    each request.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，在一个经典的 Laravel 应用程序服务中，提供者会在每个请求中加载。
- en: 'Create a new service provider named `MyServiceProvider` in the `app/Providers`
    directory:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app/Providers` 目录中创建一个新的服务提供者 `MyServiceProvider`：
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The new service provider simply shows a message when the service provider is
    created, registered, and booted.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 新的服务提供者简单地在服务提供者创建、注册和启动时显示一条消息。
- en: 'The lifecycle of a service provider starts with three phases: creation, registration,
    and boot.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 服务提供者的生命周期从三个阶段开始：创建、注册和启动。
- en: The `register()` and `boot()` methods are needed for *dependency resolution*.
    First of all, every service provider is registered. Once they are all registered,
    they could be booted. If a service provider needs another service in the `boot`
    method, you can be sure that it is ready to be used because it is already registered.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`register()` 和 `boot()` 方法需要用于 *依赖解析*。首先，每个服务提供者都会被注册。一旦它们都被注册，它们就可以启动。如果一个服务提供者在
    `boot` 方法中需要另一个服务，你可以确信它已经准备好使用，因为它已经被注册了。'
- en: Then, you have to register the service provider, so in `config/app.php` in the
    `providers` array, add `App\Providers\MyServiceProvider::class`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你必须注册服务提供者，所以需要在 `config/app.php` 文件中的 `providers` 数组中添加 `App\Providers\MyServiceProvider::class`。
- en: 'In a classical Laravel web application, for every HTTP request, the `MyServiceProvider`
    service provider is instanced, and the `construct`, `register`, and `boot` methods
    are called every time, showing this output:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个经典的 Laravel 网络应用程序中，对于每一个 HTTP 请求，`MyServiceProvider` 服务提供者都会被实例化，并且每次都会调用
    `construct`、`register` 和 `boot` 方法，显示以下输出：
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With Laravel Octane, something different happens.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Laravel Octane，会发生一些不同的事情。
- en: 'For a better understanding, we are going to launch the Laravel Octane server
    with two parameters:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，我们将使用两个参数启动 Laravel Octane 服务器：
- en: '`workers`: The number of workers that should be available to handle requests.
    We are going to set this number to `2`.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workers`：应该可用于处理请求的工作进程数量。我们将把这个数字设置为 `2`。'
- en: '`max-requests`: The number of requests to process before reloading the server.
    We are going to set this number to a maximum limit of `5` for each worker.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max-requests`：在重新加载服务器之前要处理的请求数量。我们将把这个数字设置为每个工作进程的最大限制 `5`。'
- en: 'To start the Octane server with two workers and reload the server after processing
    five requests, we enter the following command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要以两个工作进程启动 Octane 服务器，并在处理五个请求后重新加载服务器，我们输入以下命令：
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After launching Octane, try to perform more than one request with the browser
    accessing this URL: `http://127.0.0.1:8000`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Octane 后，尝试使用浏览器访问以下 URL 进行多个请求：`http://127.0.0.1:8000`。
- en: 'The following is the output:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first 2 requests take around 100 `register()` and `boot()` methods are called
    on the first two requests.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个请求大约需要 100 次调用 `register()` 和 `boot()` 方法。
- en: So we can see the first two requests (two because we have two workers) are a
    bit slower (113.62 ms and 85.49 ms) than the next requests (from the third to
    the tenth request, where we have a response time of less than 10 ms).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到前两个请求（因为我们有两个工作进程，所以是两个）比后续请求（从第三个到第十个请求，响应时间低于 10 毫秒）慢一些（113.62 毫秒和
    85.49 毫秒）。
- en: Another important thing to mention is that the `register` and `boot` methods
    are called for the first two requests until the tenth request (two workers multiplied
    by five max requests). This behavior is repeated for subsequent requests.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要提到的重要事情是，`register` 和 `boot` 方法在前两个请求中会被调用，直到第十个请求（两个工作进程乘以最多五个请求）。后续请求会重复这种行为。
- en: And so, installing Laravel Octane in your web application allows you to improve
    the response time of your application.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在您的网络应用程序中安装 Laravel Octane 允许您提高应用程序的响应时间。
- en: All this without having involved certain tools such as concurrency management
    provided by application servers such as Swoole and RoadRunner.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都不需要涉及某些工具，例如 Swoole 和 RoadRunner 等应用服务器提供的并发管理工具。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Now that we have an overview of the behavior, some benefits, and some side
    effects of Laravel Octane, we can proceed with the next chapter by installing
    and configuring one of the two Laravel Octane-compatible application servers:
    the RoadRunner application server.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了 Laravel Octane 的行为、一些优点和一些副作用，我们可以继续下一章，通过安装和配置两个 Laravel Octane
    兼容的应用服务器之一：RoadRunner 应用服务器。
- en: We will revisit some of the instructions addressed in this chapter. The goal
    of this chapter was to provide some useful summary elements to address the more
    specific and detailed cases in the rest of the book.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾本章中提到的某些指令。本章的目标是提供一些有用的总结元素，以解决本书其余部分中更具体和详细的案例。
- en: 'Part 2: The Application Server'
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：应用服务器
- en: 'Laravel Octane uses an application server such as RoadRunner or Swoole. Running
    the application in an application server instead of a classical web server allows
    the developer to use some advanced features such as managing multiple workers,
    concurrent tasks, and bootstrap applications in a more efficient way; fast caching,
    and sharing data across the workers. This part comprises the following chapters:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel Octane 使用应用服务器，如 RoadRunner 或 Swoole。在应用服务器而不是经典网络服务器上运行应用程序，允许开发者使用一些高级功能，例如更有效地管理多个工作进程、并发任务以及以更高效的方式引导应用程序；快速缓存，以及在工作进程之间共享数据。本部分包括以下章节：
- en: '[*Chapter 2*](B17728_02.xhtml#_idTextAnchor036), *Configuring the RoadRunner
    Application Server*'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第二章*](B17728_02.xhtml#_idTextAnchor036)，*配置 RoadRunner 应用服务器*'
- en: '[*Chapter 3*](B17728_03.xhtml#_idTextAnchor048), *Configuring the Swoole Application
    Server*'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第3章*](B17728_03.xhtml#_idTextAnchor048), *配置Swoole应用程序服务器*'
