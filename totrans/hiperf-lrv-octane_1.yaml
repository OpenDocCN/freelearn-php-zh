- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the Laravel Web Application Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is for **Laravel** developers who would like to make or design their
    Laravel web application in a more scalable way and make it more performant.
  prefs: []
  type: TYPE_NORMAL
- en: This book aims to provide you with knowledge, suggestions, and explanations
    on how to improve the software architecture of a web application, starting from
    a typical PHP web application architecture to a more scalable and performant architecture.
  prefs: []
  type: TYPE_NORMAL
- en: It provides a 360-degree overview of what it takes to design and build a performant
    application with **Laravel Octane**. We’ll see why Laravel Octane is suitable
    for designing and building a performant application. The book also covers the
    different tools used by Laravel Octane, such as **Open Swoole** and **RoadRunner**,
    and lists and describes the various features and differentiating elements. But
    the most important thing is to enable you to understand why and when to use Open
    Swoole or RoadRunner.
  prefs: []
  type: TYPE_NORMAL
- en: But before starting, why use Laravel Octane?
  prefs: []
  type: TYPE_NORMAL
- en: Laravel Octane is a tool that allows us to access some functionality and features
    exposed by the two application servers we just mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of Laravel Octane is the huge improvement in the response
    times to HTTP requests by clients such as web browsers. When we develop a Laravel
    application, we use an important software layer implemented by the framework.
    This software layer needs time and resources to start. Even if we talk about only
    a few resources and a short amount of time, this repeated action for each request,
    especially in a context where there are many requests, can be a problem. Or rather,
    its optimization could bring enormous benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Laravel Octane, through application servers, does just that: optimizes the
    process of starting the framework, which typically happens for each individual
    request. We will see in detail how this is done; essentially, the objects and
    everything that the framework needs are started and allocated to the start of
    the application server, and then the instances are made available to the various
    workers. **Workers** are the processes that are initiated to serve the requests.'
  prefs: []
  type: TYPE_NORMAL
- en: Another reason why it is interesting to evaluate the adoption of Laravel Octane
    in your Laravel web application is that by using an application server such as
    Swoole, you can access those features implemented by Swoole.
  prefs: []
  type: TYPE_NORMAL
- en: The functions are, for example, the advanced mechanisms of the cache driver,
    shared storage for sharing information between the various workers, and the execution
    of tasks in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: This is a totally new concept to the classic PHP developer who typically does
    not have an immediate functionality available in the PHP core for the parallelization
    of processes.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce you to the Laravel ecosystem and explore what Laravel
    Octane is.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter aims to introduce you to the application server approach, in which
    more workers cooperate to manage multiple requests. Understanding the behavior
    under the hood allows the developer to avoid some mistakes, especially on shared
    resources (objects and global states) across the worker. This is important because
    the classical PHP approach is to have one dedicated thread to manage one request.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Laravel ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the request lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know the application server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to run the code and tools shown in this book, you must have the **PHP
    engine** installed on your machine. It is recommended that you have a recent version
    of PHP installed (at least *8.0*, released in November 2020).
  prefs: []
  type: TYPE_NORMAL
- en: Also, in order to easily install additional tools, it is recommended that you
    have Homebrew installed if you use macOS. In the case of GNU/Linux systems, it
    will be sufficient to resort to using the package manager of the distribution
    used, and in the case of Windows systems, the advice is to have a virtual environment,
    for example, with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: In the current chapter, some commands and source code will be shown, simply
    to share some concepts. In subsequent chapters, especially the second chapter
    about RoadRunner and the third chapter about Open Swoole, the installation of
    each package and tool will be addressed step by step.
  prefs: []
  type: TYPE_NORMAL
- en: There are those who, regardless of their operating system, prefer to maintain
    a “clean” installation by resorting to using Docker regardless of the host operating
    system. Where the next chapters deal with the installation of operating system-dependent
    tools, the different methods will be highlighted depending on the system in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code and the configuration files of the examples described in the
    current chapter are available here: [https://github.com/PacktPublishing/High-Performance-with-Laravel-Octane/tree/main/octane-ch01](https://github.com/PacktPublishing/High-Performance-with-Laravel-Octane/tree/main/octane-ch01)'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Laravel ecosystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Laravel is a great framework in the PHP ecosystem that helps developers to build
    web applications quickly and reliably.
  prefs: []
  type: TYPE_NORMAL
- en: It includes, as dependencies, some great tools from the PHP ecosystem, such
    as **Symfony** packages, and some other solid and mature packages such as **Monolog**
    for logging, **Flysystem** for accessing files and storage, and **CommonMark**
    for managing Markdown format.
  prefs: []
  type: TYPE_NORMAL
- en: From the Symfony world, Laravel includes packages such as `Symfony/routing`
    to manage routing, and `http-foundation` and `http-kernel` to manage HTTP communication.
  prefs: []
  type: TYPE_NORMAL
- en: All this is just to say that Laravel uses the best parts of the PHP ecosystem,
    puts them together, and provides tools, helpers, classes, and methods to simplify
    the usage of all the tools from the developer’s perspective.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, Laravel is more than a framework. Laravel is an ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel also provides applications and services that are integrated with the
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, Laravel provides the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cashier**: For integration with **Stripe** and **Paddle** for the payment
    and subscription process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Breeze**, **Jetstream**, **Sanctum**, and **Socialite**: For managing authorization,
    authentication, the social login integration process, and exposing protected APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dusk** and **Pest**: For testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Echo**: For broadcasting events in real time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Envoyer**, **Forge**, and **Vapor**: For server or serverless management
    and to manage the deployment process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mix**: For compiling **JavaScript** and **CSS** through a webpack configuration
    fully integrated with the Laravel frontend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Horizon**: A web user interface for monitoring queues based on **Redis**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nova**: An administrator panel builder for Laravel applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sail**: A local development environment based on **Docker**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scout**: A full-text search engine, backed by providers such as **Algolia**,
    **Meilisearch**, or simply by the **MySQL** or **PostgreSQL** database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spark**: A boilerplate solution for managing billing/subscription in your
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Telescope**: UI module for showing debugging and insights.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Valet**: A macOS-specific bundle of applications configured for running the
    PHP application. It has dependencies with **nginx**, **PHP**, and **Dnsmasq**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Octane**: For improving performance and optimizing resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book, we will analyze the last tool in this list: Laravel Octane.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will go over the use of other tools within the Laravel ecosystem, such as
    Sail (for simplifying the installation process of a complete development environment),
    and Valet (for correctly setting up the local environment to run a web server
    and PHP). Also, Laravel Octane depends on important software that we will see
    in-depth throughout the book. Laravel Octane has strong requirements: it requires
    additional software such as Swoole or RoadRunner.'
  prefs: []
  type: TYPE_NORMAL
- en: But one step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Before we delve into the tools and their configuration, it’s important to understand
    some basic mechanisms for managing **HTTP requests**.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs: []
  type: TYPE_NORMAL
- en: HTTP is a protocol that defines rules, messages, and methods for fetching resources
    on the web, such as HTML documents (web pages) and assets. Clients (who require
    the resource) and servers (who serve the resource) communicate by exchanging messages.
    The client sends requests, and the server sends responses.
  prefs: []
  type: TYPE_NORMAL
- en: One of the goals of the book is to empower you to improve the performance of
    your web applications by doing different things, starting with designing the architecture
    of the application, choosing and using the right tools, writing code, and finally,
    releasing the application.
  prefs: []
  type: TYPE_NORMAL
- en: The tools we are going to analyze and use will do much of the work, but I think
    it is important to understand the underlying dynamics to have a good awareness
    of how the various tools work to enable you to configure, integrate, and use them
    to the best of their ability.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get deeper into the workings of Laravel Octane, let me take you through
    how servers typically deal with HTTP requests by explaining the HTTP request lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the HTTP request lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a number of components involved in performing the HTTP request. The
    components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client**: This is where the request starts and the response ends (for example,
    the browser).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network**: The requests and responses go through this and it connects the
    server and the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Proxy**: This is an optional component that could perform some tasks before
    the request reaches the web server, such as caching, rewriting and/or altering
    the request, and forwarding the request to the right web server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web server**: This receives the request and is responsible for selecting
    the correct resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PHP**: The language, or more generally in the case of server-side languages,
    the language-specific engine that is used and involved. In this case, the PHP
    interpreter is used. The PHP interpreter can be activated mainly in two ways:
    as a web server module or as a separate process. In the latter case, a technology
    called **FastCGI Process Manager** (**FPM**) is used. We will see how this mechanism
    works later in more detail. For now, it is useful to know that the web server
    somehow invokes the server-side language interpreter. By doing this, our server
    is able to interpret the language. If the invoked resource is a PHP-type file
    with the specific PHP syntax, the resource file requested is interpreted by the
    PHP engine. The output is sent back in the form of a response to the web server,
    the network, and then the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Framework**: In the case that the application is written with PHP and a framework
    is used, as a developer, you can access classes, methods, and helpers to build
    your application faster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The components are called sequentially in the HTTP request flow. The HTTP request
    starts from the browser, then goes through the network (optionally passing through
    via the proxy), until it reaches the web server that invokes the PHP engine and
    the framework is bootstrapped.
  prefs: []
  type: TYPE_NORMAL
- en: From a performance point of view, if you want to bring some improvement, you
    have to take some action or implement some solution depending on the elements
    of this architecture.
  prefs: []
  type: TYPE_NORMAL
- en: For example, on the browser side, you could work on caching assets in the browser
    or on the optimization of your JavaScript code. On the networking side, one solution
    could be resource optimization, for example, reducing the weight of assets or
    introducing architectural elements such as a CDN. In the case of the web server,
    an effective first-level improvement could be to avoid loading the PHP engine
    for the static assets (non-PHP files).
  prefs: []
  type: TYPE_NORMAL
- en: All such fine-tuning will be addressed in the final chapters, where we will
    deal with the configuration and optimization of production elements. Most of the
    book covers the optimization of the framework. For example, in *Chapters 2* and
    *3*, topics such as the use of Octane with tools such as Swoole and RoadRunner,
    which enable more efficient and effective loading of resources (shared objects
    and structures), are addressed. Other points of performance improvement on the
    framework side include the introduction of an asynchronous approach through the
    use of queuing systems (*Chapters 6* and *7*).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an idea of the components involved in an HTTP request, let’s
    look at the structure of an HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of an HTTP request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand in detail what happens in a typical HTTP request, we start by
    analyzing what is sent from the browser to the server during a request. A request
    is mainly characterized by methods (`GET`, `POST`, `PUT`, and so on), the URL,
    and HTTP headers.
  prefs: []
  type: TYPE_NORMAL
- en: The URL is visible in the browser’s address bar, whereas the headers are handled
    automatically by the browser and are not directly visible to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following describes the structure of an HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GET` method: Reads and retrieves a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `POST` method: Creates a new resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `PUT` method: Replaces a resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `PATCH` method: Edits the resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `DELETE` method: Deletes the resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **URL** identifies the resource. We’ll explain the URL structure in the
    next section (*Handling an* *HTTP request*).*   The **headers** include additional
    information that allows the server to understand how to handle the resource. This
    information can comprise authentication information, the required format of the
    resource, and so on.*   The **body payload** is additional data, for example,
    the data sent when a form is submitted to the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have an idea of the structure of an HTTP request, let’s see how
    such requests are handled.
  prefs: []
  type: TYPE_NORMAL
- en: Handling an HTTP request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A URL is made up of the protocol, the hostname, the port, the path, and the
    parameters. A typical URL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<``protocol>://<hostname>:<port>/<path>?<parameters>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a URL could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://127.0.0.1:8000/home?cache=12345`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each part that makes up the HTTP request is used specifically by the various
    software involved in handling the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: A protocol is used by the browser to determine the communication encryption
    (encrypted via HTTPS or non-encrypted via HTTP).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hostname is used by the DNS to resolve the hostname into an IP address, and
    by the web server to involve the right virtual host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A port is used by the operating system of the server to access the right process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A path is used by the web server to call the right resource and for the framework
    to activate the routing mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameters are used by the application to control the behavior of the logic
    (server-side for query parameters and client-side for the anchor parameters).
    For example, the query parameters are defined after the `?` character, and the
    anchor parameters are defined after the `#` character in the URL: `https://127.0.0.1:8000/?queryparam=1#anchorparam`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, the protocol (typically HTTP or HTTPS) is defined. Next, the hostname,
    which is useful for figuring out which server to contact, is specified. Then,
    there is a part that is not normally specified, which is the port number; typically,
    it is port `80` for HTTP and `443` for HTTPS. Also present is the path that identifies
    the resource we are requesting from the server. Finally, two other optional parts
    deal with parameters. The first concerns server-side parameters (query string),
    and the second concerns client-side or JavaScript parameters (parameters with
    anchors).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the URL, another characteristic element of the request is the
    HTTP header, which is very important for the server reached by the request to
    better understand how to handle the request.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP headers are automatically handled by the browser based on some information
    and browsing state. Typically, the headers specify the format and other information
    about the resource; for example, they specify the MIME type, user agent, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: They also specify any access tokens in case the requested resource is protected.
    The elements to manage the state are also present in the headers as cookies and
    references for the session. This information is useful for the server to understand
    and relate consecutive requests.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it so important to understand how a request is composed? Because in analyzing
    optimization elements regarding performance, the structure of the URL and the
    parts that make up the headers determine the behavior of different elements within
    the web architecture (browser, network, web server, server-side language, and
    framework).
  prefs: []
  type: TYPE_NORMAL
- en: For example, an element such as a hostname is useful to the DNS (network) to
    be able to resolve the hostname into the IP address. Knowing this is useful in
    deciding whether to do caching, for example, for name resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Each element involved has its own characteristics that can be optimized to be
    able to get better performance.
  prefs: []
  type: TYPE_NORMAL
- en: One of the characterizing elements of a typical request to a classic PHP application
    is that each request is independent of any other request. This means that if your
    PHP script instantiates an object, this operation is repeated with each request.
    This has little impact if your script is called only a few times and your script
    is simple.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try to think of a scenario in which we have a framework-based application,
    with the application having to deal with a high load of concurrent requests.
  prefs: []
  type: TYPE_NORMAL
- en: A framework-based application has numerous objects at its disposal, which must
    be instantiated and configured at startup. In the classic case of PHP, the startup
    of the framework corresponds to a request.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel Octane, on the other hand, introduces a new way of starting the application.
  prefs: []
  type: TYPE_NORMAL
- en: In a classic Laravel web application, it is sufficient to have a web server
    (such as nginx) or the internal web server provided by Laravel in the case of
    development on the developer’s local computer. A classic web server can handle
    requests without any kind of resource-sharing unless these resources are external
    resources such as a database or a cache manager.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to what happens with a classic web server, an application server
    has the task of starting and managing the executions of multiple workers. Each
    worker will be able to handle multiple requests by reusing objects and parts of
    the logic of your application.
  prefs: []
  type: TYPE_NORMAL
- en: This has one benefit, which is that the actual startup of your application and
    the setting up of the various objects occur on the first request received from
    the worker and not on each individual request.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP requests and Laravel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the Laravel application perspective, the parts involved directly in the
    HTTPS requests are typically routes and controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Handling a request through a Laravel application typically means having to
    implement the routing part and implement the logic to manage the request in the
    controller. Routing allows us to define which code to execute within our Laravel
    application against a specific path in the URL. For example, we might want to
    define that the code of a method in a specific class such as `HomeController::home()`
    must be invoked against a request that has a `/home` path in the URL. In the classic
    Laravel definition, we would write something like this in the `routes/web.php`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have to implement the logic to manage the request in the `HomeController`
    class (that we have to create) and implement the `home` method. So, in a new `app/Http/Controllers/HomeController.php`
    file, you have to implement the `HomeController` class extending the basic controller
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have an understanding of how web servers handle requests, let us
    learn more about the application servers that Laravel Octane integrates with.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the application server for Laravel Octane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the PHP ecosystem, we have several application servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Laravel Octane, which handles server configuration, startup, and execution,
    integrates mainly with two of them: Swoole and RoadRunner.'
  prefs: []
  type: TYPE_NORMAL
- en: We will deal with the installation, configuration, and use of these two application
    servers in detail later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, it is enough for us to know that once the application servers are
    installed, Laravel Octane will take care of their management. Laravel Octane will
    also take care of their proper startup via the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `octane:serve` command is added when Laravel Octane is installed.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, Laravel Octane has a strong dependency on application servers
    such as RoadRunner or Swoole.
  prefs: []
  type: TYPE_NORMAL
- en: 'At startup, Laravel Octane via Swoole or RoadRunner activates some workers,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: The activation of workers](img/Figure_1.1_B17728.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: The activation of workers'
  prefs: []
  type: TYPE_NORMAL
- en: What are workers?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Octane, a **worker** is a process that takes charge of handling the requests
    associated with it. A worker has the responsibility of starting the framework
    and initializing framework objects.
  prefs: []
  type: TYPE_NORMAL
- en: This has an extremely positive impact from a performance standpoint. The framework
    is instantiated on the first request assigned to the worker. The second (and subsequent)
    requests assigned to that worker reuse the objects already instantiated. The side
    effect of this is that the worker shares instances of global objects and static
    variables between requests. This means that different calls to the controller
    can access the data structures that are shared between requests.
  prefs: []
  type: TYPE_NORMAL
- en: To complicate matters, there is the fact that requests assigned to the same
    worker share a global state, but different workers are independent and have scope
    independent of each other. So, we can say that not all requests share the same
    global state. Requests share a global state when associated with the same worker.
    Two requests from two different workers share nothing.
  prefs: []
  type: TYPE_NORMAL
- en: In order to minimize the side effect, Laravel Octane has the responsibility
    of managing the reset of classes/objects owned directly by the framework across
    the requests.
  prefs: []
  type: TYPE_NORMAL
- en: However, Octane can’t manage and reset classes owned directly by the application.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why the main thing to pay attention to when using Octane is the scope
    and lifecycle of variables and objects.
  prefs: []
  type: TYPE_NORMAL
- en: To understand this better, I will give you a very basic example.
  prefs: []
  type: TYPE_NORMAL
- en: Example with a shared variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This example, in the `routes/web.php` file, creates a route for `path /` and
    returns a human-readable timestamp. To simplify the explanation, we are going
    to write the logic directly into the route file instead of calling and delegating
    the logic to a controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the `routes/web.php` routing file (`web.php` is already stored in the `routes`
    directory in the Laravel root folder project), a `$myStartTime` variable is instantiated
    and assigned the current time expressed in milliseconds. This variable is then
    inherited by the `route/management` function via the `use` clause.
  prefs: []
  type: TYPE_NORMAL
- en: In the performance of the function associated with `route/`, the contents of
    the `$myStartTime` variable are returned and then displayed.
  prefs: []
  type: TYPE_NORMAL
- en: With the classic behavior of the Laravel application, at each invocation/execution,
    the variable is regenerated and reinitialized (each time with a new value).
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the Laravel application in the classic mode, simply run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the web server is started, go to the following URL via the browser: `http://127.0.0.1:8000`'
  prefs: []
  type: TYPE_NORMAL
- en: By continuously reloading the page, a different value is displayed each time;
    basically, the timestamp is displayed with each request.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using the development web server provided by Laravel, you would use
    Laravel Octane and have a different result. At each page refresh (reloading of
    the web page), you would always see the same value. The value is relative to the
    timestamp of the first request served. This means that the variable is initialized
    with the first request and then the value is reused across the requests.
  prefs: []
  type: TYPE_NORMAL
- en: If you try to refresh multiple times, in some cases, you could see a new value.
  prefs: []
  type: TYPE_NORMAL
- en: If this happens, it means that the request was managed by the second (or a new)
    worker. This means that this behavior is quite unpredictable because Octane acts
    as a load balancer. When a request comes from the network, the application server
    will decide which worker (of those available) to assign the request to.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, another element that could cause a new value to be generated
    is when you hit the maximum number of requests managed by a single worker. We
    will see how to define the maximum number of requests later, and in general, we
    will have a deep dive session (in *Chapters 2* and *3*) into Laravel Octane configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior whereby variables are shared across workers until the application
    server is restarted is valid only for global variables or objects stored in the
    application service container. The local variables (the variables for which the
    scope is limited to a function or a method) are not affected.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the code previously shown, I’m going to declare a `$myLocalStartTime`
    variable in the function called by the routing mechanism. The scope of the `$myLocalStartTime`
    variable and its lifecycle is limited to the `Closure` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following command with the classic Laravel web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You will see that both values will change on each new request. You can see that
    when you open a browser to `http://127.0.0.1:8000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch Octane as a server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You will see, in your browser at `http://127.0.0.1:8000`, two different dates/times
    with milliseconds. If you refresh the page, you will see a change in just the
    second one (`$myLocalStartTime`).
  prefs: []
  type: TYPE_NORMAL
- en: You have to be aware of this behavior when you are building an application based
    on Octane.
  prefs: []
  type: TYPE_NORMAL
- en: Another example to better understand this behavior is creating a class with
    a static property.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class with a static property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to keep this example as simple as possible, I created a `MyClass` class
    in the `routes/web.php` file.
  prefs: []
  type: TYPE_NORMAL
- en: I’m going to add new routes that call the `add()` method of the `MyClass` object
    and then call and return the value of the static property retrieved by the `get()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `routes/web.php`, add the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `routes/web.php` file, declare the new route as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can launch Laravel in a classic way using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you access the URL `http://127.0.0.1:8000/static-class` multiple times,
    the value `1` will be shown. This is because, classically, for every request,
    the `MyClass` object is instanced from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch Laravel Octane using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you then access the URL `http://127.0.0.1:8000/static-class` multiple times,
    you will see the value `1` in the first request, `2` in the second, `3` in the
    third, and so on. This is because, with Octane, `MyClass` is instanced for every
    request, but the static values are kept in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a non-static property, we can see the difference as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After calling the page five times, the result shown in the browser will be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is quite simple but, in the end, good for understanding the behavior of
    static variables under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: The use of static variables is not so unusual. Just think of singleton objects
    or the app container of Laravel.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid unexpected behavior – as in this specific example with static variables
    but more generally, with global objects (Laravel makes extensive use of them)
    – explicit re-initialization must be taken care of. In this case, the static variable
    is initialized in the constructor. My suggestion is to use explicit initialization
    of the properties in the constructor. This is because it is the developer’s responsibility
    to take care of the re-initialization of the variables in the case of global states
    (objects and variables).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have seen just some very basic examples of the impact on the code if you
    are going to install and use Laravel Octane. The examples shown earlier were purposely
    very simple, but with the goal of being easy to understand. In the chapter where
    we will use Octane in a real scenario, we will cover more realistic examples.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will analyze the impact on performance. So, by installing Octane, what
    kind of improvement could we have in terms of performance?
  prefs: []
  type: TYPE_NORMAL
- en: Understanding performance measurement in Laravel Octane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have said that introducing Laravel Octane in your application allows for
    a performance boost, mainly because the objects and the various instances of the
    classes used by the framework are no longer initialized at every single HTTP request
    but at the start of the application server. As a result, for each HTTP request,
    framework objects are reused. Reusing framework objects saves time in serving
    the HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: While, on a logical and understandable level, this can have a positive impact
    in terms of performance, the goal of this part is to get pragmatic feedback on
    this performance boost by trying to recover some metrics and values.
  prefs: []
  type: TYPE_NORMAL
- en: In order to provide a rough indication of the benefits and improved response
    time performance for a request, let us try to perform a simple performance test.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we are going to install a tool to generate and execute some HTTP-concurrent
    requests. There are several such tools, one of which is **wrk** ([https://github.com/wg/wrk](https://github.com/wg/wrk)).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a macOS environment, you could use the `brew` command (provided
    by Homebrew) to install the `wrk` tool. To install the tool, use `brew install`
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With `wrk`, you can generate concurrent requests for a defined amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will conduct two tests for comparison: one test will be conducted with a
    classical web application on nginx (`http://octane.test`), and the other one with
    an application served by an application server on Laravel Octane (http://octane.test:8000).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two URLs are resolved as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://octane.test/` is resolved with local address `127.0.0.1` and will reply
    nginx'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://octane.test:8000/` is resolved with local address `127.0.0.1` and port
    `8000` is bound by Swoole'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `wrk` execution will use 4 threads, open 20 connections, and take 10 seconds
    of tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to test NGINX, launch the `wrk` command with these arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To test Laravel Octane (RoadRunner), use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This test is very basic because there are no special server-side logic or query
    databases involved, but it is good to run the test to understand the raw difference
    in bootstrapping basic objects for Laravel (application container, requests, etc.)
    and perceive their flavor.
  prefs: []
  type: TYPE_NORMAL
- en: The difference is not so great (7,196 requests versus 5,612 requests) – around
    22% – but consider that this difference grows if you add new packages and libraries
    (more code to be bootstrapped for each request).
  prefs: []
  type: TYPE_NORMAL
- en: Consider also that RoadRunner and Swoole provide other additional tools for
    improving performances such as enabling concurrency and executing concurrent tasks.
    The additional tools will be shown later in *Chapters 2* and *3*.
  prefs: []
  type: TYPE_NORMAL
- en: To better explain why Laravel Octane allows you to achieve this improvement,
    let me demonstrate how and when service providers are instanced and loaded into
    a service container.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, in a classic Laravel application service, providers are loaded in
    each request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new service provider named `MyServiceProvider` in the `app/Providers`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The new service provider simply shows a message when the service provider is
    created, registered, and booted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lifecycle of a service provider starts with three phases: creation, registration,
    and boot.'
  prefs: []
  type: TYPE_NORMAL
- en: The `register()` and `boot()` methods are needed for *dependency resolution*.
    First of all, every service provider is registered. Once they are all registered,
    they could be booted. If a service provider needs another service in the `boot`
    method, you can be sure that it is ready to be used because it is already registered.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you have to register the service provider, so in `config/app.php` in the
    `providers` array, add `App\Providers\MyServiceProvider::class`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a classical Laravel web application, for every HTTP request, the `MyServiceProvider`
    service provider is instanced, and the `construct`, `register`, and `boot` methods
    are called every time, showing this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With Laravel Octane, something different happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a better understanding, we are going to launch the Laravel Octane server
    with two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`workers`: The number of workers that should be available to handle requests.
    We are going to set this number to `2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max-requests`: The number of requests to process before reloading the server.
    We are going to set this number to a maximum limit of `5` for each worker.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To start the Octane server with two workers and reload the server after processing
    five requests, we enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After launching Octane, try to perform more than one request with the browser
    accessing this URL: `http://127.0.0.1:8000`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first 2 requests take around 100 `register()` and `boot()` methods are called
    on the first two requests.
  prefs: []
  type: TYPE_NORMAL
- en: So we can see the first two requests (two because we have two workers) are a
    bit slower (113.62 ms and 85.49 ms) than the next requests (from the third to
    the tenth request, where we have a response time of less than 10 ms).
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to mention is that the `register` and `boot` methods
    are called for the first two requests until the tenth request (two workers multiplied
    by five max requests). This behavior is repeated for subsequent requests.
  prefs: []
  type: TYPE_NORMAL
- en: And so, installing Laravel Octane in your web application allows you to improve
    the response time of your application.
  prefs: []
  type: TYPE_NORMAL
- en: All this without having involved certain tools such as concurrency management
    provided by application servers such as Swoole and RoadRunner.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have an overview of the behavior, some benefits, and some side
    effects of Laravel Octane, we can proceed with the next chapter by installing
    and configuring one of the two Laravel Octane-compatible application servers:
    the RoadRunner application server.'
  prefs: []
  type: TYPE_NORMAL
- en: We will revisit some of the instructions addressed in this chapter. The goal
    of this chapter was to provide some useful summary elements to address the more
    specific and detailed cases in the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: The Application Server'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Laravel Octane uses an application server such as RoadRunner or Swoole. Running
    the application in an application server instead of a classical web server allows
    the developer to use some advanced features such as managing multiple workers,
    concurrent tasks, and bootstrap applications in a more efficient way; fast caching,
    and sharing data across the workers. This part comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 2*](B17728_02.xhtml#_idTextAnchor036), *Configuring the RoadRunner
    Application Server*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B17728_03.xhtml#_idTextAnchor048), *Configuring the Swoole Application
    Server*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
