<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer076">
			</div>
		</div>
		<div class="Content" id="_idContainer077">
			<h1 id="_idParaDest-120"><a id="_idTextAnchor126"/>4. Functions</h1>
		</div>
		<div class="Content" id="_idContainer095">
			<p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to work with built-in functions; create user-defined functions; and write anonymous functions.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor127"/>Introduction</h1>
			<p>When writing software, we often run into situations where we need to do a specific task in different places within the application that we are building. Without thinking about it, it can be easy to fall into the habit of rewriting the same code over and over again, causing code repetition and making it harder to debug errors when they show up. However, as with all other programming languages, PHP gives you the ability to structure reusable code in what is known as a <strong class="bold">function</strong>, which is also sometimes referred to as a method. These two terms will be used interchangeably throughout this chapter.</p>
			<p>Think of a function as a reusable set of instructions or statements. After writing it once, you can call it as many times as you like. Functions bundle logic that should otherwise be kept inseparably together.</p>
			<p>Grouping and isolating a set of instructions inside a function comes with a number of benefits. The most obvious one is the option to reuse it: once you have written your function, you never need to rewrite or reinvent this particular set of instructions again. Functions also improve consistency – this means that each time you call your function, you can be sure the same set of instructions will be applied. </p>
			<p>Another less obvious benefit is that your code becomes much more readable, especially when you name your functions so that it is clear what they do. </p>
			<p>Another good thing about a function is that it encloses local variables within its scope, so that they do not pollute the global scope. We will discuss scope in more detail later. </p>
			<p>Here's an example of a simple function:</p>
			<p class="source-code">// simplest callable is a function</p>
			<p class="source-code">function foo()</p>
			<p class="source-code">{</p>
			<p class="source-code">}</p>
			<p>Here's a function that has been written to calculate the average of the values passed to this function:</p>
			<p class="source-code">// function that calculates the average of values that you pass to it</p>
			<p class="source-code">function average()</p>
			<p class="source-code">{</p>
			<p class="source-code">    $count = func_num_args();</p>
			<p class="source-code">    $total = 0;</p>
			<p class="source-code">    foreach (func_get_args() as $number) {</p>
			<p class="source-code">        $total += $number;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return $total / $count;</p>
			<p class="source-code">}</p>
			<p>Note that this is not production-ready code. The function does not check anything about its inputs and does not prevent error conditions, such as division by zero, if you do not pass any arguments. The <strong class="source-inline">function-average.php</strong> file contains a more elaborate example of the same function for you to refer to on the GitHub repository.</p>
			<p>A function is <strong class="bold">callable</strong>. However, note that not all callables are functions. Functions can call other functions, functions can pass functions around to other functions to be called by them, and functions can create functions. Confused? Read on and look at the examples and you will see that it is not complicated at all.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor128"/>What is a Callable?</h1>
			<p>Simply put, a callable is a part of your code that you can "call". When we say that you can "call" something, we mean that you can tell the program to execute it.</p>
			<p>A callable can be written with parentheses after it, for example, <strong class="source-inline">functionName()</strong>.</p>
			<p>As previously described, a function is a type of callable, so a function can be called (that is, you can tell your program to execute it). </p>
			<p>As an example, consider the following user-defined function:</p>
			<p class="source-code">function howManyTimesDidWeTellYou(int $numberOfTimes): string</p>
			<p class="source-code">{</p>
			<p class="source-code">    return "You told me $numberOfTimes times";</p>
			<p class="source-code">}</p>
			<p>Do not worry about the details of the function right now—we will get into the nitty-gritty of it later. This function could be defined anywhere in your code, but let's assume that it is defined in a script called <strong class="source-inline">how-many-times-did-we-tell-you.php</strong>.</p>
			<p>The contents of the script would then look like this:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">declare(strict_types=1);</p>
			<p class="source-code">function howManyTimesDidWeTellYou(int $numberOfTimes): string</p>
			<p class="source-code">{</p>
			<p class="source-code">    return "You told me {$numberOfTimes} times";</p>
			<p class="source-code">}</p>
			<p>The function takes a single parameter, <strong class="source-inline">$numberOfTimes</strong>, which must be of the <strong class="source-inline">int</strong> (integer) type, and it returns a string. The <strong class="source-inline">int</strong> type hint and the <strong class="source-inline">string</strong> return type are optional. We will discuss parameters and returning values later in the chapter. Now, <strong class="source-inline">function howManyTimesDidWeTellYou(int $numberOfTimes): string</strong> is just the function declaration: it defines the function. The script itself does nothing yet.</p>
			<p>In order to enable the function to actually do something, we need to call it from our code. It is perfectly valid to continue in the same script file and call the function that we just defined as follows:</p>
			<p class="source-code">howManyTimesDidWeTellYou(1);</p>
			<p>If you open a Terminal and execute the script, you will see no output. Why not? The reason is that while the function does return a string, it does not print any output. To generate output, you need to <strong class="source-inline">echo</strong> the return value of the function as follows:</p>
			<p class="source-code">echo howManyTimesDidWeTellYou(1);</p>
			<p>Now you will see output if you execute the script.</p>
			<p>Execute the script by calling it from the command line in the directory where the script lives. You can simply type the following text and press <em class="italic">Enter</em>:</p>
			<p class="source-code">php how-many-times-did-we-tell-you.php </p>
			<p>The output is as follows:</p>
			<p class="source-code">You told me 1 times</p>
			<p>You will immediately spot a problem with this output: it is grammatically incorrect. And what if we were to pass a negative integer? Then, the output would be even logically incorrect. Our function is not production-ready at this point.</p>
			<p>A more elaborate example of the function and how it can be called is to be found in the <strong class="source-inline">how-many-times-did-we-tell-you.php</strong> file.</p>
			<p>Note that it is possible to print text from within functions by using <strong class="source-inline">echo</strong> inside a function. However, this makes the function less reusable as it will generate output as soon as it is called. In some cases, you might want to delay output. For example, you may be collecting and combining strings before you output them, or you may want to store the string in a database and don't want to display it at this stage. Although printing directly from within a function is generally considered bad practice, you will see it a lot in systems such as WordPress. Printing from a function can be convenient in a context where generating output is the most important task.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor129"/>Exercise 4.1: Using Built-in Functions</h2>
			<p>This exercise is about string manipulation. PHP has many built-in string manipulation functions. The one we will be using here is <strong class="source-inline">substr()</strong>. Like most other built-in functions, the behavior of <strong class="source-inline">substr()</strong> can be tweaked by passing various parameters:</p>
			<ol>
				<li>Create a new directory called <strong class="source-inline">Chapter04</strong>. Then, inside it, create a folder named <strong class="source-inline">exercises</strong>.</li>
				<li>Create a file called <strong class="source-inline">hello.php</strong> in the <strong class="source-inline">Chapter04/exercises</strong> directory.</li>
				<li>Write the opening script tag:<p class="source-code">&lt;?php</p><p>The opening tag tells the parser that, from this point onward, what we write is PHP.</p></li>
				<li>Write the instruction that extracts and prints "Hello" from "Hello World" using <strong class="source-inline">substr()</strong>:<p class="source-code">echo substr('Hello World', 0, 5);</p><p>The <strong class="source-inline">echo</strong> command prints the result of the statement that comes after it. The statement calls the <strong class="source-inline">substr</strong> function with three arguments: the literal string, <strong class="source-inline">Hello World</strong>, and the literal integers <strong class="source-inline">0</strong> and <strong class="source-inline">5</strong>. What this says is "<em class="italic">give me the five characters of the input string starting from 0</em>". In PHP, you can think of a string as almost like an array, where each character in that string is an element. Like in many other programming languages, array indices start at zero instead of one. If you count the characters, you will see that <strong class="source-inline">H e l l o</strong> are the first five characters of the <strong class="source-inline">Hello World</strong> input string. They are returned from the function as a new string of five characters.</p></li>
				<li>Optionally, on the next line, <strong class="source-inline">echo</strong> a newline, only for clarity of the output:<p class="source-code">echo PHP_EOL;</p><p><strong class="source-inline">PHP_EOL</strong> is a predefined constant that outputs a newline in the correct format for the operating system you are on. Using this constant makes your code more portable between different operating systems.</p></li>
				<li>Open a Terminal and go to the <strong class="source-inline">Chapter04/exercises</strong> directory where your <strong class="source-inline">hello.php</strong> script is placed and execute the file using the following code:<p class="source-code">php hello.php</p><p>Observe that <strong class="source-inline">Hello</strong> and a newline are printed in the Terminal; this is what the output looks in the Terminal:</p><div class="IMG---Figure" id="_idContainer078"><img alt="Figure 4.1: Printing the output to the Terminal&#13;&#10;" src="image/C14196_04_01.jpg"/></div><p class="figure-caption">Figure 4.1: Printing the output to the Terminal</p><p class="callout-heading">Note </p><p class="callout">Don't worry if your path differs from that of the screenshot as this will depend on your system settings.</p></li>
				<li>Now change the code to the following:<p class="source-code">echo substr('Hello World', 5);</p><p>Run the script again and notice the output is now <strong class="source-inline">World</strong> (notice the space at the start). What happened is that the substring is now taken from position 5 (the sixth character, the space), to the end of the string.</p></li>
				<li>Change the code to:<p class="source-code">echo substr('Hello World', -4, 3);</p><p>Run the script and notice the output will be <strong class="source-inline">orl</strong>. What happens is that now the start is negative and counted backward from the end of the string. The length is <strong class="source-inline">3</strong> and taken toward the end of the string from the start:</p><div class="IMG---Figure" id="_idContainer079"><img alt="Figure 4.2: Printing the sliced string&#13;&#10;" src="image/C14196_04_02.jpg"/></div><p class="figure-caption">Figure 4.2: Printing the sliced string</p><p>In the preceding screenshot, you can see the output from <em class="italic">step 8</em>. The output looks this way because I used a scratch file in PhpStorm. I added a new scratch file and just quickly pasted the code into it and ran it using the green play button in PhpStorm. Scratch files are a way of quickly testing some code in files while the files are not added to your project.</p></li>
				<li>Change the statement to the following:<p class="source-code">echo substr('ideeën', -3);</p><p class="callout-heading">Note</p><p class="callout"><strong class="source-inline">Ideeën</strong> is a Dutch word that means "ideas." However, for this example, we need the <strong class="source-inline">ë</strong> character, so we can't just type "ideas."</p><p>Run the script again and notice that the output is <strong class="source-inline">ën</strong>. If you have been paying attention so far, you should have expected the output to be <strong class="source-inline">eën</strong>: it is three characters long, counted from <strong class="source-inline">start = -3</strong>, and counted backward from the end of the string until the end of the string. So, why is the output two characters long in this case and not three? The explanation is that <strong class="source-inline">ë</strong> is a multibyte character. If you need to check whether a string is UTF-8-encoding, you can use an additional built-in function called <strong class="source-inline">mb_detect_encoding</strong>, passing the string as the first parameter and UTF-8 as the second parameter. The <strong class="source-inline">substr</strong> method just counts bytes and does not account for characters that are multiple bytes in length. Now, there is a solution for that: <strong class="source-inline">mb_substr</strong>. In fact, for many string manipulation functions, there are sister functions that are prefixed with <strong class="source-inline">mb_</strong> to indicate that they support multibyte characters. If you always use the <strong class="source-inline">mb_</strong> versions of these methods, you will get the expected results.</p></li>
				<li>Change the statement to the following:<p class="source-code">echo mb_substr('ideeën', -3);</p><p>Run the script once more and notice that now you get the expected output of <strong class="source-inline">eën</strong>:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer080">
					<img alt="Figure 4.3: Printing the output of the sliced strings&#13;&#10;" src="image/C14196_04_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3: Printing the output of the sliced strings</p>
			<p>Remember to always use the <strong class="source-inline">mb_*</strong> versions of string manipulation functions.</p>
			<p>In this section, we were introduced to callables and started to get a glimpse of the built-in functions that are available to us. Next, we are going to dive a little deeper into the types of callables.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor130"/>Types of Callables</h2>
			<p>There are several types of callables:</p>
			<ul>
				<li>Functions, such as <strong class="source-inline">mb_strtoupper</strong>.</li>
				<li>Anonymous functions or closures.</li>
				<li>Variables that hold the name of a function.</li>
				<li>An array with two elements, where the first element is the object and the second element is the name of the function you wish to call that exists within the object written as a string. An example of this can be found in the <strong class="source-inline">callables.php</strong> document. </li>
				<li>An object that has the <strong class="source-inline">__invoke</strong> magic method defined.</li>
			</ul>
			<p>The <strong class="source-inline">__invoke</strong> method is a magic function that can be attached to classes that when initialized to a variable will make that assigned variable into a callable function. Here's a simple example of the <strong class="source-inline">__invoke</strong> method:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">// Defining a typical object, take note of the method that we defined</p>
			<p class="source-code">class Dog {</p>
			<p class="source-code">    public function __invoke(){</p>
			<p class="source-code">    echo "Bark";</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">// Initialize a new instance of the dog object</p>
			<p class="source-code">$sparky = new Dog();</p>
			<p class="source-code">// Here's where the magic happens, we can now call this </p>
			<p class="source-code">$sparky(); </p>
			<p>The output is as follows:</p>
			<p class="source-code">Bark</p>
			<p>In the preceding example, we declared a <strong class="source-inline">$sparky</strong> object and executed this object as a function by calling it <strong class="source-inline">$sparky()</strong>. This function, in turn, invoked its primary action and printed the result.</p>
			<p>To verify whether something is a callable, you can pass it to the built-in <strong class="source-inline">is_callable</strong> function. This function will return <strong class="source-inline">true</strong> if its first argument is a callable and <strong class="source-inline">false</strong> if not. The <strong class="source-inline">is_callable</strong> function actually takes up to three arguments that tweak the behavior of <strong class="source-inline">is_callable</strong>.</p>
			<p>Try out the following example:</p>
			<p class="source-code">// simplest callable is a function</p>
			<p class="source-code">function foo()</p>
			<p class="source-code">{</p>
			<p class="source-code">}</p>
			<p class="source-code">echo is_callable('foo') ? '"foo" is callable' : '"foo" is NOT a callable',   PHP_EOL;</p>
			<p class="source-code">// an anonymous function is also a callable</p>
			<p class="source-code">if (true === is_callable(function () {})) {</p>
			<p class="source-code">    echo 'anonymous function is a callable';</p>
			<p class="source-code">} else {</p>
			<p class="source-code">    echo 'anonymous function is NOT a callable';</p>
			<p class="source-code">}</p>
			<p>You can explore more examples in the <strong class="source-inline">callables.php</strong> script on the GitHub repository.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor131"/>Language Constructs</h1>
			<p><strong class="bold">Language constructs</strong> are things that the PHP parser already knows about. Some language constructs act like functions, while others are used to build control statements such as <strong class="source-inline">if</strong> and <strong class="source-inline">while</strong>. Language constructs that act like functions look very much like built-in functions in the way they are used. If you want to print a string, you can choose to use <strong class="source-inline">echo</strong>, which is a language construct; or <strong class="source-inline">print</strong>, which is also a language construct. There are small differences between <strong class="source-inline">echo</strong> and <strong class="source-inline">print</strong>, and <strong class="source-inline">echo</strong> is the most commonly used. When comparing the two, <strong class="source-inline">echo</strong> doesn't have a return value and has the option of multiple parameters, whereas <strong class="source-inline">print</strong> returns a value that can be used in an expression and allows only one parameter. <strong class="source-inline">echo</strong> is the most flexible of the two and is a tiny bit faster. Language constructs can be used with or without parentheses. In contrast, callables are always used with parentheses:</p>
			<p class="source-code">// echo is a language construct</p>
			<p class="source-code">echo 'hello world'; // echo does not return a value</p>
			<p class="source-code">// print is also a language construct</p>
			<p class="source-code">print('hello world'); // print returns 1</p>
			<p>Both statements print <strong class="source-inline">hello world</strong>. A language construct has a more efficient underlying implementation in C than a function and thus will execute faster. You can use parentheses with <strong class="source-inline">echo</strong> and <strong class="source-inline">print</strong>, but it is not mandatory.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor132"/>Introduction to Built-In Functions</h1>
			<p>PHP comes with many built-in functions, such as <strong class="source-inline">strtoupper</strong>, which changes the case of an input string to uppercase:</p>
			<p class="source-code">echo strtoupper('Foo');</p>
			<p class="source-code">// output: FOO</p>
			<p>PHP natively comes with a ton of functions. By adding extensions to PHP, you add even more built-in functions and classes to it. Built-in functions are precompiled in C as this is the language that PHP and its extensions are written in.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">How to add an extension will differ depending on which operating system you are on. So, when searching for it, always add the name of your operating system to your search and be sure to consult the most recent results first, as they are more likely to outline the correct procedure for installing or compiling extensions into PHP.</p>
			<p>There is hardly anything more frustrating than spending days on writing some functionality, only to discover toward the end that there is a built-in function that does the same thing five times faster. So, before writing functionality yourself, try to google or search <a href="https://packt.live/2OxT91A">https://packt.live/2OxT91A</a> for built-in functions. If you are using an IDE, built-in functions will be suggested by autocomplete as soon as you start typing in a PHP document. PHP is often called a glue language: it is used to tie different systems together. Therefore, there is a wealth of functions that talk to databases, file resources, network resources, external libraries, and so on. </p>
			<p>If you are using a function that is provided by an extension that is not installed or compiled with your PHP version, you will get an error. For example, calling <strong class="source-inline">gd_info()</strong> when <strong class="source-inline">GD</strong> is not installed results in <strong class="source-inline">Fatal error: Uncaught Error: Call to undefined function gd_info()</strong>. By the way, <strong class="source-inline">GD</strong> is a library used for image manipulation.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">On a side note, in many real-life projects, we handle multibyte strings. When handling multibyte strings, you should be using the multibyte-safe string manipulation functions. Instead of <strong class="source-inline">strtoupper</strong>, you would be using <strong class="source-inline">mb_strtoupper</strong>. </p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor133"/>Finding Built-In Functions</h2>
			<p>To find out which version of PHP you are currently using, open up a Terminal, type the following command, and then hit <em class="italic">Enter</em>:</p>
			<p class="source-code">php -v </p>
			<p>To find out what extensions are installed on your system, type the following command and hit <em class="italic">Enter</em>: </p>
			<p class="source-code">php -m</p>
			<p>This will list all extensions currently installed and enabled in your PHP installation. You can also list the extensions using the built-in <strong class="source-inline">get_loaded_extensions</strong> PHP function.</p>
			<p>To make use of that, write a file called <strong class="source-inline">list-extensions.php</strong> with the following content:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">print_r(get_loaded_extensions());</p>
			<p>Execute the file from the command line as follows:</p>
			<p class="source-code">php list-extensions.php</p>
			<p>Note that if you do this, you will have used two built-in functions: <strong class="source-inline">print_r</strong> and <strong class="source-inline">get_loaded_extensions</strong>. The <strong class="source-inline">print_r()</strong> function prints its first argument in human-readable form. You can use the second argument, a <strong class="source-inline">true</strong> Boolean value, to return the output instead of printing it on the screen. That way, you can write it to a log file, for example, or pass it on to another function.</p>
			<p>The output should look like the following screenshot (note that the extensions may vary on your system):</p>
			<div>
				<div class="IMG---Figure" id="_idContainer081">
					<img alt="Figure 4.4: Listing the extensions&#13;&#10;" src="image/C14196_04_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4: Listing the extensions</p>
			<p>Another function that you may find useful while exploring the built-in functions and the extensions is <strong class="source-inline">get_extension_funcs ( string $module_name ) : array</strong>, which you can use to list the functions that an extension provides. Often, it will be easier to find the functions in the documentation of the extension. </p>
			<p>Here is the top part of the output:</p>
			<p class="source-code">print_r(get_extension_funcs('gd'));</p>
			<p>The output is as follows:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer082">
					<img alt="Figure 4.5: Listing the top extensions&#13;&#10;" src="image/C14196_04_05.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5: Listing the top extensions</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can find more information about built-in functions at <a href="https://packt.live/2oiJPEl">https://packt.live/2oiJPEl</a>.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor134"/>Parameters and Return Values</h2>
			<p>Parameters are the variables written within the function declaration. Arguments are the values that you pass as these parameters. Return values are the values that the function returns when it has completely executed. In the previous example, <strong class="source-inline">get_loaded_extensions</strong> was called without any arguments: there was nothing between the braces after <strong class="source-inline">get_loaded_extensions</strong>. </p>
			<p>The return value of <strong class="source-inline">get_loaded_extensions()</strong> is an array of extensions loaded into PHP – extensions that are installed and enabled. That return value was used as an argument to <strong class="source-inline">print_r</strong>, which returned a user-friendly string describing its input. To clarify this, the <strong class="source-inline">list-extensions.php</strong> script could be rewritten as follows:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">// get_loaded_extensions is called without arguments</p>
			<p class="source-code">// the array returned from it is stored in the variable $extensions</p>
			<p class="source-code">$extensions = get_loaded_extensions();</p>
			<p class="source-code">// the variable $extensions is then offered as the first argument to print_r</p>
			<p class="source-code">// print_r prints the array in a human readable form</p>
			<p class="source-code">print_r($extensions);</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor135"/>Passing Parameters by Reference</h2>
			<p>Parameters that are objects are always passed by reference. We will go into further detail about objects in <em class="italic">Chapter 5</em>, <em class="italic">Object Oriented Programming</em>, but to give you a little bit of context, think of an object as a container that contains scoped variables and functions. This means that an address in memory where that object exists is passed into the function so the function can find the actual object internally when it needs it. If the function modifies the referenced object, then the original object that is held in memory will reflect those changes. If you want a copy of the object to work on instead, you need to clone the object with the <strong class="source-inline">clone</strong> keyword before working on it. You can think of a clone as a copier that will make an exact copy of the object you want to duplicate. </p>
			<p>An example of the use of the <strong class="source-inline">clone</strong> keyword can be found here:</p>
			<p class="source-code">$document = new Document();</p>
			<p class="source-code">$clonedDocument = clone $document;</p>
			<p>If the modified copy is required outside the function, you can choose to return it from the function. In the following example, <strong class="source-inline">$document</strong> becomes a variable that contains an object reference to a <strong class="source-inline">DomDocument</strong> object:</p>
			<p class="source-code">$document = new DomDocument();</p>
			<p>With scalar variable parameters, it is the programmer of the function who decides whether a parameter is passed by reference or as a copy of the original value. Note that only variables can be passed by reference. </p>
			<p>A scalar variable is a variable that holds a scalar value, such as <strong class="source-inline">$a</strong> in the following example:</p>
			<p class="source-code">$a = 10;</p>
			<p>As opposed to just <strong class="source-inline">10</strong>, which is an integer value, scalars can be numbers, strings, or arrays.</p>
			<p>If you pass a literal scalar value to a function that expects a reference, you will get an error stating that only variables can be passed by reference. This is because the PHP parser holds no references to scalars – they are just themselves. It is only when you assign a scalar to a variable that a reference to that variable will exist internally.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor136"/>Passing Scalar Variables by Reference</h2>
			<p>PHP has many functions that work on arrays. They differ a lot as to whether they take the array as a reference or not.</p>
			<p>Take the following array:</p>
			<p class="source-code">$fruits = [</p>
			<p class="source-code">    'Pear',</p>
			<p class="source-code">    'Orange',</p>
			<p class="source-code">    'Apple',</p>
			<p class="source-code">    'Banana',</p>
			<p class="source-code">];</p>
			<p>The built-in <strong class="source-inline">sort()</strong> function will sort the preceding fruits in alphabetical order. The array is passed by reference. So, after calling <strong class="source-inline">sort($fruits);</strong>, the original array will be in alphabetical order:</p>
			<p class="source-code">sort($fruits);</p>
			<p class="source-code">print_r($fruits);</p>
			<p>The output should be as follows:</p>
			<p class="source-code">Array</p>
			<p class="source-code">(</p>
			<p class="source-code">    [0] =&gt; Apple</p>
			<p class="source-code">    [1] =&gt; Banana</p>
			<p class="source-code">    [2] =&gt; Orange</p>
			<p class="source-code">    [3] =&gt; Pear</p>
			<p class="source-code">)</p>
			<p>As opposed to passing by reference, <strong class="source-inline">array_reverse</strong> works on a copy of the array passed into it and returns it with its elements in reverse order:</p>
			<p class="source-code">$reversedFruits = array_reverse($fruits);</p>
			<p class="source-code">// the original $fruits is still in the original order</p>
			<p class="source-code">print_r($reversedFruits);</p>
			<p>The output is as follows:</p>
			<p class="source-code">Array</p>
			<p class="source-code">(</p>
			<p class="source-code">    [0] =&gt; Banana</p>
			<p class="source-code">    [1] =&gt; Apple</p>
			<p class="source-code">    [2] =&gt; Orange</p>
			<p class="source-code">    [3] =&gt; Pear</p>
			<p class="source-code">)</p>
			<p>For more elaborate examples, you can refer to <strong class="source-inline">array-pass-by-reference.php</strong> and <strong class="source-inline">array-pass-a-copy.php</strong>, which are available on GitHub.</p>
			<p>Another example that you see in real-life code is <strong class="source-inline">preg_match()</strong>. This function matches an occurrence of a pattern in a string and stores it in the optional <strong class="source-inline">&amp;$matches</strong> parameter, which is passed by reference. This means that you have to declare a <strong class="source-inline">$matches</strong> variable before you call the function or even while you are calling it. After the function has run, the previously empty <strong class="source-inline">$matches</strong> array will be filled with the match. The pattern is a regular expression. Regular expressions deserve their own chapter, but the essence is that a regular expression defines a pattern that the parser can then recognize in a string and return as a match. The <strong class="source-inline">preg_match()</strong> function returns <strong class="source-inline">1</strong> if the pattern exists in the string and <strong class="source-inline">matches</strong>, if provided, will contain the actual match:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">$text = "We would like to see if any spaces followed by three word characters   are in this text";</p>
			<p class="source-code">// i is a modifier, that makes the pattern case-insensitive</p>
			<p class="source-code">$pattern = "/\s\w{3}/i";</p>
			<p class="source-code">// empty matches array, passed by reference</p>
			<p class="source-code">$matches = [];</p>
			<p class="source-code">// now call the function</p>
			<p class="source-code">preg_match($pattern, $text, $matches);</p>
			<p class="source-code">print_r($matches);</p>
			<p>The output is as follows:</p>
			<p class="source-code">(</p>
			<p class="source-code">    [0] =&gt; wou</p>
			<p class="source-code">)</p>
			<p>As you can see, the first occurrence that is found is the single match stored in <strong class="source-inline">$matches</strong>. If you want all of the spaces followed by three word characters, you should use <strong class="source-inline">preg_match_all()</strong>.</p>
			<p>To demonstrate how simply changing the <strong class="source-inline">preg_match</strong> function to <strong class="source-inline">preg_match_all</strong> can return all instances of the matches, we will change the following line:</p>
			<p class="source-code">preg_match($pattern, $text, $matches);</p>
			<p class="source-code">...</p>
			<p>We will replace it with the following code:</p>
			<p class="source-code">preg_match_all($pattern, $text, $matches);</p>
			<p class="source-code">...</p>
			<p>This will result in returning all of the sections that match our defined pattern.</p>
			<p>The output is as follows:</p>
			<p class="source-code">(</p>
			<p class="source-code">    [0] =&gt; Array</p>
			<p class="source-code">        (</p>
			<p class="source-code">            [0] =&gt; wou</p>
			<p class="source-code">            [1] =&gt; lik</p>
			<p class="source-code">            [2] =&gt; see</p>
			<p class="source-code">            [3] =&gt; any</p>
			<p class="source-code">            [4] =&gt; spa</p>
			<p class="source-code">            [5] =&gt; fol</p>
			<p class="source-code">            [6] =&gt; thr</p>
			<p class="source-code">            [7] =&gt; wor</p>
			<p class="source-code">            [8] =&gt; cha</p>
			<p class="source-code">            [9] =&gt; are</p>
			<p class="source-code">            [10] =&gt; thi</p>
			<p class="source-code">            [11] =&gt; tex</p>
			<p class="source-code">        )</p>
			<p class="source-code">)</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To learn more about regex, take a look at: <a href="https://packt.live/33n2y0n">https://packt.live/33n2y0n</a>.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor137"/>Optional Parameters</h2>
			<p>You will have noticed that we have used <strong class="source-inline">print_r()</strong> in a lot of examples to display a user-friendly representation of variables that would otherwise not make much sense. Let's take the following array:</p>
			<p class="source-code">$values = [</p>
			<p class="source-code">    'foo',</p>
			<p class="source-code">    'bar',</p>
			<p class="source-code">];</p>
			<p>Using <strong class="source-inline">echo $values;</strong> would just print <strong class="source-inline">Array</strong> on the screen, while <strong class="source-inline">print_r($values);</strong> prints a human-readable format for us to view:</p>
			<p class="source-code">Array</p>
			<p class="source-code">(</p>
			<p class="source-code">    [0] =&gt; foo</p>
			<p class="source-code">    [1] =&gt; bar</p>
			<p class="source-code">)</p>
			<p>Now, suppose that you would like to send information about <strong class="source-inline">$values</strong> to somewhere other than the screen. The reason for this could be that you want to send information about an error, or that you would like to keep a log of what is going on in your application. In the message that you send, you would like to include information about the contents of <strong class="source-inline">$values</strong>. If you were to use <strong class="source-inline">print_r</strong> for that, the output would not appear in your message but would be written to the screen instead. That is not what you want. Now the optional second parameter of <strong class="source-inline">print_r</strong> comes into play. If you pass that second argument with your function call and make it <strong class="source-inline">true</strong>, the output will not be printed directly, but instead be returned from the function:</p>
			<p class="source-code">$output = print_r($values, true);</p>
			<p>The <strong class="source-inline">$output</strong> variable now contains the following:</p>
			<p class="source-code">"Array</p>
			<p class="source-code">(</p>
			<p class="source-code">    [0] =&gt; foo</p>
			<p class="source-code">    [1] =&gt; bar</p>
			<p class="source-code">)"</p>
			<p>This can be used later to compose a message to be sent anywhere you need.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor138"/>Exercise 4.2: Working with print_r()</h2>
			<p>In this exercise, we will use the <strong class="source-inline">print_r()</strong> function to print different shapes in a human-readable format. To do this, we will execute the following steps:</p>
			<ol>
				<li value="1">Let's start by creating a new file in your project directory and calling it <strong class="source-inline">print_r.php</strong>.</li>
				<li>Next, we are going to open our PHP script with the opening tag and define a <strong class="source-inline">$shapes</strong> variable with three different shapes:<p class="source-code">&lt;?php</p><p class="source-code">     $shapes = [</p><p class="source-code">             'circle',</p><p class="source-code">             'rectangle',</p><p class="source-code">             'triangle'</p><p class="source-code">     ];</p></li>
				<li>On the next line, let's echo out the contents of <strong class="source-inline">$values</strong>:<p class="source-code">echo $shapes;</p></li>
				<li>Let's go ahead and open the project directory in the Terminal and run it:<p class="source-code">php print_r.php</p><p>You'll see that all that is printed is the following:</p><p class="source-code">Array</p><p>This is because <strong class="source-inline">echo</strong> isn't designed to show array contents. However, this is where <strong class="source-inline">print_r()</strong> now comes into play.</p></li>
				<li>Let's replace <strong class="source-inline">echo</strong> with <strong class="source-inline">print_r</strong>:<p class="source-code">print_r($shapes);</p><p>We'll run the script using the following command:</p><p class="source-code">php print_r.php</p><p>Now we can see the values of the array as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer083">
					<img alt="Figure 4.6: Printing the values of an array&#13;&#10;" src="image/C14196_04_06.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6: Printing the values of an array</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor139"/>A Varying Number of Parameters</h2>
			<p>Functions can accept a varying number of parameters. Take, for example, <strong class="source-inline">printf</strong>, which is used to print a string of text from a predefined formatted string, filling out placeholders with values:</p>
			<p class="source-code">$format = 'You have used the maximum amount of %d credits you are allowed   to spend in a %s. You will have to wait %d days before new credits become   available.';</p>
			<p class="source-code">printf($format, 1000, 'month', 9);</p>
			<p>This will print the following:</p>
			<p class="source-code">You have used the maximum amount of 1000 credits you are allowed to spend in a month. You will have to wait 9 days before new credits become available.</p>
			<p>While <strong class="source-inline">$format</strong> is a required parameter, the remaining parameters are optional and variable in number. The important takeaway here is that you can pass as many as you like. </p>
			<p>The number of parameters must match the number of placeholders in the string, but that is specific to <strong class="source-inline">printf</strong>. When allowing a varying number of parameters, it is up to the designer of the function to decide whether or not to validate the number of parameters against certain restrictions.</p>
			<p>There is also the <strong class="source-inline">sprintf</strong> function, which acts almost the same way; however, instead of printing the resulting text, it returns it from the function so that you can use the output later.</p>
			<p>You might have noticed that the placeholders are different: <strong class="source-inline">%d</strong> and <strong class="source-inline">%s</strong>. This can be used as a simple validation: <strong class="source-inline">%d</strong> expects a number, while <strong class="source-inline">%s</strong> accepts anything that can be cast to a string.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor140"/>Flag Parameters</h2>
			<p>In earlier examples, we used the <strong class="source-inline">sort()</strong> function with just one parameter: the array we want to be sorted for us. The function accepts a second parameter. In this case, the second parameter is also defined as a flag, which means only values of certain predefined constants, called flags, are accepted. The flag determines the way in which <strong class="source-inline">sort()</strong> behaves. If you want to use multiple flags, then you can simply use the pipe (<strong class="source-inline">|</strong>) symbol between each flag.</p>
			<p>Let's now take a slightly different input array:</p>
			<p class="source-code">$fruits = [</p>
			<p class="source-code">    'Pear',</p>
			<p class="source-code">    'orange', // notice orange is all lowercase</p>
			<p class="source-code">    'Apple',</p>
			<p class="source-code">    'Banana',</p>
			<p class="source-code">];</p>
			<p class="source-code">// sort with flags combined with bitwise OR operator</p>
			<p class="source-code">sort($fruits, SORT_FLAG_CASE | SORT_NATURAL);</p>
			<p class="source-code">print_r($fruits);</p>
			<p>The output is as follows:</p>
			<p class="source-code">Array</p>
			<p class="source-code">(</p>
			<p class="source-code">    [0] =&gt; Apple</p>
			<p class="source-code">    [1] =&gt; Banana</p>
			<p class="source-code">    [2] =&gt; orange</p>
			<p class="source-code">    [3] =&gt; Pear</p>
			<p class="source-code">)</p>
			<p>The array is now sorted alphabetically as expected. Without the flags, sorting would be case-sensitive and <strong class="source-inline">orange</strong> would come last, because it is lowercase. The same result can be achieved using <strong class="source-inline">natcasesort($fruits)</strong>. See the example in <strong class="source-inline">array-use-sort-with-flags.php</strong> on GitHub.</p>
			<p>In general, it is a good idea, when using a function, to consult the documentation about extended possibilities by using extra arguments. Often, a function does not exactly do what you want but can be made to do it by passing extra arguments.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor141"/>Exercise 4.3: Using Built-In Functions with Arrays</h2>
			<p>In this exercise, we will see how the PHP built-in functions work with arrays:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">array-functions.php</strong> in the <strong class="source-inline">exercises</strong> directory of <strong class="source-inline">Chapter04</strong>.</li>
				<li>Type the opening tag and the statement that creates the array named <strong class="source-inline">$signal</strong>, which contains the different colors in a traffic signal:<p class="source-code">&lt;?php</p><p class="source-code">$signal = ['red', 'amber', 'green'];</p></li>
				<li>Display the array of integers in a human-readable format:<p class="source-code">print_r($signal);</p></li>
				<li>Execute the script using the following command:<p class="source-code">php array-functions.php</p><p>The output is as follows:</p><div class="IMG---Figure" id="_idContainer084"><img alt="Figure 4.7: Printing the array of traffic signal colors&#13;&#10;" src="image/C14196_04_07.jpg"/></div><p class="figure-caption">Figure 4.7: Printing the array of traffic signal colors</p><p>Notice in the preceding output how the array elements are indexed with colors and the first element is at index <strong class="source-inline">0</strong> and the third element at index <strong class="source-inline">2</strong>. These are the default indices when you do not declare your own indices.</p></li>
				<li>Use the <strong class="source-inline">array_reverse</strong> function to reverse the array:<p class="source-code">$reversed = array_reverse($signal);</p><p>The <strong class="source-inline">array_reverse()</strong> method will reverse the order of the array elements and return the result as a new array while leaving the original array unchanged.</p></li>
				<li>Print the reversed array:<p class="source-code">print_r($reversed);</p><p>Execute the <strong class="source-inline">php array-functions.php</strong> command.</p><p>The output looks like the following screenshot: </p><div class="IMG---Figure" id="_idContainer085"><img alt="Figure 4.8: Printing the reverse array&#13;&#10;" src="image/C14196_04_08.jpg"/></div><p class="figure-caption">Figure 4.8: Printing the reverse array</p><p>Notice how element <strong class="source-inline">3</strong> is now the first element at index <strong class="source-inline">0</strong> of the array and element <strong class="source-inline">1</strong> is the last. At index <strong class="source-inline">2</strong>, although the array is reversed, the indices stay at the same positions as in the original array.</p></li>
				<li>Add the following code again to print the original array:<p class="source-code">print_r($signal);</p><p>The output is as follows:</p><div class="IMG---Figure" id="_idContainer086"><img alt="Figure 4.9: Printing the array&#13;&#10;" src="image/C14196_04_09.jpg"/></div><p class="figure-caption">Figure 4.9: Printing the array</p><p>This is to demonstrate that the original array will not be changed by <strong class="source-inline">array_reverse</strong>.</p></li>
				<li>Open a Terminal and go to the directory where you just typed the <strong class="source-inline">array-functions.php</strong> script. Run the script and hit <em class="italic">Enter</em>:<p class="source-code">php array-functions.php</p><p>Observe that three arrays are displayed. The output on the screen will look like the following screenshot when the array contains only three integers:</p><div class="IMG---Figure" id="_idContainer087"><img alt="Figure 4.10: Printing the three arrays&#13;&#10;" src="image/C14196_04_10.jpg"/></div><p class="figure-caption">Figure 4.10: Printing the three arrays</p><p>The first array displays your array with integers, the second is your array with integers in reverse order, and the third is the unchanged original array with the integers in regular order, as you entered them.</p></li>
				<li>Change the statement that reverses the array to the following:<p class="source-code">$reversed = array_reverse($signal, $preserve_keys = true);</p><p>What we did here has not always been possible in PHP, but it is possible today: we assign <strong class="source-inline">true</strong> to the <strong class="source-inline">$preserve_keys</strong> variable and, at the same time, we pass it as the second argument to <strong class="source-inline">array_reverse</strong>. The advantage of doing this is self-documenting the operations we are doing, and we can reuse the variable later if we need to. However, in general, this type of assignment can be easily overlooked and, if you do not need the variable later, it is probably better to just pass <strong class="source-inline">true</strong>. You might use this type of assignment depending on what you are building.</p><p>Look carefully at the output when you run the script again:</p><div class="IMG---Figure" id="_idContainer088"><img alt="Figure 4.11: Printing the three arrays again&#13;&#10;" src="image/C14196_04_11.jpg"/></div><p class="figure-caption">Figure 4.11: Printing the three arrays again</p><p>When you inspect the output, specifically the array in the middle, you will notice that the keys have been preserved in the reversed array. It is true that element <strong class="source-inline">3</strong> is now the first element in the array, but note that index <strong class="source-inline">2</strong> is now the first index as well. So, <strong class="source-inline">$integers[2]</strong> still contains the value of <strong class="source-inline">3</strong> and <strong class="source-inline">$integers[0]</strong> still holds the value of <strong class="source-inline">1</strong>.</p></li>
				<li>Now let's declare another <strong class="source-inline">$streets</strong> array with the names of a few streets:<p class="source-code">$streets = [</p><p class="source-code">    'walbrook',</p><p class="source-code">    'Moorgate',//Starts with an uppercase</p><p class="source-code">    'crosswall',</p><p class="source-code">    'lothbury',</p><p class="source-code">];</p></li>
				<li>Now let's sort the array with flags combined with the bitwise OR operator:<p class="source-code">sort($streets, SORT_STRING | SORT_FLAG_CASE );</p><p class="source-code">print_r($streets);</p><p>The output is as follows:</p><div class="IMG---Figure" id="_idContainer089"><img alt="Figure 4.12: Printing the array in alphabetical order&#13;&#10;" src="image/C14196_04_12.jpg"/></div><p class="figure-caption">Figure 4.12: Printing the array in alphabetical order</p><p>In this case, the <strong class="source-inline">sort()</strong> function sorts the string case-insensitively.</p></li>
				<li>If we sort the array using the bitwise AND operator, we will see that the street names starting with uppercase letters move to the top of the array and rest of the street names print in alphabetical order:<p class="source-code">sort($streets, SORT_STRING &amp; SORT_FLAG_CASE );</p><p class="source-code">print_r($streets);</p><p>The output is as follows: </p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer090">
					<img alt="Figure 4.13: Printing the words that start with uppercase letters at the top of the array&#13;&#10;" src="image/C14196_04_13.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.13: Printing the words that start with uppercase letters at the top of the array</p>
			<p>In this exercise, you have seen one of the many powerful array manipulation functions of PHP at work. You learned that this function—<strong class="source-inline">array_reverse</strong> – returns a new array rather than modifying the original. You may deduce that the input argument, your array, is not passed by reference, because, otherwise, the original would have been changed by the reversion. You also learned that the second argument to this function – <strong class="source-inline">boolean $preserve_keys</strong> – if <strong class="source-inline">true</strong> does change the behavior of the function so that the elements stay at the same indices as before the reversion. You may deduce from this that the default value of the second argument is <strong class="source-inline">false</strong>. We then explored how to use the <strong class="source-inline">sort</strong> function to arrange the elements of an array in a specific order.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor142"/>Introduction to User-Defined Functions</h1>
			<p>A user-defined function is a function that either you or another user has written and is not built into PHP itself. Built-in functions are generally faster than user-defined functions that do the same thing, as they are already compiled from C. Always look for built-in functions before you try to write your own! </p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor143"/>Naming Functions</h2>
			<p>Naming things is difficult. Try to choose names for your functions that are descriptive but not overly long. Very long function names are unreadable. When you read the name, you should ideally be able to guess what the function does. The rules for naming identifiers in PHP apply here. Function names are case-insensitive; however, by convention, you do not call a function with casing that is different from how it was defined. Speaking of conventions, you are free to design the casing any way you like, but two flavors generally prevail: <strong class="source-inline">snake_case()</strong> or <strong class="source-inline">camelCase()</strong>. In all cases, do what your team agrees upon – consistency is far more important than any personal preference, no matter how strong. If you are free to choose your coding convention, then, by all means, stick to the PSR-1 standard as recommended by PHP-FIG (<a href="https://packt.live/2IBLprS">https://packt.live/2IBLprS</a>). Although it refers to functions as methods (as in class methods), you may safely assume that this also applies to (global) functions, which this chapter is about. This means that if you are free to choose, you can choose <strong class="source-inline">camelCase()</strong> for functions.</p>
			<p>Do not redeclare a built-in function (that is, do not write a function with the same name as a built-in function in the root namespace). Instead, give your own function a unique name, or put it in its own namespace. The best practice is to never use the name of an existing function for your own function, not even within your own namespace, to avoid confusion.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor144"/>Documenting Your Functions</h2>
			<p>You may add a comment above a function, which is called a DocBlock. This contains annotations, prefixed with the <strong class="source-inline">@</strong> symbol. It also contains a description of what the function does. Ideally, it also describes why the function is there:</p>
			<p class="source-code"> /**</p>
			<p class="source-code"> * Determines the output directory where your files will </p>
			<p class="source-code"> * go, based on where the system temp directory is. It will use /tmp as </p>
			<p class="source-code"> * the default path to the system temp directory.</p>
			<p class="source-code"> *</p>
			<p class="source-code"> * @param string $systemTempDirectory</p>
			<p class="source-code"> * @return string</p>
			<p class="source-code"> */</p>
			<p class="source-code">function determineOutputDirectory(string $systemTempDirectory = '/tmp'): string { </p>
			<p class="source-code">    // … code goes here</p>
			<p class="source-code">}</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor145"/>Namespaced Functions</h2>
			<p><strong class="bold">Namespaces</strong> are a way to organize code so that name clashes are less likely. They were introduced around the time when different PHP libraries proposed classes called <strong class="source-inline">Date</strong>. If different libraries do this, you cannot use both libraries at the same time, because the second time a <strong class="source-inline">Date</strong> class is loaded, PHP will complain that you cannot redeclare the <strong class="source-inline">Date</strong> class, since it has already been loaded. </p>
			<p>To solve this problem, we use namespaces. If two different vendors of libraries use their vendor name for the namespace and create their <strong class="source-inline">Date</strong> class within that namespace, the names are far less likely to clash.</p>
			<p>You can think of a namespace as some kind of prefix. Say that <strong class="source-inline">You</strong> and <strong class="source-inline">Me</strong> are both vendors and we both want to introduce a <strong class="source-inline">Date</strong> class. Instead of naming the classes <strong class="source-inline">MeDate</strong> and <strong class="source-inline">YouDate</strong>, we create them in files that live in a <strong class="source-inline">Me</strong> directory and in a <strong class="source-inline">You</strong> directory. The class file will simply be called <strong class="source-inline">Date.php</strong> for both vendors. Inside your <strong class="source-inline">Date.php</strong> file, you will write the namespace as the very first statement (after the strict types declaration, if any):</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace You;</p>
			<p class="source-code">class Date{}</p>
			<p>We will write a <strong class="source-inline">Date.php</strong> file that starts as follows:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace Me;</p>
			<p class="source-code">class Date{}</p>
			<p>Now, because the classes live in their own namespace, they have a so-called <strong class="bold">Fully Qualified Name</strong> (<strong class="bold">FQN</strong>). The FQNs are <strong class="source-inline">You\Date</strong> and <strong class="source-inline">Me\Date</strong>. Notice that the names are different. You will learn more about namespaces in <em class="italic">Chapter 5</em>, <em class="italic">Object-Oriented Programming</em>, because they matter to objects more than functions.</p>
			<p>Namespaced functions are rare, but they are possible. To write a function in a namespace, declare the namespace at the top of the file where you define the function:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace Chapter04;</p>
			<p class="source-code">function foo(){</p>
			<p class="source-code">    return 'I was called';</p>
			<p class="source-code">}</p>
			<p class="source-code">// call it, inside the same namespace:</p>
			<p class="source-code">foo();</p>
			<p>And then call it in another file in the root namespace (no namespace):</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">require_once __DIR__ . '/chapter04-foo.php;</p>
			<p class="source-code">// call your function</p>
			<p class="source-code">Chapter04\foo();</p>
			<p>We could import the <strong class="source-inline">Chapter04</strong> namespace near the top of the unit test with a <strong class="source-inline">use</strong> statement:</p>
			<p class="source-code">use Chapter04;</p>
			<p class="source-code">// later on in the test, or any other namespace, even the root namespace.</p>
			<p class="source-code">foo(); // will work, because we "use" Chapter04.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor146"/>Pure Functions</h2>
			<p>Pure functions do not have side effects. Not-so-pure functions will have side effects. So, what is a side effect? Well, when a function has a side effect, it changes something that exists outside of the scope of a function.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor147"/>Scope</h2>
			<p>You can think of scope as a "fence" within which a variable or function can operate. Within the function scope are its input, its output, and everything that is made available inside the function body. Functions can pull things out of the global scope into their own scope and alter them, thus causing side effects. To keep things simple, it is best when functions do not have side effects. It makes fault finding and unit testing easier when functions do not try to alter the environment in which they live, but, instead, just focus on their own responsibility.</p>
			<p>Variables declared outside the function live in the global scope and are available within the function. Variables declared within the function body are not available outside the function scope, unless extra work is done.</p>
			<p>In the following examples, two ways are used to demonstrate how variables from the global scope can be used inside a function:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">// we are in global scope here</p>
			<p class="source-code">$count = 0;</p>
			<p class="source-code">function countMe(){</p>
			<p class="source-code">    // we enter function scope here</p>
			<p class="source-code">    // $count is pulled from global scope using the keyword global</p>
			<p class="source-code">    global $count;</p>
			<p class="source-code">    $count++;</p>
			<p class="source-code">}</p>
			<p class="source-code">countMe();</p>
			<p class="source-code">countMe();</p>
			<p class="source-code">echo $count;</p>
			<p>The output is as follows:</p>
			<p class="source-code">2</p>
			<p>After the function was called twice, <strong class="source-inline">$count</strong> will have the value of <strong class="source-inline">2</strong>, which is essentially a count of how many times the function was called during a single script run. After the next run, the <strong class="source-inline">$count</strong> variable will be <strong class="source-inline">2</strong> again, because the value is not preserved between script runs and also because it is initialized at <strong class="source-inline">0</strong> each time the script runs. Regardless, values are not preserved between script runs, unless you persist them explicitly in a file or some form of cache or some other form of persistence layer.</p>
			<p>In general, it is better for functions not to have side effects and not to meddle with global scope.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor148"/>The $GLOBALS Superglobal Array</h2>
			<p>Global variables are always available inside the special <strong class="source-inline">$GLOBALS</strong> superglobal array. So, instead of using the <strong class="source-inline">global</strong> keyword, we could have incremented <strong class="source-inline">$GLOBALS['count'];</strong> in the previous example.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor149"/>Exercise 4.4: Using the $GLOBALS array</h2>
			<p>In this exercise, you will change the function in <strong class="source-inline">count-me-with-GLOBALS.php</strong> so that it no longer uses the <strong class="source-inline">global</strong> keyword but uses the <strong class="source-inline">$GLOBALS</strong> superglobal array instead:</p>
			<ol>
				<li value="1">Take another look at the function used in the previous example:<p class="source-code">&lt;?php</p><p class="source-code">// we are in global scope here</p><p class="source-code">$count = 0;</p><p class="source-code">function countMe(){</p><p class="source-code">    // we enter function scope here</p><p class="source-code">    // $count is pulled from global scope using the keyword global</p><p class="source-code">    global $count;</p><p class="source-code">    $count++;</p><p class="source-code">}</p></li>
				<li>Remove the contents of the function body so that your function looks like this:<p class="source-code">function countMe()</p><p class="source-code">{</p><p class="source-code">}</p><p>The function is now empty and does nothing.</p></li>
				<li>Add a new statement to the empty function body that increments <strong class="source-inline">count</strong> in the <strong class="source-inline">$GLOBALS</strong> array:<p class="source-code">function countMe()</p><p class="source-code">{</p><p class="source-code">    $GLOBALS['count']++;</p><p class="source-code">}</p><p>The function now does exactly the same as before, but with less code.</p></li>
				<li>Call the <strong class="source-inline">countMe()</strong> function twice. The script should now look like the script in <strong class="source-inline">count-me-with-GLOBALS.php</strong>:</li>
			</ol>
			<p class="source-code-heading">count-me-with-GLOBALS.php</p>
			<p class="source-code">1  &lt;?php</p>
			<p class="source-code">2  // declare global $count variable</p>
			<p class="source-code">3  $count = 0;</p>
			<p class="source-code">4  /**</p>
			<p class="source-code">5   * This function increments the global</p>
			<p class="source-code">6   * $count variable each time it is called.</p>
			<p class="source-code">7   */</p>
			<p class="source-code">8  function countMe()</p>
			<p class="source-code">9  {</p>
			<p class="source-code">10     $GLOBALS['count']++;</p>
			<p class="source-code">11 }</p>
			<p class="source-code">12 // call the function countMe once</p>
			<p class="source-code">13 countMe();</p>
			<p class="source-code">14 // and twice</p>
			<p class="source-code">15 countMe();</p>
			<p class="source-code-link"><a href="https://packt.live/323pJfR">https://packt.live/323pJfR</a></p>
			<p>The output looks like the following screenshot when you run the script. The output is both a newline and a value of <strong class="source-inline">$count</strong> function:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer091">
					<img alt="Figure 4.14: Printing the count&#13;&#10;" src="image/C14196_04_14.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.14: Printing the count</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor150"/>The Single Responsibility Principle</h2>
			<p>A function is easier to use, more reliable when reused, and easier to test when it does only one thing – that is, when it has a single responsibility. When you need another task to be performed, do not add it to your existing function; just write another one instead.</p>
			<p>The syntax of a function is as follows:</p>
			<p class="source-code">function [identifier] ([[typeHint][…] [&amp;]$parameter1[…][= defaultValue]][,   [&amp;]$p2, ..$pn]])[: [?]returnType|void] </p>
			<p class="source-code">{</p>
			<p class="source-code">     // function body, any number of statements</p>
			<p class="source-code">     [global $someVariable [, $andAnother]] // bad idea, but possible</p>
			<p class="source-code">     [return something;]</p>
			<p class="source-code">}</p>
			<p>Don't be put off by this apparently complex syntax definition. Functions are really easy to write, as the following examples in this chapter will show you.</p>
			<p>However, let's now spend some time trying to break this syntax apart.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor151"/>The function Keyword</h2>
			<p>The <strong class="source-inline">function</strong> keyword tells the PHP parser that what comes next is a function.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor152"/>Identifier</h2>
			<p>The identifier represents the name of the function. Here, the general rules for identifiers in PHP will apply. The most important ones to remember are that it cannot start with a number and it cannot contain spaces. It can contain Unicode characters, although this is relatively uncommon. It is, however, quite common to define special, frequently used functions with underscores: </p>
			<p class="source-code">function __( $text, $domain = 'default' ) {</p>
			<p class="source-code">    return translate( $text, $domain );</p>
			<p class="source-code">}</p>
			<p>This function is used to translate the text in WordPress templates. The idea behind it is that you will spot immediately that this function is something special and you won't be tempted to write a function with the same name yourself. It is also very easy to type, which is handy for frequently used functions. As you can see, it takes a required parameter, <strong class="source-inline">$text</strong>, to be translated. It also takes an optional <strong class="source-inline">$domain</strong>, in which the translation is defined, which is the <strong class="source-inline">default</strong> domain by default (a <strong class="source-inline">text</strong> domain in translations serves to separate different fields of interest that might have the same word for different things, so that these words can be translated differently if the other language has different words depending on the context). <strong class="source-inline">__ </strong>function is what we call a wrapper for the translate function. It passes its arguments on to the <strong class="source-inline">translate</strong> function and returns the return value of the <strong class="source-inline">translate</strong> function. It is faster to type and it takes up less space in templates, making them more readable.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor153"/>Type Hints</h2>
			<p>In the function declaration, type hinting is used to specify the expected data type of an argument. Type hints for objects have existed since PHP 5.0 and for arrays since PHP 5.1. Type hints for scalars have existed since PHP 7.0. Nullable type hints have existed since PHP 7.1. A type hint for <strong class="source-inline">object</strong> has existed since PHP 7.2. Consider the following example:</p>
			<p class="source-code">function createOutOfCreditsWarning(int $maxCredits, string $period, int $waitDays): string</p>
			<p class="source-code">{</p>
			<p class="source-code">    $format = 'You have used the maximum amount of %d credits you are             </p>
			<p class="source-code">        allowed to spend in a %s. You will have to wait %d days before  </p>
			<p class="source-code">        new credits become available.';</p>
			<p class="source-code">    return sprintf($format, $maxCredits, $period, $waitDays);</p>
			<p class="source-code">}</p>
			<p>In the preceding example, there are three type hints. The first one hints that <strong class="source-inline">$maxCredits</strong> should be an integer. The second one hints that <strong class="source-inline">$period</strong> should be a string, and the third one hints that <strong class="source-inline">$waitDays</strong> must be an integer. </p>
			<p>If a type hint is prefixed with a question mark, as in <strong class="source-inline">?int</strong>, this indicates that the argument must either be the hinted type or <strong class="source-inline">null</strong>. In this case, the hinted type is <strong class="source-inline">integer</strong>. This has been possible since PHP 7.1.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor154"/>The Spread Operator (…) with Type Hints</h2>
			<p>The spread operator (<strong class="source-inline">…</strong>) is optional and indicates that the parameter has to be an array that only contains elements of the hinted type. Although it has existed since PHP 5.6, it is a rarely used yet very powerful and useful feature that makes your code more robust and reliable, with less code. There is no longer a need to check every element of a homogeneous array. When you define a parameter with such a type hint, you also need to call the function with the parameter prefixed with the spread operator.</p>
			<p>The following is an example of a fictional function that I made up to demonstrate the use of the spread operator. The <strong class="source-inline">processDocuments</strong> function transforms XML documents using <strong class="bold">eXtensible Stylesheet Language Transformations</strong> (<strong class="bold">XSLT</strong>). While this is really interesting when you need to transform documents, it doesn't really matter for the demonstration of the spread operator. </p>
			<p>The spread operator is the three dots before <strong class="source-inline">$xmlDocuments</strong> in the function signature. It means that <strong class="source-inline">$xmlDocuments</strong> must be an array that contains only objects of the <strong class="source-inline">DomDocument</strong> hinted type. A <strong class="source-inline">DomDocument</strong> hinted type is an object that can load and hold XML. It can be processed by an object of the <strong class="source-inline">XsltProcessor</strong> class, to transform the document into another document. <strong class="source-inline">XsltProcessor</strong> in PHP is very powerful and very performant. You can even use PHP functions inside your XSL style sheets. This nifty feature should be used with caution, however, because it will render your XSL style sheets useless to other processors as they do not know PHP. </p>
			<p>The return type of the function is <strong class="source-inline">Generator</strong>. This is caused by the <strong class="source-inline">yield</strong> statement inside the <strong class="source-inline">foreach</strong> loop. The <strong class="source-inline">yield</strong> statement causes the function to return each value (a document, in our case) as soon as it becomes available. This means it is efficient with memory: it does not keep the objects in memory in an array to return them all at once, but instead returns them one by one immediately after creation. This makes a generator very performant on large sets while also using fewer memory resources:</p>
			<p class="source-code">function processDocuments(DomDocument … $xmlDocuments):Generator</p>
			<p class="source-code">{</p>
			<p class="source-code">    $xsltProcessor = new XsltProcessor();</p>
			<p class="source-code">    $xsltProcessor-&gt;loadStylesheet('style.xslt');</p>
			<p class="source-code">foreach($xmlDocuments as $document){</p>
			<p class="source-code">     yield $xsltProcessor-&gt;process($document);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The preceding function may appear pretty confusing, but it is fairly simple. Let's start with the usage of the spread operator; this is used to signify that the parameter will be required as an array. Additionally, the parameters are type hinted as <strong class="source-inline">DomDocument</strong> objects, meaning that the parameters will be an array of <strong class="source-inline">DomDocument</strong> objects. Moving onto the function, we define a new instance of <strong class="source-inline">XsltProcessor</strong> and load in a style sheet for the processor. Note that this is a conceptual example and more information on <strong class="source-inline">XsltProcessor</strong> and style sheets can be found in the PHP documentation at <a href="https://packt.live/2OxT91A">https://packt.live/2OxT91A</a>. Finally, we use a <strong class="source-inline">foreach</strong> loop to iterate through the array of documents and yield the results of the process method on each document. As document processing can be memory intensive, the use case for a generator is apparent if you can imagine passing a large array of documents to this function.</p>
			<p>To call this function, use the following code:</p>
			<p class="source-code">// create two documents and load an XML file in each of them</p>
			<p class="source-code">$document1 = new DomDocument();</p>
			<p class="source-code">$document1-&gt;load($pathToXmlFile1);</p>
			<p class="source-code">$document2 = new DomDocument();</p>
			<p class="source-code">$document2-&gt;load($pathToXmlFile2);</p>
			<p class="source-code">// group the documents in an array</p>
			<p class="source-code">$documents = [$document1, $document2];</p>
			<p class="source-code">// feed the documents to our function</p>
			<p class="source-code">$processedDocuments = processDocuments(…$documents);</p>
			<p class="source-code">// because the result is a Generator, you could also loop over the </p>
			<p class="source-code">// result:</p>
			<p class="source-code">foreach(processDocuments(…$documents) as $transformedDocument) {</p>
			<p class="source-code">     // .. do something with it</p>
			<p class="source-code">}</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor155"/>Parameters in User-Defined Functions</h2>
			<p>When defining a function, you are allowed to define parameters for it. When you are defining a parameter, consider whether it is expected to always be of the same type or whether you can force the developer using your code to always pass the same type. For example, when integer values are expected, a type hint of <strong class="source-inline">int</strong> is a good idea. Even if a developer passes <strong class="source-inline">2</strong>, which is a string, they can easily be educated to cast this to an integer before passing it to your function, using <strong class="source-inline">(int) "2"</strong>. More realistically, <strong class="source-inline">2</strong> would be stored in a variable. So, now you have a type hint:</p>
			<p class="source-code">int</p>
			<p>Next, you should come up with a good name for your parameter. Ideally, it should be descriptive, but not overly long. When you expect a <strong class="source-inline">DomDocument</strong> object, <strong class="source-inline">$domDocument</strong>, <strong class="source-inline">$xmlDocument</strong>, or simply <strong class="source-inline">$document</strong> can be fine names, while <strong class="source-inline">$doc</strong> might be a little too short and confusing to some people and just <strong class="source-inline">$d</strong> would be just bad:</p>
			<p class="source-code">int $offset</p>
			<p>Does a default value make sense for <strong class="source-inline">$offset</strong>? In most cases, it will be <strong class="source-inline">0</strong>, because we usually start a process at the beginning of something. So, <strong class="source-inline">0</strong> would make a great default value, in this case:</p>
			<p class="source-code">int $offset = 0</p>
			<p>Now we have a parameter with a type hint of <strong class="source-inline">int</strong> and a default of <strong class="source-inline">0</strong>. The parameter is now optional and should be defined after the parameters that are not optional.</p>
			<p>If a parameter cannot be expected to always be of the same type, processing it in your function may be harder, because you might have to check its type in order to decide how you should treat it. This makes unit testing your function harder and it complicates fault finding if things go wrong, since your code will have several paths of execution, depending on the type of input.</p>
			<p>When a parameter is prefixed with <strong class="source-inline">&amp;</strong>, it means that if a scalar is passed, it will be passed by reference, instead of as a copy or literal. Objects are always passed by reference and, therefore, using <strong class="source-inline">&amp;</strong> on an object parameter is redundant and does not change the behavior of the function.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor156"/>Return Types in User-Defined Functions</h2>
			<p>Return types are written as a colon followed by the type name. Return types were introduced in PHP 7. They make your code more robust because you are more explicit about what you expect from your function, and this can be checked at compile time rather than failing at runtime when something goes wrong, possibly in production. If you use an IDE, it will warn you when a return type does not match what you actually return or expect from the function. This means you can correct the error before it hits your users.</p>
			<p>In the preceding example, the <strong class="source-inline">processDocuments</strong> function has a return type of <strong class="source-inline">Generator</strong>. A <strong class="source-inline">Generator</strong> type generates values and makes them available as soon as possible. This can be very performant: you don't have to wait for all the values to become available before processing them further. You can start with further processing as soon as the first value comes out of the <strong class="source-inline">Generator</strong> type. The <strong class="source-inline">Generator</strong> type churns out a value each time the <strong class="source-inline">yield</strong> language construct is used. </p>
			<p><strong class="source-inline">yield</strong> was introduced in PHP 5. At the time of writing, we are at PHP 7.3 and there are still many developers who have never used <strong class="source-inline">yield</strong> or do not even know what it does. When you are processing arrays or records from a database, for example, and you need extreme performance, consider whether you have a use case for a <strong class="source-inline">Generator</strong> type.</p>
			<p>You can use <strong class="source-inline">void</strong> as the return type to indicate that nothing is returned from the function. </p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor157"/>Signature</h2>
			<p>The following part of the function declaration is called the <strong class="bold">signature</strong>:</p>
			<p class="source-code">([typeHint [&amp;]$parameter1[= defaultValue], [&amp;]$p2, …])[: returnType]</p>
			<p>So, the signature of a function defines its parameters and the return type.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor158"/>Returning a Value</h2>
			<p>A function may return a value or not. When the function does not return anything, not even <strong class="source-inline">null</strong>, the return type can be void as of PHP 7.1. Values are returned by typing <strong class="source-inline">return</strong> followed by what you want to return. This can be any valid expression or just a single variable or literal:</p>
			<p class="source-code">return true;</p>
			<p class="source-code">return 1 &lt; $var;</p>
			<p class="source-code">return 42;</p>
			<p class="source-code">return $documents;</p>
			<p class="source-code">return; // return type will be "void" if specified</p>
			<p class="source-code">return null; // return type must be nullable if specified</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor159"/>Parameters and Arguments</h2>
			<p>Functions accept arguments. An argument is a literal, variable, object, or even callable that you pass into a function for the function to act upon. If a parameter is defined at the position of the argument, you can use the argument inside your function by using the name of the parameter. The number of parameters may be variable or fixed. <em class="italic">PHP allows you to pass more parameters than the function signature defines</em>. If you want dynamic parameters, PHP has two built-in functions that make this possible; you can get the number of parameters with <strong class="source-inline">func_num_args()</strong> and the parameters themselves with <strong class="source-inline">func_get_args()</strong>. To show these functions in action, we will take a look at an example. </p>
			<p>Here's an example of using <strong class="source-inline">func_num_args()</strong>. In this example, we define a method that will have no predefined parameters/arguments. But using the built-in <strong class="source-inline">func_num_args</strong> function, we will be able to count how many parameters/arguments are passed:</p>
			<p class="source-code">function argCounter() {</p>
			<p class="source-code">   $numOfArgs = func_num_args();</p>
			<p class="source-code">    echo "You passed $numOfArgs arg(s)";</p>
			<p class="source-code">}</p>
			<p class="source-code">argCounter(1,2,3,4,5);</p>
			<p>The output is as follows:</p>
			<p class="source-code">You passed 5 arg(s)</p>
			<p>Now that we can count the number of arguments, we can combine that function with <strong class="source-inline">func_get_args()</strong> to loop through and see what was passed. Here's an example of using <strong class="source-inline">func_get_args()</strong>:</p>
			<p class="source-code">function dynamicArgs(){</p>
			<p class="source-code">     $count = func_num_args();</p>
			<p class="source-code">     $arguments = func_get_args();</p>
			<p class="source-code">     if($count &gt; 0){</p>
			<p class="source-code">           for($i = 0; $i &lt; $count; $i++){</p>
			<p class="source-code">                echo "Argument $i: $arguments[$i]";</p>
			<p class="source-code">                echo PHP_EOL;</p>
			<p class="source-code">           }</p>
			<p class="source-code">     }</p>
			<p class="source-code">}</p>
			<p class="source-code">dynamicArgs(1,2,3,4,5);</p>
			<p>The output is as follows:</p>
			<p class="source-code">Argument 0: 1</p>
			<p class="source-code">Argument 1: 2</p>
			<p class="source-code">Argument 2: 3</p>
			<p class="source-code">Argument 3: 4</p>
			<p class="source-code">Argument 4: 5</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor160"/>Optional Parameters</h2>
			<p>Parameters to functions are optional when they have default values defined for them:</p>
			<p class="source-code">function sayHello($name = 'John') {</p>
			<p class="source-code">    return "Hello $name";</p>
			<p class="source-code">}</p>
			<p>This function defines a parameter, <strong class="source-inline">$name</strong>, with a default value of <strong class="source-inline">John</strong>. This means that when calling the function, you do not need to provide the <strong class="source-inline">$name</strong> parameter. We say that the <strong class="source-inline">$name</strong> parameter is optional. If you do not provide a <strong class="source-inline">$name</strong> parameter, <strong class="source-inline">John</strong> will be passed anyway for the <strong class="source-inline">$name</strong> parameter. Optional parameters should be defined at the very end in the function signature, because, otherwise, if any required parameters come after the optional ones, you would still have to provide the optional parameters when calling the function.</p>
			<p>The example is in <strong class="source-inline">function-with-default-value.php</strong>. The various usages are documented in the <strong class="source-inline">TestSayHello.php</strong> unit test.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor161"/>Parameters Passed by Reference to Our Function</h2>
			<p>Remember the <strong class="source-inline">countMe</strong> function? It used a global variable named <strong class="source-inline">$count</strong> to keep track of how many times the function was called. This could also have been accomplished by passing the <strong class="source-inline">$count</strong> variable by reference, which is also a slightly better practice than polluting the global scope from within your function:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">function countMeByReference(int &amp;$count): void</p>
			<p class="source-code">{</p>
			<p class="source-code">    $count++;</p>
			<p class="source-code">}</p>
			<p>Use it further down in the same script, as follows:</p>
			<p class="source-code">$count = 0;</p>
			<p class="source-code">countMeByReference($count);</p>
			<p class="source-code">countMeByReference($count);</p>
			<p class="source-code">countMeByReference($count);</p>
			<p class="source-code">echo $count; // will print 3</p>
			<p>Please note that calling methods in the same script as they are defined in is perfect for exercises and playing with code and also for simple scripts, but doing this is actually a violation of PSR-1. This is a coding convention that states that files either define functions (not causing side effects) or use them (causing side effects).</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor162"/>Default Values for Parameters</h2>
			<p>In the following example, we are demonstrating the use of default values. By defining a default value, you give the developer using the function the ability to use the function as is without having to pass their own value.</p>
			<p>Consider the following example:</p>
			<p class="source-code">/**</p>
			<p class="source-code"> * @param string $systemTempDirectory</p>
			<p class="source-code"> * @return string</p>
			<p class="source-code"> */</p>
			<p class="source-code">function determineOutputDirectory(string $systemTempDirectory = '/tmp'): string</p>
			<p class="source-code">{</p>
			<p class="source-code">    return $systemTempDirectory . DIRECTORY_SEPARATOR . 'output';</p>
			<p class="source-code">}</p>
			<p>Between the parentheses is the function signature, which consists of a single parameter, <strong class="source-inline">$systemTempDirectory</strong>, with a type hint of <strong class="source-inline">string</strong> and a default value of <strong class="source-inline">/tmp</strong>. This means that if you pass a directory with your function call, it must be a string. If you do not pass an argument, the default value will be used.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor163"/>Exercise 4.5: Writing a Function that Adds Two Numbers</h2>
			<p>Now that you've read through some of the theory behind writing your own functions, let's make a start on actually writing some of our own. In this exercise, we will create a simple function that adds two numbers and prints its sum:</p>
			<ol>
				<li value="1">Find the <strong class="source-inline">add.php</strong> file in <strong class="source-inline">Chapter04/exercises/</strong>.</li>
				<li>Start typing the following comment in the file and type the function template:<p class="source-code">&lt;?php</p><p class="source-code">function add($param1, $param2): string</p><p class="source-code">{</p><p class="source-code">}</p><p>You start with the <strong class="source-inline">function</strong> keyword; then the name of the function, <strong class="source-inline">add</strong>; the opening brace; the <strong class="source-inline">$param1</strong> and <strong class="source-inline">$param2</strong> parameters; the closing brace; the colon to announce the return type; the return type, <strong class="source-inline">string</strong>; and, finally, the function body, <strong class="source-inline">{}</strong>.</p></li>
				<li>Inside the function body, type a check to see whether the parameters are numeric values by using <strong class="source-inline">is_numeric()</strong>. This built-in function returns <strong class="source-inline">true</strong> if its argument represents a numeric value, even when its type is <strong class="source-inline">string</strong>. So, it will return <strong class="source-inline">true</strong> for <strong class="source-inline">23</strong> and <strong class="source-inline">0.145</strong> and <strong class="source-inline">10E6</strong>, for example. The latter is a scientific notation of 1,000,000:<p class="source-code">if (false === is_numeric($param1)) {</p><p class="source-code">    throw new DomainException('$param1 should be numeric.');</p><p class="source-code">}</p><p class="source-code">if (false === is_numeric($param2)) {</p><p class="source-code">    throw new DomainException('$param2 should be numeric.');</p><p class="source-code">}</p><p>We throw an exception when the value is not numeric and cannot be added. Don't worry about exceptions now; they will be explained in the next chapter.</p></li>
				<li>Now that you can be sure that both values are numeric and can be added without unexpected results, it is time to actually add them. Continue typing in the function body:<p class="source-code">$sum = $param1 + $param2;</p></li>
				<li>Now it is time to compose the requested message. On the next line, type the following:<p class="source-code">return "The sum of $param1 and $param2 is: $sum";</p><p>What you see in action here is called <strong class="bold">string interpolation</strong>. It is a way of expressing that the values of <strong class="source-inline">$param1</strong>, <strong class="source-inline">$param2</strong>, and <strong class="source-inline">$sum</strong> will be expanded into the string sentence. They will also be automatically cast to a string.</p></li>
				<li>String interpolation, although really fast, is still a relatively costly operation for the PHP parser. If you need to maximize performance for a use case where every nanosecond counts, then it would be better for you to use <em class="italic">string concatenation</em> because it is faster. Here is the same line written using string concatenation:<p class="source-code">return 'The sum of ' . $param1 . ' and ' . $param2 ' . '  is: ' . $sum;</p><p>The dot (<strong class="source-inline">.</strong>) is the string concatenation operator. It glues two strings together. Other types of values are cast to strings automatically before the concatenation happens.</p></li>
				<li>Now you can write the following after your function:<p class="source-code">echo add(1, 2);</p></li>
				<li>Add a newline for clarity of the output:<p class="source-code">echo PHP_EOL;</p></li>
				<li>Run the script from the <strong class="source-inline">exercises</strong> directory:<p class="source-code">php add.php</p><p>The output is as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer092">
					<img alt="Figure 4.15: Printing the sum&#13;&#10;" src="image/C14196_04_15.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.15: Printing the sum</p>
			<p>In this exercise, you have learned how to validate and process the arguments to your function and how to format and return some output. You have also learned how to perform some very simple math with PHP.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor164"/>Variable Functions</h2>
			<p>If you store a function name in a variable, you can call this variable as a function. Here's an example:</p>
			<p class="source-code">$callable = 'strtolower';</p>
			<p class="source-code">echo $callable('Foo'); // will print foo;</p>
			<p>This is not limited to built-in functions. In fact, you can do the same thing with your own functions.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor165"/>Anonymous Functions</h2>
			<p>These are functions without identifiers (refer to the following syntax). They can be passed into any function that accepts a callable as input. Consider the following example: </p>
			<p class="source-code">function(float $value): int{</p>
			<p class="source-code">    if (0 &lt;= $value) {</p>
			<p class="source-code">        return -1; // this is called an early return</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return 1;</p>
			<p class="source-code">}</p>
			<p>The preceding is an anonymous function, also called a closure. It does not have a name, so it cannot be called by its name, but it can be passed into another function that does accept a callable as input. </p>
			<p>If you want to call the anonymous function, there are two ways to achieve this:</p>
			<p class="source-code">echo (function(float $value): int{</p>
			<p class="source-code">    if (0 &lt;= $value) {</p>
			<p class="source-code">        return 1;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return -1;</p>
			<p class="source-code">})(2.3);</p>
			<p>In the preceding example, the function is created and called immediately with the <strong class="source-inline">2.3</strong> argument. The output that is returned will be <strong class="source-inline">1</strong>, because <strong class="source-inline">2.3</strong> is greater than <strong class="source-inline">0</strong>. Then <strong class="source-inline">echo</strong> prints the output. In this setup, the anonymous function can be called only once – there is no reference to it that would allow you to call it again.</p>
			<p>In the next example, the function will be stored in a variable named <strong class="source-inline">$callable</strong>. You may name the variable whatever you like, as long as you stick to the rules for naming variables in PHP:</p>
			<p class="source-code">$callable = function(float $value): int{</p>
			<p class="source-code">    if (0 &lt;= $value) {</p>
			<p class="source-code">        return 1;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return -1;</p>
			<p class="source-code">}; // here semicolon is added as we assign the function to $callable variable.</p>
			<p class="source-code">echo $callable(-11.4); // will print -1, because -11.4 is less than 0.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor166"/>Using a Variable from Outside of Scope Inside an Anonymous Function</h2>
			<p>As stated previously in this chapter, you may need to use a variable that was defined outside of the scope of the function you are defining. In the following exercise, you will see an example of how we can make use of the <strong class="source-inline">use</strong> keyword to pass a variable to the anonymous function.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor167"/>Exercise 4.6: Working with Anonymous Functions</h2>
			<p>In this exercise, we will declare an anonymous function and examine how it works:</p>
			<ol>
				<li value="1">Create a new file named <strong class="source-inline">callable.php</strong>. Add your opening PHP tag as follows:<p class="source-code">&lt;?php</p></li>
				<li>Then, define the initial variable that you want to use:<p class="source-code">$a = 15;</p></li>
				<li>Now define your callable function and pass your <strong class="source-inline">$a</strong> variable to it:<p class="source-code">$callable = function() use ($a) {</p><p class="source-code">    return $a;</p><p class="source-code">};</p></li>
				<li>On the next line, let's assign a new value to <strong class="source-inline">$a</strong>:<p class="source-code">$a = 'different';</p></li>
				<li>To see what the current value of <strong class="source-inline">$a</strong> is, we will call <strong class="source-inline">$callable</strong> and print it to the screen:<p class="source-code">echo $callable();</p></li>
				<li>Lastly, add a new line for readability:<p class="source-code">echo PHP_EOL;</p></li>
				<li>We can now run this script in the command line using the following command:<p class="source-code">php callable.php </p><p>The output is as follows:</p><p class="source-code">15</p><p>So, what's happening here? First, we declare an anonymous function and store it in <strong class="source-inline">$callable</strong>. We say it should use <strong class="source-inline">$a</strong> by using the <strong class="source-inline">use</strong> keyword. Then, we change the value of <strong class="source-inline">$a</strong> to <strong class="source-inline">different</strong>, call our <strong class="source-inline">$callable</strong> function, and then <strong class="source-inline">echo</strong> the result. The result is <strong class="source-inline">15</strong>, which is the initial value of <strong class="source-inline">$a</strong>. The reason for this is that when using <strong class="source-inline">use</strong> to import <strong class="source-inline">$a</strong> into the scope of the function, <strong class="source-inline">$a</strong> will be used exactly as it was at the time of function creation.</p><p>Now what happens when we use <strong class="source-inline">$a</strong> as a reference? Let's take a look:</p><p class="source-code">&lt;?</p><p class="source-code">$a = 15;</p><p class="source-code">$callable = function() use (&amp;$a) {</p><p class="source-code">    return $a;</p><p class="source-code">};</p><p class="source-code">$a = 'different';</p><p class="source-code">echo $callable(); // outputs 'different'</p><p class="source-code">// newline for readability</p><p class="source-code">echo PHP_EOL;</p><p>Note that we prefixed <strong class="source-inline">$a</strong> with <strong class="source-inline">&amp;</strong> this time. Now the output will be '<strong class="source-inline">different</strong>'.</p></li>
			</ol>
			<p>Since objects are always passed by reference, this should also be true for objects, but that is something that will be covered in another chapter.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor168"/>Exercise 4.7: Creating Variable Functions</h2>
			<p>In this exercise, we will create variable functions and examine how they work in PHP:</p>
			<ol>
				<li value="1">Open a file and name it <strong class="source-inline">variable-hello.php</strong>. Start your script with the opening PHP tag and set the strict type to <strong class="source-inline">1</strong>:<p class="source-code">&lt;?php</p><p class="source-code">declare(strict_types=1);</p></li>
				<li>Declare a variable to store the value of  the function as follows:<p class="source-code">$greeting = function(string $name): void </p><p class="source-code">{</p><p class="source-code">    echo 'Hello ' . $name;</p><p class="source-code">};</p><p>That's all you need and even a bit more, because you have added a <strong class="source-inline">string</strong> type hint and a <strong class="source-inline">void</strong> return type, which are both optional. They are good practice, so make a habit of using them. Note that the closure does not return output. Instead, it prints the greeting directly to <strong class="source-inline">stdOut</strong>.</p></li>
				<li>Now continue typing in your <strong class="source-inline">variable-hello.php</strong> script:<p class="source-code">$greeting('Susan');</p></li>
				<li>Add a newline:<p class="source-code">echo PHP_EOL;</p></li>
				<li>Verify that the output on the Terminal is <strong class="source-inline">Hello Susan</strong>:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer093">
					<img alt="Figure 4.16: Printing the output&#13;&#10;" src="image/C14196_04_16.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.16: Printing the output</p>
			<p>In this exercise, you have learned how to use string concatenation together with a function argument and how to print output directly from a function. Although this is a bad practice in many cases, it might be useful in other scenarios.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor169"/>Exercise 4.8: Playing with Functions</h2>
			<p>In this exercise, we will use a couple more predefined functions to learn about processing data and writing our processors so that they are reusable. The goal of this exercise is to take an array of directors and their movies and sort them by the director's name. We then want to process that array and print out the director's name where the first letter of the first name is in uppercase and the last name is all in uppercase. Additionally, for the movies, we want to capitalize each title, wrap them in double quotes, and separate them using commas. We will build two functions that will handle the processing of the director's name and another function for movies. We will be making use of three new built-in functions that we have yet to discuss: <strong class="source-inline">ksort</strong>, <strong class="source-inline">explode</strong>, and <strong class="source-inline">implode</strong>. To learn more about these functions, please review the documentation on <a href="https://packt.live/2OxT91A">https://packt.live/2OxT91A</a>:</p>
			<ol>
				<li value="1">First, we are going to create a new file called <strong class="source-inline">activity-functions.php</strong> and start our script with the opening PHP tag:<p class="source-code">&lt;?php</p></li>
				<li>Then, we will go ahead and define an array that will hold the director's name as a key and an array of their movies for the value:<p class="source-code-heading">activity-functions.php</p><p class="source-code">2  $directors = [</p><p class="source-code">3      'steven-spielberg' =&gt; [</p><p class="source-code">4          'ET',</p><p class="source-code">5          'Raiders of the lost ark',</p><p class="source-code">6          'Saving Private Ryan'</p><p class="source-code">7      ],</p><p class="source-code">8      'martin-scorsese' =&gt; [</p><p class="source-code">9          'Ashes and Diamonds',</p><p class="source-code">10         'The Leopard',</p><p class="source-code">11         'The River'</p><p class="source-code">12     ],</p><p class="source-code-link"><a href="https://packt.live/2p9Zbe6">https://packt.live/2p9Zbe6</a></p></li>
				<li>Now we will write our first function to process our director's name. Remember, we want the first name to have a capitalized first letter and the last name will be fully capitalized:<p class="source-code">function processDirectorName($name){</p><p class="source-code">     $nameParts = explode('-', $name);</p><p class="source-code">     $firstname = ucfirst($nameParts[0]);</p><p class="source-code">     $lastname = strtoupper($nameParts[1]);</p><p class="source-code">     return "$firstname $lastname";</p><p class="source-code">}</p></li>
				<li>Next, we will write a function to process our movie strings. Note that we want to wrap the uppercase version of each movie name and separate them with commas:<p class="source-code">function processMovies($movies)</p><p class="source-code">{</p><p class="source-code">    $formattedStrings = [];</p><p class="source-code">    for ($i = 0; $i &lt; count($movies); $i++) {</p><p class="source-code">        $formattedStrings[] = '"' . strtoupper($movies[$i]) . '"';</p><p class="source-code">    }</p><p class="source-code">    return implode(",", $formattedStrings);</p><p class="source-code">}</p></li>
				<li>Finally, we can sort our array via the array keys, and loop through and process the array:<p class="source-code">ksort($directors);</p><p class="source-code">foreach ($directors as $key =&gt; $value) {</p><p class="source-code">    echo processDirectorName($key) . ": ";</p><p class="source-code">    echo processMovies($value);</p><p class="source-code">    echo PHP_EOL;</p><p class="source-code">}</p></li>
				<li>We can now run this script in the Terminal:<p class="source-code">php activity-functions.php</p><p>You should see an output like the following:</p><p class="source-code">Felix GARY: "MEN IN BLACK: INTERNATIONAL","THE FATE OF THE FURIOUS","LAW ABIDING CITIZEN"</p><p class="source-code">Kathryn BIGELOW: "DETROIT","LAST DAYS","THE HURT LOCKER"</p><p class="source-code">Martin SCORSESE: "ASHES AND DIAMONDS","THE LEOPARD","THE RIVER"</p><p class="source-code">Steven SPIELBERG: "ET","RAIDERS OF THE LOST ARK","SAVING PRIVATE RYAN"</p><p class="callout-heading">Note</p><p class="callout">The third part of <strong class="source-inline">Felix Gary Gray</strong> is truncated in the output. Can you refactor the code to fix this bug?</p></li>
			</ol>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor170"/>Activity 4.1: Creating a Calculator</h2>
			<p>You are working on a calculator-based web app. You are given all of the user interface code but are instructed to build the function that will actually do the calculations. You are instructed to make a single function that is reusable for all the calculations that are needed within the app. </p>
			<p>The following steps will help you to complete the activity:</p>
			<ol>
				<li value="1">Create a function that will calculate and return the factorial of the input number.</li>
				<li>Create a function that will return the sum of the input numbers (a varying number of parameters).</li>
				<li>Create a function that will evaluate the <strong class="source-inline">$number</strong> input, which has to be an integer and will return whether the number is a prime number or not. The return type of this function is a Boolean (<strong class="source-inline">bool</strong>).</li>
				<li>Create a base <strong class="source-inline">performOperation</strong> function that will handle the predefined mathematical operations. The first parameter of the <strong class="source-inline">performOperation</strong> function must be a string, either '<strong class="source-inline">factorial</strong>', '<strong class="source-inline">sum</strong>', or '<strong class="source-inline">prime</strong>'. The remaining arguments are passed to the mathematical function being called as arguments.<p class="callout-heading">Note</p><p class="callout">A factorial is the product of an integer and all of the integers below it.</p></li>
			</ol>
			<p>The output should look similar to the following. The output values will depend on the numbers that you input:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer094">
					<img alt="Figure 4.17: Expected output&#13;&#10;" src="image/C14196_04_17.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.17: Expected output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 511.</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor171"/>Summary</h1>
			<p>In this chapter, you learned how you can use functions that are built into PHP to accomplish many tasks that would otherwise require you to write a lot of code to do the same thing much less quickly. You also learned various ways to write your own functions: with and without parameters, using default values or not, or even with varying amounts of parameters. You gained an understanding of functions that are pure and do not meddle with global scope versus functions that do have side effects, either because they pull variables from the global scope or receive parameters by reference and change them. You learned that you can call functions by their name or as callables stored in variables, anonymously or by name. Hopefully, you have got a taste of how flexible and powerful functions are and how they can help you to write robust code by enforcing strict types.</p>
			<p>In the next chapter, you will learn how to combine constants, variables, and functions that belong together logically into objects. This will give you an even higher level of organization in your code and will take information hiding to the next level by restricting the access level of variables and functions that are part of objects. Please remember that we call variables that live on object properties and we call functions that live on objects methods, while constants that live on objects are called class constants. Although they have a different name, they behave in a very similar way, so you will be able to reuse everything you learned in this chapter.</p>
		</div>
	</body></html>