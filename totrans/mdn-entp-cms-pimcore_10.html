<html><head></head><body>
		<div id="_idContainer164">
			<h1 id="_idParaDest-187"><em class="italic"><a id="_idTextAnchor188"/>Chapter 10</em>: Creating Pimcore Bricks</h1>
			<p>In the previous chapter, we learned how to use Pimcore to create entities and render custom web pages. Previously, in <a href="B17073_08_ePub_RK.xhtml#_idTextAnchor139"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating Custom CMS Pages</em>, we discovered how to create CMS pages using the web interface or custom <strong class="bold">Model View Controller</strong> (<strong class="bold">MVC</strong>) pages. In both cases, we'd like to have some reusable components that can be defined once and used in every case by changing some settings. Think about a contact form widget that you can drag and drop on any web page. Well, these kinds of reusable components <a id="_idIndexMarker654"/>in Pimcore are called <strong class="bold">Bricks</strong>. </p>
			<p>In this chapter, we will learn how to build reusable components that can be placed in CMS or MVC pages and, moreover, can be ported from project to project using bundles.</p>
			<p>This is our roadmap:</p>
			<ul>
				<li>Creating a bundle</li>
				<li>Understanding how a Brick works</li>
				<li>Implementing a simple Brick</li>
				<li>Implementing a contact form Brick</li>
				<li>Implementing a Slideshow brick</li>
				<li>Using bricks and blocks for a general-purpose template</li>
			</ul>
			<p>By the end of this chapter, you will have learned how to create custom interactive widgets to compose pages. This is important to cover all the needs of the users on your website.</p>
			<p>Let's start to discover bricks!</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor189"/>Technical requirements</h1>
			<p>As with the previous chapters, there is a demo that you can find on our GitHub repository here: https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/. </p>
			<p>All you need to run the demo connected to this chapter is to clone it, then navigate to the <strong class="source-inline">Full Demo</strong> folder and start the Docker environment.</p>
			<p>To do so, just follow these instructions:</p>
			<ol>
				<li>Run Docker with the following command:<p class="source-code"><strong class="bold">docker-compose up</strong></p></li>
				<li>Then, to restore all the settings from on your local machine, type the following:<p class="source-code"><strong class="bold">docker-compose exec php bash restore.sh</strong></p></li>
				<li>Navigate to <a href="http://localhost/admin">http://localhost/admin</a> and log in with your admin/pimcore credentials.</li>
			</ol>
			<p>What you will get with this setup is the following:</p>
			<ul>
				<li>A <strong class="source-inline">BlogBundle</strong> where you will find all the assets produced in this chapter</li>
				<li>A fully working Pimcore instance, with data and configuration installed</li>
			</ul>
			<p>This project is a good reference, but after all the practice we have had with Pimcore, you could also start a project from scratch and try to replicate all the steps on your own.</p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor190"/>Creating a bundle</h1>
			<p>Before starting <a id="_idIndexMarker655"/>our journey into bricks, we have to learn how to create a bundle. In <a href="B17073_07_ePub_RK.xhtml#_idTextAnchor129"><em class="italic">Chapter 7</em></a>, <em class="italic">Administrating Pimcore Sites</em>, we learned how to install a bundle released from a vendor, but how do we build our own? In this section, we will learn how a bundle is structured and how you can build it. Bundles are very important for creating a portable set of features that you can reuse or distribute across websites. In our demo project, we will create a blog bundle that is self-contained and that you can pick and place on any of your websites.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor191"/>What is a bundle?</h2>
			<p>You have <a id="_idIndexMarker656"/>used the main application for many examples in previous chapters. This is good for implementing the specific project but it is not portable. Talking simply, a bundle is a folder that contains both source code and templates. You can get this set of files by adding a composer dependency or by using a local folder. This lets you take your code and reuse it in multiple projects, or simply divide a complex application into modules. For simplicity, in this book, we will use a local folder inside the <strong class="source-inline">bundles</strong> path. Each subfolder will host a different bundle. In this chapter, we will cover all that is needed to start a blog, so we will create a <strong class="source-inline">BlogBundle</strong>. This means that we will have the <strong class="source-inline">/bundles/BlogBundle</strong> folder that will contain all the bundle-related files. This set of files is not discovered automatically; you have to add a specific configuration in your <strong class="source-inline">composer.json</strong>. In the next piece of code, there is the configuration for the blog bundle:</p>
			<p class="source-code">"autoload": {</p>
			<p class="source-code">    "psr-4": {</p>
			<p class="source-code">      "App\\": "src/",</p>
			<p class="source-code">     <strong class="bold"> "BlogBundle\\": "bundles/BlogBundle/",</strong></p>
			<p class="source-code">      "Pimcore\\Model\\DataObject\\": "var/classes/DataObject",</p>
			<p class="source-code">      "Pimcore\\Model\\Object\\": "var/classes/Object",</p>
			<p class="source-code">      "Website\\": "legacy/website/lib"</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p>As you can see in the previous snippet, the blog folder is added to the <strong class="source-inline">psr-4</strong> definition, just after the standard <strong class="source-inline">src</strong> that's mapped to the <strong class="source-inline">App</strong> namespace. In our case, we map the <strong class="source-inline">BlogBundle</strong> namespace with the <strong class="source-inline">bundles/BlogBundle/</strong> folder. Of course, you can play with this configuration and create your own setup to fit your needs. Anyway, we recommend keeping the configuration as close as possible to the Symfony standard.</p>
			<p>Here is a list of folders and files inside a bundle:</p>
			<ul>
				<li><strong class="source-inline">/bundles/BlogBundle</strong>: This is the bundle folder that contains all the bundle assets. The bundle is self-contained, so it contains all the resources (config, themes, and so on) and the classes.<strong class="bold"> </strong></li>
				<li><strong class="source-inline">DependencyInjection</strong>: This contains two important <a id="_idIndexMarker657"/>files for configuring the bundle: <strong class="source-inline">BlogExtension.php</strong> (the convention is the name of the bundle without the <strong class="source-inline">Bundle</strong> word and then <strong class="source-inline">Extension.php</strong>) and <strong class="source-inline">Configuration.php</strong>. </li>
				<li><strong class="source-inline">Document/Areabrick</strong>: This folder is used for <strong class="source-inline">Brick</strong> classes; we will look at it in detail in <a id="_idIndexMarker658"/>the next section.</li>
				<li><strong class="source-inline">Controller</strong>: This folder contains the controllers.</li>
				<li><strong class="source-inline">Resources</strong>: This contains the following subfolders:<p>a) <strong class="source-inline">config</strong>: Where your YAML files are built.</p><p>b) <strong class="source-inline">public</strong>: Here you can load all the assets that will be published under <strong class="source-inline">/bundles/{bundle name}/</strong>, so if you add here a file called <strong class="source-inline">script.js</strong>, you will have it at <a href="http://localhost/bundles/blog/script.js">http://localhost/bundles/blog/script.js</a>.</p><p>c) <strong class="source-inline">views</strong>: You can create here a subfolder containing templates for each controller. This folder also contains the <strong class="source-inline">Areas</strong> subfolder, which will have all the <strong class="source-inline">Brick</strong> templates.</p></li>
			</ul>
			<p>Now it's time to create our first bundle!</p>
			<h3>Creating a bundle from the command line</h3>
			<p>You could<a id="_idIndexMarker659"/> manually create the files and folders by <a id="_idIndexMarker660"/>using the naming convention. This is not hard, but it is easy to make some errors while doing it manually. Fortunately, we have a command from Pimcore that does the job for us. </p>
			<p>In Symfony 5, this is no longer a built-in feature, so we have to install a bundle from Pimcore and then we can use the console to create a bundle skeleton.</p>
			<p>Creating a bundle is very straightforward and will be explained in the next steps:</p>
			<ol>
				<li value="1">Enter your Docker instance using the following command:<p class="source-code"><strong class="bold"> docker-compose exec php bash</strong></p></li>
				<li>Install the bundle generator using the following command:<p class="source-code"><strong class="bold">composer require pimcore/bundle-generator</strong></p><p>The previous command will add the bundle and configure it for use as a regular console command.</p></li>
				<li>Navigate <a id="_idIndexMarker661"/>to <strong class="source-inline">config/bundles.php</strong> and <a id="_idIndexMarker662"/>register the bundle using the following piece of code:<p class="source-code">&lt;?php</p><p class="source-code">use Pimcore\Bundle\BundleGeneratorBundle\</p><p class="source-code">PimcoreBundleGeneratorBundle;</p><p class="source-code">return [</p><p class="source-code">    PimcoreBundleGeneratorBundle::class =&gt; ['all' =&gt;     true],</p><p class="source-code">];</p></li>
				<li>Run the following command:<p class="source-code"> <strong class="bold">bin/console pimcore:generate:bundle BlogBundle</strong></p><p>This will create a set of folders and files for your bundle. The result after you run this command is the creation of the bundle with all the basic subfolders. </p></li>
				<li>Moreover, in order to make the bundle content available for the application, we need to change our composer definition by adding a namespace mapping, as in the next example:<p class="source-code">"psr-4": {</p><p class="source-code">      "App\\": "src/",</p><p class="source-code">      "BlogBundle\\": "bundles/BlogBundle/",</p><p class="source-code">      …</p><p class="source-code">    }</p><p>After this step, you might need to run <strong class="source-inline">chmod -R www-data.</strong> for a permission fix. In the Docker example we provided, this is mandatory.</p></li>
				<li>Now the <a id="_idIndexMarker663"/>bundle is available for the system and<a id="_idIndexMarker664"/> can be enabled and installed as explained in <a href="B17073_03_ePub_RK.xhtml#_idTextAnchor062"><em class="italic">Chapter 3</em></a>, <em class="italic">Getting Started with Pimcore Admin UI</em>.</li>
			</ol>
			<p>In this section, we learned how a bundle is composed and how to create a new one. Now that we have our bundle ready, we can start talking about bricks by using some practical examples.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor192"/>Understanding how a Brick works</h1>
			<p>In simple<a id="_idIndexMarker665"/> words, a Brick is composed of a class that takes the place of the controller and a view. Building a Brick is not so different from implementing an MVC page. The most important exception is that, in this case, we do not have the routing part, as the Brick is added to an existing page (it cannot be run standalone). In the following diagram, we have a schema that explains how Bricks work:</p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/Figure_10.01_B17073.jpg" alt="Figure 10.1: Conceptual schema for a brick&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1: Conceptual schema for a brick</p>
			<p>In the previous diagram, we can see that a page (<strong class="bold">My Page</strong>) can host many bricks. Each one is composed of a <strong class="bold">Class</strong> and two templates (<strong class="bold">edit</strong> and <strong class="bold">view</strong>).</p>
			<p>In the following <a id="_idIndexMarker666"/>sections, we will learn how to implement every single component, including classes and templates.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor193"/>The class implementation</h2>
			<p>A brick <a id="_idIndexMarker667"/>is an instance of <strong class="source-inline">Pimcore\Extension\Document\Areabrick\AreabrickInterface</strong>, but for convenience, we always extend the <strong class="source-inline">AbstractTemplateAreabrick</strong> class, which implements the interface and gives us some interesting methods. These classes can be loaded manually or autoloaded using YAML files. Even if adding classes to YAML files is easy, it is always an additional step to do. So, we usually prefer the autoloading scenario, which simply requires us to use a default folder (<strong class="source-inline">Document/Areabrick</strong>) where we place the classes. The namespace of your class must be <strong class="source-inline">namespace BlogBundle\Document\Areabrick</strong>.</p>
			<p>The following class implements a simple brick:</p>
			<p class="source-code">class MyBrick extends AbstractTemplateAreabrick</p>
			<p class="source-code">{</p>
			<p class="source-code">    public function <strong class="bold">getName</strong>()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return 'The Brick Name';</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public function <strong class="bold">getDescription</strong>()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return 'The Brick description';</p>
			<p class="source-code">    }</p>
			<p class="source-code">     public function <strong class="bold">getTemplateSuffix</strong>()</p>
			<p class="source-code">     {</p>
			<p class="source-code">          return static::TEMPLATE_SUFFIX_TWIG;</p>
			<p class="source-code">     }</p>
			<p class="source-code">}</p>
			<p>As you can<a id="_idIndexMarker668"/> see in the preceding snippet, there are some methods that have to be implemented to provide the information for your components. These methods, highlighted in the code, are as follows:</p>
			<ul>
				<li><strong class="source-inline">getName</strong>: This method returns the name of the brick (it should be unique).</li>
				<li><strong class="source-inline">getDescription</strong>: This method returns the long description of the brick and it is shown in the web interface to give the user an idea of what the brick does.</li>
				<li> <strong class="source-inline">getTemplateSuffix</strong>: This method is used for defining the template extension (Twig or PHP). To adopt Twig templates instead of a PHP template, use <strong class="source-inline">static::TEMPLATE_SUFFIX_TWIG</strong>.</li>
			</ul>
			<p>Now that the class part is ready, we can see how to set up the templating in the next section.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor194"/>Templating</h2>
			<p>Usually, for <a id="_idIndexMarker669"/>brick classes, the template follows a naming convention. The place where they have to be located is the <strong class="source-inline">Areas</strong> folder inside the view folder (<strong class="source-inline">Resources/views</strong>). Each brick must have its own folder, but the folder name must be in spinal case (all lowercase with hyphens between words, so <strong class="source-inline">MyBrick</strong> will need a folder named <strong class="source-inline">my-brick</strong>). The name of the view template has to be <strong class="source-inline">view.html.twig</strong>. </p>
			<p>Some bricks are fully WYSIWYG, and you can change the component's behavior just by entering data. Others have the configuration separated by the rendering. In these cases, you can configure an edit popup that will prompt for data. We will see that configuration in detail with the next sections' examples. </p>
			<p>In the next schema, we summarized the naming convention, adding a path example for each case. The <strong class="bold">Global</strong> scenario is the option where you add the brick to the main project (app folder) and the <strong class="bold">Bundle</strong> scenario is where you will add the brick to specific a bundle:</p>
			<ul>
				<li><strong class="bold">View path</strong>:<p>a) <strong class="bold">Global</strong>: </p><p class="source-code"><strong class="bold">templates/views/Areas/{BrickID}/view.html.(php|twig)</strong></p><p>b) <strong class="bold">Bundle</strong>: </p><p class="source-code"><strong class="bold">{BundleLocation}/Resources/views/Areas/iframe/view.html.(php|twig)</strong></p></li>
				<li><strong class="bold">Class</strong>:<p>a) <strong class="bold">Global</strong>: </p><p class="source-code"><strong class="bold">src/Document/Areabrick/{BrickID}</strong></p><p>b) <strong class="bold">Bundle</strong>: </p><p class="source-code"><strong class="bold">{BundleLocation}/Document/Areabrick/{BrickID}</strong></p></li>
			</ul>
			<p>In this section, we learn what a brick is composed of. This was important for understanding the naming convention and the principles for using them. Now it's time to go in depth with some examples! In the next section, we will cover the most important use <a id="_idIndexMarker670"/>cases, from easy to complex usage.</p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor195"/>Implementing a simple brick</h1>
			<p>In this <a id="_idIndexMarker671"/>section, we will implement our first brick. Because the spirit of this book is to learn using real-world examples, we won't limit this to a "hello world" example. In our first example, we will create a widget that could be placed many times on the page and reused. This widget will allow adding text, choosing the header type (h1, h2, and so on), and entering the text.</p>
			<p>To complete this goal, we have to follow these steps:</p>
			<ol>
				<li value="1">Create a document and link it to a controller and a template file. We have done this step many times in <a href="B17073_04_ePub_RK.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating Documents in Pimcore</em>, and <a href="B17073_09_ePub_RK.xhtml#_idTextAnchor166"><em class="italic">Chapter 9</em></a>, <em class="italic">Configuring Entities and Rendering Data</em>. This document will be used for testing the brick that we are creating.</li>
				<li>Create a <strong class="source-inline">Heading.php</strong> file inside <strong class="source-inline">/bundles/BlogBundle/Document/Areabrick</strong>. The contents of the file should be like this:<p class="source-code">class Header extends AbstractTemplateAreabrick</p><p class="source-code">{</p><p class="source-code">    public function getName()</p><p class="source-code">    {</p><p class="source-code">        return 'Header';</p><p class="source-code">    }</p><p class="source-code">    public function getDescription()</p><p class="source-code">    {</p><p class="source-code">        return 'A component for rendering a Header';</p><p class="source-code">    }</p><p class="source-code">    public function getTemplateLocation()</p><p class="source-code">    {</p><p class="source-code">        return static::TEMPLATE_LOCATION_BUNDLE;</p><p class="source-code">    }</p><p class="source-code">}</p><p>The code provided declares a brick called <strong class="source-inline">Header</strong> with a specific description. Now that <a id="_idIndexMarker672"/>we have the brick definition, we have to add a template for it. This will be our next step.</p></li>
				<li>Add a template in <strong class="source-inline">/bundles/BlogBundle/Resources/views/Areas</strong> called <strong class="source-inline">view.html.twig</strong>.</li>
				<li>Add the following code to the file:<p class="source-code">{% if editmode %}</p><p class="source-code">{{pimcore_select('style', {</p><p class="source-code">            "store" : [</p><p class="source-code">                ['h1', 'H1'],</p><p class="source-code">                ['h2', 'H2'],</p><p class="source-code">                ['h3', 'H3']</p><p class="source-code">            ],</p><p class="source-code">            "defaultValue" : "h1"</p><p class="source-code">})}}</p><p class="source-code">{{pimcore_input('text')}}</p><p class="source-code">        </p><p class="source-code">{% else %}</p><p class="source-code">&lt;{{pimcore_select('style')}}&gt;{{pimcore_input('text')}}&lt;{{pimcore_select('style')}}&gt;</p><p class="source-code">{% endif %}</p><p>The code is divided into two branches. The first one is activated in edit mode and displays a select component that lets you choose the heading type (h1, h2, and so on) and<a id="_idIndexMarker673"/> the text; the second branch of code displays the data wrapping text in the header. All we need to implement our first brick is done; we just have to test it now.</p></li>
				<li>Inside the template that was created in <em class="italic">Step 1</em>, add the following snippet:<p class="source-code">{{ pimcore_areablock("header")}}</p><p>This editable will display the following component in edit mode:</p><div id="_idContainer144" class="IMG---Figure"><img src="image/Figure_10.02_B17073.jpg" alt="Figure 10.2: Editable components&#13;&#10;"/></div><p class="figure-caption">Figure 10.2: Editable components</p><p>This component is just a placeholder that will let us choose a brick from the brick list and will put it inside the page. We will do this in the next step.</p></li>
				<li>Click on the plus button. It will display the following menu:<div id="_idContainer145" class="IMG---Figure"><img src="image/Figure_10.03_B17073.jpg" alt="Figure 10.3: The menu for Areablock&#13;&#10;"/></div><p class="figure-caption">Figure 10.3: The menu for Areablock</p><p>As you can see in the preceding screenshot, the data we entered into the class is used to distinguish the component. In fact, we chose <strong class="bold">Header</strong> as the brick name and <strong class="bold">A component for rendering a Header</strong> as the description.</p></li>
				<li>Click on the <strong class="bold">Header</strong> item. A component will be added to the page. The Pimcore editable component lets us enter the title and pick the right heading type. Choose <strong class="bold">H1</strong> and <a id="_idIndexMarker674"/>enter <strong class="source-inline">My H1 text</strong> into the box:<div id="_idContainer146" class="IMG---Figure"><img src="image/Figure_10.04_B17073.jpg" alt="Figure 10.4: The heading brick editing&#13;&#10;"/></div><p class="figure-caption">Figure 10.4: The heading brick editing</p></li>
				<li>Now click the <strong class="bold">Preview</strong> button or navigate to the page. The output will be the following:</li>
			</ol>
			<div>
				<div id="_idContainer147" class="IMG---Figure">
					<img src="image/Figure_10.05_B17073.jpg" alt="Figure 10.5: The output of the brick&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5: The output of the brick</p>
			<p>The page displays the text we chose properly. </p>
			<p>This first example shows how simple it is to create a reusable component in Pimcore. In fact, we can use the heading brick on every page, giving the user the power of picking it when needed and configuring it. You can use this in conjunction with <strong class="bold">blocks</strong> to allow the user to <a id="_idIndexMarker675"/>choose a sequence of custom elements or hardcode it in a template. Moreover, we can also use an interactive brick. We will discover all these features in the next sections.</p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor196"/>Implementing a contact form brick</h1>
			<p>In this<a id="_idIndexMarker676"/> example, we will discover how to create an interactive component where the user can insert data. For this purpose, we will create a contact form. The behavior of this widget will be straightforward: we will have a form with a subject, name, message, and clickable button. An email will be sent to a fixed recipient address once the details are filled in and the button is clicked. This example will also introduce a working example of opening the brick's editor to get parameters not shown in the view. Follow these steps to implement the example:</p>
			<ol>
				<li value="1">First, create a document with a template and place an <strong class="source-inline">areabrick</strong> in the editable's template. In the next step, we will have to create the brick. </li>
				<li>Create the <strong class="source-inline">ContactForm.php</strong> file in <strong class="source-inline">/bundles/BlogBundle/Document/Areabrick/</strong>. The content will be as follows:<p class="source-code">class ContactForm extends AbstractTemplateAreabrick</p><p class="source-code">{</p><p class="source-code">    public function getName()</p><p class="source-code">    {</p><p class="source-code">        return 'ContactForm';</p><p class="source-code">    }</p><p class="source-code">    public function getDescription()</p><p class="source-code">    {</p><p class="source-code">        return 'ContactForm';</p><p class="source-code">    }</p><p class="source-code">    public function getTemplateLocation()</p><p class="source-code">    {</p><p class="source-code">        return static::TEMPLATE_LOCATION_BUNDLE;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Now we need to ask the user to add the recipient address for the contact form. In a complex <a id="_idIndexMarker677"/>scenario, you may need to add more parameters and organize them. This is possible by implementing a special <strong class="source-inline">EditableDialogBoxInterface</strong> interface. In the next piece of code, we can see the code that we have to add:<p class="source-code">class ContactForm extends AbstractTemplateAreabrick implements EditableDialogBoxInterface</p><p class="source-code">{</p><p class="source-code">  public function   getEditableDialogBoxConfiguration(Document\Editable   $area, ?Info $info): EditableDialogBoxConfiguration</p><p class="source-code">    {</p><p class="source-code">        $config = new EditableDialogBoxConfiguration();</p><p class="source-code">      </p><p class="source-code">        $config-&gt;setItems([</p><p class="source-code">            'type' =&gt; 'tabpanel',</p><p class="source-code">            'items' =&gt; [</p><p class="source-code">                [</p><p class="source-code">                    'type' =&gt; 'panel',</p><p class="source-code">                    'title' =&gt; 'Contact Form Settings',</p><p class="source-code">                    'items' =&gt; [</p><p class="source-code">                        [</p><p class="source-code">                            'type' =&gt; 'input',</p><p class="source-code">                            'label' =&gt; 'Email Recipient',</p><p class="source-code">                            'name' =&gt; 'recipient'</p><p class="source-code">                        ]</p><p class="source-code">                        </p><p class="source-code">            ]</p><p class="source-code">            ]</p><p class="source-code">        ]]);</p><p class="source-code">        return $config;</p><p class="source-code">    }</p><p class="source-code">}</p><p>The<a id="_idIndexMarker678"/> configuration is, in fact, an array of items that can be grouped in a container. In our case, we used a tab pane, and we placed the input inside it. This array will be used to automatically generate the user's input form. Entered data will be available to the user as regular editables, as in the following snippet:</p><p class="source-code">$recipient=$this-&gt;getDocumentEditable($info-&gt;getDocument(), 'input', 'recipient')-&gt;getData();</p></li>
				<li>Create the <strong class="source-inline">view.html.twig</strong> file. This file will contain all the content that will be displayed to the user. In the next snippet of code, we have a simplified version of the form for brevity (the full bootstrap example is in the source code related to <a id="_idIndexMarker679"/>this book):<p class="source-code">{% if alert is defined %}</p><p class="source-code">  {{ alert }}</p><p class="source-code"> {% endif%}</p><p class="source-code">        </p><p class="source-code">&lt;form id="contact-form" name="contact-form" method="POST"&gt;</p><p class="source-code">   &lt;input type="hidden" name="sendEmail" value="true"/&gt;</p><p class="source-code">   &lt;input type="text" id="name" name="name" &gt;</p><p class="source-code">   &lt;input type="text" id="email" name="email" &gt;</p><p class="source-code">   &lt;input type="text" id="subject" name="subject" &gt;</p><p class="source-code">   &lt;textarea type="text" id="message" name="message" &gt;</p><p class="source-code">   &lt;/textarea&gt;</p><p class="source-code">   &lt;input type="submit" value="submit" /&gt;</p><p class="source-code">&lt;/form&gt;</p><p>The template contains an alert message, which is a message used to confirm sending the email to the user or to display an error. The form contains the input for getting the field from the user and a submit button. The action is not specified, so this form will submit data to the page itself. The input hidden <strong class="source-inline">sendEmail</strong> is a flag that will activate the sending procedure.</p></li>
				<li>Now it's time to specify logic in the backend for reading POST data and to send a real email. The next snippet shows the method to add to the brick class:<p class="source-code">public function action(Info $info)</p><p class="source-code">{  </p><p class="source-code">     $request=$info-&gt;getRequest();</p><p class="source-code">     $id= $info-&gt;getEditable()-&gt;getName();</p><p class="source-code">     $info-&gt;setParam('id', $id);</p><p class="source-code">     $sendEmail=$request-&gt;get("sendEmail");</p><p class="source-code">     if($sendEmail==$id)</p><p class="source-code">     {</p><p class="source-code">          $name=$request-&gt;get("name");</p><p class="source-code">          $email=$request-&gt;get("email");</p><p class="source-code">          $subject=$request-&gt;get("subject");</p><p class="source-code">          $message=$request-&gt;get("message");</p><p class="source-code">        </p><p class="source-code">          //send an email here</p><p class="source-code">          $sent= $this-&gt;sendEmail($name,$email,</p><p class="source-code">          $subject,$message, $recipient);</p><p class="source-code">          if($sent)</p><p class="source-code">          {</p><p class="source-code">               $alert="the message is sent!";</p><p class="source-code">          }</p><p class="source-code">          else</p><p class="source-code">          {</p><p class="source-code">               $alert="there was an error, try later";</p><p class="source-code">          }</p><p class="source-code">          $info-&gt;setParam('name',$name);</p><p class="source-code">          $info-&gt;setParam('email',$email);</p><p class="source-code">          $info-&gt;setParam('subject',$subject);</p><p class="source-code">          $info-&gt;setParam('message',$message);</p><p class="source-code">          $info-&gt;setParam('alert',$alert);</p><p class="source-code">        </p><p class="source-code">          </p><p class="source-code">     }</p><p class="source-code">     $recipient=$this-&gt;getDocumentEditable($info-&gt;</p><p class="source-code">     getDocument(), 'input', 'recipient')-&gt;getData();</p><p class="source-code">     $info-&gt;setParam('recipient',$recipient);        </p><p class="source-code">     </p><p class="source-code">}</p><p>The<a id="_idIndexMarker680"/> preceding code implements the logic for getting parameters and sends an email notifying the user about the result. <strong class="source-inline">$request=$info-&gt;getRequest();</strong> is used to get the HTTP request that contains the submitted data, and the <strong class="source-inline">get</strong> method is used to obtain the value of the <strong class="source-inline">sendEmail</strong> flag, which activates the sending procedure. You can pass variables to the view by using the parameters, as in the following piece of code:</p><p class="source-code">$info-&gt;setParam('recipient',$recipient);  </p><p>Now all the components are in place to test our brick.</p></li>
				<li>Add the brick to the page by following <em class="italic">Steps 5-6</em> from the <em class="italic">Implementing a simple brick</em> section. Now you will have the contact form component on the page and it will be a working one.</li>
				<li>Open the settings by clicking the pencil icon in the brick's toolbar:<div id="_idContainer148" class="IMG---Figure"><img src="image/Figure_10.06_B17073.jpg" alt="Figure 10.6: Opening the popup&#13;&#10;"/></div><p class="figure-caption">Figure 10.6: Opening the popup</p></li>
				<li>By clicking <a id="_idIndexMarker681"/>the pencil icon, a popup will be shown:<div id="_idContainer149" class="IMG---Figure"><img src="image/Figure_10.07_B17073.jpg" alt="Figure 10.7: The popup for entering the recipient&#13;&#10;"/></div><p class="figure-caption">Figure 10.7: The popup for entering the recipient</p><p>You can enter an email address to be used as the recipient for the contact form.</p></li>
				<li>Save the document and open the document's page you created in <em class="italic">Step 1</em> of this section. The contact form will be shown. </li>
				<li>Fill in the form with data (it is a contact form, so the field meanings should be self-explanatory) and click <strong class="bold">Send</strong>. You should see a confirmation alert as in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/Figure_10.08_B17073.jpg" alt="Figure 10.8: The contact form showing the confirmation message after sending&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.8: The contact form showing the confirmation message after sending</p>
			<p>As you have <a id="_idIndexMarker682"/>learned from this example, it is quite easy to implement an interactive widget such as a contact form. Anyway, there are some tricks to know to avoid conflicts when you have multiple components on the same page. We will explain this in the next section.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor197"/>Avoiding conflicts</h2>
			<p>For the contact<a id="_idIndexMarker683"/> form example, we have to raise a point about submitting data on a page with multiple bricks. Using the post approach, we send data to the server and manage the request on the backend. This procedure is very easy but it can lead to some issues. In fact, think about a case where you have many components on the same page. </p>
			<p>In our example, if we put two contact form widgets on the same page, clicking send will trigger both actions. The same can happen with different components with similar field names. </p>
			<p>To avoid such conflicts, follow these troubleshooting steps:</p>
			<ol>
				<li value="1">Add a unique prefix (per component) to all the field names. In our case, this could be <strong class="source-inline">cf</strong> for <strong class="source-inline">ContactForm</strong>, and the name will be <strong class="source-inline">cf-name</strong>, <strong class="source-inline">cf-sendEmail</strong>, and so on.</li>
				<li>Add the instance name as the trigger value. This is required to make your post unique. The changes to the action method of the brick class (created in <em class="italic">Step 5</em> of <em class="italic">Implementing a contact form brick</em>) are the following:<p class="source-code">…</p><p class="source-code">$id= $info-&gt;getEditable()-&gt;getName();</p><p class="source-code">$sendEmail=$request-&gt;get("cf-sendEmail");</p><p class="source-code">if($sendEmail==$id)</p><p class="source-code">{</p><p class="source-code">…</p><p>The email <a id="_idIndexMarker684"/>sending procedure is now processed only if the name of the component is exactly the same that originates the post. Two different instances of the same brick produce different names, so your action will be triggered only once.</p><p>The final step is to make a small change in the view template file (created in <em class="italic">Step 3</em> of <em class="italic">Implementing a contact form brick</em>). We will be adding a hidden input with the <strong class="source-inline">cf-sendEmail</strong> name attribute and the ID computed from the action method as <strong class="source-inline">value</strong>. Cut and paste the next snippet to your view file:</p><p class="source-code">&lt;input type="hidden" name="cf-sendEmail" value="{{id}}"/&gt;</p><p>This value will be sent back to our action method with the post argument and we will be comparing it with the one generated on the server side. If they are not equal, the post is not matched to the current component, and we avoid any action.</p></li>
			</ol>
			<p>In this section, we learned how to implement a contact form. The example we have just finished showed us how simple it is to create an interactive brick that can be reused. You are not only able to reuse this component on any page of your website, but you can also copy the bundle to another website and get this feature for free. In the next example, we will discover how to implement a slideshow, mixing controllers and bricks to reuse the<a id="_idIndexMarker685"/> code that we might have written for an MVC page.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor198"/>Implementing a slideshow brick</h1>
			<p>In this example, we<a id="_idIndexMarker686"/> will build a slideshow widget that can be used to display a carousel of images. This will be very easy, and we will use just bootstrap and the tools learned so far. In fact, we will reuse the code used for displaying the image gallery in <a href="B17073_09_ePub_RK.xhtml#_idTextAnchor166"><em class="italic">Chapter 9</em></a>,<em class="italic"> Configuring Entities and Rendering Data</em>, but we will integrate it into a brick. To do that, follow these steps:</p>
			<ol>
				<li value="1">First of all, prepare the environment by creating a folder called <strong class="source-inline">Slideshow</strong> and upload a list of images to it. We should use wide images (such as 1920x1080).</li>
				<li>Open the image settings for each image and add the title and description of the image as metadata. We will use it in the template. </li>
				<li>Access the properties panel by clicking the <strong class="bold">Properties</strong> tab button on the toolbar. Each Pimcore entity (objects, documents, and assets) has a set of key/pair properties that can be used to expand the information dynamically. We will use them to add metadata to our images. In the next screenshot, we can see a valid configuration:<div id="_idContainer151" class="IMG---Figure"><img src="image/Figure_10.09_B17073.jpg" alt="Figure 10.9: Image properties&#13;&#10;"/></div><p class="figure-caption">Figure 10.9: Image properties</p><p>The previous screenshot shows the properties table. We added a title and subtitle field with some value inside.</p></li>
				<li>Create a thumbnail preset. We have to configure the thumbnail engine to resize the uploaded images to match the format that the slideshow component expects. The user could upload images too big or with the wrong proportions (for example, landscape instead of portrait) but we need to make sure that all the images have the same height to show the images properly. We need to crop the uploaded images and make them the same format. In our example, we can use a crop transformation that will produce images that are only 400 px tall. To do that, just<a id="_idIndexMarker687"/> enter the <strong class="bold">Width, Height</strong> and <strong class="bold">X, Y</strong> settings as in the following screenshot:<div id="_idContainer152" class="IMG---Figure"><img src="image/Figure_10.10_B17073.jpg" alt="Figure 10.10: The thumbnail configuration&#13;&#10;"/></div><p class="figure-caption">Figure 10.10: The thumbnail configuration</p></li>
				<li>Create a brick called <strong class="source-inline">SlideShow</strong> by adding <strong class="source-inline">SlideShow.php</strong> in the brick class folder (for example, <strong class="source-inline">/bundles/BlogBundle/Document/Areabrick/SlideShow.php</strong>).</li>
				<li>Create the template file in the view folder (for example, <strong class="source-inline">/bundles/BlogBundle/Resources/views/Areas/slide-show</strong>). Pay attention to the folder name – it has to match the brick name, but it's lowercase with the words split with a hyphen, so <strong class="source-inline">slide-show</strong> will be <strong class="source-inline">Slideshow</strong>.</li>
				<li>Now add the following content to the template:<p class="source-code">{{</p><p class="source-code">     pimcore_renderlet('myGallery', {</p><p class="source-code">           "controller" : "BlogBundle\\Controller\\</p><p class="source-code">           SlideShowController::galleryAction",</p><p class="source-code">           "title" : "Drag an asset folder here to get </p><p class="source-code">           a gallery",</p><p class="source-code">           "height" : 400</p><p class="source-code">     })</p><p class="source-code">}}</p><p>The preceding <a id="_idIndexMarker688"/>code adds a Pimcore renderlet that lets the user drag a folder on it and uses a controller for implementing the rendering logic. In our case, we will use the gallery action from the <strong class="source-inline">SlideShow</strong> controller. We are using a controller in a bundle, so we must specify the bundle name also.</p></li>
				<li>Add the <strong class="source-inline">SlideShow</strong> controller to the controller folder (for example, <strong class="source-inline">/bundles/BlogBundle/Document/Controller/SlideShowController.php</strong>). The initial content should be the following:<p class="source-code">&lt;?php</p><p class="source-code">namespace BlogBundle\Controller;</p><p class="source-code">use Pimcore\Controller\FrontendController;</p><p class="source-code">use Symfony\Component\HttpFoundation\Request;</p><p class="source-code">use Symfony\Component\HttpFoundation\Response;</p><p class="source-code">use Symfony\Component\Routing\Annotation\Route;</p><p class="source-code">use Sensio\Bundle\FrameworkExtraBundle\Configuration\Template;</p><p class="source-code">use Pimcore\Model\Asset;</p><p class="source-code">class SlideShowController extends FrontendController</p><p class="source-code">{</p><p class="source-code">}</p></li>
				<li>Now we have<a id="_idIndexMarker689"/> to implement the action for rendering the view. This action will take the folder added by the user and will load the image list for passing it to the view. In the following snippet, we have the action implementation; take it and add it to your controller:<p class="source-code">public function galleryAction(Request $request)</p><p class="source-code">{</p><p class="source-code">     $result=array();</p><p class="source-code">     if ('asset' === $request-&gt;get('type')) {</p><p class="source-code">          $asset = Asset::getById($request-&gt;</p><p class="source-code">          get('id'));</p><p class="source-code">          if ('folder' === $asset-&gt;getType()) {</p><p class="source-code">             $result['assets'] = $asset-&gt;</p><p class="source-code">              getChildren();</p><p class="source-code">          }</p><p class="source-code">     }</p><p class="source-code">     return $result;</p><p class="source-code">}</p><p>The code is the same as what we used in the gallery example of <em class="italic">Chapter 9</em>, <em class="italic">Configuring Entities and Rendering Data</em>, so there is no need for more explanation.</p></li>
				<li>The last step for rendering it properly is to create a view called <strong class="source-inline">gallery</strong> and place it into<a id="_idIndexMarker690"/> the folder relative to the controller (for example, <strong class="source-inline">/bundles/BlogBundle/Resources/views/slide_show/gallery.twig</strong>). The template that we will use is the following:<p class="source-code">&lt;div id="carouselExampleControls" ...&gt;</p><p class="source-code">  ... omitted bootstrap tags  </p><p class="source-code">  {% if assets %}</p><p class="source-code">     {% set active ='active' %}</p><p class="source-code">     {% for asset in assets %}</p><p class="source-code">          {% if asset is instanceof('\\Pimcore\\</p><p class="source-code">          Model\\Asset\\Image') %}</p><p class="source-code">               &lt;div class="carousel-item  {{ active </p><p class="source-code">                }}"&gt;</p><p class="source-code">                  &lt;img src<strong class="bold">="{{ asset.getThumbnail(</strong></p><p class="source-code">                    <strong class="bold">'SlideShow') }}</strong>"  ... /&gt;</p><p class="source-code">                  &lt;div ...&gt;</p><p class="source-code">                    &lt;h5<strong class="bold">&gt;{{ asset.getProperty('title') </strong></p><p class="source-code">                    <strong class="bold">}}</strong>&lt;/h5&gt;</p><p class="source-code">                    &lt;p<strong class="bold">&gt;{{ asset.getProperty(</strong></p><p class="source-code">                    <strong class="bold">'subtitle') }}</strong>&lt;/p&gt;</p><p class="source-code">                    &lt;/div&gt;</p><p class="source-code">               &lt;/div&gt;</p><p class="source-code">               {% set active=""%}</p><p class="source-code">          {% endif %}</p><p class="source-code">     {% endfor %}</p><p class="source-code"> {% endif %}</p><p class="source-code">      ... omitted bootstrap tags for navigation  </p><p class="source-code">&lt;/div&gt;</p><p>In the<a id="_idIndexMarker691"/> preceding snippet, all the tags that are not relevant to our explanation are omitted for brevity. Focusing on the part that really matters, we have a simple <strong class="source-inline">for</strong> loop that prints images following the bootstrap carousel standard. The image thumbnail is extracted from the original image using the <strong class="source-inline">getThumbnail('SlideShow')</strong> function. The <strong class="source-inline">title</strong> and <strong class="source-inline">subtitle</strong> fields are read from the asset properties using the <strong class="source-inline">asset.getProperty</strong> method. </p></li>
				<li>Add the brick to a page and drag a folder to it:<div id="_idContainer153" class="IMG---Figure"><img src="image/Figure_10.11_B17073.jpg" alt="Figure 10.11: Dragging the folder to the component&#13;&#10;"/></div><p class="figure-caption">Figure 10.11: Dragging the folder to the component</p></li>
				<li>Now you will see a sliding carousel as in the next screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer154" class="IMG---Figure">
					<img src="image/Figure_10.12_B17073.jpg" alt="Figure 10.12: The slideshow in action&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.12: The slideshow in action</p>
			<p>In the previous screenshot, we highlighted the navigation buttons and the fields printed over the image.</p>
			<p>In this section, we<a id="_idIndexMarker692"/> discovered how we can integrate controllers and bricks. The same result can be achieved by using the relation editable covered in <a href="B17073_08_ePub_RK.xhtml#_idTextAnchor139"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating Custom CMS Pages</em>, and implementing the template inside the brick itself. Now that we have covered all the topics relating to bricks, it's time to learn how to implement a layout that could let us create any kind of page without writing any additional code.</p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor199"/>Using bricks and blocks for a general-purpose template</h1>
			<p>What we <a id="_idIndexMarker693"/>want to do in this section is to find a <a id="_idIndexMarker694"/>solution for implementing all kinds of layouts without wasting hours creating custom templates. Theoretically speaking, we could have a set of base objects and then mount them together to create all kinds of websites. In practice, this is what we should do with Pimcore:</p>
			<div>
				<div id="_idContainer155" class="IMG---Figure">
					<img src="image/Figure_10.13_B17073.jpg" alt="Figure 10.13: General-purpose template&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.13: General-purpose template</p>
			<p>The previous diagram shows how a multipurpose layout is structured. We have many horizontal sections (<strong class="bold">Section 1</strong>, …, <strong class="bold">Section N</strong>) that can be divided into columns (<strong class="bold">col1</strong>, <strong class="bold">col2</strong>, <strong class="bold">col3</strong>). In each place, you will be able to add bricks for composing the page in any layout you want. </p>
			<p>Theoretically speaking, we need to add a block iteration that will print rows inside another block iteration that will print columns. This lets us create a matrix of elements where we can add an <strong class="source-inline">areablock</strong> that lets us choose any brick we want. This layout is quite easy to implement in words, and feasible by putting into practice what we learned in the last chapters. </p>
			<p>In this <a id="_idIndexMarker695"/>example, we will create a generic layout<a id="_idIndexMarker696"/> like the one that is shown in the following figure:</p>
			<div>
				<div id="_idContainer156" class="IMG---Figure">
					<img src="image/Figure_10.14_B17073.jpg" alt="Figure 10.14: Generic website layout&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.14: Generic website layout</p>
			<p>In the preceding figure, we can note the three bands (<strong class="bold">Header</strong>, <strong class="bold">contact form</strong> with a description on the left side, and then a <strong class="bold">full width</strong> <strong class="bold">slideshow</strong>). This is, of course, a very simple use case, but with some imagination, you should understand how you can extend this to any kind of web page. Follow these steps to create a custom layout:</p>
			<ol>
				<li value="1">The first step is to create an area brick that could implement a Bootstrap container. This area brick will let the user choose the column number and sizes. So, we have to create the brick class in <strong class="source-inline">Document/AreaBrick/Container.php</strong>. The starting code is the following:<p class="source-code">&lt;?php</p><p class="source-code">namespace BlogBundle\Document\Areabrick;</p><p class="source-code">class Container extends AbstractTemplateAreabrick implements EditableDialogBoxInterface</p><p class="source-code">{</p><p class="source-code">    public function getName()</p><p class="source-code">    {</p><p class="source-code">        return 'Container';</p><p class="source-code">    }</p><p class="source-code">    public function getDescription()</p><p class="source-code">    {</p><p class="source-code">        return 'Container';</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>The <a id="_idIndexMarker697"/>second<a id="_idIndexMarker698"/> step is to configure the component for exposing the column configuration to the user. In this example, we assume that we can have only three layout options (one column, two columns 30%-70%, and two columns of the same size). In a real-world example, you can prepare any possible combination in terms of the number of columns and sizes to make the user really autonomous in managing any kind of layout. In the next piece of code, there<a id="_idIndexMarker699"/> is the configuration <a id="_idIndexMarker700"/>for creating a drop-down list with all the layout:<p class="source-code">public function getEditableDialogBoxConfiguration(Document\Editable $area, ?Info $info): EditableDialogBoxConfiguration</p><p class="source-code">    {</p><p class="source-code">        $config = new EditableDialogBoxConfiguration();</p><p class="source-code">        $config-&gt;setWidth(600);</p><p class="source-code">        $config-&gt;setItems([</p><p class="source-code">            'type' =&gt; 'tabpanel',</p><p class="source-code">            'items' =&gt; [</p><p class="source-code">                [</p><p class="source-code">                    'type' =&gt; 'panel',</p><p class="source-code">                    'title' =&gt; 'Column settings',</p><p class="source-code">                    'items' =&gt; [</p><p class="source-code">                        [</p><p class="source-code">                            'type' =&gt; 'select',</p><p class="source-code">                            'label' =&gt; 'Layout',</p><p class="source-code">                            'name' =&gt; 'layout',</p><p class="source-code">                            'config' =&gt; [</p><p class="source-code">                                'store' =&gt; [</p><p class="source-code">                                    ['one.html.twig',                                     'One column'],</p><p class="source-code">                                    ['two-50-50.html.                                    twig', 'Two column                                     50-50'],</p><p class="source-code">                                    ['two-30-70.html.                                    twig', 'Tre column                                     30-70'],</p><p class="source-code">                                ]</p><p class="source-code">                            ]</p><p class="source-code">                        ]</p><p class="source-code">                        </p><p class="source-code">            ]</p><p class="source-code">            ]</p><p class="source-code">        ]]);</p><p class="source-code">        return $config;</p><p class="source-code">    }</p><p>Note that, for<a id="_idIndexMarker701"/> simplicity, we used the names <a id="_idIndexMarker702"/>of a file template as values for the select item, so that the item could be simply related to the content.</p></li>
				<li>The last step in the class is to read the configuration parameter and pass it to the view. To do this, you can just add the <strong class="source-inline">action</strong> method implementation that you find in the following piece of code to your class:<p class="source-code">public function action(Info $info)</p><p class="source-code">{       </p><p class="source-code">     $layout=$this-&gt;getDocumentEditable($info-&gt;</p><p class="source-code">     getDocument(), 'select', 'layout')-&gt;getData(); </p><p class="source-code">     $info-&gt;setParam('layout',"@Blog/areas/</p><p class="source-code">     container/templates/$layout");        </p><p class="source-code">}</p><p>As you can see from the source code, the relative filename is transformed into a full path and added to the property bag. </p></li>
				<li>Now <a id="_idIndexMarker703"/>we<a id="_idIndexMarker704"/> have to implement the main view template. Just add to the <strong class="source-inline">view.html.twig</strong> file the following code:<p class="source-code">&lt;div class="container blog-container"&gt;</p><p class="source-code">{% include layout %}</p><p class="source-code">{% if editmode %}</p><p class="source-code">    &lt;div class="blog-container-footer"&gt;</p><p class="source-code">            CONTAINER</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">{% endif %}</p><p class="source-code">&lt;/div&gt;</p><p>The previous piece of code includes the template based on the variable set in the action and simply wraps it in a bootstrap container. Moreover, when you are in edit mode, it adds a bar to the bottom to help the user identify the layout.</p></li>
				<li>Now we have to implement the brick template. As usual, we need to create a <strong class="source-inline">view.html.twig</strong> file, but this time we will also create a folder with many other templates that will be loaded dynamically. So, create the <strong class="source-inline">one.html.twig</strong>,  <strong class="source-inline">two-50-50.html.twig</strong>, and <strong class="source-inline">two-30-70.html.twig</strong> files. The final result will be the following:<div id="_idContainer157" class="IMG---Figure"><img src="image/Figure_10.15_B17073.jpg" alt="Figure 10.15: Files configuration&#13;&#10;"/></div><p class="figure-caption">Figure 10.15: Files configuration</p></li>
				<li>Now we have to implement the three templates. For brevity, we will report here only one case: the others are very similar and can be found in the repository code. The <a id="_idIndexMarker705"/>next<a id="_idIndexMarker706"/> piece of code shows the two-column implementation:<p class="source-code">&lt;div class="row"&gt;</p><p class="source-code">    &lt;div class="col-6 blog-col"&gt;</p><p class="source-code">        {{ pimcore_areablock("content_50501")}}        </p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">     &lt;div class="col-6 blog-col"&gt;</p><p class="source-code">        {{ pimcore_areablock("content_50502")}}        </p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">&lt;/div&gt;</p><p>As you can see in the previous piece of code, there is a bootstrap row and two columns (<strong class="source-inline">col-6</strong>; <strong class="source-inline">col-6</strong> means the same width). Inside each column, the <strong class="source-inline">areablock</strong> component will allow you to choose the component to add inside it. Now we are ready to use our general-purpose template in a real-world example!</p></li>
				<li>Create the <strong class="source-inline">layout.html.twig</strong> file in <strong class="source-inline">/bundles/BlogBundle/Layout</strong>, and <a id="_idIndexMarker707"/>add<a id="_idIndexMarker708"/> the following snippet:<p class="source-code">{# SETTING THE IMAGE URL#}</p><p class="source-code">{% set imageurl=null %}</p><p class="source-code">{% if not editmode %}</p><p class="source-code"> {% set image =pimcore_relation("image")%}</p><p class="source-code">  {% if  image.getElement() is defined and  image.  getElement() != null %}</p><p class="source-code">    {% set imageurl= image.getElement().    getThumbnail("SlideShow") %}</p><p class="source-code">  {% endif %} </p><p class="source-code">{% endif %}</p><p class="source-code">{# PRINT HEADER#}</p><p class="source-code">&lt;header class="masthead" style="background-image: url({{imageurl}})"&gt;</p><p class="source-code">    &lt;div class="overlay"&gt;&lt;/div&gt;</p><p class="source-code">    &lt;div class="container"&gt;</p><p class="source-code">      &lt;div class="row"&gt;</p><p class="source-code">        &lt;div class="col-lg-8 col-md-10 mx-auto"&gt;</p><p class="source-code">          &lt;div class="site-heading"&gt;</p><p class="source-code">            &lt;h1&gt; {{ pimcore_input('headline', {'width':             540}) }}&lt;/h1&gt;</p><p class="source-code">            &lt;span class="subheading"&gt; {{ pimcore_            input('subheading', {'width': 700}) }}&lt;/span&gt;</p><p class="source-code">          &lt;/div&gt;</p><p class="source-code">        &lt;/div&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;/header&gt;</p><p class="source-code">{# IMAGE INPUT #}</p><p class="source-code">{% if editmode %}</p><p class="source-code">{{  pimcore_relation("image",{</p><p class="source-code">    "types": ["asset"],</p><p class="source-code">    "subtypes": {</p><p class="source-code">        "asset": [ "image"],</p><p class="source-code">    },</p><p class="source-code">    "classes": ["person"]</p><p class="source-code">}) }}</p><p class="source-code">{% endif %}</p><p>This<a id="_idIndexMarker709"/> snippet <a id="_idIndexMarker710"/>of code will render a parametric header that is put on all our pages. You don't want to have it on all the pages? Not a problem. You can always transform this code into a brick and place it only where you really need it.</p></li>
				<li>Now, create a template. Because we want to create a standard layout with horizontal bands, we will allow the use of only the <strong class="source-inline">Container</strong> brick. </li>
				<li>To do that, just create a file inside the default folder called <strong class="source-inline">generic.html.twig</strong>, and add it in the following piece of code:<p class="source-code">{% extends 'BlogBundle:Layout:layout.html.twig' %}</p><p class="source-code">{% block content %}</p><p class="source-code"> {% include 'BlogBundle:Layout:header.html.twig' %}</p><p class="source-code">    {{ pimcore_areablock("content", {'allowed':['container']})}}</p><p class="source-code">{% endblock %}</p><p>The preceding script defines a page structure with a header and an area block that will host the containers for our page layout.</p></li>
				<li>Create a web page and use the <strong class="source-inline">generic.html.twig</strong> template we created during <em class="italic">Step 6</em> of this procedure.</li>
				<li>Open <a id="_idIndexMarker711"/>the <a id="_idIndexMarker712"/>web page that you have created in edit mode. You should see the following result:<div id="_idContainer158" class="IMG---Figure"><img src="image/Figure_10.16_B17073.jpg" alt="Figure 10.16: Adding the container to the page&#13;&#10;"/></div><p class="figure-caption">Figure 10.16: Adding the container to the page</p></li>
				<li>After this step, the component will be ready on the page. Now click on the configuration button, as in the following screenshot:<div id="_idContainer159" class="IMG---Figure"><img src="image/Figure_10.17_B17073.jpg" alt="Figure 10.17: Opening settings&#13;&#10;"/></div><p class="figure-caption">Figure 10.17: Opening settings</p></li>
				<li>At this point, the user is able to select a layout using the edit box as in the contact <a id="_idIndexMarker713"/>form example that we saw in the <a id="_idIndexMarker714"/>previous section. The result of this configuration is the following popup:<div id="_idContainer160" class="IMG---Figure"><img src="image/Figure_10.18_B17073.jpg" alt="Figure 10.18: Selecting the layout&#13;&#10;"/></div><p class="figure-caption">Figure 10.18: Selecting the layout</p><p>The following screenshot shows the area brick that lets us create as many bands as we want. After this step, you should get the following result:</p><div id="_idContainer161" class="IMG---Figure"><img src="image/Figure_10.19_B17073.jpg" alt="Figure 10.19: The container component on the page&#13;&#10;"/></div><p class="figure-caption">Figure 10.19: The container component on the page</p></li>
				<li>Add the columns content into it by clicking the plus button inside the container area (shown in <em class="italic">Figure 10.19</em>) and choosing the column brick.  </li>
				<li>Add a contact form on the right by clicking the plus button and choosing the item<a id="_idIndexMarker715"/> from<a id="_idIndexMarker716"/> the component menu. </li>
				<li>On the left column, add a header component, the one we created earlier in the <em class="italic">Implementing a simple brick</em> section. Then add a WYSIWYG editor just above the header. You should get the result shown in the following screenshot:<div id="_idContainer162" class="IMG---Figure"><img src="image/Figure_10.20_B17073.jpg" alt="Figure 10.20: The web page with the contact form and data&#13;&#10;"/></div><p class="figure-caption">Figure 10.20: The web page with the contact form and data</p></li>
				<li>Now add another container just after the previous one by clicking on the top down arrow (<em class="italic">Figure 10.20</em>). On this component, add a slideshow brick. Configure it by dragging and dropping the images as we have done in the slideshow example in this chapter. The next screenshot summarizes your work in this <a id="_idIndexMarker717"/>part<a id="_idIndexMarker718"/> of the page:</li>
			</ol>
			<div>
				<div id="_idContainer163" class="IMG---Figure">
					<img src="image/Figure_10.21_B17073.jpg" alt="Figure 10.21: The result to obtain in this example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.21: The result to obtain in this example</p>
			<p>In this section, we learned how to create a template that could suit most situations. The example has been a good opportunity for testing the general-purpose layout in a real-life scenario. This template, in conjunction with all the bricks that you could create, will cover the most common scenarios and will save a lot of time.</p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor200"/>Summary</h1>
			<p>In this chapter, we continued our journey with the Pimcore CMS by discovering the bricks engine, another important tool for creating dynamic websites. By creating bricks, it's easy to prepare reusable components that can be used by web page editors to compose any website without asking the developers for customization. This new way to proceed is very important in reducing the development effort, keeping quality standards high, and increasing the speed of implementing the features that users want. </p>
			<p>To be more specific, we discovered how bricks work by implementing real-world examples. The contact form and slideshow are components that you will reuse in your projects for sure. Moreover, we also learned how to create a general-purpose template that enables us to produce any layout of a page without writing a single line of code. </p>
			<p>In the next chapter, we will learn how to finalize our website by discovering some important details and solutions for everyday Pimcore usage. To list the most important ones, we will learn how to create a bundle's installers to easily recreate our classes and contents after the setup, and we will learn how to create a multisite instance of Pimcore. </p>
		</div>
	</body></html>