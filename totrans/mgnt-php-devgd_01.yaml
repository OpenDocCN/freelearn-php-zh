- en: Chapter 1. Magento Fundamentals for Developers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover the fundamental concepts of working with Magento.
    We will learn how Magento is structured, and go over the source of Magento's flexibility,
    that is, its modular architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Magento is a flexible and powerful system. Unfortunately, this adds some level
    of complexity as well. Currently, a clean installation of Magento has around 20,000
    files and over 1.2 million lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: With all that power and complexity, Magento can be daunting for new developers;
    but don't worry. This chapter is designed to give new developers all the fundamental
    concepts and tools they need to use and extend Magento, and in the next chapter,
    we will dive deep into Magento models and data collection.
  prefs: []
  type: TYPE_NORMAL
- en: Zend Framework – the base of Magento
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you probably know, Magento is the most powerful e-commerce platform in the
    market. What you might not know about Magento is that it is also an object-oriented
    (OO) PHP framework developed on top of **Zend Framework**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Zend Framework 2 has been available since 2013, but Magento still relies on
    Zend Framework 1.11.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how Zend''s official site describes the framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"We designed Zend Framework with simplicity in mind. To provide a lightweight,
    loosely-coupled component library simplified to provide 4/5s of the functionality
    everyone needs and that lets you customize the other 20% to meet your specific
    business needs. By focusing on the most commonly needed functionality, we retain
    the simplified spirit of PHP programming, while dramatically lower the learning
    curve – and your training costs – so developers get up-to-speed quickly."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://files.zend.com/help/Zend-Server-5/zend_framework.htm](http://files.zend.com/help/Zend-Server-5/zend_framework.htm)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What exactly is Zend Framework? Zend Framework is an OO framework developed
    on PHP that implements the **Model-View-Controller** (MVC) paradigm. When **Varien**
    (now Magento Inc.) started developing Magento, they decided to do it on top of
    Zend because of some components, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Zend_Cache`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend_Acl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend_Locale`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend_DB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend_Pdf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend_Currency`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend_Date`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend_Soap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend_Http`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In total, Magento uses around 15 different Zend components. The Varien library
    extends several of the Zend components mentioned before directly. For example,
    `Varien_Cache_Core` extends from `Zend_Cache_Core`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Zend Framework, Magento was built with the following principles in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintainable**: By using code pools to keep the core code separate from local
    customizations and third-party modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Upgradable**: Magento modularity allows extensions and third-party modules
    to be updated independently from the rest of the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexible**: Allows seamless customization and simplifies the development
    of new features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although experience of using Zend Framework or even understanding it are not
    requirements to develop Magento, having at least some basic understanding of the
    Zend components, usage, and interaction can be invaluable information as we start
    digging deeper into the core of Magento.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Zend Framework at [http://framework.zend.com/](http://framework.zend.com/).
  prefs: []
  type: TYPE_NORMAL
- en: The Magento folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Magento folder structure is slightly different from other MVC applications.
    Let''s take a look at the directory tree, and each directory and its functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app`: This folder is the core of Magento and is subdivided into three important
    directories:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`code`: This contains all our application code divided into three code pools,
    namely core, community, and local'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`design`: This contains all the templates and layouts for our application'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`locale`: This contains all the translation and e-mail template files used
    for the store'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`js`: This contains all the JavaScript libraries that are used in Magento'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`media`: This contains all the images and media files for our products and
    CMS pages, as well the product image cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lib`: This contains all the third-party libraries used in Magento (such as
    Zend and PEAR) as well as the custom libraries developed by Magento, which reside
    under the `Varien` and `Mage` directories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skin`: This contains all CSS, images and JavaScript used by the corresponding
    theme'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var`: This contains our temporary data, such as the cache file, index lock
    files, sessions, import/export files, and in the case of the Enterprise edition,
    the full page cache folders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Magento is a modular system. This means the application, including the core,
    is divided into smaller modules. For this reason, the folder structure plays a
    key role in the organization of each module. A typical Magento module folder structure
    would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Magento folder structure](img/4195OS_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s review each folder further:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Block`: In Magento, blocks form an additional layer of logic between the controllers
    and views'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`controllers`: These are formed by actions that process webserver requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Controller`: Classes in this folder can be abstract classes and they can be
    extended by the `controller` class under the `controllers` folder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`etc`: In this we can find the module-specific configuration in the form of
    XML files such as `config.xml` and `system.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Helper`: This contains auxiliary classes that encapsulate a common module
    functionality and make them available to a class of the same module and to other
    modules classes as well'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Model`: This contains models that support the controllers in the module to
    interact with data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sql`: These contain the installation and upgrade files for each specific module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`: This folder was introduced in Magento 1.6 CE and it is used in a manner
    similar to SQL scripts, but data scripts are only concerned about inserting data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we will see later in this chapter, Magento makes heavy use of factory names
    and factory methods. This is why the folder structure is so important.
  prefs: []
  type: TYPE_NORMAL
- en: Modular architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than being a large application, Magento is built by smaller modules,
    each adding specific functionality to Magento.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of this approach is the ability to enable and disable
    specific module functionality with ease as well as adding new functionality by
    adding new modules.
  prefs: []
  type: TYPE_NORMAL
- en: Autoloader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Magento is a huge framework composed by close to 20,000 files. Requiring every
    single file when the application starts would make it incredibly slow and resource
    intensive. Hence, Magento makes use of an autoloader class to require the files
    each time a factory method is called.
  prefs: []
  type: TYPE_NORMAL
- en: So what exactly is an autoloader? PHP5 includes a function called `__autoload()`.
    When instantiating a class, the `__autoload()` function is automatically called.
    Inside this function, the custom logic is defined to parse the class name and
    require the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the Magento Bootstrap code located in `app/Mage.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The Bootstrap file takes care of defining the include paths and initializing
    the Varien autoloader, which will in turn define its own autoload function as
    the default function to call. Let''s take a look under the hood and see what the
    Varien''s autoload function is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `autoload` class takes a single parameter called `$class`, which is an alias
    provided by the factory method. This alias is processed to generate a matching
    class name that is then included.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned before, Magento's directory structure is important due to the
    fact that Magento derives its class names from the directory structure. This convention
    is the core principle behind factory methods, which we will be reviewing later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Code pools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned before, inside our `app/code` folder, we have our application
    code divided into the following three different directories known as code pools:'
  prefs: []
  type: TYPE_NORMAL
- en: '`core`: This is where the Magento Core modules that provide the base functionality
    reside. The golden rule among Magento developers is that you should never, under
    any circumstance, modify any files under the core code pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`community`: This is the location where third-party modules are placed. They
    are either provided by third parties or installed through Magento Connect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local`: This is where all the modules and code developed specifically for
    this instance of Magento reside.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code pools identify where the module came from and in which order they
    should be loaded. If we take another look at the `Mage.php` Bootstrap file, we
    can see the order in which code pools are loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This means, for each class request, Magento will look in the `local` folder,
    then in the community and `core` folders, and finally inside the `lib` folder.
  prefs: []
  type: TYPE_NORMAL
- en: This also produces an interesting behavior that can easily be used to override
    core and community classes by just copying the directory structure and matching
    the class name.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Needless to say, this is a terrible practice, but it is still useful to know
    about, just in case someday you have to take care of a project that exploits this
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Routing and request flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before going into more detail about the different components that form a part
    of Magento, it is important that we understand how these components interact together
    and how Magento processes requests coming from the web server.
  prefs: []
  type: TYPE_NORMAL
- en: As with any other PHP application, we have a single file as an entry point for
    every request. In the case of Magento, this file is `index.php`, which is in charge
    of loading the `Mage.php` Bootstrap class and starting the request cycle.
  prefs: []
  type: TYPE_NORMAL
- en: The web server receives the request and Magento is instantiated by calling the
    Bootstrap file `Mage.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The frontend controller is instantiated and initialized. During this controller
    initialization, Magento searches for the web routes and instantiates them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Magento then iterates through each of the routers and calls the match. The match
    method is responsible for processing the URL and generating the corresponding
    controller and action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiates the matching controller and corresponding action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Routers are especially important in this process. Router objects are used by
    the frontend controller to match a requested URL (route) to a module controller
    and action. By default, Magento comes with the following routers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Mage_Core_Controller_Varien_Router_Admin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mage_Core_Controller_Varien_Router_Standard`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mage_Core_Controller_Varien_Router_Cms`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mage_Core_Controller_Varien_Router_Default`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The action controller will then load and render the layout, which in turn will
    load the corresponding blocks, models, and templates.
  prefs: []
  type: TYPE_NORMAL
- en: Let's analyze how Magento will handle a request to a category page. We will
    use `http://localhost/catalog/category/view/id/10` as an example. The Magento
    URI comprises three parts, namely `FrontName/ControllerName/ActionName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, for our example URL, the breakdown is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FrontName`: This is a catalog'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ControllerName`: This is a category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ActionName`: This is a view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the Magento router class `Mage_Core_Controller_Varien_Router_Standard`
    match function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'From the previous code, we can see that the first thing the router tries to
    do is parse the URI into an array. Based on our example URL, the corresponding
    array will be similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part of the function will first try to check if the request has the
    module name specified. If not, then it tries to determine the module name, based
    on the first element of our array. If a module name can''t be provided, then the
    function will return false. Let''s take a look at this part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `match` function will iterate through each of the available modules
    and try to match the controller and action using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that looks like an awful lot of code! Let's break it down further. The first
    part of the loop will check if the request has a controller name. If it is not
    set, it will check our parameter array's (`$p`) second value and try to determine
    the controller name. Then, it will try to do the same for the action name.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we get this far in the loop, we should have a module name, a controller
    name, and an action name. Magento will now use these to try and get matched with
    the Controller class name by calling the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This function will not only generate a matching class name, but it will also
    validate its existence. In our example case, this function should return `Mage_Catalog_CategoryController`.
  prefs: []
  type: TYPE_NORMAL
- en: As we now have a valid class name, we can proceed to instantiate our controller
    object. You may probably notice that so far we haven't done anything with our
    action yet, and that's precisely the next step on our loop.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our instantiated controller comes with a very handy function called `hasAction()`.
    In essence, all this function does is call a PHP function called `is_callable()`,
    which will check if our current controller has a public function matching the
    action name. In our case this will be `viewAction()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason behind this elaborate matching process and the use of a `foreach`
    loop is that it is possible for several modules to use the same `frontName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Routing and request flow](img/4195OS_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, `http://localhost/catalog/category/view/id/10` is not a very user-friendly
    URL. Fortunately, Magento has its own URL rewrite system that allows us to use
    `http://localhost/books.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dig a little deeper into the URL rewrite system and see how Magento
    gets the controller and action names from our URL alias. Inside our `Varien/Front.php`
    controller dispatch function, Magento will call the following action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Before actually looking into the inner working of the rewrite function, let''s
    take a look at the structure of the `core/url_rewrite` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the rewrite module comprises several properties, but only two
    of them are of particular interest to us, namely `request_path` and `target_path`.
    Simply put, the job of the rewrite module is to modify the request object path
    information with the matching values of `target_path`.
  prefs: []
  type: TYPE_NORMAL
- en: The Magento version of MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are familiar with traditional MVC implementations such as CakePHP or
    Symfony, you may know that the most common implementation is called a convention-based
    MVC. With a convention-based MVC to add a new Model, or let's say a Controller,
    you only need to create the file/class (following the framework conventions);
    the system will pick it up automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Magento on the other hand uses a configuration-based MVC pattern, which means
    creating our file/class is not enough; we have to tell Magento explicitly that
    we have added a new class using configuration files written in XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each Magento module has a `config.xml` file that is located under the module''s
    `etc/` directory and contains all the relevant module configurations. For example,
    if we want to add a new module that includes a new model, we need to define a
    node in the configuration file that tells Magento where to find our model. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this might look like additional work, it also gives us a huge amount
    of flexibility and power. For example, we can rewrite another class by using the
    rewrite node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Magento will then load all the `config.xml` files and merge them at runtime,
    creating a single configuration tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, modules can also have a `system.xml` file that is used to specify
    configuration options in the Magento backend, which end users can in turn use
    to configure the module functionality. A snippet of a `system.xml` file will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down each node function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`section_name`: This is just an arbitrary name that we use to identify our
    configuration section. Inside this node, we will specify all the fields and groups
    for the configuration section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`group`: Groups, as the name implies, are used to group configuration options
    and display them inside an accordion section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label`: This defines the title or label to be used on the field/section/group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tab`: This defines the tab on which the section should be displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frontend_type`: This node allows us to specify which renderer to use for our
    custom option field. Some of the available options are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Checkboxes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Checkbox
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Date
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: File
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hidden
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Image
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Label
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Link
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiline
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiselect
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Password
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Radio
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Radios
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Submit
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Textarea
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Time
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sort_order`: This specifies the position of the field, group, or section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source_model`: Certain type of fields, such as a select field, can take options
    from a source model. Magento already provides several useful classes under `Mage/Adminhtml/Model/System/Config/Source`.
    Some of the classes we can find are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`YesNo`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Country`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Currency`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AllRegions`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Category`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Language`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Just by using XML, we can build complex configuration options for our modules
    right on the Magento backend without having to worry about setting up templates,
    populating fields, or validating data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Magento is also kind enough to provide a comprehensive amount of form field
    validation models that we can use with the `<validate>` tag. Among the field validators
    we have the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`validate-email`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validate-length`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validate-url`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validate-select`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validate-password`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with any other part of Magento, we can extend `source_models`, `frontend_types`,
    and validators, and even create new ones. We will be tackling this task in a later
    chapter, where we will create a new type of each. For now, we will explore the
    concepts of models, views, file layouts, and controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Magento makes use of the ORM approach, although we can still use `Zend_Db`
    to access the database directly. We will be using models to access our data most
    of the time. For this type of task, Magento provides the following two types of
    models:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple models**: These model implementations are a simple mapping of one
    object to one table, meaning our object attributes match each field and our table
    structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity Attribute Value (EAV) models**: These type of models are used to describe
    entities with a dynamic number of attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Magento splits the model layer in two parts: a model handling the business
    logic and a resource handling the database interaction. This design decision allows
    Magento to support multiple database platforms without having to change any of
    the logic inside the models.'
  prefs: []
  type: TYPE_NORMAL
- en: Magento ORM uses one of PHP's magic class methods to provide dynamic access
    to object properties. In the next chapter, we will look into models, the Magento
    ORM, and the data collections in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Magento models don't necessarily have to be related to any type table in the
    database or an EAV entity. Observers, which we will be reviewing later, are perfect
    examples of these type of Magento models.
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The view layer is one of the areas where Magento truly sets itself apart from
    other MVC applications. Unlike traditional MVC systems, Magento''s view layer
    is divided into three different components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Layouts**: These are XML files that define block structures and properties,
    such as name and which template file to use. Each Magento module has its own set
    of layout files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blocks**: These are used in Magento to reduce the burden on the controller
    by moving most of the logic into blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Templates**: These are PHTML files that contain the HTML code and PHP tags
    required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layouts give the Magento frontend an amazing amount of flexibility. Each module
    has its own layout XML files that tell Magento what to include and render on each
    page request. By using the layouts, we can move, add, or remove blocks from our
    store, without worrying about changing anything else other than our XML files.
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting a layout file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s examine one of the Magento core layout files, in this case, the `catalog.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Layout blocks comprise three main XML nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Handle**: Each page request will have several unique handles. The layout
    uses these handles to tell Magento which blocks to load and render on a per page
    basis. The most commonly used handles are the default handle and the `[frontname]_[controller]_[action]`
    handle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default handle is especially useful to set global blocks, for example, adding
    CSS or JavaScript to all pages on the header block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference**: A `<reference>` node is use to make references to a block. It
    is useful for the specification of nested blocks or modifying an already existing
    block. In our example, we can see how a new child blocks being specified inside
    `<reference name="left">`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block**: The `<block>` node is used to load our actual blocks. Each block
    node can have the following properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: This is the identifier for the actual block class. For example, `catalog/product_list`
    makes reference to the `Mage_Catalog_Block_Product_List`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This is the name used by other blocks to make a reference to this block.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before/after`: These properties can be used to position the blocks relative
    to other block position. Both properties can use a hyphen as value to specify
    if the module should appear at the very top or the very bottom.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template`: This property determines the `.phtml` template file that will be
    used to render the block.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`action`: Each block type has specific actions that affect the frontend functionality.
    For instance, the `page/html_head` block has actions to add CSS and `js` (`addJs`
    and `addCss`).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as`: This is used to specify the unique identifier that we will be using to
    call the block from the template. For example, calling a child block by using
    `getChildHtml(''block_name'')`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocks are a new concept that Magento implements in order to reduce the controller
    load. They are basically data resources that communicate directly with the models
    that manipulate the data if needed and then pass it to the views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have our `.phtml` files. Templates contain HTML and PHP tags and
    are in charge of formatting and displaying the data from our models. Let''s take
    a look at a snippet from the product view template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a diagram displaying the MVC model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dissecting a layout file](img/4195OS_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Magento MVC controllers are designed to be thin controllers. Thin controllers
    have little business logic and are mostly used to drive the application requests.
    A basic Magento controller action will just load and render the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: From here, it is the job of the blocks to handle the *display logic* to get
    the data from our models, prepare the data, and send it to the views.
  prefs: []
  type: TYPE_NORMAL
- en: Websites and store scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of Magento's core features is the ability to handle multiple websites and
    stores with a single Magento installation. Internally, Magento refers to each
    of these instances as scopes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Websites and store scopes](img/4195OS_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Values for certain elements such as products, categories, attributes, and configuration
    are scope-specific and can differ on different scopes. This gives Magento tremendous
    flexibility. For example, a product can be set up on two different websites with
    different prices but still share the rest of the attribute configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'As developers, one of the areas where we will be using scopes the most is when
    working with configuration. The different configuration scopes available in Magento
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global**: As the name implies, this applies across all scopes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Website**: These are defined by a domain name and are composed by one or
    more stores. Websites can be set up to share customer data or be completely isolated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Store**: These are used to manage products and categories and to group store
    views. Stores also have a root category that allows us to have separated catalogs
    per store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Store view**: By using store views, we can set up multiple languages on our
    store frontend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configuration options in Magento can store values on three scopes (global,
    website, and store views). By default, all the values are set on the global scope.
    Using `system.xml` on our modules, we can specify the scopes on which the configuration
    options can be set. Let''s revisit our previous `system.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Factory names and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Magento makes use of factory methods to instantiate models, helpers, and block
    classes. A factory method is a design pattern that allows us to instantiate an
    object without using the exact class name and using a class alias instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Magento implements the following factory methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Mage::getModel()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mage::getResourceModel()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mage::helper()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mage::getSingleton()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mage::getResourceSingleton()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mage::getResourceHelper()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these methods takes a class alias that is used to determine the real
    class name of the object that we are trying to instantiate. For example, if we
    want to instantiate a product object, we can do so by calling the `getModel()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we are passing a factory name composed of `group_classname`/`model_name`.
    Magento will resolve this to the actual class name of `Mage_Catalog_Model_Product`.
    Let''s take a closer look at the inner workings of `getModel()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In return, `getModelInstance()` calls the `getModelClassName()` method that
    takes a class alias as a parameter. Then, it tries to validate the existence of
    the returned class, and if the class exists, it creates a new instance of that
    class and returns it to our `getModel()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `getModelClassName()` method calls the `getGroupedClassName()` method, which
    is actually in charge of returning the real class name of our model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getGroupedClassName()` method takes two parameters, namely `$groupType`
    and `$classId`. The `$groupType` parameter refers to the type of object that we
    are trying to instantiate. Currently, only models, blocks, and helpers are supported.
    The `$classId` that we are trying to instantiate is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, `getGroupedClassName()` is actually doing all the work. It grabs
    our class alias catalog/product and creates an array by exploding the string on
    the slash character.
  prefs: []
  type: TYPE_NORMAL
- en: Then, it loads an instance of `Varien_Simplexml_Element` and passes the first
    value in our array (`group_classname`). It also checks if the class has been rewritten,
    and if it has, we will use the corresponding group name.
  prefs: []
  type: TYPE_NORMAL
- en: Magento also uses a custom version of the `uc_words()` function that will capitalize
    the first letters and convert separators of the class alias if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the function will return the real class name to the `getModelInstance()`
    function. In our example case, this will return `Mage_Catalog_Model_Product`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Factory names and functions](img/4195OS_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Events and observers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The event and observer pattern is probably one of Magento's more interesting
    features, as it allows developers to extend Magento in critical parts of the application
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: In order to provide more flexibility and facilitate interaction between the
    different modules, Magento implements an **Event**/**Observer** pattern. This
    pattern allows modules to be loosely coupled.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two parts to this system, an **Event** dispatch with the object and
    event information and an **Observer** listening to a particular event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Events and observers](img/4195OS_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Event dispatch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Events are created or dispatched using the `Mage::dispatchEvent()` function.
    The core team has already created several events on critical parts of the core.
    For example, the Model abstract class `Mage_Core_Model_Abstract` calls two protected
    functions every time a model is saved: `_beforeSave()` and `_afterSave()` on each
    of these methods two event are fired.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Each function fires a generic `model_save_after` event, and then a dynamic version
    based on the type of object being saved. This gives us a wide range of possibilities
    to manipulate objects through observers.
  prefs: []
  type: TYPE_NORMAL
- en: The `Mage::dispatchEvent()` method takes two parameters, the first is the event
    name and the second is an array of data that is received by the observer. We can
    pass values or objects in this array. This comes in handy if we want to manipulate
    the objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand the details of the event system, let''s take a look
    at the `dispatchEvent()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is actually an alias to the `dispatchEvent()` function inside
    the App core class, located in `Mage_Core_Model_App`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dispatchEvent()` method actually does all the work on the **Event**/**Observer**
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: It gets the Magento configuration object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it walks through the observer's node children, checking if the defined
    observer is listening to the current event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each of the available observers, the dispatch event tries to instantiate
    the observer object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, Magento tries to call the corresponding observer function mapped to
    this particular event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Observer bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, dispatching an event is only part of the equation. We also need to tell
    Magento which observer is listening to each event. Not to our surprise, observers
    are specified through the `config.xml` file. As we saw before, the `dispatchEvent()`
    function queries the configuration object for available observers. Let''s take
    a look at an example `config.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The event node can be specified in each of the configuration sections (admin,
    global, frontend, and so on) and we can specify multiple `event_name` children
    nodes. The `event_name` node has to match the event name used in the `dispatchEvent()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Inside each `event_name` node, we have a single observer node that can contain
    multiple observers, each with a unique identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observer nodes have two properties, `<class>`, which points to our observer
    model class, and `<method>`, which points to the actual method inside the observer
    class. Let''s analyze an example observer class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One interesting thing about observer models is that they don't extend to any
    other Magento class.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered many important and fundamental topics about Magento:'
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Folder structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVC patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events and observers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this may seem overwhelming at first sight, it is just the tip of the iceberg.
    There is a lot more to learn about each of these topics and Magento. The purpose
    of this chapter is to make developers aware of all the important components of
    the platform, from the configuration object to the way the event/object pattern
    is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Magento is a powerful and flexible system and much more than an e-commerce platform.
    The core team has put a lot of effort in making Magento a powerful framework.
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters, we will not only review all these concepts in more detail,
    but we will also apply them in a practical manner by building our own extensions.
  prefs: []
  type: TYPE_NORMAL
