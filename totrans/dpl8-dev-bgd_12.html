<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;RESTful Web Services in Drupal"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. RESTful Web Services in Drupal</h1></div></div></div><p><span class="emphasis"><em>One of the major new developer features of Drupal 8 is built-in support for REST. In this chapter, we will explore and configure built-in support for REST. Then we will extend it by installing the RESTful module. Finally, we will develop a custom Recipe AngularJS app that will consume the REST API of our recipe website.</em></span></p><p>In this chapter, we will learn these topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introduction to web services</li><li class="listitem" style="list-style-type: disc">Introduction to REST</li><li class="listitem" style="list-style-type: disc">What is Headless Drupal?</li><li class="listitem" style="list-style-type: disc">When and why to decouple Drupal?</li><li class="listitem" style="list-style-type: disc">RESTful web services in Drupal</li><li class="listitem" style="list-style-type: disc">How to create RESTful APIs in Drupal</li><li class="listitem" style="list-style-type: disc">Creating a basic Angular website that will consume the REST API of our recipe</li></ul></div><div class="section" title="Introduction to web services"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec151"/>Introduction to web services</h1></div></div></div><p>A web service can be <a class="indexterm" id="id646"/>defined as a communication bridge between two applications over a network. The W3C defines a web service generally as:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"A software system designed to support interoperable machine-to-machine interaction over a network."</em></span></p></blockquote></div><p>Web services innovation speaks to a vital route for organizations to correspond with one another and with customers also. Not at all like customary customer/server models, for example, a web server or web page framework, web administrations don't furnish the client with a GUI. Rather, they offer business rationale, information, and procedures through an automatic interface over a system. The applications interface with one another, not with the clients. Engineers can then add the web administration to a GUI (for example, a web page or an executable system), to offer particular usefulness to clients.</p><p>Let's look into the example that we will be following in this chapter. Our Drupal website holds recipe contents, and they have data about different recipes. We want other applications and <a class="indexterm" id="id647"/>websites to be able to use these contents and data to show in their respective applications. Now, as they would like to show the data according to their needs, they will try to get the raw values of the data and display them as per their requirements.</p><p>In doing so, we need to take care of the authentication of the applications trying to fetch data from our Drupal application so that there is no third-party attack on our data.</p><p>The whole scenario of providing the data and other parties consuming it is achieved using web services, which acts as a bridge between our Drupal application and the outer world.</p><p>Numerous associations utilize various programming frameworks for administration. Distinctive programming frameworks regularly need to trade information with one another, and a web service is a strategy for correspondence that permits two product frameworks to trade this information over the Web. The product framework that demands information is known as a<a class="indexterm" id="id648"/> <span class="strong"><strong>Service Requester</strong></span>, which is an Angular web page in this chapter, though the product framework that would prepare the solicitation and give the information is known as a service provider, which is Drupal in our case.</p><p>In a nutshell, web services make it possible for outside applications and devices to communicate with our<a class="indexterm" id="id649"/> application (for this situation, our Drupal) to execute <span class="strong"><strong>CRUD</strong></span> operations (short for <span class="strong"><strong>Create</strong></span>, <span class="strong"><strong>Read</strong></span>, <span class="strong"><strong>Update</strong></span>, and <span class="strong"><strong>Delete</strong></span>).</p></div></div>
<div class="section" title="Introduction to REST"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec152"/>Introduction to REST</h1></div></div></div><p><span class="strong"><strong>REST</strong></span> is the acronym for <span class="strong"><strong>Representational State Transfer</strong></span>, which is one of the most popular ways of creating web services.</p><p>REST is one of the architectural designs for service-oriented architecture, which uses simple HTTP calls to<a class="indexterm" id="id650"/> interact with machines for all CRUD operations. REST has risen in the last couple of years alone as a dominating web services design model, dislodging most of the SOAP- and WSDL-based services, because of its simplicity.</p><p>The four basic <a class="indexterm" id="id651"/>design principles of REST are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Use HTTP methods explicitly</strong></span>: REST follows<a class="indexterm" id="id652"/> pure HTTP methods and encourages developers to utilize it clearly, which is steady with the protocol definition. This kind of basic REST design theory establishes a one-to-one mapping between CRUD functions and HTTP methods, matching to this mapping:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">POST</code>: Create a resource</li><li class="listitem" style="list-style-type: disc"><code class="literal">GET</code>: Retrieve a resource</li><li class="listitem" style="list-style-type: disc"><code class="literal">PUT</code>: Update a resource</li><li class="listitem" style="list-style-type: disc"><code class="literal">DELETE</code>: Delete a resource</li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Be stateless</strong></span>: A stateless web service creates a response that links to another page in the set and lets the client perform what it needs to in order to maintain this value around. This kind of facet of RESTful web services design can be divided into two units of tasks:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Server</strong></span>: This<a class="indexterm" id="id653"/> generates responses that incorporate links to other assets, allowing applications to get around between related resources. The server also includes Cache-Control and Last-Modified systems to determine what data to cache to reduce the load on the server.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Client</strong></span>: This uses the <a class="indexterm" id="id654"/>Cache-Control and Last-Modified systems to determine whether or not to keep a local copy and cache the resource.</li></ul></div><p>This kind of collaboration between the client app and service is vital to being stateless in RESTful web services. It boosts performance simply by saving bandwidth and reducing the server-side application state.</p><div class="mediaobject"><img alt="Introduction to REST" src="graphics/4659_12_01.jpg"/></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Expose directory structure-like URLs</strong></span>: Another RESTful web service attribute is all about URLs. REST web service URLs need to be intuitive to the point where<a class="indexterm" id="id655"/> they are simple to guess. Think of a URL as a sort of self-documenting interface that requires very little, if any, explanation or perhaps reference for any developer to understand what it takes into account also to obtain related resources. For example, in our recipe services, we will have URIs in a structure like this:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">http://www.headless.dev/api/recipes/snacks/{recipe_name}</code>, which exposes the details of a particular recipe</li><li class="listitem" style="list-style-type: disc"><code class="literal">http://www.headless.dev/api/recipes/{recipe_type}</code>, which gives the recipes associated with the recipe type</li><li class="listitem" style="list-style-type: disc">URIs should<a class="indexterm" id="id656"/> also be static so that when the resource changes or the implementation of the service changes, the link stays the same</li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Transfer XML, JavaScript Object Notation (JSON), or both</strong></span>: A representational format is necessary for clients to consume the web service and display them on their <a class="indexterm" id="id657"/>presentation layer. The very last set of constraints that goes to a RESTful World Wide Web service design has to do with the structure in the data that the application and service exchange in the request/response payload or in the HTTP body. This is exactly where it really pays to keep things simple, human-readable, and connected. To provide client applications with the capability to request a particular article's type that's perfect to get them, construct your services in order that it makes using the built-in HTTP Recognize header, where the benefit from the header is a MIME type. Some prevalent MIME types utilized by RESTful services are shown here:<div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>MIME type</p>
</th><th style="text-align: left" valign="bottom">
<p>Content type</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><span class="strong"><strong>JSON</strong></span></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">application/json</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><span class="strong"><strong>XML</strong></span></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">application/xml</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><span class="strong"><strong>XHTML</strong></span></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">application/xhtml+xml</code></p>
</td></tr></tbody></table></div></li></ul></div></div>
<div class="section" title="Headless Drupal"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec153"/>Headless Drupal</h1></div></div></div><p>The term "Headless Drupal" was<a class="indexterm" id="id658"/> coined to refer to the decoupling of the backend and frontend of a Drupal application. In Headless Drupal, a visitor to the website will not interact with Drupal directly.</p><p>From the website visitor's point of view, the user is not directly connecting to Drupal but to a frontend JavaScript framework such as KnockoutJS or AngularJS. So, the website visitor does not see a generated Drupal theme (the head), this is not used: <span class="emphasis"><em>headless</em></span>.</p><p>In this case, Drupal is only used as a backend content management system, which is read by a frontend JavaScript framework, a mobile app or another third-party application. So, the Drupal backend is exactly as you know it, but the frontend is entirely non-Drupal.</p><p>Data exchange <a class="indexterm" id="id659"/>almost always takes place through JSON.</p><p>A manifesto about the future of Drupal has been laid with four goals:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We want Drupal to be the <span class="emphasis"><em>preferred</em></span> backend content management system for designers and frontend developers.</li><li class="listitem" style="list-style-type: disc">We believe that <a class="indexterm" id="id660"/>Drupal's main strengths lie in the power and flexibility of its backend; its primary value to users is its ability to architect and display complex content models.</li><li class="listitem" style="list-style-type: disc">We believe that client-side frontend frameworks are the future of the Web.</li><li class="listitem" style="list-style-type: disc">It is critically important for Drupal to be service-oriented first—not HTML-oriented first—or risk becoming irrelevant.</li></ul></div><p>A diagrammatical representation of a Headless Drupal site explains a lot that is built by Pantheon:</p><div class="mediaobject"><img alt="Headless Drupal" src="graphics/4659_12_02.jpg"/></div><p>Headless Drupal will be served with the web services concept using the REST server to create APIs, which will be consumed by other applications or a single application to serve on the frontend.</p><p>Building a <a class="indexterm" id="id661"/>Headless site prior to Drupal 8 was possible using modules such as services and RESTWS, but Drupal 8 comes packed with REST APIs in the core, which serves the purpose well.</p><div class="section" title="When to decouple Drupal or when to use Headless Drupal"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec108"/>When to decouple Drupal or when to use Headless Drupal</h2></div></div></div><p>As discussed, Headless Drupal will be decoupling the backend architecture and frontend architecture so that the<a class="indexterm" id="id662"/> frontend has the flexibility to display the content as per the requirements. But when should you use this method? We use it especially when<a class="indexterm" id="id663"/> Drupal has a strong theming layer of its own.</p><p>Let's look at some of the pros and cons of using Headless Drupal:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Pros</strong></span>:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Clean APIs<a class="indexterm" id="id664"/> for all as it is uniform and can be used by any application to represent data.</li><li class="listitem" style="list-style-type: disc">Upgrading the frontend will require any changes in the backend and similarly upgrading the backend will not touch the frontend. However, you will need to be extremely careful while designing the content APIs.</li><li class="listitem" style="list-style-type: disc">Less reliance of Drupal expertise as the frontend is detached from Drupal.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cons</strong></span>:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A decoupled<a class="indexterm" id="id665"/> structure's engineering is more mind-boggling to comprehend and troubleshoot. Making sense of why something is broken is very difficult to debug.</li><li class="listitem" style="list-style-type: disc">Drupal's out-of-the-box functionalities need to be built from scratch. For example, the Facebook plugin, which provides Facebook access and login, is strong and stable. But to use in a decoupled environment, the whole functionality needs to be rebuilt.</li><li class="listitem" style="list-style-type: disc">The minimum team size required for efficient development is larger as the backend team is separated from the frontend.</li></ul></div></li></ul></div><p>So why is Headless<a class="indexterm" id="id666"/> Drupal making us happy?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Drupal installation is easier to maintain</li><li class="listitem" style="list-style-type: disc">The scalability of the system becomes easier</li><li class="listitem" style="list-style-type: disc">It becomes easier to work with and for different teams</li><li class="listitem" style="list-style-type: disc">The performance is improved</li><li class="listitem" style="list-style-type: disc">It makes the project future-proof</li></ul></div><p>Since the initiation <a class="indexterm" id="id667"/>of Drupal, it has grown from just being a blogging platform to a strong content management system, and the concept of Headless Drupal just strengthens its capabilities of managing contents. But you need to have a clear understanding of the project before jumping into decoupling Drupal. Though it looks tempting and has great advantages, it also has downsides.</p></div></div>
<div class="section" title="RESTful web services in Drupal"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec154"/>RESTful web services in Drupal</h1></div></div></div><p>As discussed previously, prior to Drupal 8, RESTful web services could be implemented in Drupal 7 using the Services module or RESTWS module, which (using the REST server) can be used to build powerful Headless Drupal websites. But with the evolution of Drupal 8, this functionality has been attached to the core of the Drupal 8 default bundle, along with other contributed features and modules that are pushed to the core, such as Views, Link, WYSIWYG editors, and so on.</p><p>Drupal 8 achieves the<a class="indexterm" id="id668"/> full functionality to set a basic web services environment to provide APIs using four modules in the core. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>RESTful web services (REST)</strong></span>: This exposes entities and other resources via a RESTful web API. It<a class="indexterm" id="id669"/> depends on the Serialization module for serialization of data that is sent to and from the API.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Serialization</strong></span>: This<a class="indexterm" id="id670"/> provides a service for serialization of data to and from formats such as JSON and XML.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Hypertext Application Language (HAL)</strong></span>: This serializes entities using Hypertext Application<a class="indexterm" id="id671"/> Language. Drupal core currently uses this format, which adds two keywords: <code class="literal">_link</code> for linked relation and <code class="literal">_embedded</code> for embeded media.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>HTTP Basic Authentication (basic_auth)</strong></span>: This module implements basic user authentication<a class="indexterm" id="id672"/> using the HTTP Basic Authentication provider, which uses the username and password for authentication to make API calls.</li></ul></div><div class="section" title="RESTful APIs in Drupal"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec109"/> RESTful APIs in Drupal</h2></div></div></div><p>Creating RESTful<a class="indexterm" id="id673"/> APIs in Drupal is a fairly easy task, now that the whole power of web services has been moved to the core. To create the APIs, we will be using the Recipe content type that we have built for this book.</p><p>We will go through creating three basic APIs; these will give us the following information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Get all the recipe types</li><li class="listitem" style="list-style-type: disc">Get all the recipes under a recipe type</li></ul></div></div></div>
<div class="section" title="Time for action &#x2013; getting all the recipe types"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec155"/>Time for action – getting all the recipe types</h1></div></div></div><p>This is the list of recipe<a class="indexterm" id="id674"/> types I have in my local development server running in Vagrant (<code class="literal">http://www.headless.dev</code>):</p><div class="mediaobject"><img alt="Time for action – getting all the recipe types" src="graphics/4659_12_03.jpg"/></div><p>We will create an API URL structured as <code class="literal">http://www.headless.dev/recipes</code>, which will give the list of recipes in my site. Let's get started:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We need to enable the Web Services module from the modules page.</li><li class="listitem">Click on <span class="strong"><strong>Manage</strong></span> in the administration menu bar and then click on <span class="strong"><strong>Extend</strong></span>.</li><li class="listitem">Once you are <a class="indexterm" id="id675"/>on the <span class="strong"><strong>Modules</strong></span> page, search for <span class="strong"><strong>RESTful Web Services</strong></span> and <a class="indexterm" id="id676"/><span class="strong"><strong>Serialization</strong></span>. Enable both these modules:<div class="mediaobject"><img alt="Time for action – getting all the recipe types" src="graphics/4659_12_04.jpg"/></div></li><li class="listitem">Next, we will need to create a REST export views for our recipe types. Views now comes in the core of Drupal 8, which uses the REST export mode to create web services APIs.<div class="mediaobject"><img alt="Time for action – getting all the recipe types" src="graphics/4659_12_05.jpg"/></div></li><li class="listitem">Then click on <span class="strong"><strong>Views</strong></span>:<div class="mediaobject"><img alt="Time for action – getting all the recipe types" src="graphics/4659_12_06.jpg"/></div></li><li class="listitem">You will be<a class="indexterm" id="id677"/> greeted by the <span class="strong"><strong>Views</strong></span> landing page, where <a class="indexterm" id="id678"/>you can manage, configure, and add new Views. Drupal 8 uses Views extensively to display different data and contents on the site. The <span class="strong"><strong>Web Services</strong></span> module however does not provide any views by default.</li><li class="listitem">Moving forward, click on <span class="strong"><strong>Add new view</strong></span> in the <span class="strong"><strong>Views</strong></span> landing page:<div class="mediaobject"><img alt="Time for action – getting all the recipe types" src="graphics/4659_12_07.jpg"/></div></li><li class="listitem">In the views configuration page, fill out the form as given in the next screenshot. We have selected <span class="strong"><strong>Show</strong></span> as <span class="strong"><strong>Taxonomy terms</strong></span> and <span class="strong"><strong>of type</strong></span> as <span class="strong"><strong>Recipe Type</strong></span> to create a web service API to show the Recipe Types in the site.<div class="mediaobject"><img alt="Time for action – getting all the recipe types" src="graphics/4659_12_08.jpg"/></div></li><li class="listitem">After filling<a class="indexterm" id="id679"/> out the form, we need to select the REST export <a class="indexterm" id="id680"/>display to export or expose the API by a URL.<div class="mediaobject"><img alt="Time for action – getting all the recipe types" src="graphics/4659_12_09.jpg"/></div></li><li class="listitem">Click on <span class="strong"><strong>Save and edit</strong></span> to configure the view.</li><li class="listitem">Now, by default, the view will give full entity information about the taxonomy terms.<div class="mediaobject"><img alt="Time for action – getting all the recipe types" src="graphics/4659_12_10.jpg"/></div></li><li class="listitem">The result of the views preview is very messy and hard to read. It is shown as a flat list.<div class="mediaobject"><img alt="Time for action – getting all the recipe types" src="graphics/4659_12_11.jpg"/></div><p>To make it more<a class="indexterm" id="id681"/> readable, you need to install a Google plugin called <span class="strong"><strong>JSONview</strong></span>, which renders the JSON object in a more readable <a class="indexterm" id="id682"/>manner.</p><p>Once the plugin is installed, you can view the response in the browser by hitting this URL: <code class="literal">http://www.headless.dev/api/recipes</code>.</p><p>As it gives all information about the terms, we need to filter out unnecessary fields from the response and make it more readable and consumable.</p></li><li class="listitem">We will be exposing the title, tid, and description about the recipe type to be consumed. In the <span class="strong"><strong>Views</strong></span> settings, under <span class="strong"><strong>FORMAT</strong></span>, select the <span class="strong"><strong>Show</strong></span> property and select <span class="strong"><strong>Fields</strong></span> instead of <span class="strong"><strong>Entity</strong></span>.<div class="mediaobject"><img alt="Time for action – getting all the recipe types" src="graphics/4659_12_12.jpg"/></div></li><li class="listitem">Select <span class="strong"><strong>Fields</strong></span> from the<a class="indexterm" id="id683"/> options provided so that you can add fields to your REST export:<div class="mediaobject"><img alt="Time for action – getting all the recipe types" src="graphics/4659_12_13.jpg"/></div></li><li class="listitem">Select <span class="strong"><strong>Apply</strong></span>, and in the <a class="indexterm" id="id684"/>next screen, it will ask if you need alias the field label. But it is fine to keep it as name.</li><li class="listitem">Next, we need to add the rest of the fields under the <span class="strong"><strong>FIELDS</strong></span> settings. Select <span class="strong"><strong>Add</strong></span> under <span class="strong"><strong>FIELDS</strong></span> and add in the <code class="literal">tid</code> and <code class="literal">description</code> fields:<div class="mediaobject"><img alt="Time for action – getting all the recipe types" src="graphics/4659_12_14.jpg"/></div></li><li class="listitem">Select the <span class="strong"><strong>Taxonomy term: Term ID</strong></span> field to get the term ID in your REST export.<div class="mediaobject"><img alt="Time for action – getting all the recipe types" src="graphics/4659_12_15.jpg"/></div></li><li class="listitem">And then select the<a class="indexterm" id="id685"/> <span class="strong"><strong>Taxonomy term: Description</strong></span> field from<a class="indexterm" id="id686"/> the fields list:<div class="mediaobject"><img alt="Time for action – getting all the recipe types" src="graphics/4659_12_16.jpg"/></div></li><li class="listitem">Apply the settings and save the fields as default unless you need to something more special with the fields.</li><li class="listitem">Next, we will rearrange the fields so that the order of the fields is tid, name, and description.<div class="mediaobject"><img alt="Time for action – getting all the recipe types" src="graphics/4659_12_17.jpg"/></div></li><li class="listitem">Now if we <a class="indexterm" id="id687"/>visit <code class="literal">http://www.headless.dev/api/recipes</code> in our browser, we will get a more precise and<a class="indexterm" id="id688"/> easy-to-read JSON object ready to be consumed by any app.<div class="mediaobject"><img alt="Time for action – getting all the recipe types" src="graphics/4659_12_18.jpg"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec110"/><span class="emphasis"><em>What just happened?</em></span></h2></div></div></div><p>We created an<a class="indexterm" id="id689"/> API using the Drupal REST service module and REST views export, which gives us a JSON of the available Recipe types in our Drupal site, ready to be consumed.</p></div></div>
<div class="section" title="Time for action &#x2013; creating an API to get all the recipes under a recipe type"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec156"/>Time for action – creating an API to get all the recipes under a recipe type</h1></div></div></div><p>Now we will create our<a class="indexterm" id="id690"/> next API, which is for exposing all the recipes under a recipe type:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will have a new view created in the same manner, but instead of selecting Taxonomy terms, we will be choosing contents of all type recipes.<div class="mediaobject"><img alt="Time for action – creating an API to get all the recipes under a recipe type" src="graphics/4659_12_19.jpg"/></div></li><li class="listitem">In the REST<a class="indexterm" id="id691"/> export settings, give the URL as <code class="literal">api/recipes/%</code>. The <code class="literal">%</code> sign acts as the wildcard, which will recipe type tid as the argument.<div class="mediaobject"><img alt="Time for action – creating an API to get all the recipes under a recipe type" src="graphics/4659_12_20.jpg"/></div></li><li class="listitem">In the views settings page, we configure the view just like we did it for the recipe type. The fields that we will be showing are:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Node ID</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Title</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Publishing status</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Recipe Type</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Recipe Image</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>PrepTime</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>CookTime</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>TotalTime</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Body</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Ingredients</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Instructions</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Yield</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Review</strong></span></li></ul></div></li><li class="listitem">To get the<a class="indexterm" id="id692"/> recipes associated with a particular recipe, we will use the fields Recipe Type in the recipe content, which is referenced to the Recipe Type vocabulary.</li><li class="listitem">In the advanced section of the views configuration page, under <span class="strong"><strong>CONTEXTUAL FILTERS</strong></span>, click on <span class="strong"><strong>Add</strong></span> to add in the Recipe Type tid as an argument:<div class="mediaobject"><img alt="Time for action – creating an API to get all the recipes under a recipe type" src="graphics/4659_12_21.jpg"/></div></li><li class="listitem">In the contextual filter form, search for <code class="literal">recipe type</code> and select the field to configure it:<div class="mediaobject"><img alt="Time for action – creating an API to get all the recipes under a recipe type" src="graphics/4659_12_22.jpg"/></div></li><li class="listitem">In the contextual filter configuration form, select the <span class="strong"><strong>Provide default value</strong></span> radio button<a class="indexterm" id="id693"/> and choose <span class="strong"><strong>Taxonomy term ID from URL</strong></span> from the argument <span class="strong"><strong>Type</strong></span> dropdown:<div class="mediaobject"><img alt="Time for action – creating an API to get all the recipes under a recipe type" src="graphics/4659_12_23.jpg"/></div></li><li class="listitem">The JSON object will give the indexes as the machine name of the fields. So we will alias the fields to make the indexes' names relevant.<div class="mediaobject"><img alt="Time for action – creating an API to get all the recipes under a recipe type" src="graphics/4659_12_24.jpg"/></div></li><li class="listitem">Now if you check the result in the browser by hitting the URL <code class="literal">http://www.headless.dev/api/recipes/6</code>, you will get the JSON object of the nodes<a class="indexterm" id="id694"/> associated with term ID <code class="literal">6</code>, which is for the Snack recipe type:<div class="informalexample"><pre class="programlisting">{
nid: "3",
recipe_name: "&lt;a href="/node/3" hreflang="en"&gt;Oven-Roasted Falafel&lt;/a&gt;",
status: "On",
recipe_type: "Snack",
recipe_image: "http://www.headless.dev/sites/default/files/oven-roasted-fallafel_330.png",
preptime: "10Minutes",
cooktime: "35Minutes",
totaltime: "1Hours",
summary: "&lt;p&gt;Crisp chickpeas balls are stuffed in soft pita bread along with juicy cucumbers and refreshing sauces.&lt;/p&gt;",
ingredients: "&lt;ul&gt;&lt;li class="ingredient"&gt;1 can chickpeas, rinsed and drained&lt;br /&gt;&lt;br /&gt;
  1 small onion, chopped&lt;br /&gt;&lt;br /&gt;
  2-4 garlic cloves, peeled&lt;br /&gt;&lt;br /&gt;
  2 Tbsp chopped fresh parsley &lt;br /&gt;&lt;br /&gt;
  2 Tbsp chopped fresh cilantro &lt;br /&gt;&lt;br /&gt;
  1 tsp ground cumin &lt;br /&gt;&lt;br /&gt;
  1/4 tsp salt &lt;br /&gt;&lt;br /&gt;
  Pinch of dried chili flakes&lt;br /&gt;&lt;br /&gt;
  1/4 cup whole wheat flour (plus extra, if needed) &lt;br /&gt;&lt;br /&gt;
  1 tsp baking powder &lt;br /&gt;&lt;br /&gt;
  Canola oil for cooking&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;Accompaniments:&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;
  Fresh pitas&lt;br /&gt;&lt;br /&gt;
  Tzatziki&lt;br /&gt;&lt;br /&gt;
  Chopped cucumber&lt;br /&gt;&lt;br /&gt;
  Tomatoes&lt;br /&gt;&lt;br /&gt;
  Red onion &lt;/li&gt;
&lt;/ul&gt;",
instructions: "&lt;p&gt;&lt;span&gt;Preheat oven to 425 ˚F (220 ˚C).&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span&gt;Place chickpeas, onion, garlic, parsley, cilantro, cumin, salt, and chili flakes in bowl of food processor and pulse until combined but still chunky. &lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span&gt;Add flour and baking powder and pulse until it turns into soft mixture that you can roll into balls without sticking to your hands. &lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span&gt;(Add another spoonful of flour if it seems too sticky.)&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span&gt;Roll dough into meatball-sized balls and gently flatten each into little patty. &lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span&gt;Place patties on heavy-rimmed baking sheet, preferably one that's dark in color.&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span&gt;Brush each patty with canola oil, flip them over and brush other side. &lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span&gt;Roast for 15 minutes, then flip them over and roast for another 10 minutes, until crisp and golden on both sides. &lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span&gt;Serve warm, wrapped in pitas, with tzatziki, chopped cucumber, tomatoes and red onion. &lt;/span&gt;&lt;/p&gt;",
yield: "3",
review: ""
}</pre></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec111"/><span class="emphasis"><em>What just happened?</em></span></h2></div></div></div><p>We created an API that that gives us all recipe types and another API that gives out all the recipe types under a <a class="indexterm" id="id695"/>particular recipe type. Now we will see how we can use AngularJS to consume this REST exports JSON output and display on a web page.</p></div></div>
<div class="section" title="Time for action &#x2013; consuming RESTful web services using AngularJS"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec157"/>Time for action – consuming RESTful web services using AngularJS</h1></div></div></div><p>Now that we have an<a class="indexterm" id="id696"/> API that is providing us the services with the JSON data of the recipes, recipe types, and individual recipes, let us look at how we can use this data to display in a page using HTML and AngularJS:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Since it is targeted towards a Drupal audience, we will not be looking deep into the consumption of services.</li><li class="listitem">So for starters, let us create a directory named <code class="literal">recipes</code> inside the Drupal root directory. In the directory, we will have two files, <code class="literal">recipe.js</code> and <code class="literal">index.html</code>.</li><li class="listitem">The <code class="literal">recipe.js</code> file will hold the code to call the API URL and parse the data object for consumption. The <code class="literal">index.html</code> file will hold the AngularJS code and HTML to read the parsed data and display it on the page.</li><li class="listitem">The folder structure should be similar to this:<div class="informalexample"><pre class="programlisting">Drupal Root
--recipe
----recipe.js
----index.html</pre></div></li><li class="listitem">Let's look into the <code class="literal">recipe.js</code> file, which is the AngularJS controller. As said, it will hold the JavaScript code to create an Angular Controller Module to fetch the JSON object from the API URL and parse it to provide raw content from the JSON object:<div class="informalexample"><pre class="programlisting">function Recipe($scope, $http) {
    $http.get('http://www.headless.dev/api/recipes/6').
        success(function(data) {
            $scope.recipes = data[0];
        });
}</pre></div></li><li class="listitem">The preceding code is a controller in Angular, which a JavaScript function. This function used two variables, <code class="literal">$http</code> and <code class="literal">$scope</code>.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">$http</code> calls the REST API URL using the <code class="literal">get</code> method</li><li class="listitem" style="list-style-type: disc"><code class="literal">$scope</code> holds the JSON returned from the API and passes it on to the HTML DOM of the page in an element array <code class="literal">recipe</code></li></ul></div></li><li class="listitem">Now that we have<a class="indexterm" id="id697"/> an AngularJS controller, we will create the HTML page that will load the controller into the web browser:<div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;html ng-app&gt;
  &lt;head&gt;
    &lt;title&gt;Recipes&lt;/title&gt;
    &lt;script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.min.js"&gt;&lt;/script&gt;
      &lt;script src="recipe.js"&gt;&lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;div ng-controller="Recipe"&gt;
      &lt;h1&gt;{{recipes.recipe_name}}&lt;/h1&gt;
      &lt;p&gt;{{recipes.summary}}&lt;/p&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">The first script tag loads the minified AngularJS library (<code class="literal">angular.min.js</code>) from a <a class="indexterm" id="id698"/><span class="strong"><strong>content delivery network</strong></span> (<span class="strong"><strong>CDN</strong></span>) so that we don't have to download AngularJS and place it in the project.</li><li class="listitem">The second script loads the controller code (<code class="literal">recipe.js</code>) from the application's path.</li><li class="listitem">AngularJS interacts with the HTML DOM with two attributes:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">ng-app</code> attribute to indicate that this page is an AngularJS application</li><li class="listitem" style="list-style-type: disc">The <code class="literal">ng-controller</code> attribute to define which controller to use</li></ul></div></li><li class="listitem">The placeholders reference the <code class="literal">recipe_name</code> and <code class="literal">summary</code> properties of the recipe model object, which will be set upon successfully consuming the REST service:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;h1&gt;{{recipes.recipe_name}}&lt;/h1&gt;</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;p&gt;{{recipes.summary}}&lt;/p&gt;</code></li></ul></div></li></ol></div><p>To run the client, all <a class="indexterm" id="id699"/>you need to do is open the directory in the web browser. Since our Angular application is inside the Drupal root directory, we can run it by opening this URL: <code class="literal">http://www.headless.dev/api/recipes/6/recipes</code>.</p><p>This will show the result as:</p><div class="mediaobject"><img alt="Time for action – consuming RESTful web services using AngularJS" src="graphics/4659_12_25.jpg"/></div><p>So, this is a simple way on how to consume RESTful APIs with Angular JS.</p><p>A point to remember: since the Angular application is within the Drupal root folder, there are no cross-origin issues in running the Angular application. But if the Angular application is on a different server than the server hosting the web services, then CORS (cross-origin resource sharing) has to be enabled in the server hosting the web services. This allows the restricted resources to be displayed in the Angular application server.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec112"/><span class="emphasis"><em>What just happened?</em></span></h2></div></div></div><p>We created an <a class="indexterm" id="id700"/>AngularJS app that consumes the JSON result from the REST export created from the Drupal instance. This JSON response is used by the Angular app to display the result provided by the Angular app to an HTML page. This helps us to display the data in a faster way and we have control over the display and design of the page.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec158"/>Summary</h1></div></div></div><p>So we now have a Drupal website that is used for data storage. The Drupal site will be used to generate contents and data. This data will be represented in JSON format using Drupal's built-in web services modules and views to create RESTful JSON exports, which can be used by the app to consume this JSON output and display it on the app.</p></div></body></html>