- en: Chapter 5. Configuring and Using Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing simple queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing queries using the TableGateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimization with a DB profiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Database Access Object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obviously databases are essential if we want to store data, and with all the
    different kinds of database engines around, it is sometimes hard to see the wood
    through the trees. Zend Framework 2, however, brings us a bit of hope of standardizing
    the way we work with databases. In this chapter, we will be showing loads of examples
    from database connections to optimizing the performance of our queries.
  prefs: []
  type: TYPE_NORMAL
- en: Default database engines available
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Zend Framework 2 has a default collection of database drivers available to use,
    and obviously it also supports the PHP PDO extension for a more standardized way
    of using databases.
  prefs: []
  type: TYPE_NORMAL
- en: IBM DB2 driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**IBM DB2** is a database server designed by IBM and is the second most used
    DBMS according to IDC''s report of 2009 ([http://www.marketresearch.com/IDC-v2477/Worldwide-Database-Management-Systems-Forecast-2393193/view-stat/ibm-14.html](http://www.marketresearch.com/IDC-v2477/Worldwide-Database-Management-Systems-Forecast-2393193/view-stat/ibm-14.html)).
    The database engine can be traced back to the 1970''s and was mainly only available
    for the IBM mainframe until the 1990''s when it started supporting other more
    widely used operating systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, the DB2 is mainly used in ZF2 for the IBM i Power Systems such as
    the AS/400, but remains a very powerful database engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The IBM DB2 Universal Database client needs to be installed on the PHP machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP configured either with the `--with-IBM_DB2` option or enabled (and installed)
    the `ibm_db2` extension in `php.ini`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQLi driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For PHP developers, this is probably the most used database engine, the **MySQLi**
    instead of the normal MySQL driver gives the extension several advantages over
    modern MySQL system versions (4.1.3 and newer). This improved extension supports
    the following modern MySQL functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced server support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prepared statements support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-oriented interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple statements support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced debugging availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The requirements for MySQLi driver is that the PHP is configured either with
    the `--with-mysql` or `--with-mysqli` option or enabled (and installed) the `mysql`
    and `mysqli` extension in `php.ini`.
  prefs: []
  type: TYPE_NORMAL
- en: OCI8 driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OCI8 driver supports Oracle Database 11g, 10g, 9i, and 8i (according to the
    PHP manual), and is widely used in the PHP community.
  prefs: []
  type: TYPE_NORMAL
- en: 'Requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle 9ir2, 10g, or 11g Client libraries on the PHP machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP configured either with the `--with-oci8` option or enabled (and installed)
    the `oci8` extension in `php.ini`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PGSQL driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**PostgreSQL** is an object-relational database and is my personal favorite,
    this database has been around since 1995 and is used by websites such as Reddit,
    Instagram, and Yahoo!.'
  prefs: []
  type: TYPE_NORMAL
- en: The requirement for this is that the PHP is configured either with the `--with-pgsql`
    option or enabled (and installed) the `pgsql` extension in `php.ini`.
  prefs: []
  type: TYPE_NORMAL
- en: SQLSRV driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microsoft SQL Server (and SQL Azure) is a database that works exclusively on
    Microsoft Windows, and is widely considered being a very good and stable database
    engine. Versions 3.0 or higher of the PHP extension support SQL Server 2005.
  prefs: []
  type: TYPE_NORMAL
- en: 'Requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The Microsoft SQL Server 2012 Native Client needs to be installed on the PHP
    machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The extension `php_sqlsrv_5*_nts.dll` or `php_sqlsrv_5*_ts.dll` should be enabled
    (and installed) on the PHP machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDO driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PDO extension in PHP is probably the best method of connecting to a database
    available. Not only does it have a wide selection of database engines it supports,
    but also a more standardized way of working with them, which makes it easier to
    support in the long run (and that is a pro in the long run).
  prefs: []
  type: TYPE_NORMAL
- en: Not only is it easier to support, for example, its standardized way of connecting
    to databases and executing queries makes it much easier for us developers to switch.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements for this is that at least one `pdo` extension needs to be enabled
    in the `php.ini` file or otherwise it won't work.
  prefs: []
  type: TYPE_NORMAL
- en: All the drivers communicate with PHP through either as the built-in compilation
    or used as an extension on the library. Without these extensions PHP would be
    unable to figure out how to communicate with the specific libraries. Some extensions
    (such as the Oracle one) require even more, like client libraries to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: We should always check the php.net documentation for the requirements of the
    specific extension we try to enable.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After seeing all the database types that Zend Framework 2 supports, we can finally
    start connecting to them. In this recipe, we will connect to a MySQL server and
    show different ways of doing this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make full of the following recipe, a Zend Framework 2 skeleton application
    should be used, with a MySQL server available to connect to. Don't forget that
    connecting to a MySQL server requires the `mysql` and `mysqli` extensions enabled
    in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we'll give some examples of how to connect to a single database
    or multiple databases.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a MySQL database through the configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can make the following change to the `/config/autoload/global.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the example, setting up the database configuration is quite
    easy. Now, if you were wondering how to use a configuration like this in a real
    world example, let''s consider the following controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see it is very easy to get it going now in the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to multiple databases through the configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some applications require us to connect to multiple databases at the same time,
    and we can easily achieve that in Zend Framework 2 as well by doing the following
    in the `/config/autoload/global.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In our controllers (or anywhere where we can access the service manager) we
    can easily get the `db` DBAdapter now by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Connecting to a MySQL database through code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it is less clean than the method we showed before, sometimes it is
    just necessary to connect through good old instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s see an example if we want to connect to a MySQL server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We now can easily execute the queries on the instantiated `$db`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Zend Framework 2 there are many ways of defining a database connection, in
    this section we will discuss three of them.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a MySQL database through the configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first method we are going to show is connecting to a (could be of any type)
    database through the configuration files. This is probably the easiest to do,
    but would obviously not always be what we want. However, in the case of less code
    is better maintainability, we should always consider the option of connecting
    to a database like this.
  prefs: []
  type: TYPE_NORMAL
- en: We should refrain from putting business logic in the controller, as that is
    not what a MVC is for, we just showed it here as an example only. We can get the
    db adapter from anywhere where we have the service manager in reach.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to multiple databases through the configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we can see we now have our adapters defined in the `db => adapters` array
    instead of the `db` array directly. This functionality can be achieved in any
    version of Zend Framework 2 greater or equal to 2.2.
  prefs: []
  type: TYPE_NORMAL
- en: About the ServiceManager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we use the `ServiceManager` for connecting to our database, the `ServiceManager`
    first checks if it has the key we need. If the key is found it first checks in
    its internal registry if there is already an instance for the requested service.
    If not, it will use the `config` data to instantiate it. After instantiation is
    completed it will stash away the reference in its internal registry, which can
    be retrieved again the next time we request it. This way the database adapter
    (or any other service) will be only instantiated once by the `ServiceManager`.
    Instantiating the database connection this way has a couple of pros:'
  prefs: []
  type: TYPE_NORMAL
- en: We always have one connection to the database, which is usually limited on the
    server side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't spend valuable time connecting and reinitializing the connection constantly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No memory is wasted on multiple instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing simple queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Querying the database is obviously something that we need to do once we are
    connected to the database. This recipe explains how this can be done, and the
    different methods available.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make full of the following recipe, a Zend Framework 2 skeleton application
    should be used, with a MySQL server available to connect to. Don't forget that
    connecting to a MySQL server requires the `mysql` and `mysqli` extension enabled
    in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: We have configured a database called `book`, with the table `cards` that has
    the columns `id`, `color`, `type`, and `value`. The SQL query to create the database
    and table are included in the code that comes with the book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Queries come in all sort of forms, and in this recipe we will discuss some basic
    querying.
  prefs: []
  type: TYPE_NORMAL
- en: Using raw SQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll be editing in the `/module/Application/src/Application/Controller/IndexController.php`
    file for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'An example using an array or the `ParameterContainer` object for passing variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using the prepared statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll be editing in the `/module/Application/src/Application/Controller/IndexController.php`
    file for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Quote identifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method will quote an identifier that is going to be used in a SQL query
    in a safe way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Quote identifier chain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `quoteIdentifierChain` method will quote multiple identifiers and glue
    them together with the identifier separator (see method `getIdentifierSeparator()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Quote (trusted) value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`quoteValue` and `quoteTrustedValue` are used for quoting values used in for
    example WHERE clauses. `quoteTrustedValue()` should only be used when we trust
    the value (for example if we put it in ourselves): The following is an example
    of `quoteValue` and `quoteTrustedValue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Quote value list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Quote value list quotes an entire list of values and returns them, separated
    by a comma. Comes in handy, for example, if we want to use a list in a `WHERE`
    clause where we use an `IN` operator. There is no method that handles trusted
    values, so we should be aware that this could trigger errors in our PHP error
    log if there are no drivers or modules available to quote the value, however,
    it will always return the expected values. The following is an example of `quoteValueList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Quote identifier in fragment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `quoteIdentifierInFragment` method plucks out the identifiers by a RegEx
    pattern, and makes sure only the right identifiers are quoted. If we are using
    characters outside the following characters: A-z,0-9, *, "." or ''AS'', we will
    need to give them up as a safe word by using the second parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's understand the operations we just did.
  prefs: []
  type: TYPE_NORMAL
- en: Using raw SQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first method of executing SQL is by simply using the `query()` method on
    the database connection. This is the simplest form of querying, and it has it
    pros and cons, one pro is that the queries are quick and easy, the con is that
    it isn't really useful for reuse as the query constantly needs either new input
    every time we execute it, or needs the variables passed into it every time we
    want to execute it.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the example, we created a query first with the mode set to
    `QUERY_MODE_PREPARE`, which in effect means that the query isn't executed straight
    away, but just prepared for execution. When we come to execute the query, we see
    that we parse the variables for the `WHERE` clause with the `execute()` method.
    The `execute()` statement then executes the query and gives the result back.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the second parameter to `query()`, we could also do either `QUERY_MODE_EXECUTE`
    to immediately execute the query (and thus returning the result set straight away)
    or parse an array with parameters or `ParameterContainer`. For more information
    on `ParameterContainer` see the following section.
  prefs: []
  type: TYPE_NORMAL
- en: If we parse either an array or a `ParameterContainer` object as the last option
    of `query()`, it would both lead to the query parameters being filled and the
    query mode to be put on `QUERY_MODE_PREPARE`. This means that because we already
    parsed the parameters for our query into the `query()` method, we don't have to
    add them again in the `execute()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using prepared statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `query()` method is described as a convenience function and is not really
    usefully when we want to protect ourselves against SQL injection or want to use
    a single query multiple times with different parameters. The `createStatement()`
    function on the other hand provides a great way of storing and preparing a SQL
    before use in a safe and responsible way.
  prefs: []
  type: TYPE_NORMAL
- en: As seen in the example, we have executed a similar statement such as the `query()`
    method, however this method is much more maintainable and reusable than the `query()`
    method. By using `ParameterContainer` we can easily inject our variables into
    the SQL and manage them simply because of the container nature of the object.
  prefs: []
  type: TYPE_NORMAL
- en: Because we used `:type` and `:color` the statement knows that our parameter
    array (`ParameterContainer` implements the `ArrayAccess` class) should contain
    the keys `type` and `color` to match them to the SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Quoting in our SQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually where there is database access there is user input, and if there is
    one thing we should never trust it is user input. Although the majority of people
    have no intention of hacking your website, a malicious few will try to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Zend Framework 2 offers a range of quote methods which we can use to protect
    ourselves from any harm. We should note however that these are just a small set
    of tools that you can use in prevention of a disastrous situation, and we advice
    that a full range of utilities is used to prevent SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: Using createStatement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we use `createStatement()` the result objects are instantiated through
    the driver, so the workings of a statement for MySQL can be different from Oracle
    (can, and will I think). Once we create a statement it will also automatically
    connect to the database, which is handy but we must be wary that we are not creating
    the statement on places where we might not need the database. If we omit such
    a thing it might create a leak that isn't necessary in the first place, although
    probably not such a big leak but a leak nonetheless.
  prefs: []
  type: TYPE_NORMAL
- en: The `query()` method works directly on the connection adapter, and although
    quick in use isn't recommended to use in 'real life' situations as it doesn't
    promote reusability (in my personal opinion). If in doubt, it is always best to
    do `createStatement()`, unless we are simply testing some things out then we can
    use `query()` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Executing queries using TableGateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we have seen how to execute simply queries, it is now time to tell you
    about the `TableGateway`, and it's incredible functionality. This recipe is all
    about querying the database through this and showing off its capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make full of the following recipe, a Zend Framework 2 skeleton application
    should be used, with a MySQL server available to connect to. Don't forget that
    connecting to a MySQL server requires the `mysql` and `mysqli` extension enabled
    in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we are going to do first is insert a record in our sample table. After
    that we will check that it was inserted successfully. Next, we will update the
    record with some new data, and if that worked we will delete it again from the
    table.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a new record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we go about updating a record, it might be handy if we actually have
    a record that we can use to update first. Zend Framework 2 has some new nifty
    database tools that make our lives a little easier when it comes to data handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cards table has the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id` (primary key)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s consider the following example (`/module/Application/src/Application/Controller/IndexController.php`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That concludes the table insert, and obviously this is only one way of inserting
    data in the table. Another way to execute the insert statement would be to use
    the `$sql` object we created before. If we do that we can get rid of `TableGateway`
    and just use that instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we would prefer that we could go about it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Updating a record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can now go on with checking if the insertion went fine, and following that
    we will update the record with some new data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The result of the update will be the amount of rows affected by our `update`
    statement. In our case that would only be one record as we match exactly with
    the primary key of the table.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we are done with all our updates we want to begin deleting this record
    again, so let''s look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Well that was easy. We could just use the same `where` statement as it already
    defined the clause to filter on our primary key from before.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced selects – joins conditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When developing web application we will require more than one table in our queries
    for most of the time, this is because we just need to pull a lot of data from
    everywhere to get the results we need. One way of doing this is by using join
    conditions in our `select` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s just take a look at the following table composition, we are going in
    our virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `people` table will have the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Id` (primary key)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`First_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Last_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Age`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Gender`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Address_Id` (foreign key to `addresses` table)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `addresses` table will have the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Id` (primary key)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Street`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Postcode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`City`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Country`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we want to achieve here is to retrieve the address that belongs to a person
    and show that in our result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example (`/module/Application/src/Application/Controller/IndexController.php`)
    of how we could achieve that in the best possible way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is how simple it is to create a `join` condition on a `select` statement.
    Piece of pie!
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Zend Framework 2 they have separated all the actions such as `Insert`, `DropTable`,
    `Update`, `Delete`, and `Where` into classes of their own, which makes it very
    reusable for developers. The great thing about it is that it also makes the code
    much clearer.
  prefs: []
  type: TYPE_NORMAL
- en: '`TableGatewayInterface` defines a minimum selection of methods that are implemented
    by `AbstractTableGateway` and also `TableGateway`, as that extends from `AbstractTableGateway`
    in the first place. `TableGateway`, for short, implements most common features
    needed to do table operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TableGatewayInterface`, therefore, defines the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getTable()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`select($where = null)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insert($set)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update($set, $where = null)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete($where)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizating with a DB profiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common bottlenecks in an application is the querying to the
    database, as sometimes we just don't know how much is being queried, or we can't
    find out why something is going wrong. This recipe provides us with the tools
    to find even the smallest query used.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A database profiler is used to find bottlenecks in query performance and is
    a great tool to debug the queries that are executed in a session and of course
    the time it takes for them to execute. Once we develop bigger applications we
    tend to forget when and how certain pieces of code execute, which sometimes can
    lead to unnecessary complexity in our code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Profiling an application's database usage can give a clear overview on the performance
    of our application, in this recipe we will discuss how to set up a simple profiler.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new profiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Setting up a new profiler is really easy as at the moment there is only one
    class in Zend Framework 2 that can be used as a profiler. This class is called
    `Zend\Db\Adapter\Profiler\Profiler` and can be instantiated right away. Let''s
    take a look at the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it; this is basically all that is needed to start profiling everything
    from the database. The only thing that is left to do for us is to get the profiles
    back whenever we are done with querying (or whenever we need it really). Let''s
    consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$result` variable will now be filled with the statistical information
    about the statements executed. This result could look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The database profiler is first being attached to the database adapter, making
    the adapter aware of the existence of the profiler. The adapter will start profiling
    (it does this by using the `Profiler::profileStart()` method) the statement every
    time it executes a statement, making sure that everything important will be logged
    about the statement.
  prefs: []
  type: TYPE_NORMAL
- en: When the database adapter has finished executing the statement, it will let
    the profiler know that the statement is done (it will execute the `Profiler::profileFinish()`
    method).
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the previous example we can view the SQL statement executed
    and also the parameters used. After that the start time, end time, and time elapsed
    are also added so that we can spot any potential bottlenecks in the code easily.
  prefs: []
  type: TYPE_NORMAL
- en: All in all this is very useful tool that requires almost nothing in code to
    work, and is still efficient for developers who want to find faults in their databases'
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another great little tool we can take a look at is the Zend Developer Tools,
    which is a module made by Zend that fits in Zend Framework 2 that provides very
    useful debugging tools. If we want to know more, we can find the tools at [https://github.com/zendframework/ZendDeveloperTools](https://github.com/zendframework/ZendDeveloperTools).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Database Access Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we can use a dozen different methods to standardize our database functionality,
    a Database Access Object (or DAO) can be used efficiently to achieve this. This
    recipe is a working example of how to make your own, and begin organizing your
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Database Access Object (from now on DAO) is used to simplify functionality to
    and from our database(s). The idea behind a DAO is to create mapping classes that
    have a single responsibility on their functionality. This means that, for example,
    we have a table called `cards`, which also has a mapping called `Cards`. This
    `Cards` mapping will then contain all the functionality we need to use in that
    table.
  prefs: []
  type: TYPE_NORMAL
- en: This could include, for example, the CRUD (Create, Read, Update, and Delete)
    functionality, but also more complex methods such as calculations. The idea behind
    a mapping class is that we are able to hide the layout of the database and provide
    an interface for the rest of the application, which is reliable and consistent
    without the application needing to know how the database is structured.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the recipe we will use the database layout that has a table called `cards`,
    with the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id` (primary key)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A DAO is a great way of organizing our database functionality in the application,
    so that we will always have a clear structure of our logic. In this recipe, we'll
    show how to make one of our own.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our new module and configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our DAO is going be in a completely separate module, as that is the best way
    of separating the different pieces of code. So, we go ahead to create a new module
    DAO, which should have the following directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Once we have created the necessary folders, we can copy the default `Module.php`
    from the `Application` module over to our `DAO` folder. We then open our new `Module.php`,
    and make sure the `namespace` is set to `DAO` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to create a new `/module/DAO/config/module.config.php` file
    and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This pretty basic configuration will be used by our database connector later
    on to get the connection details from.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a connector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we want to create our connector, which is basically a class that will
    create a database adapter and set everything up for us. It will not do anything
    else than that, so we should be able to code one easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a file called `/module/DAO/src/DAO/db/Connection/Connector.php`
    in the `DAO\Db\Connection` `namespace` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: That is it for the class definition; we are now able to initialize the connection
    if we have the right items available in our configuration. If not, the method
    will throw an exception and let us know anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a mapper interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We want to create a mapper interface now on which we will base all our future
    mapper classes. We do this because we want to make sure that all our mapper classes
    contain at least some of the methods we want. Our mapper interface will, therefore,
    define a small selection of methods we want our mapper classes to have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create file called `/module/DAO/src/DAO/Db/Mapper/MapperInterface.php`
    in the `DAO\Db\Mapper` `namespace` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As we see this is a pretty straightforward file as interfaces don't actually
    do any implementation of the code at all.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an abstract mapper class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although the interface doesn''t implement any of the code, an abstract class
    can. We want to create a file called `/module/DAO/src/DAO/Db/Mapper/MapperAbstract.php`
    in the same `DAO\Db\Mapper` `namespace`, which will contain a method that will
    create a connection to the database, point to the right table, and return a freshly
    baked `Zend\Db\Sql\Sql` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything set up, now let''s create the method we need for our connection
    (don''t forget to create `setServiceLocator` and `getServiceLocator` methods as
    well!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Our freshly created connection method can now be used by mappers to get a `Zend\Db\Sql\Sql`
    object, which is relevant to the table they want to work in.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Data Transfer Object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s create a new **Data Transfer** **Object** (**DTO**) file called
    `/module/DAO/src/DAO/Db/DTO/Cards.php` in the `DAO\Db\DTO` `namespace` and add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have set our private properties, we will also create some basic
    getters and setters for them. Use the following code for getters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The getters are now done, which was pretty easy, now let''s do the setters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The setters were obviously a little more complicated as we also wanted to make
    sure the data we put in is valid for our database. This way we can safely parse
    object to the mapper later on and be sure that everything will go all right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create the last method which is a construct so that we can easily set
    the properties without needing to do that manually afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We now created a simple DTO which we can use to communicate to some methods
    in our mapper. Now, last but not least let's create the mapper class!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a mapper class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mapper will be the main DAO class that we will use in the application because
    it will be the class that has the methods for `insert`, `getAll`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a `/module/DAO/src/DAO/Db/Mapper/Cards.php` file in
    the `DAO\Db\Mapper` `namespace` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a method for deleting a row first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created a simple `delete` method, now let''s continue and create our
    `getAll` method, which will retrieve all the records in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have created our `getAll`, which returns an array with Cards DTO''s
    we will now create the method to insert a record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s continue to our `load` method, which will return only one record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We now created the `load` method, which will return a Cards DTO object for
    us to use, now last but not least the `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now successfully created a mapper class and that also concludes our
    DAO. We can now easily get the mapper through the service manager in (for example)
    a controller (`/module/Cards/src/Cards/Controller/CardController.php`) by using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: And, because we created an abstract and interface it is really easy for us to
    create new mappers as well. Obviously it requires us to be consistent, but that
    is a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: About the DAO
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A DAO or Database Access Object is a design pattern that creates an abstract
    environment for developers to access their database related methods. This means
    that we create a standardized environment for us to work in, which is not only
    consistent but also very stable. Because, we limit ourselves in our way of working
    with database queries and objects we create a piece of code which is very easy
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we created a very simple DAO, which (to my personal opinion)
    is a good basis, but probably not the most efficient way of creating one. We just
    took one example how a DAO can be implemented, but we should never shut our eyes
    to the literally dozens of different ways of implementing it.
  prefs: []
  type: TYPE_NORMAL
- en: About the recipe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because our configuration contains a mapper array with all the mapper class
    names (`DAO\Db\Mapper\Cards` becomes simply cards in the configuration) we cannot
    go wrong. This separates the local configuration of the database environment from
    the code. So if we were to change the table name to 'books' we only have to change
    the configuration and the code would still work!
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a DTO so that we can easily insert/update and return
    records through a standardized way. So instead of returning an array in our selections
    we can then return an object which will contain everything we need. This way we
    make sure our data is filtered and simply transferrable.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the `insert` method in the Mapper class we assume the DTO object
    contains the right information for us to insert our record. Although this method
    is far from perfect, it is a good method of separating our checking and validating
    of the data to another object (in our case the DTO) so we can just concentrate
    on inserting the record. This separation is essential to a good working DAO.
  prefs: []
  type: TYPE_NORMAL
