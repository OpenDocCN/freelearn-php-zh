- en: Chapter 5. Configuring and Using Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 配置和使用数据库
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Connecting to a database
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: Executing simple queries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行简单查询
- en: Executing queries using the TableGateway
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TableGateway执行查询
- en: Optimization with a DB profiler
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DB分析器进行优化
- en: Creating a Database Access Object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据库访问对象
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Obviously databases are essential if we want to store data, and with all the
    different kinds of database engines around, it is sometimes hard to see the wood
    through the trees. Zend Framework 2, however, brings us a bit of hope of standardizing
    the way we work with databases. In this chapter, we will be showing loads of examples
    from database connections to optimizing the performance of our queries.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果我们想存储数据，数据库是必不可少的，而且由于有各种各样的数据库引擎，有时候很难看清事物的本质。然而，Zend Framework 2为我们带来了一丝标准化的希望。在本章中，我们将展示从数据库连接到优化查询性能的大量示例。
- en: Default database engines available
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用的默认数据库引擎
- en: Zend Framework 2 has a default collection of database drivers available to use,
    and obviously it also supports the PHP PDO extension for a more standardized way
    of using databases.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Zend Framework 2提供了一组默认的数据库驱动程序可供使用，并且显然它也支持PHP PDO扩展，以实现更标准化的数据库使用方式。
- en: IBM DB2 driver
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IBM DB2驱动程序
- en: '**IBM DB2** is a database server designed by IBM and is the second most used
    DBMS according to IDC''s report of 2009 ([http://www.marketresearch.com/IDC-v2477/Worldwide-Database-Management-Systems-Forecast-2393193/view-stat/ibm-14.html](http://www.marketresearch.com/IDC-v2477/Worldwide-Database-Management-Systems-Forecast-2393193/view-stat/ibm-14.html)).
    The database engine can be traced back to the 1970''s and was mainly only available
    for the IBM mainframe until the 1990''s when it started supporting other more
    widely used operating systems.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**IBM DB2**是由IBM设计的一个数据库服务器，根据IDC 2009年的报告，它是第二常用的数据库管理系统（DBMS）([http://www.marketresearch.com/IDC-v2477/Worldwide-Database-Management-Systems-Forecast-2393193/view-stat/ibm-14.html](http://www.marketresearch.com/IDC-v2477/Worldwide-Database-Management-Systems-Forecast-2393193/view-stat/ibm-14.html))。数据库引擎可以追溯到20世纪70年代，直到20世纪90年代才开始支持其他更广泛使用的操作系统。'
- en: Nowadays, the DB2 is mainly used in ZF2 for the IBM i Power Systems such as
    the AS/400, but remains a very powerful database engine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，DB2主要在ZF2的IBM i Power Systems（如AS/400）中使用，但仍然是一个非常强大的数据库引擎。
- en: 'Requirements:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要求：
- en: The IBM DB2 Universal Database client needs to be installed on the PHP machine
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IBM DB2通用数据库客户端需要安装在PHP机器上
- en: PHP configured either with the `--with-IBM_DB2` option or enabled (and installed)
    the `ibm_db2` extension in `php.ini`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP配置为使用`--with-IBM_DB2`选项，或者在`php.ini`中启用（并安装）了`ibm_db2`扩展
- en: MySQLi driver
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MySQLi驱动程序
- en: 'For PHP developers, this is probably the most used database engine, the **MySQLi**
    instead of the normal MySQL driver gives the extension several advantages over
    modern MySQL system versions (4.1.3 and newer). This improved extension supports
    the following modern MySQL functionality:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PHP开发者来说，这可能是最常用的数据库引擎，**MySQLi**而不是普通的MySQL驱动程序，在现代MySQL系统版本（4.1.3及更高版本）中为扩展提供了几个优势。这个改进的扩展支持以下现代MySQL功能：
- en: Enhanced server support
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强的服务器支持
- en: Transaction support
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务支持
- en: Prepared statements support
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预处理语句支持
- en: Object-oriented interface
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象接口
- en: Multiple statements support
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多语句支持
- en: Enhanced debugging availability
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强的调试可用性
- en: The requirements for MySQLi driver is that the PHP is configured either with
    the `--with-mysql` or `--with-mysqli` option or enabled (and installed) the `mysql`
    and `mysqli` extension in `php.ini`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: MySQLi驱动程序的要求是PHP配置为使用`--with-mysql`或`--with-mysqli`选项，或者在`php.ini`中启用（并安装）了`mysql`和`mysqli`扩展。
- en: OCI8 driver
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OCI8驱动程序
- en: OCI8 driver supports Oracle Database 11g, 10g, 9i, and 8i (according to the
    PHP manual), and is widely used in the PHP community.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: OCI8驱动程序支持Oracle数据库11g、10g、9i和8i（根据PHP手册），在PHP社区中广泛使用。
- en: 'Requirements:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要求：
- en: Oracle 9ir2, 10g, or 11g Client libraries on the PHP machine
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP机器上的Oracle 9ir2、10g或11g客户端库
- en: PHP configured either with the `--with-oci8` option or enabled (and installed)
    the `oci8` extension in `php.ini`
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP配置为使用`--with-oci8`选项，或者在`php.ini`中启用（并安装）了`oci8`扩展
- en: PGSQL driver
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PGSQL驱动程序
- en: '**PostgreSQL** is an object-relational database and is my personal favorite,
    this database has been around since 1995 and is used by websites such as Reddit,
    Instagram, and Yahoo!.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**PostgreSQL**是一个对象关系型数据库，也是我个人最喜欢的数据库，这个数据库自1995年以来一直存在，并被Reddit、Instagram和Yahoo!等网站使用。'
- en: The requirement for this is that the PHP is configured either with the `--with-pgsql`
    option or enabled (and installed) the `pgsql` extension in `php.ini`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此要求，PHP需要配置为带有`--with-pgsql`选项，或者在`php.ini`中启用（并安装）`pgsql`扩展。
- en: SQLSRV driver
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLSRV驱动程序
- en: Microsoft SQL Server (and SQL Azure) is a database that works exclusively on
    Microsoft Windows, and is widely considered being a very good and stable database
    engine. Versions 3.0 or higher of the PHP extension support SQL Server 2005.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 微软SQL Server（以及SQL Azure）是一个仅在Microsoft Windows上运行的数据库，并且普遍被认为是一个非常良好且稳定的数据库引擎。PHP扩展的3.0或更高版本支持SQL
    Server 2005。
- en: 'Requirements:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要求：
- en: The Microsoft SQL Server 2012 Native Client needs to be installed on the PHP
    machine
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要在PHP机器上安装Microsoft SQL Server 2012 Native Client
- en: The extension `php_sqlsrv_5*_nts.dll` or `php_sqlsrv_5*_ts.dll` should be enabled
    (and installed) on the PHP machine
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应在PHP机器上启用（并安装）`php_sqlsrv_5*_nts.dll`或`php_sqlsrv_5*_ts.dll`
- en: PDO driver
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PDO驱动程序
- en: The PDO extension in PHP is probably the best method of connecting to a database
    available. Not only does it have a wide selection of database engines it supports,
    but also a more standardized way of working with them, which makes it easier to
    support in the long run (and that is a pro in the long run).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中的PDO扩展可能是连接数据库的最佳方法。它不仅支持广泛的数据库引擎，而且还有更标准化的方式与它们交互，这使得长期支持变得更加容易（这也是长期的优势）。
- en: Not only is it easier to support, for example, its standardized way of connecting
    to databases and executing queries makes it much easier for us developers to switch.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅支持起来更容易，例如，其标准化的数据库连接和查询执行方式使得我们开发者切换起来更加容易。
- en: The requirements for this is that at least one `pdo` extension needs to be enabled
    in the `php.ini` file or otherwise it won't work.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此要求，至少需要在`php.ini`文件中启用一个`pdo`扩展，否则它将无法工作。
- en: All the drivers communicate with PHP through either as the built-in compilation
    or used as an extension on the library. Without these extensions PHP would be
    unable to figure out how to communicate with the specific libraries. Some extensions
    (such as the Oracle one) require even more, like client libraries to make it work.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所有驱动程序都通过内置编译或作为库的扩展与PHP通信。没有这些扩展，PHP将无法确定如何与特定库通信。一些扩展（如Oracle扩展）甚至需要更多，例如客户端库才能使其工作。
- en: We should always check the php.net documentation for the requirements of the
    specific extension we try to enable.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终检查php.net文档，以了解我们尝试启用的特定扩展的要求。
- en: Connecting to a database
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: After seeing all the database types that Zend Framework 2 supports, we can finally
    start connecting to them. In this recipe, we will connect to a MySQL server and
    show different ways of doing this.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到Zend Framework 2支持的数据库类型之后，我们终于可以开始连接到它们了。在这个菜谱中，我们将连接到MySQL服务器，并展示不同的连接方式。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To make full of the following recipe, a Zend Framework 2 skeleton application
    should be used, with a MySQL server available to connect to. Don't forget that
    connecting to a MySQL server requires the `mysql` and `mysqli` extensions enabled
    in PHP.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用以下菜谱，应使用一个带有MySQL服务器可供连接的Zend Framework 2骨架应用程序。别忘了连接到MySQL服务器需要在PHP中启用`mysql`和`mysqli`扩展。
- en: How to do it…
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In this recipe we'll give some examples of how to connect to a single database
    or multiple databases.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将给出一些如何连接到单个数据库或多个数据库的示例。
- en: Connecting to a MySQL database through the configuration
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过配置连接到MySQL数据库
- en: 'We can make the following change to the `/config/autoload/global.php` file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对`/config/autoload/global.php`文件进行以下更改：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see in the example, setting up the database configuration is quite
    easy. Now, if you were wondering how to use a configuration like this in a real
    world example, let''s consider the following controller:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在示例中所见，设置数据库配置相当简单。现在，如果你想知道如何在现实世界的例子中使用这样的配置，让我们考虑以下控制器：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see it is very easy to get it going now in the controller.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，现在在控制器中启动它非常容易。
- en: Connecting to multiple databases through the configuration
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过配置连接到多个数据库
- en: 'Some applications require us to connect to multiple databases at the same time,
    and we can easily achieve that in Zend Framework 2 as well by doing the following
    in the `/config/autoload/global.php` file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序要求我们同时连接到多个数据库，我们也可以在Zend Framework 2中通过在`/config/autoload/global.php`文件中执行以下操作轻松实现：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In our controllers (or anywhere where we can access the service manager) we
    can easily get the `db` DBAdapter now by doing the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的控制器（或我们能够访问服务管理器的地方）中，我们可以通过以下方式轻松地获取 `db` DBAdapter：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Connecting to a MySQL database through code
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过代码连接到 MySQL 数据库
- en: Although it is less clean than the method we showed before, sometimes it is
    just necessary to connect through good old instantiation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法不如我们之前展示的方法干净，但有时通过传统的实例化连接是必要的。
- en: 'First let''s see an example if we want to connect to a MySQL server:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一个示例，如果我们想连接到一个 MySQL 服务器：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We now can easily execute the queries on the instantiated `$db`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以轻松地在实例化的 `$db` 上执行查询。
- en: How it works…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In Zend Framework 2 there are many ways of defining a database connection, in
    this section we will discuss three of them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Zend Framework 2 中，有许多定义数据库连接的方法，在本节中，我们将讨论其中的三种。
- en: Connecting to a MySQL database through the configuration
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过配置连接到 MySQL 数据库
- en: The first method we are going to show is connecting to a (could be of any type)
    database through the configuration files. This is probably the easiest to do,
    but would obviously not always be what we want. However, in the case of less code
    is better maintainability, we should always consider the option of connecting
    to a database like this.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要展示的第一个方法是通过配置文件连接到一个（可以是任何类型）数据库。这可能是最简单的方法，但显然并不总是我们想要的。然而，在代码越少越好维护的情况下，我们应该始终考虑以这种方式连接到数据库的选项。
- en: We should refrain from putting business logic in the controller, as that is
    not what a MVC is for, we just showed it here as an example only. We can get the
    db adapter from anywhere where we have the service manager in reach.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该避免在控制器中放置业务逻辑，因为 MVC 不是为此而设计的，我们在这里只是作为示例展示。我们可以从任何有服务管理器的地方获取 db 适配器。
- en: Connecting to multiple databases through the configuration
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过配置连接到多个数据库
- en: As we can see we now have our adapters defined in the `db => adapters` array
    instead of the `db` array directly. This functionality can be achieved in any
    version of Zend Framework 2 greater or equal to 2.2.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们现在在 `db => adapters` 数组中定义了适配器，而不是直接在 `db` 数组中。这种功能可以在任何版本大于或等于 2.2
    的 Zend Framework 2 中实现。
- en: About the ServiceManager
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于 ServiceManager
- en: 'When we use the `ServiceManager` for connecting to our database, the `ServiceManager`
    first checks if it has the key we need. If the key is found it first checks in
    its internal registry if there is already an instance for the requested service.
    If not, it will use the `config` data to instantiate it. After instantiation is
    completed it will stash away the reference in its internal registry, which can
    be retrieved again the next time we request it. This way the database adapter
    (or any other service) will be only instantiated once by the `ServiceManager`.
    Instantiating the database connection this way has a couple of pros:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `ServiceManager` 连接到我们的数据库时，`ServiceManager` 首先检查它是否有我们需要的键。如果找到了键，它首先在其内部注册表中检查是否有请求服务的实例。如果没有，它将使用
    `config` 数据来实例化它。实例化完成后，它将在其内部注册表中保存引用，这样我们下次请求时可以再次检索它。这样，数据库适配器（或任何其他服务）将由 `ServiceManager`
    只实例化一次。以这种方式实例化数据库连接有几个优点：
- en: We always have one connection to the database, which is usually limited on the
    server side
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们始终有一个数据库连接，这通常在服务器端有限制
- en: We don't spend valuable time connecting and reinitializing the connection constantly
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不会花费宝贵的时间不断连接和重新初始化连接
- en: No memory is wasted on multiple instances
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有多余的内存浪费在多个实例上
- en: Executing simple queries
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行简单查询
- en: Querying the database is obviously something that we need to do once we are
    connected to the database. This recipe explains how this can be done, and the
    different methods available.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 查询数据库显然是我们连接到数据库后需要做的事情。这个配方解释了如何做到这一点，以及可用的不同方法。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To make full of the following recipe, a Zend Framework 2 skeleton application
    should be used, with a MySQL server available to connect to. Don't forget that
    connecting to a MySQL server requires the `mysql` and `mysqli` extension enabled
    in PHP.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用以下配方，应该使用一个 Zend Framework 2 骨架应用程序，并确保有一个可连接的 MySQL 服务器。别忘了连接到 MySQL
    服务器需要在 PHP 中启用 `mysql` 和 `mysqli` 扩展。
- en: We have configured a database called `book`, with the table `cards` that has
    the columns `id`, `color`, `type`, and `value`. The SQL query to create the database
    and table are included in the code that comes with the book.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了一个名为 `book` 的数据库，其中包含一个名为 `cards` 的表，该表有 `id`，`color`，`type` 和 `value`
    列。创建数据库和表的 SQL 查询包含在本书的代码中。
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Queries come in all sort of forms, and in this recipe we will discuss some basic
    querying.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 查询以各种形式出现，在这个菜谱中，我们将讨论一些基本的查询。
- en: Using raw SQL
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用原始 SQL
- en: 'We''ll be editing in the `/module/Application/src/Application/Controller/IndexController.php`
    file for this example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将编辑 `/module/Application/src/Application/Controller/IndexController.php`
    文件：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'An example using an array or the `ParameterContainer` object for passing variables:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组或 `ParameterContainer` 对象传递变量的示例：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using the prepared statements
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用预处理语句
- en: 'We''ll be editing in the `/module/Application/src/Application/Controller/IndexController.php`
    file for this example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将编辑 `/module/Application/src/Application/Controller/IndexController.php`
    文件：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Quote identifier
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用标识符
- en: 'This method will quote an identifier that is going to be used in a SQL query
    in a safe way:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将以安全的方式引用将在 SQL 查询中使用的标识符：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code will give the following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下输出：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Quote identifier chain
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用标识符链
- en: 'The `quoteIdentifierChain` method will quote multiple identifiers and glue
    them together with the identifier separator (see method `getIdentifierSeparator()`):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`quoteIdentifierChain` 方法将引用多个标识符，并用标识符分隔符（见方法 `getIdentifierSeparator()`）将它们粘合在一起：'
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code will give the following output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下输出：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Quote (trusted) value
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用（可信）值
- en: '`quoteValue` and `quoteTrustedValue` are used for quoting values used in for
    example WHERE clauses. `quoteTrustedValue()` should only be used when we trust
    the value (for example if we put it in ourselves): The following is an example
    of `quoteValue` and `quoteTrustedValue`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`quoteValue` 和 `quoteTrustedValue` 用于引用在 WHERE 子句中使用的值。`quoteTrustedValue()`
    应仅在我们信任值时使用（例如，如果我们自己放入）：以下是一个 `quoteValue` 和 `quoteTrustedValue` 的示例：'
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code will give the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下输出：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Quote value list
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用值列表
- en: 'Quote value list quotes an entire list of values and returns them, separated
    by a comma. Comes in handy, for example, if we want to use a list in a `WHERE`
    clause where we use an `IN` operator. There is no method that handles trusted
    values, so we should be aware that this could trigger errors in our PHP error
    log if there are no drivers or modules available to quote the value, however,
    it will always return the expected values. The following is an example of `quoteValueList`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 引用值列表引用整个值列表并返回它们，用逗号分隔。例如，如果我们想在 `WHERE` 子句中使用 `IN` 操作符，这个功能就很有用。没有处理可信值的方法，因此我们应该意识到，如果没有可用的驱动程序或模块来引用值，这可能会在我们的
    PHP 错误日志中触发错误，然而，它总是会返回预期的值。以下是一个 `quoteValueList` 的示例：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code will give the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下输出：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Quote identifier in fragment
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在片段中引用标识符
- en: 'The `quoteIdentifierInFragment` method plucks out the identifiers by a RegEx
    pattern, and makes sure only the right identifiers are quoted. If we are using
    characters outside the following characters: A-z,0-9, *, "." or ''AS'', we will
    need to give them up as a safe word by using the second parameter.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`quoteIdentifierInFragment` 方法通过正则表达式模式提取标识符，并确保只引用正确的标识符。如果我们使用以下字符之外的字符：A-z，0-9，*，"."
    或 ''AS''，我们需要通过使用第二个参数将它们作为安全词放弃。'
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code gives the following output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下输出：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Let's understand the operations we just did.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解我们刚才所做的操作。
- en: Using raw SQL
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用原始 SQL
- en: The first method of executing SQL is by simply using the `query()` method on
    the database connection. This is the simplest form of querying, and it has it
    pros and cons, one pro is that the queries are quick and easy, the con is that
    it isn't really useful for reuse as the query constantly needs either new input
    every time we execute it, or needs the variables passed into it every time we
    want to execute it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 SQL 的第一种方法是在数据库连接上简单地使用 `query()` 方法。这是查询的最简单形式，它既有优点也有缺点，一个优点是查询快速简单，缺点是它实际上并不适用于重用，因为每次执行查询时都需要新的输入，或者每次想要执行查询时都需要传递变量。
- en: As we can see in the example, we created a query first with the mode set to
    `QUERY_MODE_PREPARE`, which in effect means that the query isn't executed straight
    away, but just prepared for execution. When we come to execute the query, we see
    that we parse the variables for the `WHERE` clause with the `execute()` method.
    The `execute()` statement then executes the query and gives the result back.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，我们首先以`QUERY_MODE_PREPARE`模式创建了一个查询，这意味着查询不会立即执行，而是仅准备执行。当我们执行查询时，我们会看到我们使用`execute()`方法解析`WHERE`子句的变量。然后，`execute()`语句执行查询并返回结果。
- en: Instead of the second parameter to `query()`, we could also do either `QUERY_MODE_EXECUTE`
    to immediately execute the query (and thus returning the result set straight away)
    or parse an array with parameters or `ParameterContainer`. For more information
    on `ParameterContainer` see the following section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`query()`方法的第二个参数之外，我们还可以使用`QUERY_MODE_EXECUTE`立即执行查询（从而直接返回结果集）或解析带有参数的数组或`ParameterContainer`。有关`ParameterContainer`的更多信息，请参阅以下章节。
- en: If we parse either an array or a `ParameterContainer` object as the last option
    of `query()`, it would both lead to the query parameters being filled and the
    query mode to be put on `QUERY_MODE_PREPARE`. This means that because we already
    parsed the parameters for our query into the `query()` method, we don't have to
    add them again in the `execute()` method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将数组或`ParameterContainer`对象作为`query()`方法的最后一个选项进行解析，这将导致查询参数被填充，并将查询模式设置为`QUERY_MODE_PREPARE`。这意味着因为我们已经将查询参数解析到`query()`方法中，所以我们不需要在`execute()`方法中再次添加它们。
- en: Using prepared statements
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用预处理语句
- en: The `query()` method is described as a convenience function and is not really
    usefully when we want to protect ourselves against SQL injection or want to use
    a single query multiple times with different parameters. The `createStatement()`
    function on the other hand provides a great way of storing and preparing a SQL
    before use in a safe and responsible way.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`query()`方法被描述为一个便利函数，当我们想要保护自己免受SQL注入或想要使用具有不同参数的单个查询时，它并不是非常有用。另一方面，`createStatement()`函数提供了一个在安全且负责任的方式下存储和准备SQL语句以供使用的好方法。'
- en: As seen in the example, we have executed a similar statement such as the `query()`
    method, however this method is much more maintainable and reusable than the `query()`
    method. By using `ParameterContainer` we can easily inject our variables into
    the SQL and manage them simply because of the container nature of the object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，我们执行了一个类似于`query()`方法的类似语句，然而这种方法比`query()`方法更易于维护和重用。通过使用`ParameterContainer`，我们可以轻松地将变量注入SQL中，并简单地因为对象具有容器性质而管理它们。
- en: Because we used `:type` and `:color` the statement knows that our parameter
    array (`ParameterContainer` implements the `ArrayAccess` class) should contain
    the keys `type` and `color` to match them to the SQL statement.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用了`:type`和`:color`，所以语句知道我们的参数数组（`ParameterContainer`实现了`ArrayAccess`类）应该包含`type`和`color`键以匹配SQL语句。
- en: Quoting in our SQL
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的SQL中引用
- en: Usually where there is database access there is user input, and if there is
    one thing we should never trust it is user input. Although the majority of people
    have no intention of hacking your website, a malicious few will try to do so.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，只要有数据库访问，就会有用户输入，而我们绝对不应该信任的正是用户输入。尽管大多数人没有黑客攻击您网站的意图，但少数恶意的人会尝试这样做。
- en: Zend Framework 2 offers a range of quote methods which we can use to protect
    ourselves from any harm. We should note however that these are just a small set
    of tools that you can use in prevention of a disastrous situation, and we advice
    that a full range of utilities is used to prevent SQL injection.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Zend Framework 2 提供了一系列引用方法，我们可以使用这些方法来保护自己免受任何伤害。然而，我们应该注意的是，这些只是一小部分工具，您可以在预防灾难性情况时使用，我们建议使用一系列的实用工具来防止SQL注入。
- en: Using createStatement
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`createStatement`
- en: When we use `createStatement()` the result objects are instantiated through
    the driver, so the workings of a statement for MySQL can be different from Oracle
    (can, and will I think). Once we create a statement it will also automatically
    connect to the database, which is handy but we must be wary that we are not creating
    the statement on places where we might not need the database. If we omit such
    a thing it might create a leak that isn't necessary in the first place, although
    probably not such a big leak but a leak nonetheless.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `createStatement()` 时，结果对象将通过驱动程序实例化，因此 MySQL 的语句工作方式可能与 Oracle 不同（可以，并且我认为会这样）。一旦我们创建了一个语句，它也会自动连接到数据库，这很方便，但我们必须小心，不要在不需要数据库的地方创建语句。如果我们省略了这样的事情，可能会创建不必要的泄漏，尽管可能不是那么大的泄漏，但仍然是一种泄漏。
- en: The `query()` method works directly on the connection adapter, and although
    quick in use isn't recommended to use in 'real life' situations as it doesn't
    promote reusability (in my personal opinion). If in doubt, it is always best to
    do `createStatement()`, unless we are simply testing some things out then we can
    use `query()` instead.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`query()` 方法直接在连接适配器上工作，尽管使用起来很方便，但在实际生活中并不推荐使用，因为它不促进可重用性（就我个人而言）。如果有疑问，最好总是执行
    `createStatement()`，除非我们只是测试一些事情，那么我们可以使用 `query()`。'
- en: Executing queries using TableGateway
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TableGateway 执行查询
- en: After we have seen how to execute simply queries, it is now time to tell you
    about the `TableGateway`, and it's incredible functionality. This recipe is all
    about querying the database through this and showing off its capabilities.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解了如何执行简单查询之后，现在是时候告诉你关于 `TableGateway` 以及它的强大功能了。这个示例完全是关于通过它查询数据库并展示其功能。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To make full of the following recipe, a Zend Framework 2 skeleton application
    should be used, with a MySQL server available to connect to. Don't forget that
    connecting to a MySQL server requires the `mysql` and `mysqli` extension enabled
    in PHP.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分了解以下食谱，应使用 Zend Framework 2 框架的骨架应用程序，并确保有一个可连接的 MySQL 服务器。别忘了连接到 MySQL
    服务器需要在 PHP 中启用 `mysql` 和 `mysqli` 扩展。
- en: How to do it…
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: What we are going to do first is insert a record in our sample table. After
    that we will check that it was inserted successfully. Next, we will update the
    record with some new data, and if that worked we will delete it again from the
    table.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是在我们的示例表中插入一条记录。之后，我们将检查它是否成功插入。接下来，我们将使用一些新数据更新记录，如果成功了，我们将再次从表中删除它。
- en: Inserting a new record
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入新记录
- en: Before we go about updating a record, it might be handy if we actually have
    a record that we can use to update first. Zend Framework 2 has some new nifty
    database tools that make our lives a little easier when it comes to data handling.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们开始更新记录之前，如果我们实际上有一个可以用来更新的记录，那将很有帮助。Zend Framework 2 有一些新的巧妙数据库工具，使我们在数据处理方面的生活更加轻松。 '
- en: 'The cards table has the following columns:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片表有以下列：
- en: '`id` (primary key)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id` (主键)'
- en: '`color`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`'
- en: '`value`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`'
- en: '`type`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`'
- en: 'Let''s consider the following example (`/module/Application/src/Application/Controller/IndexController.php`):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例（`/module/Application/src/Application/Controller/IndexController.php`）：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That concludes the table insert, and obviously this is only one way of inserting
    data in the table. Another way to execute the insert statement would be to use
    the `$sql` object we created before. If we do that we can get rid of `TableGateway`
    and just use that instead.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 表插入操作到此结束，显然这只是在表中插入数据的一种方式。另一种执行插入语句的方法是使用我们之前创建的 `$sql` 对象。如果我们这样做，我们可以去掉
    `TableGateway` 并直接使用它。
- en: 'If we would prefer that we could go about it like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以这样进行：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Updating a record
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新记录
- en: 'We can now go on with checking if the insertion went fine, and following that
    we will update the record with some new data:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续检查插入操作是否成功，然后我们将使用一些新数据更新记录：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The result of the update will be the amount of rows affected by our `update`
    statement. In our case that would only be one record as we match exactly with
    the primary key of the table.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 更新操作的结果将是受我们的 `update` 语句影响的行数。在我们的例子中，这只会是一条记录，因为我们与表的主键完全匹配。
- en: Deleting a record
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除记录
- en: 'Now, we are done with all our updates we want to begin deleting this record
    again, so let''s look at the following code snippet:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了所有想要更新的操作，我们想要再次开始删除这条记录，让我们看看以下代码片段：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Well that was easy. We could just use the same `where` statement as it already
    defined the clause to filter on our primary key from before.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这很简单。我们可以直接使用相同的 `where` 语句，因为它已经定义了从之前的查询中过滤主键的子句。
- en: Advanced selects – joins conditions
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级选择 - 连接条件
- en: When developing web application we will require more than one table in our queries
    for most of the time, this is because we just need to pull a lot of data from
    everywhere to get the results we need. One way of doing this is by using join
    conditions in our `select` statement.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发Web应用程序时，我们大多数时候需要查询多个表，这是因为我们只需要从各个地方拉取大量数据以获取所需的结果。实现这一目标的一种方法是在我们的 `select`
    语句中使用连接条件。
- en: 'Let''s just take a look at the following table composition, we are going in
    our virtual environment:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下表组成，我们正在我们的虚拟环境中进行：
- en: 'The `people` table will have the following columns:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`people` 表将包含以下列：'
- en: '`Id` (primary key)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Id`（主键）'
- en: '`First_name`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`First_name`'
- en: '`Last_name`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Last_name`'
- en: '`Age`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Age`'
- en: '`Gender`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gender`'
- en: '`Address_Id` (foreign key to `addresses` table)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Address_Id`（`addresses` 表的外键）'
- en: 'The `addresses` table will have the following columns:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`addresses` 表将包含以下列：'
- en: '`Id` (primary key)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Id`（主键）'
- en: '`Street`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Street`'
- en: '`Number`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number`'
- en: '`Postcode`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Postcode`'
- en: '`City`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`City`'
- en: '`Country`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Country`'
- en: What we want to achieve here is to retrieve the address that belongs to a person
    and show that in our result.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要实现的是检索属于某个人的地址并在我们的结果中显示它。
- en: 'Let''s look at an example (`/module/Application/src/Application/Controller/IndexController.php`)
    of how we could achieve that in the best possible way:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子（`/module/Application/src/Application/Controller/IndexController.php`），看看我们如何以最佳方式实现这一点：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is how simple it is to create a `join` condition on a `select` statement.
    Piece of pie!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 `select` 语句上创建一个 `join` 条件竟然如此简单。易如反掌！
- en: How it works…
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In Zend Framework 2 they have separated all the actions such as `Insert`, `DropTable`,
    `Update`, `Delete`, and `Where` into classes of their own, which makes it very
    reusable for developers. The great thing about it is that it also makes the code
    much clearer.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Zend Framework 2中，他们将所有操作如`Insert`、`DropTable`、`Update`、`Delete`和`Where`都分离到它们自己的类中，这使得它们对开发者来说非常可重用。它的好处在于它还使代码更加清晰。
- en: '`TableGatewayInterface` defines a minimum selection of methods that are implemented
    by `AbstractTableGateway` and also `TableGateway`, as that extends from `AbstractTableGateway`
    in the first place. `TableGateway`, for short, implements most common features
    needed to do table operations.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`TableGatewayInterface` 定义了由 `AbstractTableGateway` 和 `TableGateway` 实现的最小方法集合，因为
    `TableGateway` 首先是从 `AbstractTableGateway` 扩展而来的。简而言之，`TableGateway` 实现了进行表操作所需的大部分常见功能。'
- en: 'The `TableGatewayInterface`, therefore, defines the following methods:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`TableGatewayInterface` 定义了以下方法：
- en: '`getTable()`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getTable()`'
- en: '`select($where = null)`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select($where = null)`'
- en: '`insert($set)`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert($set)`'
- en: '`update($set, $where = null)`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update($set, $where = null)`'
- en: '`delete($where)`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete($where)`'
- en: Optimizating with a DB profiler
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DB分析器进行优化
- en: One of the most common bottlenecks in an application is the querying to the
    database, as sometimes we just don't know how much is being queried, or we can't
    find out why something is going wrong. This recipe provides us with the tools
    to find even the smallest query used.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，最常见的瓶颈之一是对数据库的查询，因为有时我们根本不知道查询了多少，或者我们无法找出为什么某些事情出了问题。这个配方为我们提供了找到甚至是最小查询的工具。
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A database profiler is used to find bottlenecks in query performance and is
    a great tool to debug the queries that are executed in a session and of course
    the time it takes for them to execute. Once we develop bigger applications we
    tend to forget when and how certain pieces of code execute, which sometimes can
    lead to unnecessary complexity in our code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库分析器用于查找查询性能的瓶颈，是调试会话中执行的查询以及它们执行所需时间的优秀工具。一旦我们开发了更大的应用程序，我们往往会忘记某些代码何时以及如何执行，这有时会导致我们的代码出现不必要的复杂性。
- en: How to do it…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Profiling an application's database usage can give a clear overview on the performance
    of our application, in this recipe we will discuss how to set up a simple profiler.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 分析应用程序的数据库使用情况可以清楚地了解应用程序的性能，在这个配方中，我们将讨论如何设置一个简单的分析器。
- en: Setting up a new profiler
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置新的分析器
- en: 'Setting up a new profiler is really easy as at the moment there is only one
    class in Zend Framework 2 that can be used as a profiler. This class is called
    `Zend\Db\Adapter\Profiler\Profiler` and can be instantiated right away. Let''s
    take a look at the following snippet:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个新的分析器非常简单，因为目前只有Zend Framework 2中的一个类可以用作分析器。这个类被称为`Zend\Db\Adapter\Profiler\Profiler`，可以立即实例化。让我们看一下以下代码片段：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'That''s it; this is basically all that is needed to start profiling everything
    from the database. The only thing that is left to do for us is to get the profiles
    back whenever we are done with querying (or whenever we need it really). Let''s
    consider the following example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些；这基本上是开始从数据库中分析一切所需的所有内容。我们剩下要做的只是在我们完成查询（或真正需要时）获取配置文件。让我们考虑以下示例：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `$result` variable will now be filled with the statistical information
    about the statements executed. This result could look similar to the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`$result`变量现在将填充关于执行语句的统计信息。这个结果可能看起来像以下这样：'
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The database profiler is first being attached to the database adapter, making
    the adapter aware of the existence of the profiler. The adapter will start profiling
    (it does this by using the `Profiler::profileStart()` method) the statement every
    time it executes a statement, making sure that everything important will be logged
    about the statement.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库分析器首先被附加到数据库适配器上，使适配器意识到分析器的存在。适配器将在每次执行语句时开始分析（它通过使用`Profiler::profileStart()`方法来完成），确保关于语句的所有重要信息都将被记录。
- en: When the database adapter has finished executing the statement, it will let
    the profiler know that the statement is done (it will execute the `Profiler::profileFinish()`
    method).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库适配器完成语句的执行后，它将通知分析器该语句已完成（它将执行`Profiler::profileFinish()`方法）。
- en: As we can see from the previous example we can view the SQL statement executed
    and also the parameters used. After that the start time, end time, and time elapsed
    are also added so that we can spot any potential bottlenecks in the code easily.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从之前的示例中可以看到，我们可以查看执行的SQL语句以及使用的参数。之后，还会添加开始时间、结束时间和耗时，这样我们就可以轻松地发现代码中的任何潜在瓶颈。
- en: All in all this is very useful tool that requires almost nothing in code to
    work, and is still efficient for developers who want to find faults in their databases'
    performance.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这是一个非常实用的工具，几乎不需要编写任何代码就能工作，并且对于想要找出数据库性能问题的开发者来说仍然非常高效。
- en: There's more…
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: Another great little tool we can take a look at is the Zend Developer Tools,
    which is a module made by Zend that fits in Zend Framework 2 that provides very
    useful debugging tools. If we want to know more, we can find the tools at [https://github.com/zendframework/ZendDeveloperTools](https://github.com/zendframework/ZendDeveloperTools).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们可以查看的出色的小工具是Zend开发者工具，这是一个由Zend制作的模块，适用于Zend Framework 2，提供了非常有用的调试工具。如果我们想了解更多，我们可以在[https://github.com/zendframework/ZendDeveloperTools](https://github.com/zendframework/ZendDeveloperTools)找到这些工具。
- en: Creating a Database Access Object
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库访问对象
- en: Although we can use a dozen different methods to standardize our database functionality,
    a Database Access Object (or DAO) can be used efficiently to achieve this. This
    recipe is a working example of how to make your own, and begin organizing your
    functionality.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以使用十几种不同的方法来标准化我们的数据库功能，但数据库访问对象（或DAO）可以有效地用来实现这一点。这个示例是一个如何制作自己的示例，并开始组织你的功能的实际应用。
- en: Getting ready
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Database Access Object (from now on DAO) is used to simplify functionality to
    and from our database(s). The idea behind a DAO is to create mapping classes that
    have a single responsibility on their functionality. This means that, for example,
    we have a table called `cards`, which also has a mapping called `Cards`. This
    `Cards` mapping will then contain all the functionality we need to use in that
    table.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库访问对象（以下简称DAO）用于简化与我们的数据库之间的功能。DAO背后的想法是创建具有单一功能责任的映射类。这意味着，例如，我们有一个名为`cards`的表，它还有一个名为`Cards`的映射。这个`Cards`映射将包含我们在该表中需要使用的所有功能。
- en: This could include, for example, the CRUD (Create, Read, Update, and Delete)
    functionality, but also more complex methods such as calculations. The idea behind
    a mapping class is that we are able to hide the layout of the database and provide
    an interface for the rest of the application, which is reliable and consistent
    without the application needing to know how the database is structured.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能包括，例如，CRUD（创建、读取、更新和删除）功能，也可能包括更复杂的方法，如计算。映射类的理念是我们能够隐藏数据库布局，并为应用程序的其余部分提供一个可靠且一致的接口，而应用程序无需了解数据库的结构。
- en: 'For the recipe we will use the database layout that has a table called `cards`,
    with the following columns:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于配方，我们将使用具有名为`cards`的表的数据库布局，以下列出了以下列：
- en: '`id` (primary key)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id` (主键)'
- en: '`color`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`'
- en: '`value`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`'
- en: '`type`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`'
- en: How to do it…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: A DAO is a great way of organizing our database functionality in the application,
    so that we will always have a clear structure of our logic. In this recipe, we'll
    show how to make one of our own.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: DAO是一种在应用程序中组织数据库功能的好方法，这样我们就可以始终有一个清晰的逻辑结构。在这个配方中，我们将展示如何创建自己的DAO。
- en: Creating our new module and configuration
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建我们的新模块和配置
- en: 'Our DAO is going be in a completely separate module, as that is the best way
    of separating the different pieces of code. So, we go ahead to create a new module
    DAO, which should have the following directory structure:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的DAO将完全独立于另一个模块，因为这是分离不同代码片段的最佳方式。因此，我们继续创建一个新的模块DAO，它应该具有以下目录结构：
- en: '[PRE26]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once we have created the necessary folders, we can copy the default `Module.php`
    from the `Application` module over to our `DAO` folder. We then open our new `Module.php`,
    and make sure the `namespace` is set to `DAO` as well.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了必要的文件夹，我们可以将`Application`模块中的默认`Module.php`复制到我们的`DAO`文件夹中。然后我们打开我们新的`Module.php`，确保`namespace`设置为`DAO`。
- en: 'Now, it is time to create a new `/module/DAO/config/module.config.php` file
    and add the following lines:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建一个新的`/module/DAO/config/module.config.php`文件，并添加以下行：
- en: '[PRE27]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This pretty basic configuration will be used by our database connector later
    on to get the connection details from.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相当基本的配置将被我们的数据库连接器稍后用于获取连接详情。
- en: Creating a connector
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个连接器
- en: Next, we want to create our connector, which is basically a class that will
    create a database adapter and set everything up for us. It will not do anything
    else than that, so we should be able to code one easily.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要创建我们的连接器，它基本上是一个类，将创建数据库适配器并为我们设置一切。它不会做其他任何事情，所以我们应该能够轻松地编写一个。
- en: 'Let''s now create a file called `/module/DAO/src/DAO/db/Connection/Connector.php`
    in the `DAO\Db\Connection` `namespace` and add the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在创建一个名为`/module/DAO/src/DAO/db/Connection/Connector.php`的文件，在`DAO\Db\Connection`命名空间中，并添加以下代码：
- en: '[PRE28]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That is it for the class definition; we are now able to initialize the connection
    if we have the right items available in our configuration. If not, the method
    will throw an exception and let us know anyway.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是类的定义；我们现在能够初始化连接，如果我们配置中有正确的项目。如果没有，该方法将抛出异常并让我们知道。
- en: Creating a mapper interface
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个映射器接口
- en: We want to create a mapper interface now on which we will base all our future
    mapper classes. We do this because we want to make sure that all our mapper classes
    contain at least some of the methods we want. Our mapper interface will, therefore,
    define a small selection of methods we want our mapper classes to have.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要创建一个映射器接口，我们将基于它创建所有未来的映射器类。我们这样做是因为我们想要确保所有映射器类都包含我们想要的至少一些方法。因此，我们的映射器接口将定义我们希望映射器类拥有的方法的小集合。
- en: 'Now, let''s create file called `/module/DAO/src/DAO/Db/Mapper/MapperInterface.php`
    in the `DAO\Db\Mapper` `namespace` and add the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`DAO\Db\Mapper`命名空间中创建一个名为`/module/DAO/src/DAO/Db/Mapper/MapperInterface.php`的文件，并添加以下代码：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As we see this is a pretty straightforward file as interfaces don't actually
    do any implementation of the code at all.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这是一个相当直接的文件，因为接口实际上并没有对代码进行任何实现。
- en: Creating an abstract mapper class
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个抽象映射器类
- en: 'Although the interface doesn''t implement any of the code, an abstract class
    can. We want to create a file called `/module/DAO/src/DAO/Db/Mapper/MapperAbstract.php`
    in the same `DAO\Db\Mapper` `namespace`, which will contain a method that will
    create a connection to the database, point to the right table, and return a freshly
    baked `Zend\Db\Sql\Sql` object:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Everything set up, now let''s create the method we need for our connection
    (don''t forget to create `setServiceLocator` and `getServiceLocator` methods as
    well!):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our freshly created connection method can now be used by mappers to get a `Zend\Db\Sql\Sql`
    object, which is relevant to the table they want to work in.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Data Transfer Object
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s create a new **Data Transfer** **Object** (**DTO**) file called
    `/module/DAO/src/DAO/Db/DTO/Cards.php` in the `DAO\Db\DTO` `namespace` and add
    the following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that we have set our private properties, we will also create some basic
    getters and setters for them. Use the following code for getters:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The getters are now done, which was pretty easy, now let''s do the setters:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The setters were obviously a little more complicated as we also wanted to make
    sure the data we put in is valid for our database. This way we can safely parse
    object to the mapper later on and be sure that everything will go all right.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create the last method which is a construct so that we can easily set
    the properties without needing to do that manually afterwards:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We now created a simple DTO which we can use to communicate to some methods
    in our mapper. Now, last but not least let's create the mapper class!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Creating a mapper class
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mapper will be the main DAO class that we will use in the application because
    it will be the class that has the methods for `insert`, `getAll`, and so on.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a `/module/DAO/src/DAO/Db/Mapper/Cards.php` file in
    the `DAO\Db\Mapper` `namespace` and add the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s create a method for deleting a row first:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We have created a simple `delete` method, now let''s continue and create our
    `getAll` method, which will retrieve all the records in the database:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After we have created our `getAll`, which returns an array with Cards DTO''s
    we will now create the method to insert a record:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, let''s continue to our `load` method, which will return only one record:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We now created the `load` method, which will return a Cards DTO object for
    us to use, now last but not least the `update` method:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We have now successfully created a mapper class and that also concludes our
    DAO. We can now easily get the mapper through the service manager in (for example)
    a controller (`/module/Cards/src/Cards/Controller/CardController.php`) by using
    the following code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And, because we created an abstract and interface it is really easy for us to
    create new mappers as well. Obviously it requires us to be consistent, but that
    is a good thing.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: About the DAO
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A DAO or Database Access Object is a design pattern that creates an abstract
    environment for developers to access their database related methods. This means
    that we create a standardized environment for us to work in, which is not only
    consistent but also very stable. Because, we limit ourselves in our way of working
    with database queries and objects we create a piece of code which is very easy
    to work with.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: DAO（数据库访问对象）是一种设计模式，它为开发者创建了一个抽象的环境，以便他们可以访问数据库相关的方法。这意味着我们创建了一个标准化的工作环境，它不仅一致，而且非常稳定。因为，我们在处理数据库查询和创建的对象的方式上限制了自己，所以我们创建了一段非常容易工作的代码。
- en: In this recipe, we created a very simple DAO, which (to my personal opinion)
    is a good basis, but probably not the most efficient way of creating one. We just
    took one example how a DAO can be implemented, but we should never shut our eyes
    to the literally dozens of different ways of implementing it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们创建了一个非常简单的DAO，这在个人看来是一个很好的基础，但可能不是创建DAO最有效的方法。我们只是举了一个例子，说明DAO可以如何实现，但我们绝不应该忽视实际上有数十种不同的实现方式。
- en: About the recipe
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于食谱
- en: Because our configuration contains a mapper array with all the mapper class
    names (`DAO\Db\Mapper\Cards` becomes simply cards in the configuration) we cannot
    go wrong. This separates the local configuration of the database environment from
    the code. So if we were to change the table name to 'books' we only have to change
    the configuration and the code would still work!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的配置包含一个包含所有映射类名称的映射器数组（`DAO\Db\Mapper\Cards`在配置中简化为cards），我们不可能出错。这将数据库环境的本地配置与代码分离。因此，如果我们想将表名更改为'books'，我们只需更改配置，代码仍然可以工作！
- en: We are going to create a DTO so that we can easily insert/update and return
    records through a standardized way. So instead of returning an array in our selections
    we can then return an object which will contain everything we need. This way we
    make sure our data is filtered and simply transferrable.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个DTO（数据传输对象），这样我们就可以通过标准化的方式轻松地插入、更新并返回记录。因此，在我们的选择中，我们不再返回一个数组，而是返回一个包含我们所需一切内容的对象。这样我们确保我们的数据被过滤并且可以简单地传输。
- en: As we can see in the `insert` method in the Mapper class we assume the DTO object
    contains the right information for us to insert our record. Although this method
    is far from perfect, it is a good method of separating our checking and validating
    of the data to another object (in our case the DTO) so we can just concentrate
    on inserting the record. This separation is essential to a good working DAO.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在Mapper类中的`insert`方法中看到的，我们假设DTO对象包含我们插入记录所需的所有正确信息。尽管这个方法远非完美，但它是一种将我们的数据检查和验证分离到另一个对象（在我们的情况下是DTO）的好方法，这样我们就可以专注于插入记录。这种分离对于良好的DAO工作至关重要。
