- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Using Object-Oriented Programming in PHP
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PHP中使用面向对象编程
- en: PHP is an open source scripting programming language that has supported **Object-Oriented
    Programming** (**OOP**) features since PHP 5\. PHP is straightforward to learn,
    and it is very flexible. No wonder it’s prevalent. There are a lot of open source
    PHP learning materials available online, as well as open source libraries and
    frameworks. If you’re planning to build a web application, the chances are that
    there will be some downloadable PHP libraries and frameworks that will pretty
    much suit your needs. If you require PHP developers for your project, you’d be
    glad to know that there are indeed a lot of PHP developers out there.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: PHP是一种自PHP 5以来就支持**面向对象编程**（**OOP**）功能的开源脚本编程语言。PHP易于学习，非常灵活。难怪它如此普遍。网上有大量的开源PHP学习资料，以及开源库和框架。如果你计划构建一个Web应用程序，那么很可能会有一些可以下载的PHP库和框架，它们将基本满足你的需求。如果你需要PHP开发者来参与你的项目，你可能会很高兴地知道，实际上有很多PHP开发者。
- en: As a PHP developer, I have worked on many PHP projects ranging from tiny web
    applications to enterprise applications. I’ve seen many PHP applications developed
    by different companies and teams. Some applications I’ve seen and worked on personally
    were properly built following best practices and industry standards, but some
    were made of spaghetti mess glued together by duct tape. There’s one thing in
    common, though; it doesn’t matter if the software is well-written or poorly written;
    successful software will require updates. New features and bug fixes will be required.
    The more successful the software gets, the more users utilize the software, the
    more feature requests get submitted, and the more bugs get discovered. It’s a
    cycle, but it’s a great problem to have to begin with.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名PHP开发者，我参与了许多PHP项目，从小型Web应用程序到企业应用程序都有。我见过许多不同公司和团队开发的PHP应用程序。我亲眼所见并参与的一些应用程序是按照最佳实践和行业标准正确构建的，但也有一些是由胶带粘合在一起的意大利面式的混乱。尽管如此，有一点是共同的；软件写得是否好并不重要；成功的软件将需要更新。新的特性和错误修复将需要。软件越成功，用户使用软件的越多，提交的功能请求就越多，发现的错误就越多。这是一个循环，但一开始就有一个很好的问题。
- en: No one wants to see regressions introduced by new features and bug fixes, but
    it happens. And sometimes, if there are no proper development or release processes
    involved, regressions happen a lot. New bugs and problems can be introduced after
    a release, and this is very demoralizing. The business also loses its confidence
    in releasing more bug fixes or new features. For the developers and the business,
    releasing codes should be a positive experience, not a cause for anxiety.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人希望看到由新特性和错误修复引入的回归，但这种情况确实会发生。有时，如果没有适当的发展或发布流程，回归就会频繁发生。发布后可能会引入新的错误和问题，这非常令人沮丧。企业也会失去发布更多错误修复或新特性的信心。对于开发者和企业来说，发布代码应该是一种积极的体验，而不是焦虑的原因。
- en: Using OOP and **Test-Driven Development** (**TDD**) together helps to improve
    code quality by making sure that most of the functions and objects are testable,
    maintainable, reusable, and mockable. Mocks will be discussed more in [*Chapter
    8*](B18318_08.xhtml#_idTextAnchor121), *Using TDD with* *SOLID Principles*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 将OOP和**测试驱动开发**（**TDD**）结合使用，通过确保大多数函数和对象是可测试的、可维护的、可重用的和可模拟的，有助于提高代码质量。模拟将在[*第8章*](B18318_08.xhtml#_idTextAnchor121)中更详细地讨论，即*使用TDD与SOLID原则*。
- en: 'In this chapter, we’ll go through the definition and meaning of OOP in PHP.
    We’ll go through the Four Pillars of OOP: abstraction, encapsulation, inheritance,
    and polymorphism. We will try to use example codes to explain the OOP concepts,
    and these concepts will serve as the foundations for the TDD codes we will be
    writing for our example project later.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨PHP中面向对象编程的定义和意义。我们将介绍面向对象编程的四大支柱：抽象、封装、继承和多态。我们将尝试使用示例代码来解释面向对象的概念，这些概念将作为我们稍后为示例项目编写的测试驱动开发代码的基础。
- en: 'In this chapter, we will be going through the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Understanding OOP in PHP
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解PHP中的面向对象编程
- en: Classes versus objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类与对象
- en: Abstraction in OOP
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程中的抽象
- en: Encapsulation in OOP
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程中的封装
- en: Inheritance in OOP
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程中的继承
- en: Polymorphism in OOP
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程中的多态
- en: '**PHP Standards** **Recommendations** (**PSRs**)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PHP标准** **建议**（**PSRs**）'
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The user is expected to have at least basic knowledge of PHP or other OOP languages
    such as Java or C#. I’m also using the PHPStorm **Integrated Development Environment**
    (**IDE**) throughout the book, which can be seen in the screenshots.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应至少具备PHP或其他面向对象编程语言（如Java或C#）的基本知识。我在整本书中都在使用PHPStorm **集成开发环境**（**IDE**），这可以在截图里看到。
- en: Understanding OOP in PHP
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PHP中理解面向对象编程
- en: Can I use PHP with TDD? Absolutely – and PHP, thanks to its OOP capabilities,
    works well with TDD. We have previously explained that TDD is a process; it’s
    not a piece of software that you can install. You can install or download tools
    to implement TDD, and there are a lot of different tools available for other programming
    languages as well.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用PHP进行测试驱动开发（TDD）吗？当然可以——而且得益于PHP的面向对象能力，它与TDD配合得很好。我们之前已经解释过，TDD是一个过程；它不是你可以安装的软件。你可以安装或下载工具来实现TDD，而且对于其他编程语言也有许多不同的工具可用。
- en: Since PHP 5 was released in the early 2000s, classes and objects were supported,
    allowing OOP to be used for PHP. It would be an advantage if the reader has a
    good understanding of OOP and has worked on PHP OOP projects, but if not, I’ll
    do my best to introduce OOP to you, as it is an effective and efficient way to
    write software. We will also be using OOP in our example project, so we need to
    make sure that the reader understands OOP.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 自从2000年代初PHP 5发布以来，类和对象得到了支持，使得OOP可以在PHP中使用。如果读者对OOP有很好的理解并且参与过PHP面向对象编程项目，这将是一个优势；如果没有，我会尽我所能向您介绍OOP，因为它是一种编写软件的有效且高效的方法。我们还将使用OOP在我们的示例项目中，因此我们需要确保读者理解OOP。
- en: What is OOP, anyway?
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）究竟是什么呢？
- en: OOP is a programming style based on the concept of classes and objects. One
    of its goals is to let software developers write reusable and extensible codes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）是一种基于类和对象概念的编程风格。其目标之一是让软件开发者能够编写可重用和可扩展的代码。
- en: OOP focuses on packaging behaviors, logic, and properties into reusable objects.
    These objects are instances of classes, and these classes are the files that we
    software developers have to write to contain logic, routines, and properties.
    Since objects are based on classes, we can create many instances of objects using
    a single class. We can also use OOP’s inheritance feature to create an object
    that will also have the capabilities of its parent. Later in this chapter, we
    will discuss the difference between a class and an object in OOP.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）侧重于将行为、逻辑和属性打包成可重用的对象。这些对象是类的实例，而这些类是我们软件开发者必须编写的文件，用于包含逻辑、例程和属性。由于对象基于类，我们可以使用单个类创建许多对象的实例。我们还可以使用面向对象编程的继承特性来创建一个具有其父类能力的对象。在本章的后面部分，我们将讨论面向对象编程中类和对象之间的区别。
- en: Back when I was a junior developer, my friend, who was a JavaScript developer,
    told me that he struggled to understand OOP because he had read some OOP explanations
    that used vehicle and animal metaphors. He said he didn’t understand how it related
    to the actual software he was writing, so for the sake of our younger selves,
    if I ever travel back in time, I’ll try to explain OOP to junior developers such
    as myself and my friend as if I had never used OOP before. I realized that, at
    least for me, if I understand the problem and the purpose of a solution, I can
    understand the concept easier.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我还是初级开发者的时候，我的一个朋友，他是JavaScript开发者，曾经告诉我，他很难理解面向对象编程（OOP），因为他读过一些使用车辆和动物比喻的OOP解释。他说他不知道这些如何与他自己正在编写的实际软件相关联，所以为了我们年轻的自己，如果我有机会回到过去，我会尝试像从未使用过OOP一样向像我朋友和我这样的初级开发者解释OOP。我意识到，至少对我来说，如果我理解了问题和解决方案的目的，我就能更容易地理解概念。
- en: I’ve seen many developers struggle with this concept and fail to take advantage
    of its incredible power. I learned OOP back in university while using Java and
    C++ and when I worked professionally as a C# developer after graduating. Back
    then, I thought OOP was everywhere and was the usual way of writing code in the
    professional software development world, but when I started my first professional
    PHP position, I worked on a PHP application with no OOP codes in the code base.
    With PHP, a developer can create a PHP file and start writing functions and codes
    directly executed from a CLI or a web browser. It’s so easy! However, it’s a slippery
    slope.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到许多开发者在这个概念上挣扎，并未能充分利用其惊人的力量。我在大学时使用Java和C++学习OOP，并在毕业后作为C#开发者专业工作。当时，我认为OOP无处不在，是专业软件开发世界中编写代码的通常方式，但当我开始我的第一个专业PHP职位时，我在一个没有OOP代码的PHP应用程序上工作。使用PHP，开发者可以创建一个PHP文件，并直接从CLI或网页浏览器中执行函数和代码。这太容易了！然而，这是一个滑梯。
- en: I remember telling myself, “I hate OOP, and it’s so complicated; why did I waste
    my time with OOP in Java and C# when I have to write so much code just to return
    text on a web page?” Sure enough, I ended up writing many files with lots of database
    queries and lots of business logic intertwined. I basically wrote the user interface,
    business logic, and persistence codes in a single file. Does that sound familiar?
    If you’re one of the poor souls who may have inherited my spaghetti codes from
    more than a decade ago, I sincerely apologize. I wrote spaghetti codes with OOP
    and without OOP in different languages. OOP is not a magic bullet solution to
    stop messy spaghetti codes, but OOP surely does help. It’s not the tool; it’s
    how you use it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得自己对自己说：“我讨厌OOP，它太复杂了；为什么我要在Java和C#中浪费时间学习OOP，而只是为了在网页上返回文本就要写这么多代码？”果然，我最终写了很多文件，里面有很多数据库查询和很多交织在一起的业务逻辑。我基本上在一个文件中写了用户界面、业务逻辑和持久化代码。这听起来熟悉吗？如果你是那些可能从我十多年前继承下来的糟糕代码的人之一，我真诚地道歉。我用OOP和没有OOP在不同的语言中写了意大利面式的代码。OOP并不是停止混乱的意大利面式代码的万能子弹，但OOP确实有帮助。它不是工具；而是你如何使用它。
- en: The excitement I felt did not last very long. As a junior PHP developer back
    then, I ended up writing so many PHP files with so many random functions. It was
    a nightmare to maintain, and I couldn’t even reuse my own codes elsewhere in the
    application! I told myself that if I only had used OOP, I could at least borrow
    or reuse some existing codes easily even if I had spaghetti codes. Now, imagine
    working with a team where you collectively build software and you cannot easily
    reuse each other’s codes. I then hated PHP, but as it turned out, I was not using
    PHP properly. I did not know that I could use PHP to implement OOP as well. I
    think the same thing can be said of any other programming language. It doesn’t
    matter how good the language is; the project’s success depends on the software
    engineers, developers, and architects themselves. You can use OOP in any language
    and still produce spaghetti codes. In this book, we will use TDD and software
    development best practices to help us write better and less tangled code. We will
    be talking about some software development principles that will help us a lot
    in writing better code in [*Chapter 8*](B18318_08.xhtml#_idTextAnchor121), *Using
    TDD with SOLID Principles.*
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我感到的兴奋并没有持续很长时间。当时作为一个初级PHP开发者，我写了如此多的PHP文件，里面充满了随机的函数。维护起来是一场噩梦，我甚至无法在其他地方重用我自己的代码！我告诉自己，如果我当时只使用了OOP，至少可以轻松地借用或重用一些现有的代码，即使我有意大利面式的代码。现在，想象一下在一个团队中共同构建软件，你无法轻松地重用彼此的代码。我当时讨厌PHP，但结果证明，我没有正确地使用PHP。我不知道我可以用PHP来实现OOP。我认为任何其他编程语言也是如此。语言的好坏并不重要；项目的成功取决于软件工程师、开发人员和架构师自己。你可以在任何语言中使用OOP，仍然会产生意大利面式的代码。在这本书中，我们将使用TDD和软件开发最佳实践来帮助我们写出更好、更不混乱的代码。我们将讨论一些软件开发原则，这些原则将极大地帮助我们写出更好的代码，在[*第8章*](B18318_08.xhtml#_idTextAnchor121)中，我们将讨论*使用TDD与SOLID原则*。
- en: It took me a while before I truly understood the real benefits of OOP. Reading
    OOP explanations with vehicles and animals online are helpful but working on projects
    and experiencing the pains of not using OOP is what really helped me see the light.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在真正理解面向对象编程（OOP）的真正好处之前，我花了一些时间。在网上阅读有关车辆和动物的OOP解释是有帮助的，但真正帮助我明白其中的奥妙的是在实际项目中工作，并体验不使用OOP的痛苦。
- en: With OOP, a developer can write codes that can be easily borrowed or used by
    other developers, including yourself.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OOP，开发者可以写出其他开发者（包括你自己）可以轻松借用或使用的代码。
- en: In the coming sections, we’ll go through the fundamental concepts of OOP – abstraction,
    encapsulation, inheritance, and polymorphism – but before that, we will need to
    start to define what a class and an object are, as well as their differences and
    how to distinguish them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍面向对象编程的基本概念 – 抽象、封装、继承和多态 – 但在那之前，我们需要开始定义类和对象是什么，以及它们的区别以及如何区分它们。
- en: In the following examples, we will not be using TDD yet. We will just be focusing
    on OOP itself. We will be focusing on the PHP-specific implementation of OOP.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们不会使用 TDD。我们将只关注面向对象编程本身。我们将关注 PHP 面向对象编程的具体实现。
- en: Classes versus objects
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类与对象
- en: A PHP class is a file that contains codes. Your class is a file that physically
    exists on your drive. If you turn your computer off and turn it on again, the
    class file is still there. The code it contains is a template to create an object
    during execution. The class file can contain properties and behaviors. The properties
    will be able to hold data in memory once the class has been instantiated. The
    behaviors will be handled by methods or functions. You can use the accessors and
    mutator methods to change the values of a class’s properties.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 类是一个包含代码的文件。你的类是一个实际存在于你的驱动器上的文件。如果你关闭计算机并重新启动它，类文件仍然在那里。它包含的代码是在执行期间创建对象的模板。类文件可以包含属性和行为。一旦类被实例化，属性将能够在内存中保存数据。行为将由方法或函数处理。你可以使用访问器和修改器方法来更改类的属性值。
- en: Dog.php class file
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Dog.php 类文件
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding example class is a PHP file containing the namespace declaration,
    the class name, and a single method or function called `returnSound()`, which
    returns a `"``Bark"` string.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例类是一个包含命名空间声明、类名和单个方法或函数 `returnSound()` 的 PHP 文件，该方法返回一个 `"Bark"` 字符串。
- en: On the other hand, an object is an instance of a class file. The object physically
    exists in the computer’s RAM, which is volatile memory. That means if you turn
    off your computer or stop the program, you lose the object. The object will only
    be created if you run your program.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对象是类文件的实例。对象在计算机的 RAM 中物理存在，RAM 是易失性内存。这意味着如果你关闭计算机或停止程序，你会丢失对象。只有当你运行程序时，对象才会被创建。
- en: In PHP, when you execute your program, the class file will be loaded by PHP
    from your hard disk to create an instance of an object that will temporarily exist
    in your RAM. The class literally is the template for PHP to create the object
    while your program is running.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 中，当你执行程序时，类文件将从你的硬盘加载到 PHP，以创建一个临时存在于你的 RAM 中的对象实例。类实际上是 PHP 在程序运行时创建对象的模板。
- en: 'We’ll use a consumer class that will utilize or consume the `Dog.php` class,
    and use a variable to hold an instance of a class, which is an object:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个消费者类来利用或消费 `Dog.php` 类，并使用一个变量来保存类的实例，即一个对象：
- en: Display.php Class File
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Display.php 类文件
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Display` class is another class; you can think of this as a consumer class
    or the starting point of the example program. In this class, we have an `outputSound()`
    method that echoes the value from the object’s `returnSound()` method. Inside
    the `outputSound()` method, we have written instructions for PHP to create an
    instance of the `Dog` class using the `new` keyword:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Display` 类是另一个类；你可以将其视为消费者类或示例程序的起点。在这个类中，我们有一个 `outputSound()` 方法，它回显对象 `returnSound()`
    方法的值。在 `outputSound()` 方法内部，我们为 PHP 编写了使用 `new` 关键字创建 `Dog` 类实例的指令：'
- en: '![Figure 4.1 – Assigning the Dog object to the $dog variable](img/Figure_4.01_B18318.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 将 Dog 对象分配给 $dog 变量](img/Figure_4.01_B18318.jpg)'
- en: Figure 4.1 – Assigning the Dog object to the $dog variable
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 将 Dog 对象分配给 $dog 变量
- en: When PHP executes the `outputSound()` method, it will create an object that
    is based on the `Dog.php` class file that is stored in your computer’s drive and
    then it will temporarily store the instance or object inside your computer’s memory.
    The `$dog` variable will be mapped with the `Dog` class instance or object. Whenever
    you use an object’s method or properties, you are basically accessing the object
    from your computer’s memory, and not from the `Dog.php` class file. To understand
    this further, we will need to talk about *References* in PHP, which we will cover
    in the next subsection.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当 PHP 执行 `outputSound()` 方法时，它将在您的计算机驱动器中创建一个基于存储在您的计算机驱动器中的 `Dog.php` 类文件的对象，然后它将在您的计算机内存中临时存储该实例或对象。`$dog`
    变量将与 `Dog` 类实例或对象映射。每次您使用对象的方法或属性时，您实际上是在从您的计算机内存中访问对象，而不是从 `Dog.php` 类文件中。为了进一步理解这一点，我们需要讨论
    PHP 中的 *引用*，这将在下一个子节中介绍。
- en: 'Now, since we have created a new instance of the `Dog.php` class file and assigned
    it to the `$dog` variable, we will be able to access the `Dog` object’s methods
    or functions, or properties, depending on their *visibility*. We will talk about
    visibility in this chapter in the *Encapsulation in OOP* section. Since in our
    example, we have defined the `Dog.php` class’s `returnSound()` method as `public`,
    we can now access this method from the `Display.php` class’s `outputSound()` method
    with the following: `$dog->returnSound();`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们已经创建了一个新的 `Dog.php` 类实例并将其赋值给 `$dog` 变量，我们将能够访问 `Dog` 对象的方法或函数，或者属性，这取决于它们的
    *可见性*。我们将在本章的 *面向对象编程中的封装* 部分讨论可见性。由于在我们的示例中，我们将 `Dog.php` 类的 `returnSound()`
    方法定义为 `public`，我们现在可以通过以下方式从 `Display.php` 类的 `outputSound()` 方法访问此方法：`$dog->returnSound();`。
- en: References and objects in PHP
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP 中的引用和对象
- en: What is a reference anyway? Well, in PHP, it’s an alias or a way for one or
    more variables to point to specific content. From the `Dog` object example earlier,
    we have created an instance of the `Dog.php` class and assigned it to the `$dog`
    variable. The `$dog` variable itself does not really contain the `Dog` object
    or instance’s memory address; it simply contains an identifier so that it can
    point to the `Dog` object that is stored in the memory. That means that you can
    have `$dog1` and `$dog2` variables that point to the same object. Let’s modify
    the `Dog.php` and `Display.php` classes to demonstrate the concept.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，引用究竟是什么呢？好吧，在 PHP 中，它是一个别名或一种方式，允许一个或多个变量指向特定的内容。从之前的 `Dog` 对象示例中，我们已经创建了一个
    `Dog.php` 类的实例并将其赋值给 `$dog` 变量。`$dog` 变量本身并不真正包含 `Dog` 对象或实例的内存地址；它仅仅包含一个标识符，以便它可以指向存储在内存中的
    `Dog` 对象。这意味着您可以有指向同一对象的 `$dog1` 和 `$dog2` 变量。让我们修改 `Dog.php` 和 `Display.php`
    类来演示这个概念。
- en: 'We will modify the `Dog.php` class like so:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按如下方式修改 `Dog.php` 类：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And we’ll modify the `Display.php` class as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按如下方式修改 `Display.php` 类：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We’ve modified the `Dog.php` class so that we can change the sound it returns
    after we instantiate it. In the `Display.php` class, you’ll notice that we have
    introduced a new variable, `$dog2`, and assigned `$dog1` to it. We only have one
    instance of the `Dog` object, and both the `$dog1` and `$dog2` variables have
    the same identifier and are referencing the same thing. Here’s a diagram representing
    this concept:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经修改了 `Dog.php` 类，以便我们可以在实例化后更改它返回的声音。在 `Display.php` 类中，您会注意到我们引入了一个新的变量
    `$dog2`，并将其赋值给 `$dog1`。我们只有一个 `Dog` 对象的实例，而 `$dog1` 和 `$dog2` 变量具有相同的标识符，并且它们引用的是同一事物。以下是表示这个概念的图示：
- en: '![Figure 4.2 – What happens to $dog1’s property also happens to $dog2](img/Figure_4.02_B18318.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – `$dog1` 的属性发生的变化也会影响到 `$dog2`](img/Figure_4.02_B18318.jpg)'
- en: Figure 4.2 – What happens to $dog1’s property also happens to $dog2
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – `$dog1` 的属性发生的变化也会影响到 `$dog2`
- en: So, if we run `$dog2->returnSound()`, it will return the updated string that
    we have set in `$dog1` even if we have mutated the `$sound` property after we
    have assigned `$dog1` to `$dog2`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们运行 `$dog2->returnSound()`，即使在我们将 `$dog1` 赋值给 `$dog2` 之后修改了 `$sound` 属性，它也会返回我们在
    `$dog1` 中设置的更新后的字符串。
- en: 'Well, what if you don’t want `$dog2` to be affected by what happens to `$dog1`’s
    properties, but still want to create a copy or a duplicate of that object? You
    can use PHP’s `clone` keyword like so:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果您不希望 `$dog2` 受 `$dog1` 属性变化的影响，但仍然想创建该对象的副本或复制品，您可以使用 PHP 的 `clone` 关键字，如下所示：
- en: Display.php Class
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Display.php 类
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This time, `$dog2` will return the original `Bark` string value assigned to
    the `$sound` property of `$dog1` by its constructor. Here’s a diagram for your
    reference to understand this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`$dog2` 将返回原始的 `Bark` 字符串值，这是由其构造函数分配给 `$dog1` 的 `$sound` 属性。以下是一个图表，供你参考以理解这一点：
- en: '![Figure 4.3 – Clone object](img/Figure_4.03_B18318.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 克隆对象](img/Figure_4.03_B18318.jpg)'
- en: Figure 4.3 – Clone object
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 克隆对象
- en: 'Since `$dog2` has been cloned before the actor has mutated the `$sound` property
    of `$dog1`, `$dog2` will retain the old value. Whatever happens to `$dog1` will
    no longer automatically happen to `$dog2`, as they are no longer referencing the
    same object in the memory:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在演员修改 `$dog1` 的 `$sound` 属性之前，`$dog2` 已经被克隆，所以 `$dog2` 将保留旧值。无论 `$dog1` 发生什么变化，都不会自动发生在
    `$dog2` 上，因为它们不再引用内存中的同一对象：
- en: '![Figure 4.4 – Class versus object](img/Figure_4.04_B18318.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 类与对象](img/Figure_4.04_B18318.jpg)'
- en: Figure 4.4 – Class versus object
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 类与对象
- en: In summary, a PHP class is a file that contains a template for PHP to be able
    to create an object. When the `new` keyword is used and executed, PHP takes the
    class file and generates an instance of the class file, and stores it in the computer’s
    memory, this is what we call an object.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，PHP 类是一个包含 PHP 能够创建对象的模板的文件。当使用 `new` 关键字并执行时，PHP 会取用类文件，生成类文件的实例，并将其存储在计算机的内存中，这就是我们所说的对象。
- en: Now that we have clarified and explained the difference between an object and
    a class in PHP, we can now discuss the Four Pillars of OOP, starting with abstraction.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经澄清并解释了 PHP 中对象与类之间的区别，我们可以现在讨论面向对象的四个支柱，从抽象开始。
- en: Abstraction in OOP
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程中的抽象
- en: Abstraction in OOP is the concept of hiding complexities from the application,
    user, or developers. You can take a set of complex codes or instructions and wrap
    them inside a function. That function should use a verb for its name, which will
    make it easier to understand exactly what the complex instructions inside the
    function do.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程中的抽象是隐藏复杂性的概念，从应用程序、用户或开发者那里隐藏。你可以将一组复杂的代码或指令包装在一个函数中。该函数的名称应使用动词，这将使其更容易理解函数内部复杂指令的确切作用。
- en: 'For example, you can have a function called `computeTotal($a, $b, $c)` that
    contains logic or steps to compute the total based on the requirements. As a developer,
    you can just use the `computeTotal` method and not think about all the complex
    operations that are involved in the actual computation of the total, but if you
    need to fix a bug or understand what’s going on, then you can check what’s going
    on inside that `computeTotal` function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以有一个名为 `computeTotal($a, $b, $c)` 的函数，它包含根据需求计算总和的逻辑或步骤。作为一个开发者，你只需使用 `computeTotal`
    方法，无需考虑实际计算总和所涉及的复杂操作，但如果需要修复错误或理解发生了什么，那么你可以检查 `computeTotal` 函数内部的执行情况：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What’s the benefit of using this concept? Using the preceding example, the developer
    won’t need to worry about the exact sequence of steps inside the function to get
    the total. The developer only needs to know that there is a `computeTotal` function
    available to be used, along with hundreds or thousands of other functions each
    with complex steps in instructions inside them. The developer can focus on the
    solution and not worry about the fine details inside each function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个概念有什么好处？使用前面的例子，开发者无需担心函数内部获取总和的确切步骤顺序。开发者只需要知道有一个可用的 `computeTotal` 函数可以用来，以及数百或数千个其他函数，每个函数内部都有复杂的步骤指令。开发者可以专注于解决方案，无需担心每个函数内部的细节。
- en: 'An abstract class is a way to implement class abstraction and is a type of
    class that cannot be instantiated and needs to have at least one method declared
    as abstract. An abstract class is meant to be extended by other related classes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是实现类抽象的一种方式，是一种不能实例化的类，需要至少声明一个抽象方法。抽象类旨在被其他相关类扩展：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The method declared as `abstract` in `AbstractPrinter` must also exist in the
    classes that extend this method. Each class that extends the `AbstractPrinter`
    abstract class can now have its own specific operations for the `print` method.
    A method declared as `abstract` in an abstract class can only declare the method’s
    visibility, parameters, and return value. It cannot have its own implementation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AbstractPrinter` 中声明的 `abstract` 方法也必须在扩展此方法的类中存在。现在，每个扩展 `AbstractPrinter`
    抽象类的类都可以有自己的 `print` 方法的特定操作。在抽象类中声明的 `abstract` 方法只能声明方法的可见性、参数和返回值。它不能有自己的实现。
- en: Encapsulation in OOP
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象的封装
- en: Encapsulation is a concept where data and methods that access and mutate this
    data are enclosed in a single unit like a capsule. In PHP, this capsule is the
    object or class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是一个概念，其中访问和修改此数据的数据和方法被封装在一个单一的单位，如胶囊中。在PHP中，这个胶囊是对象或类。
- en: The capsule or the object will have the ability to keep its data safe from being
    read or manipulated, using the concept of visibility.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 胶囊或对象将能够使用可见性概念来保护其数据不被读取或操作。
- en: Visibility in PHP
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP中的可见性
- en: 'To be able to control what data or functions the developer can access or use
    in an object in PHP, the `public`, `protected`, and `private` keywords can be
    prefixed before the `function` keyword in the function declaration, or before
    the property name declaration:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够在PHP中控制开发者可以访问或使用对象中的哪些数据或函数，可以在函数声明或属性名声明之前使用`public`、`protected`和`private`关键字：
- en: '`private` – Only the codes within the object can access this function or property'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private` – 只有对象内部的代码可以访问此函数或属性'
- en: '`protected` – Any object extending this class will be allowed access to the
    function or property'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected` – 任何扩展此类的对象都将允许访问该函数或属性'
- en: '`public` – Any object user is allowed to access the property or method'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public` – 任何对象用户都可以访问属性或方法'
- en: What benefits do we developers get from this, then? We’ll get to know this in
    a bit.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们开发者能从这得到什么好处呢？我们将在稍后了解这一点。
- en: 'Let’s modify the `Dog.php` class from the earlier example like so:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改前面示例中的`Dog.php`类，如下所示：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a `Cavoodle.php` class :'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`Cavoodle.php`类：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Modify the `Consumer.php` class like so:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式修改`Consumer.php`类：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this `Dog.php` example class, we have declared the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`Dog.php`示例类中，我们声明了以下内容：
- en: 'Private:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有：
- en: '`$``sound`'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$``sound`'
- en: '`$``color`'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$``color`'
- en: 'Protected:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受保护的：
- en: '`getColor()`'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getColor()`'
- en: '`setColor()`'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setColor()`'
- en: 'Public:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共：
- en: '`makeSound()`'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`makeSound()`'
- en: '`setSound($sound)`'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setSound($sound)`'
- en: By doing so, we have protected the values of the `Dog` object’s `$sound` and
    `$color` properties from being modified directly by the object consumer. Only
    the `Dog` object can modify these values directly. The value stored inside the
    `$sound` property can be modified from the object consumer side by using the `$dog->setSound($sound)`
    method, but whatever the object consumer sets in the `$dog->setSound($sound)`
    method, the data that will be stored in the `Dog` object’s `$sound` property will
    always be suffixed with the value of the `$color` property. There’s nothing the
    object consumer can do to change that; only the object itself can change its own
    property’s value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们已经保护了`Dog`对象`$sound`和`$color`属性值不被对象消费者直接修改。只有`Dog`对象可以直接修改这些值。存储在`$sound`属性中的值可以通过使用`$dog->setSound($sound)`方法从对象消费者端进行修改，但无论对象消费者在`$dog->setSound($sound)`方法中设置什么，存储在`Dog`对象`$sound`属性中的数据都将始终附加`$color`属性的值。对象消费者无法做任何事情来改变这一点；只有对象本身可以改变其自身属性值。
- en: 'The following is a screenshot of the `Consumer.php` class and as I modify it,
    my PHPStorm IDE automatically suggests the available methods for the `Cavoodle`
    object:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`Consumer.php`类的截图，当我修改它时，我的PHPStorm IDE会自动建议`Cavoodle`对象可用的方法：
- en: '![Figure 4.5 – Public functions available for Dog](img/Figure_4.05_B18318.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – Dog可用的公共函数](img/Figure_4.05_B18318.jpg)'
- en: Figure 4.5 – Public functions available for Dog
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – Dog可用的公共函数
- en: You will notice that in the `Consumer` class, there are only two available functions
    for us. The `setSound()` and `makeSound()` functions are the functions that we
    have declared as publicly visible. We have successfully limited or protected the
    `Cavoodle` (which is an instance of a `Dog` class) object’s other functions and
    properties.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在`Consumer`类中，我们只有两个可用的函数。`setSound()`和`makeSound()`函数是我们声明为公开可见的函数。我们已经成功限制了或保护了`Cavoodle`（`Dog`类的一个实例）对象的其它函数和属性。
- en: 'The following screenshot shows that as we are inside the `Cavoodle.php` class,
    my IDE automatically suggests the available methods for the `Cavoodle` class itself
    by using the `$``this` key:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示，当我们处于`Cavoodle.php`类内部时，我的IDE会通过使用`$``this`键自动建议`Cavoodle`类本身可用的方法：
- en: '![Figure 4.6 – Cavoodle itself can access more functions than the Consumer
    class](img/Figure_4.06_B18318.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – Cavoodle本身可以访问比Consumer类更多的函数](img/Figure_4.06_B18318.jpg)'
- en: Figure 4.6 – Cavoodle itself can access more functions than the Consumer class
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – Cavoodle本身可以访问比Consumer类更多的函数
- en: Inside the `Cavoodle.php` class itself, you will notice that this `Cavoodle`
    object can access the `getColor()` and `setColor()` methods. Why is that? It’s
    because the `Cavoodle` class has extended the `Dog.php` class, inheriting the
    `Dog.php` class’s non-private method – and since we have declared the `getColor`
    and `setColor` functions as having protected visibility, these methods are available
    for the `Cavoodle` class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Cavoodle.php` 类内部，你会注意到这个 `Cavoodle` 对象可以访问 `getColor()` 和 `setColor()` 方法。为什么是这样？这是因为
    `Cavoodle` 类扩展了 `Dog.php` 类，继承了 `Dog.php` 类的非私有方法——并且由于我们已将 `getColor` 和 `setColor`
    函数声明为具有受保护的可见性，这些方法对 `Cavoodle` 类是可用的。
- en: Accessors and mutators
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问器和修改器
- en: Since we have set the `$sound` and `$color` properties to `private`, how do
    we let consumers access these properties? For reading data, we can write functions
    called accessors that return the data stored in the property. To change the value
    of the property, we can create functions called mutators to mutate the data for
    the property.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将 `$sound` 和 `$color` 属性设置为 `private`，我们如何让消费者访问这些属性？对于读取数据，我们可以编写名为访问器的函数，返回存储在属性中的数据。要更改属性的值，我们可以创建名为修改器的函数来修改属性中的数据。
- en: 'To access the `$sound` and `$color` properties in the `Dog.php` class, we need
    the following *accessors*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 `Dog.php` 类中的 `$sound` 和 `$color` 属性，我们需要以下 *访问器*：
- en: '`getSound`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSound`'
- en: '`getColor`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getColor`'
- en: 'To change the values of the `$sound` and `$color` properties in the `Dog.php`
    class, we need the following *mutators*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改 `Dog.php` 类中 `$sound` 和 `$color` 属性的值，我们需要以下 *修改器*：
- en: '`setSound`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setSound`'
- en: '`setColor`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setColor`'
- en: These functions are declared in the `Dog.php` class – since these are functions,
    you can add extra validation or logic change the value before storing it into
    the property or returning it to the user.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数在 `Dog.php` 类中声明——因为这些是函数，你可以在将值存储到属性或返回给用户之前添加额外的验证或逻辑更改。
- en: When writing properties or functions, it’s a good practice to declare their
    visibility to be as restrictive as possible. Start with `private` and then if
    you think the child objects need to access the function or property, then set
    the visibility to `protected`. That way, you can end up having fewer publicly
    available methods and properties.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写属性或函数时，一个好的做法是将它们的可见性声明得尽可能严格。从 `private` 开始，然后如果你认为子对象需要访问函数或属性，则将可见性设置为
    `protected`。这样，你最终会有更少的公开方法属性。
- en: This will only allow you and the other developers that use your classes to see
    the functions that are supposed to be available to the consumers. I’ve written
    and seen classes with a lot of methods, only to find out that they are not intended
    to be used by other objects apart from the main object itself. This will also
    help preserve the data integrity of the object by preventing consumer objects
    from modifying properties directly. If you need to let the consumer manipulate
    the data stored in the property of the object, the user can use mutator methods.
    To let them read the data from the property, they can use the accessors.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只允许你和其他使用你的类的开发者看到应该对消费者可用的函数。我曾编写并看到过包含许多方法的类，但后来发现它们并不是打算由除了主对象本身之外的其他对象使用。这也有助于通过防止消费者直接修改属性来保护对象的数据完整性。如果你需要让消费者操作对象属性中存储的数据，用户可以使用修改器方法。要让他们从属性中读取数据，他们可以使用访问器。
- en: Inheritance in OOP
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程中的继承
- en: Inheritance in OOP is a concept in which an object can acquire the methods and
    properties of another object.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程中的继承是一个概念，其中一个对象可以获取另一个对象的方法和属性。
- en: Inheritance can help developers reuse functions for very related objects. You
    probably heard of the **Don’t Repeat Yourself** (**DRY**) principle; inheritance
    can help with writing less code and fewer repetitions too to help you to reuse
    codes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 继承可以帮助开发者为非常相关的对象重用函数。你可能听说过 **不要重复自己** （**DRY**）原则；继承也有助于编写更少的代码和更少的重复，以帮助你重用代码。
- en: 'Objects such as `Cavoodle` and `Dog` are related – we know that `Cavoodle`
    is a type of `Dog`. The functions available for `Dog` and `Cavoodle` should be
    focused on what `Dog` and `Cavoodle` should be able to do. If you have a `Dog`
    object and it has a `computeTax` function, for example, that function is not related
    to the `Dog` object and you’re probably doing something wrong – it has low cohesion.
    Having high cohesion means that your class is focused on doing what your class
    should really be doing. By having high cohesion, it’s easier to decide if an object
    should be an object that can be inherited, as with the `Dog` and the `Cavoodle`
    objects. It won’t make sense if the `Cavoodle` class extends a `JetEngine` class,
    but it makes perfect sense for the `Cavoodle` class to extend the `Dog` class:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cavoodle`和`Dog`这样的对象是相关的——我们知道`Cavoodle`是`Dog`的一种类型。`Dog`和`Cavoodle`可用的函数应该关注`Dog`和`Cavoodle`应该能够做什么。例如，如果您有一个`Dog`对象并且它有一个`computeTax`函数，那么这个函数与`Dog`对象无关，您可能做错了什么——它具有低内聚性。具有高内聚性意味着您的类专注于做它真正应该做的事情。通过具有高内聚性，更容易决定一个对象是否应该是一个可以继承的对象，就像`Dog`和`Cavoodle`对象一样。如果`Cavoodle`类扩展了`JetEngine`类，这就不合理了，但`Cavoodle`类扩展`Dog`类是完全合理的：'
- en: Cavoodle.php
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Cavoodle.php
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To use the `Cavoodle` class’s methods in a consumer class, create a new instance
    of the `Cavoodle` class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要在消费者类中使用`Cavoodle`类的方法，创建一个新的`Cavoodle`类实例：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Cavoodle` object has inherited the `Dog` object using the `extends` keyword.
    That means that any `public` or `protected` function from `Dog` is now available
    to the `Cavoodle` object. You will notice that there is no `makeSound` function
    declared in the `Cavoodle.php` class, but we are still able to use the `$cavoodle->makeSound();`
    method simply because the `Cavoodle` object has inherited the `makeSound` function
    from the `Dog` object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cavoodle`对象使用了`extends`关键字继承了`Dog`对象。这意味着`Dog`中的任何`public`或`protected`函数现在都对`Cavoodle`对象可用。您会注意到在`Cavoodle.php`类中没有声明`makeSound`函数，但我们仍然能够使用`$cavoodle->makeSound();`方法，仅仅是因为`Cavoodle`对象从`Dog`对象继承了`makeSound`函数。'
- en: Polymorphism in OOP
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象中的多态
- en: Polymorphism means many shapes or many forms. Polymorphism is achieved through
    the inheritance of a *PHP abstract class*, as well as by implementing *PHP interfaces*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 多态意味着许多形状或许多形式。多态是通过继承*PHP抽象类*以及实现*PHP接口*来实现的。
- en: Polymorphism helps you create a format or a standard for solving a specific
    problem programmatically, instead of just focusing on a single implementation
    of a solution.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 多态帮助您创建一个格式或标准，以编程方式解决特定问题，而不是仅仅关注解决方案的单个实现。
- en: How do we apply this in PHP and what benefit do we get in using this feature?
    Let’s take the example codes in the following subsections as an example, starting
    with a PHP abstract class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在PHP中应用这个功能以及使用这个功能我们能获得什么好处？让我们以下面的子节中的示例代码为例，从PHP抽象类开始。
- en: Polymorphism with a PHP abstract class
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP抽象类中的多态
- en: 'When using abstract classes in PHP, we can implement polymorphism by using
    abstract functions. The following example is of a PHP abstract class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中使用抽象类时，我们可以通过使用抽象函数来实现多态。以下是一个PHP抽象类的示例：
- en: AbstractAnimal.php
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: AbstractAnimal.php
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Every PHP abstract class ideally should start with the `Abstract` prefix, followed
    by the desired name of the abstract class as suggested by the PSR standards. The
    PSR standards will be discussed later in this chapter in the *PHP Standards Recommendations
    (**PSR)* section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个PHP抽象类理想情况下都应该以`Abstract`前缀开始，后面跟着根据PSR标准建议的抽象类名称。PSR标准将在本章后面的*PHP标准建议（PSR）*部分进行讨论。
- en: The abstract class needs at least one function declared as *abstract*. This
    can be achieved by adding the `abstract` keyword before the access modifier or
    visibility declaration of a function, such as `abstract public function makeSound()`.
    Now, we may notice that there is no actual action or logic inside the `makeSound()`
    method of the abstract class, and as we have explained earlier, we cannot instantiate
    abstract classes. We will need child classes to extend the abstract class, where
    we can declare the specific action or logic to be performed by that child class.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类至少需要声明一个函数作为*抽象*。这可以通过在函数的访问修饰符或可见性声明之前添加`abstract`关键字来实现，例如`abstract public
    function makeSound()`。现在，我们可能会注意到抽象类中的`makeSound()`方法没有实际的动作或逻辑，正如我们之前解释的，我们不能实例化抽象类。我们需要子类来扩展抽象类，在那里我们可以声明子类要执行的具体动作或逻辑。
- en: 'The following is an example of a child `Cat.php` class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个子`Cat.php`类的示例：
- en: Cat.php
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Cat.php
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is an example of a child `Cow.php` class:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个子`Cow.php`类的示例：
- en: Cow.php
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Cow.php
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Both of these classes have inherited the `AbstractAnimal.php` class, and since
    we have declared the `makeSound()` function as an `abstract` method, the `Cat.php`
    and `Cow.php` classes are required to have those same methods as well but without
    the `abstract` keyword. You will notice that the `Cat` object’s `makeSound` function
    returns a `meow` string, and the `Cow` object’s similar `makeSound` function returns
    a `moo` string. Here, we have achieved polymorphism by having one function signature,
    and having that function signature implemented uniquely by the child classes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类都继承了`AbstractAnimal.php`类，由于我们已经将`makeSound()`函数声明为`abstract`方法，因此`Cat.php`和`Cow.php`类也必须具有这些相同的方法，但不需要`abstract`关键字。你会注意到`Cat`对象的`makeSound`函数返回一个`meow`字符串，而`Cow`对象类似的`makeSound`函数返回一个`moo`字符串。在这里，我们通过一个函数签名实现多态，并且该函数签名由子类独特地实现。
- en: Next, we will look at implementing polymorphism using a PHP interface.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨使用PHP接口实现多态性。
- en: Polymorphism with a PHP interface
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP接口的多态
- en: A PHP interface is a simpler version of a PHP abstract class. An interface cannot
    have properties like a normal class can, and it can only contain publicly visible
    functions. Each method in an interface must be implemented by any class that uses
    the interface but without the need to add the `abstract` keyword. Therefore, we
    must be very careful when declaring functions to an interface. It’s very easy
    to end up having an interface with too many functions that it doesn’t make sense
    for each implementing class to use. This is where the *Interface Segregation Principle*
    comes in to help, and this will be discussed more in [*Chapter 8*](B18318_08.xhtml#_idTextAnchor121),
    *Using TDD with* *SOLID Principles*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: PHP接口是PHP抽象类的一个简化版本。接口不能像普通类那样有属性，它只能包含公开可见的函数。接口中的每个方法都必须由使用该接口的任何类实现，但不需要添加`abstract`关键字。因此，我们在向接口声明函数时必须非常小心。很容易最终得到一个包含太多函数的接口，这些函数对于每个实现类来说都没有意义。这就是*接口分离原则*发挥作用的地方，这将在[*第8章*](B18318_08.xhtml#_idTextAnchor121)，*使用SOLID原则进行TDD*中进一步讨论。
- en: Imagine that you need a program to return results in different formats, and
    you’d also like to be able to isolate the logic and dependencies to come up with
    the desired results. You can use an interface to set a contract that will be followed
    by your objects. For example, there are different ways and formats in which to
    return output and in the following example, we will return an XML and a JSON.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你需要一个程序以不同的格式返回结果，并且你还希望能够隔离逻辑和依赖关系，以得出所需的结果。你可以使用接口来设置一个合约，该合约将由你的对象遵循。例如，有不同方式和格式可以返回输出，在以下示例中，我们将返回XML和JSON。
- en: 'We will create a PHP interface, which will serve as a contract that both the
    JSON and XML classes will implement. The interface will have a single generic
    print function that accepts a string parameter, and returns a string:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个PHP接口，该接口将作为JSON和XML类都将实现的合约。该接口将有一个单一的通用打印函数，该函数接受一个字符串参数，并返回一个字符串：
- en: PrinterInterface.php
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: PrinterInterface.php
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will then create the first concrete implementation of `PrinterInterface`
    and it will have to have a concrete implementation of the `print` function to
    return a JSON-formatted string:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建`PrinterInterface`的第一个具体实现，它必须有一个具体的`print`函数实现，以返回一个JSON格式的字符串：
- en: Json.php
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Json.php
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The second concrete implementation of `PrinterInterface` is the `Xml` class
    – it will also have to include a `print` function that returns a string, but the
    string will be formatted as an XML this time:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrinterInterface`的第二个具体实现是`Xml`类——它也必须包含一个`print`函数，该函数返回一个字符串，但这次字符串将被格式化为XML：'
- en: Xml.php
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Xml.php
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have declared a `public print(string $message): string` method signature
    in `PrinterInterface`, and since the `Xml.php` and `Json.php` classes have implemented
    `PrinterInterface` using the `implements` keyword after the class name declaration,
    both `Xml.php` and `Json.php` are now required to follow the contract. They must
    have `public print(string $message): string` functions as well. Each implementing
    class will have its own unique way of returning an output. One returns an XML
    and the other returns a JSON – one method, and different forms or shapes. This
    is how polymorphism is achieved using PHP interfaces.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在`PrinterInterface`中声明了一个`public print(string $message): string`方法签名，并且由于`Xml.php`和`Json.php`类在类名声明后使用了`implements`关键字实现了`PrinterInterface`，因此现在`Xml.php`和`Json.php`都必须遵守这个契约。它们必须拥有`public
    print(string $message): string`函数。每个实现类都将有其自己独特的返回输出的方式。一个返回XML，另一个返回JSON——同一个方法，但不同的形式或形状。这就是使用PHP接口实现多态的方法。'
- en: 'However, what’s the advantage of using polymorphism in the first place? Let’s
    take this consumer class for example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用多态的优势在哪里呢？让我们以这个消费者类为例：
- en: Display.php
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Display.php
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the `Display.php` class, we have a `displayOutput` method that uses an object
    that must implement `PrinterInterface`. The `displayOutput` method gets the result
    from the `PrinterInterface`-implementing object (we don’t know what object that
    is) and appends it as a suffix to a string before returning it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Display.php`类中，我们有一个`displayOutput`方法，它使用必须实现`PrinterInterface`的对象。`displayOutput`方法从实现`PrinterInterface`的对象（我们不知道是哪个对象）获取结果，并将其作为后缀附加到一个字符串之前返回。
- en: Now, this is the important bit – the `Display.php` class does not know how the
    `PrinterInterface`-implementing object comes up with the actual XML or JSON formatting.
    The `Display.php` class does not care and does not worry about that. We have handballed
    the responsibility to the `PrinterInterface`-implementing object. Therefore, instead
    of having one god class that contains all of the logic for returning a JSON or
    an XML output, resulting in a spaghetti mess, we just use other objects that implement
    the interface that we need them to implement. The `Display.php` class does not
    even know what class is being used – it only knows that it is using an object
    that has implemented `PrinterInterface`. We have now successfully decoupled the
    `Display.php` class from the job of formatting XML or JSON or any other format
    to other objects.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是重要的一点——`Display.php`类并不知道实现`PrinterInterface`的对象是如何生成实际的XML或JSON格式的。`Display.php`类并不关心也不担心这一点。我们已经将责任交给了实现`PrinterInterface`的对象。因此，我们不是使用一个包含所有返回JSON或XML输出逻辑的上帝类，从而造成一团糟，而是使用其他实现我们需要的接口的对象。`Display.php`类甚至不知道正在使用哪个类——它只知道它正在使用一个实现了`PrinterInterface`的对象。我们现在已经成功地将`Display.php`类从格式化XML、JSON或其他格式的任务中解耦到其他对象。
- en: Now that we have gone through the fundamentals of OOP in PHP, let’s go through
    some guidelines or standards on how to write PHP codes. These guidelines are not
    required to build or run a PHP program, but they will help developers write better,
    more readable, and more shareable codes. The following standards on how to write
    PHP codes are important when building enterprise-level applications, especially
    as you are expected to develop codes with a lot of other developers, and your
    codes can be expected to be used and last for years. Future developers who will
    eventually take over your project should be able to understand, read, and reuse
    your codes easily as well. The following standards will help you and your team
    achieve that
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了PHP中OOP的基础知识，让我们来看看一些关于如何编写PHP代码的指南或标准。这些指南不是构建或运行PHP程序所必需的，但它们将帮助开发者编写更好、更易读、更易于共享的代码。以下关于如何编写PHP代码的标准在构建企业级应用程序时非常重要，尤其是当你需要与其他许多开发者一起开发代码时，你的代码可能会被期望使用多年。最终接管你项目的未来开发者应该能够轻松理解、阅读和重用你的代码。以下标准将帮助你和你团队实现这一点。
- en: PHP Standards Recommendations (PSRs)
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP标准建议（PSRs）
- en: As mentioned earlier, there are a lot of open source libraries and frameworks
    built for PHP. Each individual developer will have their own preferences in their
    style of writing codes, and each framework or library can have its own standard
    or way of doing things. This can start to become problematic for PHP developers,
    as we tend to use a lot of different libraries and frameworks.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有很多为PHP构建的开源库和框架。每个开发者都会有自己的代码编写风格偏好，每个框架或库都可以有自己的标准或做事方式。这可能会对PHP开发者造成问题，因为我们倾向于使用很多不同的库和框架。
- en: For example, it’s no fun transitioning from one framework to another only to
    end up having different types of service containers, which will require you to
    change the way you organize the dependencies for your application, and therefore
    PSR-11 was introduced. Service containers are applications that manage the instantiation
    of objects including their dependencies—they are very handy when implementing
    Dependency Injection or DI, which is discussed in [*Chapter 8*](B18318_08.xhtml#_idTextAnchor121)*,
    Using TDD with SOLID Principles*. This is one of the examples of why it is important,
    although not required, to follow some specific guidelines or standards, and where
    PSR comes in.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从一个框架切换到另一个框架，结果却需要使用不同类型的服务容器，这会迫使你改变组织应用程序依赖项的方式，因此引入了PSR-11。服务容器是管理对象实例化及其依赖项的应用程序——在实现依赖注入或DI时非常方便，这在[*第8章*](B18318_08.xhtml#_idTextAnchor121)*，使用SOLID原则进行TDD*中有所讨论。这是为什么遵循某些特定指南或标准很重要，尽管不是必需的，以及PSR的作用所在。
- en: What is a PSR?
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是PSR？
- en: A PSR is recommended by the **PHP Framework Interoperability Group** (**PHP-FIG**).
    They are a group of very kind developers who help us make our PHP coding life
    way more organized. You can find out more about the PHP-FIG at [https://www.php-fig.org/](https://www.php-fig.org/).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: PSR由**PHP框架互操作性小组**（**PHP-FIG**）推荐。他们是一群非常友好的开发者，帮助我们使PHP编码生活更加有序。你可以在[https://www.php-fig.org/](https://www.php-fig.org/)了解更多关于PHP-FIG的信息。
- en: 'The following are the currently accepted PSRs:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是目前接受的PSR：
- en: 'PSR-1: Basic Coding Standard'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PSR-1: 基本编码标准'
- en: 'PSR-3: Logger Interface'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PSR-3: 记录器接口'
- en: 'PSR-4: Autoloading Standard'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PSR-4: 自动加载标准'
- en: 'PSR-6: Caching Interface'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PSR-6: 缓存接口'
- en: 'PSR-7: HTTP Message Interface'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PSR-7: HTTP消息接口'
- en: 'PSR-11: Container Interface'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PSR-11: 容器接口'
- en: 'PSR-12: Extending Coding Style Guide (has deprecated PSR-2)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PSR-12: 扩展编码风格指南（已弃用PSR-2）'
- en: 'PSR-13: Hypermedia Links'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PSR-13: 超媒体链接'
- en: 'PSR-14: Event Dispatcher'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PSR-14: 事件调度器'
- en: 'PSR-15: HTTP Handlers'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PSR-15: HTTP处理器'
- en: 'PSR-16: Simple Cache'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PSR-16: 简单缓存'
- en: 'PSR-17: HTTP Factories'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PSR-17: HTTP工厂'
- en: 'PSR18: HTTP Client'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PSR18: HTTP客户端'
- en: You can find all the currently accepted PSRs at [https://www.php-fig.org/psr/](https://www.php-fig.org/psr/).
    Initially, the most important PSRs to get familiar with are PSR-1, PSR-12, and
    PSR-4\. This helps us write codes in a more consistent style, especially when
    transitioning from one framework to another framework. I used to have a “favorite”
    PHP MVC framework thinking that I’d use that framework until I grew old – and
    as usual, I was wrong. I ended up using so many different frameworks that I no
    longer cared which framework I was using. I now have favorites for each specific
    job.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.php-fig.org/psr/](https://www.php-fig.org/psr/)找到所有目前接受的PSR。最初，需要熟悉的最重要PSR是PSR-1、PSR-12和PSR-4。这有助于我们以更一致的风格编写代码，尤其是在从一个框架切换到另一个框架时。我曾经有一个“最喜欢的”PHP
    MVC框架，认为我会一直使用这个框架直到我变老——就像往常一样，我错了。我最终使用了这么多不同的框架，以至于我不再关心我使用的是哪个框架。现在，我对每个具体的工作都有“最喜欢的”。
- en: The PSRs are just “recommendations.” They are not like actual laws that you
    need to follow, but if you are serious about writing PHP and improving the quality
    of your own code, then I highly suggest that you follow them. Many people have
    already experienced the pain of not following standards. I wrote my own dependency
    injection container once, only to end up having other developers in our team get
    confused down the road on how to use it. I just reinvented the wheel, the bad
    way. How I wish there was a standard I could follow! Oh yeah, there is now a PSR-11.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: PSR只是“建议”。它们不像需要遵循的实际法律，但如果你认真对待编写PHP和提升你自己的代码质量，那么我强烈建议你遵循它们。很多人已经体验过不遵循标准的痛苦。我曾经自己编写了一个依赖注入容器，结果导致我们团队的其他开发者后来在使用它时感到困惑。我只是以错误的方式重新发明了轮子。我多么希望有一个我可以遵循的标准啊！哦，对了，现在有PSR-11了。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we defined what OOP is and why we’d want to take advantage
    of it. Then, we clearly defined what classes and objects are in PHP. We then went
    through some examples for each of the Four Pillars of OOP. We learned what abstraction,
    encapsulation, inheritance, and polymorphism are and how they work in PHP. We’ve
    also briefly gone through the PSRs because we don’t just want to go ahead and
    invent standards and start writing codes – we want to produce clean PHP code that
    is easy to understand and maintain, especially in an enterprise environment where
    you can expect to work with a lot of other developers, and where your codes will
    have to be very readable and maintainable for years to come.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们定义了什么是面向对象编程（OOP），以及为什么我们要利用它。然后，我们明确地定义了PHP中的类和对象。然后，我们针对面向对象编程的四个支柱（抽象、封装、继承和多态）中的每一个都进行了示例讲解。我们学习了抽象、封装、继承和多态是什么，以及它们在PHP中的工作原理。我们还简要地介绍了PSR，因为我们不希望只是继续发明标准并开始编写代码——我们希望编写易于理解和维护的干净PHP代码，尤其是在企业环境中，您可能会与许多其他开发者一起工作，并且您的代码将需要在未来多年内非常易于阅读和维护。
- en: This chapter should have prepared you to start writing actual object-oriented
    PHP code – and in our TDD example project, we will take advantage of the OOP capabilities
    of PHP.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本章应该已经为您准备好开始编写实际的面向对象PHP代码——在我们的TDD示例项目中，我们将利用PHP的面向对象功能。
- en: In the next chapter, we will talk about unit testing. We will define what it
    is, and how unit testing is used in TDD. We will also go through different types
    of automated tests. After going through the definition of unit testing, we will
    start writing our first unit tests and start executing those unit tests.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论单元测试。我们将定义什么是单元测试，以及单元测试在TDD中的应用。我们还将介绍不同类型的自动化测试。在了解单元测试的定义后，我们将开始编写我们的第一个单元测试，并开始执行这些单元测试。
- en: Part 2 – Implementing Test-Driven Development in a PHP Project
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分 - 在PHP项目中实现测试驱动开发
- en: In this part of the book, you will achieve the necessary knowledge to utilize
    test-driven development, behavior development, and automated testing to build
    a PHP application.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，您将获得利用测试驱动开发、行为开发和自动化测试构建PHP应用程序所需的知识。
- en: 'This section comprises the following chapters:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括以下章节：
- en: '[*Chapter 5*](B18318_05.xhtml#_idTextAnchor070), *Unit Testing*'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B18318_05.xhtml#_idTextAnchor070), *单元测试*'
- en: '[*Chapter 6*](B18318_06.xhtml#_idTextAnchor094), *Applying Behavior-Driven
    Development*'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18318_06.xhtml#_idTextAnchor094), *应用行为驱动开发*'
- en: '[*Chapter 7*](B18318_07.xhtml#_idTextAnchor108), *Building Solution Code with
    BDD and TDD*'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18318_07.xhtml#_idTextAnchor108), *使用BDD和TDD构建解决方案代码*'
- en: '[*Chapter 8*](B18318_08.xhtml#_idTextAnchor121), *Using TDD with SOLID Principles*'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18318_08.xhtml#_idTextAnchor121), *使用SOLID原则进行TDD*'
