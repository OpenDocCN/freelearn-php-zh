- en: '*Chapter 12*: Implementing Product Information Management'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, you learned about some key features of the Pimcore environment
    presented in [*Chapter 1*](B17073_01_ePub_RK.xhtml#_idTextAnchor014), *Introducing
    Pimcore*. In particular, in [*Chapter 6*](B17073_06_ePub_RK.xhtml#_idTextAnchor112),
    *Using Digital Asset Management*, you discovered the Pimcore **Digital Asset Management**
    (**DAM**) feature and all aspects related to images and asset management. Then,
    in [*Chapter 4*](B17073_04_ePub_RK.xhtml#_idTextAnchor083), *Creating Documents
    in Pimcore*, and in [*Chapter 8*](B17073_08_ePub_RK.xhtml#_idTextAnchor139), *Creating
    Custom CMS Pages*, you learned about the concept of **content management systems**
    (**CMSes**) and how to create documents and site pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go in-depth through the concept of `Product` entity.
    The chapter is organized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a PIM?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the `Product` entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Product Variants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Bundle Product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing different Product Types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Workflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with the explanation of what a PIM system is, we will implement an
    example of a `Product` class. After having defined the class attributes, you will
    learn how to create product variants and bundle products, and how to manage different
    product types using Objectbricks. In the last section of the chapter, you will
    learn how to define a workflow to fill in the product information step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have done in previous chapters, all you need to do is run the demo connected
    to this chapter by navigating to the `12.` `Implementing` `Product` `Information`
    `Management` folder of the official book repository and start a Docker environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, just follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run Docker with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, to restore all the settings on your local machine, just open a new shell
    and type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Navigate to [http://localhost/admin](http://localhost/admin) and log in with
    your admin/pimcore credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can access the official book repository to get the source code through
    the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/12.%20Implementing%20Product%20Information%20Management](https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/12.%20Implementing%20Product%20Information%20Management)'
  prefs: []
  type: TYPE_NORMAL
- en: Now you are ready to navigate through the demo to discover all the aspects related
    to this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What is a PIM?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B17073_01_ePub_RK.xhtml#_idTextAnchor014), *Introducing Pimcore*,
    we briefly introduced the concept of **Product Information Management (PIM)**.
    In this section, we will better explain this concept, which we will put into practice
    throughout the following sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of PIM encompasses a set of technologies and procedures that allow
    centralized management of product data and their distribution across different
    channels. In many common scenarios, information relating to products may come
    from multiple sources, potentially with different data structures, both due to
    different needs dictated by their distribution channels and through the provision
    of different technologies in distinct areas within the same company.
  prefs: []
  type: TYPE_NORMAL
- en: The use of a PIM allows you to integrate information from different sources
    into a single platform and organize it all coherently, with the possibility of
    redistributing this information in different ways to e-commerce platforms, websites,
    paper catalogs, and so on. It also allows complete and dynamic management of the
    product data, including customizing and filtering information related to different
    types of products to manage prices and currencies, different units of measurement,
    multilingual translations, multimedia content, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to centralize all this information in a single platform allows you
    to manage products completely independently of any distribution channel; the PIM
    will be responsible for sending only the information it needs to each channel.
    This centralized management gives consistency to product information, avoiding
    the need to replicate data in different platforms and keeping them aligned, reducing
    design errors. This also brings benefits in terms of the management cost of any
    catalogs, price lists, and online platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The use of a PIM is essential for companies that need to sell or present their
    products in different platforms and media, but also for business scenarios in
    which it is necessary to share information relating to products in different departments
    or development areas, always keeping the production of such information centralized.
    The need to have a PIM increases even more as the number of products to manage
    increases, as the cost of managing and maintaining data is drastically reduced,
    limiting it to a single platform.
  prefs: []
  type: TYPE_NORMAL
- en: PIM technologies also make it possible to integrate information relating to
    products alongside them with the management of multimedia content associated with
    them and to send such content to the various distribution channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these aspects regarding the concept of PIM and its usages are summarized
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: PIM Architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.01_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.1: PIM Architecture'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous diagram, products can be imported into a PIM
    system by uploading files or implementing specific flows to establish an integration
    with other software or databases. Products can also be created and enriched directly
    in the PIM environment, through the **graphical user interface** (**GUI**).
  prefs: []
  type: TYPE_NORMAL
- en: Product data can then be exported to e-commerce or other software, or properly
    exported to files. In [*Chapter 14*](B17073_14_ePub_RK.xhtml#_idTextAnchor243),
    *Data Integration*, you will learn different ways to import and export products
    in Pimcore.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, you learned about the concept of PIM and the
    benefits that a PIM system brings as regards to product data management and distribution.
    In the following section, we will build a `Product` entity step by step, defining
    a Pimcore class that will represent the product concept.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Product Entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned about the concept of Product Information
    Management. As the name suggests, in a PIM system, it's mandatory to create a
    class that represents the products, and this is what we are going to do in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Pimcore does not set any constraints as far as the concept of products is concerned,
    so we can simply create a class named `Product` and define all the attributes
    that reflect our needs. So, as you learned in [*Chapter 5*](B17073_05_ePub_RK.xhtml#_idTextAnchor093),
    *Exploring Objects and Classes*, just go through `Product`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you followed the instructions provided in the *Technical requirements* section,
    you should find an already defined `Product` class. Please note that this is just
    a typical example of the concept of a product and that you can add or remove class
    attributes according to your needs. You can see what this class looks like in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: Product class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.02_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.2: Product class'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s describe the various class components that are shown in the previous
    screenshot. The class is composed of five panels that enclose different attributes
    representing common concepts for products, and these are outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Product Information**: In this panel, you can find the **Stock-Keeping Unit**
    (**SKU**), which is a unique identifier for products and the product price. Then,
    we added the product name and description as localized fields so that you can
    provide translations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`brand` attribute is a custom-defined single select field with common brands
    as options; there''s also a predefined options list to choose the country where
    the product was made. The last attribute is a many-to-one relation with another
    class added to describe categories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composition**: In this panel, you can find an advanced many-to-many relation
    component to relate the product to the materials that compose the product. In
    this relation, you can set the percentage of the various materials to define the
    composition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color` and `size`. For the `color` attribute, we have defined a relationship
    with a dedicated class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Images**: As the name suggests, this panel is designed to contain the product
    images. In particular, we used a **Fieldcollection** to administer an undefined
    number of images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the sake of completeness, in the following screenshot, you will see the
    other class definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: Class definitions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.03_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.3: Class definitions'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, you can see the definitions for the `Category`,
    `Material`, and `Color` classes. For the `Category` class, we have defined a unique
    `code` attribute and a couple of localized fields, called `name` and `description`.
    The same structure is made for the `Material` class, with the addition of another
    field to define the material typology. For the `Color` class, an attribute to
    set the **hexadecimal** (**hex**) value was added.
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, you should already find these classes after the installation
    process described in the *Technical requirements* section of this chapter, but
    you can import them at any time by selecting the files that you can find in the
    `src/classes` folder of the chapter repository, as you have seen in [*Chapter
    7*](B17073_07_ePub_RK.xhtml#_idTextAnchor129), *Administrating Pimcore Sites*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you have learned in [*Chapter 5*](B17073_05_ePub_RK.xhtml#_idTextAnchor093),
    *Exploring Objects and Classes*, you can easily perform data entry to create products
    and other entities. In the following screenshot, you can see an example of a created
    product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: Product entity'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.04_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.4: Product entity'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, the structure of the created product
    reflects the class definition. To better organize the contents, objects of the
    various classes are divided into the corresponding subfolders.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, we have seen how to define a `Product` entity.
    We have presented a possible implementation of the product concept, but this concept
    has no fixed definition in terms of attributes, so you can choose to create attributes
    that better reflect your needs. Beside from this, we have defined other secondary
    classes to relate the products to other concepts such as categories, materials,
    and colors. This is useful for keeping this information linked to a product without
    the need to replicate them in all products.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will learn how to create product variants in order
    to create configurable products.
  prefs: []
  type: TYPE_NORMAL
- en: Creating product variants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, you have seen how to define a `Product` entity and
    an example of product object creation. In this section, you will learn how to
    enable the inheritance for the `Product` class to create product variants and
    define configurable products. Later in this section, we will see some **PHP: Hypertext
    Preprocessor** (**PHP**) code examples that will show how to practically use variants
    during development.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable inheritance for the `Product` class, open the class definition and
    select the **General Settings** root element. You can enable class inheritance
    and allow the variants'' creation by selecting the checkboxes that you see in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5: Enabling inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.05_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.5: Enabling inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the previous screenshot, three checkboxes can be enabled,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Allow inheritance**: If checked, this property enables inheritance among
    objects in a tree-structured way. The child objects can be instances of the same
    class or may belong to a different class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Allow variants**: If checked, this enables the possibility to create object
    variants. The variant definition is a particular kind of inheritance. The variant
    class cannot be chosen, but the class is forced to be the same as the parent object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show variants in tree**: If enabled, this property allows you to see the
    variants in the object tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have enabled these checkboxes, you must click on the **Save** button
    to apply the changes. After having enabled variants for the class, variants can
    be created for products. To create a variant, just right-click on a previously
    created product, select **Add Variant**, and type the variant name.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you will see an example of a configurable product
    with variants defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6: Product variant example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.06_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.6: Product variant example'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, enabling the corresponding property
    lets the product variants be shown in the object tree. You can recognize product
    variants by the different specific icons in the tree structure.
  prefs: []
  type: TYPE_NORMAL
- en: The variants inherit all property values from the parent, but it's possible
    to override those properties in each variant. In this specific example, we have
    used the `Color`attribute to create a configurable product with different variants.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to create product variants in the Pimcore interface,
    let's see how to practically use variants in code, looking at some coding examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'A key aspect concerning variants is the object **type**. This is a system property
    defined for objects of all classes; this property cannot be filled manually, but
    it''s automatically defined when we create an element. There are three different
    object types, outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`folder`: This type is assigned when we create a folder in the **Data Objects**
    section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object`: This type is assigned when we create an object instance of a class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`variant`: This type is assigned when we create an object variant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When coding in Pimcore, it's important to know that all native methods that
    perform searches for lists of objects always consider only `folder` and `object`
    types, so it's necessary to explicitly specify that you want to retrieve variants.
    Through the following examples, we will see how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Parent PHP class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this first example, you will learn how to create a parent PHP class for the
    `Product` class and how to create a method to retrieve the product variants. The
    creation of this class is not strictly related to the concept of variants, but
    it's a feature that is worth discovering and that can be useful in different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: As we briefly introduced in the *Creating and Editing a Class Definition* section
    of [*Chapter 5*](B17073_05_ePub_RK.xhtml#_idTextAnchor093), *Exploring Objects
    and Classes*, for each class, there is the possibility of defining a custom parent
    PHP class. This can be any PHP class that directly or indirectly extends the `Pimcore\Model\DataObject\Concrete`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The `Concrete` class is a PHP class that is originally extended by all Pimcore
    classes and that contains all the common methods for all the classes, such as
    the `save` and `getById` operations, to cite a couple of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, you will see an example `product` parent class
    with a defined method to retrieve product variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous code snippet, this class extends the previously
    mentioned `Concrete` class. In this class, we have created a `getVariants` method
    that invokes the original `getChildren` method, specifying the need to retrieve
    objects of the type `variant`. This is necessary because, as we said in the previous
    section, all listing methods consider only objects and folders if no types are
    directly specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the PHP class is created, we must properly set the corresponding property
    in the `Product` class, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7: Configuring the parent PHP class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.07_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.7: Configuring the parent PHP class'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, you may write the complete class
    namespace in the **Parent PHP Class** input. Once you have filled that in, you
    must click on the **Save** button to apply the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'After having defined the parent PHP class, you can call the `getVariants` method
    for each product object instance, as you can see in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, you can see that since the `Product` class extends
    the previously created `AbstractProduct` class, every product object can use the
    defined `getVariants` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `getChildre`n method that we have seen in this example is just one particular
    case of object listing. In the following example, we will see how to retrieve
    variants in common listing methods.
  prefs: []
  type: TYPE_NORMAL
- en: Object Listing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, we have seen how to retrieve the variants of a specific
    product, using the methods that retrieve the product children. In this example,
    we will see how to retrieve variants in generic listing methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, you can see how product variants can be retrieved
    on listing queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, you can see how to initialize a product listing.
    For listing objects, there is a specific method to set the object types that you
    want to retrieve. This method is the one that is used internally by the `getChildren`
    method you have seen in the previous example. The `load` method returns an array
    of objects that respect the listing conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In these first two examples, you have learned how to retrieve existing variants.
    In the following example, you will see how to create a new variant instead.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Variant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous examples, you learned how to query for existing variants. In
    this example, you will learn how to create a product variant.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, you will see how to create a variant for an
    existing product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous code snippet, first of all you have to get the
    product object. The retrieved product must be declared as the parent of the new
    product variant. Then, it's necessary to explicitly set the product type to declare
    that the created product is a variant.
  prefs: []
  type: TYPE_NORMAL
- en: In the example, you will note the use of the `getByName` method. This kind of
    method is automatically generated for each class attribute at class-definition
    save. The first argument is the value to search for, the second one is for localized
    fields (the language for which the value must be searched), and the third one
    is the limit parameter. If the limit is 1, a single object is returned; otherwise,
    the return type is an instance of the class listing.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, you learned how to enable variants for the `Product`
    class and how to create product variants. Then, through some code examples, you
    learned how to retrieve existing variants and how to create new ones.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will learn how to create bundled products and
    how to create a service that listens to events fired after certain operations
    are made—for example, to automatically calculate one or more product field values
    when a product is saved.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Bundle Product
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned how to enable and create product variants
    and how to practically use them in code examples. In this section, you will learn
    how to define bundle products.
  prefs: []
  type: TYPE_NORMAL
- en: In marketing, the concept of **Product Bundling** is the practice of offering
    a set of individual products or services together as one combined product or service
    package. Typically, bundle products are intended to be kits or, more generically,
    a group of coherent products, with the advantage of a discounted price if bought
    together instead of buying them separately.
  prefs: []
  type: TYPE_NORMAL
- en: Through this chapter, we will first see how to modify our previously created
    `Product` class to define bundle products. Then, we will discover how to automatically
    perform operations once the product is saved to calculate the bundle price.
  prefs: []
  type: TYPE_NORMAL
- en: Defining bundle products
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you will learn how to modify the `Product` class to be able
    to define bundle products. The easiest solution is to create a self-referenced
    relation attribute with the `Product` class itself. This will let you choose the
    products that will form the bundle from the previously created products.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add this attribute, you need to perform the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Product` class definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **Product Information** panel and select **Add Data Component**
    | **Relation** | **Many-to-Many Object Relation**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write `bundle_products` as the attribute name and `Bundle` `Products` as the
    attribute title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Product` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `sku` and `name`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Save** button to apply the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see what the `Product` class should look
    like after these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8: Bundle_Products Attribute'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.08_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.8: Bundle_Products Attribute'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, the new attribute is added at the
    bottom of the panel, and the desired visible fields are selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created this attribute, we can create a bundle product. To
    do that, simply create a new product object, then use the previously created relation
    attribute to select a couple of products that will compose the bundle product.
    Once you have selected these products they will appear in the relationship, as
    you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9: Bundle Products relation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.09_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.9: Bundle Products relation'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, only the previously selected product
    fields are visible in the relation attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined which are the products that compose our bundle, we
    may want to automatically calculate the bundle price based on the price of the
    selected products. So we need to open the class definition and add a new numeric
    attribute to store the bundle price, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10: Bundle price attribute'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.10_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.10: Bundle price attribute'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, you can see that this attribute is marked as **Not
    editable**, and this means that we need a method to calculate the bundle price.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, you learned how to alter the `Product` class
    to define bundle products. In the following section, you will learn how to create
    a listener class that listens for an event fired by the product save operation,
    which will allow you to automatically calculate the bundle price.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Event Listener
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you learned how to define bundle products. In common
    scenarios, the price of a bundle product is less than the sum of the individual
    price of the products it's composed of. It may be useful to automatically calculate
    the price of a bundle product with a predefined rule, instead of manually inserting
    this value.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to create an event listener to capture events
    fired once the product is saved. The saving of an object is just one of the events
    that could be listened to in Pimcore, which includes all **create, read, update,
    and delete** (**CRUD**) operations on objects, assets, and documents, operations
    on users, the opening of search or grid lists, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an event listener, you first need to register a new class in the
    `app/config/services.yml` file, as you can see in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the previous snippet, a new service can be defined by adding
    the class namespace. In the `tags` attribute, we must define one or more tags
    of our service. Each tag is composed of three properties, outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: The name of the tag. We must provide the `kernel.event_listener` fixed
    value to let the service be correctly recognized as an event listener.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`event`: Used to specify which event we want to listen to. In our case, we
    are interested in listening to the `postUpdate` event for objects. This event,
    as the name suggests, is fired after an object is saved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method`: In this property, we must put the name of the method of our class
    that will be called automatically when an event is fired.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For event listeners, each defined tag represents a specific event, so you must
    add one tag for each event that you want your service to listen to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see how to implement the defined service to calculate the price
    of our bundle product. In the following code snippet, you will see a possible
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze the previous code snippet, to understand the key aspects. First
    of all, you may note that we have defined a method named `onObjectPostUpdate`,
    which is the name defined in the `services.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: This method takes the fired event as an argument, and from this event, we can
    extract the object that fired the event itself. As you may note, we must check
    for the object class to do the operations part only if the object is a product.
  prefs: []
  type: TYPE_NORMAL
- en: For each product that composes the bundle, we add up the product prices, and
    in the end, we decrease this sum by 20%. Please note that this is just an example
    and that you can define your own rule.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid a circular loop on product saves, we save the product only in cases
    where the new calculated price is different from the previous one. If we omit
    this check, the save operation made on this service will fire the event again.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, you learned about the concept of product bundling
    and how to change the `Product` class by adding attributes that allow you to define
    bundle products. Later, you learned how to create an event listener service to
    capture events fired by operations on objects, such as the saving of a product.
    In the provided example, you have seen how to automatically calculate the price
    of a bundle product.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will learn how to extend the `Product` class to
    manage different types of products without the need to create a specific class
    for each product.
  prefs: []
  type: TYPE_NORMAL
- en: Managing different Product Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned how to define bundle products. In this
    section, you will learn how to manage different types of products without creating
    a different class for each product type. If you need to manage a heterogeneous
    set of products, such as shirts and shoes, you will probably need specific attributes
    to better represent these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Surely, we could create two different classes for shirts and shoes, but we will
    need to define redundant fields for both classes to describe properties that are
    shared between them—for example, the title, price, description, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B17073_05_ePub_RK.xhtml#_idTextAnchor093), *Exploring Objects
    and Classes*, we introduced the concept of **Objectbricks**. With Objectbricks,
    we just need to create little sets of attributes to describe specific fields and
    allow our class to dynamically add these bricks. As the name suggests, class objects
    can be composed of one or more bricks added to the common attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating Objectbrick definitions, we need to create an attribute in
    the `Product` class to accommodate the various bricks. To create this attribute,
    just right-click on a panel component inside the class definition and select **Add
    Data Component** | **Structured** | **Objectbricks**, fill in the attribute name,
    and click on the **Save** button to apply the changes. In the following screenshot,
    you can see an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11: Objectbricks attribute'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.11_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.11: Objectbricks attribute'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, we have created an attribute of the
    **Objectbricks** type. As an optional property, we can set the maximum number
    of bricks that can be attached to each object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined the attribute in the `Product` class, we can define
    one or more Objectbricks. To do that, just go through **Settings** | **Data Objects
    | Objectbricks**. To add a new Objectbricks definition, you just need to click
    on the **Add** button, write the name of your brick, and click on the **OK** button.
    In the following screenshot, you can see an example of a created Objectbrick:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12: Objectbrick definition'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.12_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.12: Objectbrick definition'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, the Objectbricks definition panel
    is the same as the class creation one. Besides, for Objectbricks, we can select
    the classes and the specific attributes to attach the Objectbrick to. In this
    example, we have attached the Objectbrick to the `Product` class, and we have
    selected the previously created attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Objectbricks are defined, we can attach them to the product objects.
    In the following screenshot, you can see what the Objectbrick looks like in the
    product object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13: Objectbrick instance'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.13_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.13: Objectbrick instance'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, in the product objects, the Objectbricks
    appear as a specific section. You can attach one or more Objectbricks to every
    object since the defined limit is reached, and every kind of Objectbrick can be
    attached once within the same objects.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, you learned how to manage different types of
    products using Objectbricks. Objectbricks can be considered as subsets of attributes
    that can be attached to classes to extend the class concept with extra attributes.
    For the `Product` class, for example, we can think about creating specific attributes
    for shirts, shoes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to configure a workflow that will let
    you control the completeness of the product information, step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Working with workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A workflow consists of a sequence of processes and tasks that represent the
    work that must be done to reach a common goal. Typically, we may think about workflows
    as a graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pimcore Workflow Management provides configurations of multiple workflows on
    assets, documents, data objects, to support data maintenance processes, element
    life cycles, and various other processes. Pimcore workflows are based on the Symfony
    workflow component and extend it with specific features. Before starting the configuration
    of a Pimcore workflow, let''s describe the basics concepts of the Symfony workflow
    component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Workflow Type ''Workflow''**: This is the default type of workflow and allows
    you to model a workflow net that is a subclass of a petri net. For this kind of
    workflow, an element can be in several states of the workflow at the same time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Workflow Type ''State Machine''**: A state machine is a subset of a workflow
    and its purpose is to hold a state of your model. A state machine cannot be in
    more than one place simultaneously.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Place**: A place is a step in a workflow and describes a characteristic or
    status of an element. Depending on the place, an element may appear in a specific
    view—for example, to have a focus on translations only. We will have a look at
    how to create a custom layout for a Pimcore class in the following section.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Marking Store**: The marking store stores the current place(s) for each element.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Transition**: A transition describes the action that is performed to move
    from one place to another. Transitions may be allowed or not, depending on additional
    criteria, and may require additional notes and information entered by the user.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Transition Guard**: Defines a criterion that defines whether a transition
    is currently allowed or not.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By reading the following sections, you will learn how to properly configure
    a Pimcore workflow. We will start by defining a custom layout for the `Product`
    class and will then see how to set up a workflow that will guide the completion
    of product information.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Custom Layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, in the various places of a workflow we can show a custom
    view for the element. This is made possible by configuring custom layouts on the
    corresponding class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a custom layout, just open the class definition and click on the
    **Configure custom layouts** button. When that button is clicked, a new modal
    window is opened, and you can add a new custom layout or load a previously created
    one. To create a new layout, just click on the **Add** button. In the modal that
    will open, you can write the new layout name and **identifier** (**ID**), as you
    can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14: Creating a Custom Layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.14_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.14: Creating a Custom Layout'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, to add a new custom layout you just
    need to fill in the **Name** and **Unique identifier** fields and click on the
    **OK** button to confirm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have initialized the custom layout, you can specify which attributes
    you want to show in the layout itself. In the following screenshot, you can see
    how this configuration can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15: Custom Layout Configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.15_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.15: Custom Layout Configuration'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, the configuration modal is composed
    of two main panels. In the left panel, you will find the previously defined class
    structure, while in the right panel, you can drag and drop the attributes you
    want to show in the custom layout from the left panel.
  prefs: []
  type: TYPE_NORMAL
- en: For each attribute, you can decide to change some properties, such as the possibility
    to edit the attribute itself. Once you have configured the custom layout, you
    can click on the **Save** button to apply the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen how to configure custom layouts, let's see how to use
    them in a workflow configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Pimcore workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you learned how to configure custom layouts for Pimcore
    classes. In this section, you will learn how to configure Pimcore workflows and
    how to use the previously created custom layouts.
  prefs: []
  type: TYPE_NORMAL
- en: As with many other services, Pimcore workflows must be defined in the `config.yaml`
    file of the Pimcore project or the same file of a specific bundle. In this section,
    you will learn how to properly configure a workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, you will see how to initialize the workflow
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding snippet, to initialize a workflow you must add
    the `workflows` keyword under the `pimcore` keyword. Then, you must add a unique
    ID for the workflow, which is `product_workflow` in our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the lower level, you can define some parameters, which are provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`label`: The workflow title.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`type`: The workflow type, which can be `workflow` or `state_machine`, as described
    in the chapter introduction.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`supports`: One or more classes to which the workflow is applied.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`marking_store`: For `state_machine` workflows, you can specify which attribute
    of the class must be used to store the workflow state. If that attribute is a
    picklist attribute, you can let the class dynamically create the picklist options
    by reading the workflow states by defining the options provider, as you can see
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.16: Workflow states options provider'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.16_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.16: Workflow states options provider'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the previous screenshot, you can fill in the `places` keyword,
    as you can see in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the previous code snippet, you can add one or more states
    behind the `places` keyword. For each state, you must specify a unique ID and
    define a label and a color that will be used to highlight the label text. If you
    want to restrict the visible class attributes for a particular state, you may
    specify a previously defined custom layout in the `objectLayout` keyword behind
    `permissions`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step in the workflow configuration is to define transitions between
    different states. You can see how to define transitions in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the previous snippet, the transitions must be defined behind
    the `transitions` keyword. For each transition, you must define a unique ID; then,
    you must specify one or more states from which the transition can start and one
    destination state only. In the following screenshot, you can see how a transition
    can be invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.17: Invoking workflow transitions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.17_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.17: Invoking workflow transitions'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, a grouped button is automatically
    injected into the object editor to let you select the available transitions.
  prefs: []
  type: TYPE_NORMAL
- en: If needed, you can also specify a `guard` function that is automatically invoked
    when the workflow is placed in one of the `from` states. If the `guard` function
    does not pass, it will not be possible to apply the transition and move to the
    destination state. In this specific example, you can let the user edit the images
    only after the transitions are completed. A transition guard must be a function
    of the object, so the best solution is to create this function in the parent PHP
    class that we mentioned in the *Creating product variants* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, you can also specify some extra options on a transition, such as
    setting up a custom icon for the transition or letting the user write a note when
    the transition is invoked, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.18: Notes on transition'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.18_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.18: Notes on transition'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, when the user clicks on the transition
    action, a modal will open and the user can write a comment that will be stored
    in the **Notes & Events** section inside the object, and then click on the **Perform
    Action** button to complete the transition.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, in this section, you learned how to configure a Pimcore workflow.
    By defining custom layouts, you can force users to fill in product information
    step by step, to ensure data completion. In particular, you learned how to define
    places for the workflow and how to configure workflow transitions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the concept of `Product` entity and providing
    practical examples. In the first section of the chapter, you learned what a PIM
    is and what its main features are. Then, you learned how to create and configure
    a `Product` class, according to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: After having defined the `Product` class, you learned how to enable inheritance
    for the class and how to define product variants for an existing product. Through
    practical code examples, you also learned how to retrieve variants on listings
    and how to create new product variants.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, you learned about the concept of product bundling and
    how to add new fields to the `Product` class to let you define bundle products.
    Then, you learned how to create an event listener service to listen to events
    fired by the objects—for example, to catch once the product is saved. In particular,
    you have seen a code example showing how to calculate the price of a bundle product.
  prefs: []
  type: TYPE_NORMAL
- en: After that, you learned how to use Objectbricks to extend the `Product` class,
    attaching groups of attributes useful to define specific concepts. This is useful
    if you want to represent different kinds of products without creating a class
    for each kind, to avoid the redundancy of common attributes.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, you learned how to configure custom layouts for Pimcore
    classes and how to use them in Pimcore workflow configurations. Through a concrete
    example, you learned how to configure a workflow to fill in product information
    step by step.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to expose products and other entities
    to the outside through the Pimcore Datahub bundle and how to turn Pimcore into
    a **Master Data Management** (**MDM**) platform.
  prefs: []
  type: TYPE_NORMAL
