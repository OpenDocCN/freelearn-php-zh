- en: '*Chapter 12*: Implementing Product Information Management'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：实施产品信息管理'
- en: In previous chapters, you learned about some key features of the Pimcore environment
    presented in [*Chapter 1*](B17073_01_ePub_RK.xhtml#_idTextAnchor014), *Introducing
    Pimcore*. In particular, in [*Chapter 6*](B17073_06_ePub_RK.xhtml#_idTextAnchor112),
    *Using Digital Asset Management*, you discovered the Pimcore **Digital Asset Management**
    (**DAM**) feature and all aspects related to images and asset management. Then,
    in [*Chapter 4*](B17073_04_ePub_RK.xhtml#_idTextAnchor083), *Creating Documents
    in Pimcore*, and in [*Chapter 8*](B17073_08_ePub_RK.xhtml#_idTextAnchor139), *Creating
    Custom CMS Pages*, you learned about the concept of **content management systems**
    (**CMSes**) and how to create documents and site pages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了在[*第1章*](B17073_01_ePub_RK.xhtml#_idTextAnchor014)，*介绍Pimcore*中介绍的Pimcore环境的一些关键特性。特别是，在[*第6章*](B17073_06_ePub_RK.xhtml#_idTextAnchor112)，*使用数字资产管理*中，你发现了Pimcore的**数字资产管理（DAM）**特性和与图像及资产管理相关的所有方面。然后，在[*第4章*](B17073_04_ePub_RK.xhtml#_idTextAnchor083)，*在Pimcore中创建文档*和[*第8章*](B17073_08_ePub_RK.xhtml#_idTextAnchor139)，*创建自定义CMS页面*中，你学习了**内容管理系统（CMS）**的概念以及如何创建文档和网站页面。
- en: 'In this chapter, we will go in-depth through the concept of `Product` entity.
    The chapter is organized as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨`产品`实体的概念。本章的组织结构如下：
- en: What is a PIM?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是PIM？
- en: Defining the `Product` entity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`产品`实体
- en: Creating Product Variants
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建产品变体
- en: Creating a Bundle Product
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建捆绑产品
- en: Managing different Product Types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理不同的产品类型
- en: Working with Workflows
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与工作流程一起工作
- en: Starting with the explanation of what a PIM system is, we will implement an
    example of a `Product` class. After having defined the class attributes, you will
    learn how to create product variants and bundle products, and how to manage different
    product types using Objectbricks. In the last section of the chapter, you will
    learn how to define a workflow to fill in the product information step by step.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从解释PIM系统是什么开始，我们将实现一个`产品`类的示例。在定义了类属性之后，你将学习如何创建产品变体和捆绑产品，以及如何使用Objectbricks管理不同的产品类型。在章节的最后部分，你将学习如何定义一个工作流程来逐步填写产品信息。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As you have done in previous chapters, all you need to do is run the demo connected
    to this chapter by navigating to the `12.` `Implementing` `Product` `Information`
    `Management` folder of the official book repository and start a Docker environment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的章节中所做的那样，你所需要做的就是运行与本章相关的演示，通过导航到官方书库的`12.` `实施` `产品` `信息` `管理`文件夹，并启动一个Docker环境。
- en: 'To do so, just follow these instructions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，只需遵循以下说明：
- en: 'Run Docker with the following command:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行Docker：
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, to restore all the settings on your local machine, just open a new shell
    and type the following command:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为了恢复您本地机器上的所有设置，只需打开一个新的shell，并输入以下命令：
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Navigate to [http://localhost/admin](http://localhost/admin) and log in with
    your admin/pimcore credentials.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到[http://localhost/admin](http://localhost/admin)，并使用您的管理员/pimcore凭据登录。
- en: 'You can access the official book repository to get the source code through
    the following link:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下链接访问官方书库以获取源代码：
- en: '[https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/12.%20Implementing%20Product%20Information%20Management](https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/12.%20Implementing%20Product%20Information%20Management)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/12.%20Implementing%20Product%20Information%20Management](https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/12.%20Implementing%20Product%20Information%20Management)'
- en: Now you are ready to navigate through the demo to discover all the aspects related
    to this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好通过演示来探索与本章相关的所有方面。
- en: What is a PIM?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是PIM？
- en: In [*Chapter 1*](B17073_01_ePub_RK.xhtml#_idTextAnchor014), *Introducing Pimcore*,
    we briefly introduced the concept of **Product Information Management (PIM)**.
    In this section, we will better explain this concept, which we will put into practice
    throughout the following sections of this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B17073_01_ePub_RK.xhtml#_idTextAnchor014)，*介绍Pimcore*中，我们简要介绍了**产品信息管理（PIM）**的概念。在本节中，我们将更好地解释这个概念，我们将在本章的后续部分将其付诸实践。
- en: The concept of PIM encompasses a set of technologies and procedures that allow
    centralized management of product data and their distribution across different
    channels. In many common scenarios, information relating to products may come
    from multiple sources, potentially with different data structures, both due to
    different needs dictated by their distribution channels and through the provision
    of different technologies in distinct areas within the same company.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: PIM（产品信息管理）的概念涵盖了一系列技术和流程，这些技术和流程允许对产品数据进行集中管理，并在不同的渠道间进行分发。在许多常见的场景中，与产品相关的信息可能来自多个来源，这些信息可能具有不同的数据结构，这既是因为它们在不同渠道的需求不同，也是因为同一公司内部不同区域提供的技术不同。
- en: The use of a PIM allows you to integrate information from different sources
    into a single platform and organize it all coherently, with the possibility of
    redistributing this information in different ways to e-commerce platforms, websites,
    paper catalogs, and so on. It also allows complete and dynamic management of the
    product data, including customizing and filtering information related to different
    types of products to manage prices and currencies, different units of measurement,
    multilingual translations, multimedia content, and much more.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PIM可以使您将来自不同来源的信息整合到一个单一平台上，并对其进行连贯的组织，同时有可能以不同的方式重新分配这些信息到电子商务平台、网站、纸质目录等。它还允许对产品数据进行全面和动态的管理，包括定制和过滤与不同类型产品相关的信息，以管理价格和货币、不同的计量单位、多语言翻译、多媒体内容等等。
- en: The ability to centralize all this information in a single platform allows you
    to manage products completely independently of any distribution channel; the PIM
    will be responsible for sending only the information it needs to each channel.
    This centralized management gives consistency to product information, avoiding
    the need to replicate data in different platforms and keeping them aligned, reducing
    design errors. This also brings benefits in terms of the management cost of any
    catalogs, price lists, and online platforms.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将所有这些信息集中在一个平台上，使您能够完全独立于任何分销渠道管理产品；PIM将负责向每个渠道发送所需的信息。这种集中化管理使产品信息保持一致性，避免了在不同平台上复制数据的需求，并保持它们的一致性，减少了设计错误。这也为任何目录、价格表和在线平台的管理成本带来了好处。
- en: The use of a PIM is essential for companies that need to sell or present their
    products in different platforms and media, but also for business scenarios in
    which it is necessary to share information relating to products in different departments
    or development areas, always keeping the production of such information centralized.
    The need to have a PIM increases even more as the number of products to manage
    increases, as the cost of managing and maintaining data is drastically reduced,
    limiting it to a single platform.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要在不同平台和媒体上销售或展示其产品的公司来说，使用PIM是必不可少的，但同样对于需要在不同部门或开发领域共享与产品相关信息的企业场景也是必要的，始终保持此类信息的生产集中化。随着需要管理的产品数量增加，拥有PIM的需求也会增加，因为管理和维护数据成本会大幅降低，限制在单一平台上。
- en: PIM technologies also make it possible to integrate information relating to
    products alongside them with the management of multimedia content associated with
    them and to send such content to the various distribution channels.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: PIM技术还使得将产品相关的信息与它们的多媒体内容管理相结合成为可能，并将此类内容发送到各种分销渠道。
- en: 'All these aspects regarding the concept of PIM and its usages are summarized
    in the following diagram:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有关于PIM概念及其用法的这些方面都在以下图中进行了总结：
- en: '![Figure 12.1: PIM Architecture'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.1: PIM Architecture]'
- en: '](img/Figure_12.01_B17073.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.01_B17073.jpg]'
- en: 'Figure 12.1: PIM Architecture'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：PIM架构
- en: As you can see in the previous diagram, products can be imported into a PIM
    system by uploading files or implementing specific flows to establish an integration
    with other software or databases. Products can also be created and enriched directly
    in the PIM environment, through the **graphical user interface** (**GUI**).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的图中所见，产品可以通过上传文件或实施特定的流程与其他软件或数据库建立集成，从而导入到PIM系统中。产品也可以直接在PIM环境中创建和丰富，通过**图形用户界面**（**GUI**）。
- en: Product data can then be exported to e-commerce or other software, or properly
    exported to files. In [*Chapter 14*](B17073_14_ePub_RK.xhtml#_idTextAnchor243),
    *Data Integration*, you will learn different ways to import and export products
    in Pimcore.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 产品数据可以随后导出到电子商务或其他软件，或者正确地导出到文件中。在[*第14章*](B17073_14_ePub_RK.xhtml#_idTextAnchor243)中，*数据集成*，你将学习在Pimcore中导入和导出产品的不同方法。
- en: To summarize, in this section, you learned about the concept of PIM and the
    benefits that a PIM system brings as regards to product data management and distribution.
    In the following section, we will build a `Product` entity step by step, defining
    a Pimcore class that will represent the product concept.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，你学习了PIM的概念以及PIM系统在产品数据管理和分发方面的好处。在下一节中，我们将逐步构建`Product`实体，定义一个代表产品概念的Pimcore类。
- en: Defining the Product Entity
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义产品实体
- en: In the previous section, you learned about the concept of Product Information
    Management. As the name suggests, in a PIM system, it's mandatory to create a
    class that represents the products, and this is what we are going to do in this
    section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，你学习了产品信息管理的概念。正如其名所示，在一个PIM系统中，创建一个代表产品的类是强制性的，这正是本节将要做的。
- en: Pimcore does not set any constraints as far as the concept of products is concerned,
    so we can simply create a class named `Product` and define all the attributes
    that reflect our needs. So, as you learned in [*Chapter 5*](B17073_05_ePub_RK.xhtml#_idTextAnchor093),
    *Exploring Objects and Classes*, just go through `Product`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Pimcore在产品概念方面没有设置任何约束，因此我们可以简单地创建一个名为`Product`的类，并定义所有反映我们需求的属性。所以，正如你在[*第5章*](B17073_05_ePub_RK.xhtml#_idTextAnchor093)中学习的，*探索对象和类*，只需通过`Product`即可。
- en: 'If you followed the instructions provided in the *Technical requirements* section,
    you should find an already defined `Product` class. Please note that this is just
    a typical example of the concept of a product and that you can add or remove class
    attributes according to your needs. You can see what this class looks like in
    the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循了*技术要求*部分提供的说明，你应该找到一个已经定义好的`Product`类。请注意，这只是一个典型的产品概念示例，你可以根据你的需求添加或删除类属性。你可以在下面的屏幕截图中看到这个类的样子：
- en: '![Figure 12.2: Product class'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.2: 产品类'
- en: '](img/Figure_12.02_B17073.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.02_B17073.jpg]'
- en: 'Figure 12.2: Product class'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：产品类
- en: 'Let''s describe the various class components that are shown in the previous
    screenshot. The class is composed of five panels that enclose different attributes
    representing common concepts for products, and these are outlined here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述前一个屏幕截图中显示的各种类组件。该类由五个面板组成，这些面板包围着代表产品常见概念的不同的属性，这些将在下面概述：
- en: '**Product Information**: In this panel, you can find the **Stock-Keeping Unit**
    (**SKU**), which is a unique identifier for products and the product price. Then,
    we added the product name and description as localized fields so that you can
    provide translations.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品信息**：在这个面板中，你可以找到**库存单位**（**SKU**），它是产品的唯一标识符以及产品价格。然后，我们添加了产品名称和描述作为本地化字段，以便你可以提供翻译。'
- en: '`brand` attribute is a custom-defined single select field with common brands
    as options; there''s also a predefined options list to choose the country where
    the product was made. The last attribute is a many-to-one relation with another
    class added to describe categories.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`brand`属性是一个自定义的单选字段，具有常见的品牌作为选项；还有一个预定义的选项列表，可以选择产品制造的国家。最后一个属性是与另一个类的一个多对一关系，用于描述类别。'
- en: '**Composition**: In this panel, you can find an advanced many-to-many relation
    component to relate the product to the materials that compose the product. In
    this relation, you can set the percentage of the various materials to define the
    composition.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组成**：在这个面板中，你可以找到一个高级的多对多关系组件，用于将产品与构成产品的材料相关联。在这个关系中，你可以设置各种材料的百分比来定义组成。'
- en: '`color` and `size`. For the `color` attribute, we have defined a relationship
    with a dedicated class.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`和`size`。对于`color`属性，我们定义了一个与专用类的关系。'
- en: '**Images**: As the name suggests, this panel is designed to contain the product
    images. In particular, we used a **Fieldcollection** to administer an undefined
    number of images.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图片**：正如其名所示，这个面板旨在包含产品图片。特别是，我们使用了一个**Fieldcollection**来管理未定义数量的图片。'
- en: 'For the sake of completeness, in the following screenshot, you will see the
    other class definitions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，在下面的屏幕截图中，你将看到其他类定义：
- en: '![Figure 12.3: Class definitions'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3：类定义'
- en: '](img/Figure_12.03_B17073.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.03_B17073.jpg)'
- en: 'Figure 12.3: Class definitions'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：类定义
- en: In the previous screenshot, you can see the definitions for the `Category`,
    `Material`, and `Color` classes. For the `Category` class, we have defined a unique
    `code` attribute and a couple of localized fields, called `name` and `description`.
    The same structure is made for the `Material` class, with the addition of another
    field to define the material typology. For the `Color` class, an attribute to
    set the **hexadecimal** (**hex**) value was added.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个屏幕截图中，您可以看到`Category`、`Material`和`Color`类的定义。对于`Category`类，我们定义了一个唯一的`code`属性和几个本地化字段，称为`name`和`description`。`Material`类采用了相同的结构，并增加了一个字段来定义材料类型。对于`Color`类，增加了一个设置**十六进制**（**hex**）值的属性。
- en: As previously mentioned, you should already find these classes after the installation
    process described in the *Technical requirements* section of this chapter, but
    you can import them at any time by selecting the files that you can find in the
    `src/classes` folder of the chapter repository, as you have seen in [*Chapter
    7*](B17073_07_ePub_RK.xhtml#_idTextAnchor129), *Administrating Pimcore Sites*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您应该已经在本章*技术要求*部分的安装过程之后找到了这些类，但您可以在任何时间通过选择您可以在章节存储库的`src/classes`文件夹中找到的文件来导入它们，正如您在[*第七章*](B17073_07_ePub_RK.xhtml#_idTextAnchor129)中看到的，*管理Pimcore站点*。
- en: 'As you have learned in [*Chapter 5*](B17073_05_ePub_RK.xhtml#_idTextAnchor093),
    *Exploring Objects and Classes*, you can easily perform data entry to create products
    and other entities. In the following screenshot, you can see an example of a created
    product:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[*第五章*](B17073_05_ePub_RK.xhtml#_idTextAnchor093)中学习的，*探索对象和类*，您可以轻松进行数据录入以创建产品和其它实体。在下面的屏幕截图中，您可以看到创建的产品示例：
- en: '![Figure 12.4: Product entity'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4：产品实体'
- en: '](img/Figure_12.04_B17073.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.04_B17073.jpg)'
- en: 'Figure 12.4: Product entity'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：产品实体
- en: As you can see in the previous screenshot, the structure of the created product
    reflects the class definition. To better organize the contents, objects of the
    various classes are divided into the corresponding subfolders.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前一个屏幕截图中看到的，创建的产品的结构反映了类定义。为了更好地组织内容，各种类的对象被分到了相应的子文件夹中。
- en: To summarize, in this section, we have seen how to define a `Product` entity.
    We have presented a possible implementation of the product concept, but this concept
    has no fixed definition in terms of attributes, so you can choose to create attributes
    that better reflect your needs. Beside from this, we have defined other secondary
    classes to relate the products to other concepts such as categories, materials,
    and colors. This is useful for keeping this information linked to a product without
    the need to replicate them in all products.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，我们学习了如何定义`Product`实体。我们展示了一个产品概念的可能的实现，但这个概念在属性方面没有固定的定义，因此您可以选择创建更符合您需求的属性。除此之外，我们还定义了其他次要类来关联产品与其它概念，如类别、材料和颜色。这对于将此类信息与产品关联起来非常有用，无需在所有产品中重复它们。
- en: In the following section, you will learn how to create product variants in order
    to create configurable products.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何创建产品变体以创建可配置产品。
- en: Creating product variants
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建产品变体
- en: 'In the previous section, you have seen how to define a `Product` entity and
    an example of product object creation. In this section, you will learn how to
    enable the inheritance for the `Product` class to create product variants and
    define configurable products. Later in this section, we will see some **PHP: Hypertext
    Preprocessor** (**PHP**) code examples that will show how to practically use variants
    during development.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您已经了解了如何定义一个`Product`实体以及创建产品对象的示例。在本节中，您将学习如何为`Product`类启用继承以创建产品变体和定义可配置产品。在本节的后面部分，我们将看到一些**PHP：超文本预处理器**（**PHP**）代码示例，这些示例将展示如何在开发过程中实际使用变体。
- en: 'To enable inheritance for the `Product` class, open the class definition and
    select the **General Settings** root element. You can enable class inheritance
    and allow the variants'' creation by selecting the checkboxes that you see in
    the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`Product`类启用继承，打开类定义并选择**常规设置**根元素。您可以通过选择以下屏幕截图中看到的复选框来启用类继承并允许创建变体：
- en: '![Figure 12.5: Enabling inheritance'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5：启用继承'
- en: '](img/Figure_12.05_B17073.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.05_B17073.jpg)'
- en: 'Figure 12.5: Enabling inheritance'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：启用继承
- en: 'As you can see in the previous screenshot, three checkboxes can be enabled,
    as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在先前的屏幕截图中所见，可以启用以下三个复选框：
- en: '**Allow inheritance**: If checked, this property enables inheritance among
    objects in a tree-structured way. The child objects can be instances of the same
    class or may belong to a different class.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许继承**：如果勾选此属性，则允许以树状结构在对象之间进行继承。子对象可以是同一类的实例，也可能属于不同的类。'
- en: '**Allow variants**: If checked, this enables the possibility to create object
    variants. The variant definition is a particular kind of inheritance. The variant
    class cannot be chosen, but the class is forced to be the same as the parent object.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许变体**：如果勾选，则启用创建对象变体的可能性。变体定义是一种特定的继承。不能选择变体类，但强制类与父对象相同。'
- en: '**Show variants in tree**: If enabled, this property allows you to see the
    variants in the object tree.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在树中显示变体**：如果启用，此属性允许您在对象树中查看变体。'
- en: Once you have enabled these checkboxes, you must click on the **Save** button
    to apply the changes. After having enabled variants for the class, variants can
    be created for products. To create a variant, just right-click on a previously
    created product, select **Add Variant**, and type the variant name.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您勾选了这些复选框，就必须单击**保存**按钮以应用更改。在为类启用变体后，可以为产品创建变体。要创建变体，只需在先前创建的产品上右键单击，选择**添加变体**，并输入变体名称。
- en: 'In the following screenshot, you will see an example of a configurable product
    with variants defined:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，您将看到一个具有定义变体的可配置产品的示例：
- en: '![Figure 12.6: Product variant example'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.6：产品变体示例](img/Figure_12.6_B17073.jpg)'
- en: '](img/Figure_12.06_B17073.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.06：示例图片](img/Figure_12.06_B17073.jpg)'
- en: 'Figure 12.6: Product variant example'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6：产品变体示例
- en: As you can see in the previous screenshot, enabling the corresponding property
    lets the product variants be shown in the object tree. You can recognize product
    variants by the different specific icons in the tree structure.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在先前的屏幕截图中所见，启用相应的属性可以让产品变体在对象树中显示。您可以通过树结构中的不同特定图标识别产品变体。
- en: The variants inherit all property values from the parent, but it's possible
    to override those properties in each variant. In this specific example, we have
    used the `Color`attribute to create a configurable product with different variants.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 变体继承父对象的所有属性值，但在每个变体中都可以覆盖这些属性。在具体示例中，我们使用了`颜色`属性来创建具有不同变体的可配置产品。
- en: Now that you have learned how to create product variants in the Pimcore interface,
    let's see how to practically use variants in code, looking at some coding examples.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何在 Pimcore 界面中创建产品变体，让我们看看如何在代码中实际使用变体，通过查看一些编码示例。
- en: 'A key aspect concerning variants is the object **type**. This is a system property
    defined for objects of all classes; this property cannot be filled manually, but
    it''s automatically defined when we create an element. There are three different
    object types, outlined as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 变体方面的一个关键方面是对象**类型**。这是一个为所有类的对象定义的系统属性；此属性不能手动填写，但在创建元素时自动定义。有三种不同的对象类型，如下所述：
- en: '`folder`: This type is assigned when we create a folder in the **Data Objects**
    section.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`文件夹`：当我们创建**数据对象**部分中的文件夹时，分配此类型。'
- en: '`object`: This type is assigned when we create an object instance of a class.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`对象`：当我们创建类的对象实例时，分配此类型。'
- en: '`variant`: This type is assigned when we create an object variant.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`变体`：当我们创建对象变体时，分配此类型。'
- en: When coding in Pimcore, it's important to know that all native methods that
    perform searches for lists of objects always consider only `folder` and `object`
    types, so it's necessary to explicitly specify that you want to retrieve variants.
    Through the following examples, we will see how to do this.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pimcore 中编码时，重要的是要知道，所有执行对象列表搜索的本地方法始终只考虑`文件夹`和`对象`类型，因此需要明确指定您想要检索变体。通过以下示例，我们将看到如何做到这一点。
- en: Parent PHP class
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 父 PHP 类
- en: In this first example, you will learn how to create a parent PHP class for the
    `Product` class and how to create a method to retrieve the product variants. The
    creation of this class is not strictly related to the concept of variants, but
    it's a feature that is worth discovering and that can be useful in different scenarios.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个示例中，您将学习如何为`Product`类创建父 PHP 类以及如何创建检索产品变体的方法。创建此类与变体概念没有直接关系，但它是一个值得发现的功能，可能在不同的场景中很有用。
- en: As we briefly introduced in the *Creating and Editing a Class Definition* section
    of [*Chapter 5*](B17073_05_ePub_RK.xhtml#_idTextAnchor093), *Exploring Objects
    and Classes*, for each class, there is the possibility of defining a custom parent
    PHP class. This can be any PHP class that directly or indirectly extends the `Pimcore\Model\DataObject\Concrete`
    class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[*第五章*](B17073_05_ePub_RK.xhtml#_idTextAnchor093)的*创建和编辑类定义*部分简要介绍的，在[*探索对象和类*]中，对于每个类，都有定义自定义父PHP类的可能性。这可以是任何直接或间接扩展`Pimcore\Model\DataObject\Concrete`类的PHP类。
- en: The `Concrete` class is a PHP class that is originally extended by all Pimcore
    classes and that contains all the common methods for all the classes, such as
    the `save` and `getById` operations, to cite a couple of them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Concrete`类是一个PHP类，它是所有Pimcore类的原始扩展，并包含所有类的公共方法，例如`save`和`getById`操作，仅举两例。'
- en: 'In the following code snippet, you will see an example `product` parent class
    with a defined method to retrieve product variants:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，您将看到一个定义了检索产品变体方法的`product`父类示例：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see in the previous code snippet, this class extends the previously
    mentioned `Concrete` class. In this class, we have created a `getVariants` method
    that invokes the original `getChildren` method, specifying the need to retrieve
    objects of the type `variant`. This is necessary because, as we said in the previous
    section, all listing methods consider only objects and folders if no types are
    directly specified.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码片段中所见，这个类扩展了之前提到的`Concrete`类。在这个类中，我们创建了一个`getVariants`方法，该方法调用原始的`getChildren`方法，并指定需要检索类型为`variant`的对象。这是必要的，因为我们之前提到，所有列表方法在未直接指定类型时，只考虑对象和文件夹。
- en: 'Once the PHP class is created, we must properly set the corresponding property
    in the `Product` class, as you can see in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了PHP类，我们必须在`Product`类中正确设置相应的属性，如以下屏幕截图所示：
- en: '![Figure 12.7: Configuring the parent PHP class'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 12.7: 配置父PHP类'
- en: '](img/Figure_12.07_B17073.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_12.07_B17073.jpg]'
- en: 'Figure 12.7: Configuring the parent PHP class'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：配置父PHP类
- en: As you can see in the previous screenshot, you may write the complete class
    namespace in the **Parent PHP Class** input. Once you have filled that in, you
    must click on the **Save** button to apply the changes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的屏幕截图中所见，您可以在**父PHP类**输入框中写入完整的类命名空间。一旦填写完毕，您必须点击**保存**按钮以应用更改。
- en: 'After having defined the parent PHP class, you can call the `getVariants` method
    for each product object instance, as you can see in the following code snippet:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了父PHP类之后，您可以为每个产品对象实例调用`getVariants`方法，如以下代码片段所示：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous code snippet, you can see that since the `Product` class extends
    the previously created `AbstractProduct` class, every product object can use the
    defined `getVariants` method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您可以看到，由于`Product`类扩展了之前创建的`AbstractProduct`类，每个产品对象都可以使用定义的`getVariants`方法。
- en: The `getChildre`n method that we have seen in this example is just one particular
    case of object listing. In the following example, we will see how to retrieve
    variants in common listing methods.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中我们看到的`getChildre`n方法只是对象列表的一个特例。在下面的例子中，我们将看到如何检索常见列表方法中的变体。
- en: Object Listing
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象列表
- en: In the previous example, we have seen how to retrieve the variants of a specific
    product, using the methods that retrieve the product children. In this example,
    we will see how to retrieve variants in generic listing methods.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了如何使用检索产品子对象的方法来检索特定产品的变体。在这个例子中，我们将看到如何在通用列表方法中检索变体。
- en: 'In the following code snippet, you can see how product variants can be retrieved
    on listing queries:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，您可以查看如何在列表查询中检索产品变体：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previous code snippet, you can see how to initialize a product listing.
    For listing objects, there is a specific method to set the object types that you
    want to retrieve. This method is the one that is used internally by the `getChildren`
    method you have seen in the previous example. The `load` method returns an array
    of objects that respect the listing conditions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您可以查看如何初始化产品列表。对于列表对象，有一个特定的方法来设置您想要检索的对象类型。这个方法就是您在前一个例子中看到的`getChildren`方法所使用的内部方法。`load`方法返回一个符合列表条件的对象数组。
- en: In these first two examples, you have learned how to retrieve existing variants.
    In the following example, you will see how to create a new variant instead.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个第一个示例中，您已经学习了如何检索现有变体。在下面的示例中，您将看到如何创建一个新的变体。
- en: Creating a new Variant
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的变体
- en: In the previous examples, you learned how to query for existing variants. In
    this example, you will learn how to create a product variant.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您学习了如何查询现有变体。在这个示例中，您将学习如何创建产品变体。
- en: 'In the following code snippet, you will see how to create a variant for an
    existing product:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，您将看到如何为现有产品创建一个变体：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see in the previous code snippet, first of all you have to get the
    product object. The retrieved product must be declared as the parent of the new
    product variant. Then, it's necessary to explicitly set the product type to declare
    that the created product is a variant.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码片段中所见，首先您必须获取产品对象。检索到的产品必须声明为新产品变体的父级。然后，必须显式设置产品类型以声明创建的产品是一个变体。
- en: In the example, you will note the use of the `getByName` method. This kind of
    method is automatically generated for each class attribute at class-definition
    save. The first argument is the value to search for, the second one is for localized
    fields (the language for which the value must be searched), and the third one
    is the limit parameter. If the limit is 1, a single object is returned; otherwise,
    the return type is an instance of the class listing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，您会注意到`getByName`方法的使用。这种类型的方法在类定义保存时自动为每个类属性生成。第一个参数是要搜索的值，第二个参数是本地化字段（必须搜索值的语言），第三个参数是限制参数。如果限制为1，则返回单个对象；否则，返回类型是类列表的实例。
- en: To summarize, in this section, you learned how to enable variants for the `Product`
    class and how to create product variants. Then, through some code examples, you
    learned how to retrieve existing variants and how to create new ones.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，您学习了如何为`Product`类启用变体以及如何创建产品变体。然后，通过一些代码示例，您学习了如何检索现有变体以及如何创建新的变体。
- en: In the following section, you will learn how to create bundled products and
    how to create a service that listens to events fired after certain operations
    are made—for example, to automatically calculate one or more product field values
    when a product is saved.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何创建捆绑产品以及如何创建一个在执行某些操作后触发事件的监听服务——例如，在产品保存时自动计算一个或多个产品字段值。
- en: Creating a Bundle Product
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建捆绑产品
- en: In the previous section, you learned how to enable and create product variants
    and how to practically use them in code examples. In this section, you will learn
    how to define bundle products.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您学习了如何启用和创建产品变体，以及如何在代码示例中实际使用它们。在本节中，您将学习如何定义捆绑产品。
- en: In marketing, the concept of **Product Bundling** is the practice of offering
    a set of individual products or services together as one combined product or service
    package. Typically, bundle products are intended to be kits or, more generically,
    a group of coherent products, with the advantage of a discounted price if bought
    together instead of buying them separately.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在市场营销中，**产品捆绑**的概念是将一组单独的产品或服务作为一个组合产品或服务包一起提供。通常，捆绑产品旨在作为套件或更普遍地，一组协调一致的产品，如果一起购买而不是单独购买，则具有折扣价格的优势。
- en: Through this chapter, we will first see how to modify our previously created
    `Product` class to define bundle products. Then, we will discover how to automatically
    perform operations once the product is saved to calculate the bundle price.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们将首先看到如何修改之前创建的`Product`类以定义捆绑产品。然后，我们将发现如何在产品保存后自动执行操作来计算捆绑价格。
- en: Defining bundle products
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义捆绑产品
- en: In this section, you will learn how to modify the `Product` class to be able
    to define bundle products. The easiest solution is to create a self-referenced
    relation attribute with the `Product` class itself. This will let you choose the
    products that will form the bundle from the previously created products.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何修改`Product`类以能够定义捆绑产品。最简单的解决方案是创建一个与`Product`类自身相关的自引用关系属性。这将让您能够从之前创建的产品中选择将构成捆绑的产品。
- en: 'To add this attribute, you need to perform the following instructions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加此属性，您需要执行以下操作：
- en: Open the `Product` class definition.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Product`类定义。
- en: Right-click on the **Product Information** panel and select **Add Data Component**
    | **Relation** | **Many-to-Many Object Relation**.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**产品信息**面板，然后选择**添加数据组件** | **关系** | **多对多对象关系**。
- en: Write `bundle_products` as the attribute name and `Bundle` `Products` as the
    attribute title.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将属性名称写为`bundle_products`，属性标题为`Bundle Products`。
- en: In the `Product` class.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Product`类中。
- en: In the `sku` and `name`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`sku`和`name`中。
- en: Click on the **Save** button to apply the changes.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**按钮以应用更改。
- en: 'In the following screenshot, you can see what the `Product` class should look
    like after these operations:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，您可以看到这些操作后`Product`类应该是什么样子：
- en: '![Figure 12.8: Bundle_Products Attribute'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8：Bundle_Products属性'
- en: '](img/Figure_12.08_B17073.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.08_B17073.jpg)'
- en: 'Figure 12.8: Bundle_Products Attribute'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：Bundle_Products属性
- en: As you can see in the previous screenshot, the new attribute is added at the
    bottom of the panel, and the desired visible fields are selected.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前一个屏幕截图中所见，新属性被添加到面板的底部，并且选定了所需的可见字段。
- en: 'Now that we have created this attribute, we can create a bundle product. To
    do that, simply create a new product object, then use the previously created relation
    attribute to select a couple of products that will compose the bundle product.
    Once you have selected these products they will appear in the relationship, as
    you can see in the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了此属性，我们可以创建一个捆绑产品。为此，只需创建一个新的产品对象，然后使用之前创建的关系属性选择几个将组成捆绑产品的产品。一旦选择了这些产品，它们将出现在关系中，如以下屏幕截图所示：
- en: '![Figure 12.9: Bundle Products relation'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.9：捆绑产品关系'
- en: '](img/Figure_12.09_B17073.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.09_B17073.jpg)'
- en: 'Figure 12.9: Bundle Products relation'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：捆绑产品关系
- en: As you can see in the previous screenshot, only the previously selected product
    fields are visible in the relation attribute.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前一个屏幕截图中所见，只有之前选定的产品字段在关系属性中可见。
- en: 'Now that we have defined which are the products that compose our bundle, we
    may want to automatically calculate the bundle price based on the price of the
    selected products. So we need to open the class definition and add a new numeric
    attribute to store the bundle price, as you can see in the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了组成我们捆绑产品的产品，我们可能希望根据所选产品的价格自动计算捆绑价格。因此，我们需要打开类定义并添加一个新的数值属性来存储捆绑价格，如以下屏幕截图所示：
- en: '![Figure 12.10: Bundle price attribute'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.10：捆绑价格属性'
- en: '](img/Figure_12.10_B17073.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.10_B17073.jpg)'
- en: 'Figure 12.10: Bundle price attribute'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：捆绑价格属性
- en: In the previous screenshot, you can see that this attribute is marked as **Not
    editable**, and this means that we need a method to calculate the bundle price.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个屏幕截图中，您可以看到此属性被标记为**不可编辑**，这意味着我们需要一个方法来计算捆绑价格。
- en: To summarize, in this section, you learned how to alter the `Product` class
    to define bundle products. In the following section, you will learn how to create
    a listener class that listens for an event fired by the product save operation,
    which will allow you to automatically calculate the bundle price.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，您学习了如何修改`Product`类以定义捆绑产品。在下一节中，您将学习如何创建一个监听器类，该类监听由产品保存操作触发的事件，这将允许您自动计算捆绑价格。
- en: Creating an Event Listener
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建事件监听器
- en: In the previous section, you learned how to define bundle products. In common
    scenarios, the price of a bundle product is less than the sum of the individual
    price of the products it's composed of. It may be useful to automatically calculate
    the price of a bundle product with a predefined rule, instead of manually inserting
    this value.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个章节中，您学习了如何定义捆绑产品。在常见场景中，捆绑产品的价格可能低于其组成的单个产品的总价。自动使用预定义的规则计算捆绑产品的价格可能很有用，而不是手动插入此值。
- en: In this section, you will learn how to create an event listener to capture events
    fired once the product is saved. The saving of an object is just one of the events
    that could be listened to in Pimcore, which includes all **create, read, update,
    and delete** (**CRUD**) operations on objects, assets, and documents, operations
    on users, the opening of search or grid lists, and many others.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何创建一个事件监听器以捕获产品保存后触发的事件。对象的保存只是Pimcore中可以监听的事件之一，它包括对对象、资产和文档的所有**创建、读取、更新和删除**（**CRUD**）操作，对用户的操作，搜索或网格列表的打开，以及其他许多操作。
- en: 'To create an event listener, you first need to register a new class in the
    `app/config/services.yml` file, as you can see in the following code snippet:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个事件监听器，你首先需要在`app/config/services.yml`文件中注册一个新的类，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see in the previous snippet, a new service can be defined by adding
    the class namespace. In the `tags` attribute, we must define one or more tags
    of our service. Each tag is composed of three properties, outlined as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个代码片段所示，可以通过添加类命名空间来定义一个新的服务。在`tags`属性中，我们必须定义我们的服务的一个或多个标签。每个标签由以下三个属性组成：
- en: '`name`: The name of the tag. We must provide the `kernel.event_listener` fixed
    value to let the service be correctly recognized as an event listener.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`名称`：标签的名称。我们必须提供`kernel.event_listener`固定值，以便服务能正确识别为事件监听器。'
- en: '`event`: Used to specify which event we want to listen to. In our case, we
    are interested in listening to the `postUpdate` event for objects. This event,
    as the name suggests, is fired after an object is saved.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`事件`：用于指定我们想要监听的事件。在我们的例子中，我们感兴趣的是监听对象的`postUpdate`事件。正如其名所示，该事件在对象保存后触发。'
- en: '`method`: In this property, we must put the name of the method of our class
    that will be called automatically when an event is fired.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`方法`：在这个属性中，我们必须放入我们的类中将被自动调用的方法名称。'
- en: For event listeners, each defined tag represents a specific event, so you must
    add one tag for each event that you want your service to listen to.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于事件监听器，每个定义的标签代表一个特定的事件，因此你必须为每个你希望你的服务监听的事件添加一个标签。
- en: 'Let''s now see how to implement the defined service to calculate the price
    of our bundle product. In the following code snippet, you will see a possible
    implementation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看如何实现定义的服务来计算我们捆绑产品的价格。在下面的代码片段中，你会看到一个可能的实现：
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's analyze the previous code snippet, to understand the key aspects. First
    of all, you may note that we have defined a method named `onObjectPostUpdate`,
    which is the name defined in the `services.yml` file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析前面的代码片段，以了解关键方面。首先，你可能注意到我们定义了一个名为`onObjectPostUpdate`的方法，这是在`services.yml`文件中定义的名称。
- en: This method takes the fired event as an argument, and from this event, we can
    extract the object that fired the event itself. As you may note, we must check
    for the object class to do the operations part only if the object is a product.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将触发事件作为参数，并从该事件中提取触发事件的本身对象。正如你可能注意到的，只有当对象是产品时，我们才必须检查对象类以执行操作部分。
- en: For each product that composes the bundle, we add up the product prices, and
    in the end, we decrease this sum by 20%. Please note that this is just an example
    and that you can define your own rule.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构成捆绑的每个产品，我们将产品价格相加，最后从这个总和减少20%。请注意，这只是一个示例，你可以定义自己的规则。
- en: To avoid a circular loop on product saves, we save the product only in cases
    where the new calculated price is different from the previous one. If we omit
    this check, the save operation made on this service will fire the event again.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免产品保存时的循环，我们只在新的计算价格与之前的价格不同时保存产品。如果我们省略这个检查，对这个服务进行的保存操作将再次触发事件。
- en: To summarize, in this section, you learned about the concept of product bundling
    and how to change the `Product` class by adding attributes that allow you to define
    bundle products. Later, you learned how to create an event listener service to
    capture events fired by operations on objects, such as the saving of a product.
    In the provided example, you have seen how to automatically calculate the price
    of a bundle product.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，你了解了产品捆绑的概念以及如何通过添加允许你定义捆绑产品的属性来更改`Product`类。后来，你学习了如何创建事件监听器服务来捕获由对象操作（如产品保存）触发的事件。在提供的示例中，你看到了如何自动计算捆绑产品的价格。
- en: In the following section, you will learn how to extend the `Product` class to
    manage different types of products without the need to create a specific class
    for each product.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，你将学习如何扩展`Product`类来管理不同类型的产品，而无需为每个产品创建一个特定的类。
- en: Managing different Product Types
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理不同产品类型
- en: In the previous section, you learned how to define bundle products. In this
    section, you will learn how to manage different types of products without creating
    a different class for each product type. If you need to manage a heterogeneous
    set of products, such as shirts and shoes, you will probably need specific attributes
    to better represent these concepts.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了如何定义捆绑产品。在本节中，你将学习如何管理不同类型的产品，而无需为每种产品类型创建一个不同的类。如果你需要管理一个异构的产品集，例如衬衫和鞋子，你可能需要特定的属性来更好地表示这些概念。
- en: Surely, we could create two different classes for shirts and shoes, but we will
    need to define redundant fields for both classes to describe properties that are
    shared between them—for example, the title, price, description, and so on.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以为衬衫和鞋子创建两个不同的类，但我们需要为这两个类定义冗余字段来描述它们之间共享的属性——例如，标题、价格、描述等。
- en: In [*Chapter 5*](B17073_05_ePub_RK.xhtml#_idTextAnchor093), *Exploring Objects
    and Classes*, we introduced the concept of **Objectbricks**. With Objectbricks,
    we just need to create little sets of attributes to describe specific fields and
    allow our class to dynamically add these bricks. As the name suggests, class objects
    can be composed of one or more bricks added to the common attributes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B17073_05_ePub_RK.xhtml#_idTextAnchor093)，“探索对象和类”，我们介绍了**Objectbricks**的概念。使用Objectbricks，我们只需要创建一些属性的小集合来描述特定的字段，并允许我们的类动态地添加这些砖块。正如其名所示，类对象可以由一个或多个添加到公共属性中的砖块组成。
- en: 'Before creating Objectbrick definitions, we need to create an attribute in
    the `Product` class to accommodate the various bricks. To create this attribute,
    just right-click on a panel component inside the class definition and select **Add
    Data Component** | **Structured** | **Objectbricks**, fill in the attribute name,
    and click on the **Save** button to apply the changes. In the following screenshot,
    you can see an example of this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Objectbrick定义之前，我们需要在`Product`类中创建一个属性来容纳各种砖块。要创建此属性，只需在类定义内部右键单击面板组件，然后选择**添加数据组件**
    | **结构化** | **Objectbricks**，填写属性名称，然后单击**保存**按钮以应用更改。在下面的屏幕截图中，你可以看到一个示例：
- en: '![Figure 12.11: Objectbricks attribute'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.11：Objectbricks属性'
- en: '](img/Figure_12.11_B17073.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.11_B17073.jpg)'
- en: 'Figure 12.11: Objectbricks attribute'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：Objectbricks属性
- en: As you can see in the previous screenshot, we have created an attribute of the
    **Objectbricks** type. As an optional property, we can set the maximum number
    of bricks that can be attached to each object.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，我们已创建了一个**Objectbricks**类型的属性。作为一个可选属性，我们可以设置每个对象可以附加的最大砖块数。
- en: 'Now that we have defined the attribute in the `Product` class, we can define
    one or more Objectbricks. To do that, just go through **Settings** | **Data Objects
    | Objectbricks**. To add a new Objectbricks definition, you just need to click
    on the **Add** button, write the name of your brick, and click on the **OK** button.
    In the following screenshot, you can see an example of a created Objectbrick:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在`Product`类中定义了属性，我们可以定义一个或多个Objectbricks。要做到这一点，只需通过**设置** | **数据对象 |
    Objectbricks**。要添加新的Objectbricks定义，只需单击**添加**按钮，写下你的砖块名称，然后单击**确定**按钮。在下面的屏幕截图中，你可以看到一个创建的Objectbrick的示例：
- en: '![Figure 12.12: Objectbrick definition'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.12：Objectbrick定义'
- en: '](img/Figure_12.12_B17073.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.12_B17073.jpg)'
- en: 'Figure 12.12: Objectbrick definition'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：Objectbrick定义
- en: As you can see in the previous screenshot, the Objectbricks definition panel
    is the same as the class creation one. Besides, for Objectbricks, we can select
    the classes and the specific attributes to attach the Objectbrick to. In this
    example, we have attached the Objectbrick to the `Product` class, and we have
    selected the previously created attribute.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，Objectbricks定义面板与类创建面板相同。此外，对于Objectbricks，我们可以选择要附加Objectbrick的类和特定属性。在这个例子中，我们将Objectbrick附加到了`Product`类，并选择了之前创建的属性。
- en: 'Once the Objectbricks are defined, we can attach them to the product objects.
    In the following screenshot, you can see what the Objectbrick looks like in the
    product object:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了Objectbricks，我们就可以将它们附加到产品对象上。在下面的屏幕截图中，你可以看到Objectbrick在产品对象中的样子：
- en: '![Figure 12.13: Objectbrick instance'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.13：Objectbrick实例'
- en: '](img/Figure_12.13_B17073.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.13_B17073.jpg)'
- en: 'Figure 12.13: Objectbrick instance'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：Objectbrick实例
- en: As you can see in the previous screenshot, in the product objects, the Objectbricks
    appear as a specific section. You can attach one or more Objectbricks to every
    object since the defined limit is reached, and every kind of Objectbrick can be
    attached once within the same objects.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，在产品对象中，Objectbricks 以一个特定的部分出现。由于已达到定义的限制，您可以给每个对象附加一个或多个 Objectbricks，并且每种类型的
    Objectbrick 都可以在同一对象中附加一次。
- en: To summarize, in this section, you learned how to manage different types of
    products using Objectbricks. Objectbricks can be considered as subsets of attributes
    that can be attached to classes to extend the class concept with extra attributes.
    For the `Product` class, for example, we can think about creating specific attributes
    for shirts, shoes, and so on.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，您学习了如何使用 Objectbricks 管理不同类型的产品。Objectbricks 可以被视为可以附加到类上以扩展类概念的属性子集。例如，对于
    `Product` 类，我们可以考虑为衬衫、鞋子等创建特定的属性。
- en: In the next section, you will learn how to configure a workflow that will let
    you control the completeness of the product information, step by step.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何配置一个工作流，这将让您逐步控制产品信息的完整性。
- en: Working with workflows
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与工作流一起工作
- en: A workflow consists of a sequence of processes and tasks that represent the
    work that must be done to reach a common goal. Typically, we may think about workflows
    as a graph.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流由一系列代表达到共同目标必须完成的工作的过程和任务组成。通常，我们可能会将工作流视为一个图。
- en: 'Pimcore Workflow Management provides configurations of multiple workflows on
    assets, documents, data objects, to support data maintenance processes, element
    life cycles, and various other processes. Pimcore workflows are based on the Symfony
    workflow component and extend it with specific features. Before starting the configuration
    of a Pimcore workflow, let''s describe the basics concepts of the Symfony workflow
    component, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Pimcore 工作流管理提供了对资产、文档、数据对象上的多个工作流的配置，以支持数据维护过程、元素生命周期以及各种其他过程。Pimcore 工作流基于
    Symfony 工作流组件，并扩展了其特定功能。在开始配置 Pimcore 工作流之前，让我们描述以下 Symfony 工作流组件的基本概念：
- en: '**Workflow Type ''Workflow''**: This is the default type of workflow and allows
    you to model a workflow net that is a subclass of a petri net. For this kind of
    workflow, an element can be in several states of the workflow at the same time.'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**工作流类型 ''Workflow''**：这是默认的工作流类型，允许您建模一个作为Petri网子类的工作流网。对于此类工作流，一个元素可以在工作流的几个状态中同时存在。'
- en: '**Workflow Type ''State Machine''**: A state machine is a subset of a workflow
    and its purpose is to hold a state of your model. A state machine cannot be in
    more than one place simultaneously.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**工作流类型 ''状态机''**：状态机是工作流的一个子集，其目的是保持模型的状态。状态机不能同时在多个地方存在。'
- en: '**Place**: A place is a step in a workflow and describes a characteristic or
    status of an element. Depending on the place, an element may appear in a specific
    view—for example, to have a focus on translations only. We will have a look at
    how to create a custom layout for a Pimcore class in the following section.'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**位置**：位置是工作流中的一个步骤，描述了元素的特征或状态。根据位置，元素可能出现在特定的视图中——例如，仅关注翻译。在下一节中，我们将探讨如何为
    Pimcore 类创建自定义布局。'
- en: '**Marking Store**: The marking store stores the current place(s) for each element.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**标记存储**：标记存储存储每个元素的当前位置（s）。'
- en: '**Transition**: A transition describes the action that is performed to move
    from one place to another. Transitions may be allowed or not, depending on additional
    criteria, and may require additional notes and information entered by the user.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**过渡**：过渡描述了从一处移动到另一处所执行的操作。过渡可能允许或不允许，这取决于额外的标准，并且可能需要用户输入的额外注释和信息。'
- en: '**Transition Guard**: Defines a criterion that defines whether a transition
    is currently allowed or not.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**过渡守卫**：定义了一个标准，用于确定是否允许当前进行过渡。'
- en: By reading the following sections, you will learn how to properly configure
    a Pimcore workflow. We will start by defining a custom layout for the `Product`
    class and will then see how to set up a workflow that will guide the completion
    of product information.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读以下章节，您将学习如何正确配置 Pimcore 工作流。我们将首先定义 `Product` 类的定制布局，然后我们将看到如何设置一个将指导产品信息完成的工作流。
- en: Configuring a Custom Layout
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置自定义布局
- en: As mentioned before, in the various places of a workflow we can show a custom
    view for the element. This is made possible by configuring custom layouts on the
    corresponding class.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在工作流程的各个地方，我们可以为元素显示自定义视图。这是通过在相应的类上配置自定义布局来实现的。
- en: 'To create a custom layout, just open the class definition and click on the
    **Configure custom layouts** button. When that button is clicked, a new modal
    window is opened, and you can add a new custom layout or load a previously created
    one. To create a new layout, just click on the **Add** button. In the modal that
    will open, you can write the new layout name and **identifier** (**ID**), as you
    can see in the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自定义布局，只需打开类定义并点击**配置自定义布局**按钮。当点击该按钮时，将打开一个新的对话框，您可以在其中添加一个新的自定义布局或加载之前创建的一个。要创建新布局，只需点击**添加**按钮。在将打开的对话框中，您可以写下新的布局名称和**标识符**（**ID**），如以下屏幕截图所示：
- en: '![Figure 12.14: Creating a Custom Layout'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.14：创建自定义布局](img/Figure_12.14_B17073.jpg)'
- en: '](img/Figure_12.14_B17073.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_12.14_B17073.jpg)'
- en: 'Figure 12.14: Creating a Custom Layout'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：创建自定义布局
- en: As you can see in the previous screenshot, to add a new custom layout you just
    need to fill in the **Name** and **Unique identifier** fields and click on the
    **OK** button to confirm.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的屏幕截图中所见，要添加新的自定义布局，只需填写**名称**和**唯一标识符**字段，然后点击**确定**按钮进行确认。
- en: 'Once you have initialized the custom layout, you can specify which attributes
    you want to show in the layout itself. In the following screenshot, you can see
    how this configuration can be done:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您初始化了自定义布局，您就可以指定您想在布局中显示哪些属性。在以下屏幕截图中，您可以查看如何进行此配置：
- en: '![Figure 12.15: Custom Layout Configuration'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.15：自定义布局配置](img/Figure_12.15_B17073.jpg)'
- en: '](img/Figure_12.15_B17073.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_12.15_B17073.jpg)'
- en: 'Figure 12.15: Custom Layout Configuration'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15：自定义布局配置
- en: As you can see in the previous screenshot, the configuration modal is composed
    of two main panels. In the left panel, you will find the previously defined class
    structure, while in the right panel, you can drag and drop the attributes you
    want to show in the custom layout from the left panel.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的屏幕截图中所见，配置对话框由两个主要面板组成。在左侧面板中，您将找到之前定义的类结构，而在右侧面板中，您可以从左侧面板拖放您想在自定义布局中显示的属性。
- en: For each attribute, you can decide to change some properties, such as the possibility
    to edit the attribute itself. Once you have configured the custom layout, you
    can click on the **Save** button to apply the changes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个属性，您可以决定更改一些属性，例如是否可以编辑该属性本身。一旦您配置了自定义布局，您就可以点击**保存**按钮来应用更改。
- en: Now that you have seen how to configure custom layouts, let's see how to use
    them in a workflow configuration.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了如何配置自定义布局，让我们看看如何在工作流程配置中使用它们。
- en: Configuring a Pimcore workflow
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Pimcore工作流程
- en: In the previous section, you learned how to configure custom layouts for Pimcore
    classes. In this section, you will learn how to configure Pimcore workflows and
    how to use the previously created custom layouts.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您学习了如何为Pimcore类配置自定义布局。在本节中，您将学习如何配置Pimcore工作流程以及如何使用之前创建的自定义布局。
- en: As with many other services, Pimcore workflows must be defined in the `config.yaml`
    file of the Pimcore project or the same file of a specific bundle. In this section,
    you will learn how to properly configure a workflow.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他服务一样，Pimcore工作流程必须在Pimcore项目的`config.yaml`文件或特定包的相同文件中定义。在本节中，您将学习如何正确配置工作流程。
- en: 'In the following code snippet, you will see how to initialize the workflow
    configuration:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，您将看到如何初始化工作流程配置：
- en: '[PRE8]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see in the preceding snippet, to initialize a workflow you must add
    the `workflows` keyword under the `pimcore` keyword. Then, you must add a unique
    ID for the workflow, which is `product_workflow` in our example.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码片段中所见，要初始化工作流程，您必须在`pimcore`关键字下添加`workflows`关键字。然后，您必须为工作流程添加一个唯一的ID，在我们的例子中是`product_workflow`。
- en: 'At the lower level, you can define some parameters, which are provided here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在较低级别，您可以定义一些参数，这些参数在此提供：
- en: '`label`: The workflow title.'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`label`：工作流程标题。'
- en: '`type`: The workflow type, which can be `workflow` or `state_machine`, as described
    in the chapter introduction.'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`type`：工作流程类型，可以是`workflow`或`state_machine`，如章节介绍中所述。'
- en: '`supports`: One or more classes to which the workflow is applied.'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`supports`：工作流程应用到的一个或多个类。'
- en: '`marking_store`: For `state_machine` workflows, you can specify which attribute
    of the class must be used to store the workflow state. If that attribute is a
    picklist attribute, you can let the class dynamically create the picklist options
    by reading the workflow states by defining the options provider, as you can see
    in the following screenshot:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`marking_store`：对于`state_machine`工作流程，您可以指定必须使用类的哪个属性来存储工作流程状态。如果该属性是选择列表属性，您可以通过定义选项提供者，通过读取工作流程状态来让类动态创建选择列表选项，就像您在下面的屏幕截图中所看到的那样：'
- en: '![Figure 12.16: Workflow states options provider'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.16：工作流程状态选项提供者'
- en: '](img/Figure_12.16_B17073.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.16](img/Figure_12.16_B17073.jpg)'
- en: 'Figure 12.16: Workflow states options provider'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16：工作流程状态选项提供者
- en: 'As you can see in the previous screenshot, you can fill in the `places` keyword,
    as you can see in the following snippet:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在之前的屏幕截图中所看到的那样，您可以填写`places`关键字，就像您在下面的代码片段中所看到的那样：
- en: '[PRE9]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see in the previous code snippet, you can add one or more states
    behind the `places` keyword. For each state, you must specify a unique ID and
    define a label and a color that will be used to highlight the label text. If you
    want to restrict the visible class attributes for a particular state, you may
    specify a previously defined custom layout in the `objectLayout` keyword behind
    `permissions`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在之前的代码片段中所看到的那样，您可以在`places`关键字后面添加一个或多个状态。对于每个状态，您必须指定一个唯一的ID并定义一个标签和颜色，该颜色将用于突出显示标签文本。如果您想限制特定状态的可见类属性，您可以在`permissions`关键字后面的`objectLayout`关键字中指定一个先前定义的自定义布局。
- en: 'The last step in the workflow configuration is to define transitions between
    different states. You can see how to define transitions in the following code
    snippet:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程配置的最后一步是定义不同状态之间的过渡。您可以在下面的代码片段中查看如何定义过渡：
- en: '[PRE10]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see in the previous snippet, the transitions must be defined behind
    the `transitions` keyword. For each transition, you must define a unique ID; then,
    you must specify one or more states from which the transition can start and one
    destination state only. In the following screenshot, you can see how a transition
    can be invoked:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在之前的代码片段中所看到的那样，过渡必须在`transitions`关键字后面定义。对于每个过渡，您必须定义一个唯一的ID；然后，您必须指定一个或多个起始状态和一个目标状态。在下面的屏幕截图中，您可以查看如何调用过渡：
- en: '![Figure 12.17: Invoking workflow transitions'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.17：调用工作流程过渡'
- en: '](img/Figure_12.17_B17073.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.17](img/Figure_12.17_B17073.jpg)'
- en: 'Figure 12.17: Invoking workflow transitions'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17：调用工作流程过渡
- en: As you can see in the previous screenshot, a grouped button is automatically
    injected into the object editor to let you select the available transitions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在之前的屏幕截图中所看到的那样，一个分组按钮会自动注入到对象编辑器中，以便您选择可用的过渡。
- en: If needed, you can also specify a `guard` function that is automatically invoked
    when the workflow is placed in one of the `from` states. If the `guard` function
    does not pass, it will not be possible to apply the transition and move to the
    destination state. In this specific example, you can let the user edit the images
    only after the transitions are completed. A transition guard must be a function
    of the object, so the best solution is to create this function in the parent PHP
    class that we mentioned in the *Creating product variants* section of this chapter.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您还可以指定一个`guard`函数，当工作流程放置在`from`状态之一时，该函数会自动调用。如果`guard`函数未通过，则无法应用过渡并移动到目标状态。在这个特定示例中，您可以让用户在过渡完成后仅编辑图像。过渡守卫必须是对象的一个函数，因此最好的解决方案是在本章*创建产品变体*部分提到的父PHP类中创建此函数。
- en: 'Optionally, you can also specify some extra options on a transition, such as
    setting up a custom icon for the transition or letting the user write a note when
    the transition is invoked, as you can see in the following screenshot:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，您还可以在过渡上指定一些额外选项，例如为过渡设置自定义图标或让用户在调用过渡时写下注释，就像您在下面的屏幕截图中所看到的那样：
- en: '![Figure 12.18: Notes on transition'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.18：过渡说明'
- en: '](img/Figure_12.18_B17073.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.18](img/Figure_12.18_B17073.jpg)'
- en: 'Figure 12.18: Notes on transition'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18：过渡说明
- en: As you can see in the previous screenshot, when the user clicks on the transition
    action, a modal will open and the user can write a comment that will be stored
    in the **Notes & Events** section inside the object, and then click on the **Perform
    Action** button to complete the transition.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在之前的屏幕截图中所看到的那样，当用户点击过渡操作时，会打开一个模态窗口，用户可以写下将被存储在对象内部的**笔记与事件**部分的注释，然后点击**执行操作**按钮来完成过渡。
- en: To summarize, in this section, you learned how to configure a Pimcore workflow.
    By defining custom layouts, you can force users to fill in product information
    step by step, to ensure data completion. In particular, you learned how to define
    places for the workflow and how to configure workflow transitions.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，你学习了如何配置Pimcore工作流。通过定义自定义布局，你可以强制用户逐步填写产品信息，以确保数据完整性。特别是，你学习了如何定义工作流的位置以及如何配置工作流转换。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the concept of `Product` entity and providing
    practical examples. In the first section of the chapter, you learned what a PIM
    is and what its main features are. Then, you learned how to create and configure
    a `Product` class, according to your needs.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了`Product`实体的概念，并通过实际示例进行了介绍。在章节的第一部分，你学习了PIM是什么以及它的主要特性。然后，你学习了如何根据你的需求创建和配置`Product`类。
- en: After having defined the `Product` class, you learned how to enable inheritance
    for the class and how to define product variants for an existing product. Through
    practical code examples, you also learned how to retrieve variants on listings
    and how to create new product variants.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`Product`类之后，你学习了如何为该类启用继承以及如何为现有产品定义产品变体。通过实际代码示例，你还学习了如何在列表中检索变体以及如何创建新的产品变体。
- en: Later in this chapter, you learned about the concept of product bundling and
    how to add new fields to the `Product` class to let you define bundle products.
    Then, you learned how to create an event listener service to listen to events
    fired by the objects—for example, to catch once the product is saved. In particular,
    you have seen a code example showing how to calculate the price of a bundle product.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，你学习了产品捆绑的概念以及如何向`Product`类添加新字段以定义捆绑产品。然后，你学习了如何创建事件监听服务来监听由对象触发的事件——例如，当产品被保存时。特别是，你看到了一个代码示例，展示了如何计算捆绑产品的价格。
- en: After that, you learned how to use Objectbricks to extend the `Product` class,
    attaching groups of attributes useful to define specific concepts. This is useful
    if you want to represent different kinds of products without creating a class
    for each kind, to avoid the redundancy of common attributes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你学习了如何使用Objectbricks扩展`Product`类，附加一组有助于定义特定概念的属性。如果你想要表示不同种类的产品而不为每种产品创建一个类，以避免常见属性的冗余，这非常有用。
- en: In the last section, you learned how to configure custom layouts for Pimcore
    classes and how to use them in Pimcore workflow configurations. Through a concrete
    example, you learned how to configure a workflow to fill in product information
    step by step.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，你学习了如何为Pimcore类配置自定义布局以及如何在Pimcore工作流配置中使用它们。通过一个具体示例，你学习了如何配置一个工作流以逐步填写产品信息。
- en: In the next chapter, you will learn how to expose products and other entities
    to the outside through the Pimcore Datahub bundle and how to turn Pimcore into
    a **Master Data Management** (**MDM**) platform.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何通过Pimcore Datahub捆绑将产品和其他实体暴露给外部，以及如何将Pimcore转变为**主数据管理**（**MDM**）平台。
