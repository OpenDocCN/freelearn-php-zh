- en: Chapter 7. Backend Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。后端开发
- en: '**Backend development** is a term that is most commonly used to describe work
    closely related to the server side. This usually implies the actual server, application
    code, and the database. For example, if we open a storefront of a web shop, add
    a few products to the cart, and then check out, the application will store the
    information provided. This information is managed on a server with a server-side
    language, such as PHP, and then saved in a database. In [Chapter 4](part0028_split_000.html#QMFO2-818f5224668745eb9070ddf1d85e6bfa
    "Chapter 4. Models and Collections"), *Models and Collections*, we took a look
    at the backbone of backend development. In this chapter, we will explore other
    backend-related aspects.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**后端开发** 是一个最常用来描述与服务器端紧密相关的工作的术语。这通常意味着实际的服务器、应用程序代码和数据库。例如，如果我们打开一个网络商店的店面，向购物车添加几个产品，然后结账，应用程序将存储提供的信息。这些信息由一个使用服务器端语言（如PHP）的服务器管理，然后保存在数据库中。在
    [第4章](part0028_split_000.html#QMFO2-818f5224668745eb9070ddf1d85e6bfa "第4章。模型和集合")，*模型和集合*中，我们探讨了后端开发的框架。在本章中，我们将探讨其他与后端相关的方面。'
- en: 'We will use the `Foggyline_Office` module that was defined in one of the previous
    chapters as we go through the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨以下主题时，我们将使用在第几章中定义的 `Foggyline_Office` 模块：
- en: Cron jobs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cron` 作业'
- en: Notification messages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知消息
- en: Sessions and cookies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话和cookies
- en: Logging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录日志
- en: The profiler
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析器
- en: Events and observers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件和观察者
- en: Caches
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Widgets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件
- en: Custom variables
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义变量
- en: i18n (internationalization)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: i18n（国际化）
- en: Indexers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引器
- en: These individual isolated units of functionality are mostly used in everyday
    backend-related development.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能独立的单元通常用于日常后端相关开发。
- en: Cron jobs
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`cron` 作业'
- en: Speaking of `cron` jobs, it is worth noting one important thing. A `Magento
    cron` job is not the same as an operating system `cron` job. An operating system
    `cron` is driven by a `crontab` (short for `cron` table) file. The `crontab` file,
    is a configuration file that specifies shell commands that need to be run periodically
    on a given schedule.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到 `cron` 作业，有一点很重要。`Magento cron` 作业与操作系统的 `cron` 作业不同。操作系统的 `cron` 由一个 `crontab`（即
    `cron` 表）文件驱动。`crontab` 文件是一个配置文件，它指定了需要在给定的时间表上定期运行的shell命令。
- en: A `Magento cron` job is driven by a periodic execution of PHP code that handles
    entries in the `cron_schedule` table. The `cron_schedule` table is where `Magento
    cron` jobs are queued once they are picked up from the individual `crontab.xml`
    file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magento cron` 作业由定期执行处理 `cron_schedule` 表条目的PHP代码驱动。`cron_schedule` 表是 `Magento
    cron` 作业从单个 `crontab.xml` 文件中提取后排队的地方。'
- en: The `Magento cron` jobs cannot be executed without the operating system `cron`
    job being set to execute the `php bin/magento cron:run` command. Ideally, an operating
    system `cron` job should be set to trigger `Magento's cron:run` every minute.
    `Magento` will then internally execute its `cron` jobs according to the way an
    individual `cron` job is defined in the `crontab.xml` file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magento` 的 `cron` 作业无法在没有将操作系统的 `cron` 作业设置为执行 `php bin/magento cron:run`
    命令的情况下执行。理想情况下，应该设置一个操作系统的 `cron` 作业，使其每分钟触发 `Magento` 的 `cron:run`。然后，`Magento`
    将根据在 `crontab.xml` 文件中定义的每个单独的 `cron` 作业的方式内部执行其 `cron` 作业。'
- en: 'To define a new `cron` job in `Magento cron`, we first need to define a `crontab.xml`
    file in the module. Let''s create a `app/code/Foggyline/Office/etc/crontab.xml`
    file with the following content:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `Magento cron` 中定义一个新的 `cron` 作业，我们首先需要在模块中定义一个 `crontab.xml` 文件。让我们创建一个
    `app/code/Foggyline/Office/etc/crontab.xml` 文件，内容如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the `XSD` schema location points to `crontab.xsd` from within the
    `Magento_Cron` module.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`XSD` 架构位置指向 `Magento_Cron` 模块内的 `crontab.xsd`。
- en: The `id` attribute of a `group` element is set to the `default` value. In its
    modules, `Magento` defines two different groups, namely default and index. We
    used the `default` value, as this is the one that gets executed when the standard
    `php bin/magento cron:run` command is triggered on the console.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`group` 元素的 `id` 属性被设置为 `default` 默认值。在其模块中，`Magento` 定义了两个不同的组，即默认和索引。我们使用了
    `default` 值，因为这是在控制台触发标准的 `php bin/magento cron:run` 命令时执行的那个值。'
- en: Within the `group` element, we have individual jobs defined under the `job`
    element. The `job` element requires us to specify the `name`, `instance`, and
    `method` attributes. The `name` attribute has to be unique within the `group`
    element. The value of the `instance` and `method` attributes should point to the
    class that will be instantiated and the method within the class that needs to
    be executed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在`group`元素内，我们在`job`元素下定义了单独的作业。`job`元素要求我们指定`name`、`instance`和`method`属性。`name`属性必须在`group`元素内是唯一的。`instance`和`method`属性的值应指向将被实例化的类以及需要在该类中执行的方法。
- en: The `schedule` element nested within the `cron` job specifies the desired time
    of job execution. It uses the same time expression as that of the entries in an
    operating system `crontab` file. The specific example that we will look at defines
    an expression (`*/2 * * * *`) that is executed every two minutes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cron`作业中嵌套的`schedule`元素指定了作业期望的执行时间。它使用与操作系统`crontab`文件中的条目相同的时间表达式。我们将查看的特定示例定义了一个每两分钟执行一次的表达式（`*/2
    * * * *`）。
- en: 'Once we have defined the `crontab.xml` file, we need to define the `Foggyline\Office\Model\Cron`
    class file, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了`crontab.xml`文件，我们需要定义`Foggyline\Office\Model\Cron`类文件，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code simply defines a `logHello` method used by the `cron` job.
    In the `logHello` method, we used the `logger` method that was instantiated via
    the constructor. The `logger` method will make a log entry in the `var/log/system.log`
    file once it is executed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码简单地定义了一个由`cron`作业使用的`logHello`方法。在`logHello`方法中，我们使用了通过构造函数实例化的`logger`方法。一旦执行，`logger`方法将在`var/log/system.log`文件中创建一个日志条目。
- en: Once the command is executed, you will see the `Ran` jobs by schedule message
    in the console. Additionally, the `cron_schedule` table should get filled with
    all the `Magento cron` jobs that were defined.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令执行，你将在控制台看到按计划运行的`Ran`作业消息。此外，`cron_schedule`表应该填充所有已定义的`Magento cron`作业。
- en: At this point, we should trigger the `php bin/magento cron:run` command in the
    console.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该在控制台触发`php bin/magento cron:run`命令。
- en: 'The `cron_schedule` table contains the following columns:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`cron_schedule`表包含以下列：'
- en: '`schedule_id`: The auto-increment `primary` field.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schedule_id`：自增`primary`字段。'
- en: '`job_code`: The value of the job `name` attribute, as defined in `crontab.xml`
    file, which equals to `foggyline_office_logHello` table in our example.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`job_code`：在`crontab.xml`文件中定义的作业`name`属性的值，在我们的例子中等于`foggyline_office_logHello`表。'
- en: '`status`: Defaults to the pending value for the newly created entries in the
    table and allows for a `pending`, `running`, `success`, `missed` or `error` value.
    Its value changes as the `cron` job traverses through its life cycle.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`：默认为表中新创建条目的待处理值，允许有`pending`、`running`、`success`、`missed`或`error`值。其值会随着`cron`作业在其生命周期中的变化而改变。'
- en: '`messages`: Stores the possible exception error message if the exception has
    occurred during a job''s execution.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`messages`：存储在作业执行过程中发生的异常错误消息（如果发生异常）。'
- en: '`created_at`: The `timestamp` value that denotes when a job was created.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created_at`：表示作业创建的时间戳值。'
- en: '`scheduled_at`: The `timestamp` value that denotes when a job was scheduled
    for execution.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scheduled_at`：表示作业计划执行的时间戳值。'
- en: '`executed_at`: The `timestamp` value that denotes when a job''s execution started.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`executed_at`：表示作业执行开始的时间戳值。'
- en: '`finished_at`: The `timestamp` value that denotes when a job has finished executing.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finished_at`：表示作业执行完成的时间戳值。'
- en: 'Unless we have already set the operating system `cron` to trigger the `php
    bin/magento cron:run` command, we need to trigger it on our own a few times every
    two minutes in order to actually execute the job. The first time a command is
    run, if the job does not exist in the `cron_schedule` table, `Magento` will merely
    queue it, but it won''t execute it. The subsequent `cron` runs will execute the
    command. Once we are sure that the `cron` job entry in the `cron_schedule` table
    has the `finished_at` column value filled, we will see an entry that looks like
    `[2015-11-21 09:42:18] main.INFO: Hello from Cron job! [] []` in the `var/log/system.log`
    file.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '除非我们已经设置了操作系统的`cron`以触发`php bin/magento cron:run`命令，否则我们需要每隔两分钟自己触发它几次，以便实际执行作业。第一次运行命令时，如果作业不在`cron_schedule`表中，`Magento`只会将其排队，但不会执行它。随后的`cron`运行将执行命令。一旦我们确认`cron_schedule`表中的`cron`作业条目已填充`finished_at`列值，我们将在`var/log/system.log`文件中看到一个类似`[2015-11-21
    09:42:18] main.INFO: Hello from Cron job! [] []`的条目。'
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: While developing and testing `cron` jobs in `Magento`, we might need to truncate
    the `cron_schedule` table, delete `Magento's var/cache` value, and execute the
    `php bin/magento cron:run` command repetitively until we get it tested and working.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Magento`中开发和测试`cron`作业时，我们可能需要截断`cron_schedule`表，删除`Magento`的`var/cache`值，并重复执行`php
    bin/magento cron:run`命令，直到测试并通过。
- en: Notification messages
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通知消息
- en: '`Magento` implements the notification message mechanism via the `Messages`
    module. The `Messages` module conforms to `\Magento\Framework\Message\ManagerInterface`.
    Though the interface itself does not impose any session relation, an implementation
    adds interface-defined types of messages to a session and allows access to those
    messages later. In the `app/etc/di.xml` file, there is a preference defined for
    `\Magento\Framework\Message\ManagerInterface` towards the `Magento\Framework\Message\Manager`
    class.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magento`通过`Messages`模块实现通知消息机制。`Messages`模块符合`\Magento\Framework\Message\ManagerInterface`接口。尽管接口本身不强制任何会话关系，但实现会添加接口定义的消息类型到会话中，并允许稍后访问这些消息。在`app/etc/di.xml`文件中，为`\Magento\Framework\Message\ManagerInterface`定义了一个针对`Magento\Framework\Message\Manager`类的偏好设置。'
- en: '`Message\ManagerInterface` specifies four types of messages, namely `error`,
    `warning`, `notice`, and `success`. The types of messages are followed by several
    key methods in the `Message\Manager` class, such as `addSuccess`, `addNotice`,
    `addWarning`, `addError`, and `addException`. The `addException` method is basically
    a wrapper for `addError` that accepts an `exception` object as a parameter.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message\ManagerInterface`指定了四种消息类型，即`error`、`warning`、`notice`和`success`。消息类型后面跟着`Message\Manager`类中的几个关键方法，如`addSuccess`、`addNotice`、`addWarning`、`addError`和`addException`。`addException`方法基本上是`addError`的包装，它接受一个`exception`对象作为参数。'
- en: 'Let''s try to run the following code in the `execute` method of `app/code/Foggyline/Office/Controller/Test/Crud.php`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`app/code/Foggyline/Office/Controller/Test/Crud.php`的`execute`方法中尝试运行以下代码：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once this code executed, the result, as shown in the following screenshot,
    will appear on the page in the browser:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦此代码执行，结果，如以下截图所示，将在浏览器页面中显示：
- en: '![Notification messages](img/00039.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![通知消息](img/00039.jpeg)'
- en: Notification messages appear both in the frontend and admin area.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通知消息在前端和后台区域都会出现。
- en: 'The frontend layout `vendor/magento/module-theme/view/frontend/layout/default.xml`
    file defines it as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前端布局文件`vendor/magento/module-theme/view/frontend/layout/default.xml`定义如下：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `template` file that renders the messages is `view/frontend/templates/messages.phtml`
    in the `Magento_Theme` module. By looking at the `Magento\Framework\View\Element\Messages`
    class, you will see that the `_toHtml` method branches into `if-else` statements,
    depending on whether template is set or not. In case the template is not set,
    `_toHtml` internally calls the `_renderMessagesByType` method, which renders messages
    in the HTML format that are grouped by type.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 用于渲染消息的`template`文件位于`Magento_Theme`模块中的`view/frontend/templates/messages.phtml`。通过查看`Magento\Framework\View\Element\Messages`类，你会看到`_toHtml`方法根据模板是否设置而分支到`if-else`语句。如果模板未设置，`_toHtml`方法内部会调用`_renderMessagesByType`方法，该方法以类型分组渲染HTML格式的消息。
- en: 'The `view/adminhtml/layout/default.xml` admin layout file in the `Magento_AdminNotification`
    module defines it as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magento_AdminNotification`模块中的`view/adminhtml/layout/default.xml`管理布局文件如下定义：'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `template` file that renders the messages is `view/adminhtml/templates/system/messages.phtml`
    in the `Magento_AdminNotification` module. When you look at the `Magento\AdminNotification\Block\System\Messages`
    class, you will see that its `_toHtml` is calling the `_toHtml` parent method,
    where the parent belongs to the `\Magento\Framework\View\Element\Template` class.
    This means that the output is relying on the `view/adminhtml/templates/system/messages.phtml`
    file in the `Magento_AdminNotification` module.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 用于渲染消息的`template`文件位于`Magento_AdminNotification`模块中的`view/adminhtml/templates/system/messages.phtml`。当你查看`Magento\AdminNotification\Block\System\Messages`类时，你会看到它的`_toHtml`正在调用父方法`_toHtml`，其中父类属于`\Magento\Framework\View\Element\Template`类。这意味着输出依赖于`Magento_AdminNotification`模块中的`view/adminhtml/templates/system/messages.phtml`文件。
- en: Session and cookies
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话和cookies
- en: Sessions in `Magento` conform to `Magento\Framework\Session\SessionManagerInterface`.
    In the `app/etc/di.xml` file, there is a definition preference for the `SessionManagerInterface`
    class which points to the `Magento\Framework\Session\Generic` class type. The
    `Session\Generic` class is just an empty class that extends the `Magento\Framework\Session\SessionManager`
    class, which in turn implements the `SessionManagerInterface` class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magento`中的会话符合`Magento\Framework\Session\SessionManagerInterface`。在`app/etc/di.xml`文件中，有一个对`SessionManagerInterface`类的定义偏好设置，它指向`Magento\Framework\Session\Generic`类类型。`Session\Generic`类只是一个空的类，它扩展了`Magento\Framework\Session\SessionManager`类，而后者又实现了`SessionManagerInterface`类。'
- en: There is one important object that gets instantiated in the `SessionManager`
    instance that conforms to `\Magento\Framework\Session\Config\ConfigInterface`.
    On looking at `app/etc/di.xml` file, we can see a preference for `ConfigInterface`
    pointing to a `Magento\Framework\Session\Config` class type.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SessionManager`实例中，有一个重要的对象被实例化，它符合`\Magento\Framework\Session\Config\ConfigInterface`。查看`app/etc/di.xml`文件，我们可以看到对`ConfigInterface`的偏好设置指向`Magento\Framework\Session\Config`类类型。
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To fully understand the session behavior in `Magento`, we should study the inner
    workings of both the `SessionManager` and `Session\Config` classes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解`Magento`中的会话行为，我们应该研究`SessionManager`和`Session\Config`类的内部工作原理。
- en: '`Magento` uses cookies to keep track of a session. These cookies have a default
    lifetime of 3,600 seconds. When a session is established, a cookie with the name
    of `PHPSESSID` is created in the browser. The value of the cookie equals the session
    name. By default, sessions are stored in files in the `var/session` directory
    of `Magento`''s root installation.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magento`使用cookie来跟踪会话。这些cookie的默认生存期为3,600秒。当会话建立时，在浏览器中创建一个名为`PHPSESSID`的cookie。cookie的值等于会话名称。默认情况下，会话存储在`Magento`根安装的`var/session`目录中的文件中。'
- en: 'If you have a look at these session files, you will see that session information
    is being stored in serialized strings that are divided into groupings such as
    `_session_validator_data, _session_hosts`, `default`, `customer_website_1`, and
    `checkout`, as shown in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看这些会话文件，您将看到会话信息被存储在序列化的字符串中，这些字符串被分为如`_session_validator_data, _session_hosts`,
    `default`, `customer_website_1`, 和`checkout`等分组，如下面的截图所示：
- en: '![Session and cookies](img/00040.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![会话和cookie](img/00040.jpeg)'
- en: This is not the finite list of grouping. Modules that implement their own session
    handling bits can add their own groups.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是分组列表的终结。实现自己会话处理部分的模块可以添加自己的组。
- en: 'We can store and retrieve information in a session by simply using expressions
    like the following ones:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地使用以下表达式在会话中存储和检索信息：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding expressions will create and get an entry from the session under
    the default group.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式将在默认组下创建和获取会话条目。
- en: 'We can get the entire content of the default session group simply by using
    the `$this->sessionManager->getData()` expression, which will return an array
    of data that is similar to the following one:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`$this->sessionManager->getData()`表达式简单地获取默认会话组的全部内容，这将返回一个类似于以下的数据数组：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the `foggyline_office_var_1` value is right there among other
    session values.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`foggyline_office_var_1`值就在其他会话值之中。
- en: 'There are several useful methods of `ConfigInterface` that we can use to fetch
    session configuration information; a few of these methods are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigInterface`有几个有用的方法，我们可以使用这些方法来获取会话配置信息；以下是一些方法：'
- en: '`getCookieSecure`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCookieSecure`'
- en: '`getCookieDomain`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCookieDomain`'
- en: '`getCookieHttpOnly`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCookieHttpOnly`'
- en: '`getCookieLifetime`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCookieLifetime`'
- en: '`getName`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getName`'
- en: '`getSavePath`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSavePath`'
- en: '`getUseCookies`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getUseCookies`'
- en: '`getOptions`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getOptions`'
- en: 'Here''s a result example of the `getOptions` method call on the `Session\Config`
    instance:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个在`Session\Config`实例上调用`getOptions`方法的结果示例：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Cookies often go hand in hand with sessions. Besides being used to link to a
    certain session, cookies are often used to store some information on the client
    side, thus tracking or identifying the return users and customers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: cookie通常与会话一起使用。除了用于链接到某个会话外，cookie还常用于在客户端存储一些信息，从而跟踪或识别回头用户和客户。
- en: Besides the pure PHP approach with the `setcookie` function, we can manage cookies
    in `Magento` through an instance of `Magento\Framework\Stdlib\CookieManagerInterface`.
    When you look at `app/etc/di.xml` file, you will see that the preference for `CookieManagerInterface`
    points to a class of the `Magento\Framework\Stdlib\Cookie\PhpCookieManager` type.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`setcookie`函数的纯PHP方法外，我们还可以通过`Magento\Framework\Stdlib\CookieManagerInterface`实例在`Magento`中管理cookie。当你查看`app/etc/di.xml`文件时，你会看到对`CookieManagerInterface`的偏好设置指向了`Magento\Framework\Stdlib\Cookie\PhpCookieManager`类型的类。
- en: 'The following restrictions are worth noting when it comes to `Magento` cookies:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到`Magento`的cookie时，以下限制值得关注：
- en: We can set maximum of 50 cookies in the system. Otherwise, `Magento` will throw
    an `Unable to send the cookie. Maximum number of cookies would be exceeded` exception.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在系统中设置最多50个cookie。否则，`Magento`将抛出`Unable to send the cookie. Maximum number
    of cookies would be exceeded`异常。
- en: We can store a cookie with a maximum size of 4096 bytes. Otherwise, `Magento`
    will throw an `Unable to send the cookie. Size of \'%name\' is %size bytes` exception.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以存储最大大小为4096字节的cookie。否则，`Magento`将抛出`Unable to send the cookie. Size of
    'name' is size bytes`异常。
- en: By imposing these restrictions, `Magento` ensures that we are compatible with
    most browsers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施这些限制，`Magento`确保我们与大多数浏览器兼容。
- en: The `CookieManagerInterface` class, among other things, specifies the `setSensitiveCookie`
    method requirement. This method sets a value in a private cookie with the given
    `$name $value` pairing. Sensitive cookies have **HttpOnly** set to true and thus
    cannot be accessed by JavaScript.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`CookieManagerInterface`类，以及其他一些功能，指定了`setSensitiveCookie`方法的要求。此方法使用给定的`$name
    $value`配对在私有cookie中设置一个值。敏感cookie将**HttpOnly**设置为true，因此不能通过JavaScript访问。'
- en: 'As we will soon demonstrate in the following examples, to set a public or private
    cookie, we can help ourselves by using instances of the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在以下示例中很快展示的，要设置公共或私有cookie，我们可以通过使用以下实例来帮助自己：
- en: '`\Magento\Framework\Stdlib\Cookie\CookieMetadataFactory`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\Stdlib\Cookie\CookieMetadataFactory`'
- en: '`\Magento\Framework\Stdlib\CookieManagerInterface`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\Stdlib\CookieManagerInterface`'
- en: '`\Magento\Framework\Session\Config\ConfigInterface`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\Session\Config\ConfigInterface`'
- en: 'We can set public cookies in the following way:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式设置公共cookie：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code will result in a cookie, as shown in the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将生成一个cookie，如下面的截图所示：
- en: '![Session and cookies](img/00041.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![会话和cookie](img/00041.jpeg)'
- en: 'We can set private cookies in the following way:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式设置私有cookie：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code will result in a cookie, as shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将生成一个cookie，如下面的截图所示：
- en: '![Session and cookies](img/00042.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![会话和cookie](img/00042.jpeg)'
- en: Interestingly, both the public and private cookies in the preceding example
    show that **HttpOnly** is checked off because by default, a `Magento` admin has
    **Stores** | **Settings** | **Configuration** | **General** | **Web** | **Default
    Cookie Settings** | **Use HTTP Only** set to **Yes**. Since we are using the `setHttpOnly`
    method in the public cookie example, we simply picked up the `config` value via
    `$this->sessionConfig->getCookieHttpOnly()` and passed it on. If we comment out
    that line, we will see that the public cookie does not really set **HttpOnly**
    by default.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，前面示例中的公共和私有cookie都显示**HttpOnly**被勾选，因为默认情况下，`Magento`管理员在**Stores** | **Settings**
    | **Configuration** | **General** | **Web** | **Default Cookie Settings** | **Use
    HTTP Only**设置为**Yes**。由于我们在公共cookie示例中使用`setHttpOnly`方法，我们只需通过`$this->sessionConfig->getCookieHttpOnly()`获取`config`值并传递即可。如果我们取消注释该行，我们将看到公共cookie实际上并没有默认设置**HttpOnly**。
- en: Logging
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录
- en: '`Magento` supports the messages logging mechanism via its `\Psr\Log\LoggerInterface`
    class. The `LoggerInterface` class has a preference defined within `app/etc/di.xml`
    file for the `Magento\Framework\Logger\Monolog` class type. The actual `crux`
    of implementation is actually in the `Monolog` parent class named `Monolog\Logger`,
    which comes from the `Monolog` vendor.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magento`通过其`\Psr\Log\LoggerInterface`类支持消息记录机制。`LoggerInterface`类在`app/etc/di.xml`文件中为`Magento\Framework\Logger\Monolog`类类型定义了偏好设置。实现的`核心`实际上在名为`Monolog\Logger`的`Monolog`父类中，它来自`Monolog`供应商。'
- en: 'The `LoggerInterface` class uses the following eight methods to write logs
    to the eight RFC 5424 levels:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoggerInterface`类使用以下八种方法将日志写入八个RFC 5424级别：'
- en: '`debug`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug`'
- en: '`info`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info`'
- en: '`notice`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notice`'
- en: '`warning`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`warning`'
- en: '`error`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`'
- en: '`critical`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`critical`'
- en: '`alert`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alert`'
- en: '`emergency`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emergency`'
- en: 'To use a logger, we need to pass the `LoggerInterface` class to a constructor
    of a class from within we want to use it and then simply make one of the following
    method calls:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用记录器，我们需要将`LoggerInterface`类传递给一个构造函数，该构造函数位于我们想要使用的类内部，然后简单地调用以下方法之一：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, the preferred shorter version through individual log level type
    methods is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，通过单独的日志级别类型方法，首选的较短的版本如下：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Both approaches result in the same two log files being created in `Magento`,
    which are as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会在`Magento`中创建相同的两个日志文件，如下所示：
- en: '`var/log/debug.log`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var/log/debug.log`'
- en: '`var/log/system.log`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var/log/system.log`'
- en: The `debug.log` file contains only the debug level type of the log, while the
    rest are saved under `system.log`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug.log`文件只包含日志的调试级别类型，其余的都保存在`system.log`中。'
- en: 'Entries within these logs will then look like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日志条目将看起来像这样：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Each of these `logger` methods can accept an entire array of arbitrary data
    called `context`, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`logger`方法中的每一个都可以接受一个名为`context`的任意数据数组，如下所示：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding expression will produce the following entry in `system.log`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式将在`system.log`中产生以下条目：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We can manually delete any of the `.log` files from the `var/log` directory,
    and `Magento` will automatically create it again when needed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动从`var/log`目录中删除任何`.log`文件，当需要时，`Magento`会自动重新创建它。
- en: '`Magento` also has another logging mechanism in place, where it logs the following
    actions in the `log_*` tables in a database:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magento`还实施了一种其他的日志记录机制，它在数据库的`log_*`表中记录以下操作：'
- en: '`log_customer`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log_customer`'
- en: '`log_quote`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log_quote`'
- en: '`log_summary`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log_summary`'
- en: '`log_summary_type`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log_summary_type`'
- en: '`log_url`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log_url`'
- en: '`log_url_info`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log_url_info`'
- en: '`log_visitorz`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log_visitorz`'
- en: '`log_visitor_info`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log_visitor_info`'
- en: '`log_visitor_online`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log_visitor_online`'
- en: It is worth noting that this database logging is not related in any way to `Psr`
    logger that was described previously. While `Psr` logger serves developers within
    the code to group and log certain messages according to the `Psr` standard, the
    database logging logs the live data that is a result of `user/customer` interaction
    in the browser.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这种数据库日志记录与之前描述的`Psr`记录器没有任何关系。虽然`Psr`记录器在代码中为开发者提供了一种根据`Psr`标准对某些消息进行分组和记录的方法，但数据库日志记录记录的是浏览器中`用户/客户`交互产生的实时数据。
- en: 'By default, `Magento` keeps database logs for around 180 days. This is a configurable
    option that can be controlled in the `Magento` admin area under the **Stores**
    | **Settings** | **Configuration** | **Advanced** | **System** | **Log Cleaning**
    tab with other log related options, as shown in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Magento`保留数据库日志大约180天。这是一个可配置的选项，可以在`Magento`管理区域**商店** | **设置** | **配置**
    | **高级** | **系统** | **日志清理**选项卡中控制，如以下截图所示：
- en: '![Logging](img/00043.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![日志记录](img/00043.jpeg)'
- en: '**Configuration** options that are shown in the preceding screenshot only bare
    meaning operating system `cron` is triggering `Magento cron`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置**选项，如前一张截图所示，仅表示操作系统`cron`正在触发`Magento cron`。'
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'We can execute two commands on terminal: `php bin/magento log:status` to get
    the current state information about log tables and `php bin/magento log:clean`
    to force the clearing of tables.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在终端执行两个命令：`php bin/magento log:status`以获取日志表当前状态信息，以及`php bin/magento log:clean`以强制清除表。
- en: The profiler
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剖析器
- en: '`Magento` has an in-built profiler that can be used to identify performance
    problems on the server side. In a nutshell, the profiler can tell us the execution
    time of certain chunks of code. There is nothing that great with its behavior.
    We can only get the execution time of code blocks or individual expressions that
    have been wrapped by the profiler''s start and stop methods. On its own, `Magento`
    calls for the profiler extensively across its code. However, we can''t see it
    in effect as the profiler output is disabled by default.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magento`有一个内置的剖析器，可以用来识别服务器端的性能问题。简而言之，剖析器可以告诉我们某些代码块执行的时间。它的行为并没有什么特别之处。我们只能获取被剖析器的开始和停止方法包裹的代码块或单个表达式的执行时间。`Magento`在其代码中广泛地调用剖析器。然而，我们看不到它的效果，因为剖析器的输出默认是禁用的。'
- en: '`Magento` supports three profiler outputs, namely `html`, `csvfile`, and `firebug`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magento`支持三种剖析器输出，即`html`、`csvfile`和`firebug`。'
- en: 'To enable the profiler, we can edit `.htaccess` and add one of the following
    expressions:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用剖析器，我们可以编辑`.htaccess`并添加以下表达式之一：
- en: '`SetEnv MAGE_PROFILER "html"`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetEnv MAGE_PROFILER "html"`'
- en: '`SetEnv MAGE_PROFILER "csvfile"`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetEnv MAGE_PROFILER "csvfile"`'
- en: '`SetEnv MAGE_PROFILER "firebug"`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetEnv MAGE_PROFILER "firebug"`'
- en: 'The HTML type of profiler will show its output into the footer area of a page
    that we open in the browser, as shown in the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器的HTML类型将输出到我们在浏览器中打开的页面的页脚区域，如下面的截图所示：
- en: '![The profiler](img/00044.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![The profiler](img/00044.jpeg)'
- en: 'The `csv` file type of profiler will output into `var/log/profiler.csv`, as
    shown in the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器的`csv`文件类型将输出到`var/log/profiler.csv`，如下面的截图所示：
- en: '![The profiler](img/00045.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![The profiler](img/00045.jpeg)'
- en: 'The firebug type of profiler will output into `var/log/profiler.csv`, as shown
    in the following screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器的firebug类型将输出到`var/log/profiler.csv`，如下面的截图所示：
- en: '![The profiler](img/00046.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![The profiler](img/00046.jpeg)'
- en: 'The profiler outputs the following pieces of information:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器输出了以下信息：
- en: '`Time` profiler shows the time spent from `Profiler::start` to `Profiler::stop`.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Time`分析器显示从`Profiler::start`到`Profiler::stop`所花费的时间。'
- en: '`Avg` profiler shows the average time spent from `Profiler::start` to `Profiler::stop`
    for cases where `Cnt` is greater than one.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Avg`分析器显示对于`Cnt`大于一的情况，从`Profiler::start`到`Profiler::stop`所花费的平均时间。'
- en: '`Cnt` profiler shows the integer value of how many times we have started the
    profiler with the same timer name. For example, if we have called `\Magento\Framework\Profiler::start(''foggyline:office'')`;
    twice somewhere in the code, then `Cnt` will show the value of `2`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cnt`分析器显示我们使用相同的计时器名称启动分析器的次数的整数值。例如，如果我们已经在代码的某个地方调用了`\Magento\Framework\Profiler::start(''foggyline:office'')`两次，那么`Cnt`将显示值为`2`。'
- en: '`Emalloc` profiler stands for the amount of memory allocated to PHP. It is
    a mix of the core PHP `memory_get_usage` function without the true parameter passed
    to it and the timer values.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Emalloc`分析器代表分配给PHP的内存量。它是核心PHP `memory_get_usage`函数（没有传递带有true参数的它）和计时器值的组合。'
- en: '`RealMem` profiler also stands for the amount of memory allocated to PHP whose
    final value is also obtained via the `memory_get_usage` function minus the timer
    values, but this time with the true parameter passed to it.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RealMem`分析器也代表分配给PHP的内存量，其最终值也是通过`memory_get_usage`函数减去计时器值获得的，但这次传递了带有true参数的它。'
- en: 'We can easily add our own `Profiler::start` calls anywhere in the code. Every
    `Profiler::start` should be followed by some code expressions and then finalized
    with a `Profiler::stop` call, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在代码的任何地方轻松地添加自己的`Profiler::start`调用。每个`Profiler::start`都应该跟随一些代码表达式，然后通过一个`Profiler::stop`调用结束，如下所示：
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Depending on where we call the profiler in the code, the resulting output should
    be similar to the one shown in the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在代码中调用分析器的位置，生成的输出应该类似于以下截图所示：
- en: '![The profiler](img/00047.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![The profiler](img/00047.jpeg)'
- en: Events and observers
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件和观察者
- en: '`Magento` implements the observer pattern through `\Magento\Framework\Event\ManagerInterface`.
    In `app/etc/di.xml`, there is a preference for `ManagerInterface` that points
    to the `Magento\Framework\Event\Manager\Proxy` class type. The `Proxy` class further
    extends the `\Magento\Framework\Event\Manager` class that implements the actual
    event dispatch method.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magento`通过`\Magento\Framework\Event\ManagerInterface`实现观察者模式。在`app/etc/di.xml`中，有一个指向`Magento\Framework\Event\Manager\Proxy`类类型的`ManagerInterface`偏好设置。`Proxy`类进一步扩展了`\Magento\Framework\Event\Manager`类，该类实现了实际的事件分发方法。'
- en: 'Events are dispatched by calling a dispatch method on the instance of the `Event\Manager`
    class and passing the name and some data, which is optional, to it. Here''s an
    example of a `Magento` core event:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 事件通过在`Event\Manager`类的实例上调用分发方法，并将名称和一些数据（可选）传递给它来分发。以下是一个`Magento`核心事件的示例：
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `$this->eventManager` is an instance of the previously mentioned `Event\Manager`
    class. In this case, the event name equals to `customer_customer_authenticated`,
    while the data passed to the event is the array with two elements. The preceding
    event is fired when the authenticate method is called on `\Magento\Customer\Model\AccountManagement`,
    that is, when a customer logs in.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`$this->eventManager`是之前提到的`Event\Manager`类的实例。在这种情况下，事件名称等于`customer_customer_authenticated`，而传递给事件的数据是包含两个元素的数组。前一个事件是在调用`\Magento\Customer\Model\AccountManagement`上的authenticate方法时触发的，即当客户登录时。'
- en: 'Dispatching an event only makes sense if we expect someone to observe it and
    execute their code when the event is dispatched. Depending on the area from which
    we want to observe events, we can define observers in one of the following XML
    files:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当我们期望有人观察事件并在事件被触发时执行他们的代码时，触发事件才有意义。根据我们想要观察事件的区域，我们可以在以下XML文件之一中定义观察者：
- en: '`app/code/{vendorName}/{moduleName}/etc/events.xml`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app/code/{vendorName}/{moduleName}/etc/events.xml`'
- en: '`app/code/{vendorName}/{moduleName}/etc/frontend/events.xml`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app/code/{vendorName}/{moduleName}/etc/frontend/events.xml`'
- en: '`app/code/{vendorName}/{moduleName}/etc/adminhtml/events.xml`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app/code/{vendorName}/{moduleName}/etc/adminhtml/events.xml`'
- en: Let's define an observer that will log an e-mail address of an authenticated
    user into a `var/log/system.log` file. We can use the `Foggyline_Office` module
    and add some code to it. As we are interested in the storefront, it makes sense
    to put the observer in the `etc/frontend/events.xml` module.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个观察者，它将认证用户的电子邮件地址记录到`var/log/system.log`文件中。我们可以使用`Foggyline_Office`模块并向其中添加一些代码。由于我们对店面感兴趣，将观察者放在`etc/frontend/events.xml`模块中是有意义的。
- en: 'Let''s define the `app/code/Foggyline/Office/etc/frontend/events.xml` file
    with content, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义包含以下内容的`app/code/Foggyline/Office/etc/frontend/events.xml`文件：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we are specifying a `foggyline_office_customer_authenticated` observer
    for the `customer_customer_authenticated` event. The observer is defined in the
    `LogCustomerEmail` class that is placed in the `Observer` module directory. The
    `Observer` class has to implement the `Magento\Framework\Event\ObserverInterface`
    class. The `Observer` interface defines a single execute method. The execute method
    hosts the observer code and is executed when the `customer_customer_authenticated`
    event is dispatched.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定了一个`foggyline_office_customer_authenticated`观察者用于`customer_customer_authenticated`事件。观察者定义在放置在`Observer`模块目录中的`LogCustomerEmail`类中。`Observer`类必须实现`Magento\Framework\Event\ObserverInterface`类。`Observer`接口定义了一个单一的`execute`方法。`execute`方法包含观察者代码，并在`customer_customer_authenticated`事件被触发时执行。
- en: 'Let''s go ahead and define the `Foggyline\Office\Observer\LogCustomerEmail`
    class in the `app/code/Foggyline/Office/Observer/LogCustomerEmail.php` file, as
    follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在`app/code/Foggyline/Office/Observer/LogCustomerEmail.php`文件中定义`Foggyline\Office\Observer\LogCustomerEmail`类，如下所示：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `execute` method takes a single parameter called `$observer` of the `\Magento\Framework\Event\Observer`
    type. The event that we are observing is passing two pieces of data within the
    array, namely the `model` and `password`. We can access this by using the `$observer->getEvent()->get{arrayKeyName}`
    expression. The `$customer` object is an instance of the `Magento\Customer\Model\Data\CustomerSecure`
    class, which contains properties such as `email`, `firstname`, `lastname`, and
    so on. Thus, we can extract the e-mail address from it and pass it to logger's
    `info` method.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute`方法接受一个名为`$observer`的单个参数，其类型为`\Magento\Framework\Event\Observer`。我们正在观察的事件在数组中传递两份数据，即`model`和`password`。我们可以通过使用`$observer->getEvent()->get{arrayKeyName}`表达式来访问这些数据。`$customer`对象是`Magento\Customer\Model\Data\CustomerSecure`类的一个实例，它包含诸如`email`、`firstname`、`lastname`等属性。因此，我们可以从中提取电子邮件地址并将其传递给记录器的`info`方法。'
- en: 'Now that we know how to observe existing events, let''s see how we can dispatch
    our own events. We can dispatch events from almost anywhere in the code, with
    or without data, as shown in the following example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何观察现有的事件，让我们看看我们如何可以触发我们自己的事件。我们可以在代码的几乎任何地方触发事件，无论是有数据还是无数据，如下面的示例所示：
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It is worth noting that there are two types of events; we can group them in
    the following way according to the way their name is assigned:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，存在两种类型的事件；我们可以根据它们名称的分配方式将它们分组如下：
- en: '**Static**: `$this->eventManager->dispatch(''event_name'', ...)`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态**: `$this->eventManager->dispatch(''event_name'', ...)`'
- en: '**Dynamic**: `$this->eventManager->dispatch({expression}.''_event_name'', ...)`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态**: `$this->eventManager->dispatch({expression}.''_event_name'', ...)`'
- en: 'The static events have a fixed string for a name, while the dynamic ones have
    a name that is determined during the runtime. Here''s a nice example of the core
    `Magento` functionality from the `afterLoad` method that is defined under `lib/internal/Magento/Framework/Data/AbstractSearchResult.php`,
    which showcases how to use both types of events:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 静态事件有一个固定的字符串名称，而动态事件则有一个在运行时确定的名称。以下是一个很好的核心`Magento`功能示例，来自定义在`lib/internal/Magento/Framework/Data/AbstractSearchResult.php`下的`afterLoad`方法，展示了如何使用这两种类型的事件：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can see a *static* event (`abstract_search_result_load_after`) and a dynamic
    event (`$this->eventPrefix . ''_load_after''`). The `$this->eventPrefix` is an
    expression that gets evaluated during the runtime. We should be careful when using
    dynamic events as they are triggered under multiple situations. Some interesting
    dynamic events are the one defined on classes like the following ones:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一个**静态**事件（`abstract_search_result_load_after`）和一个动态事件（`$this->eventPrefix
    . '_load_after'`）。`$this->eventPrefix` 是一个在运行时被评估的表达式。在使用动态事件时我们应该小心，因为它们在多种情况下被触发。一些有趣的动态事件是在以下类中定义的：
- en: '`Magento\Framework\Model\AbstractModel`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Magento\Framework\Model\AbstractModel`'
- en: '`$this->_eventPrefix . ''_load_before''`'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$this->_eventPrefix . ''_load_before''`'
- en: '`$this->_eventPrefix . ''_load_after''`'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$this->_eventPrefix . ''_load_after''`'
- en: '`$this->_eventPrefix . ''_save_commit_after''`'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$this->_eventPrefix . ''_save_commit_after''`'
- en: '`$this->_eventPrefix . ''_save_before''`'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$this->_eventPrefix . ''_save_before''`'
- en: '`$this->_eventPrefix . ''_save_after''`'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$this->_eventPrefix . ''_save_after''`'
- en: '`$this->_eventPrefix . ''_delete_before''`'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$this->_eventPrefix . ''_delete_before''`'
- en: '`$this->_eventPrefix . ''_delete_after''`'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$this->_eventPrefix . ''_delete_after''`'
- en: '`$this->_eventPrefix . ''_delete_commit_after''`'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$this->_eventPrefix . ''_delete_commit_after''`'
- en: '`$this->_eventPrefix . ''_clear''`'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$this->_eventPrefix . ''_clear''`'
- en: '`\Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection`'
- en: '`$this->_eventPrefix . ''_load_before''`'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$this->_eventPrefix . ''_load_before''`'
- en: '`$this->_eventPrefix . ''_load_after''`'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$this->_eventPrefix . ''_load_after''`'
- en: '`\Magento\Framework\App\Action\Action`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\Magento\Framework\App\Action\Action`'
- en: '`''controller_action_predispatch_'' . $request-> getRouteName()`'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''controller_action_predispatch_'' . $request-> getRouteName()`'
- en: '`''controller_action_predispatch_'' . $request-> getFullActionName()`'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''controller_action_predispatch_'' . $request-> getFullActionName()`'
- en: '`''controller_action_postdispatch_'' . $request-> getFullActionName()`'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''controller_action_postdispatch_'' . $request-> getFullActionName()`'
- en: '`''controller_action_postdispatch_'' . $request-> getRouteName()`'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''controller_action_postdispatch_'' . $request-> getRouteName()`'
- en: '`Magento\Framework\View\Result\Layout`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Magento\Framework\View\Result\Layout`'
- en: '`''layout_render_before_'' . $this->request-> getFullActionName()`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''layout_render_before_'' . $this->request-> getFullActionName()`'
- en: These events are fired on the `model`, `collection`, `controller`, and `layout`
    classes, which are probably among the most used backend elements that often require
    observing and interacting. Even though we can say that the full event name is
    known during the runtime along with the dynamic event, this can be assumed even
    before the runtime.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件在 `model`、`collection`、`controller` 和 `layout` 类上触发，这些类可能是最常用的后端元素，经常需要观察和交互。尽管我们可以说在运行时，我们知道完整的事件名称以及动态事件，但这也可以在运行前就假设。
- en: For example, assuming that we want to observe `'controller_action_predispatch_'
    . $request->getFullActionName()` for the `Foggyline_Office` module's `Crud` controller
    action, the actual full event name will be `'controller_action_predispatch_foggyline_office_test_crud'`,
    given that `$request->getFullActionName()` will resolve to `foggyline_office_test_crud`
    during the runtime.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要观察 `Foggyline_Office` 模块的 `Crud` 控制器动作的 `'controller_action_predispatch_'
    . $request->getFullActionName()`，那么实际的全事件名称将是 `'controller_action_predispatch_foggyline_office_test_crud'`，因为在运行时
    `$request->getFullActionName()` 将解析为 `foggyline_office_test_crud`。
- en: Cache(s)
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存（s）
- en: '`Magento` has eleven out-of-the-box cache types, according to the following
    list. These are used across many levels within the system:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下列表，`Magento` 提供了十一种内置缓存类型，这些类型在系统内部多个层级中使用：
- en: '**Configuration**: Various XML configurations that were collected across modules
    and merged'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：跨模块收集并合并的各种XML配置'
- en: '**Layouts**: Layout building instructions'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局**：布局构建指令'
- en: '**Blocks HTML output**: Page blocks HTML'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块HTML输出**：页面块HTML'
- en: '**Collections data**: Collection data files'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合数据**：集合数据文件'
- en: '**Reflection data**: API interfaces reflection data'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反射数据**：API接口反射数据'
- en: '**Database DDL operations**: Results of DDL queries, such as describing tables
    or indexes'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库DDL操作**：DDL查询的结果，例如描述表或索引'
- en: '**EAV types and attributes**: Entity types declaration cache'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EAV类型和属性**：实体类型声明缓存'
- en: '**Page cache**: Full page caching'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页面缓存**：完整页面缓存'
- en: '**Translations**: Translation files'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**翻译**：翻译文件'
- en: '**Integrations configuration**: Integration configuration file'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成配置**：集成配置文件'
- en: '**Integrations API configuration**: Integrations API configuration file'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成API配置**：集成API配置文件'
- en: '**Web services configuration**: REST and SOAP configurations, generated WSDL
    file'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web服务配置**：REST和SOAP配置，生成的WSDL文件'
- en: 'There is also **Additional Cache Management** that manages the cache for the
    following files:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有 **附加缓存管理**，它管理以下文件的缓存：
- en: Previously generated product image files
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前生成的产品图片文件
- en: Themes JavaScript and CSS files combined to one file
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题 JavaScript 和 CSS 文件合并为一个文件
- en: Preprocessed view files and static files
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预处理视图文件和静态文件
- en: Each of these caches can be cleared separately.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这些缓存中的每一个都可以单独清除。
- en: 'We can easily define our own cache type. We can do so by first creating an
    `app/code/Foggyline/Office/etc/cache.xml` file with content, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地定义自己的缓存类型。我们可以通过首先创建一个 `app/code/Foggyline/Office/etc/cache.xml` 文件并包含以下内容来实现：
- en: '[PRE21]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When defining a new cache type, we need to specify its `name` and `instance`
    attributes. The `name` attribute of the `type` element should be set to `foggyline_office`
    and should be unique across `Magento`. This value should match the `TYPE_IDENTIFIER`
    constant value on the `Foggyline\Office\Model\Cache` class, which will be created
    soon. The `instance` attribute holds the class name that we will use for caching.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义新的缓存类型时，我们需要指定其 `name` 和 `instance` 属性。`type` 元素的 `name` 属性应设置为 `foggyline_office`，并且在整个
    `Magento` 中应该是唯一的。这个值应该与 `Foggyline\Office\Model\Cache` 类中的 `TYPE_IDENTIFIER`
    常量值相匹配，该类将很快创建。`instance` 属性包含我们将用于缓存的类名。
- en: 'Then, we will define the `Foggyline\Office\Model\Cache` class in the `app/code/Foggyline/Office/Model/Cache.php`
    file with the following content:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在 `app/code/Foggyline/Office/Model/Cache.php` 文件中定义 `Foggyline\Office\Model\Cache`
    类，内容如下：
- en: '[PRE22]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `Cache` class extends from `TagScope` and specifies its own values for `TYPE_IDENTIFIER`
    and `CACHE_TAG`, passing them along to the parent constructor in the `__construct`
    method. With these two files (`cache.xml` and `Cache`), we have basically defined
    a new cache type.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cache` 类继承自 `TagScope` 并为其自己的 `TYPE_IDENTIFIER` 和 `CACHE_TAG` 指定值，在 `__construct`
    方法中将它们传递给父构造函数。有了这两个文件（`cache.xml` 和 `Cache`），我们基本上定义了一种新的缓存类型。'
- en: 'Once we have specified the `cache.xml` file and the referenced `cache` class,
    we should be able to see our cache type in the `Magento` admin under the **System**
    | **Tools** | **Cache Management** menu, as shown in the following screenshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们指定了 `cache.xml` 文件和引用的 `cache` 类，我们应该能够在 `Magento` 管理后台的 **系统** | **工具**
    | **缓存管理** 菜单下看到我们的缓存类型，如下截图所示：
- en: '![Cache(s)](img/00048.jpeg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![Cache(s)](img/00048.jpeg)'
- en: On its own, simply defining a new cache does not mean that it will get filled
    and used by `Magento`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过定义一个新的缓存，并不意味着它会被 `Magento` 填充和使用。
- en: 'If you would like to use the cache anywhere within your code, you can do so
    by first passing the instance of the cache class to the constructor, as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在代码的任何地方使用缓存，你可以通过首先将缓存类的实例传递给构造函数来实现，如下所示：
- en: '[PRE23]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, you can execute a chunk of code, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以执行一段代码，如下所示：
- en: '[PRE24]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code shows how we first try to load the value from the existing
    cache entry, and if there is none, we save it. If the cache type is set to `disabled`
    under the **Cache Management** menu, then the preceding code will never save and
    pull the data from the cache, as it is not in effect.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了我们首先尝试从现有的缓存条目中加载值，如果没有，则保存它。如果缓存类型在 **缓存管理** 菜单下设置为 `disabled`，则上述代码将永远不会保存并从缓存中拉取数据，因为它不起作用。
- en: 'If you take a look at the `var/cache` folder of `Magento` at this point, you
    will see something similar to what''s shown in the following screenshot:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你查看 `Magento` 的 `var/cache` 文件夹，你将看到以下截图所示的内容：
- en: '![Cache(s)](img/00049.jpeg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![Cache(s)](img/00049.jpeg)'
- en: '`Magento` created two cache entries for us, namely `var/cache/mage-tags/mage---a8a_OFFICE`
    and `var/cache/mage--f/mage---a8a_SOME_SPECIFIC_ID`. The `mage---a8a_OFFICE` file
    has only a single line of entry in this specific case, and the entry is the `a8a_SOME_SPECIFIC_ID`
    string, which obviously points to the other file. The `mage---a8a_SOME_SPECIFIC_ID`
    file contains the actual serialized `$objInfo` array.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magento` 为我们创建了两个缓存条目，分别是 `var/cache/mage-tags/mage---a8a_OFFICE` 和 `var/cache/mage--f/mage---a8a_SOME_SPECIFIC_ID`。在这个特定情况下，`mage---a8a_OFFICE`
    文件只有一行条目，条目是 `a8a_SOME_SPECIFIC_ID` 字符串，显然指向另一个文件。`mage---a8a_SOME_SPECIFIC_ID`
    文件包含实际的序列化 `$objInfo` 数组。'
- en: The `a8a_` prefix and other prefixes in the `cache` file names are not really
    relevant to us; this is something that `Magento` adds on its own. What is relevant
    to us is the passing of proper individual cache tags to the chunks or variables
    that we want to cache, like in the preceding example, and the `TYPE_IDENTIFIER`
    and `CACHE_TAG` tags that we set for the `Cache` class.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`a8a_` 前缀和其他 `cache` 文件名中的前缀对我们来说并不真正相关；这是 `Magento` 自己添加的。对我们来说，相关的是向我们要缓存的块或变量传递适当的单个缓存标签，就像前面的例子中那样，以及我们为
    `Cache` 类设置的 `TYPE_IDENTIFIER` 和 `CACHE_TAG` 标签。'
- en: Widgets
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小部件
- en: '`Magento` provides support for widgets. Though the word "widget" might imply
    frontend development skills and activities, we will look at them as a part of
    the backend development flow because creating useful and robust widgets requires
    a significant amount of backend knowledge.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magento` 提供了对小部件的支持。尽管“小部件”这个词可能意味着前端开发技能和活动，但我们将把它们视为后端开发流程的一部分，因为创建有用且健壮的小部件需要大量的后端知识。'
- en: '`Magento` provides several out-of-the-box widgets; some of them are as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magento` 提供了几个开箱即用的小部件；其中一些如下：'
- en: CMS page link
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMS 页面链接
- en: CMS static block
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMS 静态块
- en: Catalog category link
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录分类链接
- en: Catalog new products list
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录新产品列表
- en: Catalog product link
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录产品链接
- en: Catalog products list
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录产品列表
- en: Orders and returns
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单和退货
- en: Recently compared products
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最近比较的产品
- en: Recently viewed products
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最近查看的产品
- en: 'To create a fully custom widget, we start by defining `app/code/Foggyline/Office/etc/widget.xml`
    with content, as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个完全自定义的小部件，我们首先定义 `app/code/Foggyline/Office/etc/widget.xml` 并添加内容，如下所示：
- en: '[PRE25]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `id` widget has been set to `foggyline_office`, while the class powering
    widget has been set to `Foggyline\Office\Block\Widget\Example`. the `widget` class
    is basically a `block` class that extends from `\Magento\Framework\View\Element\AbstractBlock`
    and implements `\Magento\Widget\Block\BlockInterface`. The `label` and `description`
    element set values appear under the `Magento` admin when we select the widget
    for use.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`id` 小部件已被设置为 `foggyline_office`，而驱动小部件的类已被设置为 `Foggyline\Office\Block\Widget\Example`。`widget`
    类基本上是一个扩展自 `\Magento\Framework\View\Element\AbstractBlock` 并实现 `\Magento\Widget\Block\BlockInterface`
    的 `block` 类。当我们选择小部件进行使用时，`label` 和 `description` 元素设置的值将显示在 `Magento` 管理后台。 '
- en: 'The parameters of a widget are its configurable options that translate into
    HTML form elements, depending on the `type` and `source_model` options that we
    have selected. In the following example, we will demonstrate the usage of the
    `select` and `text` elements to retrieve input from a user, as shown in the following
    screenshot:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件的参数是其可配置选项，这些选项根据我们选择的 `type` 和 `source_model` 选项转换为 HTML 表单元素。在下面的例子中，我们将演示使用
    `select` 和 `text` 元素从用户那里获取输入，如图所示：
- en: '![Widgets](img/00050.jpeg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![小部件](img/00050.jpeg)'
- en: 'Let''s proceed by creating the actual `Widget`\`Example` class in the `app/code/Foggyline/Office/Block/Widget/Example.php`
    file with content, as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在 `app/code/Foggyline/Office/Block/Widget/Example.php` 文件中创建实际的 `WidgetExample`
    类并添加内容来继续，如下所示：
- en: '[PRE26]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: What is happening here is that we are using `Element\Text` as a block type and
    not `Element\Template` because we want to simplify the example, as `Element\Template`
    will require the `phtml` template to be defined as well. By using `Element\Text`,
    we can simply define `_beforeToHtml` and call the `setText` method to set the
    text string of the block's output. We will build the output string by picking
    up the `var1` and `var2` variables, which were passed as parameters to the block.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，我们正在使用 `Element\Text` 作为块类型，而不是 `Element\Template`，因为我们想简化示例，因为 `Element\Template`
    还需要定义 `phtml` 模板。通过使用 `Element\Text`，我们可以简单地定义 `_beforeToHtml` 并调用 `setText` 方法来设置块的输出文本字符串。我们将通过拾取作为参数传递给块的
    `var1` 和 `var2` 变量来构建输出字符串。
- en: 'Now, if we open the `Magento` admin area, go to **Content** | **Elements**
    | **Pages**, and select **Home Page** to edit, we should be able to click on the
    **Insert Frontend App** button and add our widget to the page. Alternatively,
    if we are not editing the page content in the `WYSIWYG` mode, we can also add
    the widget manually to the page by using the following expression:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们打开 `Magento` 管理区域，转到 **内容** | **元素** | **页面**，并选择 **主页** 进行编辑，我们应该能够点击
    **插入前端应用** 按钮并将我们的小部件添加到页面中。或者，如果我们不是在 `WYSIWYG` 模式下编辑页面内容，我们也可以使用以下表达式手动将小部件添加到页面中：
- en: '[PRE27]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we should see the example widget: `var1=1, var2=5` string in the browser
    while visiting the home page of the storefront.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们访问店面主页时，我们应该在浏览器中看到示例小部件：`var1=1, var2=5` 字符串。
- en: We can use frontend apps to create highly configurable and embeddable widgets
    that users can easily assign to a CMS page or block.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前端应用创建高度可配置和可嵌入的组件，用户可以轻松地将它们分配到CMS页面或块。
- en: Custom variables
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义变量
- en: Variables are a handy little feature of a core `Magento_Variable` module. `Magento`
    allows you to create custom variables and then use them in e-mail templates, the
    `WYSIWYG` editor, or even code expressions.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是`Magento_Variable`核心模块的一个便捷小功能。`Magento`允许你创建自定义变量，然后可以在电子邮件模板、`WYSIWYG`编辑器或甚至代码表达式中使用它们。
- en: 'The following steps outline how we can create a new variable manually:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了如何手动创建新变量：
- en: In the `Magento` admin area, navigate to **System** | **Other Settings** | **Custom
    Variables**.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Magento`管理区域，导航到**系统** | **其他设置** | **自定义变量**。
- en: Click on the **Add New Variable** button.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加新变量**按钮。
- en: While keeping in mind the **Store View** switcher, fill in the required **Variable
    Code** and **Variable Name** options, and preferably one of the optional options,
    either **Variable HTML Value** or **Variable Plain Value**.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在考虑**商店视图**切换器的同时，填写所需的**变量代码**和**变量名称**选项，并最好选择一个可选选项，即**变量HTML值**或**变量纯文本值**。
- en: Click on the **Save** button.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**按钮。
- en: 'Now that we have created the custom variable, we can use it in an e-mail template
    or the `WYSIWYG` editor by calling it using the following expression:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了自定义变量，我们可以通过以下表达式在电子邮件模板或`WYSIWYG`编辑器中使用它：
- en: '[PRE28]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding expression will call for the value of the `custom` variable with
    code `foggyline_hello`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式将调用代码`foggyline_hello`中`custom`变量的值。
- en: 'Variables can be used within various code expressions, though it is not recommended
    to rely on the existence of an individual variable, as an admin user can delete
    it at any point. The following example demonstrates how we can use an existing
    variable in the code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在各种代码表达式中使用，尽管不建议依赖于单个变量的存在，因为管理员用户可以在任何时间点删除它。以下示例演示了如何在代码中使用现有变量：
- en: '[PRE29]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `$this->_variableFactory` is an instance of `\Magento\Variable\Model\VariableFactory`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`$this->_variableFactory`是`\Magento\Variable\Model\VariableFactory`的一个实例。'
- en: If used in the right way, variables can be useful. Storing information such
    as phone numbers or specialized labels that are used in CMS pages, blogs, and
    e-mail templates is a nice example of using custom variables.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用得当，变量可以很有用。存储诸如电话号码或用于CMS页面、博客和电子邮件模板中的专用标签等信息是使用自定义变量的好例子。
- en: i18n
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: i18n
- en: '**i18n** is the abbreviation for **internationalization**. `Magento` adds i18n
    support out of the box, thus adapting to various languages and regions without
    application changes. Within `app/functions.php`, there is a `__()` translation
    function, which is defined as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**i18n**是**国际化**的缩写。`Magento`默认添加i18n支持，因此无需应用更改即可适应各种语言和地区。在`app/functions.php`中，有一个`__()`翻译函数，其定义如下：'
- en: '[PRE30]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This `translation` function accepts a variable number of arguments and passes
    them to a constructor of the `\Magento\Framework\Phrase` class and returns its
    instance. The `Phrase` class has the `__toString` method, which then returns the
    translated string.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`translation`函数接受可变数量的参数，并将它们传递给`\Magento\Framework\Phrase`类的构造函数，并返回其实例。`Phrase`类有`__toString`方法，然后返回翻译后的字符串。
- en: 'Here are a few examples of how we can use the `__()` function:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些如何使用`__()`函数的示例：
- en: '`__(''Translate me'')`'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__(''Translate me'')`'
- en: '`__(''Var1 %1, Var2 %2, Var %3'', time(), date(''Y''), 32)`'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__(''Var1 %1, Var2 %2, Var %3'', time(), date(''Y''), 32)`'
- en: '`__(''Copyright %1 <a href="%2">Magento</a>'', date(''Y''), ''http://magento.com'')`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__(''版权 %1 <a href="%2">Magento</a>'', date(''Y''), ''http://magento.com'')`'
- en: Strings passed through the `translation` function are expected to be found under
    the local CSV files, such as `app/code/{vendorName}/{moduleName}/i18n/{localeCode}.csv`.
    Let's imagine for a moment that we have two different store views defined in the
    `Magento` admin area under **Stores** | **Settings** | **All Stores**. One store
    has **Store** | **Settings** | **Configuration** | **General** | **Locale Options**
    | **Locale** set to **English (United Kingdom)** and the other one to **German
    (Germany)**. The local code for **English (United Kingdom)** is `en_GB`, and for
    **German (Germany)**, it is `de_DE`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`translation`函数传递的字符串预计可以在本地CSV文件中找到，例如`app/code/{vendorName}/{moduleName}/i18n/{localeCode}.csv`。让我们暂时想象一下，我们在`Magento`管理区域的**商店**
    | **设置** | **所有商店**下定义了两个不同的商店视图。一个商店将**商店** | **设置** | **配置** | **常规** | **区域选项**
    | **区域**设置为**英语（英国**）和另一个设置为**德语（德国**）。**英语（英国**）的本地代码是`en_GB`，而**德语（德国**）的本地代码是`de_DE`。
- en: 'For the `de_DE` locale, we will add translation entries in the `app/code/Foggyline/Office/i18n/de_DE.csv`
    file, as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`de_DE`区域设置，我们将在`app/code/Foggyline/Office/i18n/de_DE.csv`文件中添加翻译条目，如下所示：
- en: '[PRE31]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For the `en_GB` locale, we will add translation entries in the `app/code/Foggyline/Office/i18n/en_GB.csv`
    file, as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`en_GB`区域设置，我们将在`app/code/Foggyline/Office/i18n/en_GB.csv`文件中添加翻译条目，如下所示：
- en: '[PRE32]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Looking at the two CSV files, a pattern emerges. We can see that the CSV files
    function in the following way:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 观察两个CSV文件，出现了一个模式。我们可以看到CSV文件按以下方式工作：
- en: Individual translation strings are provided according to every line of CSV
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据CSV的每一行提供单独的翻译字符串
- en: Each line further comprises two individual strings that are separated by a comma
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一行进一步包含两个由逗号分隔的独立字符串
- en: Both individual strings are surrounded by quotes
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个独立字符串都被引号包围
- en: If a string contains quotes, it is escaped by a double quote so that it does
    not break translation
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个字符串包含引号，它将通过双引号转义，以便它不会破坏翻译
- en: The `%1`, `%2`, `%3`...`%n` pattern is used to mark variable placeholders that
    we provided during application runtime through the code
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%1`、`%2`、`%3`...`%n`模式用于标记我们在应用程序运行时通过代码提供的变量占位符'
- en: '`Magento` supports several commands related to its `bin/magento` console tool:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magento`支持与其`bin/magento`控制台工具相关的几个命令：'
- en: '[PRE33]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we execute a console command as follows, Magento will recursively look for
    translatable expressions within PHP, PHTML, or XML files that have phrases to
    translate:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行以下控制台命令，Magento将递归地查找PHP、PHTML或XML文件中的可翻译表达式，这些文件包含要翻译的短语：
- en: '[PRE34]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The output of the preceding command will basically overwrite the `app/code/Foggyline/Office/i18n/en_GB.csv`
    file, which has all the `Foggyline/Office` module translatable phrases. This is
    a nice way of aggregating all the translatable phrases into appropriate locale
    files, such as `en_GB.csv` in this case.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出将基本上覆盖`app/code/Foggyline/Office/i18n/en_GB.csv`文件，该文件包含所有`Foggyline/Office`模块的可翻译短语。这是一种将所有可翻译短语聚合到适当的区域文件中的好方法，例如在本例中的`en_GB.csv`。
- en: 'The translation CSV files can also be placed under the individual theme. For
    example, let''s imagine a situation where we add content to `app/design/frontend/Magento/blank/i18n/en_GB.csv`,
    as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译CSV文件也可以放置在单个主题下。例如，让我们想象一种情况，我们向`app/design/frontend/Magento/blank/i18n/en_GB.csv`添加内容，如下所示：
- en: '[PRE35]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, a `Translate me` string output of the storefront for the `en_GB` locale
    would resolve to `Theme_en_GB Translate me` and not to the `en_GB Translate me`
    string.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于`en_GB`区域设置的店面，`Translate me`字符串的输出将解析为`Theme_en_GB Translate me`，而不是`en_GB
    Translate me`字符串。
- en: Tip
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Theme CSV translations take higher precedence than module CSV translations,
    thus enabling developers to override individual module translations.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 主题CSV翻译的优先级高于模块CSV翻译，因此允许开发者覆盖单个模块的翻译。
- en: Along with CSV translation files, `Magento` also supports a feature called ``can
    activate the inline translation in the `Magento` admin area by navigating to **Store**``
    **| **Settings** | **Configuration** | **Advanced** | **Developer** | **Translate
    Inline**. This feature can be turned on separately for admin and storefront, as
    shown in the following screenshot:**
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 除了CSV翻译文件外，`Magento`还支持一个名为``可以在`Magento`管理区域中激活行内翻译，通过导航到**商店**`` **| **设置**
    | **配置** | **高级** | **开发者** | **行内翻译**。此功能可以分别针对管理员和店面单独打开，如下面的截图所示：
- en: '**![i18n](img/00051.jpeg)**'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**![i18n](img/00051.jpeg)**'
- en: '**As shown in the preceding screenshot, when a feature is activated, red dotted
    borders appear around the HTML elements. Hovering over an individual element shows
    a little book icon near the individual element at the bottom left corner. Clicking
    on the book icon opens a popup, as shown in the following screenshot:**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**如图所示的前一个截图，当某个功能被激活时，HTML元素周围会出现红色的虚线边框。将鼠标悬停在单个元素上时，在左下角会显示一个小书图标。点击书图标会弹出一个窗口，如图下所示：**'
- en: '**![i18n](img/00052.jpeg)**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**![国际化](img/00052.jpeg)**'
- en: '**It is important to note that these red dotted borders and the book icon will
    only appear for strings that we passed through the `__()` translate function.**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**需要注意的是，这些红色的虚线边框和书图标只会出现在我们通过`__()`翻译函数传递的字符串上。**'
- en: '**Here, we can see various pieces of information about the string, such as
    the `Shown`, `Translated`, and `Original` string. There is also an input field
    called `Custom`, where we can add a new translation. Inline translation strings
    are stored in the `translation` table in the database.**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**在这里，我们可以看到有关字符串的各种信息，例如`显示`、`翻译`和`原文`字符串。还有一个名为`自定义`的输入字段，我们可以在此添加新的翻译。内联翻译字符串存储在数据库中的`translation`表中。**'
- en: '**Tip**'
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '**Inline translation takes higher precedence than theme CSV translation files.**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**内联翻译比主题CSV翻译文件具有更高的优先级。**'
