- en: Chapter 7. Backend Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Backend development** is a term that is most commonly used to describe work
    closely related to the server side. This usually implies the actual server, application
    code, and the database. For example, if we open a storefront of a web shop, add
    a few products to the cart, and then check out, the application will store the
    information provided. This information is managed on a server with a server-side
    language, such as PHP, and then saved in a database. In [Chapter 4](part0028_split_000.html#QMFO2-818f5224668745eb9070ddf1d85e6bfa
    "Chapter 4. Models and Collections"), *Models and Collections*, we took a look
    at the backbone of backend development. In this chapter, we will explore other
    backend-related aspects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `Foggyline_Office` module that was defined in one of the previous
    chapters as we go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Cron jobs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notification messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sessions and cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The profiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events and observers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: i18n (internationalization)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These individual isolated units of functionality are mostly used in everyday
    backend-related development.
  prefs: []
  type: TYPE_NORMAL
- en: Cron jobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Speaking of `cron` jobs, it is worth noting one important thing. A `Magento
    cron` job is not the same as an operating system `cron` job. An operating system
    `cron` is driven by a `crontab` (short for `cron` table) file. The `crontab` file,
    is a configuration file that specifies shell commands that need to be run periodically
    on a given schedule.
  prefs: []
  type: TYPE_NORMAL
- en: A `Magento cron` job is driven by a periodic execution of PHP code that handles
    entries in the `cron_schedule` table. The `cron_schedule` table is where `Magento
    cron` jobs are queued once they are picked up from the individual `crontab.xml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The `Magento cron` jobs cannot be executed without the operating system `cron`
    job being set to execute the `php bin/magento cron:run` command. Ideally, an operating
    system `cron` job should be set to trigger `Magento's cron:run` every minute.
    `Magento` will then internally execute its `cron` jobs according to the way an
    individual `cron` job is defined in the `crontab.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a new `cron` job in `Magento cron`, we first need to define a `crontab.xml`
    file in the module. Let''s create a `app/code/Foggyline/Office/etc/crontab.xml`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `XSD` schema location points to `crontab.xsd` from within the
    `Magento_Cron` module.
  prefs: []
  type: TYPE_NORMAL
- en: The `id` attribute of a `group` element is set to the `default` value. In its
    modules, `Magento` defines two different groups, namely default and index. We
    used the `default` value, as this is the one that gets executed when the standard
    `php bin/magento cron:run` command is triggered on the console.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `group` element, we have individual jobs defined under the `job`
    element. The `job` element requires us to specify the `name`, `instance`, and
    `method` attributes. The `name` attribute has to be unique within the `group`
    element. The value of the `instance` and `method` attributes should point to the
    class that will be instantiated and the method within the class that needs to
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: The `schedule` element nested within the `cron` job specifies the desired time
    of job execution. It uses the same time expression as that of the entries in an
    operating system `crontab` file. The specific example that we will look at defines
    an expression (`*/2 * * * *`) that is executed every two minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have defined the `crontab.xml` file, we need to define the `Foggyline\Office\Model\Cron`
    class file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code simply defines a `logHello` method used by the `cron` job.
    In the `logHello` method, we used the `logger` method that was instantiated via
    the constructor. The `logger` method will make a log entry in the `var/log/system.log`
    file once it is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Once the command is executed, you will see the `Ran` jobs by schedule message
    in the console. Additionally, the `cron_schedule` table should get filled with
    all the `Magento cron` jobs that were defined.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should trigger the `php bin/magento cron:run` command in the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cron_schedule` table contains the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`schedule_id`: The auto-increment `primary` field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`job_code`: The value of the job `name` attribute, as defined in `crontab.xml`
    file, which equals to `foggyline_office_logHello` table in our example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: Defaults to the pending value for the newly created entries in the
    table and allows for a `pending`, `running`, `success`, `missed` or `error` value.
    Its value changes as the `cron` job traverses through its life cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`messages`: Stores the possible exception error message if the exception has
    occurred during a job''s execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created_at`: The `timestamp` value that denotes when a job was created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scheduled_at`: The `timestamp` value that denotes when a job was scheduled
    for execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`executed_at`: The `timestamp` value that denotes when a job''s execution started.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finished_at`: The `timestamp` value that denotes when a job has finished executing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unless we have already set the operating system `cron` to trigger the `php
    bin/magento cron:run` command, we need to trigger it on our own a few times every
    two minutes in order to actually execute the job. The first time a command is
    run, if the job does not exist in the `cron_schedule` table, `Magento` will merely
    queue it, but it won''t execute it. The subsequent `cron` runs will execute the
    command. Once we are sure that the `cron` job entry in the `cron_schedule` table
    has the `finished_at` column value filled, we will see an entry that looks like
    `[2015-11-21 09:42:18] main.INFO: Hello from Cron job! [] []` in the `var/log/system.log`
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While developing and testing `cron` jobs in `Magento`, we might need to truncate
    the `cron_schedule` table, delete `Magento's var/cache` value, and execute the
    `php bin/magento cron:run` command repetitively until we get it tested and working.
  prefs: []
  type: TYPE_NORMAL
- en: Notification messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Magento` implements the notification message mechanism via the `Messages`
    module. The `Messages` module conforms to `\Magento\Framework\Message\ManagerInterface`.
    Though the interface itself does not impose any session relation, an implementation
    adds interface-defined types of messages to a session and allows access to those
    messages later. In the `app/etc/di.xml` file, there is a preference defined for
    `\Magento\Framework\Message\ManagerInterface` towards the `Magento\Framework\Message\Manager`
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Message\ManagerInterface` specifies four types of messages, namely `error`,
    `warning`, `notice`, and `success`. The types of messages are followed by several
    key methods in the `Message\Manager` class, such as `addSuccess`, `addNotice`,
    `addWarning`, `addError`, and `addException`. The `addException` method is basically
    a wrapper for `addError` that accepts an `exception` object as a parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to run the following code in the `execute` method of `app/code/Foggyline/Office/Controller/Test/Crud.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this code executed, the result, as shown in the following screenshot,
    will appear on the page in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Notification messages](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notification messages appear both in the frontend and admin area.
  prefs: []
  type: TYPE_NORMAL
- en: 'The frontend layout `vendor/magento/module-theme/view/frontend/layout/default.xml`
    file defines it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `template` file that renders the messages is `view/frontend/templates/messages.phtml`
    in the `Magento_Theme` module. By looking at the `Magento\Framework\View\Element\Messages`
    class, you will see that the `_toHtml` method branches into `if-else` statements,
    depending on whether template is set or not. In case the template is not set,
    `_toHtml` internally calls the `_renderMessagesByType` method, which renders messages
    in the HTML format that are grouped by type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `view/adminhtml/layout/default.xml` admin layout file in the `Magento_AdminNotification`
    module defines it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `template` file that renders the messages is `view/adminhtml/templates/system/messages.phtml`
    in the `Magento_AdminNotification` module. When you look at the `Magento\AdminNotification\Block\System\Messages`
    class, you will see that its `_toHtml` is calling the `_toHtml` parent method,
    where the parent belongs to the `\Magento\Framework\View\Element\Template` class.
    This means that the output is relying on the `view/adminhtml/templates/system/messages.phtml`
    file in the `Magento_AdminNotification` module.
  prefs: []
  type: TYPE_NORMAL
- en: Session and cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sessions in `Magento` conform to `Magento\Framework\Session\SessionManagerInterface`.
    In the `app/etc/di.xml` file, there is a definition preference for the `SessionManagerInterface`
    class which points to the `Magento\Framework\Session\Generic` class type. The
    `Session\Generic` class is just an empty class that extends the `Magento\Framework\Session\SessionManager`
    class, which in turn implements the `SessionManagerInterface` class.
  prefs: []
  type: TYPE_NORMAL
- en: There is one important object that gets instantiated in the `SessionManager`
    instance that conforms to `\Magento\Framework\Session\Config\ConfigInterface`.
    On looking at `app/etc/di.xml` file, we can see a preference for `ConfigInterface`
    pointing to a `Magento\Framework\Session\Config` class type.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To fully understand the session behavior in `Magento`, we should study the inner
    workings of both the `SessionManager` and `Session\Config` classes.
  prefs: []
  type: TYPE_NORMAL
- en: '`Magento` uses cookies to keep track of a session. These cookies have a default
    lifetime of 3,600 seconds. When a session is established, a cookie with the name
    of `PHPSESSID` is created in the browser. The value of the cookie equals the session
    name. By default, sessions are stored in files in the `var/session` directory
    of `Magento`''s root installation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a look at these session files, you will see that session information
    is being stored in serialized strings that are divided into groupings such as
    `_session_validator_data, _session_hosts`, `default`, `customer_website_1`, and
    `checkout`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Session and cookies](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is not the finite list of grouping. Modules that implement their own session
    handling bits can add their own groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can store and retrieve information in a session by simply using expressions
    like the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding expressions will create and get an entry from the session under
    the default group.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the entire content of the default session group simply by using
    the `$this->sessionManager->getData()` expression, which will return an array
    of data that is similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `foggyline_office_var_1` value is right there among other
    session values.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several useful methods of `ConfigInterface` that we can use to fetch
    session configuration information; a few of these methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getCookieSecure`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCookieDomain`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCookieHttpOnly`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCookieLifetime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getSavePath`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getUseCookies`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getOptions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a result example of the `getOptions` method call on the `Session\Config`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Cookies often go hand in hand with sessions. Besides being used to link to a
    certain session, cookies are often used to store some information on the client
    side, thus tracking or identifying the return users and customers.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the pure PHP approach with the `setcookie` function, we can manage cookies
    in `Magento` through an instance of `Magento\Framework\Stdlib\CookieManagerInterface`.
    When you look at `app/etc/di.xml` file, you will see that the preference for `CookieManagerInterface`
    points to a class of the `Magento\Framework\Stdlib\Cookie\PhpCookieManager` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following restrictions are worth noting when it comes to `Magento` cookies:'
  prefs: []
  type: TYPE_NORMAL
- en: We can set maximum of 50 cookies in the system. Otherwise, `Magento` will throw
    an `Unable to send the cookie. Maximum number of cookies would be exceeded` exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can store a cookie with a maximum size of 4096 bytes. Otherwise, `Magento`
    will throw an `Unable to send the cookie. Size of \'%name\' is %size bytes` exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By imposing these restrictions, `Magento` ensures that we are compatible with
    most browsers.
  prefs: []
  type: TYPE_NORMAL
- en: The `CookieManagerInterface` class, among other things, specifies the `setSensitiveCookie`
    method requirement. This method sets a value in a private cookie with the given
    `$name $value` pairing. Sensitive cookies have **HttpOnly** set to true and thus
    cannot be accessed by JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we will soon demonstrate in the following examples, to set a public or private
    cookie, we can help ourselves by using instances of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\Magento\Framework\Stdlib\Cookie\CookieMetadataFactory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\Stdlib\CookieManagerInterface`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\Session\Config\ConfigInterface`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can set public cookies in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will result in a cookie, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Session and cookies](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can set private cookies in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will result in a cookie, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Session and cookies](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Interestingly, both the public and private cookies in the preceding example
    show that **HttpOnly** is checked off because by default, a `Magento` admin has
    **Stores** | **Settings** | **Configuration** | **General** | **Web** | **Default
    Cookie Settings** | **Use HTTP Only** set to **Yes**. Since we are using the `setHttpOnly`
    method in the public cookie example, we simply picked up the `config` value via
    `$this->sessionConfig->getCookieHttpOnly()` and passed it on. If we comment out
    that line, we will see that the public cookie does not really set **HttpOnly**
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Magento` supports the messages logging mechanism via its `\Psr\Log\LoggerInterface`
    class. The `LoggerInterface` class has a preference defined within `app/etc/di.xml`
    file for the `Magento\Framework\Logger\Monolog` class type. The actual `crux`
    of implementation is actually in the `Monolog` parent class named `Monolog\Logger`,
    which comes from the `Monolog` vendor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LoggerInterface` class uses the following eight methods to write logs
    to the eight RFC 5424 levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '`debug`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notice`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`warning`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`critical`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alert`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emergency`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use a logger, we need to pass the `LoggerInterface` class to a constructor
    of a class from within we want to use it and then simply make one of the following
    method calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the preferred shorter version through individual log level type
    methods is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Both approaches result in the same two log files being created in `Magento`,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var/log/debug.log`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var/log/system.log`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `debug.log` file contains only the debug level type of the log, while the
    rest are saved under `system.log`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Entries within these logs will then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these `logger` methods can accept an entire array of arbitrary data
    called `context`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding expression will produce the following entry in `system.log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can manually delete any of the `.log` files from the `var/log` directory,
    and `Magento` will automatically create it again when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '`Magento` also has another logging mechanism in place, where it logs the following
    actions in the `log_*` tables in a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '`log_customer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log_quote`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log_summary`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log_summary_type`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log_url`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log_url_info`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log_visitorz`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log_visitor_info`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log_visitor_online`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worth noting that this database logging is not related in any way to `Psr`
    logger that was described previously. While `Psr` logger serves developers within
    the code to group and log certain messages according to the `Psr` standard, the
    database logging logs the live data that is a result of `user/customer` interaction
    in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `Magento` keeps database logs for around 180 days. This is a configurable
    option that can be controlled in the `Magento` admin area under the **Stores**
    | **Settings** | **Configuration** | **Advanced** | **System** | **Log Cleaning**
    tab with other log related options, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Logging](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Configuration** options that are shown in the preceding screenshot only bare
    meaning operating system `cron` is triggering `Magento cron`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can execute two commands on terminal: `php bin/magento log:status` to get
    the current state information about log tables and `php bin/magento log:clean`
    to force the clearing of tables.'
  prefs: []
  type: TYPE_NORMAL
- en: The profiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Magento` has an in-built profiler that can be used to identify performance
    problems on the server side. In a nutshell, the profiler can tell us the execution
    time of certain chunks of code. There is nothing that great with its behavior.
    We can only get the execution time of code blocks or individual expressions that
    have been wrapped by the profiler''s start and stop methods. On its own, `Magento`
    calls for the profiler extensively across its code. However, we can''t see it
    in effect as the profiler output is disabled by default.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Magento` supports three profiler outputs, namely `html`, `csvfile`, and `firebug`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the profiler, we can edit `.htaccess` and add one of the following
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetEnv MAGE_PROFILER "html"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetEnv MAGE_PROFILER "csvfile"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetEnv MAGE_PROFILER "firebug"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The HTML type of profiler will show its output into the footer area of a page
    that we open in the browser, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The profiler](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `csv` file type of profiler will output into `var/log/profiler.csv`, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The profiler](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The firebug type of profiler will output into `var/log/profiler.csv`, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The profiler](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The profiler outputs the following pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Time` profiler shows the time spent from `Profiler::start` to `Profiler::stop`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Avg` profiler shows the average time spent from `Profiler::start` to `Profiler::stop`
    for cases where `Cnt` is greater than one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cnt` profiler shows the integer value of how many times we have started the
    profiler with the same timer name. For example, if we have called `\Magento\Framework\Profiler::start(''foggyline:office'')`;
    twice somewhere in the code, then `Cnt` will show the value of `2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Emalloc` profiler stands for the amount of memory allocated to PHP. It is
    a mix of the core PHP `memory_get_usage` function without the true parameter passed
    to it and the timer values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RealMem` profiler also stands for the amount of memory allocated to PHP whose
    final value is also obtained via the `memory_get_usage` function minus the timer
    values, but this time with the true parameter passed to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can easily add our own `Profiler::start` calls anywhere in the code. Every
    `Profiler::start` should be followed by some code expressions and then finalized
    with a `Profiler::stop` call, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on where we call the profiler in the code, the resulting output should
    be similar to the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The profiler](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Events and observers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Magento` implements the observer pattern through `\Magento\Framework\Event\ManagerInterface`.
    In `app/etc/di.xml`, there is a preference for `ManagerInterface` that points
    to the `Magento\Framework\Event\Manager\Proxy` class type. The `Proxy` class further
    extends the `\Magento\Framework\Event\Manager` class that implements the actual
    event dispatch method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Events are dispatched by calling a dispatch method on the instance of the `Event\Manager`
    class and passing the name and some data, which is optional, to it. Here''s an
    example of a `Magento` core event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `$this->eventManager` is an instance of the previously mentioned `Event\Manager`
    class. In this case, the event name equals to `customer_customer_authenticated`,
    while the data passed to the event is the array with two elements. The preceding
    event is fired when the authenticate method is called on `\Magento\Customer\Model\AccountManagement`,
    that is, when a customer logs in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dispatching an event only makes sense if we expect someone to observe it and
    execute their code when the event is dispatched. Depending on the area from which
    we want to observe events, we can define observers in one of the following XML
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app/code/{vendorName}/{moduleName}/etc/events.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app/code/{vendorName}/{moduleName}/etc/frontend/events.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app/code/{vendorName}/{moduleName}/etc/adminhtml/events.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's define an observer that will log an e-mail address of an authenticated
    user into a `var/log/system.log` file. We can use the `Foggyline_Office` module
    and add some code to it. As we are interested in the storefront, it makes sense
    to put the observer in the `etc/frontend/events.xml` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define the `app/code/Foggyline/Office/etc/frontend/events.xml` file
    with content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are specifying a `foggyline_office_customer_authenticated` observer
    for the `customer_customer_authenticated` event. The observer is defined in the
    `LogCustomerEmail` class that is placed in the `Observer` module directory. The
    `Observer` class has to implement the `Magento\Framework\Event\ObserverInterface`
    class. The `Observer` interface defines a single execute method. The execute method
    hosts the observer code and is executed when the `customer_customer_authenticated`
    event is dispatched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and define the `Foggyline\Office\Observer\LogCustomerEmail`
    class in the `app/code/Foggyline/Office/Observer/LogCustomerEmail.php` file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `execute` method takes a single parameter called `$observer` of the `\Magento\Framework\Event\Observer`
    type. The event that we are observing is passing two pieces of data within the
    array, namely the `model` and `password`. We can access this by using the `$observer->getEvent()->get{arrayKeyName}`
    expression. The `$customer` object is an instance of the `Magento\Customer\Model\Data\CustomerSecure`
    class, which contains properties such as `email`, `firstname`, `lastname`, and
    so on. Thus, we can extract the e-mail address from it and pass it to logger's
    `info` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to observe existing events, let''s see how we can dispatch
    our own events. We can dispatch events from almost anywhere in the code, with
    or without data, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth noting that there are two types of events; we can group them in
    the following way according to the way their name is assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static**: `$this->eventManager->dispatch(''event_name'', ...)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic**: `$this->eventManager->dispatch({expression}.''_event_name'', ...)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The static events have a fixed string for a name, while the dynamic ones have
    a name that is determined during the runtime. Here''s a nice example of the core
    `Magento` functionality from the `afterLoad` method that is defined under `lib/internal/Magento/Framework/Data/AbstractSearchResult.php`,
    which showcases how to use both types of events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see a *static* event (`abstract_search_result_load_after`) and a dynamic
    event (`$this->eventPrefix . ''_load_after''`). The `$this->eventPrefix` is an
    expression that gets evaluated during the runtime. We should be careful when using
    dynamic events as they are triggered under multiple situations. Some interesting
    dynamic events are the one defined on classes like the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Magento\Framework\Model\AbstractModel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$this->_eventPrefix . ''_load_before''`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$this->_eventPrefix . ''_load_after''`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$this->_eventPrefix . ''_save_commit_after''`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$this->_eventPrefix . ''_save_before''`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$this->_eventPrefix . ''_save_after''`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$this->_eventPrefix . ''_delete_before''`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$this->_eventPrefix . ''_delete_after''`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$this->_eventPrefix . ''_delete_commit_after''`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$this->_eventPrefix . ''_clear''`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$this->_eventPrefix . ''_load_before''`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$this->_eventPrefix . ''_load_after''`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Magento\Framework\App\Action\Action`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''controller_action_predispatch_'' . $request-> getRouteName()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''controller_action_predispatch_'' . $request-> getFullActionName()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''controller_action_postdispatch_'' . $request-> getFullActionName()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''controller_action_postdispatch_'' . $request-> getRouteName()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Magento\Framework\View\Result\Layout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''layout_render_before_'' . $this->request-> getFullActionName()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These events are fired on the `model`, `collection`, `controller`, and `layout`
    classes, which are probably among the most used backend elements that often require
    observing and interacting. Even though we can say that the full event name is
    known during the runtime along with the dynamic event, this can be assumed even
    before the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: For example, assuming that we want to observe `'controller_action_predispatch_'
    . $request->getFullActionName()` for the `Foggyline_Office` module's `Crud` controller
    action, the actual full event name will be `'controller_action_predispatch_foggyline_office_test_crud'`,
    given that `$request->getFullActionName()` will resolve to `foggyline_office_test_crud`
    during the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Cache(s)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Magento` has eleven out-of-the-box cache types, according to the following
    list. These are used across many levels within the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration**: Various XML configurations that were collected across modules
    and merged'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layouts**: Layout building instructions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blocks HTML output**: Page blocks HTML'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collections data**: Collection data files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reflection data**: API interfaces reflection data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database DDL operations**: Results of DDL queries, such as describing tables
    or indexes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EAV types and attributes**: Entity types declaration cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Page cache**: Full page caching'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Translations**: Translation files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrations configuration**: Integration configuration file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrations API configuration**: Integrations API configuration file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web services configuration**: REST and SOAP configurations, generated WSDL
    file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is also **Additional Cache Management** that manages the cache for the
    following files:'
  prefs: []
  type: TYPE_NORMAL
- en: Previously generated product image files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Themes JavaScript and CSS files combined to one file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preprocessed view files and static files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these caches can be cleared separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily define our own cache type. We can do so by first creating an
    `app/code/Foggyline/Office/etc/cache.xml` file with content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When defining a new cache type, we need to specify its `name` and `instance`
    attributes. The `name` attribute of the `type` element should be set to `foggyline_office`
    and should be unique across `Magento`. This value should match the `TYPE_IDENTIFIER`
    constant value on the `Foggyline\Office\Model\Cache` class, which will be created
    soon. The `instance` attribute holds the class name that we will use for caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will define the `Foggyline\Office\Model\Cache` class in the `app/code/Foggyline/Office/Model/Cache.php`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `Cache` class extends from `TagScope` and specifies its own values for `TYPE_IDENTIFIER`
    and `CACHE_TAG`, passing them along to the parent constructor in the `__construct`
    method. With these two files (`cache.xml` and `Cache`), we have basically defined
    a new cache type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have specified the `cache.xml` file and the referenced `cache` class,
    we should be able to see our cache type in the `Magento` admin under the **System**
    | **Tools** | **Cache Management** menu, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cache(s)](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: On its own, simply defining a new cache does not mean that it will get filled
    and used by `Magento`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to use the cache anywhere within your code, you can do so
    by first passing the instance of the cache class to the constructor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can execute a chunk of code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how we first try to load the value from the existing
    cache entry, and if there is none, we save it. If the cache type is set to `disabled`
    under the **Cache Management** menu, then the preceding code will never save and
    pull the data from the cache, as it is not in effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a look at the `var/cache` folder of `Magento` at this point, you
    will see something similar to what''s shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cache(s)](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '`Magento` created two cache entries for us, namely `var/cache/mage-tags/mage---a8a_OFFICE`
    and `var/cache/mage--f/mage---a8a_SOME_SPECIFIC_ID`. The `mage---a8a_OFFICE` file
    has only a single line of entry in this specific case, and the entry is the `a8a_SOME_SPECIFIC_ID`
    string, which obviously points to the other file. The `mage---a8a_SOME_SPECIFIC_ID`
    file contains the actual serialized `$objInfo` array.'
  prefs: []
  type: TYPE_NORMAL
- en: The `a8a_` prefix and other prefixes in the `cache` file names are not really
    relevant to us; this is something that `Magento` adds on its own. What is relevant
    to us is the passing of proper individual cache tags to the chunks or variables
    that we want to cache, like in the preceding example, and the `TYPE_IDENTIFIER`
    and `CACHE_TAG` tags that we set for the `Cache` class.
  prefs: []
  type: TYPE_NORMAL
- en: Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Magento` provides support for widgets. Though the word "widget" might imply
    frontend development skills and activities, we will look at them as a part of
    the backend development flow because creating useful and robust widgets requires
    a significant amount of backend knowledge.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Magento` provides several out-of-the-box widgets; some of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: CMS page link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMS static block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catalog category link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catalog new products list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catalog product link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catalog products list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orders and returns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recently compared products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recently viewed products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a fully custom widget, we start by defining `app/code/Foggyline/Office/etc/widget.xml`
    with content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `id` widget has been set to `foggyline_office`, while the class powering
    widget has been set to `Foggyline\Office\Block\Widget\Example`. the `widget` class
    is basically a `block` class that extends from `\Magento\Framework\View\Element\AbstractBlock`
    and implements `\Magento\Widget\Block\BlockInterface`. The `label` and `description`
    element set values appear under the `Magento` admin when we select the widget
    for use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters of a widget are its configurable options that translate into
    HTML form elements, depending on the `type` and `source_model` options that we
    have selected. In the following example, we will demonstrate the usage of the
    `select` and `text` elements to retrieve input from a user, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Widgets](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s proceed by creating the actual `Widget`\`Example` class in the `app/code/Foggyline/Office/Block/Widget/Example.php`
    file with content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: What is happening here is that we are using `Element\Text` as a block type and
    not `Element\Template` because we want to simplify the example, as `Element\Template`
    will require the `phtml` template to be defined as well. By using `Element\Text`,
    we can simply define `_beforeToHtml` and call the `setText` method to set the
    text string of the block's output. We will build the output string by picking
    up the `var1` and `var2` variables, which were passed as parameters to the block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we open the `Magento` admin area, go to **Content** | **Elements**
    | **Pages**, and select **Home Page** to edit, we should be able to click on the
    **Insert Frontend App** button and add our widget to the page. Alternatively,
    if we are not editing the page content in the `WYSIWYG` mode, we can also add
    the widget manually to the page by using the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we should see the example widget: `var1=1, var2=5` string in the browser
    while visiting the home page of the storefront.'
  prefs: []
  type: TYPE_NORMAL
- en: We can use frontend apps to create highly configurable and embeddable widgets
    that users can easily assign to a CMS page or block.
  prefs: []
  type: TYPE_NORMAL
- en: Custom variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables are a handy little feature of a core `Magento_Variable` module. `Magento`
    allows you to create custom variables and then use them in e-mail templates, the
    `WYSIWYG` editor, or even code expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps outline how we can create a new variable manually:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Magento` admin area, navigate to **System** | **Other Settings** | **Custom
    Variables**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Add New Variable** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While keeping in mind the **Store View** switcher, fill in the required **Variable
    Code** and **Variable Name** options, and preferably one of the optional options,
    either **Variable HTML Value** or **Variable Plain Value**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Save** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have created the custom variable, we can use it in an e-mail template
    or the `WYSIWYG` editor by calling it using the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding expression will call for the value of the `custom` variable with
    code `foggyline_hello`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables can be used within various code expressions, though it is not recommended
    to rely on the existence of an individual variable, as an admin user can delete
    it at any point. The following example demonstrates how we can use an existing
    variable in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `$this->_variableFactory` is an instance of `\Magento\Variable\Model\VariableFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: If used in the right way, variables can be useful. Storing information such
    as phone numbers or specialized labels that are used in CMS pages, blogs, and
    e-mail templates is a nice example of using custom variables.
  prefs: []
  type: TYPE_NORMAL
- en: i18n
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**i18n** is the abbreviation for **internationalization**. `Magento` adds i18n
    support out of the box, thus adapting to various languages and regions without
    application changes. Within `app/functions.php`, there is a `__()` translation
    function, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This `translation` function accepts a variable number of arguments and passes
    them to a constructor of the `\Magento\Framework\Phrase` class and returns its
    instance. The `Phrase` class has the `__toString` method, which then returns the
    translated string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples of how we can use the `__()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__(''Translate me'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__(''Var1 %1, Var2 %2, Var %3'', time(), date(''Y''), 32)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__(''Copyright %1 <a href="%2">Magento</a>'', date(''Y''), ''http://magento.com'')`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings passed through the `translation` function are expected to be found under
    the local CSV files, such as `app/code/{vendorName}/{moduleName}/i18n/{localeCode}.csv`.
    Let's imagine for a moment that we have two different store views defined in the
    `Magento` admin area under **Stores** | **Settings** | **All Stores**. One store
    has **Store** | **Settings** | **Configuration** | **General** | **Locale Options**
    | **Locale** set to **English (United Kingdom)** and the other one to **German
    (Germany)**. The local code for **English (United Kingdom)** is `en_GB`, and for
    **German (Germany)**, it is `de_DE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `de_DE` locale, we will add translation entries in the `app/code/Foggyline/Office/i18n/de_DE.csv`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `en_GB` locale, we will add translation entries in the `app/code/Foggyline/Office/i18n/en_GB.csv`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the two CSV files, a pattern emerges. We can see that the CSV files
    function in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: Individual translation strings are provided according to every line of CSV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each line further comprises two individual strings that are separated by a comma
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both individual strings are surrounded by quotes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a string contains quotes, it is escaped by a double quote so that it does
    not break translation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `%1`, `%2`, `%3`...`%n` pattern is used to mark variable placeholders that
    we provided during application runtime through the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Magento` supports several commands related to its `bin/magento` console tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute a console command as follows, Magento will recursively look for
    translatable expressions within PHP, PHTML, or XML files that have phrases to
    translate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The output of the preceding command will basically overwrite the `app/code/Foggyline/Office/i18n/en_GB.csv`
    file, which has all the `Foggyline/Office` module translatable phrases. This is
    a nice way of aggregating all the translatable phrases into appropriate locale
    files, such as `en_GB.csv` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The translation CSV files can also be placed under the individual theme. For
    example, let''s imagine a situation where we add content to `app/design/frontend/Magento/blank/i18n/en_GB.csv`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, a `Translate me` string output of the storefront for the `en_GB` locale
    would resolve to `Theme_en_GB Translate me` and not to the `en_GB Translate me`
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Theme CSV translations take higher precedence than module CSV translations,
    thus enabling developers to override individual module translations.
  prefs: []
  type: TYPE_NORMAL
- en: Along with CSV translation files, `Magento` also supports a feature called ``can
    activate the inline translation in the `Magento` admin area by navigating to **Store**``
    **| **Settings** | **Configuration** | **Advanced** | **Developer** | **Translate
    Inline**. This feature can be turned on separately for admin and storefront, as
    shown in the following screenshot:**
  prefs: []
  type: TYPE_NORMAL
- en: '**![i18n](img/00051.jpeg)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**As shown in the preceding screenshot, when a feature is activated, red dotted
    borders appear around the HTML elements. Hovering over an individual element shows
    a little book icon near the individual element at the bottom left corner. Clicking
    on the book icon opens a popup, as shown in the following screenshot:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**![i18n](img/00052.jpeg)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**It is important to note that these red dotted borders and the book icon will
    only appear for strings that we passed through the `__()` translate function.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Here, we can see various pieces of information about the string, such as
    the `Shown`, `Translated`, and `Original` string. There is also an input field
    called `Custom`, where we can add a new translation. Inline translation strings
    are stored in the `translation` table in the database.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Inline translation takes higher precedence than theme CSV translation files.**'
  prefs: []
  type: TYPE_NORMAL
