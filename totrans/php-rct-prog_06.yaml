- en: Chapter 6. PHP Streams API and Higher-Order Observables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 PHP Streams API和更高阶Observables
- en: In this chapter, we'll introduce a lot of new features that we need for the
    next chapter. Almost everything covered in this chapter is related to **PHP Streams
    API**, Promises and event loops (`reactphp/event-loop` project in our case). This
    also includes a couple of more advanced RxPHP operators working with so-called
    higher-order Observables.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍许多我们为下一章所需的新特性。本章涵盖的几乎所有内容都与**PHP Streams API**、Promises和事件循环（在我们的案例中是`reactphp/event-loop`项目）相关。这还包括一些更高级的RxPHP操作符，它们与所谓的更高阶Observables一起工作。
- en: 'In particular, in this chapter, we''ll do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下几件事：
- en: Quickly look at using Promises in PHP with the `reactphp/promise` library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速了解使用PHP中的`reactphp/promise`库来使用Promises
- en: Introduce PHP Streams API and, with examples, see what benefits it brings with
    minimal or no effort
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍PHP Streams API，并通过示例查看它带来的好处，无需或几乎无需额外努力
- en: Examine the internals of `StreamSelectLoop` class, this time in the context
    of PHP Streams API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`StreamSelectLoop`类的内部结构，这次是在PHP Streams API的上下文中
- en: See what caveats we need to be aware of when working with non-blocking code
    in event loops
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看我们在使用事件循环中的非阻塞代码时需要注意的注意事项
- en: Talk about higher-order Observables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论更高阶Observables
- en: Introduce four new and more advanced operators, `concatAll()`, `mergeAll()`, `combineLatest()`
    and `switchMap()`, which are intended to work with higher-order Observables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍四个新的更高级的操作符，`concatAll()`、`mergeAll()`、`combineLatest()`和`switchMap()`，它们旨在与更高阶Observables一起工作
- en: This chapter is going to introduce a lot of new things we haven't encountered
    yet. However, all of them have their benefits in practice, as we'll see in the
    next chapter, where we'll write an application that spawns multiple subprocesses
    on the go. Each subprocess will be a self-sufficient WebSocket server itself,
    and we'll use knowledge gained in this chapter to communicate with them and to
    collect information from them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍许多我们尚未遇到的新事物。然而，所有这些在实践中都有其益处，正如我们在下一章中将要看到的，我们将编写一个在运行时产生多个子进程的应用程序。每个子进程本身就是一个自给自足的WebSocket服务器，我们将使用本章中获得的知识与他们通信并从他们那里收集信息。
- en: Using Promises in PHP
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PHP中使用Promises
- en: While using Reactive Extensions, we think of data as continuous streams that
    emit data over time. A similar, and probably more familiar, concept is Promises,
    which represent a single value in the future.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用响应式扩展时，我们认为数据是连续的流，随着时间的推移发出数据。一个类似且可能更熟悉的概念是Promises，它代表未来的单个值。
- en: You've probably met Promises in libraries such as jQuery, where it's commonly
    used to handle responses from an AJAX request. There are multiple implementations
    in PHP, but the principle is always the same. We're going to use a library called
    `reactphp/promise` ( [https://github.com/reactphp/promise](https://github.com/reactphp/promise)
    ), which follows Promises/A proposal ( [http://wiki.commonjs.org/wiki/Promises/A](http://wiki.commonjs.org/wiki/Promises/A)
    ) and adds some extra functionality as well. Since we're going to use this library
    for this and the next chapter, we will have a look at how to use it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在jQuery等库中遇到过Promises，它通常用于处理AJAX请求的响应。PHP中有多种实现，但原则始终相同。我们将使用一个名为`reactphp/promise`（[https://github.com/reactphp/promise](https://github.com/reactphp/promise)）的库，该库遵循Promises/A提案（[http://wiki.commonjs.org/wiki/Promises/A](http://wiki.commonjs.org/wiki/Promises/A)）并添加了一些额外的功能。由于我们将使用这个库为本章和下一章，我们将看看如何使用它。
- en: 'Install `react/promise` package via composer:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用composer安装`react/promise`包：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will use two basic classes:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个基本类：
- en: '`Promise`: This class represents a result of a deferred computation that will
    be available in the future.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise`：这个类表示一个延迟计算的结果，该结果将在未来可用。'
- en: '`Deferred`: This class represents an action that''s pending. It returns a single
    instance of Promise, which is resolved or rejected. Usually, by resolving a Promise,
    we understand that the action ended successfully, while rejection means it failed.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Deferred`：这个类表示一个挂起的操作。它返回一个Promise的单个实例，该实例将被解决或拒绝。通常，通过解决一个Promise，我们理解操作已成功结束，而拒绝则意味着它失败了。'
- en: 'Each Promise is going to be resolved or rejected, and we can handle its results
    via multiple methods (we can call them operators as well, since they serve a similar
    purpose, like in Rx). Each of these methods returns a new Promise, so we''ll be
    able to chain them in a very similar way to how we do it in Rx:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Promise` 都将被解决或拒绝，我们可以通过多个方法（我们也可以将它们称为操作符，因为它们具有类似的作用，如 Rx）来处理其结果。这些方法中的每一个都返回一个新的
    `Promise`，因此我们可以以与在 Rx 中执行的方式非常相似的方式将它们链式调用：
- en: '`then()`: This method takes two callbacks as arguments. The first one is called
    only when the Promise is resolved, while the second one is called only when it''s
    rejected. Each callback can return a modified value, which is passed to the next
    operator.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`then()`: 此方法接受两个回调函数作为参数。第一个回调函数仅在 `Promise` 被解决时调用，而第二个回调函数仅在它被拒绝时调用。每个回调函数都可以返回一个修改后的值，该值将被传递给下一个操作符。'
- en: '`done()`: Similarly to `then()`, it takes two callbacks as arguments. However,
    this method returns null, so it doesn''t allow chaining. It''s intended only to
    consume the result and prevents you from modifying it any further.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`done()`: 与 `then()` 类似，它接受两个回调函数作为参数。然而，此方法返回 `null`，因此不允许链式调用。它仅用于消费结果，并防止您进一步修改它。'
- en: '`otherwise()`: This is a handler when the Promise is rejected or when the preceding `then()`
    method throws an exception.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`otherwise()`: 当 `Promise` 被拒绝或前面的 `then()` 方法抛出异常时，这是一个处理程序。'
- en: '`always()`: This is the cleanup method called when the Promise is either resolved
    or rejected.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`always()`: 这是当 `Promise` 被解决或拒绝时调用的清理方法。'
- en: Using the then() and done() methods
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 then() 和 done() 方法
- en: 'We can demonstrate how to use a `Promise` and `Deferred` classes with the `then()`
    and `done()` methods in the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下示例演示如何使用 `Promise` 和 `Deferred` 类以及 `then()` 和 `done()` 方法：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `promise()` method returns an instance of the `Promise` class, which is
    then chained with two `then()` and one `done()` calls. We've mentioned that a `Promise`
    class represents a single value in the future. For this reason, calling `promise()`
    method multiple times always returns the same `Promise` object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`promise()` 方法返回 `Promise` 类的一个实例，然后通过两个 `then()` 和一个 `done()` 调用来链式调用。我们提到，`Promise`
    类代表未来的单个值。因此，多次调用 `promise()` 方法总是返回相同的 `Promise` 对象。'
- en: In the first `then()` call, we'll print the value and return `$val + 1`. This
    modified value will be passed to the consecutive `then()` call, which again updates
    the value and passes it to `done()`. The `done()` method returns `null`, so it
    can't be chained with any more operators.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个 `then()` 调用中，我们将打印值并返回 `$val + 1`。这个修改后的值将被传递到后续的 `then()` 调用，该调用再次更新值并将其传递给
    `done()`。`done()` 方法返回 `null`，因此不能与任何更多的操作符链式调用。
- en: 'The output is then as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that it's the instance of the `Deferred` class that is responsible for
    resolving or rejecting the `Promise` class because it represents the asynchronous
    action. The `Promise` class, on the other hand, represents just the result of
    the `Deferred` class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，负责解决或拒绝 `Promise` 类的是 `Deferred` 类的实例，因为它表示异步操作。另一方面，`Promise` 类仅表示 `Deferred`
    类的结果。
- en: Using the otherwise() and always() methods
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 otherwise() 和 always() 方法
- en: 'Similarly to using `then()` and `done()`, we''ll handle exceptions with `otherwise()`,
    and we''ll also append `always()`, which will be called regardless of the `Promise`
    class being resolved or rejected:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 `then()` 和 `done()` 类似，我们将使用 `otherwise()` 处理异常，并且还会附加 `always()`，无论 `Promise`
    类是被解决还是被拒绝，它都会被调用：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, the callable for `then()` throws an exception, which is caught by the following `otherwise()`
    method. This chain of Promises is always finished by an `always()` call, even
    when we threw an exception in `then()`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`then()` 的可调用部分抛出一个异常，该异常被下面的 `otherwise()` 方法捕获。即使我们在 `then()` 中抛出异常，Promise
    链总是以一个 `always()` 调用结束。
- en: 'If we run this example, we''ll receive the following output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此示例，我们将收到以下输出：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `otherwise()` method is, in fact, just a shortcut for `then(null, $onRejected)`,
    so we could write it as a single call. However, this notation is split into two
    separate method calls, making it easier to understand. We can also test a scenario
    where we reject the `Promise` class instead of resolving it:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`otherwise()` 方法实际上只是 `then(null, $onRejected)` 的快捷方式，因此我们可以将其写为单个调用。然而，这种表示法被分成两个单独的方法调用，这使得它更容易理解。我们还可以测试一个场景，其中我们拒绝
    `Promise` 类而不是解决它：'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This skips the `then()` call and triggers only the `otherwise()` callable:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将跳过 `then()` 调用，并仅触发 `otherwise()` 可调用部分：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that the `always()` method was called in both situations. Also, note
    that the `otherwise()` method allows creating multiple handlers for different
    exception classes. If we don't specify the class type in the callable definition,
    it'll be triggered on any exception.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在两种情况下都调用了 `always()` 方法。此外，注意 `otherwise()` 方法允许为不同的异常类创建多个处理器。如果我们没有在可调用定义中指定类类型，它将在任何异常上触发。
- en: PHP Streams API
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP Streams API
- en: 'If we want to work with sockets in PHP, we''re offered two sets of methods,
    starting with one of these two prefixes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 PHP 中使用套接字，我们提供了两组方法，从以下两个前缀之一开始：
- en: '`socket_*`: Low-level API to the socket communication available since PHP 4.1\.
    This extension needs to be enabled when compiling PHP with the `--enable-sockets`
    option. You can check whether your PHP supports this API by running `php -i` in
    the console and watching for `--enable-sockets` under the `Configure Command`
    option.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket_*`：自 PHP 4.1 起可用的套接字通信的低级 API。在编译 PHP 时需要启用此扩展，可以使用 `--enable-sockets`
    选项。您可以通过在控制台中运行 `php -i` 并在 `Configure Command` 选项下查看 `--enable-sockets` 来检查您的
    PHP 是否支持此 API。'
- en: '`stream_*`: API introduced in PHP 4.3 that generalizes usage of file, network,
    and other operations under a unified set of functions. Streams in the sense of
    this API are resource objects that share some common behavior. This extension
    is part of PHP and doesn''t require any extra steps to be enabled. More stream
    functions were added in PHP 5, such as `stream_socket_server()`, which we''ll
    use in a moment.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream_*`：PHP 4.3 中引入的 API，它将文件、网络和其他操作的一般化使用统一到一组函数中。在这个 API 的意义上，流是具有一些共同行为的资源对象。此扩展是
    PHP 的一部分，不需要任何额外步骤即可启用。PHP 5 中添加了更多流函数，例如 `stream_socket_server()`，我们将在稍后使用它。'
- en: In general, we'll always want to use the newer `stream_*` API because it's a
    built-in part of PHP and offers better functionality.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们总是希望使用更新的 `stream_*` API，因为它 PHP 的内置部分，并提供了更好的功能。
- en: The core feature is that it's built around using resources. A resource in PHP
    is a special variable holding a reference to some external resource (this can
    be a socket connection, file handler, and so on). These have some limitations.
    For instance, they can't be serialized, for obvious reasons, and certain methods
    are not applicable with particular types of resources, such as `fseek()`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 核心特性是它围绕使用资源构建。在 PHP 中，资源是一个特殊的变量，它持有对某些外部资源的引用（这可以是套接字连接、文件句柄等）。这些有一些限制。例如，由于显而易见的原因，它们不能被序列化，并且某些方法对特定类型的资源不适用，例如
    `fseek()`。
- en: 'Working with resources and streams is unified, so we can use `stream_*` functions
    when, for example, writing data to files instead of the typical `fwrite()` function.
    Consider the following example, where we copy the content of a file to another
    file and instead of using `fwrite()`, or `file_get_content()` and `file_put_content()`,
    we''ll use `stream_copy_to_stream()`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与资源和流一起工作是一致的，因此当我们例如向文件写入数据时，我们可以使用 `stream_*` 函数而不是典型的 `fwrite()` 函数。考虑以下示例，我们将一个文件的内容复制到另一个文件，而不是使用
    `fwrite()`、`file_get_content()` 和 `file_put_content()`，我们将使用 `stream_copy_to_stream()`：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Both `$source` and `$dest` are resources. The `stream_copy_to_stream()` function
    just copies the content of one stream to another. How one resource reads the data
    and how the second resource writes the data is up to the inner implementation
    of this resource. We could also use `fseek()` to move the read cursor to some
    position instead of reading data from the beginning of the file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`$source` 和 `$dest` 都是资源。`stream_copy_to_stream()` 函数只是将一个流的内容复制到另一个流。一个资源如何读取数据以及第二个资源如何写入数据取决于该资源的内部实现。我们也可以使用
    `fseek()` 将读取光标移动到某个位置，而不是从文件开头读取数据：'
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now we have skipped the first five bytes of the file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经跳过了文件的前五个字节。
- en: There are many types of resources. We can see what types we're supporting with
    the `get_resource_type()` function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类型的资源。我们可以使用 `get_resource_type()` 函数查看我们支持哪些类型。
- en: 'In the following example, we create three different types of resources:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们创建了三种不同类型的资源：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can see that each resource type is identified by a different string:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到每种资源类型都由不同的字符串标识：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In [Chapter 3](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 3. Writing a Reddit Reader with RxPHP") , *Writing a Reddit Reader with
    RxPHP*, we read inputs from the console by opening a stream to `php://stdin` and
    using `fread()` to periodically (with `IntervalObservable`) get content of the
    current read buffer. We also used the `stream_set_blocking()` function to make
    the read stream nonblocking, which makes `fread()` return an empty string if there
    was no data available.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d "第
    3 章。使用 RxPHP 编写 Reddit 读者")，《使用 RxPHP 编写 Reddit 读者》，我们通过打开到 `php://stdin` 的流并使用
    `fread()` 来从控制台读取输入，通过 `IntervalObservable` 定期获取当前读取缓冲区的内容。我们还使用了 `stream_set_blocking()`
    函数来使读取流非阻塞，这样如果没有任何数据可用，`fread()` 将返回一个空字符串。
- en: Using an event loop is, of course, a viable option, but there's also a function
    made exactly for this purpose, called `stream_select()`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件循环当然是一个可行的选项，但还有一个专门为此目的创建的函数，称为 `stream_select()`。
- en: Using the stream_select() function
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 stream_select() 函数
- en: Instead of looping over all streams and checking manually whether they have
    any data available, we can use the `stream_select()` function ( [http://php.net/manual/en/function.stream-select.php](http://php.net/manual/en/function.stream-select.php)
    ). This function takes arrays of streams as parameters and waits until there's
    some activity on at least one of them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是遍历所有流并手动检查它们是否有任何可用数据，我们可以使用 `stream_select()` 函数（[http://php.net/manual/en/function.stream-select.php](http://php.net/manual/en/function.stream-select.php)）。此函数接受流数组作为参数，并等待至少其中一个流上有活动发生。
- en: 'Since any resource created with `fopen()` is a stream, we can use this function
    to wait for user input instead of using a loop:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用 `fopen()` 创建的任何资源都是流，我们可以使用此函数等待用户输入，而不是使用循环：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `stream_select()` function returns the number of active streams, or zero
    if the timeout elapsed. It takes five arguments in total, where the first four
    of them are required:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`stream_select()` 函数返回活动流的数量，如果超时则返回零。它总共接受五个参数，其中前四个是必需的：'
- en: '`array &$read`: This is the array of read streams (streams are checked for
    any available data to be read).'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array &$read`：这是读取流的数组（检查流是否有可读数据）。'
- en: '`array &$write`: This is the array of write streams. Streams listed here need
    to indicate they''re ready to write data.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array &$write`：这是写入流的数组。列出的流需要指示它们已准备好写入数据。'
- en: '`array &$except`: This is the array of streams with higher priority.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array &$except`：这是具有更高优先级的流的数组。'
- en: '`int $tv_sec`: This is the maximum time in seconds spent waiting for at least
    one of the streams to be active.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int $tv_sec`：这是等待至少一个流变为活动状态的最大秒数。'
- en: '`int $tv_usec` (optional): This is the time in microseconds added to the timeout
    in seconds.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int $tv_usec`（可选）：这是添加到超时秒数中的微秒数。'
- en: Each array is passed by reference, so we can't leave it with just `[]`; we need
    to pass it as a variable (`null` is also acceptable). The last integer parameter `5`
    is the timeout after which this function returns, even though it didn't catch
    any activity on any of its streams.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组都是通过引用传递的，所以我们不能只留下 `[]`；我们需要将其作为变量传递（`null` 也可以接受）。最后一个整数参数 `5` 是该函数返回的超时时间，即使它没有在其任何流上捕获任何活动。
- en: So in this example, we create a resource `$stdin` using `fopen()`, then wait
    for five seconds for any user input (the data is sent to the buffer by terminal
    after we press the ***Enter*** key) and then use `fgets()` to get the data from
    buffer and print it in reversed order.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个例子中，我们使用 `fopen()` 创建了一个资源 `$stdin`，然后等待五秒钟以获取任何用户输入（在按下 ***Enter*** 键后，数据由终端发送到缓冲区），然后使用
    `fgets()` 从缓冲区获取数据并按相反顺序打印。
- en: Notice that we had to make the `$stdin` stream nonblocking anyway. If we didn't,
    the `stream_select()` would never end, regardless the timeout.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们无论如何都必须使 `$stdin` 流非阻塞。如果我们不这样做，`stream_select()` 将永远不会结束，无论超时与否。
- en: StreamSelectLoop and stream_select() function
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StreamSelectLoop 和 stream_select() 函数
- en: We've been using the `StreamSelectLoop` class in  [Chapter 3](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 3. Writing a Reddit Reader with RxPHP") , *Writing a Reddit Reader with
    RxPHP*, to periodically emit values with `IntervalObservable`, or in  [Chapter
    2](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d "Chapter 2. Reactive
    Programming with RxPHP") , *Reactive Programming with RxPHP*, to check for user
    input. Let's combine what we've learned about PHP streams, `stream_select()` function,
    and `StreamSelectLoop` together and update the previous example to use `StreamSelectLoop`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 3 章](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d "第
    3 章。使用 RxPHP 编写 Reddit 读者") ，*使用 RxPHP 编写 Reddit 读者* 中使用了 `StreamSelectLoop` 类，以周期性地使用
    `IntervalObservable` 发射值，或者在 [第 2 章](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "第 2 章。使用 RxPHP 进行响应式编程") ，*使用 RxPHP 进行响应式编程* 中检查用户输入。让我们将我们关于 PHP 流、`stream_select()`
    函数和 `StreamSelectLoop` 的知识结合起来，并更新之前的示例以使用 `StreamSelectLoop`。
- en: 'The `StreamSelectLoop` class has an `addReadStream()` method to add streams
    (resources) and callables, which are executed when the stream is active. Then
    it calls `stream_select()` internally and waits for activity on any of the streams
    in a loop:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamSelectLoop` 类有一个 `addReadStream()` 方法，用于添加流（资源）和可调用函数，这些函数在流活跃时执行。然后它内部调用
    `stream_select()` 并在一个循环中等待任何流的活动：'
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, it should be obvious why the event loop class is called `StreamSelectLoop`
    and not `EventLoop` or just `Loop`: it uses `stream_select()` internally.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，很明显为什么事件循环类被称为 `StreamSelectLoop`，而不是 `EventLoop` 或仅仅是 `Loop`：它内部使用了 `stream_select()`。
- en: Now we know how `StreamSelectLoop` is able to work with PHP streams. However,
    a very good question is, how do Observables such as `IntervalObservable`, which
    periodically emit values, work when they don't use any streams?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了 `StreamSelectLoop` 如何与 PHP 流一起工作。然而，一个非常好的问题是，当 Observables，如 `IntervalObservable`，周期性地发射值时，它们不使用任何流是如何工作的？
- en: Scheduling events with StreamSelectLoop
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 StreamSelectLoop 安排事件
- en: Apart from using `StreamSelectLoop` to handle streams, we can also schedule
    one-time or periodical events by just specifying an interval and a callable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 `StreamSelectLoop` 来处理流之外，我们还可以通过指定一个间隔和一个可调用函数来安排一次性或周期性事件。
- en: 'Consider the following example, which creates two timers:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，它创建了两个计时器：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The periodic timer fires every second, while the one-time timer is fired just
    once after 1500ms. Output in the console will print values for the increasing
    `$counter` variable:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 周期性计时器每秒触发一次，而一次性计时器在 1500 毫秒后只触发一次。控制台输出将打印出增加的 `$counter` 变量的值：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So how is `StreamSelectLoop` able to schedule events when we're not using streams
    at all?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们根本不使用流时，`StreamSelectLoop` 是如何安排事件的呢？
- en: The answer is the `stream_select()` function and its fourth and fifth arguments.
    Even when we're not waiting for any stream activity, we can still make use of
    the timeouts provided to `stream_select()`. We could, in fact, achieve the same
    result if we used just the `usleep()` function to hold the script execution for
    a period of time. However, if we did use `usleep()`, we wouldn't be able to combine
    timers with streams.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 `stream_select()` 函数及其第四和第五个参数。即使我们不是在等待任何流活动，我们仍然可以利用 `stream_select()`
    提供的超时。实际上，如果我们只使用 `usleep()` 函数来暂停脚本执行一段时间，我们也可以达到相同的结果。然而，如果我们使用了 `usleep()`，我们就无法将计时器与流结合起来。
- en: When we start the event loop with `$loop->run()`, it iterates all its times
    and checks which timer is supposed to fire first. In our case it's the periodic
    timer that'll fire after one second, so `StreamSelectLoop` calls `stream_select()`
    and sets its fourth parameter (timeout) to one second. Since we didn't add any
    streams to the loop, the `stream_select()` call will always end with a timeout,
    which is intentional in this case.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `$loop->run()` 启动事件循环时，它会迭代所有时间并检查哪个计时器应该首先触发。在我们的例子中，是将在一秒后触发的周期性计时器，所以
    `StreamSelectLoop` 调用 `stream_select()` 并将其第四个参数（超时）设置为 一秒。由于我们没有向循环中添加任何流，`stream_select()`
    调用将始终以超时结束，这在当前情况下是故意的。
- en: If we did add a stream to the loop that would signal activity any time before
    the timer is supposed to fire, then `stream_select()` might be interrupted and
    the stream would be handled before the timer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向循环中添加了一个流，该流会在计时器应该触发之前任何时候发出活动信号，那么 `stream_select()` 可能会被中断，流会在计时器之前被处理。
- en: 'We can go back to our example where the `StreamSelectLoop` class works as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以回到我们的示例，其中 `StreamSelectLoop` 类的工作方式如下：
- en: We scheduled a one-second timeout that makes `stream_select()`return even when
    there's no stream activity.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们安排了一个一秒的超时，即使没有流活动，`stream_select()`也会返回。
- en: The `StreamSelectLoop` class checks what timers are due and calls their callables.
    Then, if the timer was periodical, it reschedules the timer to fire again in the
    future.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StreamSelectLoop`类检查哪些定时器已到期，并调用它们的可调用函数。然后，如果定时器是周期性的，它会重新安排定时器，以便在未来再次触发。'
- en: This was the first iteration of the internal loop where `stream_select()` caused
    the pause.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是内部循环的第一次迭代，其中`stream_select()`导致了暂停。
- en: At the second iteration, it checks for the nearest timers again. This time it's
    the one-time timer that'll fire in 500ms (1000ms already elapsed), so the timeout
    for `stream_select()` is going to be just 500ms.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二次迭代中，它再次检查最近的定时器。这次是将在500ms（已过去1000ms）触发的单次定时器，因此`stream_select()`的超时时间将仅为500ms。
- en: This goes on until we call `$loop->stop()` from one of the callables.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这会一直持续到我们从其中一个可调用函数中调用`$loop->stop()`。
- en: 'We can rewrite this example with a periodic timer to use `IntervalObservable`,
    while also reading any input from `php://stdin`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用周期性定时器重写这个示例，同时使用`IntervalObservable`读取任何来自`php://stdin`的输入：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Observables don't work directly with `StreamSelectLoop`, so we need to wrap
    it with a Scheduler. The `EventLoopScheduler` class inherits the `VirtualTimeScheduler`
    class that we explained in detail in the previous chapter, when we talked about
    testing and how it's used with the `TestScheduler` class. The principle with `EventLoopScheduler`
    is the same.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察者不能直接与`StreamSelectLoop`一起工作，因此我们需要用调度器包装它。`EventLoopScheduler`类继承自我们在上一章详细解释的`VirtualTimeScheduler`类，当时我们讨论了测试及其与`TestScheduler`类的使用。`EventLoopScheduler`的原则是相同的。
- en: The `EventLoopScheduler` class schedules timers on the `StreamSelectLoop` instance,
    which doesn't forbid us from using the same loop for streams also.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventLoopScheduler`类在`StreamSelectLoop`实例上安排定时器，这并不禁止我们为流使用相同的循环。'
- en: Minimalistic HTTP Server with StreamSelectLoop
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用StreamSelectLoop的最简HTTP服务器
- en: 'A nice example of using just `StreamSelectLoop` to create a simple HTTP web
    server is available on the GitHub page for the `react/event-loop` package:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用仅`StreamSelectLoop`创建简单HTTP服务器的良好示例可在`react/event-loop`包的GitHub页面找到：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This demo uses `stream_socket_server()` to create a listening TCP socket server
    accepting connections only from localhost on port `8080`. The `$server` stream
    is then added to the event loop, and every time a new connection is established,
    it's captured by `stream_select()`. Then, to actually accept the connection, we
    need to call the `stream_socket_accept()` function, which returns another stream
    representing the stream to this client. Then, with `addWriteStream()` we'll know
    when the client is ready to start receiving data.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用`stream_socket_server()`创建一个监听TCP套接字服务器，仅接受来自本地主机端口`8080`的连接。然后，`$server`流被添加到事件循环中，每次建立新的连接时，它都会被`stream_select()`捕获。然后，为了实际接受连接，我们需要调用`stream_socket_accept()`函数，该函数返回另一个流，代表到该客户端的流。然后，通过`addWriteStream()`我们将知道客户端何时准备好开始接收数据。
- en: 'There are four important things to notice:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个重要的事情需要注意：
- en: With `stream_socket_server()`, we can use multiple different protocols. The
    most common are `tcp`, `udp`, and `unix`. We can get a full list of all the available
    protocols with `stream_get_transports()`.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`stream_socket_server()`，我们可以使用多种不同的协议。最常见的是`tcp`、`udp`和`unix`。我们可以使用`stream_get_transports()`获取所有可用协议的完整列表。
- en: If we have *N* clients there are always *N+1* streams in the loop. This is because
    the server stream that accepts connections is inside the event loop as well.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有*N*个客户端，循环中始终有*N+1*个流。这是因为接受连接的服务器流也在事件循环内部。
- en: When we write data to the client stream, we need to be aware that it might not
    be able to write the entire response at once and we'll need to send it in chunks.
    That's why we always check how many bytes were written to the stream with `fwrite()`.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们向客户端流写入数据时，我们需要意识到它可能无法一次写入整个响应，我们需要分块发送。这就是为什么我们总是检查使用`fwrite()`写入流中的字节数。
- en: After we're done writing data to the write stream, we close it with `fclose()`
    and remove it from the loop because we don't need it anymore. When a new client
    connection is accepted it'll have its own write stream.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们完成向写入流写入数据后，我们使用`fclose()`关闭它，并从循环中移除，因为我们不再需要它。当接受新的客户端连接时，它将有自己的写入流。
- en: A note on nonblocking event loops
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于非阻塞事件循环的说明
- en: The implementation details of `StreamSelectLoop` suggest that it can't guarantee
    that all timers will fire exactly at the time they should. For example, if we
    created two timers that both need to fire after 500ms, then we can predict pretty
    accurately that the first callable will be executed after exactly 500ms. However,
    the callable for the second timer is dependent on the execution time of the first
    callable. This means that if the first callable took 100ms to execute; the second
    callable will be trigger after 600ms instead of 500ms.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamSelectLoop`的实现细节表明，它不能保证所有计时器都会在它们应该的时间精确触发。例如，如果我们创建了两个都需要在500ms后触发的计时器，那么我们可以相当准确地预测第一个可调用将在500ms后精确执行。然而，第二个计时器的可调用依赖于第一个可调用的执行时间。这意味着如果第一个可调用执行了100ms；第二个可调用将在600ms而不是500ms后触发。'
- en: An implication of this is that the event loop is nonblocking - as long as our
    code is nonblocking.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个影响是事件循环是非阻塞的——只要我们的代码是非阻塞的。
- en: There's no parallelism in PHP, thus all code is strictly sequential. If we write
    code that takes long to execute or needs to be blocking from its nature, it's
    going to cause the entire event loop to also be blocking.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中没有并行性，因此所有代码都是严格顺序的。如果我们编写了执行时间较长的代码或需要从本质上阻塞的代码，它将导致整个事件循环也变为阻塞。
- en: Using multiple StreamSelectLoop instances
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多个StreamSelectLoop实例
- en: In real-world PHP applications, where we need to work asynchronously with PHP
    streams, Observables, HTTP servers/clients, or WebSocket servers/clients (and
    basically any asynchronous code), we might need to use multiple event loops. This
    means a situation where each nonblocking part of the application requires its
    own event loop.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的PHP应用程序中，当我们需要使用PHP流、Observables、HTTP服务器/客户端或WebSocket服务器/客户端（以及基本上任何异步代码）进行异步工作时，我们可能需要使用多个事件循环。这意味着应用程序的每个非阻塞部分都需要自己的事件循环。
- en: For example, we need to use an event loop to use `IntervalObservable`, but we
    also need an event loop for a WebSocket server that needs to read data from a
    PHP stream.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们需要使用事件循环来使用`IntervalObservable`，但我们还需要一个事件循环来读取PHP流数据的WebSocket服务器。
- en: 'Consider the following example, where we simulate a similar scenario:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，其中我们模拟了类似的场景：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, the second `$loop2` will never start. The PHP interpreter will
    only stay in the first `$loop1`, which never ends because of the periodic timer.
    If we did it in reverse order (calling `$loop2` first and then `$loop1`) it would
    actually work. The second loop would just be delayed by two seconds because the
    first loop runs just one action and then ends (there are no other timers active,
    so it'll end automatically).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，第二个`$loop2`永远不会启动。PHP解释器将只停留在第一个`$loop1`中，因为它永远不会结束，因为周期性计时器。如果我们按相反的顺序做（首先调用`$loop2`然后是`$loop1`），它实际上会工作。第二个循环将只是延迟两秒钟，因为第一个循环只运行一个动作然后结束（没有其他计时器活跃，所以它会自动结束）。
- en: This is something we need to be aware of. In [Chapter 7](part0054_split_000.html#1JFUC2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 7. Implementing Socket IPC and WebSocket Server/Client") , *Implementing
    Socket IPC and WebSocket Server/Client*, we'll write an app that uses a WebSocket
    server and a Unix socket client that need to run at the same time. This means
    they both need to be able to read data from streams in a loop. The good thing
    is that the WebSocket server will use the same event loop implementation from `react/event-loop`
    package.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要注意的事情。在第7章[实现Socket IPC和WebSocket服务器/客户端](part0054_split_000.html#1JFUC2-bd355a22cf10407cb10df27e65585b8d
    "第7章。实现Socket IPC和WebSocket服务器/客户端")中，我们将编写一个同时运行WebSocket服务器和Unix套接字客户端的应用程序。这意味着它们都需要能够循环读取流中的数据。好事是WebSocket服务器将使用来自`react/event-loop`包的相同事件循环实现。
- en: The outcome of this is that, in PHP, we need to have just a single event loop,
    which might be a problem with certain libraries that need to work with their own
    event loop implementations, but don't expose any way we can hook them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，在PHP中，我们只需要一个事件循环，这可能会成为某些需要与自己的事件循环实现一起工作但又不公开任何我们可以挂钩的库的问题。
- en: However, this doesn't necessarily apply to RxJS or, in general, to JavaScript
    applications where the interpreter works differently to PHP. We'll talk about
    the differences when using RxJS and RxPHP in more depth in the last chapter of
    this book.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不一定适用于RxJS，或者更普遍地说，不适用于解释器工作方式与PHP不同的JavaScript应用程序。我们将在本书的最后一章更深入地讨论使用RxJS和RxPHP时的差异。
- en: Event loop interoperability in PHP
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PHP中的事件循环互操作性
- en: To tackle this problem there's an attempt to standardize even loop implementations
    to follow the same API.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，有人尝试标准化事件循环的实现，以遵循相同的API。
- en: The `async-interop/event-loop` package defines a set of interfaces that an even
    loop needs to implement to be truly interchangeable. This means that we can write
    a library that only relies on the interfaces provided by `async-interop/event-loop`
    and the end user can decide which even loop implementation they want to use.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`async-interop/event-loop` 包定义了一系列接口，事件循环需要实现这些接口才能真正互换。这意味着我们可以编写一个仅依赖于 `async-interop/event-loop`
    提供的接口的库，最终用户可以决定他们想要使用哪个事件循环实现。'
- en: We can have a look at an example of `StreamSelectLoop` we know already and use
    it only via the interface provided by `async-interop/event-loop`. As of now, `StreamSelectLoop`
    doesn't implement this interface natively so we'll need one more package `wyrihaximus/react-async-interop-loop`
    that wraps the event loop implementation from `react/event-loop` with `async-interop/event-loop`
    interface.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看一个我们已知的 `StreamSelectLoop` 示例，并通过 `async-interop/event-loop` 提供的接口来使用它。目前，`StreamSelectLoop`
    并没有原生实现这个接口，因此我们需要一个额外的包 `wyrihaximus/react-async-interop-loop`，它将 `react/event-loop`
    的事件循环实现用 `async-interop/event-loop` 接口包装。
- en: 'Our `composer.json` file will be very simple because we''ll have just a single
    required package:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `composer.json` 文件将会非常简单，因为我们只需要一个必需的包：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `wyrihaximus/react-async-interop-loop` package requires as dependencies
    both `async-interop/event-loop` and `react/event-loop` so we don't need to include
    them ourselves.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`wyrihaximus/react-async-interop-loop` 包需要作为依赖同时包含 `async-interop/event-loop`
    和 `react/event-loop`，所以我们不需要自己包含它们。'
- en: 'Then we''ll write a minimal example that schedules two actions using the `Loop`
    interoperability interface:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将编写一个使用 `Loop` 互操作性接口安排两个动作的最小示例：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that all our operations are done only on the `Loop` class which comes
    from the `async-interop/event-loop` package and its static methods. We already
    know that we always have to have only one event loop running at a time. This is
    why all the methods on the `Loop` class are static.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们所有的操作都是在来自 `async-interop/event-loop` 包的 `Loop` 类及其静态方法上进行的。我们已经知道我们一次只能有一个事件循环在运行。这就是为什么
    `Loop` 类上的所有方法都是静态的。
- en: The `setFactory()` method tells the `Loop` class how to create an instance of
    our event loop. In our case we're using `react/event-loop` that is wrapped inside `ReactDriverFactory`
    to follow the `async-interop` interface.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`setFactory()` 方法告诉 `Loop` 类如何创建我们的事件循环实例。在我们的例子中，我们使用 `react/event-loop`，它被包裹在
    `ReactDriverFactory` 中，以遵循 `async-interop` 接口。'
- en: Event loops and future versions of RxPHP
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件循环和 RxPHP 的未来版本
- en: Using event loops (and thus all operators requiring asynchronous scheduling)
    has been significantly simplified in RxPHP 2 and most of the time we don't even
    need to worry about starting the event loop ourselves.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxPHP 2 中，使用事件循环（以及因此需要异步调度的所有操作符）已经显著简化，大多数时候我们甚至不需要担心自己启动事件循环。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: RxPHP 2 was supposed to be based on the async-interop/event-loop interface.
    However, the specification is still unstable so the RxPHP team decided to rollback
    to the RxPHP 1 style of event loops. The following paragraphs describe how the
    event loops should be used in the future versions of RxPHP (maybe RxPHP 3). At
    the end, RxPHP 2 is based on the `StreamSelectLoop` class from the `reactphp`
    library as we're used to.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: RxPHP 2 本来应该基于 `async-interop/event-loop` 接口。然而，该规范仍然不稳定，所以 RxPHP 团队决定回滚到 RxPHP
    1 风格的事件循环。以下段落描述了在 RxPHP 的未来版本（可能是 RxPHP 3）中应该如何使用事件循环。最后，RxPHP 2 基于我们熟悉的 `reactphp`
    库中的 `StreamSelectLoop` 类。
- en: 'RxPHP in the future will rely on the `async-interop/event-loop` interface.
    Since we don''t want to start the loop ourselves we can autoload a bootstrap script
    from RxPHP to start the loop automatically at the end of the script execution
    using PHP''s `register_shutdown_function()`. We''ll update our `composer.json`
    again and add the `autoload` directive:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，RxPHP 将会依赖于 `async-interop/event-loop` 接口。由于我们不希望自行启动循环，我们可以从 RxPHP 中自动加载一个引导脚本，在脚本执行结束时自动启动循环，使用
    PHP 的 `register_shutdown_function()`。我们将再次更新我们的 `composer.json` 并添加 `autoload`
    指令：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can write any asynchronous code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写任何异步代码：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that we're neither creating a Scheduler nor starting the loop. In RxPHP
    2 all operators have their default Scheduler predefined so we don't need to pass
    it in the `subscribe()` method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们既没有创建调度器，也没有启动循环。在 RxPHP 2 中，所有操作符都有默认的调度器预定义，所以我们不需要在 `subscribe()` 方法中传递它。
- en: 'If we wanted to follow a similar approach as with RxPHP 1 we could hardcode
    the Scheduler:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: However, in some situations, we might not want to wait until the end of the
    script for `register_shutdown_function()` to start the loop and we want to start
    it ourselves.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Both Observables will start emitting values at the same time when the loop
    is started so the output will be as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can also manually start the event loop after we create the first Observable:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The loop will end after printing three values and then we carry on with the
    second Observable. The event loop will be automatically started again at the end
    the script execution. The output is then the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that at the time of writing this book (April 2017) both `async-interop/event-loop`
    and RxPHP 2 are in pre-release state and their APIs might change.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order Observables
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When talking about the prerequisites for functional programming we mentioned
    higher-order functions. These are functions that return other functions. A very
    similar concept is applied in RxPHP as well, when using Observables.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'A higher-order Observable is an Observable that emits other Observables. To
    illustrate how higher-order Observables differ from first-order Observables, consider
    the following simple example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This example just prints three values and completes as expected. This is what
    we expect from any first-order Observable:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we can make this more complicated by adding the `map()` operator that,
    instead of returning an integer, returns another Observable:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We create an Observable using `range()` for each value from the source Observable.
    In our example, Observables that arrive to the `DebugSubject` instances are supposed
    to emit values `[0]`, `[0, 1]`, and `[0,1,2]`, respectively.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The output in console is not satisfactory. The `DebugSubject` instance prints
    what it receives, which is an instance of `RangeObservable`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'This is correct behavior. We''re really returning Observables from the `map()`
    operator, and `subscribe()` method doesn''t care what values it passes through:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The value for each `onNext` is `RangeObservable` (`Rx\Observable\RangeObservable`)
    because `DebugSubject` receives an object and transforms it into a string. Then
    it prints the class name, including its namespace, in parentheses.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: So, what if we want to flatten the inner Observables and re-emit all values
    from them?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: RxPHP has a couple of operators intended to work with higher-order Observables.
    In particular the most useful are `mergeAll()`, `concatAll()`, and `switchLatest()`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, we can choose `mergeAll()` or `concatAll()`. The difference
    between these two is the same as `merge()` and `concat()`. The `mergeAll()` operator
    subscribes to all inner Observables right when it receives them, and re-emits
    all their values immediately. On the other hand, `concatAll()` will subscribe
    to the inner Observables one at the time, in the order it receives them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The concatAll() and mergeAll() operators
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, it doesn't matter which one we choose. The `RangeObservable`
    is a cold Observable that uses `ImmediateScheduler`, so all values are always
    emitted in the correct order.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementation with `mergeAll()` could look like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now `Observable::range(1, 3)` emits three instances of `RangeObservable`. The `mergeAll()`
    operator subscribes to each of them and re-emits all their values to its observer,
    which is a `DebugSubject` instance.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'How `mergeAll()` works is obvious from the following marble diagram:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![The concatAll() and mergeAll() operators](img/00024.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: Marble diagram representing the mergeAll() operator in RxJS (http://reactivex.io/rxjs/class/es6/Observable.js)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The source Observable, represented as a horizontal line at the top, doesn't
    emit values directly (there are no circles on the line). Instead, it emits other
    Observables, represented by diagonal lines.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this example, we''ll get values as described above, which are `0`, `0`,
     `1`, `0`, `1`, and `2`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can also test what happens if we work with Observables that emit values asynchronously.
    In this case, it matters whether we use `mergeAll()` or `concatAll()`, so we'll
    test both scenarios.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `mergeAll()` and an example similar to the previous one.
    We''ll use `IntervalObservable` and `take(3)` to emit three Observables that asynchronously
    emit three values:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Each value from the inner Observable is transformed into a string to be easily
    identifiable. We can describe what happens in this example by time-stamping each
    value:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '`1000ms`: The first value is emitted from the outer `IntervalObservable`, which
    is via the `map()` operator turned into another `IntervalObservable`. At this
    point, `mergeAll()` subscribes to this first inner Observable.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1600ms`: The inner `IntervalObservable` emits a first-value (integer `0`),
    which is converted to a string and printed by the `DebugSubject` instance.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2000ms`: The second inner Observable is created. The `mergeAll()` operator
    subscribes to it as well. It''s subscribed to two Observables now.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2200ms`: The first inner `IntervalObservable` emits its second value `(1)`.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2600ms`: The second inner `IntervalObservable` emits its first value `(0)`.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2800ms`: The first inner `IntervalObservable` emits its last value `(2)`.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3000ms`: The third inner `IntervalObservable` is created.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This continues until all inner `IntervalObservable` emit three values, thanks
    to the `take(3)` operator.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the values from inner Observables are really emitted asynchronously
    and, if we want to consume them, it's very easy to use the `mergeAll()` operator.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'The full console output is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Implementation using `concatAll()` is exactly the same. The only thing that
    changes is how we use this operator:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Just like the `concat()` operator, `concatAll()` keeps the order of Observables
    and subscribes to the next Observable only after the previous Observables are
    completed. The output in the console is in the order the inner `IntervalObservables`
    are created:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The core principle of higher-order Observables isn't easy to grasp at first
    sight, so feel free to experiment by yourself.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Although it's hard to see the real benefit of `concat()`, `concatAll()`, `merge()`,
    and `mergeAll()` in RxPHP, these all are very common in RxJS. Typically, when
    we need to run multiple HTTP requests in order or independently of each other,
    it's very convenient to use one of these operators. More on this topic is in the
    final chapter, which shows some interesting use-cases of RxJS.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The switchLatest Operator
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With `concatAll()` or `mergeAll()`, we know we'll always receive all values
    emitted from all inner Observables. In some use cases, we might care only about
    values from the most recent Observable, while discarding all other Observables.
    This is something we can't do with either `concatAll()` or `mergeAll()` because
    these always wait until the current Observable completes or all Observables complete,
    respectively.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: This is why there's a `switchLatest()` operator that's always subscribed only
    to the most recent Observable and automatically unsubscribes from the previous
    one.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'The following marble diagram explains this principle very well:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![The switchLatest Operator](img/00025.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: Marble diagram representing the switch() operator in RxJS (http://reactivex.io/rxjs/class/es6/Observable.js)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This operator is called, simply, `switch()` in RxJS. There are also the `switchMap()`
    and `switchMapTo()` operators, currently available only in RxJS.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we can see that the source Observable emits two Observables.
    The first inner Observable emits four values, but only two of them ("a" and "b")
    are re-emitted. Before the third value is emitted the source Observable emits
    another inner Observable and the current one is unsubscribed. Then it carries
    on by re-emitting values from the new inner Observable.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the inner Observable is consumed even after the source Observable
    completes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how is this operator going to change the output from the same example we
    used for `concatAll()` and `mergeAll()`? Take a look at the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We know for sure we won''t receive all values from all inner Observables because
    each one of them is created before the previous one completes:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Each inner Observable was able to emit only its first value, and then they were
    unsubscribed except for the last Observable. Since there are no more emissions
    from the source Observable, `switchLatest()` stays subscribed to it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The combineLatest() operator
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both `concatAll()` and `mergeAll()` re-emit all values emitted by their inner
    Observable (or Observables) one by one. There's one more operator with a similar
    functionality, called `combineLatest()`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to the previous two, `combineLatest()` takes arguments as an array
    of Observables and immediately subscribes to all of them. Then, the last value
    emitted by each Observable is internally stored in a buffer by `combineLatest()`
    and when all source Observables have emitted at least one value, it emits the
    entire buffer as a single array. Then on any emission from any of the source Observables
    the updated buffer is re-emitted again.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'This is demonstrated in the following marble diagram:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![The combineLatest() operator](img/00026.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: Marble diagram representing the combineLatest() operator in RxJS (http://reactivex.io/rxjs/class/es6/Observable.js)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when the first Observable emitted **a**, it wasn't immediately re-emitted.
    Only after the second Observable emits its first value the `combineLatest()` operator
    reemitted both of them. This means that, if we have an array of *N* Observables,
    the observer for `combineLatest()` will always receive an array of *N* values.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: An important implication of this is that, if we had an Observable in the source
    array that, for some reason, didn't emit any value, then `combineLatest()` won't
    emit any value either because it needs to have at least one value for each source
    Observable. This can be easily avoided by using the `startWith()` or `startWithArray()`
    operators that prepend value emissions before the source Observable.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example, where we have an Observable with just a single
    value, created using `Observable::just()`. We want to combine it using the `combineLatest()`
    operator with an array of `IntervalObservable` instances:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We know for sure that the output array will always start with integer `42`.
    This array will be emitted for every change in the array of source Observables.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the second `IntervalObservable` emits its first value after 250ms,
    while the third `IntervalObservable` emits its first value after just 100ms. This
    means that we'll never receive the first value from the third `IntervalObservable`.
    It'll never be re-emitted, because `combineLatest()` needs all Observables to
    emit at least one value, and in our case, it's going to wait for the second `IntervalObservable`,
    which is the slowest one.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'The console output confirms our expected behavior:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The last two emissions happened only because of the second `IntervalObservable`.
    Also, notice that, since every emission from the source Observables triggers `combineLatest()`
    to re-emit its current values, there's always only one updated value in the array.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to be sure we''ll catch all values emitted from all Observables,
    we can use `startWith()` to set default values for each of them:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now the output is going to start with `null` values, and we can be sure we''ll
    receive all values from all source Observables:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: These four operators belong to a category of more advanced Rx features. Although
    these aren't commonly used in either RxPHP or RxJS, it's very useful to know that
    they exist, because it leverages the true power of Reactive Extensions. The internal
    logic provided by `switchMap()` or `combineLatest()` lets us avoid using any state
    variables to keep track of where we need to subscribe/unsubscribe and what values
    we need to store.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: We'll encounter `combineLatest()` and `switchMap()` used in one operator chain
    in the next chapter. Also, in the final chapter of this book, when talking about
    similarities with RxJS, we'll use a slightly modified version of `combineLatest()`
    in JavaScript. The `concatAll()` and `mergeAll()` Operators are useful in RxJS
    as well, and we can do some tricks with them that aren't possible in RxPHP as
    of now; but more on that in the final chapter.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered a lot of new topics. We're going to use all of what we
    just learned in the next chapter, where we'll use Unix sockets for inter-process
    communication and WebSocket server for a simple chat application. Most importantly,
    we're going to use spawning subprocesses with `ProcessObservable`, PHP Streams
    API for Unix socket communication. We are also going to look into event loops,
    including use cases, where we need to share the same instance of the event loop
    among Unix socket streams and a WebSocket server. Then we will move on to higher-order
    Observables to collect statuses from multiple subprocesses, and a WebSocket server
    and client. PHP Streams API and higher-order Observables are, in principle, a
    little harder to understand at first glance, so feel free to take your time and
    experiment by yourself.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll also introduce the concept of backpressure in Rx,
    which is a common way to avoid overloading the consumer by emitting more values
    that the observer is able to process.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
