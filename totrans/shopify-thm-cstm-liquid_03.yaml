- en: '[*Chapter 2*](B17606_02_Final_PD_ePub.xhtml#_idTextAnchor030): The Basic Flow
    of Liquid'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will help us understand what Liquid is and learn the basics of
    Liquid to provide us with the essential knowledge needed to master it. We will
    split the chapter into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Liquid?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Liquid and its delimiters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the comparison operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with logic operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the types of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling whitespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will gain a deeper understanding of Liquid logic,
    the type of operators we can use to manipulate the various types of data, and
    the Liquid way of removing those pesky whitespace characters. By learning how
    to use logical operators and manipulate handle attributes, we will gain valuable
    knowledge of producing various dynamic features, setting our skills on the correct
    path toward writing quality and complex code.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter is available on GitHub here: [https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter02](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter02).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3ArKxia](https://bit.ly/3ArKxia)'
  prefs: []
  type: TYPE_NORMAL
- en: What is Liquid?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we gained the first insights into Shopify. We learned
    what Shopify is, how to create Shopify Partner accounts, and how to manage our
    theme. Finally, we have learned about theme structure, the directories it contains,
    and some essential files in our `Layout` directory, at which point we might have
    noticed that most of our files contain the `.liquid` extension. *So what exactly
    is Liquid?*
  prefs: []
  type: TYPE_NORMAL
- en: Liquid is an open source project created by Shopify co-founder and CEO Tobias
    Lütke. As a template language, Liquid variables connect the Shopify store's data
    to the static HTML content in our theme, allowing us to turn the static template
    page into a fully dynamic and powerful e-commerce store and producing impressive
    results. We can also consider Liquid elements as placeholders that will only get
    populated with proper data after the code inside the file is compiled and sent
    to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Ever since 2006, Liquid has been growing and evolving. Today, many different
    web applications rely on Liquid, Shopify being one of those, which shows that
    the need for Liquid is ever-growing. Learning Liquid is a great way to advance
    your knowledge further, and with its easy-to-learn syntax, we will master Liquid
    and be able to create complex functionality in no time.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Liquid and its delimiters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the two ways that we can discern a Liquid file is by the extension `.liquid`.
    Being a template language, a Liquid file is a combination of *static and dynamic
    content*:'
  prefs: []
  type: TYPE_NORMAL
- en: Elements that we write in HTML are called **static content**, and they stay
    the same no matter what page we are currently on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other side, elements written in Liquid are called **dynamic content**
    elements, whose content changes depending on the page we are on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While our browsers can quickly process the HTML code, they would not know what
    to do with Liquid code as they do not understand it. We can break up the flow
    of what happens when we submit a Shopify URL to our browser into five logical
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The Shopify server tries to determine which store we are trying to access.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Depending on the type of page we are currently requesting information for, Shopify
    tries to locate and select the proper Liquid template from the active theme directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After successfully identifying the Liquid template that we require, the Shopify
    server starts replacing the placeholders with actual data stored on the Shopify
    platform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once Shopify has finished replacing the placeholders and performing any logic
    located inside the selected template, our browser will receive the compiled HTML
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that our browser has received the HTML file as a response, the browser starts
    processing the file and fetches all other required assets, including JavaScript,
    stylesheets, images, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second way that we can distinguish Liquid files and code is by its two
    delimiters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{{ }}` double curly braces are used to indicate that we are expecting an output.
    An example Liquid code where we are expecting an output is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our collection name is Winter Shoes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`{% %}` curly braces with a percentage, on the other hand, are used if we want
    to indicate that we are looking to perform some kind of logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our last example, we were able to see the result of using `{{ collection.title
    }}` to recover the name of the collection. Now, *what if we wanted to show the
    collection description, but for some reason, the* `collection description` *field
    did not return anything?* We would have ended up with an incomplete message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To ensure that this does not happen, we can check whether the data value exists
    using Liquid logic and comparison operators combined with some Shopify data types.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the comparison operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With Liquid, we have access to seven comparison operators, which we can combine
    to create any type of logical flow that our code requires. Let''s review them
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `==` operator allows us to check whether the element we are comparing is
    equal to some value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The`!=` operator works similarly to the previous operator. The difference is
    that this operator checks whether the element we are comparing is not equal to
    some value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `>` operator allows us to check whether the compared value is greater than
    the comparing value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, as in the previous example, we will be checking the number of products
    in our collection, however, in this case, we will be using the `<` operator, which
    returns `true` only if the comparing value is less than the value being compared
    to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '{% if collection.all_products_count > operator allows us to check whether the
    compared value is greater than the comparing value. If it is, the logic returns
    true, and our message will show. However, if we were to run our code now, the
    logic would return false, and we would not see our message. *Why?*If we look at
    our example, we will notice that we have quotation marks encapsulating our comparing
    value, which means that our comparing-to value is a string, compared to our `collection.all_products_count`,
    which returns a number. As we have mentioned before, the comparison operators
    will return `true` only when we have met the exact conditions that the operator
    requires. In our current example, for our message to be made visible, two conditions
    must be met.The first condition is that both values must be the same data type,
    meaning that we cannot mix two types of data as we did just now. We would need
    to remove the quotation marks from our comparing-to value, consequently turning
    it from a string to a number data type. The second condition is that our comparing
    value is greater than the compared to value. Once we have met the two conditions,
    the logic returns `true`, and our message will be shown.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `>=` operator allows us to check whether the element we are comparing is
    greater than or equal to the comparing value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `<=` operator allows us to check if the compared value is less than or
    equal to the comparing value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with logic operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides comparison operators, we also have access to two logic operators, which
    allow us to combine multiple conditions to create complex statements. We can divide
    them into the two following groups:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `or` operator allows us to set multiple conditionals, where we must meet
    at least one of them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, the `and` operator allows us to set multiple conditions. However,
    for this operator to return `true`, all conditions must be met:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`contains` is the final operator on our list. This particular operator works
    differently than the previous ones as it does not check whether a comparing value
    is equal to a compared-to value. Instead, it allows us to check whether a string
    contains a substring:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have learned a lot about using logical and comparison operators. However,
    we only learned how to compare one value against another known value. *So how
    would we check if a compared value, for example a collection description, exists?*
    Since `collection.description` returns content with which we are unfamiliar, we
    have no way of performing this check with our current knowledge. To perform this
    action, we would first need to learn the different types of data we can use with
    Liquid.
  prefs: []
  type: TYPE_NORMAL
- en: Understand the types of data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have mentioned two data types, **strings** and **numbers** to be
    precise. However, in Liquid, there are six different types of data that are available
    to us:'
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nil
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EmptyDrop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **string** is a type of data that we use to represent text. Since a string
    can be any combination of letters, numbers, or special characters, we should always
    encapsulate it with quotation marks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we check whether the product title contains the string
    `"Book"` or the same product title contains the string `"2021"`, and if it does,
    our message will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **number** is a type of data that require no quotation marks, and we use
    it to represent the following two types of numerical data:'
  prefs: []
  type: TYPE_NORMAL
- en: A **float** is a floating-point number, meaning that the number contains a decimal
    point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An **integer** or **int**, on the other hand, is a whole number without a decimal
    point:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, we check whether the product price is greater than `25`, and
    at the same time, lower than `and` comparator, both conditionals must be true.
    If either one of them returns `false`, our message will not be shown.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that neither of our two comparing values, `25` or `product.price` will
    return.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`true` or `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the example, similar to the number data type, Booleans do
    not use quotation marks. If `customer.accepts_marketing` has signed up for our
    newsletter, the object will be true, and our message will be visible.
  prefs: []
  type: TYPE_NORMAL
- en: Nil
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Nil** is a data type that returns an empty value when our code has no results.
    Since nil does not return any values, we can use it to check for the truthfulness
    of a statement. However, we should note that we can only use nil to check whether
    the value exists. We cannot use nil to check the content of the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we check whether the customer visiting our store has
    an account on our store using the conditional to perform the check if the customer
    object exists. Note that we have not added any operator or data type after our
    customer object. The reason for this is that nil is a special empty value. It
    is not a string with text `nil` or a variable and, as such, does not require any
    visual representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can split the values inside Liquid into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: All data types that are true by default when used inside a conditional are considered
    **truthy**. Note that even empty values, such as strings, are considered truthy
    by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, all data types that return `false` are considered `false`
    by default are false and nil.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since nil is considered falsy, our message will not show unless the customer
    has an account in our store. Otherwise, the conditional will return `true`, and
    our message will show.
  prefs: []
  type: TYPE_NORMAL
- en: 'While nil is extremely useful, it does not provide an answer to all of our
    questions. If we recall, in one of our previous examples, we used `collection.description`
    to see the content of our description collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If our collection description has some defined content, our message will show
    correctly. However, if we have not defined a description for our collection, then
    `collection.description` will return empty, and we would end up with an incomplete
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As we recall, we can only use nil to check whether an element such as an object
    exists. It cannot check its content, *but what exactly does that mean?*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have wrapped our element within a conditional using the
    nil data type to check whether a `collection.description` instance exists. However,
    as we can see, this is not the result that we hoped for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since nil only checks whether an element exists, in our case, our conditional
    has found that `collection.description`, while empty, does exist. Remember that
    all values inside Liquid except false and nil are by default truthy, meaning that
    even empty strings are considered truthy. For this reason, even though our `collection.description`
    instance was empty and returned an empty string (since we used nil inside a conditional),
    the result was that the value was truthy. Therefore, the code inside the conditional
    is visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this problem, instead of checking whether the value exists, we should
    check whether our value is not blank:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we check to see whether our collection description
    is not empty using the not equal parameter against `blank`. If the result of this
    conditional is that `collection.description` is not blank, the message we have
    defined will show. Otherwise, the conditional will return `false` and the message
    defined inside the conditional will not render.
  prefs: []
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An **array** is a data structure that contains a list of elements, usually
    of the same type. Note that we cannot initialize our array using Liquid only,
    but we can break down a string into an array of substrings, the data in which
    we can access using one of these two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The first option for accessing data inside an array is by directly accessing
    each item individually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since, as we mentioned, we cannot initialize an array using Liquid only, for
    this example, we can use `product.tags`, which would return an array of strings:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <p>{{ product.tags[0] }}</p>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <p>{{ product.tags[1] }}</p>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <p>{{ product.tags[2] }}</p>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <p>{{ product.tags[3] }}</p>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <p>{{ product.tags[4] }}</p>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <p>learning</p>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <p>with</p>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <p>packt</p>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <p>is</p>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <p>awesome!</p>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To access all items inside an array, we would need to loop through each item
    in our array and output their contents:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use the `for` tag to repeatedly execute a block of code or to go over
    all of the values inside an array and output them:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While it is easier to use the loop over an array to quickly output an array
    than to call out each item inside an array individually, it is essential to be
    aware of both methods, which will allow us to create some complex functionalities
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: EmptyDrop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final data type in our list is **EmptyDrop**, which would result from us
    trying to access an attribute of the previously deleted object or disabled by
    using its handle.
  prefs: []
  type: TYPE_NORMAL
- en: Before we learn about the final data type, we will first need to learn what
    a handle is, and how to find it.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the handle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `-`) are used to replace any special characters and spaces. Similar to when
    we learned how to access an individual item inside an array using the position
    index, we can use page handles to access the attributes of a Liquid object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now understand what a page handle is, but let''s try to put that into context
    by creating a page on our store and see what we just learned in action:'
  prefs: []
  type: TYPE_NORMAL
- en: To create a new page, we will first need to navigate to our store by visiting
    [https://www.my-store-name.myshopify.com/admin](https://www.my-store-name.myshopify.com/admin)
    and logging in using our Shopify Partner credentials. An alternative way to do
    this is to visit the Shopify Partners site at [https://www.shopify.com/partners](https://www.shopify.com/partners)
    and log in with the Partner account that we created in the previous chapter, subsequently
    clicking on the **Store** button in the left sidebar and then logging in to our
    store by clicking the **Log in** button next to the name of our store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After successfully logging in to our store, in the sidebar, under **Sales channels**,
    click on **Online Store** to expand the additional sections of the menu and subsequently
    click on the **Pages** link, redirecting us to the **Pages** section of our store:![Figure
    2.1 – Accessing the Pages section
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_2.1_B17606.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.1 – Accessing the Pages section
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once inside, since our store is new and has no content, the only thing that
    we will see is the **Add page** button. Otherwise, we would see a list of all
    the pages that we have access to in our store. To proceed with creating our first
    page, click on the **Add page** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After initializing the process of creating a new page, we will see the page
    where we can define the content of the new page, including the name, description,
    visibility, and which template the page should use. We will only need to enter
    the title of our page for our current purpose, ensuring that we select the `Learning
    about the page handle` as the title. We also made sure to select the **Visible**
    option, so the only thing left is to click on the **Save** button:![Figure 2.2
    – Creating and publishing the new page in the Shopify admin interface
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_2.2_B17606.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 2.2 – Creating and publishing the new page in the Shopify admin interface
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have created our page, we can see the page handle by clicking on
    the **Edit website SEO** button on the lower part of the window, which will expand
    and reveal the SEO information for our page, where, among other options, we can
    see the handle of our page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Updating the page URL and handle information'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.3_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Updating the page URL and handle information
  prefs: []
  type: TYPE_NORMAL
- en: As we recall, the handle is a page title in lowercase with hyphens (`-`) replacing
    the special characters and empty spaces. In our case, the handle for our page
    is `learning-about-the-page-handle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: If for some reason, we were to change the title of the page that we have now
    created, this would only affect the page title. The handle would remain the same,
    as changing the page name does not automatically update the handle. The only way
    to change the handle is to click on **Edit website SEO** and manually edit the
    handle inside the **URL and handle** field.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned what the page handle is and how to manage it, we can
    proceed from where we left off with the EmptyDrop data type.
  prefs: []
  type: TYPE_NORMAL
- en: EmptyDrop data type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we recall, EmptyDrop results from us trying to access an attribute of the
    previously deleted or disabled object. Note that EmptyDrop, like nil, is not a
    string with the text `EmptyDrop`, nor a variable, and as such, it does not have
    a visual representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access an object using its handle by pluralizing the name of the object
    that we are trying to access, followed by either a squared bracket (`[]`) or dot
    (`.`) notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'While the result will be the same no matter which notation we select, it is
    important to mention both, as they each have their purpose, which we will cover
    in the later chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now learned how to access an object and read its attributes through
    the page handle. However, *what if we were to go back to our admin interface and
    disable the previously created page by switching the Visibility option to Hidden?*
    The result of such an action would be EmptyDrop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'EmptyDrop attributes have only one attribute called `empty?`, which is always
    truthy. To avoid this issue, we can create a conditional statement to check whether
    EmptyDrop is `empty`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If the object is not equal to empty, which is always truthy for EmptyDrop, the
    code inside our conditional will render. Otherwise, if the code is equal to empty,
    the object we are looking for is empty, and the code will not render.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling whitespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous sections, we learned how to use conditionals with variable
    data types to ensure that we always receive a correct value. However, even with
    our conditionals, the same values can be accompanied by some unwanted whitespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we have created a conditional that will return `true`
    if our collection object exists, ensuring that our message will not be incomplete.
    While our result looks correct, if we were to inspect the page, we would see that
    things aren''t perfect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from our previous example, we have successfully recovered the
    collection information. However, we can see a significant number of empty spaces
    around our message, which results from processing Liquid code. Even though not
    every Liquid code will output HTML, each line will generate a line for each line
    of Liquid code by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this problem, we can introduce a hyphen inside our syntax tag as
    `{{- - }}` or `{%- -%}`, which allows us to strip any unwanted whitespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'With the introduction of the hyphens seen in the previous code block, we have
    successfully removed the two empty lines that our conditional was rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the hyphens we added on both ends within our conditional has removed
    the whitespace on both sides. However, we have only added one hyphen on the closing
    bracket of the `collection.title` to remove the empty whitespace on its right
    side. If we were to add a hyphen to the left side as well, we would have removed
    the space separating the verb `"is"` and the collection name.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of Liquid by learning what Liquid is,
    and how to discern Liquid code by learning how to read and write its syntax. We
    have gained an understanding of all Liquid logic and comparison operators, which,
    combined with all Liquid data types we have covered, will help us ensure that
    we always receive only the data we are expecting. As we progress further, this
    will become more and more essential.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have learned how to create and access each page individually, which
    will be of great use to us in the following chapter, where we will be learning
    more about the objects that we have mentioned on a few occasions throughout the
    current chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What type of delimiter should we use if we are expecting an output as a result?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What will the result of the following conditional be, and why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What are the two methods to access an item inside an attribute?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the correct way of accessing an object using its handle?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two problems inside the following block of code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
