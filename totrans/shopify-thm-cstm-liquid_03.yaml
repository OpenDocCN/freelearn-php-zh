- en: '[*Chapter 2*](B17606_02_Final_PD_ePub.xhtml#_idTextAnchor030): The Basic Flow
    of Liquid'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第二章*](B17606_02_Final_PD_ePub.xhtml#_idTextAnchor030)：液体的基本流程'
- en: 'This chapter will help us understand what Liquid is and learn the basics of
    Liquid to provide us with the essential knowledge needed to master it. We will
    split the chapter into the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助我们了解 Liquid 是什么，学习 Liquid 的基础知识，为我们提供掌握它所需的基本知识。我们将把本章分为以下主题：
- en: What is Liquid?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Liquid？
- en: Understanding Liquid and its delimiters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Liquid 及其定界符
- en: Learning the comparison operators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习比较运算符
- en: Working with logic operators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用逻辑运算符
- en: Understanding the types of data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数据类型
- en: Controlling whitespace
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制空白字符
- en: By the end of this chapter, we will gain a deeper understanding of Liquid logic,
    the type of operators we can use to manipulate the various types of data, and
    the Liquid way of removing those pesky whitespace characters. By learning how
    to use logical operators and manipulate handle attributes, we will gain valuable
    knowledge of producing various dynamic features, setting our skills on the correct
    path toward writing quality and complex code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将对 Liquid 逻辑有更深入的理解，我们将使用哪些运算符来操作各种类型的数据，以及 Liquid 移除那些讨厌的空白字符的方式。通过学习如何使用逻辑运算符和操作处理属性，我们将获得有关生产各种动态功能的有价值知识，并将我们的技能引向编写高质量和复杂代码的正确路径。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter is available on GitHub here: [https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter02](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter02).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在 GitHub 上找到：[https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter02](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter02)。
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3ArKxia](https://bit.ly/3ArKxia)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的“代码在行动”视频可以在这里找到：[https://bit.ly/3ArKxia](https://bit.ly/3ArKxia)
- en: What is Liquid?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Liquid？
- en: In the previous chapter, we gained the first insights into Shopify. We learned
    what Shopify is, how to create Shopify Partner accounts, and how to manage our
    theme. Finally, we have learned about theme structure, the directories it contains,
    and some essential files in our `Layout` directory, at which point we might have
    noticed that most of our files contain the `.liquid` extension. *So what exactly
    is Liquid?*
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们获得了对 Shopify 的初步了解。我们学习了 Shopify 是什么，如何创建 Shopify 合作伙伴账户，以及如何管理我们的主题。最后，我们学习了主题结构、它包含的目录以及我们
    `Layout` 目录中的一些基本文件，这时我们可能会注意到我们的大部分文件都包含 `.liquid` 扩展名。*那么，Liquid 究竟是什么呢？*
- en: Liquid is an open source project created by Shopify co-founder and CEO Tobias
    Lütke. As a template language, Liquid variables connect the Shopify store's data
    to the static HTML content in our theme, allowing us to turn the static template
    page into a fully dynamic and powerful e-commerce store and producing impressive
    results. We can also consider Liquid elements as placeholders that will only get
    populated with proper data after the code inside the file is compiled and sent
    to the browser.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Liquid 是由 Shopify 联合创始人兼首席执行官 Tobias Lütke 创建的开源项目。作为一个模板语言，Liquid 变量将 Shopify
    商店的数据库连接到我们主题中的静态 HTML 内容，使我们能够将静态模板页面转变为一个完全动态且功能强大的电子商务商店，并产生令人印象深刻的成果。我们还可以将
    Liquid 元素视为占位符，这些占位符只有在文件内的代码编译并发送到浏览器后才会填充适当的数据。
- en: Ever since 2006, Liquid has been growing and evolving. Today, many different
    web applications rely on Liquid, Shopify being one of those, which shows that
    the need for Liquid is ever-growing. Learning Liquid is a great way to advance
    your knowledge further, and with its easy-to-learn syntax, we will master Liquid
    and be able to create complex functionality in no time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2006 年以来，Liquid 一直在发展和演变。如今，许多不同的网络应用程序都依赖于 Liquid，Shopify 就是其中之一，这表明对 Liquid
    的需求一直在增长。学习 Liquid 是进一步扩展知识的好方法，并且凭借其易于学习的语法，我们将迅速掌握 Liquid 并能够创建复杂的功能。
- en: Understanding Liquid and its delimiters
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Liquid 及其定界符
- en: 'One of the two ways that we can discern a Liquid file is by the extension `.liquid`.
    Being a template language, a Liquid file is a combination of *static and dynamic
    content*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分液体文件的两个方法之一是通过扩展名 `.liquid`。作为一个模板语言，液体文件是静态内容和动态内容的组合：
- en: Elements that we write in HTML are called **static content**, and they stay
    the same no matter what page we are currently on.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 HTML 中编写的元素被称为 **静态内容**，无论我们当前在哪个页面上，它们都保持不变。
- en: On the other side, elements written in Liquid are called **dynamic content**
    elements, whose content changes depending on the page we are on.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，用Liquid编写的元素被称为**动态内容**元素，其内容会根据我们所在的页面而变化。
- en: 'While our browsers can quickly process the HTML code, they would not know what
    to do with Liquid code as they do not understand it. We can break up the flow
    of what happens when we submit a Shopify URL to our browser into five logical
    steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的浏览器可以快速处理HTML代码，但它们不知道如何处理Liquid代码，因为它们不理解它。我们可以将提交Shopify URL到浏览器时发生的事情的流程分解为五个逻辑步骤：
- en: The Shopify server tries to determine which store we are trying to access.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Shopify服务器试图确定我们正在尝试访问哪个商店。
- en: Depending on the type of page we are currently requesting information for, Shopify
    tries to locate and select the proper Liquid template from the active theme directory.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据我们当前请求信息的页面类型，Shopify会尝试从活动主题目录中定位并选择合适的Liquid模板。
- en: After successfully identifying the Liquid template that we require, the Shopify
    server starts replacing the placeholders with actual data stored on the Shopify
    platform.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功识别所需的Liquid模板后，Shopify服务器开始用Shopify平台存储的实际数据替换占位符。
- en: Once Shopify has finished replacing the placeholders and performing any logic
    located inside the selected template, our browser will receive the compiled HTML
    file.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Shopify完成替换占位符和执行所选模板中定位的任何逻辑，我们的浏览器将接收到编译后的HTML文件。
- en: Now that our browser has received the HTML file as a response, the browser starts
    processing the file and fetches all other required assets, including JavaScript,
    stylesheets, images, and so on.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在浏览器已经接收到HTML文件作为响应，浏览器开始处理文件并获取所有其他必需的资产，包括JavaScript、样式表、图像等。
- en: 'The second way that we can distinguish Liquid files and code is by its two
    delimiters:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分液体文件和代码的第二种方式是通过其两个定界符：
- en: '`{{ }}` double curly braces are used to indicate that we are expecting an output.
    An example Liquid code where we are expecting an output is as follows:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{ }}` 双大括号用于表示我们期望一个输出。以下是一个期望输出的Liquid代码示例：'
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our collection name is Winter Shoes
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的收藏夹名称是冬季鞋子
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`{% %}` curly braces with a percentage, on the other hand, are used if we want
    to indicate that we are looking to perform some kind of logic.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，如果我们想表示我们正在执行某种逻辑，则使用带有百分比的`{% %}`大括号。
- en: 'In our last example, we were able to see the result of using `{{ collection.title
    }}` to recover the name of the collection. Now, *what if we wanted to show the
    collection description, but for some reason, the* `collection description` *field
    did not return anything?* We would have ended up with an incomplete message:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最后的例子中，我们能够看到使用`{{ collection.title }}`恢复收藏夹名称的结果。现在，*如果我们想显示收藏夹描述，但出于某种原因，*
    `收藏夹描述` *字段没有返回任何内容？* 我们最终会得到一个不完整的信息：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To ensure that this does not happen, we can check whether the data value exists
    using Liquid logic and comparison operators combined with some Shopify data types.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这种情况不会发生，我们可以使用Liquid逻辑和比较操作符以及一些Shopify数据类型来检查数据值是否存在。
- en: Learning the comparison operators
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习比较操作符
- en: 'With Liquid, we have access to seven comparison operators, which we can combine
    to create any type of logical flow that our code requires. Let''s review them
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Liquid，我们可以访问七个比较操作符，我们可以将它们组合起来创建任何类型的逻辑流程，我们的代码需要。让我们按以下方式回顾它们：
- en: 'The `==` operator allows us to check whether the element we are comparing is
    equal to some value:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==` 操作符允许我们检查我们正在比较的元素是否等于某个值：'
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The`!=` operator works similarly to the previous operator. The difference is
    that this operator checks whether the element we are comparing is not equal to
    some value:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!=` 操作符与前面的操作符类似。区别在于，这个操作符检查我们正在比较的元素是否不等于某个值：'
- en: '[PRE4]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `>` operator allows us to check whether the compared value is greater than
    the comparing value:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>` 操作符允许我们检查比较值是否大于比较值：'
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Similarly, as in the previous example, we will be checking the number of products
    in our collection, however, in this case, we will be using the `<` operator, which
    returns `true` only if the comparing value is less than the value being compared
    to:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于前面的例子，我们将检查我们收藏夹中的产品数量，然而，在这种情况下，我们将使用`<`操作符，它仅在比较值小于被比较值时返回`true`：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '{% if collection.all_products_count > operator allows us to check whether the
    compared value is greater than the comparing value. If it is, the logic returns
    true, and our message will show. However, if we were to run our code now, the
    logic would return false, and we would not see our message. *Why?*If we look at
    our example, we will notice that we have quotation marks encapsulating our comparing
    value, which means that our comparing-to value is a string, compared to our `collection.all_products_count`,
    which returns a number. As we have mentioned before, the comparison operators
    will return `true` only when we have met the exact conditions that the operator
    requires. In our current example, for our message to be made visible, two conditions
    must be met.The first condition is that both values must be the same data type,
    meaning that we cannot mix two types of data as we did just now. We would need
    to remove the quotation marks from our comparing-to value, consequently turning
    it from a string to a number data type. The second condition is that our comparing
    value is greater than the compared to value. Once we have met the two conditions,
    the logic returns `true`, and our message will be shown.'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{% if collection.all_products_count > operator 允许我们检查比较值是否大于比较值。如果是，逻辑返回 `true`，我们的消息将显示。然而，如果我们现在运行我们的代码，逻辑将返回
    `false`，我们不会看到我们的消息。*为什么？*如果我们看我们的例子，我们会注意到我们有一个包含比较值的引号，这意味着我们的比较到的值是一个字符串，与我们的
    `collection.all_products_count` 相比，它返回一个数字。正如我们之前提到的，比较运算符只有在满足运算符要求的精确条件时才会返回
    `true`。在我们的当前例子中，为了使我们的消息可见，必须满足两个条件。第一个条件是两个值必须是相同的数据类型，这意味着我们不能像刚才那样混合两种数据类型。我们需要从我们的比较到的值中移除引号，从而将其从字符串转换为数字数据类型。第二个条件是我们的比较值大于比较到的值。一旦我们满足这两个条件，逻辑返回
    `true`，我们的消息将显示。'
- en: '[PRE7]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `>=` operator allows us to check whether the element we are comparing is
    greater than or equal to the comparing value:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>=` 运算符允许我们检查我们比较的元素是否大于或等于比较值：'
- en: '[PRE8]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `<=` operator allows us to check if the compared value is less than or
    equal to the comparing value:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<=` 运算符允许我们检查比较值是否小于或等于比较值：'
- en: '[PRE9]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Working with logic operators
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用逻辑运算符
- en: 'Besides comparison operators, we also have access to two logic operators, which
    allow us to combine multiple conditions to create complex statements. We can divide
    them into the two following groups:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了比较运算符之外，我们还可以访问两个逻辑运算符，它们允许我们将多个条件组合起来创建复杂的语句。我们可以将它们分为以下两个组：
- en: 'The `or` operator allows us to set multiple conditionals, where we must meet
    at least one of them:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or` 运算符允许我们设置多个条件，其中我们必须满足至少一个：'
- en: '[PRE10]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similarly, the `and` operator allows us to set multiple conditions. However,
    for this operator to return `true`, all conditions must be met:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，`and` 运算符允许我们设置多个条件。然而，要使此运算符返回 `true`，所有条件都必须满足：
- en: '[PRE11]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`contains` is the final operator on our list. This particular operator works
    differently than the previous ones as it does not check whether a comparing value
    is equal to a compared-to value. Instead, it allows us to check whether a string
    contains a substring:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains` 是我们列表中的最后一个运算符。这个特定的运算符与之前的运算符不同，因为它不检查比较值是否等于比较到的值。相反，它允许我们检查一个字符串是否包含子字符串：'
- en: '[PRE12]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have learned a lot about using logical and comparison operators. However,
    we only learned how to compare one value against another known value. *So how
    would we check if a compared value, for example a collection description, exists?*
    Since `collection.description` returns content with which we are unfamiliar, we
    have no way of performing this check with our current knowledge. To perform this
    action, we would first need to learn the different types of data we can use with
    Liquid.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了关于使用逻辑和比较运算符的很多知识。然而，我们只学习了如何将一个值与另一个已知值进行比较。*那么我们如何检查一个比较值，例如一个集合描述，是否存在呢？*
    由于 `collection.description` 返回我们不熟悉的内容，我们无法用我们目前的知识来进行这项检查。要执行此操作，我们首先需要了解我们可以与
    Liquid 一起使用的不同类型的数据。
- en: Understand the types of data
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数据类型
- en: 'So far, we have mentioned two data types, **strings** and **numbers** to be
    precise. However, in Liquid, there are six different types of data that are available
    to us:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经提到了两种数据类型，**字符串**和**数字**。然而，在 Liquid 中，有六种不同的数据类型可供我们使用：
- en: Strings
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Number
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: Boolean
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: Nil
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值
- en: Array
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: EmptyDrop
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EmptyDrop
- en: Strings
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'A **string** is a type of data that we use to represent text. Since a string
    can be any combination of letters, numbers, or special characters, we should always
    encapsulate it with quotation marks:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串**是我们用来表示文本的数据类型。由于字符串可以是字母、数字或特殊字符的任意组合，我们应始终用引号将其括起来：'
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous example, we check whether the product title contains the string
    `"Book"` or the same product title contains the string `"2021"`, and if it does,
    our message will be shown.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们检查产品标题是否包含字符串`"Book"`或相同的标题包含字符串`"2021"`，如果是，我们的消息将显示。
- en: Number
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: 'A **number** is a type of data that require no quotation marks, and we use
    it to represent the following two types of numerical data:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字**是一种不需要引号的数据类型，我们用它来表示以下两种数值数据：'
- en: A **float** is a floating-point number, meaning that the number contains a decimal
    point.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点数**是一个带有小数点的浮点数，这意味着数字包含小数点。'
- en: 'An **integer** or **int**, on the other hand, is a whole number without a decimal
    point:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，**整数**或**int**是一个不带小数点的整数：
- en: '[PRE14]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, we check whether the product price is greater than `25`, and
    at the same time, lower than `and` comparator, both conditionals must be true.
    If either one of them returns `false`, our message will not be shown.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们检查产品价格是否大于`25`，同时，低于`and`比较器，两个条件都必须为真。如果其中任何一个返回`false`，我们的消息将不会显示。
- en: Notice that neither of our two comparing values, `25` or `product.price` will
    return.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们两个比较值`25`或`product.price`都不会返回。
- en: Boolean
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: '`true` or `false`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`true`或`false`：'
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we can see from the example, similar to the number data type, Booleans do
    not use quotation marks. If `customer.accepts_marketing` has signed up for our
    newsletter, the object will be true, and our message will be visible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从示例中看到的那样，与数字数据类型类似，布尔值不使用引号。如果`customer.accepts_marketing`已注册我们的通讯简报，对象将为真，我们的消息将可见。
- en: Nil
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无
- en: '**Nil** is a data type that returns an empty value when our code has no results.
    Since nil does not return any values, we can use it to check for the truthfulness
    of a statement. However, we should note that we can only use nil to check whether
    the value exists. We cannot use nil to check the content of the value:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**Nil**是一种在代码没有结果时返回空值的数据类型。由于`nil`不返回任何值，我们可以用它来检查语句的真实性。然而，我们应该注意，我们只能使用`nil`来检查值是否存在。我们不能使用`nil`来检查值的内
    容：'
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the previous example, we check whether the customer visiting our store has
    an account on our store using the conditional to perform the check if the customer
    object exists. Note that we have not added any operator or data type after our
    customer object. The reason for this is that nil is a special empty value. It
    is not a string with text `nil` or a variable and, as such, does not require any
    visual representation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们使用条件来检查访问我们商店的客户是否在我们的商店有账户，如果客户对象存在。请注意，我们没有在我们的客户对象后添加任何操作符或数据类型。原因是`nil`是一个特殊的空值。它不是一个包含文本`nil`的字符串或变量，因此不需要任何视觉表示。
- en: 'We can split the values inside Liquid into two categories:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将Liquid内部的值分为两类：
- en: All data types that are true by default when used inside a conditional are considered
    **truthy**. Note that even empty values, such as strings, are considered truthy
    by default.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有在条件中使用时默认为`true`的数据类型都被认为是**真值**。请注意，即使是空值，如字符串，也默认被认为是真值。
- en: On the other hand, all data types that return `false` are considered `false`
    by default are false and nil.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，所有返回`false`的数据类型默认被认为是`false`和`nil`。
- en: Since nil is considered falsy, our message will not show unless the customer
    has an account in our store. Otherwise, the conditional will return `true`, and
    our message will show.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`nil`被认为是假的，除非客户在我们的商店有账户，否则我们的消息不会显示。否则，条件将返回`true`，我们的消息将显示。
- en: 'While nil is extremely useful, it does not provide an answer to all of our
    questions. If we recall, in one of our previous examples, we used `collection.description`
    to see the content of our description collection:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`nil`非常有用，但它不能回答我们所有的问题。如果我们回想一下，在我们之前的某个例子中，我们使用了`collection.description`来查看描述集合的内容：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If our collection description has some defined content, our message will show
    correctly. However, if we have not defined a description for our collection, then
    `collection.description` will return empty, and we would end up with an incomplete
    message:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的集合描述中包含一些定义的内容，我们的消息将正确显示。然而，如果我们没有为我们的集合定义描述，那么`collection.description`将返回空，我们最终会得到一个不完整的信息：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we recall, we can only use nil to check whether an element such as an object
    exists. It cannot check its content, *but what exactly does that mean?*
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所回忆的，我们只能使用nil来检查诸如对象之类的元素是否存在。它不能检查其内容，*但这究竟意味着什么？*
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this example, we have wrapped our element within a conditional using the
    nil data type to check whether a `collection.description` instance exists. However,
    as we can see, this is not the result that we hoped for:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用nil数据类型在条件中包裹我们的元素，以检查`collection.description`实例是否存在。然而，正如我们所看到的，这不是我们希望得到的结果：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since nil only checks whether an element exists, in our case, our conditional
    has found that `collection.description`, while empty, does exist. Remember that
    all values inside Liquid except false and nil are by default truthy, meaning that
    even empty strings are considered truthy. For this reason, even though our `collection.description`
    instance was empty and returned an empty string (since we used nil inside a conditional),
    the result was that the value was truthy. Therefore, the code inside the conditional
    is visible.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于nil只检查元素是否存在，在我们的情况下，我们的条件已经发现`collection.description`虽然为空，但确实存在。请记住，Liquid中的所有值（除了false和nil）默认都是真值，这意味着空字符串也被认为是真值。因此，尽管我们的`collection.description`实例为空并返回了一个空字符串（因为我们在一个条件中使用nil），但结果是该值是真值。因此，条件内的代码是可见的。
- en: 'To resolve this problem, instead of checking whether the value exists, we should
    check whether our value is not blank:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们不应该检查值是否存在，而应该检查我们的值是否不为空：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the previous example, we check to see whether our collection description
    is not empty using the not equal parameter against `blank`. If the result of this
    conditional is that `collection.description` is not blank, the message we have
    defined will show. Otherwise, the conditional will return `false` and the message
    defined inside the conditional will not render.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们使用不等于参数对`blank`进行检查，以查看我们的集合描述是否不为空。如果这个条件的结果是`collection.description`不为空，我们将显示定义的消息。否则，条件将返回`false`，并且条件内定义的消息将不会渲染。
- en: Array
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'An **array** is a data structure that contains a list of elements, usually
    of the same type. Note that we cannot initialize our array using Liquid only,
    but we can break down a string into an array of substrings, the data in which
    we can access using one of these two methods:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组**是一种包含元素列表的数据结构，通常元素类型相同。请注意，我们无法仅使用Liquid来初始化我们的数组，但我们可以将字符串分解为子字符串数组，我们可以使用这两种方法之一来访问这些数据：'
- en: The first option for accessing data inside an array is by directly accessing
    each item individually.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问数组内部数据的第一种方法是通过直接访问每个项目。
- en: 'Since, as we mentioned, we cannot initialize an array using Liquid only, for
    this example, we can use `product.tags`, which would return an array of strings:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于，正如我们提到的，我们无法仅使用Liquid来初始化数组，因此在这个例子中，我们可以使用`product.tags`，这将返回一个字符串数组：
- en: '[PRE22]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <p>{{ product.tags[0] }}</p>
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <p>{{ product.tags[0] }}</p>
- en: <p>{{ product.tags[1] }}</p>
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <p>{{ product.tags[1] }}</p>
- en: <p>{{ product.tags[2] }}</p>
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <p>{{ product.tags[2] }}</p>
- en: <p>{{ product.tags[3] }}</p>
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <p>{{ product.tags[3] }}</p>
- en: <p>{{ product.tags[4] }}</p>
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <p>{{ product.tags[4] }}</p>
- en: '[PRE23]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <p>learning</p>
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <p>learning</p>
- en: <p>with</p>
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <p>with</p>
- en: <p>packt</p>
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <p>packt</p>
- en: <p>is</p>
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <p>is</p>
- en: <p>awesome!</p>
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <p>awesome!</p>
- en: '[PRE24]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To access all items inside an array, we would need to loop through each item
    in our array and output their contents:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要访问数组中的所有项目，我们需要遍历数组中的每个项目并输出它们的内 容：
- en: '[PRE25]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can use the `for` tag to repeatedly execute a block of code or to go over
    all of the values inside an array and output them:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用`for`标签重复执行代码块或遍历数组中的所有值并输出它们：
- en: '[PRE26]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: While it is easier to use the loop over an array to quickly output an array
    than to call out each item inside an array individually, it is essential to be
    aware of both methods, which will allow us to create some complex functionalities
    later on.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用循环遍历数组来快速输出数组比逐个调用数组中的每个项目要容易，但我们必须意识到这两种方法，这将允许我们稍后创建一些复杂的功能。
- en: EmptyDrop
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EmptyDrop
- en: The final data type in our list is **EmptyDrop**, which would result from us
    trying to access an attribute of the previously deleted object or disabled by
    using its handle.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表中的最后一个数据类型是 **EmptyDrop**，它将出现在我们尝试使用句柄访问之前已删除的对象或禁用的属性的情况下。
- en: Before we learn about the final data type, we will first need to learn what
    a handle is, and how to find it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习最终数据类型之前，我们首先需要了解什么是句柄，以及如何找到它。
- en: Finding the handle
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找句柄
- en: The `-`) are used to replace any special characters and spaces. Similar to when
    we learned how to access an individual item inside an array using the position
    index, we can use page handles to access the attributes of a Liquid object.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`-` 用于替换任何特殊字符和空格。类似于我们学习如何使用位置索引访问数组中的单个项目，我们也可以使用页面句柄来访问液态对象的属性。'
- en: 'We now understand what a page handle is, but let''s try to put that into context
    by creating a page on our store and see what we just learned in action:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在理解了页面句柄是什么，但让我们通过在我们的商店中创建一个页面来尝试将其放入上下文中，看看我们刚刚学到了什么：
- en: To create a new page, we will first need to navigate to our store by visiting
    [https://www.my-store-name.myshopify.com/admin](https://www.my-store-name.myshopify.com/admin)
    and logging in using our Shopify Partner credentials. An alternative way to do
    this is to visit the Shopify Partners site at [https://www.shopify.com/partners](https://www.shopify.com/partners)
    and log in with the Partner account that we created in the previous chapter, subsequently
    clicking on the **Store** button in the left sidebar and then logging in to our
    store by clicking the **Log in** button next to the name of our store.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建新页面，我们首先需要通过访问 [https://www.my-store-name.myshopify.com/admin](https://www.my-store-name.myshopify.com/admin)
    并使用我们的 Shopify 合作伙伴凭据登录来导航到我们的商店。另一种方法是访问 Shopify 合作伙伴网站 [https://www.shopify.com/partners](https://www.shopify.com/partners)，并使用我们在上一章中创建的合作伙伴账户登录，然后在左侧侧边栏中点击
    **商店** 按钮，然后通过点击商店名称旁边的 **登录** 按钮来登录我们的商店。
- en: After successfully logging in to our store, in the sidebar, under **Sales channels**,
    click on **Online Store** to expand the additional sections of the menu and subsequently
    click on the **Pages** link, redirecting us to the **Pages** section of our store:![Figure
    2.1 – Accessing the Pages section
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功登录我们的商店后，在侧边栏中，在 **销售渠道** 下方点击 **在线商店** 以展开菜单的附加部分，然后点击 **页面** 链接，将我们重定向到商店的
    **页面** 部分：![图 2.1 – 访问页面部分
- en: '](img/Figure_2.1_B17606.jpg)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.1_B17606.jpg)'
- en: Figure 2.1 – Accessing the Pages section
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.1 – 访问页面部分
- en: Once inside, since our store is new and has no content, the only thing that
    we will see is the **Add page** button. Otherwise, we would see a list of all
    the pages that we have access to in our store. To proceed with creating our first
    page, click on the **Add page** button.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入，由于我们的商店是新的且没有内容，我们唯一能看到的就是 **添加页面** 按钮。否则，我们会看到我们可以在商店中访问的所有页面的列表。要继续创建我们的第一个页面，请点击
    **添加页面** 按钮。
- en: After initializing the process of creating a new page, we will see the page
    where we can define the content of the new page, including the name, description,
    visibility, and which template the page should use. We will only need to enter
    the title of our page for our current purpose, ensuring that we select the `Learning
    about the page handle` as the title. We also made sure to select the **Visible**
    option, so the only thing left is to click on the **Save** button:![Figure 2.2
    – Creating and publishing the new page in the Shopify admin interface
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化创建新页面的过程后，我们将看到可以定义新页面内容的页面，包括名称、描述、可见性和页面应使用的模板。对于我们的当前目的，我们只需要输入我们页面的标题，确保我们选择
    `了解页面句柄` 作为标题。我们还确保选择了 **可见** 选项，所以剩下的就是点击 **保存** 按钮：![图 2.2 – 在 Shopify 管理界面中创建和发布新页面
- en: '](img/Figure_2.2_B17606.jpg)'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.2_B17606.jpg)'
- en: Figure 2.2 – Creating and publishing the new page in the Shopify admin interface
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.2 – 在 Shopify 管理界面中创建和发布新页面
- en: 'Now that we have created our page, we can see the page handle by clicking on
    the **Edit website SEO** button on the lower part of the window, which will expand
    and reveal the SEO information for our page, where, among other options, we can
    see the handle of our page:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了页面，我们可以通过点击窗口下方的 **编辑网站 SEO** 按钮来查看页面句柄，这将展开并显示我们页面的 SEO 信息，其中我们可以看到页面的句柄（以及其他选项）：
- en: '![Figure 2.3 – Updating the page URL and handle information'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3 – 更新页面 URL 和句柄信息'
- en: '](img/Figure_2.3_B17606.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.3_B17606.jpg)'
- en: Figure 2.3 – Updating the page URL and handle information
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 更新页面URL和句柄信息
- en: As we recall, the handle is a page title in lowercase with hyphens (`-`) replacing
    the special characters and empty spaces. In our case, the handle for our page
    is `learning-about-the-page-handle`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所回忆的，句柄是一个以小写字母书写的页面标题，其中特殊字符和空格由连字符（`-`）替换。在我们的例子中，我们页面的句柄是`learning-about-the-page-handle`。
- en: 'Important note:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: If for some reason, we were to change the title of the page that we have now
    created, this would only affect the page title. The handle would remain the same,
    as changing the page name does not automatically update the handle. The only way
    to change the handle is to click on **Edit website SEO** and manually edit the
    handle inside the **URL and handle** field.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，我们更改了我们现在创建的页面的标题，这将只会影响页面标题。句柄将保持不变，因为更改页面名称不会自动更新句柄。更改句柄的唯一方法是点击**编辑网站SEO**，并在**URL和句柄**字段中手动编辑句柄。
- en: Now that we have learned what the page handle is and how to manage it, we can
    proceed from where we left off with the EmptyDrop data type.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了页面句柄是什么以及如何管理它，我们可以从EmptyDrop数据类型离开的地方继续前进。
- en: EmptyDrop data type
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EmptyDrop数据类型
- en: As we recall, EmptyDrop results from us trying to access an attribute of the
    previously deleted or disabled object. Note that EmptyDrop, like nil, is not a
    string with the text `EmptyDrop`, nor a variable, and as such, it does not have
    a visual representation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所回忆的，EmptyDrop是由于我们试图访问之前已删除或禁用的对象的属性而产生的。请注意，EmptyDrop，就像nil一样，不是一个包含文本“EmptyDrop”的字符串，也不是一个变量，因此它没有可视表示。
- en: 'We can access an object using its handle by pluralizing the name of the object
    that we are trying to access, followed by either a squared bracket (`[]`) or dot
    (`.`) notation:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将我们要访问的对象的名称复数化，然后跟随一个方括号（`[]`）或点（`.`）表示法来使用句柄访问对象：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'While the result will be the same no matter which notation we select, it is
    important to mention both, as they each have their purpose, which we will cover
    in the later chapters:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们选择哪种表示法，结果都将相同，但重要的是要提到两者，因为它们各自都有其目的，我们将在后面的章节中介绍：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have now learned how to access an object and read its attributes through
    the page handle. However, *what if we were to go back to our admin interface and
    disable the previously created page by switching the Visibility option to Hidden?*
    The result of such an action would be EmptyDrop:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何通过页面句柄访问对象并读取其属性。然而，*如果我们回到我们的管理界面，通过将可见性选项切换到隐藏来禁用之前创建的页面，会发生什么？*
    这样的操作结果将是EmptyDrop：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'EmptyDrop attributes have only one attribute called `empty?`, which is always
    truthy. To avoid this issue, we can create a conditional statement to check whether
    EmptyDrop is `empty`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: EmptyDrop属性只有一个名为`empty?`的属性，它始终为真值。为了避免这个问题，我们可以创建一个条件语句来检查EmptyDrop是否为`empty`：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If the object is not equal to empty, which is always truthy for EmptyDrop, the
    code inside our conditional will render. Otherwise, if the code is equal to empty,
    the object we are looking for is empty, and the code will not render.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象不等于空，对于EmptyDrop来说，这始终为真值，那么我们的条件内的代码将渲染。否则，如果代码等于空，我们正在寻找的对象是空的，代码将不会渲染。
- en: Controlling whitespace
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制空白
- en: 'In the previous sections, we learned how to use conditionals with variable
    data types to ensure that we always receive a correct value. However, even with
    our conditionals, the same values can be accompanied by some unwanted whitespaces:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何使用变量数据类型的条件来确保我们始终收到正确的值。然而，即使有了我们的条件，相同的值也可能伴随着一些不需要的空白：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the previous example, we have created a conditional that will return `true`
    if our collection object exists, ensuring that our message will not be incomplete.
    While our result looks correct, if we were to inspect the page, we would see that
    things aren''t perfect:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个条件，如果我们的集合对象存在，它将返回`true`，确保我们的消息不会不完整。虽然我们的结果看起来是正确的，但如果我们要检查页面，我们会看到事情并不完美：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As we can see from our previous example, we have successfully recovered the
    collection information. However, we can see a significant number of empty spaces
    around our message, which results from processing Liquid code. Even though not
    every Liquid code will output HTML, each line will generate a line for each line
    of Liquid code by default.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从先前的例子中可以看到的，我们已经成功恢复了集合信息。然而，我们可以看到我们的消息周围有大量的空格，这是由处理Liquid代码产生的。即使不是每个Liquid代码都会输出HTML，默认情况下，每一行都会为每一行Liquid代码生成一行。
- en: 'To resolve this problem, we can introduce a hyphen inside our syntax tag as
    `{{- - }}` or `{%- -%}`, which allows us to strip any unwanted whitespace:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以在我们的语法标签内引入一个破折号，作为`{{- - }}`或`{%- -%}`，这允许我们去除任何不需要的空白字符：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With the introduction of the hyphens seen in the previous code block, we have
    successfully removed the two empty lines that our conditional was rendering:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入之前代码块中看到的破折号后，我们成功移除了条件渲染的两个空行：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice how the hyphens we added on both ends within our conditional has removed
    the whitespace on both sides. However, we have only added one hyphen on the closing
    bracket of the `collection.title` to remove the empty whitespace on its right
    side. If we were to add a hyphen to the left side as well, we would have removed
    the space separating the verb `"is"` and the collection name.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们添加在条件两端的破折号如何移除了两边的空白字符。然而，我们只在`collection.title`的闭合括号上添加了一个破折号来移除其右侧的空格。如果我们同时在左侧也添加一个破折号，我们将移除分隔动词`"is"`和集合名称的空格。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the basics of Liquid by learning what Liquid is,
    and how to discern Liquid code by learning how to read and write its syntax. We
    have gained an understanding of all Liquid logic and comparison operators, which,
    combined with all Liquid data types we have covered, will help us ensure that
    we always receive only the data we are expecting. As we progress further, this
    will become more and more essential.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过学习什么是Liquid以及如何通过学习阅读和编写其语法来了解Liquid的基础。我们已经理解了所有的Liquid逻辑和比较运算符，结合我们已覆盖的所有Liquid数据类型，这将帮助我们确保我们总是只接收我们期望的数据。随着我们进一步学习，这一点将变得越来越重要。
- en: Lastly, we have learned how to create and access each page individually, which
    will be of great use to us in the following chapter, where we will be learning
    more about the objects that we have mentioned on a few occasions throughout the
    current chapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何单独创建和访问每一页，这在下一章中对我们非常有用，我们将学习更多关于在本章中几次提到的一些对象。
- en: Quiz
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 习题
- en: What type of delimiter should we use if we are expecting an output as a result?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们期望得到一个输出结果，我们应该使用哪种类型的分隔符？
- en: What will the result of the following conditional be, and why?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下条件的结果将是什么，原因是什么？
- en: '[PRE35]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: What are the two methods to access an item inside an attribute?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问属性内的一项有哪些两种方法？
- en: What is the correct way of accessing an object using its handle?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用其句柄访问对象的方法是什么？
- en: What are the two problems inside the following block of code?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码块中存在哪两个问题？
- en: '[PRE36]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
