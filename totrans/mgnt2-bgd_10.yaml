- en: Chapter 9. The Web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout previous chapters, we learned how to use some of the backend components
    so that storeowners can manage and manipulate the data such as customers, products,
    categories, orders, and so on. Sometimes this is not enough, like when we are
    pulling data in or out from third-party systems. In cases like these, the Magento
    Web API framework makes it easy to call Magento services through REST or SOAP.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: User types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST versus SOAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hands-on with token-based authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hands-on with OAuth-based authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth-based Web API calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hands-on with session-based authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom Web APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search Criteria Interface for list filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we can start making Web API calls, we must authenticate our identity
    and have the necessary permissions (authorization) to access the API resource.
    Authentication allows Magento to identify the caller's user type. Based on the
    user's (administrator, integration, customer, or guest) access rights, the API
    calls' resource accessibility is determined.
  prefs: []
  type: TYPE_NORMAL
- en: User types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The list of resources that we can access depends on our user type and is defined
    within our module `webapi.xml` configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of users known to API, listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Administrator or integration**: Resources for which administrators or integrators
    are authorized. For example, if administrators are authorized for the `Magento_Cms::page
    resource`, they can make a `POST /V1/cmsPage` call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customer**: Resources for which customers are authorized. These are the resources
    with anonymous or self permission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Guest user**: Resources for which guests are authorized. These are the resources
    with anonymous permission.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two files play a crucial role toward defining an API: our module `acl.xml`
    and `webapi.xml` files.'
  prefs: []
  type: TYPE_NORMAL
- en: '`acl.xml` is where we define our module **access control list** (**ACL**).
    It defines an available set of permissions to access the resources. The `acl.xml`
    files across all Magento modules are consolidated to build an ACL tree that is
    used to select allowed admin role resources or third-party integration''s access
    (**System** | **Extensions** | **Integrations** | **Add New Integration** | **Available
    APIs**).'
  prefs: []
  type: TYPE_NORMAL
- en: '`webapi.xml` is where we define Web API resources and their permissions. When
    we create `webapi.xml`, the permissions defined in `acl.xml` are referenced to
    create access rights for each API resource.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following (truncated) `webapi.xml` from the core
    `Magento_Cms` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `webapi.xml` file for the CMS page API, only a user with `Magento_Cms::page`
    authorization can access `POST /V1/cmsPage` or `GET /V1/cmsBlock/search`. We will
    get back to a more detailed explanation of route later on in our examples; for
    the moment, our focus is on `resource`. We can assign multiple child `resource`
    elements under resources. In cases like these, it would be sufficient for a user
    to have any one of those ACLs assigned to be able to make an API call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual authorization is then granted to either an administrator or integration,
    defined in the Magento admin, with full group or a specific resource selected
    in the ACL tree as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User types](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Given that `webapi.xml` and `acl.xml` go hand in hand, let''s take a look at
    the (truncated) `acl.xml` file from the core `Magento_Cms` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the position of the `Magento_Cms::page` resource is nested under
    `Magento_Backend::content_elements`, which in turn is nested under `Magento_Backend::content`,
    which is further nested under `Magento_Backend::admin`. This tells Magento where
    to render the ACL under Magento admin when showing the **Roles Resources** tree
    as shown in the previous screenshot. This does not mean that the user authorized
    against the `Magento_Cms::page` resource won't be able to access the API if all
    those parent `Magento_Backend` resources are granted to him as well.
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing against a resource is sort of a flat thing. There is no tree check
    when authorizing. Thus, each resource is required to have a unique `id` attribute
    value on a `resource` element when defined under `acl.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: The resources just defined are what we listed before as resources for which
    administrators or integrators are authorized.
  prefs: []
  type: TYPE_NORMAL
- en: The customer, on the other hand, is assigned a resource named `anonymous` or
    `self`. If we were to do a full `<resource ref="anonymous" />` string search across
    all Magento core modules, several occurrences would show up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the (truncated) core module `vendor/magento/module-catalog/etc/webapi.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding XML defines an API endpoint path with a value of `/V1/products`,
    available via the **HTTP GET** method. It further defines a resource called `anonymous`,
    which means either the currently logged-in customer or guest user can call this
    API endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '`anonymous` is a special permission that doesn''t need to be defined in `acl.xml`.
    As such, it will not show up in the permissions tree under Magento admin. This
    simply means that the current resource in `webapi.xml` can be accessed without
    the need for authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we take a look at the `self` resource, whose example we can find under
    the (truncated) `vendor/magento/module-customer/etc/webapi.xml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`self` is a special kind of access that enables a user to access resources
    they own, assuming we already have an authenticated session with the system. For
    example, `GET /V1/customers/me` fetches the logged-in customer''s details. This
    is something that is typically useful for JavaScript-based components/widgets.'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile applications, third-party applications, and JavaScript components/widgets
    (storefront or admin) are the three main types of clients as seen by Magento.
    Though a client is basically everything communicating with our APIs, each type
    of client has a preferred authentication method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Magento supports three types of authentication methods, listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Token-based authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth-based authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session-based authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Token-based authentication** is most suitable for mobile applications, where
    a token acts like an electronic key providing access to the Web API''s. The general
    concept behind a token-based authentication system is relatively simple. The user
    provides a username and password during initial authentication in order to obtain
    a time-limited token from the system. If a token is successfully obtained, all
    subsequent API calls are then made with that token.'
  prefs: []
  type: TYPE_NORMAL
- en: '**OAuth-based authentication** is suitable for third-party applications that
    integrate with Magento. Once an application is authorized through the **OAuth
    1.0a handshake process**, it gains access to Magento Web APIs. There are three
    key terminologies we must understand here: *user* (resource owner), *client* (consumer),
    and *server* (service provider). The user or resource owner is the one who is
    being asked to allow access to its protected resource. Imagine a customer as a
    user (resource owner) allowing access to its orders to some third-party applications.
    In such a case, this third-party application would be the client (consumer), whereas
    Magento and its Web API would be the server (service provider).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Session-based authentication** is probably the simplest one to grasp. As
    a customer, you log in to the Magento storefront with your customer credentials.
    As an admin, you log in to the Magento admin with your admin credentials. The
    Magento Web API framework uses your logged-in session information to verify your
    identity and authorize access to the requested resource.'
  prefs: []
  type: TYPE_NORMAL
- en: REST versus SOAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Magento supports both **SOAP** (short for **Simple Object Access Protocol**)
    and **REST** (short for **Representational State Transfer**) types of communication
    with the Web API. Authentication methods themselves are not really bound to any
    of them. We can use the same authentication method and Web API method calls with
    both SOAP and REST.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the REST specifics we might outline as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We run REST Web API calls through cURL commands or a REST client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Requests support `HTTP` verbs: `GET`, `POST`, `PUT`, or `DELETE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `HTTP` header requires an authorization parameter, specifying the authentication
    token with the **Bearer HTTP authorization scheme**, `Authorization: Bearer <TOKEN>`.
    `<TOKEN>` is the authentication token returned by the Magento token service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the `HTTP` header `Accept: application/<FORMAT>`, where `<FORMAT>`
    is either JSON or XML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the SOAP specifics we might outline as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We run SOAP Web API calls through cURL commands or a SOAP client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Web Service D****efinition Language** (**WSDL**) file is generated only
    for services that we request. There is no one big merged WSDL file for all services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Magento Web API uses WSDL 1.2, compliant with WS-I 2.0 Basic Profile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each Magento service interface that is part of a service contract is represented
    as a separate service in the WSDL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming several services implies specifying them in the WSDL endpoint URL
    in a comma-separated manner, for example `http://<magento.host>/soap/<optional_store_code>?wsdl&services=<service_name_1>,<service_name_2>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can get a list of all available services by hitting a URL like `http://<SHOP-URL>/soap/default?wsdl_list`
    in the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following REST and SOAP examples will make extensive use of cURL, which
    is essentially a program that allows you to make HTTP requests from the command
    line or different language implementations (like PHP). We can further describe
    cURL as the console browser, or our *view source* tool for the web. Anything we
    can do with various fancy REST and SOAP libraries, we can do with cURL as well;
    it is just considered to be a more low-level approach.
  prefs: []
  type: TYPE_NORMAL
- en: Doing SOAP requests with cURL or anything else that does not have WSDL/XML parsing
    implemented internally is cumbersome. Thus, using PHP SoapClient or something
    more robust is a must. **SoapClient** is an integrated, actively maintained part
    of PHP, and is thus generally available.
  prefs: []
  type: TYPE_NORMAL
- en: With negative points being pointed, we will still present all of our API calls
    with console cURL, PHP cURL, and PHP SoapClient examples. Given that libraries
    abstract so much functionality, it is absolutely essential that a developer has
    a solid understanding of cURL, even for making SOAP calls.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on with token-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The crux of token-based authentication is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Client requests access with a username and password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application validates credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application provides a signed token to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code example demonstrates the console cURL REST-like request
    for the customer user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code example demonstrates the PHP cURL REST-like request for
    the customer user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code example demonstrates the console cURL SOAP-like request
    for the customer user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `-d @request.xml` part. Here, we are saying to the `curl` command
    to take the content of the `request.xml` file and pass it on as `POST` body data
    where the content of the `request.xml` file for the preceding `curl` command is
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code example demonstrates the PHP cURL SOAP-like request for
    the customer user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code example demonstrates the usage of PHP SoapClient to make
    a Web API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The API call for admin user authentication is nearly identical, and depends
    on which one of three approaches we take. The difference is merely in using `https://magento2.ce/rest/V1/integration/admin/token`
    as the endpoint URL in the case of REST, and using `http://magento2.ce/index.php/soap/default?services=integrationCustomerTokenServiceV1`.
    Additionally, for a SOAP call, we are calling `integrationAdminTokenServiceV1CreateAdminAccessToken`
    on the `$request` object.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of successful authentication, for both the customer and admin API
    call, the response would be a random-looking 32-characters-long string that we
    call token. This token is further saved to the `oauth_token` table in the database,
    under the token column.
  prefs: []
  type: TYPE_NORMAL
- en: This might be a bit confusing with regard to what the `oauth_token` table has
    to do with token authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we think about it, token-based authentication can be looked at as a simplified
    version of OAuth, where the user would authenticate using a username and password
    and then give the obtained time-expiring token to some third-party application
    to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of failed authentication, the server returns **HTTP 401 Unauthorized**,
    with a body containing a JSON message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we are able to call the API method, though we are not already authenticated?
    This means we must be calling an API defined by the anonymous type of resource.
    A quick look at the API endpoint gives us a hint as to the location of its definition.
    Looking under the `vendor/magento/module-integration/etc/webapi.xml` file, we
    can see the following (truncated) XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can clearly see how even token-based authentication itself is defined as
    API, using the anonymous resource so that everyone can access it. In a nutshell,
    token-based authentication is a feature of the `Magento\Integration` module.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our authentication token, we can start making other API calls.
    Remember, token simply means we have been authenticated against a given username
    and password. It does not mean we get full access to all Web API methods. This
    further depends on whether our customer or user has the proper access role.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on with OAuth-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OAuth-based authentication is the most complex, yet most flexible one supported
    by Magento. Before we get to use it, the merchant must register our external application
    as integration with the Magento instance. Placing ourselves in the role of merchant,
    we do so in the Magento admin area under **System** | **Extensions** | **Integrations**.
    Clicking on the **Add New Integration** button opens the screen as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hands-on with OAuth-based authentication](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The value `External Book App` is the freely given name of our external application.
    If we were connecting it with Twitter, we could have easily put its name here.
    Next to **Name**, we have the **Email**, **Callback URL**, and **Identity Link
    URL** fields. The value of e-mail is not really that important. The callback URL
    and identity link URL define the external application endpoint that receives OAuth
    credentials. The values of these links point to *external app* that stands as
    the OAuth client. We will come back to it in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **API** tab under the **Available APIs** pane, we set **Resource Access**
    to the value of **All** or **Custom**. If set to **Custom**, we can further fine-tune
    the resources in the **Resources** option we want to allow access to this integration
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hands-on with OAuth-based authentication](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We should always give the minimum required resources to the external application
    we are using. This way, we minimize possible security risks. The preceding screenshot
    shows us defining only `Sales`, `Products`, `Customer`, and `Marketing` resources
    to the integration. This means that the API user would not be able to use content
    resources, such as save or delete pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we click the **Save** button now, we should be redirected back to the **System**
    | **Extensions** | **Integrations** screen as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hands-on with OAuth-based authentication](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There are three things to focus our attention here. First, we are seeing an
    **Integration not secure** message. This is because when we defined our callback
    URL and identity link URL, we used HTTP and not HTTPS protocol. When doing real-world
    connections, for security reasons, we need to be sure to use HTTPS. Further, we
    notice how the **Status** column still says **Inactive**.
  prefs: []
  type: TYPE_NORMAL
- en: The **Activate** link, to the right of the **Status** column, is the preceding
    step before the two-legged OAuth handshake starts. Only an administrator with
    access to integration listing in the backend can initiate this.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we need to pull the entire PHP code behind the `External Book
    App` OAuth client from here, [https://github.com/ajzele/B05032-BookAppOauthClient](https://github.com/ajzele/B05032-BookAppOauthClient),
    and place it into the root of our Magento installation under the `pub/external-book-app/`
    folder as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hands-on with OAuth-based authentication](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The function of these files is to simulate our own mini-OAuth client. We will
    not go into much detail about the content of these files, It is more important
    to look at it as an external OAuth client app. The `callback-url.php` and `identity-link-url.php`
    files will execute when Magento triggers the callback and identity link URL's
    as configured under the output image on the previous page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the OAuth client files are in place, we go back to our integrations listing.
    Here, we click on the **Activate** link. This opens a modal box, asking us to
    approve access to the API resources as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hands-on with OAuth-based authentication](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice how API resources listed here match those few we set under the **API**
    tab when creating integration. There are only two actions we can do here really:
    either click **Cancel** or **Allow** to start the two-legged OAuth handshake.
    Clicking the **Allow** button does two things in parallel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it instantly posts the credentials to the endpoint (callback URL) specified
    when creating the `External Book App` integration. The **HTTP POST** from Magento
    to the callback URL contains parameters with values similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, a HTTP POST request is hitting the `callback-url.php` file whose
    content (partial) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can see that parameters passed by Magento are stored into an external app
    session named `BookAppOAuth`. Later on, within the `check-login.php` file, these
    parameters will be used to instantiate the `BookAppOauthClient`, which will further
    be used to get a request token, which is a pre-authorized token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parallel to **Callback URL** HTTP POST, we have a popup window opening as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hands-on with OAuth-based authentication](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The login form we see in the popup is just some dummy content we placed under
    the `identity-link-url.php` file. Magento passes two values to this file via HTTP
    GET. These are `consumer_id` and `success_call_back`. The `consumer_id` value
    is the ID of our integration we created in the admin area. It is up to the OAuth
    client app to decide if it wants to do anything with this value or not. The `success_call_back`
    URL points to our Magento `admin integration/loginSuccessCallback` path. If we
    take a look at the code of the `identity-link-url.php` file, we can see the form
    is set to do the `POST` action on the URL like `check-login.php?consumer_id={$consumerId}&callback_url={$callbackUrl}`.
  prefs: []
  type: TYPE_NORMAL
- en: If we now click the **Login** button, the form will `POST` data to the `check-login.php`
    file passing it `consumer_id` and `callback_url` within the URL as `GET` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of `check-login.php` is defined (partially) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To keep thing simple, we have no real user login check here. We might have added
    one above the OAuth-related calls, and then authenticate the user against some
    username and password before allowing it to use OAuth. However, for simplicity
    reasons we omitted this part from our sample OAuth client app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `check-login.php` file, we can see that based on the previously
    stored session parameters we perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate the `\OAuth\Common\Consumer\Credentials` object passing it the `oauth_consumer_key`,
    `oauth_consumer_secret`, `store_base_url` stored in the session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiate the `BookAppOauthClient` object passing its constructor the entire
    credentials object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `OauthClient` object to get the request token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the request token to get a long-lived access token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If everything executes successfully, the popup window closes and we get redirected
    back to the integrations listing. The difference now is that looking at the grid,
    we have an **Active** status and next to it we have a **Reauthorize** link, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hands-on with OAuth-based authentication](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'What we are really after at this point are **Access Token** and **Access Token
    Secret**. We can see those if we edit the `External Book App` integration. These
    values should now be present on the **Integration Details** tab as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hands-on with OAuth-based authentication](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Access Token** is the key to all of our further API calls, and with it we
    successfully finish our authentication bit of OAuth-based authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: OAuth-based Web API calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have obtained OAuth access token, from the preceding steps, we can start
    making Web API calls to other methods. Even though the Web API coverage is the
    same for both REST and SOAP, there is a significant difference when making method
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of giving a more robust example, we will be targeting the customer
    group `save` method, (partially) defined in the `vendor/magento/module-customer/etc/webapi.xml`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the access token to make Web API calls, like `POST /V1/customerGroups`,
    we need to include these request parameters in the authorization request header
    in the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '`oauth_consumer_key`, available from the Magento admin area, under the integration
    edit screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oauth_nonce`, random value, uniquely generated by the application for each
    request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oauth_signature_method`, name of the signature method used to sign the request.
    Valid values are: `HMAC-SHA1`, `RSA-SHA1`, and `PLAINTEXT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though the Outh protocol supports `PLAINTEXT`, Magento does not. We will
    be using `HMAC-SHA1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oauth_timestamp`, integer value, Unix-like timestamp.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oauth_token`, available from the Magento admin area, under the integration
    edit screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oauth_version`, Magento supports Oauth 1.0a, thus we use `1.0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oauth_signature`, generated signature value, omitted from the signature generation
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To generate an OAuth 1.0a HMAC-SHA1 signature for a HTTP request takes focused
    effort, if done manually.
  prefs: []
  type: TYPE_NORMAL
- en: We need to determine the HTTP method and URL of the request, which equals to
    `POST http://magento2-merchant.loc/rest/V1/customerGroups`. It is important to
    use the correct protocol here, so make sure that the `https://` or `http://` portion
    of the URL matches the actual request sent to the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then gather all of the parameters included in the request. There are two
    such locations for these additional parameters: the URL (as part of the query
    string) and the request body.'
  prefs: []
  type: TYPE_NORMAL
- en: In the HTTP request, the parameters are URL encoded, but we need to collect
    the raw values. In addition to the request parameters, every `oauth_*` parameter
    needs to be included in the signature, except the `oauth_signature` itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters are normalized into a single string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Parameters are sorted by name, using lexicographical byte value ordering. If
    two or more parameters share the same name, they are sorted by their value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters are concatenated in their sorted order into a single string. For
    each parameter, the name is separated from the corresponding value by an `=` character
    (ASCII code 61), even if the value is empty. Each name-value pair is separated
    by an `&` character (ASCII code 38).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further, we define the signing key as a value of `{Consumer Key}+{&}+{Access
    Token Secret}`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we apply the string normalization rules to parameters and determine the
    signing key, we call `hash_hmac('sha1', $data, {Signing Key}, true)` to get the
    final `oauth_signature` value.
  prefs: []
  type: TYPE_NORMAL
- en: This should get us the `oauth_signature` as a random 28-characters-long string,
    similar to this one – `Pi/mGfA0SOlIxO9W30sEch6bjGE=`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding how to generate the signature string is important, but getting
    it right every time is tedious and time consuming. We can help ourselves by instantiating
    the objects of the built-in `\OAuth\Common\Consumer\Credentials` and `\OAuth\OAuth1\Signature\Signature`
    classes, like (partially) shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the `oauth_signature` value, we are ready to do our console
    `curl` REST example. It comes down to running the following on a console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding command is merely visually broken into new lines. It
    should all be single line on a console. Once executed, the API call will create
    a new customer group called `The Book Writer`. A logical question one might ask
    looking at the `curl` command is how come we did not normalize the POST data passed
    as JSON via the `–d` flag switch. This is because parameters in the HTTP POST
    request body are only taken into consideration for signature generation if content-type
    is `application/x-www-form-urlencoded`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The console cURL SOAP requests do not require usage of the OAuth signature.
    We can execute a SOAP request passing `Authorization: Bearer { Access Token value
    }` into the request header, like shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `request.xml` contains content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code example demonstrates the PHP cURL SOAP-like request for
    the customer group `save` method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the method name `customerGroupRepositoryV1Save` actually comprises
    service name `customerGroupRepositoryV1`, plus the `Save` name of the actual method
    within the service.
  prefs: []
  type: TYPE_NORMAL
- en: We can get a list of all services defined by opening a URL like `http://magento2.ce/soap/default?wsdl_list`
    in the browser (depending on our Magento installation).
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on with session-based authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Session-based authentication is the third and most simple type of authentication
    in Magento. We do not have any complexities of token-passing here. As the customer,
    we log in to the Magento storefront with our customer credentials. As an admin,
    we log in to the Magento admin with our admin credentials. Magento uses a cookie
    named `PHPSESSID` to track the session where our login state is stored. The Web
    API framework uses our logged-in session information to verify our identity and
    authorize access to the requested resource.
  prefs: []
  type: TYPE_NORMAL
- en: Customers can access resources that are configured with anonymous or self-permission
    in the `webapi.xml` configuration file, like `GET /rest/V1/customers/me`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to open the `http://magento2.ce/rest/V1/customers/me` URL while in
    the browser, but not logged in as the customer, we would get a response as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we log in as the customer and then try to open that same URL, we would get
    a response as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Admin users can access resources that are assigned to their Magento admin profile.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom Web APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Magento comes with a solid number of API methods that we can call. However,
    sometimes this is not enough, as our business needs dictate additional logic,
    and we need to be able to add our own methods to the Web API.
  prefs: []
  type: TYPE_NORMAL
- en: The best part of creating our own API's is that we do not have to be concerned
    about making them REST or SOAP. Magento abstracts this so that our API methods
    are automatically available for REST and for SOAP calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding new API''s conceptually evolves around two things: defining business
    logic through various classes, and exposing it via the `webapi.xml` file. However,
    as we will soon see, there is a lot of **boilerplate** to it.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a miniature module called `Foggyline_Slider`, on which we will
    demonstrate `create (POST)`, `update (PUT)`, `delete (DELETE)`, and `list (GET)`
    method calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a module registration file, `app/code/Foggyline/Slider/registration.php`,
    with content (partial) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a module configuration file, `app/code/Foggyline/Slider/etc/module.xml`,
    with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an install script where our future models will persist module data.
    We do so by creating the `app/code/Foggyline/Slider/Setup/InstallSchema.php` file
    with content (partial) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we specify the ACL for our resources. Our resources are going to be CRUD
    actions we do on our module entities. We will structure our module in a way that
    `slide` and `image` are separate entities, where one slide can have multiple image
    entities linked to it. Thus, we would like to be able to control access to save
    and delete actions separately for each entity. We do so by defining the `app/code/Foggyline/Slider/etc/acl.xml`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the ACL has been set, we define our Web API resources within the `app/code/Foggyline/Slider/etc/webapi.xml`
    file (partial) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice how each of those service class attributes point to the interface, not
    the class. This is the way we should build our exposable services, always having
    an interface definition behind them. As we will soon see, using `di.xml`, this
    does not mean Magento will try to create objects from these interfaces directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now create the `app/code/Foggyline/Slider/etc/di.xml` file with content
    (partial) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: What is happening here is that we are telling Magento something like, "hey,
    whenever you need to pass around an instance that conforms to the `Foggyline\Slider\Api\Data\SlideInterface`
    interface, preferably use the `Foggyline\Slider\Model\Slide` class for it."
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we still do not have any of those interfaces or model classes
    actually created. When creating APIs, we should first start by defining interfaces,
    and then our models should extend from those interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interface `Foggyline\Slider\Api\Data\SlideInterface` is defined within the
    `app/code/Foggyline/Slider/Api/Data/SlideInterface.php` file (partial) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We are going for ultimate simplification here. Our `Slide` entity only really
    has ID and title values. The `id` and `slide_id` point to the same field in the
    database and the implementation of their getters and setters should yield the
    same results.
  prefs: []
  type: TYPE_NORMAL
- en: Although `API/Data/*.php` interfaces become blueprint requirements for our data
    models, we also have `Api/*RepositoryInterface.php` files. The idea here is to
    extract create, update, delete, search, and similar data-handling logic away from
    the data model class into its own class. This way, our model classes become more
    pure data and business logic classes while the rest of persistence and search-related
    logic moves into these repository classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our **Slide** **Repository Interface** is defined within the `app/code/Foggyline/Slider/Api/SlideRepositoryInterface.php`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With interfaces in place, we can move on to model class. In order to persist
    and fetch data in a database, our `Slide` entity really needs three files under
    the `Model` directory. These are called data *model*, *resource class*, and *collection
    class*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data model class is defined under the `app/code/Foggyline/Slider/Model/Slide.php`
    file (partial) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the model data class is the model resource class, defined in the
    `app/code/Foggyline/Slider/Model/ResourceModel/Slide.php` file (partial) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the third bit is the model collection class, defined in the `app/code/Foggyline/Slider/Model/ResourceModel/Slide/Collection.php`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If we were to manually instantiate the model data class now, we would be able
    to persist the data in the database. To complete the `di.xml` requirements, we
    still lack one more final ingredient – the `Model/SlideRepository` class file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us go and create the `app/code/Foggyline/Slider/Model/SlideRepository.php`
    file with content (partial) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It might appear that there is a lot going on here, but really we are just passing
    on some class and interface names to the constructor in order to instantiate the
    objects we will use across individual service methods defined in the `webapi.xml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first service method on our list is `getById`, defined within `SlideRepository.php`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have the save method, defined within `SlideRepository.php` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `save` method addresses both `POST` and `PUT` requests defined in `webapi.xml`,
    thus effectively handling the creation of new slides or an update of existing
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going further, we have the `getList` method, defined within `SlideRepository.php`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the `deleteById` method, defined within `SlideRepository.php`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that we only covered the `Slide` entity in the preceding partial
    code examples, which is enough to progress further with API call examples.
  prefs: []
  type: TYPE_NORMAL
- en: API call examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since all of our defined API's are resource protected, we first need to authenticate
    as the admin user, assuming the admin user has access to all our custom resources
    that encompass the ones we defined. For simplicity sake, we will use the token-based
    authentication method, examples of which are given previously in this chapter.
    Once authenticated, we should have a 32 random characters long token like `pk8h93nq9cevaw55bohkjbp0o7kpl4d3`,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the token key has been obtained, we will test the following API calls
    using console cURL, PHP cURL, PHP SoapClient, and console SOAP style cURL examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /V1/foggylineSliderSlide/:slideId`, calls the `getById` service method,
    requires the `Foggyline_Slider::slide` resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /V1/foggylineSliderSlide/search`, calls the `getList` service method,
    requires the `Foggyline_Slider::slide` resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /V1/foggylineSliderSlide`, calls the `save` service method, requires
    the `Foggyline_Slider::slide_save` resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT /V1/foggylineSliderSlide/:id`, calls the `save` service method, requires
    the `Foggyline_Slider::slide_save` resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE /V1/foggylineSliderSlide/:slideId`, calls the `deleteById` service
    method, requires the `Foggyline_Slider::slide_delete` resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The getById service method call examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The console cURL style for executing `GET /V1/foggylineSliderSlide/:slideId`
    is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The PHP cURL style for executing `GET /V1/foggylineSliderSlide/:slideId` is
    done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The response for console and PHP cURL style should be a JSON string similar
    to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The PHP SoapClient style for executing `GET /V1/foggylineSliderSlide/:slideId`
    is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The response for PHP SoapClient style should be the `stdClass` PHP object as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The console SOAP style cURL for executing `GET /V1/foggylineSliderSlide/:slideId`
    is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `request.xml` has content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we did not really do `GET`, rather a `POST` type of request. Also,
    the URL to which we are pointing our `POST` is not really the same as with previous
    requests. This is because Magento SOAP requests are always `POST` (or `PUT`) type,
    as the data is submitted in XML format. XML format in return specifies the service,
    and the request header action specifies the method to be called on the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response for console SOAP style cURL should be an XML as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The getList service method call examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The console cURL style for executing `GET /V1/foggylineSliderSlide/search`
    is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The PHP cURL style for executing `GET /V1/foggylineSliderSlide/search` is done
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The response for console and PHP cURL style should be a JSON string similar
    to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The PHP SoapClient style for executing `GET /V1/foggylineSliderSlide/search`
    is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The response for PHP SoapClient style should be the `stdClass` PHP object as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The console SOAP style cURL for executing `GET /V1/foggylineSliderSlide/search`
    is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `request.xml` has content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Notice we did not really do `GET`, rather `POST`. Also, the URL to which we
    are pointing our `POST` is not really the same as with previous requests. This
    is because Magento SOAP requests are always `POST` type, as the data is submitted
    in XML format. XML format in return specifies the service, and the request header
    action specifies the method to be called on the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response for console SOAP style cURL should be an XML as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The save (as new) service method call examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The console cURL style for executing `POST /V1/foggylineSliderSlide` is done
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The PHP cURL style for executing `POST /V1/foggylineSliderSlide` is done as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The response for console and PHP cURL style should be a JSON string similar
    to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The PHP SoapClient style for executing `POST /V1/foggylineSliderSlide` is done
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The response for PHP SoapClient style should be the `stdClass` PHP object as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The console SOAP style cURL for executing `POST /V1/foggylineSliderSlide` is
    done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `request.xml` has content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The response for console SOAP style cURL should be an XML as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The save (as update) service method call examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The console cURL style for executing `PUT /V1/foggylineSliderSlide/:id` is
    done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The PHP cURL style for executing `PUT /V1/foggylineSliderSlide/:id` is done
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The response for console and PHP cURL style should be a JSON string similar
    to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The PHP SoapClient style for executing `PUT /V1/foggylineSliderSlide/:id` is
    done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The response for PHP SoapClient style should be the `stdClass` PHP object as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The console SOAP style cURL for executing `PUT /V1/foggylineSliderSlide/:id`
    is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `request.xml` has content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The response for console SOAP style cURL should be an XML as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The deleteById service method call examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The console cURL style for executing `DELETE /V1/foggylineSliderSlide/:slideId`
    is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The PHP cURL style for executing `DELETE /V1/foggylineSliderSlide/:slideId`
    is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The response for console and PHP cURL style should be a JSON string similar
    to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The PHP SoapClient style for executing `DELETE /V1/foggylineSliderSlide/:slideId`
    is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The response for PHP SoapClient style should be the `stdClass` PHP object as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The console SOAP style cURL for executing `DELETE /V1/foggylineSliderSlide/:slideId`
    is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `request.xml` has content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The response for console SOAP style cURL should be an XML as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The preceding API call examples cover all of our custom-defined APIs for the
    `Slide` entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking back at the `$searchCriteria` variable, we used the `GET` type of HTTP
    method, passing the entire variable as a query string. If we think about it, we
    could have specified `POST` during the Web API resource definition and packed
    the content of the `$searchCriteria` variable into the request body. Although
    the `GET` method approach might look a bit dirtier, imagine if we assigned the
    anonymous or self role to the resource: we would be able to simply open a lengthy
    URL in the browser and have the search results. Think of a possible widget use,
    where a widget would simply do an AJAX request to the URL and fetch the results
    for guests or the customer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The full module source code can be found here: [https://github.com/ajzele/B05032-Foggyline_Slider](https://github.com/ajzele/B05032-Foggyline_Slider).
    Aside from the `Slide` entity, the full module code includes the `Image` entity
    as well. Since each slide can contain multiple images, we can further test the
    `Image` API calls analogous to the preceding calls.'
  prefs: []
  type: TYPE_NORMAL
- en: Search Criteria Interface for list filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing how to do a proper list filtering to fetch the entities that match a
    certain lookup is essential for the effective use of `getList` services across
    core Magento and possibly custom-coded API's. An example is fetching the list
    of customers registered within the last 24 hours for the latest added product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look back at our `app/code/Foggyline/Slider/etc/webapi.xml` file,
    the bit where we defined the service `method="getList"`. The service class is
    defined as `Foggyline\Slider\Api\SlideRepositoryInterface`, which is defined as
    a preference for the `Foggyline\Slider\Model\SlideRepository` class. Finally,
    within the `SlideRepository` class, we have the actual `getList`. Method `getList`
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `getList` method takes only one parameter, object instance,
    that complies with `SearchCriteriaInterface` called `$searchCriteria`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What this means is we already have the (incomplete) JSON object of the following
    type to pass to the `getList` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to further understand the inner workings of `search_criteria`, we
    need to understand `SearchCriteriaInterface`, which is (partially) defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Every interface getter and setter method expects the values to be found in
    passed API parameters. What this means is that the `getPageSize()` and `setPageSize()`
    methods would expect `search_criteria` to have an integer type `page_size` property
    on it. Similarly, the `getFilterGroups()` and `setFilterGroups()` methods would
    expect `search_criteria` to have an array of `\Magento\Framework\Api\Search\FilterGroup`
    passed to it. These insights bring us to an (incomplete) JSON object of the following
    type to pass to the `getList` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Now we have got to the point where we need to determine what goes into `filter_groups`
    and `sort_orders`, since these are not simple types but compound values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking further into `\Magento\Framework\Api\Search\FilterGroup`, we see the
    definition of the `getFilters()` and `setFilters()` methods that work with an
    array of `\Magento\Framework\Api\Filter` objects. What this means is that `filter_groups`
    has a property filter that is an array of individual filter objects defined as
    `\Magento\Framework\Api\Filter`. With this in mind, we are now down to the following
    form of the `search_criteria` JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking further into individual `\Magento\Framework\Api\Filter`, through its
    getters and setters it defines we can conclude properties like `field`, `value`,
    and `condition_type`. This brings us one step further to finalizing our `search_criteria`
    JSON object, which is now structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us take a look at `sort_orders` as the last outstanding bit. `sort_orders`
    is of type `\Magento\Framework\Api\SortOrder`, which has getters and setters for
    the field and direction properties. Knowing this, we are able to fully construct
    our `search_criteria` JSON object (or array) that we would be passing to the `getList()`
    service method call, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: What happens when we define multiple entries under `filter_groups`, `filters`,
    or `sort_orders`? The logical expectation would be that these break into `AND`
    and `OR` operators in SQL when they hit the database. Surprisingly, this is not
    always the case, at least not with our preceding example. Since the actual implementation
    of the `getList` method is left for us to handle, we can decide how we want to
    handle the filter groups and filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking back at our `getList` method, as (partially) shown next, we are not
    doing anything to imply an `OR` operator, so everything ends up with an `AND`
    condition on the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code simply loops through all filter groups, pulling in all filters
    within the group and calling the same `addFieldToFilter` method for everything.
    Similar behavior is implemented across core Magento modules. Although the filtering
    itself follows the `\Magento\Framework\Api\SearchCriteriaInterface` interface,
    there is no unified Magento-wide approach to force `AND` and `OR` operators in
    filtering.
  prefs: []
  type: TYPE_NORMAL
- en: However, Magento core API's like `GET` products do implement both `AND` and
    `OR` conditions. In cases like these, filter groups result in `OR` and filters
    within the group result in `AND` conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Following best practices, we should make sure our modules that implement search
    criteria do so respecting the `filter_groups`/`filters` and `OR`/`AND` relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot of ground relating to Magento API's. There
    is much more left to be said, but the steps outlined here should be enough to
    get us started even with more advanced API usage. We started the chapter with
    learning about types of users and the authentication methods supported. Strong
    emphasis was placed on making several types of API calls, like console cURL, PHP
    cURL, PHP SoapClient, and console cURL SOAP. This was to encourage developers
    to understand the inner workings of API calls more deeply than just using high-level
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the next chapter, we will look into some of the major sections of
    Magento.
  prefs: []
  type: TYPE_NORMAL
