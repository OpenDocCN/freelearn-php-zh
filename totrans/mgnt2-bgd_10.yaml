- en: Chapter 9. The Web API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. Web API
- en: Throughout previous chapters, we learned how to use some of the backend components
    so that storeowners can manage and manipulate the data such as customers, products,
    categories, orders, and so on. Sometimes this is not enough, like when we are
    pulling data in or out from third-party systems. In cases like these, the Magento
    Web API framework makes it easy to call Magento services through REST or SOAP.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何使用一些后端组件，以便店主可以管理和操作数据，如客户、产品、类别、订单等。有时这还不够，比如当我们从第三方系统中拉取或推送数据时。在这些情况下，Magento
    Web API框架使得通过REST或SOAP调用Magento服务变得容易。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: User types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户类型
- en: Authentication methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证方法
- en: REST versus SOAP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST与SOAP
- en: Hands-on with token-based authentication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于令牌的认证实践
- en: Hands-on with OAuth-based authentication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于OAuth的认证实践
- en: OAuth-based Web API calls
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于OAuth的Web API调用
- en: Hands-on with session-based authentication
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于会话的认证实践
- en: Creating custom Web APIs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义Web API
- en: Search Criteria Interface for list filtering
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表过滤的搜索条件接口
- en: Before we can start making Web API calls, we must authenticate our identity
    and have the necessary permissions (authorization) to access the API resource.
    Authentication allows Magento to identify the caller's user type. Based on the
    user's (administrator, integration, customer, or guest) access rights, the API
    calls' resource accessibility is determined.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始进行Web API调用之前，我们必须验证我们的身份并拥有访问API资源的必要权限（授权）。认证允许Magento识别调用者的用户类型。根据用户的（管理员、集成、客户或访客）访问权限，确定API调用资源的可访问性。
- en: User types
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户类型
- en: The list of resources that we can access depends on our user type and is defined
    within our module `webapi.xml` configuration file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以访问的资源列表取决于我们的用户类型，并在我们的模块配置文件`webapi.xml`中定义。
- en: 'There are three types of users known to API, listed as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: API已知有三种用户类型，如下所示：
- en: '**Administrator or integration**: Resources for which administrators or integrators
    are authorized. For example, if administrators are authorized for the `Magento_Cms::page
    resource`, they can make a `POST /V1/cmsPage` call.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理员或集成者**：管理员或集成者被授权的资源。例如，如果管理员被授权访问`Magento_Cms::page resource`，他们可以发起`POST
    /V1/cmsPage`调用。'
- en: '**Customer**: Resources for which customers are authorized. These are the resources
    with anonymous or self permission.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户**：客户被授权的资源。这些资源具有匿名或自我权限。'
- en: '**Guest user**: Resources for which guests are authorized. These are the resources
    with anonymous permission.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访客用户**：访客被授权的资源。这些资源具有匿名权限。'
- en: 'Two files play a crucial role toward defining an API: our module `acl.xml`
    and `webapi.xml` files.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 两个文件在定义API方面起着至关重要的作用：我们的模块`acl.xml`和`webapi.xml`文件。
- en: '`acl.xml` is where we define our module **access control list** (**ACL**).
    It defines an available set of permissions to access the resources. The `acl.xml`
    files across all Magento modules are consolidated to build an ACL tree that is
    used to select allowed admin role resources or third-party integration''s access
    (**System** | **Extensions** | **Integrations** | **Add New Integration** | **Available
    APIs**).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`acl.xml`是我们定义我们的模块**访问控制列表**（**ACL**）的地方。它定义了访问资源的可用权限集。所有Magento模块的`acl.xml`文件被合并以构建一个ACL树，该树用于选择允许的admin角色资源或第三方集成的访问（**系统**
    | **扩展** | **集成** | **添加新集成** | **可用API**）。'
- en: '`webapi.xml` is where we define Web API resources and their permissions. When
    we create `webapi.xml`, the permissions defined in `acl.xml` are referenced to
    create access rights for each API resource.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`webapi.xml`是我们定义Web API资源和它们权限的地方。当我们创建`webapi.xml`时，`acl.xml`中定义的权限被引用以创建每个API资源的访问权限。'
- en: 'Let''s take a look at the following (truncated) `webapi.xml` from the core
    `Magento_Cms` module:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下（截断的）来自核心`Magento_Cms`模块的`webapi.xml`：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding `webapi.xml` file for the CMS page API, only a user with `Magento_Cms::page`
    authorization can access `POST /V1/cmsPage` or `GET /V1/cmsBlock/search`. We will
    get back to a more detailed explanation of route later on in our examples; for
    the moment, our focus is on `resource`. We can assign multiple child `resource`
    elements under resources. In cases like these, it would be sufficient for a user
    to have any one of those ACLs assigned to be able to make an API call.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CMS 页面 API 的前述 `webapi.xml` 文件中，只有拥有 `Magento_Cms::page` 授权的用户可以访问 `POST /V1/cmsPage`
    或 `GET /V1/cmsBlock/search`。我们将在示例中稍后更详细地解释路由；目前，我们的重点是 `resource`。我们可以在资源下分配多个子
    `resource` 元素。在这些情况下，用户只要有任何一个这些 ACL 被分配，就能进行 API 调用。
- en: 'The actual authorization is then granted to either an administrator or integration,
    defined in the Magento admin, with full group or a specific resource selected
    in the ACL tree as shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的授权是授予给管理员或集成商，他们在 Magento 管理员中定义，可以选择完整的组或 ACL 树中选定的特定资源，如下面的截图所示：
- en: '![User types](img/00061.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![用户类型](img/00061.jpeg)'
- en: 'Given that `webapi.xml` and `acl.xml` go hand in hand, let''s take a look at
    the (truncated) `acl.xml` file from the core `Magento_Cms` module:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `webapi.xml` 和 `acl.xml` 相互关联，让我们看看核心模块 `Magento_Cms` 的（截断的）`acl.xml` 文件：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice how the position of the `Magento_Cms::page` resource is nested under
    `Magento_Backend::content_elements`, which in turn is nested under `Magento_Backend::content`,
    which is further nested under `Magento_Backend::admin`. This tells Magento where
    to render the ACL under Magento admin when showing the **Roles Resources** tree
    as shown in the previous screenshot. This does not mean that the user authorized
    against the `Magento_Cms::page` resource won't be able to access the API if all
    those parent `Magento_Backend` resources are granted to him as well.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `Magento_Cms::page` 资源的位置嵌套在 `Magento_Backend::content_elements` 之下，而 `Magento_Backend::content_elements`
    又嵌套在 `Magento_Backend::content` 之下，`Magento_Backend::content` 又嵌套在 `Magento_Backend::admin`
    之下。这告诉 Magento 在显示 **角色资源** 树时，在 Magento 管理员下渲染 ACL 的位置，如前一个截图所示。这并不意味着如果用户被授权访问所有这些父
    `Magento_Backend` 资源，他仍然无法访问 `Magento_Cms::page` 资源所对应的 API。
- en: Authorizing against a resource is sort of a flat thing. There is no tree check
    when authorizing. Thus, each resource is required to have a unique `id` attribute
    value on a `resource` element when defined under `acl.xml`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对资源进行授权是一种相对简单的事情。在授权时没有树形检查。因此，当在 `acl.xml` 下定义时，每个资源都需要在 `resource` 元素上有一个唯一的
    `id` 属性值。
- en: The resources just defined are what we listed before as resources for which
    administrators or integrators are authorized.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所列出的，这些定义的资源是管理员或集成商被授权访问的资源。
- en: The customer, on the other hand, is assigned a resource named `anonymous` or
    `self`. If we were to do a full `<resource ref="anonymous" />` string search across
    all Magento core modules, several occurrences would show up.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，客户被分配了一个名为 `anonymous` 或 `self` 的资源。如果我们对所有 Magento 核心模块进行完整的 `<resource
    ref="anonymous" />` 字符串搜索，会出现几个匹配项。
- en: 'Let''s take a look at the (truncated) core module `vendor/magento/module-catalog/etc/webapi.xml`
    file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看核心模块 `vendor/magento/module-catalog/etc/webapi.xml` 文件（以下为截断内容）：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding XML defines an API endpoint path with a value of `/V1/products`,
    available via the **HTTP GET** method. It further defines a resource called `anonymous`,
    which means either the currently logged-in customer or guest user can call this
    API endpoint.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 XML 定义了一个 API 端点路径，其值为 `/V1/products`，可以通过 **HTTP GET** 方法访问。它进一步定义了一个名为
    `anonymous` 的资源，这意味着当前登录的客户或访客用户可以调用此 API 端点。
- en: '`anonymous` is a special permission that doesn''t need to be defined in `acl.xml`.
    As such, it will not show up in the permissions tree under Magento admin. This
    simply means that the current resource in `webapi.xml` can be accessed without
    the need for authentication.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`anonymous` 是一种特殊权限，在 `acl.xml` 中不需要定义。因此，它不会在 Magento 管理员下的权限树中显示。这仅仅意味着当前在
    `webapi.xml` 中的资源可以无需认证即可访问。'
- en: 'Finally, we take a look at the `self` resource, whose example we can find under
    the (truncated) `vendor/magento/module-customer/etc/webapi.xml` file as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来看看 `self` 资源，其示例可以在（截断的）`vendor/magento/module-customer/etc/webapi.xml`
    文件中找到如下：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`self` is a special kind of access that enables a user to access resources
    they own, assuming we already have an authenticated session with the system. For
    example, `GET /V1/customers/me` fetches the logged-in customer''s details. This
    is something that is typically useful for JavaScript-based components/widgets.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`self`是一种特殊的访问方式，允许用户访问他们拥有的资源，前提是我们已经与系统建立了认证会话。例如，`GET /V1/customers/me`获取已登录客户的详细信息。这对于基于JavaScript的组件/小部件通常很有用。'
- en: Authentication methods
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证方法
- en: Mobile applications, third-party applications, and JavaScript components/widgets
    (storefront or admin) are the three main types of clients as seen by Magento.
    Though a client is basically everything communicating with our APIs, each type
    of client has a preferred authentication method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Magento的视角，移动应用、第三方应用和JavaScript组件/小部件（店面或管理员）是三种主要的客户端类型。尽管客户端基本上是与我们的API进行通信的一切，但每种类型的客户端都有一个首选的认证方法。
- en: 'Magento supports three types of authentication methods, listed as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Magento支持三种类型的认证方法，如下列出：
- en: Token-based authentication
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于令牌的认证
- en: OAuth-based authentication
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于OAuth的认证
- en: Session-based authentication
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于会话的认证
- en: '**Token-based authentication** is most suitable for mobile applications, where
    a token acts like an electronic key providing access to the Web API''s. The general
    concept behind a token-based authentication system is relatively simple. The user
    provides a username and password during initial authentication in order to obtain
    a time-limited token from the system. If a token is successfully obtained, all
    subsequent API calls are then made with that token.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于令牌的认证**最适合移动应用，其中令牌就像一个电子钥匙，提供对Web API的访问。基于令牌的认证系统背后的概念相对简单。用户在初始认证期间提供用户名和密码，以便从系统中获取一个时间有限的令牌。如果成功获取令牌，所有后续的API调用都使用该令牌进行。'
- en: '**OAuth-based authentication** is suitable for third-party applications that
    integrate with Magento. Once an application is authorized through the **OAuth
    1.0a handshake process**, it gains access to Magento Web APIs. There are three
    key terminologies we must understand here: *user* (resource owner), *client* (consumer),
    and *server* (service provider). The user or resource owner is the one who is
    being asked to allow access to its protected resource. Imagine a customer as a
    user (resource owner) allowing access to its orders to some third-party applications.
    In such a case, this third-party application would be the client (consumer), whereas
    Magento and its Web API would be the server (service provider).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于OAuth的认证**适用于与Magento集成的第三方应用。一旦应用通过**OAuth 1.0a握手过程**获得授权，它就能访问Magento
    Web API。在此我们必须了解三个关键术语：*用户*（资源所有者）、*客户端*（消费者）和*服务器*（服务提供商）。用户或资源所有者是请求允许访问其受保护资源的人。想象一下，一个客户作为用户（资源所有者）允许第三方应用访问其订单。在这种情况下，这个第三方应用就是客户端（消费者），而Magento及其Web
    API则是服务器（服务提供商）。'
- en: '**Session-based authentication** is probably the simplest one to grasp. As
    a customer, you log in to the Magento storefront with your customer credentials.
    As an admin, you log in to the Magento admin with your admin credentials. The
    Magento Web API framework uses your logged-in session information to verify your
    identity and authorize access to the requested resource.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于会话的认证**可能是最容易理解的一种。作为客户，您使用客户凭证登录到Magento店面。作为管理员，您使用管理员凭证登录到Magento管理员界面。Magento
    Web API框架使用您的登录会话信息来验证您的身份并授权访问请求的资源。'
- en: REST versus SOAP
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST与SOAP的比较
- en: Magento supports both **SOAP** (short for **Simple Object Access Protocol**)
    and **REST** (short for **Representational State Transfer**) types of communication
    with the Web API. Authentication methods themselves are not really bound to any
    of them. We can use the same authentication method and Web API method calls with
    both SOAP and REST.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Magento支持Web API的两种通信类型：**SOAP**（即**简单对象访问协议**）和**REST**（即**表征状态转移**）。认证方法本身并不绑定于任何一种。我们可以使用相同的认证方法和Web
    API方法调用，无论是SOAP还是REST。
- en: 'Some of the REST specifics we might outline as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能如下概述一些REST的特定内容：
- en: We run REST Web API calls through cURL commands or a REST client.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过cURL命令或REST客户端运行REST Web API调用。
- en: 'Requests support `HTTP` verbs: `GET`, `POST`, `PUT`, or `DELETE`.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求支持`HTTP`动词：`GET`、`POST`、`PUT`或`DELETE`。
- en: 'A `HTTP` header requires an authorization parameter, specifying the authentication
    token with the **Bearer HTTP authorization scheme**, `Authorization: Bearer <TOKEN>`.
    `<TOKEN>` is the authentication token returned by the Magento token service.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一个 `HTTP` 标头需要一个授权参数，指定使用 **Bearer HTTP 授权方案** 的认证令牌，`Authorization: Bearer
    <TOKEN>`。`<TOKEN>` 是 Magento 令牌服务返回的认证令牌。'
- en: 'We can use the `HTTP` header `Accept: application/<FORMAT>`, where `<FORMAT>`
    is either JSON or XML.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们可以使用 `HTTP` 标头 `Accept: application/<FORMAT>`，其中 `<FORMAT>` 是 JSON 或 XML
    之一。'
- en: 'Some of the SOAP specifics we might outline as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能如下概述一些 SOAP 特性：
- en: We run SOAP Web API calls through cURL commands or a SOAP client.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过 cURL 命令或 SOAP 客户端运行 SOAP Web API 调用。
- en: A **Web Service D****efinition Language** (**WSDL**) file is generated only
    for services that we request. There is no one big merged WSDL file for all services.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有为我们请求的服务才会生成 **Web 服务定义语言**（**WSDL**）文件。没有为所有服务合并的一个大 WSDL 文件。
- en: The Magento Web API uses WSDL 1.2, compliant with WS-I 2.0 Basic Profile.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Magento Web API 使用 WSDL 1.2，符合 WS-I 2.0 基本配置文件。
- en: Each Magento service interface that is part of a service contract is represented
    as a separate service in the WSDL.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个作为服务合同一部分的 Magento 服务接口在 WSDL 中都表示为一个独立的服务。
- en: Consuming several services implies specifying them in the WSDL endpoint URL
    in a comma-separated manner, for example `http://<magento.host>/soap/<optional_store_code>?wsdl&services=<service_name_1>,<service_name_2>`.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费多个服务意味着在 WSDL 端点 URL 中以逗号分隔的方式指定它们，例如 `http://<magento.host>/soap/<optional_store_code>?wsdl&services=<service_name_1>,<service_name_2>`。
- en: We can get a list of all available services by hitting a URL like `http://<SHOP-URL>/soap/default?wsdl_list`
    in the browser.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过在浏览器中访问类似 `http://<SHOP-URL>/soap/default?wsdl_list` 的 URL 来获取所有可用服务的列表。
- en: The following REST and SOAP examples will make extensive use of cURL, which
    is essentially a program that allows you to make HTTP requests from the command
    line or different language implementations (like PHP). We can further describe
    cURL as the console browser, or our *view source* tool for the web. Anything we
    can do with various fancy REST and SOAP libraries, we can do with cURL as well;
    it is just considered to be a more low-level approach.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 REST 和 SOAP 示例将广泛使用 cURL，它本质上是一个允许您从命令行或不同语言实现（如 PHP）中发出 HTTP 请求的程序。我们可以进一步将
    cURL 描述为控制台浏览器，或我们的网络 *view source* 工具。我们可以用各种花哨的 REST 和 SOAP 库做的任何事情，我们也可以用 cURL
    做到；它只是被认为是一个更底层的做法。
- en: Doing SOAP requests with cURL or anything else that does not have WSDL/XML parsing
    implemented internally is cumbersome. Thus, using PHP SoapClient or something
    more robust is a must. **SoapClient** is an integrated, actively maintained part
    of PHP, and is thus generally available.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 cURL 或其他没有内部实现 WSDL/XML 解析的任何东西进行 SOAP 请求是繁琐的。因此，使用 PHP SoapClient 或更健壮的工具是必须的。**SoapClient**
    是 PHP 的一个集成、积极维护的部分，因此通常是可用的。
- en: With negative points being pointed, we will still present all of our API calls
    with console cURL, PHP cURL, and PHP SoapClient examples. Given that libraries
    abstract so much functionality, it is absolutely essential that a developer has
    a solid understanding of cURL, even for making SOAP calls.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有负分，我们仍将使用控制台 cURL、PHP cURL 和 PHP SoapClient 示例来展示所有我们的 API 调用。鉴于库抽象了如此多的功能，开发人员对
    cURL 有一个坚实的理解是绝对必要的，即使是为了进行 SOAP 调用。
- en: Hands-on with token-based authentication
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于令牌的认证实践
- en: 'The crux of token-based authentication is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 基于令牌的认证的核心如下：
- en: Client requests access with a username and password
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端使用用户名和密码请求访问
- en: Application validates credentials
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序验证凭证
- en: Application provides a signed token to the client
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序向客户端提供一个签名令牌
- en: 'The following code example demonstrates the console cURL REST-like request
    for the customer user:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了针对客户用户的控制台 cURL REST 请求：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following code example demonstrates the PHP cURL REST-like request for
    the customer user:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了针对客户用户的 PHP cURL REST 请求：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following code example demonstrates the console cURL SOAP-like request
    for the customer user:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了针对客户用户的控制台 cURL SOAP 请求：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice the `-d @request.xml` part. Here, we are saying to the `curl` command
    to take the content of the `request.xml` file and pass it on as `POST` body data
    where the content of the `request.xml` file for the preceding `curl` command is
    defined as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `-d @request.xml` 部分。在这里，我们告诉 `curl` 命令取 `request.xml` 文件的内容，并将其作为 `POST`
    主体数据传递，其中 `request.xml` 文件的内容由前面的 `curl` 命令定义如下：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code example demonstrates the PHP cURL SOAP-like request for
    the customer user:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了针对客户用户的PHP cURL SOAP-like请求：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following code example demonstrates the usage of PHP SoapClient to make
    a Web API call:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了使用PHP SoapClient进行Web API调用的用法：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The API call for admin user authentication is nearly identical, and depends
    on which one of three approaches we take. The difference is merely in using `https://magento2.ce/rest/V1/integration/admin/token`
    as the endpoint URL in the case of REST, and using `http://magento2.ce/index.php/soap/default?services=integrationCustomerTokenServiceV1`.
    Additionally, for a SOAP call, we are calling `integrationAdminTokenServiceV1CreateAdminAccessToken`
    on the `$request` object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员用户认证的API调用几乎相同，并且取决于我们采取的三种方法中的哪一种。区别仅在于在REST的情况下，使用`https://magento2.ce/rest/V1/integration/admin/token`作为端点URL，以及在使用`http://magento2.ce/index.php/soap/default?services=integrationCustomerTokenServiceV1`的情况下。此外，对于SOAP调用，我们在`$request`对象上调用`integrationAdminTokenServiceV1CreateAdminAccessToken`。
- en: In the case of successful authentication, for both the customer and admin API
    call, the response would be a random-looking 32-characters-long string that we
    call token. This token is further saved to the `oauth_token` table in the database,
    under the token column.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在认证成功的情况下，无论是客户还是管理员API调用，响应都会是一个看起来随机的32个字符长字符串，我们称之为令牌。此令牌随后被保存在数据库中的`oauth_token`表中的令牌列下。
- en: This might be a bit confusing with regard to what the `oauth_token` table has
    to do with token authentication.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能对`oauth_token`表与令牌认证有什么关系有些困惑。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we think about it, token-based authentication can be looked at as a simplified
    version of OAuth, where the user would authenticate using a username and password
    and then give the obtained time-expiring token to some third-party application
    to use it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细思考，基于令牌的认证可以看作是OAuth的简化版本，其中用户会使用用户名和密码进行认证，然后将获得的时效性令牌提供给第三方应用程序使用。
- en: 'In the case of failed authentication, the server returns **HTTP 401 Unauthorized**,
    with a body containing a JSON message:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在认证失败的情况下，服务器会返回**HTTP 401 未授权**，其体包含一个JSON消息：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice how we are able to call the API method, though we are not already authenticated?
    This means we must be calling an API defined by the anonymous type of resource.
    A quick look at the API endpoint gives us a hint as to the location of its definition.
    Looking under the `vendor/magento/module-integration/etc/webapi.xml` file, we
    can see the following (truncated) XML:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何能够调用API方法，尽管我们尚未进行认证？这意味着我们必须调用由匿名资源类型定义的API。快速查看API端点可以给我们一些关于其定义位置的提示。在`vendor/magento/module-integration/etc/webapi.xml`文件下查看，我们可以看到以下（截断的）XML：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can clearly see how even token-based authentication itself is defined as
    API, using the anonymous resource so that everyone can access it. In a nutshell,
    token-based authentication is a feature of the `Magento\Integration` module.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到，即使是基于令牌的认证本身也被定义为API，使用匿名资源以便每个人都可以访问它。简而言之，基于令牌的认证是`Magento\Integration`模块的一个特性。
- en: Now that we have our authentication token, we can start making other API calls.
    Remember, token simply means we have been authenticated against a given username
    and password. It does not mean we get full access to all Web API methods. This
    further depends on whether our customer or user has the proper access role.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了认证令牌，我们可以开始进行其他API调用。记住，令牌仅仅意味着我们已经对给定的用户名和密码进行了认证。它并不意味着我们能够访问所有Web
    API方法。这进一步取决于我们的客户或用户是否有适当的访问角色。
- en: Hands-on with OAuth-based authentication
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于OAuth的认证实践
- en: 'OAuth-based authentication is the most complex, yet most flexible one supported
    by Magento. Before we get to use it, the merchant must register our external application
    as integration with the Magento instance. Placing ourselves in the role of merchant,
    we do so in the Magento admin area under **System** | **Extensions** | **Integrations**.
    Clicking on the **Add New Integration** button opens the screen as shown in the
    following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 基于OAuth的认证是Magento支持的最复杂但最灵活的一种。在我们使用它之前，商家必须将我们的外部应用程序注册为与Magento实例的集成。以商家的身份，我们在**系统**
    | **扩展** | **集成**下的Magento管理区域进行操作。点击**添加新集成**按钮会打开如下截图所示的界面：
- en: '![Hands-on with OAuth-based authentication](img/00062.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![基于OAuth的认证实践](img/00062.jpeg)'
- en: The value `External Book App` is the freely given name of our external application.
    If we were connecting it with Twitter, we could have easily put its name here.
    Next to **Name**, we have the **Email**, **Callback URL**, and **Identity Link
    URL** fields. The value of e-mail is not really that important. The callback URL
    and identity link URL define the external application endpoint that receives OAuth
    credentials. The values of these links point to *external app* that stands as
    the OAuth client. We will come back to it in a moment.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`External Book App`的值是我们外部应用的自由命名。如果我们将其与Twitter连接，我们就可以轻松地将它的名字放在这里。在**名称**旁边，我们有**电子邮件**、**回调URL**和**身份链接URL**字段。电子邮件的值并不是特别重要。回调URL和身份链接URL定义了接收OAuth凭证的外部应用端点。这些链接的值指向作为OAuth客户端的*外部应用*。我们稍后会回到这一点。'
- en: 'In the **API** tab under the **Available APIs** pane, we set **Resource Access**
    to the value of **All** or **Custom**. If set to **Custom**, we can further fine-tune
    the resources in the **Resources** option we want to allow access to this integration
    as shown in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在**可用API**面板下的**API**选项卡中，我们将**资源访问**设置为**全部**或**自定义**。如果设置为**自定义**，我们可以在**资源**选项中进一步微调我们希望允许访问此集成的资源，如下截图所示：
- en: '![Hands-on with OAuth-based authentication](img/00063.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![动手实践OAuth基于的身份验证](img/00063.jpeg)'
- en: We should always give the minimum required resources to the external application
    we are using. This way, we minimize possible security risks. The preceding screenshot
    shows us defining only `Sales`, `Products`, `Customer`, and `Marketing` resources
    to the integration. This means that the API user would not be able to use content
    resources, such as save or delete pages.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终给外部应用我们正在使用的最小必要资源。这样，我们最小化了可能的安全风险。前面的截图显示我们只定义了`Sales`、`Products`、`Customer`和`Marketing`资源到集成中。这意味着API用户将无法使用内容资源，例如保存或删除页面。
- en: 'If we click the **Save** button now, we should be redirected back to the **System**
    | **Extensions** | **Integrations** screen as shown in the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在点击**保存**按钮，我们应该被重定向回**系统** | **扩展** | **集成**屏幕，如下截图所示：
- en: '![Hands-on with OAuth-based authentication](img/00064.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![动手实践OAuth基于的身份验证](img/00064.jpeg)'
- en: There are three things to focus our attention here. First, we are seeing an
    **Integration not secure** message. This is because when we defined our callback
    URL and identity link URL, we used HTTP and not HTTPS protocol. When doing real-world
    connections, for security reasons, we need to be sure to use HTTPS. Further, we
    notice how the **Status** column still says **Inactive**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要关注三件事情。首先，我们看到一个**集成不安全**的消息。这是因为当我们定义回调URL和身份链接URL时，我们使用了HTTP协议而不是HTTPS协议。在现实世界的连接中，出于安全考虑，我们需要确保使用HTTPS。此外，我们注意到**状态**列仍然显示为**不活跃**。
- en: The **Activate** link, to the right of the **Status** column, is the preceding
    step before the two-legged OAuth handshake starts. Only an administrator with
    access to integration listing in the backend can initiate this.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 位于**状态**列右侧的**激活**链接是启动双因素OAuth握手之前的步骤。只有能够访问后端集成列表的管理员才能启动此步骤。
- en: 'At this point, we need to pull the entire PHP code behind the `External Book
    App` OAuth client from here, [https://github.com/ajzele/B05032-BookAppOauthClient](https://github.com/ajzele/B05032-BookAppOauthClient),
    and place it into the root of our Magento installation under the `pub/external-book-app/`
    folder as shown in the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要从以下位置拉取`External Book App` OAuth客户端背后的全部PHP代码，[https://github.com/ajzele/B05032-BookAppOauthClient](https://github.com/ajzele/B05032-BookAppOauthClient)，并将其放置在我们Magento安装根目录下的`pub/external-book-app/`文件夹中，如下截图所示：
- en: '![Hands-on with OAuth-based authentication](img/00065.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![动手实践OAuth基于的身份验证](img/00065.jpeg)'
- en: The function of these files is to simulate our own mini-OAuth client. We will
    not go into much detail about the content of these files, It is more important
    to look at it as an external OAuth client app. The `callback-url.php` and `identity-link-url.php`
    files will execute when Magento triggers the callback and identity link URL's
    as configured under the output image on the previous page.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件的功能是模拟我们自己的迷你OAuth客户端。我们不会深入探讨这些文件的内容，更重要的是将其视为一个外部OAuth客户端应用。当Magento触发回调和配置在上一页输出图像下的身份链接URL时，`callback-url.php`和`identity-link-url.php`文件将会执行。
- en: 'Once the OAuth client files are in place, we go back to our integrations listing.
    Here, we click on the **Activate** link. This opens a modal box, asking us to
    approve access to the API resources as shown in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 OAuth 客户端文件就绪，我们回到我们的集成列表。在这里，我们点击 **激活** 链接。这打开了一个模态框，要求我们批准访问 API 资源，如下面的截图所示：
- en: '![Hands-on with OAuth-based authentication](img/00066.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![动手实践 OAuth 基于的身份验证](img/00066.jpeg)'
- en: 'Notice how API resources listed here match those few we set under the **API**
    tab when creating integration. There are only two actions we can do here really:
    either click **Cancel** or **Allow** to start the two-legged OAuth handshake.
    Clicking the **Allow** button does two things in parallel.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里列出的 API 资源与我们在创建集成时在 **API** 选项卡下设置的那些相匹配。我们在这里实际上只能做两件事：要么点击 **取消**，要么点击
    **允许** 来开始双因素 OAuth 握手。点击 **允许** 按钮并行执行两件事。
- en: 'First, it instantly posts the credentials to the endpoint (callback URL) specified
    when creating the `External Book App` integration. The **HTTP POST** from Magento
    to the callback URL contains parameters with values similar to the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它立即将凭据发送到创建 `外部图书应用` 集成时指定的端点（回调 URL）。从 Magento 到回调 URL 的 **HTTP POST** 包含与以下类似的参数值：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Basically, a HTTP POST request is hitting the `callback-url.php` file whose
    content (partial) is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，一个 HTTP POST 请求正在击中 `callback-url.php` 文件，其内容（部分）如下：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can see that parameters passed by Magento are stored into an external app
    session named `BookAppOAuth`. Later on, within the `check-login.php` file, these
    parameters will be used to instantiate the `BookAppOauthClient`, which will further
    be used to get a request token, which is a pre-authorized token.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，通过 Magento 传递的参数被存储在一个名为 `BookAppOAuth` 的外部应用会话中。稍后，在 `check-login.php`
    文件中，这些参数将被用来实例化 `BookAppOauthClient`，这将进一步被用来获取一个请求令牌，这是一个预先授权的令牌。
- en: 'Parallel to **Callback URL** HTTP POST, we have a popup window opening as shown
    in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与 **回调 URL** HTTP POST 并行，我们打开了一个弹出窗口，如下面的截图所示：
- en: '![Hands-on with OAuth-based authentication](img/00067.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![动手实践 OAuth 基于的身份验证](img/00067.jpeg)'
- en: The login form we see in the popup is just some dummy content we placed under
    the `identity-link-url.php` file. Magento passes two values to this file via HTTP
    GET. These are `consumer_id` and `success_call_back`. The `consumer_id` value
    is the ID of our integration we created in the admin area. It is up to the OAuth
    client app to decide if it wants to do anything with this value or not. The `success_call_back`
    URL points to our Magento `admin integration/loginSuccessCallback` path. If we
    take a look at the code of the `identity-link-url.php` file, we can see the form
    is set to do the `POST` action on the URL like `check-login.php?consumer_id={$consumerId}&callback_url={$callbackUrl}`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在弹出窗口中看到的登录表单只是我们放在 `identity-link-url.php` 文件下的某些虚拟内容。Magento 通过 HTTP GET
    向此文件传递两个值。这些是 `consumer_id` 和 `success_call_back`。`consumer_id` 的值是我们创建在管理区域中的集成
    ID。OAuth 客户端应用决定是否要使用此值。`success_call_back` URL 指向我们的 Magento `admin integration/loginSuccessCallback`
    路径。如果我们查看 `identity-link-url.php` 文件的代码，我们可以看到表单被设置为在 URL 上执行 `POST` 动作，例如 `check-login.php?consumer_id={$consumerId}&callback_url={$callbackUrl}`。
- en: If we now click the **Login** button, the form will `POST` data to the `check-login.php`
    file passing it `consumer_id` and `callback_url` within the URL as `GET` parameters.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在点击 **登录** 按钮，表单将 `POST` 数据到 `check-login.php` 文件，并在 URL 中作为 `GET` 参数传递
    `consumer_id` 和 `callback_url`。
- en: 'The content of `check-login.php` is defined (partially) as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`check-login.php` 的内容（部分）定义如下：'
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To keep thing simple, we have no real user login check here. We might have added
    one above the OAuth-related calls, and then authenticate the user against some
    username and password before allowing it to use OAuth. However, for simplicity
    reasons we omitted this part from our sample OAuth client app.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们在这里没有进行真正的用户登录检查。我们可能在 OAuth 相关调用之上添加了一个，然后在允许使用 OAuth 之前对用户进行用户名和密码的验证。然而，出于简化原因，我们从我们的示例
    OAuth 客户端应用中省略了这部分。
- en: 'Within the `check-login.php` file, we can see that based on the previously
    stored session parameters we perform the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `check-login.php` 文件中，我们可以看到，基于之前存储的会话参数，我们执行以下操作：
- en: Instantiate the `\OAuth\Common\Consumer\Credentials` object passing it the `oauth_consumer_key`,
    `oauth_consumer_secret`, `store_base_url` stored in the session
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过传递存储在会话中的 `oauth_consumer_key`、`oauth_consumer_secret` 和 `store_base_url`
    来实例化 `\OAuth\Common\Consumer\Credentials` 对象
- en: Instantiate the `BookAppOauthClient` object passing its constructor the entire
    credentials object
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化 `BookAppOauthClient` 对象，将其构造函数传递整个凭据对象
- en: Use the `OauthClient` object to get the request token
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `OauthClient` 对象获取请求令牌
- en: Use the request token to get a long-lived access token
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用请求令牌获取长期访问令牌
- en: 'If everything executes successfully, the popup window closes and we get redirected
    back to the integrations listing. The difference now is that looking at the grid,
    we have an **Active** status and next to it we have a **Reauthorize** link, as
    shown in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切执行成功，弹出窗口将关闭，我们将被重定向回集成列表。现在的不同之处在于，查看网格时，我们有一个**活动**状态，旁边有一个**重新授权**链接，如下面的截图所示：
- en: '![Hands-on with OAuth-based authentication](img/00068.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![动手实践 OAuth 基于的身份验证](img/00068.jpeg)'
- en: 'What we are really after at this point are **Access Token** and **Access Token
    Secret**. We can see those if we edit the `External Book App` integration. These
    values should now be present on the **Integration Details** tab as shown in the
    following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正想要在这个阶段的是**访问令牌**和**访问令牌密钥**。如果我们编辑 `External Book App` 集成，我们可以看到这些值。这些值现在应该出现在以下截图所示的**集成详细信息**选项卡上：
- en: '![Hands-on with OAuth-based authentication](img/00069.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![动手实践 OAuth 基于的身份验证](img/00069.jpeg)'
- en: '**Access Token** is the key to all of our further API calls, and with it we
    successfully finish our authentication bit of OAuth-based authentication.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问令牌**是我们所有后续 API 调键的密钥，并且我们成功地完成了基于 OAuth 的身份验证部分。'
- en: OAuth-based Web API calls
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于 OAuth 的 Web API 调用
- en: Once we have obtained OAuth access token, from the preceding steps, we can start
    making Web API calls to other methods. Even though the Web API coverage is the
    same for both REST and SOAP, there is a significant difference when making method
    calls.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了 OAuth 访问令牌，从前面的步骤中，我们可以开始对其他方法进行 Web API 调用。尽管 Web API 覆盖范围对 REST 和
    SOAP 都相同，但在进行方法调用时存在显著差异。
- en: 'For the purpose of giving a more robust example, we will be targeting the customer
    group `save` method, (partially) defined in the `vendor/magento/module-customer/etc/webapi.xml`
    file as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个更健壮的示例，我们将针对客户组 `save` 方法，部分定义在 `vendor/magento/module-customer/etc/webapi.xml`
    文件中，如下所示：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To use the access token to make Web API calls, like `POST /V1/customerGroups`,
    we need to include these request parameters in the authorization request header
    in the call:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用访问令牌进行 Web API 调用，例如 `POST /V1/customerGroups`，我们需要在调用中包含这些请求参数在授权请求头中：
- en: '`oauth_consumer_key`, available from the Magento admin area, under the integration
    edit screen.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oauth_consumer_key`，从 Magento 管理区域获取，在集成编辑屏幕下。'
- en: '`oauth_nonce`, random value, uniquely generated by the application for each
    request.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oauth_nonce`，随机值，应用程序为每个请求唯一生成。'
- en: '`oauth_signature_method`, name of the signature method used to sign the request.
    Valid values are: `HMAC-SHA1`, `RSA-SHA1`, and `PLAINTEXT`.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oauth_signature_method`，用于签名请求的签名方法名称。有效值有：`HMAC-SHA1`、`RSA-SHA1` 和 `PLAINTEXT`。'
- en: Even though the Outh protocol supports `PLAINTEXT`, Magento does not. We will
    be using `HMAC-SHA1`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管OAuth协议支持`PLAINTEXT`，但Magento不支持。我们将使用`HMAC-SHA1`。
- en: '`oauth_timestamp`, integer value, Unix-like timestamp.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oauth_timestamp`，整数值，Unix-like 时间戳。'
- en: '`oauth_token`, available from the Magento admin area, under the integration
    edit screen.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oauth_token`，从 Magento 管理区域获取，在集成编辑屏幕下。'
- en: '`oauth_version`, Magento supports Oauth 1.0a, thus we use `1.0`.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oauth_version`，Magento 支持 Oauth 1.0a，因此我们使用 `1.0`。'
- en: '`oauth_signature`, generated signature value, omitted from the signature generation
    process.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oauth_signature`，生成的签名值，在签名生成过程中省略。'
- en: To generate an OAuth 1.0a HMAC-SHA1 signature for a HTTP request takes focused
    effort, if done manually.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 HTTP 请求生成 OAuth 1.0a HMAC-SHA1 签名需要集中精力，如果手动完成。
- en: We need to determine the HTTP method and URL of the request, which equals to
    `POST http://magento2-merchant.loc/rest/V1/customerGroups`. It is important to
    use the correct protocol here, so make sure that the `https://` or `http://` portion
    of the URL matches the actual request sent to the API.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确定请求的 HTTP 方法和 URL，它等于 `POST http://magento2-merchant.loc/rest/V1/customerGroups`。在这里使用正确的协议非常重要，所以请确保
    URL 的 `https://` 或 `http://` 部分与实际发送到 API 的请求相匹配。
- en: 'We then gather all of the parameters included in the request. There are two
    such locations for these additional parameters: the URL (as part of the query
    string) and the request body.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后收集请求中包含的所有参数。这些附加参数有两个位置：URL（作为查询字符串的一部分）和请求体。
- en: In the HTTP request, the parameters are URL encoded, but we need to collect
    the raw values. In addition to the request parameters, every `oauth_*` parameter
    needs to be included in the signature, except the `oauth_signature` itself.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 请求中，参数被 URL 编码，但我们需要收集原始值。除了请求参数外，每个 `oauth_*` 参数都需要包含在签名中，除了 `oauth_signature`
    本身之外。
- en: 'The parameters are normalized into a single string as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 参数按照以下方式归一化为单个字符串：
- en: Parameters are sorted by name, using lexicographical byte value ordering. If
    two or more parameters share the same name, they are sorted by their value.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数按名称排序，使用字典序字节值排序。如果两个或多个参数具有相同的名称，则按其值排序。
- en: Parameters are concatenated in their sorted order into a single string. For
    each parameter, the name is separated from the corresponding value by an `=` character
    (ASCII code 61), even if the value is empty. Each name-value pair is separated
    by an `&` character (ASCII code 38).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数按排序顺序连接成一个字符串。对于每个参数，名称与相应的值由一个 `=` 字符（ASCII 码 61）分隔，即使值是空的。每个名称-值对由一个 `&`
    字符（ASCII 码 38）分隔。
- en: Further, we define the signing key as a value of `{Consumer Key}+{&}+{Access
    Token Secret}`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将签名密钥定义为 `{消费者密钥}+{&}+{访问令牌密钥}` 的值。
- en: Once we apply the string normalization rules to parameters and determine the
    signing key, we call `hash_hmac('sha1', $data, {Signing Key}, true)` to get the
    final `oauth_signature` value.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将字符串归一化规则应用于参数并确定签名密钥，我们就调用 `hash_hmac('sha1', $data, {签名密钥}, true)` 来获取最终的
    `oauth_signature` 值。
- en: This should get us the `oauth_signature` as a random 28-characters-long string,
    similar to this one – `Pi/mGfA0SOlIxO9W30sEch6bjGE=`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会得到一个随机的 28 个字符长的字符串作为 `oauth_signature`，类似于这个 – `Pi/mGfA0SOlIxO9W30sEch6bjGE=`。
- en: 'Understanding how to generate the signature string is important, but getting
    it right every time is tedious and time consuming. We can help ourselves by instantiating
    the objects of the built-in `\OAuth\Common\Consumer\Credentials` and `\OAuth\OAuth1\Signature\Signature`
    classes, like (partially) shown as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何生成签名字符串很重要，但每次都正确地获取它既繁琐又耗时。我们可以通过实例化内置的 `\OAuth\Common\Consumer\Credentials`
    和 `\OAuth\OAuth1\Signature\Signature` 类的对象来帮助自己，如下（部分）所示：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that we have the `oauth_signature` value, we are ready to do our console
    `curl` REST example. It comes down to running the following on a console:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `oauth_signature` 值，我们就准备好在我们的控制台 `curl` REST 示例中操作了。这归结为在控制台上运行以下命令：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the preceding command is merely visually broken into new lines. It
    should all be single line on a console. Once executed, the API call will create
    a new customer group called `The Book Writer`. A logical question one might ask
    looking at the `curl` command is how come we did not normalize the POST data passed
    as JSON via the `–d` flag switch. This is because parameters in the HTTP POST
    request body are only taken into consideration for signature generation if content-type
    is `application/x-www-form-urlencoded`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的命令只是从视觉上换行。它应该在控制台上是一行。一旦执行，API 调用将创建一个新的客户组，名为 `The Book Writer`。观察 `curl`
    命令时，可能会有人问，为什么我们没有对通过 `-d` 标志开关传递的 JSON POST 数据进行归一化。这是因为如果内容类型为 `application/x-www-form-urlencoded`，则只有
    HTTP POST 请求体中的参数才被考虑用于签名生成。
- en: 'The console cURL SOAP requests do not require usage of the OAuth signature.
    We can execute a SOAP request passing `Authorization: Bearer { Access Token value
    }` into the request header, like shown in the following example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '控制台 cURL SOAP 请求不需要使用 OAuth 签名。我们可以通过将 `Authorization: Bearer {访问令牌值}` 传递到请求头中执行
    SOAP 请求，如下所示：'
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Where `request.xml` contains content as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `request.xml` 包含以下内容：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following code example demonstrates the PHP cURL SOAP-like request for
    the customer group `save` method call:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了针对客户组 `save` 方法调用的 PHP cURL SOAP 类似请求：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how the method name `customerGroupRepositoryV1Save` actually comprises
    service name `customerGroupRepositoryV1`, plus the `Save` name of the actual method
    within the service.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意方法名 `customerGroupRepositoryV1Save` 实际上由服务名 `customerGroupRepositoryV1` 和服务内部实际方法的
    `Save` 名称组成。
- en: We can get a list of all services defined by opening a URL like `http://magento2.ce/soap/default?wsdl_list`
    in the browser (depending on our Magento installation).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在浏览器中打开类似 `http://magento2.ce/soap/default?wsdl_list` 的 URL 来获取所有定义的服务列表（取决于我们的
    Magento 安装）。
- en: Hands-on with session-based authentication
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于会话认证的实践操作
- en: Session-based authentication is the third and most simple type of authentication
    in Magento. We do not have any complexities of token-passing here. As the customer,
    we log in to the Magento storefront with our customer credentials. As an admin,
    we log in to the Magento admin with our admin credentials. Magento uses a cookie
    named `PHPSESSID` to track the session where our login state is stored. The Web
    API framework uses our logged-in session information to verify our identity and
    authorize access to the requested resource.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 基于会话的认证是Magento中第三种也是最简单的一种认证方式。在这里我们没有token传递的复杂性。作为客户，我们使用客户凭证登录到Magento店面。作为管理员，我们使用管理员凭证登录到Magento后台。Magento使用名为`PHPSESSID`的cookie来跟踪存储我们的登录状态的会话。Web
    API框架使用我们登录的会话信息来验证我们的身份并授权访问请求的资源。
- en: Customers can access resources that are configured with anonymous or self-permission
    in the `webapi.xml` configuration file, like `GET /rest/V1/customers/me`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 客户可以访问在`webapi.xml`配置文件中配置了匿名或自授权的资源，如`GET /rest/V1/customers/me`。
- en: 'If we try to open the `http://magento2.ce/rest/V1/customers/me` URL while in
    the browser, but not logged in as the customer, we would get a response as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中尝试打开`http://magento2.ce/rest/V1/customers/me` URL，但没有以客户身份登录，我们会得到以下响应：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we log in as the customer and then try to open that same URL, we would get
    a response as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以客户身份登录然后尝试打开相同的URL，我们会得到以下响应：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Admin users can access resources that are assigned to their Magento admin profile.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员用户可以访问分配给他们的Magento管理员配置文件的资源。
- en: Creating custom Web APIs
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义Web API
- en: Magento comes with a solid number of API methods that we can call. However,
    sometimes this is not enough, as our business needs dictate additional logic,
    and we need to be able to add our own methods to the Web API.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Magento附带了一系列我们可以调用的API方法。然而，有时这还不够，因为我们的业务需求需要额外的逻辑，我们需要能够向Web API添加我们自己的方法。
- en: The best part of creating our own API's is that we do not have to be concerned
    about making them REST or SOAP. Magento abstracts this so that our API methods
    are automatically available for REST and for SOAP calls.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们自己的API的最佳部分是，我们不必担心它们是REST还是SOAP。Magento抽象化这一点，使得我们的API方法自动对REST和SOAP调用可用。
- en: 'Adding new API''s conceptually evolves around two things: defining business
    logic through various classes, and exposing it via the `webapi.xml` file. However,
    as we will soon see, there is a lot of **boilerplate** to it.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在概念上，添加新的API涉及到两个方面：通过各种类定义业务逻辑，并通过`webapi.xml`文件公开它。然而，正如我们很快就会看到的，这有很多**样板代码**。
- en: Let's create a miniature module called `Foggyline_Slider`, on which we will
    demonstrate `create (POST)`, `update (PUT)`, `delete (DELETE)`, and `list (GET)`
    method calls.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`Foggyline_Slider`的微型模块，我们将演示`创建（POST）`、`更新（PUT）`、`删除（DELETE）`和`列表（GET）`方法调用。
- en: 'Create a module registration file, `app/code/Foggyline/Slider/registration.php`,
    with content (partial) as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个模块注册文件，`app/code/Foggyline/Slider/registration.php`，内容（部分）如下：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a module configuration file, `app/code/Foggyline/Slider/etc/module.xml`,
    with content as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个模块配置文件，`app/code/Foggyline/Slider/etc/module.xml`，内容如下：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create an install script where our future models will persist module data.
    We do so by creating the `app/code/Foggyline/Slider/Setup/InstallSchema.php` file
    with content (partial) as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个安装脚本，我们的未来模型将持久化模块数据。我们通过创建`app/code/Foggyline/Slider/Setup/InstallSchema.php`文件来实现，内容（部分）如下：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we specify the ACL for our resources. Our resources are going to be CRUD
    actions we do on our module entities. We will structure our module in a way that
    `slide` and `image` are separate entities, where one slide can have multiple image
    entities linked to it. Thus, we would like to be able to control access to save
    and delete actions separately for each entity. We do so by defining the `app/code/Foggyline/Slider/etc/acl.xml`
    file as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们指定我们资源的ACL。我们的资源是我们对我们模块实体执行的CRUD操作。我们将以`slide`和`image`作为独立实体来结构化我们的模块，其中一张幻灯片可以与多个图像实体相关联。因此，我们希望能够分别控制每个实体的保存和删除操作的访问权限。我们通过定义`app/code/Foggyline/Slider/etc/acl.xml`文件如下来实现：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that the ACL has been set, we define our Web API resources within the `app/code/Foggyline/Slider/etc/webapi.xml`
    file (partial) as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在ACL已经设置好了，我们在`app/code/Foggyline/Slider/etc/webapi.xml`文件（部分）中定义我们的Web API资源，如下所示：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice how each of those service class attributes point to the interface, not
    the class. This is the way we should build our exposable services, always having
    an interface definition behind them. As we will soon see, using `di.xml`, this
    does not mean Magento will try to create objects from these interfaces directly.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到每个服务类属性都指向接口，而不是类。这是我们构建可公开服务的方式，总是有一个接口定义在它们后面。正如我们很快就会看到的，使用`di.xml`，这并不意味着Magento会直接从这些接口创建对象。
- en: 'We now create the `app/code/Foggyline/Slider/etc/di.xml` file with content
    (partial) as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建`app/code/Foggyline/Slider/etc/di.xml`文件，内容（部分）如下：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What is happening here is that we are telling Magento something like, "hey,
    whenever you need to pass around an instance that conforms to the `Foggyline\Slider\Api\Data\SlideInterface`
    interface, preferably use the `Foggyline\Slider\Model\Slide` class for it."
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是我们告诉Magento类似于，“嘿，每当你需要传递一个符合`Foggyline\Slider\Api\Data\SlideInterface`接口的实例时，最好使用`Foggyline\Slider\Model\Slide`类。”
- en: At this point, we still do not have any of those interfaces or model classes
    actually created. When creating APIs, we should first start by defining interfaces,
    and then our models should extend from those interfaces.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有实际创建任何这些接口或模型类。在创建API时，我们应该首先从定义接口开始，然后我们的模型应该从这些接口扩展。
- en: 'Interface `Foggyline\Slider\Api\Data\SlideInterface` is defined within the
    `app/code/Foggyline/Slider/Api/Data/SlideInterface.php` file (partial) as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接口`Foggyline\Slider\Api\Data\SlideInterface`定义在`app/code/Foggyline/Slider/Api/Data/SlideInterface.php`文件中（部分）如下：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are going for ultimate simplification here. Our `Slide` entity only really
    has ID and title values. The `id` and `slide_id` point to the same field in the
    database and the implementation of their getters and setters should yield the
    same results.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在追求极致的简化。我们的`Slide`实体实际上只有ID和标题值。`id`和`slide_id`指向数据库中的同一字段，它们的getter和setter的实现应该产生相同的结果。
- en: Although `API/Data/*.php` interfaces become blueprint requirements for our data
    models, we also have `Api/*RepositoryInterface.php` files. The idea here is to
    extract create, update, delete, search, and similar data-handling logic away from
    the data model class into its own class. This way, our model classes become more
    pure data and business logic classes while the rest of persistence and search-related
    logic moves into these repository classes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`API/Data/*.php`接口成为我们的数据模型的设计蓝图要求，但我们也有`Api/*RepositoryInterface.php`文件。这里的想法是将创建、更新、删除、搜索和类似的数据处理逻辑从数据模型类提取出来，放入它自己的类中。这样，我们的模型类就变成了更纯粹的数据和业务逻辑类，而其余的持久化和搜索相关逻辑则移动到这些存储库类中。
- en: 'Our **Slide** **Repository Interface** is defined within the `app/code/Foggyline/Slider/Api/SlideRepositoryInterface.php`
    file as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的**幻灯片存储接口**定义在`app/code/Foggyline/Slider/Api/SlideRepositoryInterface.php`文件中，如下所示：
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With interfaces in place, we can move on to model class. In order to persist
    and fetch data in a database, our `Slide` entity really needs three files under
    the `Model` directory. These are called data *model*, *resource class*, and *collection
    class*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口就位后，我们可以继续到模型类。为了在数据库中持久化和获取数据，我们的`Slide`实体在`Model`目录下确实需要三个文件。这些被称为数据*模型*、*资源类*和*集合类*。
- en: 'The data model class is defined under the `app/code/Foggyline/Slider/Model/Slide.php`
    file (partial) as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模型类定义在`app/code/Foggyline/Slider/Model/Slide.php`文件中（部分）如下：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Following the model data class is the model resource class, defined in the
    `app/code/Foggyline/Slider/Model/ResourceModel/Slide.php` file (partial) as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接着是模型资源类，定义在`app/code/Foggyline/Slider/Model/ResourceModel/Slide.php`文件中（部分）如下：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, the third bit is the model collection class, defined in the `app/code/Foggyline/Slider/Model/ResourceModel/Slide/Collection.php`
    file as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第三部分是模型集合类，定义在`app/code/Foggyline/Slider/Model/ResourceModel/Slide/Collection.php`文件中，如下所示：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If we were to manually instantiate the model data class now, we would be able
    to persist the data in the database. To complete the `di.xml` requirements, we
    still lack one more final ingredient – the `Model/SlideRepository` class file.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在手动实例化模型数据类，我们就能在数据库中持久化数据。为了完成`di.xml`的要求，我们仍然缺少一个最后的成分——`Model/SlideRepository`类文件。
- en: 'Let us go and create the `app/code/Foggyline/Slider/Model/SlideRepository.php`
    file with content (partial) as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`app/code/Foggyline/Slider/Model/SlideRepository.php`文件，内容（部分）如下：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It might appear that there is a lot going on here, but really we are just passing
    on some class and interface names to the constructor in order to instantiate the
    objects we will use across individual service methods defined in the `webapi.xml`
    file.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来这里有很多事情要做，但实际上我们只是在构造函数中传递一些类和接口名称，以便实例化我们将用于 `webapi.xml` 文件中定义的各个服务方法的对象。
- en: 'The first service method on our list is `getById`, defined within `SlideRepository.php`
    as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表中的第一个服务方法是 `getById`，在 `SlideRepository.php` 中定义如下：
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then we have the save method, defined within `SlideRepository.php` as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有 `save` 方法，在 `SlideRepository.php` 中定义如下：
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `save` method addresses both `POST` and `PUT` requests defined in `webapi.xml`,
    thus effectively handling the creation of new slides or an update of existing
    ones.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`save` 方法处理了 `webapi.xml` 中定义的 `POST` 和 `PUT` 请求，因此有效地处理了新幻灯片的创建或现有幻灯片的更新。'
- en: 'Going further, we have the `getList` method, defined within `SlideRepository.php`
    as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，我们有 `getList` 方法，在 `SlideRepository.php` 中定义如下：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we have the `deleteById` method, defined within `SlideRepository.php`
    as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `deleteById` 方法，在 `SlideRepository.php` 中定义如下：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Keep in mind that we only covered the `Slide` entity in the preceding partial
    code examples, which is enough to progress further with API call examples.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们只在前面的部分代码示例中涵盖了 `Slide` 实体，这对于进一步进行 API 调用示例已经足够。
- en: API call examples
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 调用示例
- en: Since all of our defined API's are resource protected, we first need to authenticate
    as the admin user, assuming the admin user has access to all our custom resources
    that encompass the ones we defined. For simplicity sake, we will use the token-based
    authentication method, examples of which are given previously in this chapter.
    Once authenticated, we should have a 32 random characters long token like `pk8h93nq9cevaw55bohkjbp0o7kpl4d3`,
    for example.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们定义的所有 API 都受资源保护，我们首先需要以管理员用户身份进行身份验证，假设管理员用户可以访问我们定义的所有自定义资源，包括我们定义的资源。为了简化，我们将使用基于令牌的认证方法，例如，本章前面给出的示例。一旦认证成功，我们应该有一个32个随机字符长的令牌，例如
    `pk8h93nq9cevaw55bohkjbp0o7kpl4d3`。
- en: 'Once the token key has been obtained, we will test the following API calls
    using console cURL, PHP cURL, PHP SoapClient, and console SOAP style cURL examples:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取了令牌密钥，我们将使用控制台 cURL、PHP cURL、PHP SoapClient 以及控制台 SOAP 风格 cURL 示例来测试以下 API
    调用：
- en: '`GET /V1/foggylineSliderSlide/:slideId`, calls the `getById` service method,
    requires the `Foggyline_Slider::slide` resource'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /V1/foggylineSliderSlide/:slideId`, 调用 `getById` 服务方法，需要 `Foggyline_Slider::slide`
    资源'
- en: '`GET /V1/foggylineSliderSlide/search`, calls the `getList` service method,
    requires the `Foggyline_Slider::slide` resource'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /V1/foggylineSliderSlide/search`, 调用 `getList` 服务方法，需要 `Foggyline_Slider::slide`
    资源'
- en: '`POST /V1/foggylineSliderSlide`, calls the `save` service method, requires
    the `Foggyline_Slider::slide_save` resource'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /V1/foggylineSliderSlide`, 调用 `save` 服务方法，需要 `Foggyline_Slider::slide_save`
    资源'
- en: '`PUT /V1/foggylineSliderSlide/:id`, calls the `save` service method, requires
    the `Foggyline_Slider::slide_save` resource'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT /V1/foggylineSliderSlide/:id`, 调用 `save` 服务方法，需要 `Foggyline_Slider::slide_save`
    资源'
- en: '`DELETE /V1/foggylineSliderSlide/:slideId`, calls the `deleteById` service
    method, requires the `Foggyline_Slider::slide_delete` resource'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE /V1/foggylineSliderSlide/:slideId`, 调用 `deleteById` 服务方法，需要 `Foggyline_Slider::slide_delete`
    资源'
- en: The getById service method call examples
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`getById` 服务方法调用示例'
- en: 'The console cURL style for executing `GET /V1/foggylineSliderSlide/:slideId`
    is done as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `GET /V1/foggylineSliderSlide/:slideId` 的控制台 cURL 风格如下：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The PHP cURL style for executing `GET /V1/foggylineSliderSlide/:slideId` is
    done as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `GET /V1/foggylineSliderSlide/:slideId` 的 PHP cURL 风格如下：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The response for console and PHP cURL style should be a JSON string similar
    to the following one:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台和 PHP cURL 风格的响应应该是一个类似于以下 JSON 字符串：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The PHP SoapClient style for executing `GET /V1/foggylineSliderSlide/:slideId`
    is done as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `GET /V1/foggylineSliderSlide/:slideId` 的 PHP SoapClient 风格如下：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The response for PHP SoapClient style should be the `stdClass` PHP object as
    follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: PHP SoapClient 风格的响应应该是如下 `stdClass` PHP 对象：
- en: '[PRE43]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The console SOAP style cURL for executing `GET /V1/foggylineSliderSlide/:slideId`
    is done as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `GET /V1/foggylineSliderSlide/:slideId` 的控制台 SOAP 风格 cURL 如下：
- en: '[PRE44]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Where `request.xml` has content as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `request.xml` 的内容如下：
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice how we did not really do `GET`, rather a `POST` type of request. Also,
    the URL to which we are pointing our `POST` is not really the same as with previous
    requests. This is because Magento SOAP requests are always `POST` (or `PUT`) type,
    as the data is submitted in XML format. XML format in return specifies the service,
    and the request header action specifies the method to be called on the service.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们实际上并没有做 `GET` 操作，而是做了 `POST` 类型的请求。此外，我们指向的 `POST` 请求的 URL 并非与之前的请求相同。这是因为
    Magento SOAP 请求始终是 `POST`（或 `PUT`）类型，因为数据是以 XML 格式提交的。返回的 XML 格式指定了服务，而请求头中的操作指定了要在服务上调用的方法。
- en: 'The response for console SOAP style cURL should be an XML as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台 SOAP 风格 cURL 的响应应该是一个如下所示的 XML：
- en: '[PRE46]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The getList service method call examples
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取列表服务方法调用示例
- en: 'The console cURL style for executing `GET /V1/foggylineSliderSlide/search`
    is done as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `GET /V1/foggylineSliderSlide/search` 的控制台 cURL 风格如下：
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The PHP cURL style for executing `GET /V1/foggylineSliderSlide/search` is done
    as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `GET /V1/foggylineSliderSlide/search` 的 PHP cURL 风格如下：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The response for console and PHP cURL style should be a JSON string similar
    to the following one:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台和 PHP cURL 风格的响应应该是一个类似于以下 JSON 字符串：
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The PHP SoapClient style for executing `GET /V1/foggylineSliderSlide/search`
    is done as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `GET /V1/foggylineSliderSlide/search` 的 PHP SoapClient 风格如下：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The response for PHP SoapClient style should be the `stdClass` PHP object as
    follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: PHP SoapClient 风格的响应应该是如下所示的 `stdClass` PHP 对象：
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The console SOAP style cURL for executing `GET /V1/foggylineSliderSlide/search`
    is done as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `GET /V1/foggylineSliderSlide/search` 的控制台 SOAP 风格 cURL 如下：
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Where `request.xml` has content as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `request.xml` 的内容如下：
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice we did not really do `GET`, rather `POST`. Also, the URL to which we
    are pointing our `POST` is not really the same as with previous requests. This
    is because Magento SOAP requests are always `POST` type, as the data is submitted
    in XML format. XML format in return specifies the service, and the request header
    action specifies the method to be called on the service.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们实际上并没有做 `GET` 操作，而是做了 `POST`。此外，我们指向的 `POST` 请求的 URL 并非与之前的请求相同。这是因为 Magento
    SOAP 请求始终是 `POST` 类型，因为数据是以 XML 格式提交的。返回的 XML 格式指定了服务，而请求头中的操作指定了要在服务上调用的方法。
- en: 'The response for console SOAP style cURL should be an XML as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台 SOAP 风格 cURL 的响应应该是一个如下所示的 XML：
- en: '[PRE54]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The save (as new) service method call examples
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存（作为新文件）服务方法调用示例
- en: 'The console cURL style for executing `POST /V1/foggylineSliderSlide` is done
    as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `POST /V1/foggylineSliderSlide` 的控制台 cURL 风格如下：
- en: '[PRE55]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The PHP cURL style for executing `POST /V1/foggylineSliderSlide` is done as
    follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `POST /V1/foggylineSliderSlide` 的 PHP cURL 风格如下：
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The response for console and PHP cURL style should be a JSON string similar
    to the following one:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台和 PHP cURL 风格的响应应该是一个类似于以下 JSON 字符串：
- en: '[PRE57]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The PHP SoapClient style for executing `POST /V1/foggylineSliderSlide` is done
    as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `POST /V1/foggylineSliderSlide` 的 PHP SoapClient 风格如下：
- en: '[PRE58]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The response for PHP SoapClient style should be the `stdClass` PHP object as
    follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: PHP SoapClient 风格的响应应该是如下所示的 `stdClass` PHP 对象：
- en: '[PRE59]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The console SOAP style cURL for executing `POST /V1/foggylineSliderSlide` is
    done as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `POST /V1/foggylineSliderSlide` 的控制台 SOAP 风格 cURL 如下：
- en: '[PRE60]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Where `request.xml` has content as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `request.xml` 的内容如下：
- en: '[PRE61]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The response for console SOAP style cURL should be an XML as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台 SOAP 风格 cURL 的响应应该是一个如下所示的 XML：
- en: '[PRE62]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The save (as update) service method call examples
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存（作为更新）服务方法调用示例
- en: 'The console cURL style for executing `PUT /V1/foggylineSliderSlide/:id` is
    done as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `PUT /V1/foggylineSliderSlide/:id` 的控制台 cURL 风格如下：
- en: '[PRE63]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The PHP cURL style for executing `PUT /V1/foggylineSliderSlide/:id` is done
    as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `PUT /V1/foggylineSliderSlide/:id` 的 PHP cURL 风格如下：
- en: '[PRE64]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The response for console and PHP cURL style should be a JSON string similar
    to the following one:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台和 PHP cURL 风格的响应应该是一个类似于以下 JSON 字符串：
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The PHP SoapClient style for executing `PUT /V1/foggylineSliderSlide/:id` is
    done as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `PUT /V1/foggylineSliderSlide/:id` 的 PHP SoapClient 风格如下：
- en: '[PRE66]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The response for PHP SoapClient style should be the `stdClass` PHP object as
    follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: PHP SoapClient 风格的响应应该是如下所示的 `stdClass` PHP 对象：
- en: '[PRE67]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The console SOAP style cURL for executing `PUT /V1/foggylineSliderSlide/:id`
    is done as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `PUT /V1/foggylineSliderSlide/:id` 的控制台 SOAP 风格 cURL 如下：
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Where `request.xml` has content as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `request.xml` 的内容如下：
- en: '[PRE69]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The response for console SOAP style cURL should be an XML as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台 SOAP 风格 cURL 的响应应该是一个如下所示的 XML：
- en: '[PRE70]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The deleteById service method call examples
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`deleteById` 服务方法调用示例'
- en: 'The console cURL style for executing `DELETE /V1/foggylineSliderSlide/:slideId`
    is done as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `DELETE /V1/foggylineSliderSlide/:slideId` 的控制台 cURL 风格如下：
- en: '[PRE71]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The PHP cURL style for executing `DELETE /V1/foggylineSliderSlide/:slideId`
    is done as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `DELETE /V1/foggylineSliderSlide/:slideId` 的 PHP cURL 风格如下：
- en: '[PRE72]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The response for console and PHP cURL style should be a JSON string similar
    to the following one:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台和 PHP cURL 风格的响应应该是一个类似于以下 JSON 字符串的字符串：
- en: '[PRE73]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The PHP SoapClient style for executing `DELETE /V1/foggylineSliderSlide/:slideId`
    is done as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `DELETE /V1/foggylineSliderSlide/:slideId` 的 PHP SoapClient 风格如下：
- en: '[PRE74]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The response for PHP SoapClient style should be the `stdClass` PHP object as
    follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: PHP SoapClient 风格的响应应该是类似于以下 `stdClass` PHP 对象：
- en: '[PRE75]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The console SOAP style cURL for executing `DELETE /V1/foggylineSliderSlide/:slideId`
    is done as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `DELETE /V1/foggylineSliderSlide/:slideId` 的控制台 SOAP 风格 cURL 如下：
- en: '[PRE76]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Where `request.xml` has content as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `request.xml` 的内容如下：
- en: '[PRE77]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The response for console SOAP style cURL should be an XML as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台 SOAP 风格 cURL 的响应应该是一个类似于以下 XML 的字符串：
- en: '[PRE78]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The preceding API call examples cover all of our custom-defined APIs for the
    `Slide` entity.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 API 调用示例涵盖了我们对 `Slide` 实体自定义定义的所有 API。
- en: 'Looking back at the `$searchCriteria` variable, we used the `GET` type of HTTP
    method, passing the entire variable as a query string. If we think about it, we
    could have specified `POST` during the Web API resource definition and packed
    the content of the `$searchCriteria` variable into the request body. Although
    the `GET` method approach might look a bit dirtier, imagine if we assigned the
    anonymous or self role to the resource: we would be able to simply open a lengthy
    URL in the browser and have the search results. Think of a possible widget use,
    where a widget would simply do an AJAX request to the URL and fetch the results
    for guests or the customer.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下 `$searchCriteria` 变量，我们使用了 `GET` 类型的 HTTP 方法，将整个变量作为查询字符串传递。如果我们这样考虑，我们可以在
    Web API 资源定义期间指定 `POST`，并将 `$searchCriteria` 变量的内容打包到请求体中。尽管 `GET` 方法的方法可能看起来有点脏，但想象一下如果我们为资源分配了匿名或自角色：我们就可以简单地打开一个长
    URL 并获取搜索结果。考虑一个可能的小部件用途，其中小部件会简单地向 URL 发送 AJAX 请求并获取访客或客户的搜索结果。
- en: 'The full module source code can be found here: [https://github.com/ajzele/B05032-Foggyline_Slider](https://github.com/ajzele/B05032-Foggyline_Slider).
    Aside from the `Slide` entity, the full module code includes the `Image` entity
    as well. Since each slide can contain multiple images, we can further test the
    `Image` API calls analogous to the preceding calls.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的模块源代码可以在以下位置找到：[https://github.com/ajzele/B05032-Foggyline_Slider](https://github.com/ajzele/B05032-Foggyline_Slider)。除了
    `Slide` 实体外，完整的模块代码还包括 `Image` 实体。由于每个幻灯片可以包含多个图片，我们可以进一步测试类似于前面调用的 `Image` API
    调用。
- en: Search Criteria Interface for list filtering
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表过滤的搜索条件接口
- en: Knowing how to do a proper list filtering to fetch the entities that match a
    certain lookup is essential for the effective use of `getList` services across
    core Magento and possibly custom-coded API's. An example is fetching the list
    of customers registered within the last 24 hours for the latest added product.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何进行适当的列表过滤以获取匹配特定查找条件的实体对于有效使用核心 Magento 的 `getList` 服务以及可能的自定义编码 API 是至关重要的。例如，获取过去
    24 小时内注册的客户列表以获取最新添加的产品。
- en: 'Let''s take a look back at our `app/code/Foggyline/Slider/etc/webapi.xml` file,
    the bit where we defined the service `method="getList"`. The service class is
    defined as `Foggyline\Slider\Api\SlideRepositoryInterface`, which is defined as
    a preference for the `Foggyline\Slider\Model\SlideRepository` class. Finally,
    within the `SlideRepository` class, we have the actual `getList`. Method `getList`
    is defined as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 `app/code/Foggyline/Slider/etc/webapi.xml` 文件，其中我们定义了服务 `method="getList"`。服务类定义为
    `Foggyline\Slider\Api\SlideRepositoryInterface`，它被定义为 `Foggyline\Slider\Model\SlideRepository`
    类的偏好。最后，在 `SlideRepository` 类中，我们有实际的 `getList` 方法。`getList` 方法定义如下：
- en: '[PRE79]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We can see that the `getList` method takes only one parameter, object instance,
    that complies with `SearchCriteriaInterface` called `$searchCriteria`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`getList` 方法只接受一个参数，即符合 `SearchCriteriaInterface` 的对象实例，称为 `$searchCriteria`。
- en: 'What this means is we already have the (incomplete) JSON object of the following
    type to pass to the `getList` method:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们已经有以下类型的（不完整）JSON对象来传递给 `getList` 方法：
- en: '[PRE80]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'In order to further understand the inner workings of `search_criteria`, we
    need to understand `SearchCriteriaInterface`, which is (partially) defined as
    follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步理解`search_criteria`的内部工作原理，我们需要了解`SearchCriteriaInterface`，它部分定义如下：
- en: '[PRE81]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Every interface getter and setter method expects the values to be found in
    passed API parameters. What this means is that the `getPageSize()` and `setPageSize()`
    methods would expect `search_criteria` to have an integer type `page_size` property
    on it. Similarly, the `getFilterGroups()` and `setFilterGroups()` methods would
    expect `search_criteria` to have an array of `\Magento\Framework\Api\Search\FilterGroup`
    passed to it. These insights bring us to an (incomplete) JSON object of the following
    type to pass to the `getList` method:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 每个接口的获取器和设置器方法都期望在传递的API参数中找到值。这意味着`getPageSize()`和`setPageSize()`方法会期望`search_criteria`有一个整型`page_size`属性。同样，`getFilterGroups()`和`setFilterGroups()`方法会期望传递给它们的`search_criteria`有一个`\Magento\Framework\Api\Search\FilterGroup`数组。这些见解使我们达到了传递给`getList`方法的以下（不完整）JSON对象类型：
- en: '[PRE82]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Now we have got to the point where we need to determine what goes into `filter_groups`
    and `sort_orders`, since these are not simple types but compound values.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经到了需要确定`filter_groups`和`sort_orders`包含什么内容的时候了，因为这些不是简单类型，而是复合值。
- en: 'Looking further into `\Magento\Framework\Api\Search\FilterGroup`, we see the
    definition of the `getFilters()` and `setFilters()` methods that work with an
    array of `\Magento\Framework\Api\Filter` objects. What this means is that `filter_groups`
    has a property filter that is an array of individual filter objects defined as
    `\Magento\Framework\Api\Filter`. With this in mind, we are now down to the following
    form of the `search_criteria` JSON object:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步查看`\Magento\Framework\Api\Search\FilterGroup`，我们看到`getFilters()`和`setFilters()`方法的定义，这些方法与`\Magento\Framework\Api\Filter`对象数组一起工作。这意味着`filter_groups`有一个属性过滤器，它是一个由`\Magento\Framework\Api\Filter`定义的单独过滤器对象的数组。考虑到这一点，我们现在来看`search_criteria`
    JSON对象的以下形式：
- en: '[PRE83]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Looking further into individual `\Magento\Framework\Api\Filter`, through its
    getters and setters it defines we can conclude properties like `field`, `value`,
    and `condition_type`. This brings us one step further to finalizing our `search_criteria`
    JSON object, which is now structured as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步查看单个`\Magento\Framework\Api\Filter`，通过其获取器和设置器定义，我们可以得出`field`、`value`和`condition_type`等属性。这使我们进一步接近最终确定我们的`search_criteria`
    JSON对象，现在它的结构如下：
- en: '[PRE84]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Let us take a look at `sort_orders` as the last outstanding bit. `sort_orders`
    is of type `\Magento\Framework\Api\SortOrder`, which has getters and setters for
    the field and direction properties. Knowing this, we are able to fully construct
    our `search_criteria` JSON object (or array) that we would be passing to the `getList()`
    service method call, as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看最后的`sort_orders`。`sort_orders`是`\Magento\Framework\Api\SortOrder`类型，它为字段和方向属性提供了获取器和设置器。了解这一点后，我们能够完全构建我们的`search_criteria`
    JSON对象（或数组），这是我们传递给`getList()`服务方法调用的，如下所示：
- en: '[PRE85]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: What happens when we define multiple entries under `filter_groups`, `filters`,
    or `sort_orders`? The logical expectation would be that these break into `AND`
    and `OR` operators in SQL when they hit the database. Surprisingly, this is not
    always the case, at least not with our preceding example. Since the actual implementation
    of the `getList` method is left for us to handle, we can decide how we want to
    handle the filter groups and filters.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`filter_groups`、`filters`或`sort_orders`下定义多个条目时会发生什么？逻辑预期是，当它们到达数据库时，这些会分解成`AND`和`OR`操作符。令人惊讶的是，这并不总是情况，至少在我们的先前列表中不是这样。由于`getList`方法的实际实现留给我们处理，我们可以决定我们想要如何处理过滤器组和过滤器。
- en: 'Looking back at our `getList` method, as (partially) shown next, we are not
    doing anything to imply an `OR` operator, so everything ends up with an `AND`
    condition on the database:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们的`getList`方法，如以下部分所示，我们没有做任何暗示使用`OR`操作符的事情，所以所有内容最终都在数据库上以`AND`条件结束：
- en: '[PRE86]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The preceding code simply loops through all filter groups, pulling in all filters
    within the group and calling the same `addFieldToFilter` method for everything.
    Similar behavior is implemented across core Magento modules. Although the filtering
    itself follows the `\Magento\Framework\Api\SearchCriteriaInterface` interface,
    there is no unified Magento-wide approach to force `AND` and `OR` operators in
    filtering.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码只是简单地遍历所有过滤器组，将组内的所有过滤器拉入，并对所有内容调用相同的 `addFieldToFilter` 方法。类似的行为在核心 Magento
    模块中得到了实现。尽管过滤本身遵循 `\Magento\Framework\Api\SearchCriteriaInterface` 接口，但在 Magento
    范围内没有统一的处理方法来强制执行过滤中的 `AND` 和 `OR` 操作符。
- en: However, Magento core API's like `GET` products do implement both `AND` and
    `OR` conditions. In cases like these, filter groups result in `OR` and filters
    within the group result in `AND` conditions.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，像 `GET` 产品这样的 Magento 核心API确实实现了 `AND` 和 `OR` 条件。在这些情况下，过滤器组导致 `OR` 条件，而组内的过滤器导致
    `AND` 条件。
- en: Tip
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Following best practices, we should make sure our modules that implement search
    criteria do so respecting the `filter_groups`/`filters` and `OR`/`AND` relationship.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循最佳实践，我们应该确保我们的模块在实现搜索条件时，尊重 `filter_groups`/`filters` 和 `OR`/`AND` 的关系。
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a lot of ground relating to Magento API's. There
    is much more left to be said, but the steps outlined here should be enough to
    get us started even with more advanced API usage. We started the chapter with
    learning about types of users and the authentication methods supported. Strong
    emphasis was placed on making several types of API calls, like console cURL, PHP
    cURL, PHP SoapClient, and console cURL SOAP. This was to encourage developers
    to understand the inner workings of API calls more deeply than just using high-level
    libraries.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了与 Magento API 相关的许多内容。还有很多话要说，但这里概述的步骤应该足以让我们开始使用更高级的 API。我们以了解用户类型和支持的认证方法开始本章。我们特别强调了进行多种类型的
    API 调用，如控制台 cURL、PHP cURL、PHP SoapClient 和控制台 cURL SOAP。这是为了鼓励开发者更深入地理解 API 调用的内部工作原理，而不仅仅是使用高级库。
- en: Throughout the next chapter, we will look into some of the major sections of
    Magento.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Magento 的一些主要部分。
