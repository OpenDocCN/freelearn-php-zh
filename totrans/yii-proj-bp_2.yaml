- en: Chapter 2. Discovering What's Nearby
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。探索附近有什么
- en: When developing an application, we are often presented with the geolocation
    data for a particular point of interest. Whether it's a business location or a
    job that the end user is applying to, knowing what's around that particular location
    can provide immediate value to the user when making a decision about that location.
    For example, a user may want to know what restaurants are near a particular location
    or what public services or public transportation options are near a particular
    job the user is interested in. With the help of third-party location APIs, we
    can inform the user what is near a given point of interest. For our second application,
    we develop a web application that shows the user what is near a particular point
    of interest using information from the Google Places API. In this chapter, we
    also cover how to integrate third-party libraries into our application and how
    to improve the performance of our application with caching.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用时，我们经常遇到特定兴趣点的地理位置数据。无论是商业位置还是最终用户申请的工作，了解该特定位置周围的情况可以在用户做出关于该位置的决定时提供即时价值。例如，用户可能想知道特定位置附近的餐馆或公共设施或公共交通选项。借助第三方位置API，我们可以告知用户给定兴趣点附近的情况。对于我们的第二个应用，我们开发了一个Web应用，使用Google
    Places API的信息向用户展示特定兴趣点附近的情况。在本章中，我们还介绍了如何将第三方库集成到我们的应用中以及如何通过缓存来提高我们应用的性能。
- en: Describing the project
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述项目
- en: As with our tasks application that was outlined in [Chapter 1](ch01.html "Chapter 1. A
    Task-management Application"), *A Task-management Application*, we begin the development
    by getting a high-level overview of what the project will do and how our application
    will behave.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](ch01.html "第1章。任务管理应用")中概述的任务应用一样，即*任务管理应用*，我们首先通过获取项目将做什么以及我们的应用将如何表现的高级概述来开始开发。
- en: Searching nearby locations
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索附近位置
- en: The core component of this application is its ability to find other locations
    near an existing location. The easiest way to find this information is to take
    advantage of a third-party API. For this application, we'll be using the Google
    Places API, a web API that can provide nearby locations from given latitude and
    longitude coordinates.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用的核心组件是其查找现有位置附近其他位置的能力。获取此类信息的最简单方法是利用第三方API。对于此应用，我们将使用Google Places API，这是一个可以提供给定纬度和经度坐标附近位置的Web
    API。
- en: Showing locations
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示位置
- en: Rather than simply telling our users what locations are near a given point of
    interest, we can enhance user experience by showing them the points of interest
    and nearby locations on a map. Many different mapping sources exist to show a
    map. For this application, we'll take advantage of another Google API, the Google
    Maps API.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是仅仅告诉用户给定兴趣点附近的位置，我们可以通过在地图上展示兴趣点和附近位置来增强用户体验。存在许多不同的地图源可以显示地图。对于此应用，我们将利用另一个Google
    API，即Google Maps API。
- en: Storing locations
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储位置
- en: To show the user the locations that are available for them to search nearby,
    we need to store these locations first. For storing these locations, we'll need
    a database that we can store imported locations into. Like our tasks application
    that we developed in [Chapter 1](ch01.html "Chapter 1. A Task-management Application"),
    *A Task-management Application*, we'll use SQLite as our primary database again.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向用户展示他们可以搜索的可用位置，我们首先需要存储这些位置。为了存储这些位置，我们需要一个可以存储导入位置的数据库。就像我们在[第1章](ch01.html
    "第1章。任务管理应用")中开发的任务应用一样，我们将再次使用SQLite作为我们的主要数据库。
- en: Importing locations
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入位置
- en: Finally, we're going to need a command-line tool to import locations from a
    data feed. To accomplish this, we're going to create a console task that can be
    run from the command line. This task will fetch information from the provided
    JSON feed and import it into our database. By making this a command-line task,
    we can automate and schedule the import via scheduled tasks on Windows or a Unix
    crontab.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个命令行工具从数据源导入位置。为了完成这项任务，我们将创建一个可以从命令行运行的控制台任务。此任务将从提供的JSON源获取信息并将其导入我们的数据库。通过将其作为命令行任务，我们可以通过Windows上的计划任务或Unix的crontab来自动化和安排导入。
- en: Designing the database
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计数据库
- en: With the core components of our application identified, we can now get started
    with developing the database. Let's start with creating our `locations` table.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了应用程序的核心组件后，我们现在可以开始开发数据库了。让我们从创建我们的 `locations` 表开始。
- en: Locations
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位置
- en: 'When developing applications that import data from an external source, you
    can often take advantage of the structure of the external feed to determine what
    your own database tables should look like. Provided with the chapter resources
    at `protected/data/` is a file called `parks.json` that serves as our external
    data source. Since the data in this feed is consistent, let''s take a look at
    a single item in the feed:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发从外部源导入数据的应用程序时，您通常可以利用外部源的结构来确定自己的数据库表应该是什么样子。在 `protected/data/` 的章节资源中提供了一个名为
    `parks.json` 的文件，作为我们的外部数据源。由于该源中的数据是一致的，让我们看一下源中的一个条目：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A single element in our data feed is composed of the name of the location,
    its latitude and longitude coordinates, and the city and state of the location.
    To make things simple, we can represent each of these attributes as a `TEXT` attribute
    in our table. Once we have added an `ID` column and `created` and `updated` columns,
    our `locations` table will look as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数据源中的单个元素由位置的名称、纬度和经度坐标以及该位置的市和州组成。为了简化，我们可以将这些属性表示为表中每个的 `TEXT` 属性。一旦我们添加了
    `ID` 列和 `created` 以及 `updated` 列，我们的 `locations` 表将如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Initializing the project
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化项目
- en: 'As we did in our tasks project, we begin the development by creating a few
    folders in our application web root:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在任务项目中做的那样，我们在应用程序的 web 根目录下创建了一些文件夹以开始开发：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this application, we added two new folders, `commands` and `extensions`.
    The `commands` folder is a special folder in Yii that `yiic` will reference when
    running console commands. The `extensions` folder is a special folder in Yii,
    where Yii extensions or third-party classes can be placed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们添加了两个新的文件夹，`commands` 和 `extensions`。`commands` 文件夹是 Yii 中的一个特殊文件夹，当运行命令行命令时，`yiic`
    将引用它。`extensions` 文件夹是 Yii 中的一个特殊文件夹，其中可以放置 Yii 扩展或第三方类。
- en: 'Next, let''s go ahead and add our Yii Bootstrap file, `index.php`, to the root
    of our application. We need to be sure to change the Yii path to the location
    on the system:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将我们的 Yii 启动文件 `index.php` 添加到应用程序的根目录。我们需要确保将 Yii 路径更改为系统上的位置：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s create our `yiic.php` file within our `protected` folder that will
    run both our migrations and console commands. Once again, we need to be sure to
    adjust the path to the Yii framework in the `require` statement:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `protected` 文件夹中创建我们的 `yiic.php` 文件，该文件将运行我们的迁移和命令行命令。我们再次需要确保在 `require`
    语句中调整到 Yii 框架的路径：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating the configuration file
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建配置文件
- en: 'Next, we need to create the configuration file that our Yii application will
    use. Let''s add the following to `protected/config/main.php`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建我们的 Yii 应用程序将使用的配置文件。让我们将以下内容添加到 `protected/config/main.php`：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In comparison to the configuration file we made in [Chapter 1](ch01.html "Chapter 1. A
    Task-management Application"), *A Task-management Application*, the only parts
    of the file that were changed are the location of the database file for SQLite
    to use and the name of the application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在 [第1章](ch01.html "第1章。任务管理应用程序") 中制作的配置文件相比，*任务管理应用程序*，文件中唯一改变的部分是 SQLite
    数据库文件的存储位置以及应用程序的名称。
- en: Retrieving the sample data
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取示例数据
- en: Provided with the chapter resources within the `protected/data` folder is a
    file called `parks.json`; it contains the sample data that we will use for our
    application. Let's go ahead and grab this file from the project resources and
    add it to the `protected/data` folder.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `protected/data` 文件夹内的章节资源中有一个名为 `parks.json` 的文件；它包含我们将用于应用程序的示例数据。让我们从项目资源中获取这个文件并将其添加到
    `protected/data` 文件夹中。
- en: Creating the database
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库
- en: 'To create the database, we again use migrations. From the command line, let''s
    navigate to the project root and create the migration using `yiic`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建数据库，我们再次使用迁移。现在，让我们从命令行导航到项目根目录并使用 `yiic` 创建迁移：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After confirming the creation, we open up the new migration file in `protected/migrations`
    and replace the `contents up()` method with the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 确认创建后，我们在 `protected/migrations` 中打开新的迁移文件，并将 `contents up()` 方法替换为以下内容：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we replace the contents of the `down()` method with the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `down()` 方法的内文替换为以下内容：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'From the command line, let''s now apply the new migration:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们从命令行应用新的迁移：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating the locations model
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建位置模型
- en: To interact with our data, we need to create a model that once again references
    our new database table. Using the instructions outlined in [Chapter 1](ch01.html
    "Chapter 1. A Task-management Application"), *A Task-management Application*,
    we enable the `Gii` module and create a new model called Location to interact
    with the `locations` table in our database.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与我们的数据交互，我们需要创建一个模型，该模型再次引用我们新的数据库表。使用[第1章](ch01.html "第1章。任务管理应用程序")中概述的说明，“任务管理应用程序”，我们启用`Gii`模块并创建一个名为Location的新模型，以与数据库中的`locations`表交互。
- en: 'Once created, we add a `beforeSave()` method to the generated file (`protected/modules/Location.php`)
    to automatically set the created and updated time:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完成后，我们在生成的文件（`protected/modules/Location.php`）中添加一个`beforeSave()`方法来自动设置创建和更新时间：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we modify the `rules()` method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们修改`rules()`方法：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Importing the data feed
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入数据源
- en: Before creating the frontend controllers to display our data, we need to create
    a tool to import our data feed. To create this tool, we create a class in our
    commands directory that extends `CConsoleCommand`; this will enable us to import
    data from the command line and automate it if we so choose.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建前端控制器以显示我们的数据之前，我们需要创建一个工具来导入我们的数据源。为了创建这个工具，我们在命令目录中创建了一个继承自`CConsoleCommand`的类；这将使我们能够从命令行导入数据，并选择自动化它。
- en: 'To begin, we need to create a new class called `ImportLocationsCommand` inside
    of our `commands` directory at `/protected` that extends `CConsoleCommand`. The
    filename inside the commands directory should be `ImportLocationscommand.php`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在`/protected`目录下的`commands`目录中创建一个名为`ImportLocationsCommand`的新类，该类继承自`CConsoleCommand`。在命令目录中的文件名应该是`ImportLocationscommand.php`：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we add a method to handle the retrieval of the data we want to import.
    To provide the greatest amount of flexibility, we create two methods: the first
    will fetch the data from our external data source and the second will actually
    import the data into our database.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个方法来处理我们想要导入的数据的检索。为了提供最大的灵活性，我们创建了两个方法：第一个将从我们的外部数据源获取数据，第二个实际上将数据导入我们的数据库。
- en: 'In a real-world application, the first method that we build might fetch the
    data from a web resource via CURL. Alternatively, the data might be uploaded and
    provided to us via FTP. Since our data is stored locally, however, our method
    will simply fetch the contents of the file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们构建的第一个方法可能会通过CURL从网络资源获取数据。或者，数据可能通过FTP上传并供我们使用。然而，由于我们的数据是本地存储的，因此我们的方法将简单地获取文件的全部内容：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By moving this functionality into its own method, we can easily change this
    method in future to fetch this data from another location, without having to change
    other parts of our code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将此功能移动到自己的方法中，我们可以轻松地在未来更改此方法，以从另一个位置获取数据，而无需更改代码的其他部分。
- en: 'Next, we create a new method called `actionImportLocations()` that will perform
    the import:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为`actionImportLocations()`的新方法来执行导入：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For simplicity, we assume that our `getData()` method will always return valid
    data to this method. Inside the method, we add the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们假设`getData()`方法将始终返回有效数据给此方法。在方法内部，我们添加以下内容：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: An important consideration when importing data is to make sure that we don't
    accidentally create duplicate data within our application. There are several ways
    to handle this.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入数据时，一个重要的考虑因素是确保我们不会意外地在应用程序中创建重复数据。有几种处理方法。
- en: The easiest way to handle this edge case is to simply truncate the database
    table and perform a fresh import. While this type of import is incredibly simple,
    with larger datasets, it could cause our application not to function properly
    while the import is running.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这种边缘情况的最简单方法就是简单地截断数据库表并执行全新的导入。虽然这种类型的导入非常简单，但在处理更大的数据集时，它可能会在导入过程中导致我们的应用程序无法正常工作。
- en: A more reliable method would be to import this data into a temporary database
    table and then delete the active table and rename the temporary one to the active
    table's name. In addition to ensuring that we don't have duplicate data, this
    method also ensures that if we have a problem importing the data, we can simply
    abort the import with an error and not worry about having a corrupted database.
    Additionally, this method should also reduce the downtime associated with importing
    the raw data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更可靠的方法是将这些数据导入到一个临时数据库表中，然后删除活动表并将临时表重命名为活动表的名字。除了确保我们没有重复数据外，这种方法还可以确保如果我们导入数据时出现问题，我们可以简单地通过错误中断导入，而不必担心数据库被损坏。此外，这种方法还应减少与导入原始数据相关的停机时间。
- en: The most complex way of importing the data would be to compare your existing
    database with the data from the feed and import only the difference between the
    two. While significantly more complex, this method can reduce the overhead needed
    to retrieve the data, and when put in combination with the previous method, should
    reduce almost all of the downtime associated with an import.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 导入数据最复杂的方法是将现有的数据库与数据源中的数据进行比较，只导入两者之间的差异。虽然这种方法更复杂，但它可以减少检索数据所需的开销，并且与之前的方法结合使用时，应几乎减少所有与导入相关的停机时间。
- en: 'To keep things simple, we''re going to opt for the first method, which we can
    easily implement, as follows. First, we''re going to truncate the existing data
    in our database:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们将选择第一种方法，这很容易实现。首先，我们将截断数据库中的现有数据：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since our database matches our data feed, we''ll simply iterate through the
    results and import them row by row:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的数据库与我们的数据源匹配，我们将简单地遍历结果并逐行导入：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'From the command line, we can now import our data by running the `importlocations`
    command we just created. Running command-line tasks takes the following format:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行，我们现在可以通过运行我们刚刚创建的`importlocations`命令来导入我们的数据。运行命令行任务的格式如下：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In our case, the full command looks as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个例子中，完整的命令如下所示：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the import went well, we will see the debug output that we added to the
    command without any errors:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果导入顺利，我们将看到我们添加到命令中的调试输出，没有任何错误：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about `CConsoleCommand` from the official guide at [http://www.yiiframework.com/doc/guide/1.1/en/topics.console](http://www.yiiframework.com/doc/guide/1.1/en/topics.console)
    or from the Yii class reference at [http://www.yiiframework.com/doc/api/1.1/CConsoleCommand](http://www.yiiframework.com/doc/api/1.1/CConsoleCommand).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从官方指南[http://www.yiiframework.com/doc/guide/1.1/en/topics.console](http://www.yiiframework.com/doc/guide/1.1/en/topics.console)或从Yii类参考[http://www.yiiframework.com/doc/api/1.1/CConsoleCommand](http://www.yiiframework.com/doc/api/1.1/CConsoleCommand)中了解更多关于`CConsoleCommand`的信息。
- en: Google APIs
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google API
- en: Before we begin work at the frontend of our application, we need to create an
    API key to interact with Google Maps and the Google Places API.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始应用前端工作之前，我们需要创建一个API密钥以与Google Maps和Google Places API交互。
- en: Enabling Google APIs
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用Google API
- en: 'To enable the Google APIs our project is using, open up a web browser and navigate
    to the Google API Console located at [https://console.developers.google.com/project](https://console.developers.google.com/project).
    Once we have logged in to a Google account, we click on the **Create Project**
    button and fill out the form with a unique project name and project ID, as shown
    in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用我们项目使用的Google API，请打开一个网络浏览器并导航到位于[https://console.developers.google.com/project](https://console.developers.google.com/project)的Google
    API控制台。一旦我们登录到Google账户，我们点击**创建项目**按钮，并填写具有唯一项目名称和项目ID的表单，如下面的截图所示：
- en: '![Enabling Google APIs](img/7734OS_02_01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![启用Google API](img/7734OS_02_01.jpg)'
- en: 'Once the project has been created, we navigate to the newly created project
    and click on the **APIs & auth** link in the sidebar. From the list of APIs, we
    toggle both **Google Maps JavaScript API v3** and **Places API** to **ON**, as
    shown in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建项目，我们将导航到新创建的项目，并在侧边栏中点击**APIs & auth**链接。从API列表中，我们将**Google Maps JavaScript
    API v3**和**Places API**切换到**开启**，如下面的截图所示：
- en: '![Enabling Google APIs](img/7734OS_02_02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![启用Google API](img/7734OS_02_02.jpg)'
- en: Generating an API key
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成API密钥
- en: 'With both APIs enabled for the project, we click on the **Credentials** link
    in the sidebar. From this menu, we can create a new API key for our application
    to use. Once on this page, we are presented with two options, either an OAuth
    Client ID or a Public API key. Click on **Create new Key** under **Public API
    access**, as shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目启用了这两个API之后，我们点击侧边栏中的**凭证**链接。从这个菜单，我们可以为我们的应用程序创建一个新的API密钥。一旦进入这个页面，我们将有两个选项，即OAuth客户端ID或公共API密钥。点击**公共API访问**下的**创建新密钥**，如以下截图所示：
- en: '![Generating an API key](img/7734OS_02_03.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![生成API密钥](img/7734OS_02_03.jpg)'
- en: 'Then, from the next menu select **Server key**, which will generate a new client
    API key for us to use in our application:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从下一个菜单选择**服务器密钥**，这将为我们生成一个新的客户端API密钥，以便在我们的应用程序中使用：
- en: '![Generating an API key](img/7734OS_02_04.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![生成API密钥](img/7734OS_02_04.jpg)'
- en: Once the page reloads, we copy the full API key to our clipboard.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 页面重新加载后，我们将完整的API密钥复制到我们的剪贴板。
- en: Storing the API key
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储API密钥
- en: 'Next, we need to store our API in our application so that we can use it. Fortunately,
    Yii provides a setting for static parameters in `protected/config/main.php` called
    `params` that we can store our API key in. Let''s add the following as a root
    element to our configuration file and replace `<your_api_key_here>` with the actual
    API key:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的应用程序中存储我们的API，以便我们可以使用它。幸运的是，Yii在`protected/config/main.php`中提供了一个用于静态参数的设置，称为`params`，我们可以在这里存储我们的API密钥。让我们将以下内容作为配置文件的根元素添加，并用实际的API密钥替换`<your_api_key_here>`：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This data is then available as an array through `Yii::app()->params`, which
    we can query against, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这些数据可以通过`Yii::app()->params`作为一个数组来访问，我们可以按照以下方式查询：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Creating the presentation layer
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表示层
- en: 'Now, we''re ready to start displaying content. To get started, we create a
    new controller called `SiteController.php` in the `protected/controllers` directory
    that contains the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始显示内容。为了开始，我们在`protected/controllers`目录中创建一个新的控制器，命名为`SiteController.php`，它包含以下内容：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, let''s create our main layout in `protected/views/layouts/main.php`.
    For simplicity, we''re once again going to use the jQuery and Twitter Bootstrap
    styles from publicly available CDNs, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`protected/views/layouts/main.php`中创建我们的主要布局。为了简单起见，我们再次将使用从公开可用的CDNs获取的jQuery和Twitter
    Bootstrap样式，如下所示：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since our application will have only one page, we will register the Google
    Maps JavaScript API directly in our layout, as shown in the preceding code. Note
    that when we registered this JavaScript file, we included our Google API key,
    which we added to the `params` section of our configuration file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序将只有一个页面，我们将直接在我们的布局中注册Google Maps JavaScript API，如前述代码所示。请注意，当我们注册此JavaScript文件时，我们包括了我们的Google
    API密钥，该密钥已添加到配置文件的`params`部分：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, let''s create a simple view file for our `site/index` action in `protected/views/sites/index.php`
    to hold our maps container:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为我们的`site/index`动作在`protected/views/sites/index.php`中创建一个简单的视图文件，以保存我们的地图容器：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Interacting with the Google Maps JavaScript API
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与Google Maps JavaScript API交互
- en: Since Google Maps is a JavaScript API, we need to write some JavaScript code
    to interact with it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Google Maps是一个JavaScript API，我们需要编写一些JavaScript代码来与之交互。
- en: To begin, create a new file in `/js` called `Main.js`. This JavaScript file
    will store all of our JavaScript methods to create and interact with Google Maps.
    The utility functions we create here will make interacting with the map easier
    later on.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`/js`目录中创建一个新的文件，命名为`Main.js`。此JavaScript文件将存储我们创建和与Google Maps交互的所有JavaScript方法。我们在这里创建的实用函数将使稍后与地图交互更容易。
- en: 'Before we start writing any JavaScript, we need to load our JavaScript file
    from our layout. To do this, we can register a new script from `CClientScript`
    by adding the following to our call to `CClientScript` in our `main.php` file
    at `protected/views/layouts`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写任何JavaScript之前，我们需要从我们的布局中加载我们的JavaScript文件。为此，我们可以在`protected/views/layouts`目录下的`main.php`文件中通过添加以下内容来注册一个新的脚本`CClientScript`：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that our JavaScript file will be loaded, we open up our `Main.js` file
    and create a new JavaScript object called `Main`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在JavaScript文件将被加载，我们打开`Main.js`文件并创建一个新的JavaScript对象，命名为`Main`：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Within this object, we need to create three properties: a property to store
    the Google Maps object, a property to store any options Google Maps may require,
    and a property to store any marker we add to the map:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在此对象中，我们需要创建三个属性：一个用于存储Google Maps对象，一个用于存储Google Maps可能需要的任何选项，以及一个用于存储我们添加到地图上的任何标记：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, we create a function that will actually load the Google Maps object. This
    function will need to handle two separate loading cases.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个函数来实际加载谷歌地图对象。这个函数需要处理两个不同的加载情况。
- en: The first case this function will need to handle is the loading of Google Maps
    without any map markers. In this situation, we assume the user has arrived at
    the page for the first time and has not selected the point of interest that they
    want to see nearby locations for. The second case this function will need to handle
    is the initialization of the map with a given point of interest centered and focused
    on.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数需要处理的第一个情况是加载没有地图标记的谷歌地图。在这种情况下，我们假设用户第一次到达该页面，并且尚未选择他们想要查看附近位置的感兴趣点。这个函数需要处理的第二个情况是使用给定的感兴趣点初始化地图，并聚焦在该点上。
- en: 'To handle these two cases, our function will accept a latitude and longitude
    location. If the latitude and longitude positions are given to the method, we
    will center the map on that location. If they are not provided, we will center
    the map on a zoomed-out location of where our data generally lies, which in this
    case is the downtown Chicago area:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这两种情况，我们的函数将接受一个纬度和经度位置。如果提供了纬度和经度位置，我们将地图中心定位在那个位置。如果没有提供，我们将地图中心定位在我们数据通常所在的位置的缩放视图，在这个例子中是芝加哥市中心地区：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, within the same function, we''re going to set our map options and load
    the map in the placeholder that we set in our `index.php` file at `protected/views/site`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在同一个函数中，我们将设置我们的地图选项并在我们的`index.php`文件中的`protected/views/site`占位符中加载地图：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'So that we can see our map in action, we add the following to our `index.php`
    file at `protected/views/site` and refresh the page:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们看到地图的实际效果，我们在`index.php`文件中的`protected/views/site`添加以下内容并刷新页面：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once the page loads, we should see the Google Maps object displayed, as shown
    in the following screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载后，我们应该看到谷歌地图对象显示，如下面的截图所示：
- en: '![Interacting with the Google Maps JavaScript API](img/7734OS_02_05.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![与谷歌地图JavaScript API交互](img/7734OS_02_05.jpg)'
- en: After verifying that our map has loaded, let's head back to our `Main.js` file
    and add a few more utility functions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证我们的地图已加载后，让我们回到我们的`Main.js`文件并添加一些额外的实用函数。
- en: 'First, let''s add a simple wrapper to create the Google Maps latitude and longitude
    coordinates. This method will help ensure that our Google Maps object loads when
    we want to interact with it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加一个简单的包装器来创建谷歌地图的纬度和经度坐标。这种方法将帮助我们确保当我们要与之交互时，我们的谷歌地图对象能够加载：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Secondly, let''s create a function to add map markers. This function will need
    to display two types of markers, the first being the selected point of interest
    and the second being the nearby points of interest:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，让我们创建一个函数来添加地图标记。这个函数需要显示两种类型的标记，第一种是选定的感兴趣点，第二种是附近的感兴趣点：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Within the function, we create a new `marker` object:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们创建一个新的`marker`对象：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we push this `marker` object onto the map:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这个`marker`对象推送到地图上：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we add the `marker` object to the `markers` variable that we defined
    earlier. This allows us to clear the map if we want to make our application more
    dynamic:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`marker`对象添加到我们之前定义的`markers`变量中。这允许我们在想要使我们的应用程序更动态时清除地图：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, let''s create a function that will clear the map. This function will
    iterate through all of the markers in the `markers` variable that we defined earlier
    and remove the map marker we set with `addMarker()`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个函数来清除地图。这个函数将遍历我们在之前定义的`markers`变量中的所有标记，并移除我们使用`addMarker()`设置的地图标记：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information on how to interact with the Google Maps JavaScript API v3 is
    located at [https://developers.google.com/maps/documentation/javascript/tutorial](https://developers.google.com/maps/documentation/javascript/tutorial).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何与谷歌地图JavaScript API v3交互的更多信息，请参阅[https://developers.google.com/maps/documentation/javascript/tutorial](https://developers.google.com/maps/documentation/javascript/tutorial)。
- en: Searching nearby locations
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索附近位置
- en: To search nearby locations, we're going to take advantage of the Google Places
    API. Rather than implementing the API documentation ourselves, as outlined in
    [https://developers.google.com/places/documentation/](https://developers.google.com/places/documentation/),
    we're going to take advantage of an open source wrapper for the API located at
    [https://github.com/joshtronic/php-googleplaces](https://github.com/joshtronic/php-googleplaces).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了搜索附近的地点，我们将利用Google Places API。我们不会自己实现API文档，如[https://developers.google.com/places/documentation/](https://developers.google.com/places/documentation/)中所述，而是将利用位于[https://github.com/joshtronic/php-googleplaces](https://github.com/joshtronic/php-googleplaces)的开源API包装器。
- en: 'To take advantage of this wrapper, we download the repository to our `extensions`
    folder, which should look as follows, once we have downloaded the repository:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这个包装器，我们将仓库下载到我们的`extensions`文件夹中，下载完成后应该如下所示：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With the wrapper downloaded, we reopen `SiteController.php` and create a new
    private method called `getPlaces()`, which takes a location from our database
    as an argument:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完包装器后，我们重新打开`SiteController.php`并创建一个新的私有方法`getPlaces()`，它接受我们的数据库中的一个地点作为参数：
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To make Yii aware of this class, we need to first import it using `Yii::import()`.
    This method is preferred over a `require` or `include` statement because it both
    registers the class with Yii''s autoloader and only loads the class once if we
    use it multiple times. Since this class wasn''t autoloaded in our configuration
    file, we need to manually import it here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Yii知道`ext.GooglePlaces`代表`protected/extensions/GooglePlaces.php`，我们首先使用`Yii::import()`导入它。这个方法比`require`或`include`语句更受欢迎，因为它既将类注册到Yii的自动加载器中，又在我们多次使用时只加载类一次。由于这个类在我们的配置文件中没有自动加载，我们需要在这里手动导入它：
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: How does Yii know that `ext.GooglePlaces` represents `protected/extensions/GooglePlaces.php`?
    Yii uses path aliases to easily identify where files and folders are located within
    our application root. This enables us to easily reference these files and folders
    without having to specify an absolute path. You can read more about path aliases
    at [http://www.yiiframework.com/doc/guide/1.1/en/basics.namespace](http://www.yiiframework.com/doc/guide/1.1/en/basics.namespace).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Yii是如何知道`ext.GooglePlaces`代表`protected/extensions/GooglePlaces.php`的呢？Yii使用路径别名来轻松识别文件和文件夹在我们应用程序根目录中的位置。这使得我们可以轻松地引用这些文件和文件夹，而无需指定绝对路径。您可以在[http://www.yiiframework.com/doc/guide/1.1/en/basics.namespace](http://www.yiiframework.com/doc/guide/1.1/en/basics.namespace)上了解更多关于路径别名的信息。
- en: 'Next, we instantiate the class with the API key that we created earlier:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用我们之前创建的API密钥实例化这个类：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we specify the radius and location that we want to search around:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们指定我们想要搜索的半径和地点：
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In a densely populated area with many different shops, it's safe to assume that
    we'd find several results within a 200-meter radius. In a less densely populated
    area, it would be wise to adjust our radius to something much larger to find nearby
    results better.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个人口密集、商店众多的地区，我们可以合理地假设在200米半径内我们会找到几个结果。在一个人口较少的地区，调整我们的半径到一个更大的值以更好地找到附近的搜索结果会更明智。
- en: 'Then, we search for nearby locations:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们搜索附近的地点：
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With a method in place to perform the search, we now need to update our `index`
    action to call our new method. To do this, we assume that the client is going
    to specify which location they want to search around by selecting a location from
    a drop-down list and sending us the unique ID we created for the record when we
    imported it. Within `SiteController.php`, we add the following action:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了执行搜索的方法后，我们现在需要更新我们的`index`操作来调用我们的新方法。为此，我们假设客户端将通过从下拉列表中选择一个地点并发送我们创建的唯一ID来指定他们想要搜索的地点。在`SiteController.php`中，我们添加以下操作：
- en: '[PRE45]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Selecting a location
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择地点
- en: 'Now that our controller can search nearby locations, we need to update our
    view, `protected/views/site/index.php`, with a form to allow the user to select
    a location they''re inserted in:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们控制器可以搜索附近的地点了，我们需要更新我们的视图，`protected/views/site/index.php`，添加一个表单，允许用户选择他们想要插入的地点：
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the previous code sample, we used `CHtml::listData()` to simultaneously retrieve
    a list of locations from our database and populate the drop-down menu with the
    appropriate ID name pairs to be displayed. Using `CHtml::listData()`, we can ensure
    that our data is fetched and displayed dynamically based on what we have in our
    database.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们使用了`CHtml::listData()`来同时从我们的数据库中检索地点列表，并用适当的ID名称对填充下拉菜单以显示。使用`CHtml::listData()`，我们可以确保我们的数据是根据数据库中的内容动态获取和显示的。
- en: Showing locations on a map
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在地图上显示位置
- en: 'While our form is functional, we still need to update our view to actually
    display the locations on the map. This is where we use the JavaScript code we
    created earlier. Before the closing `</div>` tag of our sidebar, let''s load `CClientScript`
    to dynamically register the JavaScript with Yii:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的表单功能正常，但我们仍然需要更新我们的视图来实际显示地图上的位置。这就是我们使用之前创建的JavaScript代码的地方。在我们的侧边栏的`</div>`标签之前，让我们加载`CClientScript`以动态地将JavaScript与Yii注册：
- en: '[PRE47]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, there are two cases we need to handle. In the first case, the user has
    arrived at our site for the first time and simply needs to be shown the map. In
    the second case, we need to show a map that is centered around our point of interest.
    Since our `$places[''results'']` array will be empty in the first case, we can
    express this as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要处理两种情况。在第一种情况下，用户第一次到达我们的网站，只需要显示地图。在第二种情况下，我们需要显示一个以我们的兴趣点为中心的地图。由于在第一种情况下，我们的`$places['results']`数组将是空的，我们可以这样表示：
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Let's reload the page and try it out. If a location is selected, a blue marker
    will indicate the position on the map. Otherwise, no marker will be shown.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新加载页面并尝试一下。如果选择了位置，地图上会显示一个蓝色标记。否则，不会显示任何标记。
- en: 'Next, we need to add the nearby locations to the map. To do this, we simply
    iterate through the `$places[''results'']` array and register a unique script
    that will place a marker on the map. For added clarity for the end user, we also
    add the item as a text entry in the sidebar:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将附近的地点添加到地图上。为此，我们只需遍历`$places['results']`数组，并注册一个唯一的脚本，该脚本将在地图上放置一个标记。为了提高最终用户的清晰度，我们还在侧边栏中添加了文本条目：
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With everything in place, we can now search our `locations` database and see
    nearby locations displayed on the map:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪后，我们现在可以搜索我们的`locations`数据库，并在地图上显示附近的地点：
- en: '![Showing locations on a map](img/7734OS_02_06.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![在地图上显示位置](img/7734OS_02_06.jpg)'
- en: Optimizing the performance with caching
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用缓存优化性能
- en: As is often the case with third-party APIs, the Google Places API is a paid-for
    resource that comes with a daily courtesy limit (currently at 1,000 requests per
    day), which means that every time a user makes a request to our application, we're
    paying for it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如第三方API通常的情况一样，Google Places API是一个付费资源，它附带每日的礼貌限制（目前为每天1,000次请求），这意味着每次用户向我们的应用程序发出请求时，我们都在为其付费。
- en: However, since the likelihood of a new point of interest being created within
    the next few hours, days, or even weeks is pretty small, we can cache this data
    locally rather than making a request to Google each time the page is requested.
    Doing this will not only save us money, but it will also speed up our application
    since this data can be retrieved from a local resource rather than a third-party
    one.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于在接下来的几个小时、几天甚至几周内创建一个新的兴趣点的可能性相当小，我们可以在本地缓存这些数据，而不是每次请求页面时都向谷歌发送请求。这样做不仅可以节省我们的费用，而且还可以加快我们的应用程序的速度，因为可以从本地资源而不是第三方资源检索这些数据。
- en: 'To do this, we first need to enable a cache in our configuration file. There
    are several different caches available for use in Yii, including file-based caches,
    memcache-based caching, and a Redis cache. For this application, we''ll keep things
    simple and use file-based caching. To enable the cache, we add the following to
    the components section of our configuration file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先需要在配置文件中启用缓存。Yii中有几种不同的缓存可供使用，包括基于文件的缓存、基于memcache的缓存和Redis缓存。对于这个应用程序，我们将保持简单，并使用基于文件的缓存。要启用缓存，我们在配置文件的组件部分添加以下内容：
- en: '[PRE50]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With the cache enabled, we start using it within our application. Let''s open
    up `SiteController.php` and replace the `getPlaces()` method with the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 启用缓存后，我们开始在应用程序中使用它。让我们打开`SiteController.php`文件，并将`getPlaces()`方法替换为以下内容：
- en: '[PRE51]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s walk through what we just did. First, we''re going to generate a unique
    hash that we''ll store our hashes against. To do this, we''re going to store the
    latitude and longitude of any given location as an `md5` hash, which should provide
    sufficient search space for us to store our results:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们刚才做了什么。首先，我们将生成一个唯一的哈希值，我们将使用这个哈希值存储我们的哈希值。为此，我们将任何给定位置的纬度和经度存储为一个`md5`哈希值，这应该为我们提供足够的空间来存储我们的结果：
- en: '[PRE52]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we''re going to retrieve the cache result from the cache. In the event
    that data is not returned, this method will return false:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从缓存中检索缓存结果。如果数据未返回，此方法将返回false：
- en: '[PRE53]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we don''t have any value presently stored in the cache, we''ll perform a
    search against the API:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前缓存中没有存储任何值，我们将对API进行搜索：
- en: '[PRE54]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'After retrieving the results from the API, we then store it against the `md5`
    hash that we generated earlier:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从API检索结果后，我们将其存储在之前生成的`md5`哈希值中：
- en: '[PRE55]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we return the data:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回数据：
- en: '[PRE56]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: By adding this cache, our application should perform much better when multiple
    users are searching against it, and we reduce the risk of hitting our daily API
    limit. If we do need to upgrade our application to one that needs more requests,
    we can be confident that we're only paying for what we absolutely need, rather
    than for each request.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加这个缓存，当多个用户同时搜索时，我们的应用程序应该会表现得更好，并且我们降低了触碰到每日API限制的风险。如果我们确实需要升级我们的应用程序到一个需要更多请求的应用程序，我们可以确信我们只为我们绝对需要的部分付费，而不是为每个请求付费。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Throughout this chapter, we covered a lot of ground. We went over how to integrate
    console commands into our application with `CConsoleCommand` as well as how to
    import data into our database from an external source. We also went over how to
    integrate with two popular Google APIs: Google Maps and the Google Places API.
    Additionally, we covered caching the responses of these APIs. Finally, we went
    over importing third-party code into our application.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们覆盖了很多内容。我们讨论了如何使用`CConsoleCommand`将控制台命令集成到我们的应用程序中，以及如何从外部源将数据导入我们的数据库。我们还讨论了如何集成两个流行的Google
    API：Google Maps和Google Places API。此外，我们还讨论了这些API响应的缓存。最后，我们讨论了将第三方代码导入我们的应用程序。
- en: In this chapter and in [Chapter 1](ch01.html "Chapter 1. A Task-management Application"),
    *A Task-management Application*, we went over almost all the basic components
    of building a Yii application. In the next chapter, we will create a scheduling
    application that will automatically remind the user of events before they occur'.
    We'll also expand on all of the topics we covered so far to build and work with
    more complex topics. Before continuing, be sure to take a look at all the classes
    we referenced in this chapter, in the official Yii documentation, so that you
    can better understand them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和[第1章](ch01.html "第1章。任务管理应用程序")《任务管理应用程序》中，我们讨论了构建Yii应用程序的大部分基本组件。在下一章中，我们将创建一个调度应用程序，该应用程序将在事件发生之前自动提醒用户。我们还将扩展我们迄今为止讨论的所有主题，以构建和操作更复杂的话题。在继续之前，请务必查看本章中引用的所有类，在官方Yii文档中，以便更好地理解它们。
