- en: Chapter 5. Building Your Own Restful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will create our own microblogging application similar to
    Twitter. The social component will be fairly simple: users will post on their
    walls messages containing up to 140 characters. The real input of this chapter
    will reside in setting up a JSON API that can be accessed by external applications
    and adding automated tests that will allow you to track regressions. In order
    to limit the amount of data exchanged, we will make our application use this API
    as often as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of the chapter, you should know:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create a signup form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a JSON API without duplicating any code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the `Parser` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are language-agnostic template systems and why use such systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the Mustache engine and how to implement views using it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a magic migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement unit tests and run them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible for visitors to subscribe to our micro blogging application.
    Once they do, they are able to write small posts of 140 characters which will
    be displayed on their profile page. Anyone, even non-users, can see a user's profile
    page.
  prefs: []
  type: TYPE_NORMAL
- en: In order to avoid authentication issues and keep this project simple, we will
    only provide a read-only JSON API. Also, we won't track applications using our
    API and therefore no limitations will be implemented (this could be an important
    point if you are thinking of publishing your own API). Therefore, only the users'
    profile information (username, creation date, and so on) and published posts will
    be available through the API.
  prefs: []
  type: TYPE_NORMAL
- en: Conception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need the following two models:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Conception](img/5401OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Entity Relationship diagram (Min-Max notation)
  prefs: []
  type: TYPE_NORMAL
- en: '**User**: Since the model''s table will be generated from the `Auth` package''s
    migration, the columns will already be generated. The columns we need are `username`
    and `password`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post**: Each post has a `content` and a `created_at` property. Since each
    post can only be published by a single user and each user can publish many posts,
    there is a `belongs_to` relationship between posts and users and a `has_many`
    relationship between users and posts. Thus, an additional `user_id` property must
    be added for the relationship.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FuelPHP installation and configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You first need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install a new FuelPHP instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure Apache and the host file to handle it. In this chapter, we will access
    our application by requesting the `http://mymicroblog.app` URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update Composer if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new database for your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, configure FuelPHP in order to allow your application to access this
    database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This project will also need the `ORM`, the `Auth`, and the `Parser` packages.
    We used the `ORM` and the `Auth` packages in previous chapters, but we never used
    the `Parser` package; we will explain its role later in *The Parser package and
    template engines* section. Since they are already installed, we just need to enable
    them. For doing this, simply open the `APPPATH/config/config.php` file and insert
    the following lines of code at the end of the returned array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can uncomment the appropriate lines. This will load the `ORM`,
    the `Auth`, and the `Parser` package every time a FuelPHP instance is loaded.
    We also need to change a few configuration items for the `Auth` package.
  prefs: []
  type: TYPE_NORMAL
- en: First, copy the file located at `PKGPATH/auth/config/auth.php` to `APPPATH/config/auth.php`
    and `PKGPATH/auth/config/simpleauth.php` to `APPPATH/config/simpleauth.php`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, open the configuration file `APPPATH/config/auth.php` and change the `salt`
    value to a random string (this is a security precaution). We will use the `Simpleauth`
    driver here, as we don't need many features in our authentication system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, open the file `APPPATH/config/simpleauth.php` and set the value of `login_hash_salt`
    to a random string (again, for security precaution). Install the `Auth` tables
    by executing their migration files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you take a look at the database, you should see that several tables have
    been generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`users`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`users_clients`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`users_providers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`users_scopes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`users_sessions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`users_sessionscopes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, as expected, there are much fewer tables generated than for the `Ormauth`
    driver.
  prefs: []
  type: TYPE_NORMAL
- en: The Parser package and template engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may notice that we added the `parser` package into the `always_load.package`
    key. Thanks to this package, instead of writing our view in PHP, we are able to
    use template engines. For those of you that are not familiar with template engines,
    they allows us to write our view files in a different syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, a list of items might be displayed by writing the following code
    in PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But, using the HAML template engine, it can be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, by using the Mustache template engine, it can be written like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are various reasons you might want to use template engines:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows you to write much more concise and elegant code, for example as in
    the HAML language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows you to keep a consistent code format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It forces you to separate logic from presentation. Thus, you can easily hand
    your code to a designer who can change it without having to understand any PHP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our project, we are going to use the Mustache template engine, but for none
    of the preceding reasons.
  prefs: []
  type: TYPE_NORMAL
- en: A major benefit of language-agnostic template engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you open the main web page of the Mustache template engine ([http://mustache.github.io/](http://mustache.github.io/)),
    you are going to see that the engine is available in many different languages
    (Ruby, JavaScript, Python, Node.js, PHP, Java, C++, ASP, C#, and so on). However,
    it doesn''t matter which language you are going to use the engine: the syntax
    of the template will remain the same and the language won''t have any influence
    on the code you will write. This is because Mustache is a language-agnostic template
    engine. This is a great advantage if you work with a team using many different
    languages such as PHP, JavaScript, Ruby, or Python; your views can be written
    in the same common markup language. We are going to use this feature to our own
    advantage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the most common way that websites work right now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A major benefit of language-agnostic template engines](img/5401OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'But you often need to dynamically load new content once your webpage is displayed
    in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A major benefit of language-agnostic template engines](img/5401OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to further illustrate this, let’s say we are displaying a user’s profile
    page, and thus displaying its list of posts. If the user has already published
    1000 posts, we won’t display them all at once. We will first display the last
    30 posts, for instance, using PHP views, so at some point the web page should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the visitor will scroll through the bottom of the web page, it will send
    an AJAX request to the server API that will replace the 30 previous posts, but
    in JSON format. The returned code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have all the necessary data, but we need to transform it to HTML code so
    that the user can see it. Whether you use jQuery or direct DOM manipulations,
    you will need to use JavaScript code to do this (that code will act as JavaScript
    views). This will lead to code duplication, in the sense that, if you change the
    way posts are displayed in the PHP views, you will need to change the JavaScript
    code as well. For large projects, this will quickly become unmanageable. However,
    all this can change if we use the mustache template engine
  prefs: []
  type: TYPE_NORMAL
- en: '![A major benefit of language-agnostic template engines](img/5401OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Nothing exceptional here. However, the process is improved when loading dynamic
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A major benefit of language-agnostic template engines](img/5401OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since the Mustache template engine is language agnostic, it is possible to interpret
    a single template in both PHP and JavaScript. If we want to change, let's say,
    how posts are displayed, all we have to do is to change this one template. No
    duplication always means a more robust and maintainable application.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we could always write a full JavaScript application that would load
    data from the API without using any PHP views. This way, no template engine would
    be necessary, as we would only write JavaScript views. However, being able to
    return HTML content directly from the server has two benefits. First, if the client
    doesn't support JavaScript—as is the case for most search engines—it will still
    be able to access the website (so the indexing of your application will be better).
    Secondly, when the client is accessing your website for the first time, you can
    speed up the process by returning the cached HTML code of the requested web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the Mustache template engine, we need to install it. In the
    `composer.json` file, add the following line in the `require` list (don''t forget
    to add a comma in the previous line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Then update Composer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We chose the Mustache engine mainly because of its simplicity, but you have
    a lot of other choices. If you want to use the API strategy we are going to implement
    in a more complex project, I recommend you take a look at more complete solutions.
    For instance, though they are not per se language-agnostic template engines, you
    could take a look at Smarty and its JavaScript port jSmart.
  prefs: []
  type: TYPE_NORMAL
- en: Subscription and authentication features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of generating entire scaffolds, we will manually create controllers
    and views as we won't need most CRUD features.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the subscription and authentication forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s create the user controller. Create a file at `APPPATH/classes/controller/user.php`
    and set its contents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The home page, which will be handled by the `index` action of the `User` controller,
    displays the user's posts if the user is logged in, otherwise it will display
    the subscription and authentication forms.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have no user in our system, nobody can log in. Thus, we will begin
    the subscription and authentication forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the following method in the `User` controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We will come back to this action later, but so far it should be pretty straightforward
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are using `Controller_Template`, we need to define a template. Create
    the template view file at `APPPATH/views/template.php` and set its contents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It is inspired by the admin template generated in [Chapter 3](ch03.html "Chapter 3. Building
    a Blog Application"), *Building a Blog Application* you can compare it to the
    file used for the scaffold generation located at `PKGPATH/oil/views/admin/template.php`.
    We use the Bootstrap framework to easily structure our web pages in a responsive
    way; we will use its CSS classes from time to time. You can take a look at the
    official documentation for Bootstrap at [http://getbootstrap.com/](http://getbootstrap.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also define some custom CSS classes inside the `website.css` file.
    Since we are already including it in our template, create the style sheet file
    at `public/assets/css/website.css` and set its contents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create the `APPPATH/views/user/connect.mustache` view. We need
    to add the sign up and sign in forms there, so no rocket science:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Since there are no dynamic parts in our view yet, you can see it is very similar
    to a classic PHP or HTML view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, as we want the `index` action of the `User` controller to be our home
    page, we need to define its URI in the `_root_` key of our `routes` configuration
    file. Open the `APPPATH/config/routes.php` configuration file and set its contents
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you request the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://mymicroblog.app/`'
  prefs: []
  type: TYPE_NORMAL
- en: You should see a simple yet responsive web page with sign up and sign in forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see what the web page looks like on large
    screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the subscription and authentication forms](img/5401OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is what the web page looks like on smaller screens and devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the subscription and authentication forms](img/5401OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handling the signup form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As no user exists right now, it is time to create the `signup` action in the
    `User` controller (targeted by the signup form) so that we can create our first
    user. Create the following method and read comments (you should already be familiar
    with all these methods):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now request the home page and fill the signup form correctly, a new
    user should be created in the `users` table. If something goes wrong (you enter
    an incomplete e-mail address or the username already exists for instance), an
    error message will be displayed but the form will be emptied since we go back
    to the home page. This is no big deal, but it could lower your transformation
    ratio. We saved the form data in the signup_form flash variable; therefore, it
    is now accessible in the `index` action. We will pass it to the view by replacing,
    in the `index` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To autofill the `username` field, open the `APPPATH/views/user/connect.mustache`
    view file and replace the `username` input in the signup form with the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we displayed the `$signup_form['username']` variable by writing
    `{{signup_form.username}}`. In a Mustache file, a `$var` variable is displayed
    by writing `{{var}}` and `$var['val_1']` is displayed by writing `{{var.val_1}}`.
    If `$var` is an object, `$var->val_1` is also displayed by writing `{{var.val_1}}`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also autofill the `email` field by adding `value="{{signup_form.email}}"`
    in the `email` input of the signup form.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the signin form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we can create new users, we need to handle the signin form. We will
    therefore create the `signin` action in the `User` controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is again very much inspired from the `admin` controller generated by the
    administration panel generator in `oil`; take a look at the `login` action of
    the `admin` controller (used for the administration panel generation) located
    at `PKGPATH/oil/views/admin/orm/controllers/admin.php`.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing the user to sign out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You probably noticed while testing the form that, once you successfully log
    in, you are unable to log out. Also, unless you have just successfully logged
    in, you don't have any idea whether you are logged in or not.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, we will display the username in the navigation bar and
    allow the user to sign out in a dropdown, as we did in the administration panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the template file located at `APPPATH/views/template.php`, and replace
    `<div class="navbar-header">...</div>` with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you are logged in, your username should now appear in the upper right side
    of your screen. If you click on your username, the **Sign out** link should appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have to implement this `signout` action inside the `User` controller.
    This step is pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Allowing the user to create and view posts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now allow users to create their own posts and display them in their
    profile page. Posts will also be the main information displayed by our API.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the Post model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need first to generate the Post model. As usual, we will use `oil`. Enter
    the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that we used the `--no-timestamp` parameter here. It simply prevents
    the automatic generation of the `created_at` and `updated_at` columns. Since we
    can have a lot of posts and the `updated_at` column then be useless, we generate
    the `created_at` column manually. As a consequence, we need to specify the `CreatedAt`
    observer ourselves. Open the Post model located at `APPPATH/classes/model/post.php`
    and add the following attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, simply execute your application migrations using `oil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Allowing the user to create new posts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will begin by implementing the user interface, and then we will implement
    the post creation action.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the user interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let''s add a **New post** button in the right side of the navigation
    bar. Open the template file located at `APPPATH/views/template.php` and just after
    `<ul class="nav navbar-nav pull-right">`, add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you refresh the home page and are signed in, you should see the button appear
    with a pencil icon inside it on the right-hand side of the navigation bar. We
    extensively used the Bootstrap framework, so it is recommended that you read the
    official documentation at [http://getbootstrap.com/](http://getbootstrap.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The important things to notice are the two attributes declared inside the link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that when we click on the link, we want Bootstrap to display a modal
    window using the content of the `div` element with `id = create_post_modal`. Thus,
    we need to define this `div` element. Before `</body>`, add the following lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This code was inspired from the live demo in the official documentation at [http://getbootstrap.com/javascript/#modals](http://getbootstrap.com/javascript/#modals).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following style in the `website.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'On clicking on the **New post** button, you should now see the following modal
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the user interface](img/5401OS_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, if you try to click on the **Submit** button, nothing will happen.
    We need to add some JavaScript code to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Since this won't be very short, first create a new JavaScript file at `public/assets/js/post_form.js`
    and include it in the template by adding `'post_form.js'`, after `'bootstrap.js'`,
    inside the `Asset::js` call in the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the newly created JavaScript file and set its contents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Read the comments in the preceding code. If you refresh the home page and try
    to submit a new post, the message **Sorry, it seems there was an issue somewhere.
    Please try again later.** will appear because we didn't implement the `post`/`create`
    action yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This line is problematic, because we are defining here the maximum number of
    characters a post can have, and we will need this information later when implementing
    our action (for validation). The best option is to define this information once
    so that, if we have to change it in the future, we only need to change one line.
    Therefore, we will write this variable in a configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the configuration file at `APPPATH/config/mymicroblog.php` and set its
    contents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Its access will be easy later in our action, but the configuration file''s
    content is currently inaccessible by our JavaScript code. In order to solve this
    issue, open the template view file located at `APPPATH/views/template.php`, and
    add the following lines of code after `$(function(){ $(''.topbar'').dropdown();
    });` inside the `script` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, go back to the `post_form.js` JavaScript file and replace `var postMaxNbCharacters
    = 140; // will be improved` with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When you have some common variables and constants between your JavaScript and
    your PHP code, it is always a good idea to adopt a similar solution.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the post creation action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will now handle the AJAX request, check the sent data, and create the post
    if everything is ok.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to create the `Post` controller. Create the `APPPATH/classes/controller/post.php`
    file and, for the moment, set its contents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we are extending a different controller class here; instead
    of `Controller_Template`, we are extending `Controller_Rest`. It is a basic controller
    with a RESTful support built in. It will allow us to easily implement the JSON
    response we will send, and it will also help us later when we will implement the
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, add the following test action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you request the following URL now:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://mymicroblog.app/post/test`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output should appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The requested REST method returned an array or object:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{ "test_1": 42, "test_2": "Answer to the Ultimate Question", "test_3": {
    "test_4": [ "test_5", "test_6", "test_7" ], "test_8": true, "test_9": null } }**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you request the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://mymicroblog.app/post/test.json`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you request the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://mymicroblog.app/post/test.xml`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you request the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://mymicroblog.app/post/test.php`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You should have understood by now that, depending on the extension defined in
    the requested URL, the action will return a result in the associated format. I
    recommend you to read the official documentation at [http://fuelphp.com/docs/general/controllers/rest.html#/formats](http://fuelphp.com/docs/general/controllers/rest.html#/formats)
    to see which formats are supported.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation can be accessed by opening the FuelPHP website and navigating
    to **DOCS** | **FuelPHP** | **General** | **Controllers** | **Rest**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A specific property of the REST controllers is that they allow you to implement
    actions that only answer to specific HTTP methods. For instance, if we had named
    our `action_test` method as `get_test`, the `test` action would have only responded
    to `GET` requests. The same is true for `POST`, `PUT`, `DELETE`, and `PATCH` requests;
    you are again recommended to read the official FuelPHP documentation about REST
    controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the `test` action and add the following `create` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you try to add a new valid post, a new row should be added in the `posts`
    table and the following message should appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Your post has been successfully published!**'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Though we are sending a JSON response, we don't consider the `create` action
    as a part of the application API. As written earlier, our API will only allow
    read-only access and no authentication will be required; the action doesn't observe
    any of those requirements. However, the fact that it returns JSON content (as
    well as other formats) is a good start if you want to integrate it into an API.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the profile page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we can create posts now, it would be great to display them. As we wrote
    in the specification, the user profile page displays the list of published posts,
    so we will implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We would like to display this profile page when requesting the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://mymicroblog.app/USERNAME`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could add a parameter to the `index` action of the `User` controller, but
    that would unnecessarily complicate the action. Instead of doing that, we are
    going to use routes to transparently reroute those URLs to the `show` action of
    the `User` controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://mymicroblog.app/user/show/USERNAME`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, open the `APPPATH/config/routes.php` configuration file and add
    the following line at the end of the returned array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Creating the user model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside the `show` action, we will have to request a user from the database.
    We will create the user model to do this more easily. Create the `APPPATH/classes/model/user.php`
    file and set its contents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the show action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will now implement the `show` action inside the `User` controller, as we
    had done previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few more things that we need to do. First, you can see we specified
    `''related'' => ''user''` when finding posts, but we didn''t declare this relation
    inside the Post model. Fix that by opening the Post model and adding the following
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the User model, you might have seen that we get the number of posts
    to load from the configuration `\Config::get(''mymicroblog.pagination_nb_posts'')`.
    We need to specify this configuration item inside the `APPPATH/config/mymicroblog.php`
    file. Inside the returned array, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'But there is still an issue; we haven''t loaded the configuration file yet,
    so `\Config::get(''mymicroblog.pagination_nb_posts'')` will return `null`. We
    could load the configuration file in the same action, but since we are going to
    need it elsewhere, we are going to load it in the `before` method. This method
    is called before any action is executed. Add the following line in the beginning
    of the `User` controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If we want this action to work, we still need to implement the `user/show.mustache`
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, create the `APPPATH/views/user/show.mustache` view file and set its
    contents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The only new syntax that is `{{> post/list}};` it means we want to display
    the `post/list` partial, and its PHP equivalent looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We have separated the `post` listing because we will need to display it on
    other actions. Therefore, the next logical step is to implement this partial.
    Create the `APPPATH/views/post/list.mustache` view file and set its contents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We just implemented a simple `div` element and called another partial inside
    it. This new partial will only display the content of the list. Create the `APPPATH/vi`
    `ews/post/inside_list.mustache` view file and set its contents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand this, you need to understand a new Mustache tag. The `{{#posts}}`
    and `{{/posts}}` tags are implemented here to loop over the `posts` array. The
    content within these two tags will be repeated for each post. Variables displayed
    inside this loop will either be previously declared variables, or the properties
    of the current post in the loop; for instance, `{{created_at}}` is the `created_at`
    attribute of the current post in the loop, but we could display `{{independent_variable}}`,
    which would not be an attribute of the current post but of a previously declared
    variable. Take a look at the official documentation to understand how variables
    are resolved (the second link is hosted on the repository of the PHP port of Mustache
    but is quite complete and clear):'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://mustache.github.io/mustache.5.html](http://mustache.github.io/mustache.5.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/bobthecow/mustache.php/wiki/Variable-Resolution](https://github.com/bobthecow/mustache.php/wiki/Variable-Resolution)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, if you now try to access a profile page, only the username will be
    displayed even if this user created posts. This is because Mustache doesn''t know
    where to find partials. To solve this issue, open back the `User` controller and
    add the following lines of code at the end of the `before` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If you plan to use Mustache on modules, you will need to set other paths when
    calling the `setPartialsLoader` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now add some styles. Open the `public/assets/css/website.css` file
    and append the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If you refresh the profile page, the posts' list should appear now.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is still an issue though: no date is displayed. However, you have probably
    read how we displayed `created_at` in the `APPPATH/views/post/inside_list.mustache`
    view file, as shown in the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing is visible, but the timestamp can be accessed inside a `span` element
    with the `post_date` class. We want to display those dates in a relative format
    (for example, 5 minutes ago) and regularly update them. We will do this using
    JavaScript and jQuery. As this is a complex operation, we will create a new JavaScript
    file. Create the `public/assets/js/posts_dates.js` file and set its contents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need to include this script inside the template located at `APPPATH/views/template.php`.
    Add `'posts_dates.js'`, after `'post_form.js'`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have developed the first version of the profile pages, we will begin
    to implement the API to access our website data.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the base controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we will need methods on both the `User` and `Post` controllers, we will
    first implement a base controller that will be extended by both controllers. Create
    the `APPPATH/classes/controller/base.php` file and set its contents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You can see that `Controller_Base` is extending a new native controller named
    `Controller_Hybrid`. As its name suggests, it is a hybrid version implementing
    features from both `Controller_Template` and `Controller_Rest`. It is exactly
    what we need if we want an action to return JSON or HTML, depending on the context.
  prefs: []
  type: TYPE_NORMAL
- en: First, move the `before` method we implemented in the `User` controller inside
    this new `Base` controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, implement the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Each time we want a hybrid response (HTML, JSON, or XML depending on the extension
    requested), we will have to call the `hybrid_response` method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, make the `Post` and the `User` controllers extend this new `Base` controller.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing your first hybrid action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside the `show` action of the `User` controller, replace `$this->template->content
    = ...;` with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you request the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://mymicroblog.app/USERNAME.json`'
  prefs: []
  type: TYPE_NORMAL
- en: (Or `http://mymicroblog.app/USERNAME.xml`, as browsers generally display this
    format better)
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see that the data is now accessible. The problem is that you can read
    too much information:'
  prefs: []
  type: TYPE_NORMAL
- en: The most urgent issue is that we display all the attributes for each object.
    It is very problematic for user objects as we display their hashed passwords,
    their login hash, their e-mails, and possibly other confidential information.
    This is a very serious security issue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't need to display every time the same attributes of an object. For instance,
    we might want to release more information about a user when displaying its profile
    page, but only its username when displaying the `user` attribute of a post. This
    is less urgent, but still an important issue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing mappers to control how the information is shared
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to control which information is sent through the API, we will implement
    mappers that will transform our objects to appropriate associative arrays containing
    only the attributes we want to show. The mappers will map differently objects
    depending on the context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `APPPATH/classes/mapper.php` file and set its contents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now create the mappers for our Post and User models. First, create
    the `APPPATH/classes/mapper/post.php` file and set its contents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the `APPPATH/classes/mapper/user.php` file and set its contents
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we just have to use these mappers in our `show` action of the `User` controller.
    Inside the action, replace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'With the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you request the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://mymicroblog.app/USERNAME.json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://mymicroblog.app/USERNAME.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should see that only the useful information appears. You can always access
    `http://mymicroblog.app/USERNAME`, as the Mustache template engine processes objects
    and associative arrays in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some open source libraries provide tools that allow you to do a similar job
    that we did with our `mapper` classes, but in a standardized and more sophisticated
    way. If you are searching for one, I recommend that you take a look at the `fractal`
    library at [http://fractal.thephpleague.com/](http://fractal.thephpleague.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Improving the listing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The profile web pages are still incomplete as we only show the users' last 20
    posts. It would be great to improve this listing by adding a **See more** button
    that allows us to read older posts.
  prefs: []
  type: TYPE_NORMAL
- en: I recommended you to generate many posts (you could do that programmatically)
    on a profile in order to test our interface.
  prefs: []
  type: TYPE_NORMAL
- en: Giving JavaScript access to our Mustache views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we are going to transform JSON data to HTML content using JavaScript.
    Indeed, when you will for instance click on the **See more** button, an AJAX request
    will be sent toward our API that will return JSON data. We need to transform this
    JSON code to HTML content so that the viewer can read it but as we don't want
    any code duplication, we will give the JavaScript code access to our Mustache
    views. This will be done by copying all the Mustache files content into an object
    in the `public/assets/js/templates.js` JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the templates.js file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We will discuss two alternatives to generate the `template.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: The easy and dirty way
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The easy and dirty solution is to regenerate this file each time someone accesses
    your application in development mode. To do this, open a `APPPATH/bootstrap.php`
    file and add the following lines of code at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Even though we generate the file only on development mode, it can become unsustainable
    if you have a big application containing lots of templates; you will have latency
    and memory issues. You also might need to change some permission to allow the
    file to be created. In most cases, you should be ok though, and a good point of
    this solution is that it doesn't require any dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Using guard-templates
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Instead of generating the JavaScript file each time you request your application,
    you could use a utility such as guard-templates. The idea is that you launch this
    utility when you are coding your application, and that utility will track any
    file change and regenerate the JavaScript file when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please note that, at the time of writing, this utility doesn''t seem to work
    on Ubuntu: if that is still the case when you read the book, you are recommended
    to use the solution we provided in the last section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You first need Ruby and gem installed on your computer. Then, you must install
    the `guard-template` gem by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then execute the following command at the root of your website directory (as
    you did for `oil`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the generated `Guardfile` file at the root of your website directory;
    it contains a sample configuration of the guard-templates utility. Replace its
    content with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Understanding this configuration should be fairly easy. If you have any doubt,
    you can always check the official documentation at [https://github.com/thegreatape/guard-templates](https://github.com/thegreatape/guard-templates).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then launch `guard` by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: It will then generate the JavaScript file and regenerate it each time any Mustache
    template is changed.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating template.js and Mustache.js
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that our Mustache templates are stored into a JavaScript file, we have to
    integrate it into our website.
  prefs: []
  type: TYPE_NORMAL
- en: First, we must install `mustache.js`, which is the JavaScript port of Mustache.
    In order to do this, go to the `mustache.js` repository at [https://github.com/janl/mustache.js](https://github.com/janl/mustache.js).
  prefs: []
  type: TYPE_NORMAL
- en: Clone the repository or download and unzip the archive in the `public/assets/js/mustache`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also implement the `render` function, which is inspired from the `render`
    function of FuelPHP (the equivalent of `View::forge(...)->render()`). To do this,
    create the `public/assets/js/view.js` file and set its contents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to include our JavaScript files in the template. Open the `APPPATH/views/template.php`
    file and add the following lines of code after the `''bootstrap.js''`, line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Refresh your web page. If you open the JavaScript console (in your browser''s
    developer tools) now and execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You should see that it returns the correct HTML code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the post/list action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will also need to retrieve the posts data from the server. For this, we
    will implement two actions inside the `Post` controller: the `list` and `count`
    actions. Add the following code at the end of the `Post` controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get` and `count` actions call the `static::get_posts_query` method. We
    need to implement this method, and we will do that in the `Base` controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you request the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://mymicroblog.app/post/list.json?user_id=ID`'
  prefs: []
  type: TYPE_NORMAL
- en: It will return the 20 latest posts of the user with `id = ID`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you request the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://mymicroblog.app/post/list.json?user_id=ID&before_id=30`'
  prefs: []
  type: TYPE_NORMAL
- en: It will return the 20 latest posts with an `id` value less than `30` that have
    been published by the user with `id = ID`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you request the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://mymicroblog.app/post/list.json?user_id=ID&after_id=30`'
  prefs: []
  type: TYPE_NORMAL
- en: It will return the 20 latest posts with an `id` value greater than `30` that
    have been published by the user with `id = ID`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you request the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://mymicroblog.app/post/count.json?user_id=ID`'
  prefs: []
  type: TYPE_NORMAL
- en: It will return the number of posts published by the user with `id = ID`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you request the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://mymicroblog.app/post/count.json?user_id=ID&before_id=30`'
  prefs: []
  type: TYPE_NORMAL
- en: It will return the number of posts with an `id` value less than `30` that have
    been published by the user with `id = ID`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you request the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://mymicroblog.app/post/count.json?user_id=ID&after_id=30`'
  prefs: []
  type: TYPE_NORMAL
- en: It will return the number of posts with an `id` value greater than `30` that
    have been published by the user with `id = ID`.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `count` action later, when we will need to know if any posts
    have been published since we displayed a user profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'To limit code duplication, in the `show` action of the `User` controller, replace
    `$posts = Model_Post::find(''all'', ...);` with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Preventing any duplication inside the controllers is ok, but if you need to
    implement a lot of code and methods similar to `get_posts_query` inside a controller,
    something is wrong with your implementation. You should think about moving some
    pieces of code in models, helpers, or libraries. I must say I hesitated a bit
    about where this method should be implemented, but I decided to implement it in
    the `Base` controller since it would be more convenient. In general, be wary of
    long pieces of code inside a controller, as they should not contain too much logic.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the See more button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will need to do some changes in the views. First, open `APPPATH/views/post/inside_list.mustache`
    and replace `<div class="post">` with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'It will allow us to identify which posts are already displayed. Then, open
    the `APPPATH/views/post/list.mustache` view and replace `<div class="row post_list">`
    with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow us to know the user identifier when requesting for more posts.
    Then, add the following lines of code after `{{> post/inside_list}}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the button is added, we need to specify what will happen when we click
    on it so we will code it on a new JavaScript file. Create the `public/assets/js/posts_list.js`
    file and set its contents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to include this JavaScript file in the template. Open the template
    and add `'posts_list.js'`, after `'posts_dates.js'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add the following CSS code at the end of the `public/assets/css/website.css`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The **See more** button should now work when you have more than 20 posts in
    a profile page. It could be perfected in many ways. For instance, when there are
    less than 20 posts in a profile, the button is first visible, but if you click
    on it, it will simply disappear as there are no more posts to show. There are
    many easy ways to solve this small problem, so we will leave it to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'One improvement that could come in handy for those readers that are not very
    familiar with JavaScript is infinite scrolling. Open the `public/assets/js/posts_list.js`
    file and replace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'With the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Redirecting the home page to the logged user's web page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the user is connected, we want to redirect the home page to his web page
    so they can take a look at their posts. In order to do this, go to the `index`
    action of the `User` controller and in place of the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: That is optional, but you might also want to change and add some `Response::redirect`
    calls inside the `signin` action of the `User` controller to make things a bit
    cleaner (without changing anything the user will be redirected twice when signing
    in).
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests are particularly suitable for this project, as it is important to
    regularly check if the API is returning the correct data. We will in this section
    quickly introduce you to how unit tests are implemented in FuelPHP. These tests
    will be very superficial as this is just an introduction. If you are not familiar
    with unit tests, you can start by reading the FuelPHP documentation about unit
    testing at [http://fuelphp.com/docs/general/unit_testing.html](http://fuelphp.com/docs/general/unit_testing.html).
  prefs: []
  type: TYPE_NORMAL
- en: The documentation can be accessed at the FuelPHP website by navigating to **DOCS**
    | **FuelPHP** | **General** | **Unit Testing**.
  prefs: []
  type: TYPE_NORMAL
- en: For more general information, you can look at the Wikipedia web page for more
    references ([http://en.wikipedia.org/wiki/Unit_testing](http://en.wikipedia.org/wiki/Unit_testing)).
  prefs: []
  type: TYPE_NORMAL
- en: To make things short, unit tests allow you to test individual units in your
    code, such as methods or classes, to check if they work as intended. In most cases,
    they are executed regularly to check if there is no regression in your project.
    In the Test Driven Development process, tests are even written before the code
    and are used as some sort type of unit specification. In that development process,
    developers first define how a method should work in unit tests, and then they
    implement the method and check that it passes all the tests and assertions (assertions
    are conditions that must be met) they have previously written.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests should be separated from Integration tests, that test a group of
    units and how they function together, Functional tests that check that your projects
    follow its functional requirements, and Acceptance tests that check that final
    features accessed by users are working as it is expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing unit tests, you should try at least to stick with the following
    guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Each unit test should only test a single code unit (generally methods, but sometimes
    classes) at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to write as few assertions as possible to test features, as unnecessary
    assertions lead to less maintainability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests should be independent from each other. For instance, you should not write
    a unit test that supposes another unit test has been run before.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each unit test purpose should be clear: Its name should be explicit and the
    code should be easy to understand (don''t hesitate to use comments).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's see in practice how to run unit tests in FuelPHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to install PHPUnit. To do that, enter the following command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'While PHPUnit is downloaded and installed, create the `APPPATH/config/oil.php`
    configuration file and set its contents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Once PHPUnit is installed, you can launch tests. First, simply execute the
    following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `375` tests already exist and the `php oil test` command line
    executed all of them. These tests are all in the FuelPHP core and can be found
    in the `fuel/core/tests` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create our own tests. Create the `APPPATH/tests/examples.php`
    file and set its contents to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: All methods beginning with `test` will be executed when running this test file.
    Read the comments in the preceding code and read the official documentation of
    PHPUnit for more information ([https://phpunit.de](https://phpunit.de)).
  prefs: []
  type: TYPE_NORMAL
- en: When you are running test files, FuelPHP is in the test environment. Therefore,
    you have to configure the database access in the `APPPATH/config/test/db.php`
    file. It is recommended that you create a separate database for unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run only your application tests by executing the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The tests have been correctly executed. However, as explained at the beginning
    of this section, we have written very superficial tests. If you want to have good
    test coverage of your application, you will need to write many more tests.
  prefs: []
  type: TYPE_NORMAL
- en: Possible improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, you should protect all your forms from **Cross-Site Request Forgery**
    (**CSRF**) attacks as we did in [Chapter 3](ch03.html "Chapter 3. Building a Blog
    Application"), *Building a Blog Application*. As you are using Mustache templates,
    you will need to do things a little bit differently here (for instance, you will
    need to write your CSRF input in plain HTML). I recommend you read the official
    documentation at [http://fuelphp.com/docs/general/security.html#csrf](http://fuelphp.com/docs/general/security.html#csrf).
  prefs: []
  type: TYPE_NORMAL
- en: The documentation can be accessed on the FuelPHP website by navigating to **DOCS**
    | **FuelPHP** | **General** | **Security**.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, if you want to make your API easily available using JavaScript on
    an external website, you have to set the Access-Control-Allow-Origin header to
    `*`. This can be done in the `before` method inside the `Base` controller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we only used the `post/inside_list` partial in the JavaScript side of
    our application, but we could have done much more. For instance, since all the
    data is available, instead of loading the profile page HTML version when we click
    on a username, we could load the JSON data and use our partials to display the
    profile page.
  prefs: []
  type: TYPE_NORMAL
- en: Our microblog application is still very basic. However, we could manage subscriptions,
    notifications, mentions, and direct messages; allow the users to search for posts
    and other users; automatically transform URLs in posts; improve the user interface...
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built a basic microblogging application that supports several
    features such as user subscription, authentication, post creation, and profile
    pages. We have seen that an API can be implemented without any code duplication
    and much effort, if it is handled correctly. We have also used Mustache, a language-agnostic
    template engine, which allowed us to use the same views in the server (PHP) and
    client (JavaScript) sides. Finally, we have used unit tests to check whether the
    features of our application are behaving as expected.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce you to Novius OS, a Content Management
    System based on the FuelPHP framework.
  prefs: []
  type: TYPE_NORMAL
