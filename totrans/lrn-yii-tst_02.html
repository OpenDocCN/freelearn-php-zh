<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Tooling up for Testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Tooling up for Testing</h1></div></div></div><p>In this chapter, we're going to have an overview of Yii 2, what has changed since the last version, with which you might have become comfortable its new directory structure and organization, as well as its new features and niceties.</p><p>We cannot introduce Yii 2 without looking at <a id="id42" class="indexterm"/>
<span class="strong"><strong>Composer</strong></span>, a new way to organize and extend your projects in PHP.</p><p>Once we have had a look at all the basic tools we're going to use, let's review our plan and consider what we will be working on in the rest of this book: user authentication REST interface and user login from a modal window.</p><p>In order to start working on our features, we need to step aside and review our plan from a project management and quality assurance point of view, that is, introduce the master test plan. In other words, we need to consider what we are going to test and how much before undertaking the actual implementation work.</p><p>We will be working through the following steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Downloading and installing Yii 2</li><li class="listitem" style="list-style-type: disc">Finding your way around Yii 2</li><li class="listitem" style="list-style-type: disc">Defining our working strategy</li><li class="listitem" style="list-style-type: disc">Introducing testing for our purposes</li></ul></div><div class="section" title="Downloading and installing Yii 2"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Downloading and installing Yii 2</h1></div></div></div><p>If you've worked <a id="id43" class="indexterm"/>with Yii in the past, be prepared. The new version of Yii 2 can be considered as a brand new framework, modern and robust.</p><p>Yii 2 takes a long-awaited step forward in the right direction. It is the result of several years of work, done collaboratively on <a id="id44" class="indexterm"/>the Internet, mostly on GitHub (<a class="ulink" href="https://github.com/yiisoft/yii2">https://github.com/yiisoft/yii2</a>), by developers from different parts of the world.</p><p>As a user of Yii, you can collaborate too, by simply filing bug reports, feature requests at <a class="ulink" href="https://github.com/yiisoft/yii2/issues">https://github.com/yiisoft/yii2/issues</a>, polishing <a id="id45" class="indexterm"/>off the documentation and translations, and creating new extensions and features for review and inclusion on the project. There are<a id="id46" class="indexterm"/> also many other non-officially supported subprojects that can benefit from your support: some already there for you to use, and some that you may have written yourself.</p></div></div>
<div class="section" title="Environment and workflow"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Environment and workflow</h1></div></div></div><p>As a developer, you<a id="id47" class="indexterm"/> will have your own environment with which you need to feel confident enough, and which can actually help you writing the code without many worries. If you do feel that there's a gap between writing the code and seeing the actual result, then there's something you need to fix.</p><p>It's quite important for the purpose of this book to outline my optimal environment that I will use throughout the upcoming chapters and code samples that you will find.</p><p>I will, of course, note when the environment might make a difference, but be wary that, if your environment is different, you may need to check the developer's documentation or reach out to anyone who might know the answer, in case something is not working.</p><p>My <a id="id48" class="indexterm"/>personal <a id="id49" class="indexterm"/>development environment is composed of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A robust <a id="id50" class="indexterm"/><span class="strong"><strong>Integrated Development Environment</strong></span> (<span class="strong"><strong>IDE</strong></span>), such as IntelliJ PHPStorm, rather than a simple code editor (for example, VIM): You get some additional benefits from it, for example, an integrated debugger, a syntax checker, a code hinting system, and so forth.</li><li class="listitem" style="list-style-type: disc">A modern version control system (for example, GIT): Commit always and often. It's the only way for you to understand the history and control the changes in your project in a sensible way. Head over to <a class="ulink" href="http://git-scm.com/doc">http://git-scm.com/doc</a> if you need more information and learn by visually experimenting with it at <a class="ulink" href="http://pcottle.github.io/learnGitBranching/">http://pcottle.github.io/learnGitBranching/</a>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Linux Apache MariaDB PHP</strong></span> (<span class="strong"><strong>LAMP</strong></span>) box <a id="id51" class="indexterm"/>packaged as a virtual machine: I've passed through the stage of having my own machine acting as my LAMP box, but this has proved to be too unreliable for many reasons. Mostly because after a while, you will end up confusing experimental plugins and tools that are not meant to be used on certain projects, potentially messing up your work.</li></ul></div><p>A development or testing environment is usually quite simple to set up as it won't require an extensive configuration, as it would do in a critical or production environment.</p><p>One of the reasons in favor of having such an environment setup, in particular with reference to the LAMP box, is the ability to configure it as you wish based on the project you're working on, and in particular being able to replicate the live/production environment as close as possible. This has a clear advantage when it comes to the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Working within a team with more than one developer</li><li class="listitem" style="list-style-type: disc">Replicating bugs occurring on any environment (for example, test, stage, or live)</li></ul></div><p>Vagrant <a id="id52" class="indexterm"/>is probably the tool you're looking for if you want to start easy (see <a class="ulink" href="http://www.vagrantup.com/">http://www.vagrantup.com/</a>), and if <a id="id53" class="indexterm"/>it convinces you, it might be worth giving the book, <span class="emphasis"><em>Creating Development Environments with Vagrant</em></span>, <span class="emphasis"><em>Michael Peacock</em></span>, <span class="emphasis"><em>Packt Publishing</em></span>, a shot (<a class="ulink" href="http://www.packtpub.com/creating-development-environments-with-vagrant/book">http://www.packtpub.com/creating-development-environments-with-vagrant/book</a>).</p><p>PHP does not need <a id="id54" class="indexterm"/>major adjustments, and I believe a default PHP installation will suffice to get you started as this is the only constraint for running Yii 2. Be sure to have a version equal to or above 5.4, and have a CLI PHP available on the command line, by issuing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php –v</strong></span>
<span class="strong"><strong>PHP 5.5.22-1+deb.sury.org~precise+1 (cli) (built: Feb 20 2015 11:25:06) </strong></span>
<span class="strong"><strong>Copyright (c) 1997-2015 The PHP Group</strong></span>
<span class="strong"><strong>Zend Engine v2.5.0, Copyright (c) 1998-2015 Zend Technologies</strong></span>
<span class="strong"><strong>    with Zend OPcache v7.0.4-dev, Copyright (c) 1999-2015, by Zend Technologies</strong></span>
<span class="strong"><strong>    with Xdebug v2.2.5, Copyright (c) 2002-2014, by Derick Rethans</strong></span>
</pre></div><p>The preceding output is from a Vagrant machine running Ubuntu 12.04 with PHP 5.5 installed.</p><p>The dollar sign (<code class="literal">$</code>) means the command can be run by a user and you won't need administrative permissions to run it.</p><p>If you get a <code class="literal">command not found</code> error, be sure to refer to your distribution/OS vendor for support on how to install it. Most of the distributions provide it by default, while others require additional configuration parameters or packages.</p></div>
<div class="section" title="Introducing Composer"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Introducing Composer</h1></div></div></div><p>As you might <a id="id55" class="indexterm"/>well know, Yii 1 was (initially) shipped as a standalone library that needed installation on the target environment, and from there you could use its CLI interface to create your web app. After that, the library would be sitting somewhere in your filesystem to be directly called by the web app upon loading it.</p><p>When Yii started, this was common practice; there wasn't a way to keep the code self-contained and you could easily get into several problems whenever you needed to ship the code to shared hosting environments (I'm looking at you Plesk/OpenBaseDir restriction).</p><p>Secondly, system-wide packages and dependencies were often restricting the developers to embrace new features and work around existing bugs, without even counting that these were (too) often overlooked. If you've been working on the web with PHP for quite a while, I'm pretty sure you've experienced the sense of lagging behind other big frameworks on the development scene (and not just in PHP-land).</p><p>Composer (<a class="ulink" href="http://getcomposer.org">http://getcomposer.org</a>) solves<a id="id56" class="indexterm"/> the problem under many aspects, and thanks to the efforts of Nils Adermann, Jordi Boggiano, and many community contributions, it was first released in 2012.</p><p>Composer takes inspiration from Node.js' <span class="strong"><strong>npm</strong></span> <a id="id57" class="indexterm"/>and Ruby's<a id="id58" class="indexterm"/> <span class="strong"><strong>bundler</strong></span>. It provides a way to define and install dependencies (that is, libraries), and install web applications that are available from<a id="id59" class="indexterm"/> Packagist (<a class="ulink" href="https://packagist.org/">https://packagist.org/</a>) on a per-project basis.</p><div class="section" title="Installing and using it"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Installing and using it</h2></div></div></div><p>Let's start by following the<a id="id60" class="indexterm"/> installation guide proposed on the<a id="id61" class="indexterm"/> Composer website (<a class="ulink" href="https://getcomposer.org/doc/00-intro.md#installation-nix">https://getcomposer.org/doc/00-intro.md#installation-nix</a>). Consider the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -s https://getcomposer.org/installer | php</strong></span>
</pre></div><p>In the preceding command we are using <code class="literal">curl</code> to download the installer and <code class="literal">php</code> to parse it and output an executable PHP file called <code class="literal">composer.phar</code>. Be mindful that the installation under a different OS (in case you don't have a Linux box to play with) varies, for example, under OS X, Composer is part of the <code class="literal">homebrew-php</code> project<a id="id62" class="indexterm"/> at <a class="ulink" href="https://github.com/Homebrew/homebrew-php">https://github.com/Homebrew/homebrew-php</a>.</p><p>At this point, you can simply call Composer directly using a relative or absolute path, as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ php composer.phar</strong></span>
</pre></div><p>Or move it into <a id="id63" class="indexterm"/>a more appropriate position for easier invocation, as you will see next.</p><p>If you can run sudo or log in as root, move it into a system wide <code class="literal">bin</code> folder, as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo mv composer.phar /usr/local/bin/composer</strong></span>
</pre></div><p>If the preceding<a id="id64" class="indexterm"/> option does not apply, you can install it in user-space, for example, <code class="literal">~/bin/</code>, and then add the path to your <code class="literal">PATH</code> environment variable, as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mv composer.phar ~/bin/composer</strong></span>
<span class="strong"><strong>$ PATH=$PATH:~/bin/; export PATH</strong></span>
</pre></div><p>The last command is adding the path to your terminal environment, so it can be invoked from anywhere you are in the filesystem. This specific command would need to be issued every time you open a terminal.</p><p>Otherwise, you can add it permanently, as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo "export PATH=$PATH:~/bin/;" &gt;&gt; ~/.bashrc</strong></span>
</pre></div><p>By adding the <code class="literal">export</code> statement to your <code class="literal">.bashrc</code> (<code class="literal">&gt;&gt; ~/.bashrc</code> appends the output of <code class="literal">echo</code> to the end of the <code class="literal">.bashrc</code> file), you are simply making the directory searchable automatically every time you log in, given you are using BASH as shell interpreter.</p><p>If you're unsure which shell you're on, you can check using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo $0</strong></span>
</pre></div><p>However, while this will work on most shells and it's quite easy to remember, it won't work if your shell is CSH, in which case, use the more complex but also more portable <code class="literal">ps</code> invocation, as shown in the following: command</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ps -p $$ -o cmd=''</strong></span>
</pre></div><p>Once you have installed Composer, you can simply invoke it using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ composer</strong></span>
</pre></div><div class="section" title="The composer.json and composer.lock files"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>The composer.json and composer.lock files</h3></div></div></div><p>Composer <a id="id65" class="indexterm"/>works by reading the <code class="literal">composer.json</code> file found<a id="id66" class="indexterm"/> in the root of your project, which will contain all the requirements and dependencies:</p><div class="informalexample"><pre class="programlisting">composer.json

{
  "require": {
    "twig/twig": "1.16.*"
  }
}</pre></div><p>The preceding snippet is quite clear: it's defining a dependency of our project on <a id="id67" class="indexterm"/>Twig (<a class="ulink" href="http://twig.sensiolabs.org/">http://twig.sensiolabs.org/</a>). This is a<a id="id68" class="indexterm"/> template engine with a clear and compact syntax. It's also defining a specific dependency on any version of Twig starting with 1.16.</p><p>Modifying the <code class="literal">composer.json</code> file by hand <a id="id69" class="indexterm"/>can be prone to human errors, and sometimes it might be necessary, as we will see later on, to add the packages to your <code class="literal">require</code> or <code class="literal">require-dev</code> section via the command line using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ composer require "twig/twig:1.16.*"</strong></span>
</pre></div><p>This way the <code class="literal">composer.json</code> file will be automatically created if it does not already exist, and the package with its dependencies will be installed for you. Alternatively, if you've created the file yourself or if you've received the file as part of a project, you can invoke the <code class="literal">install</code> command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ composer install</strong></span>
<span class="strong"><strong>Loading composer repositories with package information</strong></span>
<span class="strong"><strong>Installing dependencies (including require-dev)</strong></span>
<span class="strong"><strong>  - Installing twig/twig (1.6.5)</strong></span>
<span class="strong"><strong>    Downloading: 100%         </strong></span>

<span class="strong"><strong>Writing lock file</strong></span>
<span class="strong"><strong>Generating autoload files</strong></span>
</pre></div><p>The normal behavior of the preceding command is to fetch the required packages as archives (called dist in composer jargon) for stable sources, or via repository if either the dist is not available or if the package is in some stage that is not stable (for example, beta or dev).</p><p>You can change this<a id="id70" class="indexterm"/> behavior by using the <code class="literal">--prefer-dist</code> option to force searching for the dist even for development packages, or <code class="literal">--prefer-source</code> to force the checkout from repository rather than dist for stable packages.</p><p>As you will see by <a id="id71" class="indexterm"/>listing the content of the directory, Composer will install all libraries into your project folder under the <code class="literal">/vendor</code> directory and create a <code class="literal">composer.lock</code> file in the root folder that will hold a snapshot of the current state of the installation, locking the installed libraries to the specific version defined in the lock file, as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ tree -L 2</strong></span>
<span class="strong"><strong>.</strong></span>
<span class="strong"><strong>├── composer.json</strong></span>
<span class="strong"><strong>├── composer.lock</strong></span>
<span class="strong"><strong>└── vendor</strong></span>
<span class="strong"><strong>    ├── autoload.php</strong></span>
<span class="strong"><strong>    ├── composer</strong></span>
<span class="strong"><strong>    └── twig</strong></span>
</pre></div><p>When sharing your code, you need to commit the <code class="literal">composer.lock</code> file, so everyone in your team and any other environment you will deploy to will run exactly the same version of the dependencies you have, mitigating the risk of bugs affecting only some environments. Composer will look for the lock file first before deciding to use the JSON file to download a more up-to-date version based on the definitions.</p><p>On the other hand, it is not recommended to commit the <code class="literal">/vendor</code> directory to your VCS as it can cause several problems, such as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Difficulty in handling revisions and updates</li><li class="listitem" style="list-style-type: disc">Increased size of the repository without any benefit</li><li class="listitem" style="list-style-type: disc">In Git, it could cause problems if you're adding packages checked out via Git, as it will show them as submodules, while they're not.</li></ul></div><p>This heavily depends on your deployment policy, but, in general, it will be better to have your environments and team mates run the <code class="literal">composer install</code> command on their own.</p><p>If you ever need to update the dependencies, you can simply issue the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ composer update</strong></span>
</pre></div><p>Or to update a<a id="id72" class="indexterm"/> specific <a id="id73" class="indexterm"/>package, the command will be the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ composer update twig/twig [...]</strong></span>
</pre></div><p>The <code class="literal">[...]</code> means you can add as many packages to be updated with a single command.</p></div><div class="section" title="Packages and Packagist"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Packages and Packagist</h3></div></div></div><p>By <a id="id74" class="indexterm"/>creating the <code class="literal">composer.json</code> file, you are also defining your project as a package. This is a package that depends on other packages. The only difference is that your project is without a name, yet.</p><p>Composer can help<a id="id75" class="indexterm"/> you here in defining your project/package in a more consistent and clear way. Consider the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ composer init</strong></span>
</pre></div><p>This will start by asking you for some basic information regarding your project, including the requirements that you want for your project, and then create (or overwrite) the <code class="literal">composer.json</code> file, as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Package name (&lt;vendor&gt;/&lt;name&gt;) [peach/yii2composer]:</strong></span>
<span class="strong"><strong>Description []: Installing Yii 2 from scratch with composer</strong></span>
<span class="strong"><strong>Author [Matteo 'Peach' Pescarin &lt;my@email.com&gt;]:</strong></span>
<span class="strong"><strong>Minimum Stability []: dev</strong></span>
<span class="strong"><strong>License []: GPL-3.0</strong></span>
</pre></div><p>Among these, the one worth noticing is the <code class="literal">Minimum Stability</code> option: it provides a way to control the stability of the packages. By omitting it, it defaults to stable. This option combined with <code class="literal">"prefer-stable": true</code> (or <code class="literal">false</code> if you want to have the dev versions of your dependencies) will give you enough power to decide the policy of stability of the dependencies where this is not explicitly defined.</p><p>It will then move into setting the dependencies interactively, as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Define your dependencies.</strong></span>

<span class="strong"><strong>Would you like to define your dependencies (require) interactively [yes]?</strong></span>
<span class="strong"><strong>Search for a package []: twig</strong></span>

<span class="strong"><strong>Found 15 packages matching twig</strong></span>

<span class="strong"><strong>   [0] twig/twig</strong></span>
<span class="strong"><strong>   ...</strong></span>

<span class="strong"><strong>Enter package # to add, or the complete package name if it is not listed []: 0</strong></span>
<span class="strong"><strong>Enter the version constraint to require []: @dev</strong></span>
</pre></div><p>The search can be anything, and it<a id="id76" class="indexterm"/> works the same way as you would by searching on the <a id="id77" class="indexterm"/>website (<a class="ulink" href="https://packagist.org">https://packagist.org</a>). If you want to have a more clear idea of<a id="id78" class="indexterm"/> what you're going to install, you probably want to have a look at the website: you need to be aware of the dependencies and browse the code to check it does what it says on the tin.</p><p>Knowing how to use the version constraints can be quite important in any project with just a few dependencies. According to <a class="ulink" href="https://getcomposer.org/doc/01-basic-usage.md#package-versions">https://getcomposer.org/doc/01-basic-usage.md#package-versions</a>, the following are the possible keywords you need to be aware of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Exact version</strong></span>: For example, <code class="literal">1.0.23</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Range</strong></span>: For example, <code class="literal">&gt;=1.2</code> or <code class="literal">&gt;=1.0,&lt;2.0</code> or use the pipe as a logical OR as <code class="literal">&gt;=1.0,&lt;2.0 | &gt;=3.0</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Wildcard</strong></span>: For example, <code class="literal">1.2.*</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Tilde operator</strong></span>: Here, <code class="literal">~1.2</code> is the <a id="id79" class="indexterm"/>same as <code class="literal">&gt;=1.2,&lt;2.0</code>; <code class="literal">~1.2.3</code> is the same as <code class="literal">&gt;=1.2.3,&lt;1.3</code> (semantically: <code class="literal">[[[[...]c.]b.]a.]x</code>, where <code class="literal">x</code> is the only variable)</li></ul></div><p>Composer <a id="id80" class="indexterm"/>provides <a id="id81" class="indexterm"/>further granularity when selecting specific packages, specifically you can filter by stability by adding <code class="literal">@dev</code> (or <code class="literal">alpha</code>, <code class="literal">beta</code>, <code class="literal">RC</code> or <code class="literal">stable</code>).</p><p>Sometimes, you<a id="id82" class="indexterm"/> are forced to use an unstable version, either because of the lack of a stable version or because the stable version ships with a bug that has been fixed in the master (dev)!</p><p>Together with <code class="literal">require</code>, which defines the list of fundamental packages that are a direct dependency, <code class="literal">require-dev</code> defines instead the secondary packages used for development, such as libraries for running tests, performing debugging, and so on. However, these are not fundamental for the application to work, as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Would you like to define your dev dependencies (require-dev) interactively [yes]?</strong></span>
</pre></div><p>You can also skip adding packages for <code class="literal">require</code>, and then add them later using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ composer require</strong></span>
</pre></div><p>While for <code class="literal">require-dev</code>, at <a id="id83" class="indexterm"/>least with the version I've got installed at the time of writing this book, you need to add them manually as seen at the beginning.</p><p>At this point of<a id="id84" class="indexterm"/> the process, you'll be able to review the JSON that will be written before confirming it, as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>    "name": "peach/composer",</strong></span>
<span class="strong"><strong>    "description": "A Composer project",</strong></span>
<span class="strong"><strong>    "require": {</strong></span>
<span class="strong"><strong>        "twig/twig": "@dev"</strong></span>
<span class="strong"><strong>    },</strong></span>
<span class="strong"><strong>    "license": "GPL-3.0",</strong></span>
<span class="strong"><strong>    "authors": [</strong></span>
<span class="strong"><strong>        {</strong></span>
<span class="strong"><strong>            "name": "Matteo 'Peach' Pescarin",</strong></span>
<span class="strong"><strong>            "email": "my@email.com"</strong></span>
<span class="strong"><strong>        }</strong></span>
<span class="strong"><strong>    ],</strong></span>
<span class="strong"><strong>    "minimum-stability": "dev"</strong></span>
<span class="strong"><strong>}</strong></span>

<span class="strong"><strong>Do you confirm generation [yes]?</strong></span>
<span class="strong"><strong>Would you like the vendor directory added to your .gitignore [yes]?</strong></span>
<span class="strong"><strong>$</strong></span>
</pre></div><p>Once you've got your <code class="literal">composer.json</code> file created, you can edit it and tweak it to your liking. There are many other options that can be specified. Refer to <a class="ulink" href="https://getcomposer.org/doc/04-schema.md">https://getcomposer.org/doc/04-schema.md</a>.</p><p>By compiling your <code class="literal">composer.json</code> file, you are actually creating a package yourself that could be shared on Packagist with other developers.</p><p>The process itself is not particularly difficult, as you just need to add a few additional options, as defined in the JSON schema documentation (<a class="ulink" href="https://getcomposer.org/doc/04-schema.md#the-composer-json-schema">https://getcomposer.org/doc/04-schema.md#the-composer-json-schema</a>), and publish your code using a Git, subversion or mercurial repository. You can also decide to publish just a dist package. Refer to the documentation at <a class="ulink" href="https://getcomposer.org/doc/">https://getcomposer.org/doc/</a> for more information if you want to take a step in this direction.</p><p>Once you've<a id="id85" class="indexterm"/> created your <code class="literal">composer.json</code> file, you can start installing all the dependencies as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ composer install --prefer-dist</strong></span>
</pre></div><p>Composer lets you <a id="id86" class="indexterm"/>decide how to fetch all the requirements and, in this particular case, we gave preference to dist files when available. The result is the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Loading composer repositories with package information</strong></span>
<span class="strong"><strong>Installing dependencies (including require-dev)</strong></span>
<span class="strong"><strong>  - Installing twig/twig (dev-master 72aa82b)</strong></span>
<span class="strong"><strong>    Downloading: 100%         </strong></span>

<span class="strong"><strong>Writing lock file</strong></span>
<span class="strong"><strong>Generating autoload files</strong></span>
<span class="strong"><strong>$</strong></span>
</pre></div></div></div><div class="section" title="Creating your first web app"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Creating your first web app</h2></div></div></div><p>At this point, you <a id="id87" class="indexterm"/>should have gained enough confidence with Composer to be able to undertake the next step. But before doing this, forget what you've learned!</p><p>Creating a <code class="literal">composer.json</code> file and requiring a bunch of packages can be done by anyone. With Composer, you can create a project from a given package. This means that the package will be extracted into a specified directory (not <code class="literal">/vendor</code> anymore). This new project will have all its dependencies checked out and saved within its scope, that is, within its own directory.</p><p>The syntax for the command we're going to use to install Yii 2 and start working with it is the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>composer create-project vendor/project target-directory</strong></span>
</pre></div><p>Here, <code class="literal">vendor/project</code> is the Packagist name of the project, in our case, the name will be <code class="literal">yiisoft/yii2-app-basic,</code> as we will see later, and <code class="literal">target-directory</code> is where you want to install it. This command won't create a <code class="literal">composer.json</code> file, so you can run it from anywhere in your environment, just be sure to specify the correct target path.</p><p>Yii 2 developers<a id="id88" class="indexterm"/> have shared two packages that contain an initial application you can start working with: a <span class="emphasis"><em>basic</em></span> and an <span class="emphasis"><em>advanced</em></span> one.</p><p>The difference between the two is the type of dependencies and what's already been implemented.</p><p>Both projects come with a <code class="literal">README.md</code> file in Markdown format, which you can read to understand the details. To keep it short:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Basic</strong></span>: As the <a id="id89" class="indexterm"/>name says, it's a basic implementation, very close to what you would get by installing Yii 1, ready to be used with a default Apache or Nginx installation.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Advanced</strong></span>: This is <a id="id90" class="indexterm"/>a very basic configuration if you need to build a multitiered application. The one you will get with the advanced app consists of a frontend, a backend, and a console application, all as separate Yii applications with some common components. It would require a specific initialization, so refer to the <code class="literal">README.md</code> file for details.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>The advanced application features an additional script called <code class="literal">init,</code> which wraps Composer and enables or disables the installation of <code class="literal">require-dist</code>.</p><p>For a more detailed guide, check out the documentation at <a class="ulink" href="http://www.yiiframework.com/doc-2.0/guide-tutorial-advanced-app.html">http://www.yiiframework.com/doc-2.0/guide-tutorial-advanced-app.html</a>.</p></div></div><p>Consider the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ composer create-project --prefer-dist --stability=dev yiisoft/yii2-app-basic basic</strong></span>
</pre></div><p>We are now installing into <code class="literal">/basic</code> the <code class="literal">yiisoft/yii2-app-basic</code> package. There are other ways to get you started, but this is definitely the most clean way I can think of, as you won't be tied to a repository nor anything else.</p><p>There is no interaction required after this command, as it would carry on installing the required packages including <code class="literal">require-dev</code>.</p><p>It might be that at this point, Composer will fail in installing some dependencies, or you can fall in some runtime errors later on, so it's probably better if you check your requirements are met by opening the requirement script in your browser, which will check that everything is all right. The file is found in the root of the project and it's called <code class="literal">requirements.php</code>.</p><p>In Ubuntu, there <a id="id91" class="indexterm"/>are some packages you might want to install, which are going to be needed, such as <code class="literal">php5-mcrypt</code>, <code class="literal">php5-xsl</code>, and <code class="literal">php5-xdebug</code>. Each Linux distribution ships these PHP extensions in different ways and their naming might be different; please consult your Linux distro documentation if you're having problems on how to find, install, or configure them.</p><p>At the end of the installation process, you will note some additional work being done, as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Generating autoload files</strong></span>
<span class="strong"><strong>Setting writable: runtime ...done</strong></span>
<span class="strong"><strong>Setting writable: web/assets ...done</strong></span>
<span class="strong"><strong>Setting executable: yii ...done</strong></span>
<span class="strong"><strong>$</strong></span>
</pre></div><p>If you had memory of the previous version of Yii, this was something many were looking for.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>Please note that these steps need to be replicated manually if you're running Composer on a freshly checked out application, or you would need to run the <code class="literal">init</code> tool if you've got the advanced application installed.</p></div></div></div><div class="section" title="The CLI command line"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>The CLI command line</h2></div></div></div><p>In Yii 2, Composer<a id="id92" class="indexterm"/> is used both as a way to install the basic skeleton of your <a id="id93" class="indexterm"/>web app, something you would have done with Yii 1 using the CLI interface instead, as shown in the following sequence of commands, and as a way to manage the dependencies of your projects:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd protected/</strong></span>
<span class="strong"><strong>$ ./yiic webapp ~/public_html/myproject</strong></span>
</pre></div><p>As you can imagine, the scope and functionality of the command line is now quite different and has been expanded.</p><p>First of all, the CLI is now found in the root of the project and it's called <code class="literal">yii</code>, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./yii</strong></span>
</pre></div><p>By just running the preceding command, you will get a list of possible commands, as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>- asset     Allows you to combine and compress your JavaScript and CSS files.</strong></span>
<span class="strong"><strong>- cache     Allows you to flush cache.</strong></span>
<span class="strong"><strong>- fixture   Manages loading and unloading fixtures.</strong></span>
<span class="strong"><strong>- hello     This command echoes the first argument that you have entered.</strong></span>
<span class="strong"><strong>- help      Provides help information about console commands.</strong></span>
<span class="strong"><strong>- message   Extracts messages to be translated from source files.</strong></span>
<span class="strong"><strong>- migrate   Manages application migrations.</strong></span>

<span class="strong"><strong>To see the help of each command, enter:</strong></span>

<span class="strong"><strong>  yii help &lt;command-name&gt;</strong></span>
<span class="strong"><strong>$</strong></span>
</pre></div><p>The ones you will <a id="id94" class="indexterm"/>recognize from Yii 1 are <code class="literal">migrate</code> and <code class="literal">message</code>, which accomplish the same operations you were used to, albeit some have been improved. The only real difference is the way you'll be calling its specific actions (for example, <code class="literal">migrate/create</code>).</p><p>The shell and web app commands have now been replaced with a cache management tool called <code class="literal">cache</code>, a fixtures creation tool called <code class="literal">fixture,</code> which we'll see later on, and a demo command called <code class="literal">hello</code>, which you can use as inspiration to code one yourself (for example, to create cronjob tasks).</p></div></div>
<div class="section" title="Finding your way around Yii 2"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Finding your way around Yii 2</h1></div></div></div><p>Now you should have <a id="id95" class="indexterm"/>everything you need installed on your box, so let's start looking around and see how Yii 2 is organized so that we will know where to put our hands when needed.</p><p>Remember, there's always a <code class="literal">README.md</code> file you can consult: in the advanced application, it will show you the structure and use of the various directories.</p><p>By just listing the content of the root of the project, you will immediately spot a big difference:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ tree -L 1 -d</strong></span>
<span class="strong"><strong>.</strong></span>
<span class="strong"><strong>├── assets</strong></span>
<span class="strong"><strong>├── commands</strong></span>
<span class="strong"><strong>├── config</strong></span>
<span class="strong"><strong>├── controllers</strong></span>
<span class="strong"><strong>├── mail</strong></span>
<span class="strong"><strong>├── models</strong></span>
<span class="strong"><strong>├── runtime</strong></span>
<span class="strong"><strong>├── tests</strong></span>
<span class="strong"><strong>├── vendor</strong></span>
<span class="strong"><strong>├── views</strong></span>
<span class="strong"><strong>└── web</strong></span>

<span class="strong"><strong>11 directories</strong></span>
</pre></div><p>I've willingly excluded the files from the output of <code class="literal">tree</code> and displayed only the directories.</p><p>It seems like all the content of what once was in <code class="literal">/protected</code> have been dropped outside of the document root.</p><p>The project <a id="id96" class="indexterm"/>structure is now very similar to what could be a Django or a Ruby on Rails application; the project root contains all the code, which is organized the same way as it was in the <code class="literal">protected</code> folder (for example, controllers, modules, config, and so on), some additional directories, such as for widgets, and the document root for your web server.</p><p>The directory you will need to configure Apache to use is called <code class="literal">web</code>, and it's used by Yii to ship only the static files, assets, and the entry scripts, as shown in the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ tree -L 2  web</strong></span>
<span class="strong"><strong>web</strong></span>
<span class="strong"><strong>├── assets</strong></span>
<span class="strong"><strong>├── css</strong></span>
<span class="strong"><strong>│   └── site.css</strong></span>
<span class="strong"><strong>├── favicon.ico</strong></span>
<span class="strong"><strong>├── index.php</strong></span>
<span class="strong"><strong>├── index-test.php</strong></span>
<span class="strong"><strong>└── robots.txt</strong></span>

<span class="strong"><strong>2 directories, 5 files</strong></span>
</pre></div><p>I tend to prefer this organization as it gives the user the immediate idea of the organization of the code by lowering down the nesting levels of the directories.</p><p>If you are keen on using Nginx, that's not a problem, and you will find the required answers in the official documentation, which can be found at <a class="ulink" href="http://www.yiiframework.com/doc-2.0/guide-start-installation.html#configuring-web-servers">http://www.yiiframework.com/doc-2.0/guide-start-installation.html#configuring-web-servers</a>.</p><p>The only two directories that require a bit of explanation are <code class="literal">mail</code>, which is used to store the HTML template(s) for the e-mails (see documentation at <a class="ulink" href="http://www.yiiframework.com/doc-2.0/guide-tutorial-mailing.html">http://www.yiiframework.com/doc-2.0/guide-tutorial-mailing.html</a>), and, possibly, <code class="literal">tests</code>, which you will be learning soon.</p></div>
<div class="section" title="Structure of the default web application"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Structure of the default web application</h1></div></div></div><p>The <a id="id97" class="indexterm"/>basic application is composed of a <code class="literal">SiteController</code> with a couple of modules and a login system.</p><p>The configuration files should be quite straightforward to understand and can be found in the <code class="literal">/config</code> directory. We will be touching on them every now and then in order to configure certain aspects and extensions we're going to use.</p><p>Regardless of whether you are using the manually installed basic application or the Composer-driven method explained earlier, you will be required to set up the database on your environment and configure the application.</p><p>In the configuration file <code class="literal">web.php</code>, be sure to have set up the <code class="literal">cookieValidationKey</code>, and while in <code class="literal">db.php</code>, set up the DSN of your database as described in the documentation at <a class="ulink" href="http://www.yiiframework.com/doc-2.0/guide-start-databases.html#configuring-a-db-connection">http://www.yiiframework.com/doc-2.0/guide-start-databases.html#configuring-a-db-connection</a>.</p><p>You will also note the following at the end of the <code class="literal">web.php</code> file:</p><div class="informalexample"><pre class="programlisting">// config/web.php

if (YII_ENV_DEV) {
    // configuration adjustments for 'dev' environment
    $config['bootstrap'][] = 'debug';
    $config['modules']['debug'] = 'yii\debug\Module';

    $config['bootstrap'][] = 'gii';
    $config['modules']['gii'] = 'yii\gii\Module';
}</pre></div><p>By default, Yii 2 will provide you with a <code class="literal">YII_DEBUG</code> global constant definition, and an environment <code class="literal">YII_ENV_&lt;ENVIRONMENT&gt;</code> definition, which could come handy in certain conditions. Be aware that its use should be limited to specific cases where an alternative and more portable solution cannot be found, either by revisiting the implementation or the initial requirements. In a <a id="id98" class="indexterm"/>production environment, <code class="literal">YII_DEBUG</code> should be set to <code class="literal">false</code> and <code class="literal">YII_ENV</code> to <code class="literal">prod</code>.</p><div class="section" title="Documentation and sample code"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Documentation and sample code</h2></div></div></div><p>With <a id="id99" class="indexterm"/>this version, Yii is now following more strict standards in the way that the code is written and distributed.</p><p>Documentation and readability of the code is essential and is mainly dictated by the PSR-1 and PSR-2 coding style guide (note that PSR-2 is explicitly depending on PSR-1), published by <a id="id100" class="indexterm"/>PHP-FIG (<a class="ulink" href="http://www.php-fig.org">http://www.php-fig.org</a>).</p><p>In PHPStorm, it is quite easy to set up <a id="id101" class="indexterm"/>the code style. Alternatively, you can use <a id="id102" class="indexterm"/>PHP_Codesniffer (<a class="ulink" href="https://github.com/squizlabs/PHP_CodeSniffer">https://github.com/squizlabs/PHP_CodeSniffer</a>) to accomplish the same task and validate your code:</p><p>Feel free to browse the code and check what it does. It's not massively different to what Yii 1 sample application did, apart from the use of PHP 5.4 syntactic sugar.</p></div></div>
<div class="section" title="Defining our working strategy"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Defining our working strategy</h1></div></div></div><p>Now<a id="id103" class="indexterm"/> we know most of our tools that we are going to use, but we still don't know what we're going to do with them.</p><p>Let's have a look at the features we want to implement into Yii Playground, and let's analyze the end-to-end structure of the final application and how we should meet our quality assurance requirements.</p><div class="section" title="Key features to be implemented"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Key features to be implemented</h2></div></div></div><p>Given what we've <a id="id104" class="indexterm"/>seen in the previous sections, the base web app provided by Yii contains just a basic infrastructure with which you can start playing around. For the purpose of this book, we're going to add several features that in a real-world environment would normally be requested by the client or stakeholders on the project through a brief, discussed and analyzed by the internal teams and scheduled to be developed.</p><p>We are going to follow these steps and outline the necessary work needed in order to meet the desired level of quality assurance for the resulting application.</p><p>As previously said, the aim of testing is first and foremost to ensure that the code we produce matches the desired requirements. Anything else outside our code is not normally tested, but here exceptions apply and it really boils down to what the third-party code is doing, its overall quality, and reliability.</p><p>We are going <a id="id105" class="indexterm"/>to aim to change the basic app in order to be able to login from a modal window.</p><p>Once you've got the business requirements in place, we would break this feature down into subfeatures, if needed.</p><p>In fact, the path we will take on how to implement the modal window and the underlying infrastructure is quite important.</p><p>The code controlling the window from the client-side perspective needs to communicate with the backend to validate and authenticate the user. On a very basic level, this can be achieved by just adjusting the already existing controller that deals with the login process.</p><p>But we can do better. We can decide to roll our new login system without changing the existing one, thus avoiding introducing a breaking change that can affect our users. If for some reason a bug will slip past our control, we can just disable the new feature, while still letting the users log into the system.</p><p>This specific feature is also bringing up a series of implicit requirements, such as security and portability of our code, and integration with the existing and upcoming functionality. We want the user login application that sits on the client side to be self-contained and reusable as much as possible. Same goes for the backend authentication system.</p><p>The proposed approach is then the following, together with the high-level assurance criteria we need to satisfy, which will outline the scope of the work in much more detail when implementing it and, on the other side, will help us create the required tests:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">User REST interface to authenticate the user.</li><li class="listitem">Modal login window.</li></ol></div><div class="section" title="User authentication REST interface"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec04"/>User authentication REST interface</h3></div></div></div><p>The <a id="id106" class="indexterm"/>REST interface will define some entry points to our application that will be easy to use. The URLs will then have a syntax of <code class="literal">/resource/id/operation</code>.</p><p>A GET retrieves information, a POST will store information. For example, POST user/login to log in, POST user/logout to log out, POST user/update to update some fields once if the user is logged in, and GET user/details to display user information.</p><p>The communication will work using JSON where needed.</p></div><div class="section" title="User login from a modal window"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec05"/>User login from a modal window</h3></div></div></div><p>Now let's <a id="id107" class="indexterm"/>piece together what we've done with the REST interface and code the JavaScript code that will open the modal window, validate the form, communicate the login credentials to the backend, and keep the user logged in until the browser window is closed.</p><p>As previously said, the code needs to be self-contained and portable, and for security reasons, it will not deal with any sensible information at any point, like the actual authentication.</p></div></div></div>
<div class="section" title="Introducing testing for our purposes"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Introducing testing for our purposes</h1></div></div></div><p>Now that <a id="id108" class="indexterm"/>we have defined what to do, we need to discuss what kind of testing is needed and how much of it we want to test, based on the approaches we have outlined in <a class="link" href="ch01.html" title="Chapter 1. The Testing Mindset">Chapter 1</a>, <span class="emphasis"><em>The Testing Mindset</em></span>.</p><p>We're going to cover the following areas of testing:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Unit tests</strong></span>: This<a id="id109" class="indexterm"/> is to <a id="id110" class="indexterm"/>achieve isolated components testing</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Integration tests</strong></span>: This<a id="id111" class="indexterm"/> is to ensure the various components are<a id="id112" class="indexterm"/> working well together</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Acceptance tests</strong></span>: These <a id="id113" class="indexterm"/>are the most relevant types of tests <a id="id114" class="indexterm"/>from the user perspective, as they try to meet the right requirements defined at the beginning</li></ul></div><p>Clearly, without knowing how our application is structured, it is hard to understand what kind of work we're going to endure.</p><p>So, before getting into defining the actual tests, we need to start breaking down our application into several modules, and overseeing the structure from an architectural point of view.</p><p>There are many ways to perform an architectural breakdown, some might be stricter and more detailed, using a textual list, while others might end up being a rough sketch using a diagram. This heavily depends on the size and complexity of your application, and, in our case, a diagram seems to fit our purposes.</p><p>We need to remember that we always want to balance the effort and the time spent on these initial phases with the amount of detail required at any given point. For instance, we might not know exactly how the modal window login will interact with the rest of the application, whether we need to develop a user model that is more complex than the one we will start with or even split it into different components so as to provide a different functionality to the frontend, or whether this is out of scope with the work we want to do and we can do it in a self-contained way.</p><p>Moreover, the diagram <a id="id115" class="indexterm"/>can miss small bits, which we might forget to test or consider when evaluating our test plan. For example, the JavaScript side of our application might include several small sets of utility functions that should be considered as separate modules for manageability and reuse.</p><div class="mediaobject"><img src="graphics/B03646_02_01.jpg" alt="Introducing testing for our purposes"/><div class="caption"><p>Partial view of the structure of our application</p></div></div><p>As a solution to<a id="id116" class="indexterm"/> these problems, it is always advisable to revisit the structure of the software module and its own breakdown when approaching the development of the specific feature. This is something we will see in detail in the next chapters.</p><p>In the preceding diagram, we can see that our application comprises essentially three main areas, starting from the bottom: a data storage system (database), a model representing the data, and a functional part (the view/controller part of the application). On top of everything sits our main interaction bit given by the user browser. This is not representative of the whole application, rather just the specific areas where we're going to work on.</p><p>As we've already seen, the <span class="strong"><strong>unit tests</strong></span><a id="id117" class="indexterm"/> are aimed at testing an atomic bit of the application, such as a class or a small set of related functions: their purpose is to be <span class="emphasis"><em>small</em></span> and <span class="emphasis"><em>isolate</em></span>, meaning they should have no external dependencies. Keep in mind that totally isolated tests in web development are difficult to achieve, and we are in fact not allowed to touch parts of our infrastructure, for instance, the database interaction. These tests<a id="id118" class="indexterm"/> are actually called <span class="strong"><strong>small tests</strong></span><a id="id119" class="indexterm"/> in Google's internal terminology , which immediately indicates their scope and the time they will take to run.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>Google is currently one of the publicly known companies that have made testing one of their core values. Their approach makes constant use of adjectives to distinguish between types of tests.</p><p>To read more about Google's way of testing, you might be interested in <span class="emphasis"><em>How Google Tests Software</em></span>, <span class="emphasis"><em>Addison Wesley</em></span>, <span class="emphasis"><em>James Whittaker</em></span>, <span class="emphasis"><em>Jason Arbon,</em></span> and <span class="emphasis"><em>Jeff Carollo</em></span>.</p></div></div><p>In our application, the unit test can be represented in the following way:</p><div class="mediaobject"><img src="graphics/B03646_02_02.jpg" alt="Introducing testing for our purposes"/><div class="caption"><p>Graphical representation of unit testing coverage</p></div></div><p>A practical example is the user model we're going to create, and, as stated before, we might have other unit tests that we might want to write, for instance, in our JavaScript layer in the frontend, in case we were dealing with a client-side application where part of the business logic lives in the user browser.</p><p>Just remember, the tests<a id="id120" class="indexterm"/> covering the user model shouldn't make any use of external dependencies (for example, external helpers, such as the security module) and, secondly, they can avoid touching parts of the framework over which we don't have any control, specifically those that have potentially already been covered by other tests.</p><p>When focusing a bit more on the global picture, we can now see how things stack up and interact with each other. With <a id="id121" class="indexterm"/>
<span class="strong"><strong>integration tests</strong></span>, we might be required to use mocks and fakes <a id="id122" class="indexterm"/>anyway, but this is not highly recommended as it would be used for unit tests. In Google's terminology, these tests are called <a id="id123" class="indexterm"/>
<span class="strong"><strong>medium tests</strong></span>, as they take a bit more when executed and are also trivial to develop in certain situations.</p><div class="mediaobject"><img src="graphics/B03646_02_03.jpg" alt="Introducing testing for our purposes"/><div class="caption"><p>Graphical representation of integration tests coverage.</p></div></div><p>The last pieces of the<a id="id124" class="indexterm"/> jigsaw are the acceptance tests, as shown in the following:</p><div class="mediaobject"><img src="graphics/B03646_02_04.jpg" alt="Introducing testing for our purposes"/><div class="caption"><p>Graphical overview of acceptance tests.</p></div></div><p>
<span class="strong"><strong>Acceptance tests</strong></span> <a id="id125" class="indexterm"/>are similar to system tests (or end-to-end tests), but they target the user rather than the consistency of the overall system from an engineering point of view. Acceptance<a id="id126" class="indexterm"/> tests are close to what could be a real-world use: these tests are required to ensure that all components are working well together, and meet the acceptance criteria defined at the beginning, as specific actions that outline the user interaction with the application.</p><p>Acceptance criteria are those we have defined previously when outlining our features: the user should be able to log in using a modal window.</p><p>I've intentionally avoided to use a business domain language, as we want to keep it as wide as possible for this initial part, instead we're going to dive into that later on.</p><p>At Google, acceptance (and end-to-end) tests are also called<a id="id127" class="indexterm"/> <span class="strong"><strong>large</strong></span> or <span class="strong"><strong>enormous tests</strong></span> because <a id="id128" class="indexterm"/>they will take a lot more to implement and to execute. They also require an infrastructure that could mimic a real-world scenario, which may not be trivial to set up. Because of this, creating corner cases can be quite difficult as this means that we're going to test only the defined scenarios and any specific case we think to be meaningful to the area that we're testing.</p><p>In our case, this might be something along the lines of "The user will receive an error when using wrong credentials."</p><p>Again, we will specifically dig into these details later on in this book.</p><div class="section" title="Using a top-down approach versus a bottom-up approach"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Using a top-down approach versus a bottom-up approach</h2></div></div></div><p>It's important <a id="id129" class="indexterm"/>to reiterate that BDD has been created as an improvement over TDD and quite an important one at that. It provides a better and more flexible language to define acceptance criteria, which will also help define the scope of the testing needed.</p><p>We have two ways to define our testing strategy and our test plan: using either a bottom-up (or <span class="emphasis"><em>outside-in</em></span>) or a top-down (or <span class="emphasis"><em>inside-out</em></span>) approach, as shown in the following diagram:</p><div class="mediaobject"><img src="graphics/B03646_02_05.jpg" alt="Using a top-down approach versus a bottom-up approach"/><div class="caption"><p>Comparison of different size of tests and their benefit.</p></div></div><p>It's not new for agencies and startups when trying to build up and improve their QA to start from the bottom, implementing unit tests and trying to get a good amount of coverage.</p><p>The use of TDD is <a id="id130" class="indexterm"/>encouraged and it's actually the first step in getting into the <span class="emphasis"><em>testing mentality</em></span>, by writing tests first and then going through the <span class="emphasis"><em>red, green, and refactor</em></span> phases. But its sole focus relies on the code, and the responsibility to implement and ensure they're covering the right amount of code rests with the developer.</p><p>Unit tests will help you focus on small and atomic parts of your application, and the tests, by being rather quick to be executed, will help you discover bugs frequently and improve the quality of the code developed. Your architectural and design skills will also improve significantly.</p><p>At a certain point, you will find yourself knowing that there's still something that is not touched by tests. While the project grows, the amount of manual and exploratory testing grows with it.</p><p>Integration tests can help you alleviate this problem, but please refrain yourself from spawning an incredible amount of integration tests: these can quickly become brittle and unmaintainable, especially when the external dependencies can become out-of-sync.</p><p>Acceptance tests are going to keep everything together and eliminate the need for the repetitive tasks you can perform when doing manual tests. Again, acceptance tests are not a replacement for exploratory testing and should instead focus on the acceptance criteria defined.</p><p>As you can imagine, the top-down approach gives you the following advantages:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A complete solution with a good enough coverage</li><li class="listitem">A clear panoramic of the testing infrastructure</li><li class="listitem">A good balance between effort, development, and tests</li><li class="listitem">Most of all, the <span class="emphasis"><em>confidence</em></span> that your system is solid, if not rock-solid</li></ol></div></div><div class="section" title="What to test and what not to test"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>What to test and what not to test</h2></div></div></div><p>The distribution of test coverage could end up being distributed as 100 percent–20 percent–10 percent, for unit, integration, and acceptance tests, respectively. The percentage for integration and acceptance can grow quite a fair bit in user-facing projects.</p><p>In this context, it is particularly important to understand what <span class="strong"><strong>code coverage</strong></span><a id="id131" class="indexterm"/> means.</p><p>If you haven't already, you will probably find some software engineer that will convince you that 100 percent coverage is essential and not reaching it is some sort of shame you have to wear for the rest of the project, looking down at the ground for you're not a respectable developer.</p><p>Reaching full coverage is a noble aim, and that's where we will try to get, but we need also to be realists and, as highlighted before, understand that there are many situations where this is not possible at all.</p><p>The "what to test" question, or in other words the scope<a id="id132" class="indexterm"/> of the testing, is defined by our acceptance criteria for each feature we are going to develop.</p><p>Using the top-down approach, we will also be able to highlight which bits are important to be integration tested, while trying to achieve 100 percent for units.</p></div><div class="section" title="The master test plan"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>The master test plan</h2></div></div></div><p>At the <a id="id133" class="indexterm"/>end of <a id="id134" class="indexterm"/>this initial planning work, you will have everything needed to define your master test plan.</p><p>The master test plan is a unified way to document the scope and details of what needs to be tested and how.</p><p>You don't need to be formal, and there's no specific requirement or procedure to follow, unless you're working for a big company where it's considered a deliverable at the beginning of the project to be signed off by the stakeholders.</p><p>In our case, it will be roughly defined by the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">User API implementation:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Unit test as much as possible (aim for 100 percent, but 60 percent to 70 percent is considered acceptable on a case-by-case basis)</li><li class="listitem" style="list-style-type: disc">Functional tests to cover all the entry points of the application</li><li class="listitem" style="list-style-type: disc">Well defined corner-cases—bad parameters and/or requests (for example, GET instead of POST) as client-side errors, and server-side errors handling (50* errors and similar)</li></ul></div></li><li class="listitem" style="list-style-type: disc">User login<a id="id135" class="indexterm"/> from modal window:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Functional tests to ensure we are getting the right markup</li><li class="listitem" style="list-style-type: disc">Well defined corner cases—for example, no e-mail specified, e-mail with no Gravatar setup</li><li class="listitem" style="list-style-type: disc">Acceptance tests—user clicks on the login button, modal is displayed, user logs in, user sees him/her as logged in; user is logged in, click on the logout button, the user sees him/her as logged out</li></ul></div></li></ul></div><p>As you can imagine, the <a id="id136" class="indexterm"/>test plan should be a document that lives together with the project, being expanded and amended upon necessity when introducing new features or changing others. This requirement determines some constraints that should be respected if you want to keep having a specification document that is simple enough to be updated in a short time (10 minutes top) and, at a glance, lets you know what the implied risk and importance of each component and feature is.</p><p>If you want to understand more of the topic, I would strongly suggest you read more starting from <a id="id137" class="indexterm"/>
<span class="strong"><strong>Attributes-Components-Capabilities</strong></span> (<span class="strong"><strong>ACC</strong></span>) at <a class="ulink" href="https://code.google.com/p/test-analytics/wiki/AccExplained">https://code.google.com/p/test-analytics/wiki/AccExplained</a>.</p><p>The ACC goes together with risk analysis and mitigation. By putting your components, their relative capabilities (or features), and the attributes they should provide, such as "secure", "stable", "elegant", and so on in a grid, you can immediately understand where you should focus your testing attentions. For each row, you can give a risk value, relative to the other features. We want to keep the value relative to avoid making it too difficult to compute and also because it is meaningful only in this context.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Summary</h1></div></div></div><p>During this chapter, you saw many important things, which are the base of what we're going to work on in the next chapters and the base of testing from a wider perspective: you learned the importance of our workflow and environment setup, you saw how to use Composer and use it to install Yii, and, finally, we've picked up the concepts detailed in <a class="link" href="ch01.html" title="Chapter 1. The Testing Mindset">Chapter 1</a>, <span class="emphasis"><em>The Testing Mindset</em></span>, and made them concrete, applying them to our specific application and the features that we're going to implement.</p><p>Now, before we dive into the actual implementation of the application, we need to get first into the testing suite <span class="strong"><strong>Codeception</strong></span>, the jargon it uses, and the various features that it will provide, which we're going to use in the upcoming chapters.</p></div></body></html>