- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Code Quality Metrics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码质量指标
- en: Wouldn’t it be great if we could measure the quality of our software? Software
    developers often want to improve their software again and again – but maybe it
    is already “good enough.” How do we know when it reaches a good state?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能衡量我们软件的质量会怎么样？软件开发者经常想要不断改进他们的软件——但也许它已经“足够好了”。我们如何知道它达到了良好的状态？
- en: Software quality metrics were introduced by smart people in the early days of
    programming. In the 1970s, they thought about this topic and produced the ideas
    that are still in use today. Of course, we want to benefit from this knowledge
    and apply it to our own projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件质量指标是在编程的早期由聪明人提出的。在20世纪70年代，他们考虑了这个话题，并产生了今天仍在使用的想法。当然，我们希望从这些知识中受益，并将其应用于我们的项目中。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing code quality metrics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍代码质量指标
- en: Gathering metrics in PHP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PHP中收集指标
- en: The pros and cons of using metrics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指标的优势和劣势
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you have gone through the previous chapter and tried out all the tools, you
    already have everything that you need for this chapter installed. If not, please
    make sure to do so before you run the upcoming examples.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了上一章并尝试了所有工具，那么你已经安装了这一章所需的所有内容。如果没有，请在运行即将到来的示例之前确保这样做。
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Clean-Code-in-PHP](https://github.com/PacktPublishing/Clean-Code-in-PHP)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Clean-Code-in-PHP](https://github.com/PacktPublishing/Clean-Code-in-PHP)
- en: Introducing code quality metrics
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍代码质量指标
- en: In this section, you will learn about how to measure the quality of software
    in general. We will look at some of the most used metrics in the PHP world and
    explain what they can tell you about your code, how to gather them, and when they
    are useful or not.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解如何衡量软件的整体质量。我们将探讨PHP世界中一些最常用的指标，并解释它们能告诉你关于你代码的什么信息，如何收集它们，以及它们何时有用或无用。
- en: Aspects of software quality
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件质量方面
- en: 'Before we dive into the numbers, we need to clarify one important thing first:
    what does software quality actually mean? Surely, everybody has a certain understanding
    of quality, but it might be hard to put this in words. Luckily, there are already
    existing models, such as the **FURPS** model, which was developed at Hewlett-Packard
    back in the 1980s. The acronym stands for the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究数字之前，我们首先需要澄清一个重要的事情：软件质量实际上是什么意思？当然，每个人对质量都有一定的理解，但可能很难用言语表达出来。幸运的是，已经存在一些现成的模型，例如20世纪80年代在惠普开发的**FURPS**模型。这个缩写代表以下内容：
- en: '**Functionality**: Is the software capable of dealing with a wide variety of
    use cases? Has it been developed with security in mind?'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能性**：软件能否处理各种用例？它是否在考虑安全性的情况下开发？'
- en: '**Usability**: How good is the user experience? Is it documented and easy to
    understand?'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：用户体验有多好？它是否被文档化并且易于理解？'
- en: '**Reliability**: Is the software available at all times? How probable are crashes,
    or errors, that might affect the output?'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：软件是否始终可用？崩溃或可能影响输出的错误的可能性有多大？'
- en: '**Performance**: Indicates the speed of the software. Does it make efficient
    use of the available resources? Does it scale well?'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：表明软件的速度。它是否有效地使用了可用资源？它是否具有良好的可扩展性？'
- en: '**Supportability**: Can the software be tested and maintained well? Is it easy
    to install and can it be translated (localized) into other languages?'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：软件能否被很好地测试和维护？它是否易于安装，并且能否被翻译（本地化）成其他语言？'
- en: 'Further quality aspects include, among others, accessibility and legal conformity.
    As you can see, this model covers more aspects such as user experience and documentation
    than we as PHP developers will typically work on. That is why we can look at software
    quality from two different viewpoints: external and internal quality. Let us have
    a closer look at what that means:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其他质量方面包括，但不仅限于，可访问性和法律合规性。正如你所见，这个模型涵盖了比我们作为PHP开发者通常工作的更多方面，如用户体验和文档。这就是为什么我们可以从两个不同的角度来审视软件质量：外部质量和内部质量。让我们更深入地了解一下这意味着什么：
- en: '**External quality**: Outward, or user-facing, aspects are part of the external
    quality of software. This covers a lot of the aspects we introduced previously.
    What they have in common is that they can be measured without touching or analyzing
    the code itself – think of performance testing tools that measure the response
    time of a request or end-to-end tests that emulate a user by automatically executing
    tests on the application.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部质量**：外部或面向用户的方面是软件外部质量的一部分。这包括我们之前介绍的大多数方面。它们的共同之处在于，它们可以在不接触或分析代码本身的情况下进行测量——想想性能测试工具，它们测量请求的响应时间，或者端到端测试，它们通过自动在应用程序上执行测试来模拟用户。'
- en: '**Internal quality**: As software developers, we usually care more about the
    internal quality of software. Is the code easy to read and understand? Can you
    extend it easily? Can we write tests for it? While users will never see the code,
    or are not concerned about its testability, it does affect them indirectly: code
    of high quality contains lesser bugs and is also often (but not always) faster
    and more efficient. It is also known to be easier to extend and maintain. Typically,
    these aspects can be checked using automated unit tests or code analyzers.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部质量**：作为软件开发者，我们通常更关心软件的内部质量。代码是否易于阅读和理解？是否容易扩展？我们能否为其编写测试？虽然用户永远不会看到代码，或者不关心其可测试性，但它会间接地影响他们：高质量的代码包含更少的错误，并且通常（但不总是）更快、更高效。它也更容易扩展和维护。通常，这些方面可以通过自动单元测试或代码分析器来检查。'
- en: In this book, we focus on the internal code quality. That is why we speak about
    code quality in particular and don’t use the broader term, software quality.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们专注于内部代码质量。这就是为什么我们特别谈论代码质量，而不是使用更广泛的概念，即软件质量。
- en: Code quality metrics
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码质量指标
- en: 'Now that we have a better understanding of what code quality means, let us
    now have a look at what code quality metrics we want to talk about in this section:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对代码质量有了更好的理解，让我们看看在本节中我们想要讨论哪些代码质量指标：
- en: Lines of code
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码行数
- en: The cyclomatic complexity
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圈复杂度
- en: The NPath complexity
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPath复杂性
- en: Halstead metrics
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Halstead度量
- en: The Change Risk Anti-Patterns index
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更风险反模式索引
- en: The maintainability index
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护性指标
- en: The lines of code
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码行数
- en: Counting the **Lines of Code** (**LOC**) in a project is not a quality metric.
    However, it is a useful tool to grasp the size of a project – for example, when
    you start working on it. Furthermore, as we will see, it is used by other metrics
    as a base for their calculations. It is also helpful to have an idea about how
    many lines of code you are dealing with – for example, when you need to estimate
    refactoring efforts for certain classes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 计算项目中的**代码行数**（**LOC**）不是一个质量指标。然而，它是一个有用的工具，可以帮助我们掌握项目的大小——例如，当你开始工作的时候。此外，正如我们将看到的，它被其他指标用作计算的基础。了解你正在处理的代码行数也是一个有用的概念——例如，当你需要估计某些类的重构工作量时。
- en: 'That is why we want to have a closer look at it now. First, we can differentiate
    the LOC further:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们现在想更深入地了解它。首先，我们可以进一步区分LOC：
- en: '**LOC**: LOC simply counts all lines of code, including comments and blank
    lines.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码行数**（**LOC**）：LOC简单地计算所有代码行，包括注释和空白行。'
- en: '**Comment Lines of Code** (**CLOC**): This metric tells you how many lines
    of your code are comments. It can be an indicator of how well the source code
    is commented on. However, as we know, comments tend to rot (i.e., they get outdated
    quickly and are often more harmful than they are useful), so there is no percentage
    or any other rule of thumb we can recommend. Still, it is interesting to know.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注释行代码**（**CLOC**）：这个指标告诉你你的代码中有多少行是注释。它可以是一个指标，表明源代码的注释是否良好。然而，正如我们所知，注释往往会过时（即，它们很快就会过时，并且通常比有用更有害），所以我们没有推荐任何百分比或其他经验法则。尽管如此，了解这一点仍然很有趣。'
- en: '**Non-Comment Lines of Code** (**NCLOC**): If you want to compare the size
    of one project with another, leaving out the comments will give you a better picture
    of how much real code you need to deal with.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非注释行代码**（**NCLOC**）：如果你想比较一个项目与另一个项目的大小，省略注释将能更好地展示你需要处理的真实代码量。'
- en: '**Logical Lines of Code** (**LLOC**): For this metric, it is assumed that every
    statement equals one line of code. The following code snippet illustrates how
    it is supposed to work. Consider the following line of code:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑行代码**（**LLOC**）：对于这个指标，假设每个语句等于一行代码。以下代码片段说明了它应该如何工作。考虑以下代码行：'
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, the LOC would be 1\. Since we have three executable statements in this
    line, LLOC would count this as 3, as the code can also be written with each statement
    in one line:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，LOC将是1。因为我们在这行中有三个可执行语句，LLOC将计算为3，因为代码也可以用每个语句一行的方式编写：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, we highlighted the executable statements. Comments,
    empty lines, and syntactical elements such as brackets are not executable statements
    – that is why the full-line comment and the closing brace at the end of the loop
    are not counted as a logical line.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们强调了可执行语句。注释、空行和如括号之类的语法元素不是可执行语句——这就是为什么整行注释和循环末尾的闭合括号不被计为一个逻辑行。
- en: The cyclomatic complexity
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环复杂度
- en: Instead of just counting the lines of code, we can also measure the complexity
    of the code – for example, by counting the number of execution paths within a
    function. A common metric for this is the `if`, `while`, `for`, and `case` statements.
    Additionally, the function entry counts as one statement as well.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以计算代码的行数，还可以测量代码的复杂性——例如，通过计算函数内的执行路径数量。这种度量中的一个常见指标是`if`、`while`、`for`和`case`语句。此外，函数入口也计为一个语句。
- en: 'The following example illustrates how the metric works:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了该度量是如何工作的：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The CC for the preceding code snippet would be 3: the function entry counts
    as the first decision path and both `if` statements count as one decision path
    each as well. However, both `else` statements are not taken into account by definition,
    as they are part of the `if` clauses. This metric is especially useful to quickly
    assess the complexity of code that you do not know yet. It is often used to check
    a single function, but can also be applied to classes or even a whole application.
    If you have a function with a high CC, consider splitting it into several smaller
    functions to reduce the value.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码片段的CC值为3：函数入口算作第一条决策路径，两个`if`语句各自算作一条决策路径。然而，根据定义，两个`else`语句没有被考虑在内，因为它们是`if`子句的一部分。这个度量对于快速评估你还不了解的代码的复杂性特别有用。它通常用于检查单个函数，但也可以应用于类或整个应用程序。如果你有一个CC值高的函数，考虑将其拆分为几个更小的函数以降低其值。
- en: The NPath complexity
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NPath复杂性
- en: A second metric of code complexity is the `if`, `while`, `for`, and `case`)
    that are defined for the CC. Furthermore, the function entry point is not counted
    as a decision path for this metric.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 代码复杂性的第二个度量是定义在CC上的`if`、`while`、`for`和`case`等语句。此外，对于这个度量，函数入口点不计为一个决策路径。
- en: 'Looking at the above example, the NPath complexity would be 4, because we have
    2 * 2 possible paths through the function: both `if` statements, as well as both
    `else` statements. So, all four `echo` statements are considered decision paths.
    As mentioned previously, the function call itself is not considered. Now, if we
    added another `if` statement, the NPath complexity would increase to 8\. This
    is because we would then have 2 * 2 * 2 possible paths. In other words, the metric
    grows exponentially, so it can rapidly become quite high.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 观察上述示例，NPath复杂性将是4，因为我们有2 * 2通过函数的可能路径：两个`if`语句，以及两个`else`语句。所以，所有四个`echo`语句都被视为决策路径。如前所述，函数调用本身不被考虑。现在，如果我们添加另一个`if`语句，NPath复杂性将增加到8。这是因为我们会有2
    * 2 * 2种可能的路径。换句话说，这个度量是指数增长的，所以它可以迅速变得相当高。
- en: The NPath complexity depicts the actual effort to test a function better than
    the CC, as it tells us directly how many possible outcomes of the function we
    would need to test to achieve 100% test coverage.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: NPath复杂性比CC更好地描述了测试函数的实际工作量，因为它直接告诉我们为了达到100%的测试覆盖率，我们需要测试函数的多少种可能的结果。
- en: Halstead metrics
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Halstead度量
- en: Maurice Halstead introduced a set of eight metrics in the late 1970s, which
    are still in use today and are known as the `==`, `!=`, and `&&`) and operands
    (e.g., function names, variables, and constants), but as you will see, they already
    tell you a lot about the inspected code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 莫里斯·哈斯泰德在20世纪70年代末引入了一套八项度量，这些度量至今仍在使用，并被称为`==`、`!=`和`&&`等运算符（例如，函数名、变量和常量），但正如你将看到的，它们已经告诉你很多关于检查的代码的信息。
- en: 'We do not need to know exactly how these metrics work. If you are interested,
    you can find out more about these metrics here: https://www.verifysoft.com/en_halstead_metrics.html.
    However, you should have an idea of what Halstead metrics there are:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要确切地知道这些度量是如何工作的。如果你感兴趣，可以在这里了解更多关于这些度量的信息：https://www.verifysoft.com/en_halstead_metrics.html。然而，你应该对现有的Halstead度量有一个大致的了解：
- en: '*Length*: Calculating the sum of the total number of operators and operands
    tells us how much code we must deal'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*长度*：计算操作符和操作数总数的总和，告诉我们必须处理多少代码'
- en: '*Vocabulary*: The sum of the number of unique operators and operands already
    indicates the complexity of the code'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*词汇量*：已使用的唯一操作符和操作数的总和已足以表明代码的复杂性'
- en: '*Volume*: Describes the information content of the code based on the length
    and vocabulary'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*体积*：根据长度和词汇描述代码的信息内容'
- en: '*Difficulty*: Indicates the error proneness (i.e., how likely it is to introduce
    bugs)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*难度*：表示错误倾向性（即引入错误的可能程度）'
- en: '*Level*: Inverts the difficulty – as in, the higher the level, the less error-prone
    it is'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*级别*：反转难度——即在级别越高，错误倾向性越低'
- en: '*Effort*: The effort that is necessary to understand the code'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*努力度*：理解代码所需的努力'
- en: '*Time*: Tells us how long it roughly took to implement it'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*时间*：告诉我们大致需要多长时间来实现它'
- en: '*Bugs*: Estimates the number of bugs that the code contains'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*错误*：估计代码中包含的错误数量'
- en: These values will give you a rough indication of what type of code you are dealing
    with. Is it easy to understand? How much time was spent developing it? How many
    bugs can be expected? However, without comparing these values with results from
    other applications, they will not help you that much.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值将为您提供关于您正在处理的代码类型的大致指示。是否易于理解？开发它花费了多少时间？可以预期多少错误？然而，如果不将这些值与其他应用程序的结果进行比较，它们对您的帮助不大。
- en: The Change Risk Anti-Patterns index
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变更风险反模式指数
- en: Another especially useful metric is the **Change Risk Anti-Patterns** (**CRAP**)
    index. It uses the CC and the code coverage of the code under consideration.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个特别有用的指标是**变更风险反模式指数**（**CRAP**）。它使用考虑中的代码的CC和代码覆盖率。
- en: Code coverage
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: You have probably heard the term code coverage a lot already. It is a metric
    that is used in context with automated tests and describes the number of lines
    of code (stated in percent of the total number of lines) that unit tests have
    been written for. We will discuss this metric and its prerequisites again later
    in the book when we are dealing with this topic in more detail.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经多次听说过代码覆盖率这个术语。它是在自动化测试的上下文中使用的指标，描述了单元测试已编写的代码行数（以总行数的百分比表示）。我们将在本书稍后更详细地讨论这个指标及其先决条件。
- en: The combination of these two metrics is quite useful. Code that is not overly
    complex and has high test coverage is far more likely to be bug-free and maintainable
    than code that is complex and where there are not many tests for it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个指标的结合相当有用。既不复杂又有高测试覆盖率的代码，比复杂且测试不多的代码更有可能没有错误且易于维护。
- en: The maintainability index
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 维护性指数
- en: As the last metric in this section, we will look at the **maintainability index**.
    It will provide you with just one value that indicates the maintainability of
    the inspected code, or, in other words, it tells you how easy it will be to change
    it without introducing new bugs. Two things make this metric particularly interesting
    for us.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节最后一个指标，我们将查看**维护性指数**。它将为您提供仅一个值，表示检查的代码的可维护性，换句话说，它告诉您在不引入新错误的情况下更改它的难易程度。有两件事使这个指标对我们特别有趣。
- en: 'Firstly, it is based on the aforementioned metrics and uses the LOC, Halstead
    metrics, and the CC to calculate the index. Yet again, we do not really need to
    know the exact formula. If you are interested, you can look it up here: [https://www.verifysoft.com/en_maintainability.html](https://www.verifysoft.com/en_maintainability.html).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它基于上述指标，并使用LOC、Halstead指标和CC来计算指数。再次强调，我们并不真的需要知道确切的公式。如果您感兴趣，可以在这里查找：[https://www.verifysoft.com/en_maintainability.html](https://www.verifysoft.com/en_maintainability.html)。
- en: 'Secondly, this metric will return a value that you can use to assess the code
    quality directly:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，此指标将返回一个可以直接用于评估代码质量的值：
- en: '85 and more: Good maintainability'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 85及以上：良好可维护性
- en: '65 to 85: Moderate maintainability'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 65到85：中等可维护性
- en: '65 and below: Bad maintainability'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 65以下：差的可维护性
- en: With this metric, you need no other code to compare it to. That is why it is
    particularly useful to quickly assess the code quality.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此指标，您无需与其他代码进行比较。这就是为什么它特别适用于快速评估代码质量。
- en: In this section, we have gone through a lot of theory. Excellent job so far
    – you will not regret learning about it for sure because, in the next section,
    we will show you how to gather these metrics using even more PHP tools.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经讨论了很多理论。到目前为止，做得很好——您一定会后悔学习这些知识的，因为在下一节中，我们将向您展示如何使用更多的PHP工具来收集这些指标。
- en: Gathering metrics in PHP
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PHP中收集指标
- en: In this section, we want to have a look at the tools there are in the PHP world
    to gather code quality metrics. As you will see shortly, these metrics are not
    just numbers – they will allow you to make educated guesses about how much effort
    it will take to refactor code. They will also help you to identify the parts of
    the code that will require the most attention.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们想看看PHP世界中用于收集代码质量指标的工具。如您很快就会看到的，这些指标不仅仅是数字——它们将允许您对重构代码所需的工作量做出明智的猜测。它们还将帮助您识别需要最多关注的代码部分。
- en: 'Again, we have curated a selection of tools for you:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们为您精选了一系列工具：
- en: '`phploc`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`phploc`'
- en: PHP Depend
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP Depend
- en: PhpMetrics
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PhpMetrics
- en: phploc
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: phploc
- en: As we learned in the previous section, the abbreviation LOC stands for lines
    of code, so the name already reveals the main purpose of this tool. Being a basic
    metric, it already tells us quite a few things about a code base. `phploc` also
    provides further metrics, such as the CC, so it is worth having a closer look
    at it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中学到的，LOC的缩写代表代码行数，所以这个名字已经揭示了此工具的主要目的。作为一个基本指标，它已经告诉我们很多关于代码库的信息。`phploc`还提供了其他指标，如CC，因此值得更仔细地研究它。
- en: Installation and usage
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装和使用
- en: 'The author of this tool, Sebastian Bergmann, is well known for `phpunit`, the
    de facto standard for automated tests in the PHP world. He recommends not installing
    it using Composer but using `phar` directly. We will discuss the pros and cons
    of this approach in the next chapter. For now, let us just follow the author’s
    advice and download `phar` directly:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具的作者Sebastian Bergmann因`phpunit`而闻名，`phpunit`是PHP世界中事实上的自动化测试标准。他建议不要使用Composer安装它，而是直接使用`phar`。我们将在下一章讨论这种方法的优缺点。现在，让我们遵循作者的建议，直接下载`phar`：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will download the latest version of `phploc` into the current directory.
    After downloading it, we can directly use it to scan a project:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载`phploc`的最新版本到当前目录。下载后，我们可以直接使用它来扫描项目：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Scanning single files
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描单个文件
- en: Although `phploc` is meant to be used on whole projects, it is also possible
    to specify a single file to scan. While the average measures make no sense because
    they are meant to be used on a whole project, it is still useful if you need to
    find out the LOC metrics or the CC for a class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`phploc`旨在用于整个项目，但也可以指定单个文件进行扫描。虽然平均指标没有意义，因为它们是用于整个项目的，但如果您需要找出LOC指标或类的CC值，它仍然很有用。
- en: 'The preceding command will scan the `src` folder with all its subfolders and
    gather information about it, which will be presented directly on the command line
    as shown in *Figure 8.1*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将扫描包含所有子文件夹的`src`文件夹，并收集有关它的信息，这些信息将直接在命令行上显示，如图*图8.1*所示：
- en: '![Figure 8.1: An example output of phploc (an excerpt)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1：phploc的一个示例输出（摘录）'
- en: '](img/Figure_8.01_B19050.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.01_B19050.jpg](img/Figure_8.01_B19050.jpg)'
- en: 'Figure 8.1: An example output of phploc (an excerpt)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：phploc的一个示例输出（摘录）
- en: 'That is quite a lot more information than just the LOC. The information is
    divided into the following categories:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这比仅仅LOC的信息要多得多。信息分为以下类别：
- en: '**Size**: Obviously, the main reason for this tool to exist is to measure the
    size of a project by counting the number of lines of code, using the several ways
    of counting we introduced in the previous section. The focus lies on LLOC and
    you will get the averages for this metric per class, class method, and function.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**: 显然，这个工具存在的主要原因是通过计算代码行数来衡量项目的大小，使用我们在上一节中介绍的各种计数方法。重点在于代码行数（LLOC），你将得到每个类、类方法和函数的此指标平均值。'
- en: '`phploc` will calculate the average CC values per LLOC, classes, and methods.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`phploc`将计算每个代码行数（LLOC）、类和方法的平均CC值。'
- en: '**Dependencies**: This section tells you how many accesses to the global state
    have been made and how many attributes and methods are being accessed statically.
    Both global and static access are considered as practices and should be avoided,
    so these numbers give you greater hints about the code quality.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖关系**：本节告诉你对全局状态进行了多少次访问，以及有多少属性和方法被静态访问。全局和静态访问都被视为实践，应该避免，因此这些数字为你提供了关于代码质量的更多线索。'
- en: '`phploc` returns more details on the code structure. There are no clear rules
    on how to interpret them; however, you can draw some conclusions from them. For
    example, see the following:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`phploc`返回有关代码结构的更多详细信息。没有明确的规则来解释它们；然而，你可以从中得出一些结论。例如，参见以下：'
- en: Regarding the overall code size, how many namespaces are used? A large code
    base with only a few namespaces indicates that the project is not well structured.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于整体代码大小，使用了多少个命名空间？只有少数命名空间的庞大代码库表明项目结构不佳。
- en: Are interfaces used and how many compared to the project size? The usage of
    interfaces increases the interchangeability of classes and indicates well-structured
    code.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口是否被使用以及与项目规模相比使用了多少个？接口的使用增加了类的可互换性，并表明代码结构良好。
- en: This is all we need to know about the functionality of `phploc` for now. It
    is a simple-to-use yet helpful tool that helps you get a grasp on the overall
    code quality and structure of a project quickly and should therefore be part of
    your toolkit. It does not tell you how to interpret the numbers, though, which
    requires some experience.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们目前需要了解的关于`phploc`功能的所有内容。这是一个简单易用且有用的工具，可以帮助你快速了解项目的整体代码质量和结构，因此应该成为你的工具包的一部分。尽管如此，它并没有告诉你如何解释这些数字，这需要一些经验。
- en: PHP Depend
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PHP Depend
- en: If there was a prize for the most metrics combined in one tool, then it would
    surely go to **PHP Depend** (**PDepend**). It covers all the metrics we discussed
    in the previous section, plus many more. However, it is not the most user-friendly
    tool there is. Plus, the website and the repository documentation are not perfect.
    Nevertheless, you should check it out.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个奖项是授予在单一工具中结合最多指标的人，那么它肯定属于**PHP Depend**（**PDepend**）。它涵盖了我们在上一节中讨论的所有指标，还有更多。然而，它并不是最用户友好的工具。此外，网站和存储库文档并不完美。尽管如此，你应该检查一下。
- en: Installation and usage
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装和使用
- en: 'As before, this tool can be installed using Composer or downloading `phar`
    directly. We will go with the Composer-based installation for now:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个工具可以使用Composer安装或直接下载`phar`。我们现在将采用基于Composer的安装方式：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If there were no unpleasant surprises, you can execute it directly:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有不愉快的惊喜，你可以直接执行：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we already can see that the ancestor of PDepend is JDepend, a Java code
    quality tool, as the output is written into an XML file. The filename is specified
    using the `--summary-xml` option. Furthermore, we must specify the to-be-scanned
    folder as an argument.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已可以看到PDepend的祖先是JDepend，这是一个Java代码质量工具，因为输出被写入XML文件。文件名使用`--summary-xml`选项指定。此外，我们必须指定要扫描的文件夹作为参数。
- en: '`PDepend` does output some numbers, though, as can be seen in the following
    example output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`PDepend`确实输出了一些数字，如下面的示例输出所示：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We skipped some lines here. The numbers will only tell you how often each metric
    has been calculated for the given folder, so the direct output is not particularly
    helpful. To see the actual metrics, we need to open the XML report. In our case,
    the file that has been generated is called `pdepend_summary.xml`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们跳过了一些行。数字只会告诉你对于给定的文件夹，每个指标被计算了多少次，所以直接输出并不特别有帮助。要查看实际的指标，我们需要打开XML报告。在我们的例子中，生成的文件被命名为`pdepend_summary.xml`。
- en: 'The XML report is too huge to print in this book, so you best try it out yourself
    to see it in all its glory. However, we can show you how it is structured:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于XML报告太大，无法在本书中打印，所以你最好亲自尝试一下，看看它的全貌。然而，我们可以向你展示它的结构：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `<metrics>` node represents the directory that was scanned in its entirety.
    It has the following child nodes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`<metrics>`节点代表完整扫描的目录。它有以下子节点：'
- en: '`<files>`, which lists all the scanned files using the `<file>` child nodes.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<files>`，它使用`<file>`子节点列出所有扫描的文件。'
- en: '`<package>`, which lists all the namespaces. Within this node, there are further
    `<class>` child nodes. For each class, there is a list of `<method>` nodes, one
    for each method in the class. Finally, the filename of the class is mentioned
    in another `<file>` node.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<package>`，列出了所有命名空间。在这个节点中，有进一步 `<class>` 子节点。对于每个类，都有一个 `<method>` 节点列表，每个类中有一个方法对应一个
    `<method>` 节点。最后，类的文件名在另一个 `<file>` 节点中提到。'
- en: 'Of course, this is not everything that *PDepend* will generate as output. For
    each node, it will add up dozens of attributes, which contain the names and values
    of the calculated metrics. This is an example node from a XML report that was
    generated on the source code of *PDepend* itself:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是 *PDepend* 将生成的所有输出。对于每个节点，它都会添加数十个属性，这些属性包含计算出的度量的名称和值。这是一个从 *PDepend*
    本身源代码生成的 XML 报告的示例节点：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should be able to recognize some metrics such as `lloc` (LOC) or `ccn`
    (CC Number) already. For the others, you will find explanations, or at least the
    long names, for the abbreviations in the *XML* report in the online documentation:
    [https://pdepend.org/documentation/software-metrics/index.html](https://pdepend.org/documentation/software-metrics/index.html).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够识别一些度量，例如 `lloc`（LOC）或 `ccn`（CC Number）。对于其他度量，您可以在在线文档中的 *XML* 报告中找到解释，或者至少是缩写的长名称：[https://pdepend.org/documentation/software-metrics/index.html](https://pdepend.org/documentation/software-metrics/index.html)。
- en: Further options
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步选项
- en: '*PDepend* has two options you should know about:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*PDepend* 有两个选项您应该了解：'
- en: '`--exclude`: This will exclude a namespace (or package, in this terminology)
    from the scans. You can use multiple namespaces, separated by commas. Make sure
    to add quotes around the namespace(s):'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--exclude`：这将排除一个命名空间（或在此术语中为包）的扫描。您可以使用多个命名空间，用逗号分隔。确保在命名空间（们）周围加上引号：'
- en: '`$ vendor/bin/pdepend --summary-xml=pdepend_summary.xml` `src`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ vendor/bin/pdepend --summary-xml=pdepend_summary.xml` `src`'
- en: '`--ignore`: Allows you to ignore one or more folders. Again, don’t forget the
    quotes:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--ignore`：允许您忽略一个或多个文件夹。同样，不要忘记引号：'
- en: '`$ vendor/bin/pdepend --summary-xml=pdepend_summary.xml` `src`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ vendor/bin/pdepend --summary-xml=pdepend_summary.xml` `src`'
- en: It can also generate images in SVG format with further information. We will
    not cover them in this book, though, as there is a better tool for this, which
    you will find in the next section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以生成带有更多信息的 SVG 格式图像。尽管如此，我们在这本书中不会涉及它们，因为有一个更好的工具，您将在下一节中找到。
- en: '*PDepend* is powerful, but at the same time difficult to oversee. The generated
    output is hard to read and, once the project has become a bit bigger, becomes
    unusable unless you use other tools to parse the XML file. However, you may need
    the advanced metrics it provides one day, or you may work on a project where it
    is already in use. So, at least you are prepared now.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*PDepend* 功能强大，但同时也难以掌握。生成的输出难以阅读，一旦项目变得稍微大一些，除非您使用其他工具来解析 XML 文件，否则变得不可用。然而，您可能有一天需要它提供的先进度量，或者您可能在一个已经使用它的项目中工作。所以，至少您现在已经准备好了。'
- en: PhpMetrics
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PhpMetrics
- en: Up until now, the world of PHP quality metrics was text-based only. This will
    change now, as we will now have a look at *PhpMetrics*, which will generate reports
    that are much better suited for the human eye and are even interactive.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，PHP 质量度量世界仅基于文本。现在将会有所改变，因为我们现在将查看 *PhpMetrics*，它将生成更适合人类眼睛且甚至具有交互性的报告。
- en: Installation and usage
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装和使用
- en: 'Let us add *PhpMetrics* to your project using Composer:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Composer 将 *PhpMetrics* 添加到您的项目中：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After all the files have been downloaded, you can immediately start generating
    your first report:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有文件下载完毕后，您可以直接开始生成您的第一个报告：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `--report-html` option specifies the folder in which the report will be
    created. You can specify more than one folder to be scanned by providing them
    as a comma-separated list. For our example, however, we will just use the `src`
    folder.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`--report-html` 选项指定报告将被创建的文件夹。您可以通过提供以逗号分隔的列表来指定要扫描的多个文件夹。然而，在我们的例子中，我们只会使用
    `src` 文件夹。'
- en: 'As a result, *PhpMetrics* will list several statistics that will already tell
    you a bit about the code. *Figure 8.2* shows an excerpt of the output, which might
    remind you of the output generated by `phploc`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*PhpMetrics* 将列出一些统计信息，这将让您对代码有一些了解。*图 8.2* 展示了输出的摘录，可能会让您想起 `phploc` 生成的输出：
- en: '![Figure 8.2: The PhpMetrics console output (an excerpt)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2：PhpMetrics 控制台输出（摘录）'
- en: '](img/Figure_8.02_B19050.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.02_B19050.jpg)'
- en: 'Figure 8.2: The PhpMetrics console output (an excerpt)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：PhpMetrics 控制台输出（摘录）
- en: 'To open the actual HTML report that has just been generated, simply open the
    `index.html` file in that folder in your browser. Before we have a closer look
    at the generated report, let us see which other useful options *PhpMetrics* offers
    first:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开刚刚生成的实际 HTML 报告，只需在浏览器中打开该文件夹中的 `index.html` 文件。在我们更仔细地查看生成的报告之前，让我们先看看 *PhpMetrics*
    还提供了哪些其他有用的选项：
- en: '`--metrics`: This option will return a list of the available metrics. It helps
    decipher abbreviations such as `mIwoC`.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--metrics`：此选项将返回可用指标列表。它有助于解释像 `mIwoC` 这样的缩写。'
- en: '`--exclude`: With this option, you can specify one or more directories to be
    excluded from scanning.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--exclude`：使用此选项，你可以指定一个或多个要排除的目录。'
- en: '`--report-[csv|json|summary-json|violations]`: Allows you to save the results
    in different report formats other than HTML – for example, `--report-json`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--report-[csv|json|summary-json|violations]`：允许你以不同的报告格式保存结果，而不是 HTML——例如，`--report-json`。'
- en: Opening the browser from the command line
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行打开浏览器
- en: 'If you are using a Linux-based operating system, such as Ubuntu, you can quickly
    open an HTML file from the command line as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是基于 Linux 的操作系统，例如 Ubuntu，你可以按以下方式快速从命令行打开 HTML 文件：
- en: '`$ firefox phpmetrics_report/index.html`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ firefox phpmetrics_report/index.html`'
- en: 'Alternatively, see the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，查看以下内容：
- en: '`$ chromium phpmetrics_report/index.html`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ chromium phpmetrics_report/index.html`'
- en: Understanding the report
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解报告
- en: If you have opened a *PhpMetrics* report for the first time, you will find a
    wide variety of information. We will not dive into every little detail but will
    show you which parts of the report we think are the most valuable to start with.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次打开 *PhpMetrics* 报告，你会看到各种各样的信息。我们不会深入到每一个细节，但会向你展示我们认为开始时最有价值的报告部分。
- en: 'To illustrate the usage of *PhpMetrics* better, we randomly chose an existing
    open source package called `thephpleague/container` as a code base to work on.
    It is an excellent PSR-11-compliant dependency injection container, which is just
    the right size to use as an example. *Figure 8.3* shows the overview page of an
    example report that we generated for it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明 *PhpMetrics* 的用法，我们随机选择了一个名为 `thephpleague/container` 的现有开源软件包作为代码库进行工作。它是一个优秀的
    PSR-11 兼容的依赖注入容器，大小适中，非常适合作为示例。*图 8.3* 展示了我们为它生成的示例报告的概览页：
- en: '![Figure 8.3: A PhpMetrics report overview'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3：PhpMetrics 报告概览'
- en: '](img/Figure_8.03_B19050.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.03_B19050.jpg)'
- en: 'Figure 8.3: A PhpMetrics report overview'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3：PhpMetrics 报告概览
- en: Key metrics
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关键指标
- en: 'On the left-hand side, you will find the menu where you can access other pages
    of the report. The top part of the page is populated with a couple of key metrics,
    where the most interesting ones are:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，你可以找到菜单，可以访问报告的其他页面。页面的顶部填充了一些关键指标，其中最有趣的是：
- en: '**Lines of code** tells you more about the size of this project. By clicking
    on the label, you will be sent to another page with a detailed list of all the
    classes and their related size metrics such as LOC.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码行数**告诉你更多关于这个项目的大小。点击标签后，你将被发送到另一个页面，其中列出了所有类及其相关的尺寸指标，如 LOC。'
- en: '**Violations** shows you the number of violations that *PhpMetrics* has discovered.
    Again, by clicking on the label, you will be sent to another page with a list
    of classes and their violations – for example, if they are too complex (*Too complex
    method code*), have a high bug probability (*Probably bugged*), or use too many
    other classes or other dependencies (*Too dependent*).'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**违规** 显示了 *PhpMetrics* 发现的违规数量。再次点击标签，你将被发送到另一个页面，其中列出了类及其违规情况——例如，如果它们过于复杂（*过于复杂的方法代码*），有很高的错误概率（*可能存在错误*），或者使用了过多的其他类或其他依赖（*过度依赖*）。'
- en: '**Average cyclomatic complexity by class** tells you exactly what it says on
    the tin. The detailed view gives you more information about the complexity on
    a class level.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平均循环复杂度按类**确切地告诉你它所说的内容。详细视图为你提供了关于类级别复杂性的更多信息。'
- en: The other boxes offer interesting information as well, but the preceding ones
    are already perfect for getting a quick view of the most problematic parts of
    the code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 其他框也提供了有趣的信息，但前面的那些已经足够让你快速查看代码中最有问题的地方。
- en: Maintainability or complexity
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 维护性或复杂性
- en: 'Underneath the key metrics, *PhpMetrics* shows a diagram, among other things,
    which you surely already spotted when first opening the report: the **Maintainability
    / complexity** graph. It consists of a colored circle for each namespace of the
    project, where the size of the circle represents the CC of a class. The bigger
    the circle, the higher the complexity. The color shows you the maintainability
    index, ranging from green (high) to red (low).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在关键指标下方，*PhpMetrics*显示了一个图表，以及其他内容，你肯定在第一次打开报告时已经注意到了：**可维护性/复杂性**图。它由项目每个命名空间的一个彩色圆圈组成，圆圈的大小代表类的CC（复杂度）。圆圈越大，复杂性越高。颜色显示可维护性指数，从绿色（高）到红色（低）。
- en: 'If you hover your mouse over a circle, you can see the namespace the circle
    represents and the two metrics in detail:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将鼠标悬停在圆圈上，你可以看到这个圆圈代表的命名空间以及两个详细指标：
- en: '![Figure 8.4: The Maintainability / complexity graph with a popup'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.4: The Maintainability / complexity graph with a popup'
- en: '](img/Figure_8.04_B19050.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.04_B19050.jpg]'
- en: 'Figure 8.4: The Maintainability / complexity graph with a popup'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：带有弹出窗口的可维护性/复杂性图
- en: This graph is extremely useful for quickly grasping the overall code quality
    – the fewer big red circles there are, the better. This way, you can see the problematic
    parts of your code easily.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图对于快速把握整体代码质量非常有用——红色大圆圈越少，越好。这样，你可以轻松地看到代码中的问题部分。
- en: Object relations
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对象关系
- en: 'When you select **Object relations** from the left-hand menu, a graph that
    shows the relations between each namespace will appear. Hovering the mouse pointer
    over a text label will highlight its relations. The graph becomes massive, so
    we can not show it to you in this book in its full beauty, but we can at least
    give a first impression:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从左侧菜单中选择**对象关系**时，将出现显示每个命名空间之间关系的图表。将鼠标指针悬停在文本标签上会突出显示其关系。由于图表很大，我们无法在这本书中展示其全部美，但我们至少可以给出一个初步印象：
- en: '![Figure 8.5: An Object relations graph'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.5: An Object relations graph'
- en: '](img/Figure_8.05_B19050.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.05_B19050.jpg]'
- en: 'Figure 8.5: An Object relations graph'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：对象关系图
- en: Coupling
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 耦合
- en: 'The coupling of classes states how they depend on each other. There are two
    main metrics:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 类之间的耦合表示它们如何相互依赖。有两个主要指标：
- en: '**Afferent couplings** (**Ca**) tell you the number of classes that depend
    on this class. Too many dependencies indicate the importance of a class for the
    project.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入耦合**（**Ca**）告诉你有多少个类依赖于这个类。依赖太多表明这个类对项目的重要性。'
- en: '**Efferent couplings** (**Ce**) give you an idea of how many dependencies a
    class uses. The higher this is, the more the class depends on others.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**出耦合**（**Ce**）给你一个关于一个类使用多少依赖的印象。这个值越高，类对其他类的依赖性就越大。'
- en: Package-oriented metrics
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 包导向指标
- en: 'The last graph we want to show you is the **Abstractness vs. Instability**
    graph. As the name already indicates, it shows the relationship between abstractness
    and the instability of packages. It was introduced by Robert Martin and is based
    on his work on object-oriented metrics. *Figure 8.6* shows you an example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要展示的最后一个是**抽象度与不稳定性**图。正如其名称所暗示的，它显示了包的抽象度与不稳定性之间的关系。它是由罗伯特·马丁引入的，基于他对面向对象指标的深入研究。*图8.6*展示了示例：
- en: '![Figure 8.6: An Abstractness vs. Instability graph'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.6: An Abstractness vs. Instability graph'
- en: '](img/Figure_8.06_B19050.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.06_B19050.jpg]'
- en: 'Figure 8.6: An Abstractness vs. Instability graph'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：抽象度与不稳定性图
- en: 'But what exactly do these two terms mean in the context of software development?
    Let us look at the following definitions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 但这两个术语在软件开发中的确切含义是什么？让我们看看以下定义：
- en: '`0` (concrete) to `1` (abstract).'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`0`（具体）到`1`（抽象）。
- en: '`0` (stable) to `1` (unstable).'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`0`（稳定）到`1`（不稳定）。
- en: Martin stated that packages that are stable and thus highly independent of other
    classes should also have a high level of *A*. Vice versa, unstable packages should
    consist of concrete classes. So, in theory, the *A* of a class weighs out its
    *I*. This means that ideally, *A* plus *I* should be `1` (*A + I = 1*). This equation
    also draws the angled line from the top-left to the bottom-right corner of the
    graph. You should strive to keep your packages close to the line.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 马丁指出，稳定且因此高度独立于其他类的包也应该有高水平的*A*。反之，不稳定的包应由具体类组成。所以，从理论上讲，类的*A*抵消了它的*I*。这意味着理想情况下，*A*加上*I*应该是`1`（*A
    + I = 1*）。这个等式也画出了从左上角到右下角的斜线。你应该努力使你的包接近这条线。
- en: In the actual report, you will find a table below the graph where you will find
    the values in more detail. If you hover the mouse pointer over a circle, a popup
    will appear that tells you the name of the class the circle represents, as well
    as the *A* (the first digit) and the *I* (the second digit).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际报告中，你会在图表下方找到一个表格，其中更详细地列出了数值。如果你将鼠标指针悬停在圆圈上，会出现一个弹出窗口，告诉你该圆圈代表的类的名称，以及 *A*（第一位数字）和
    *I*（第二位数字）。
- en: Other information
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他信息
- en: This ends our tour through *PhpMetrics*. There is a lot more to discover, such
    as, for example, the *ClassRank*, where the famous *PageRank* algorithm from Google
    is used to rank the classes according to their importance (i.e., the number of
    interactions they have with other code parts). We can’t cover everything in this
    book – however, by now, you already know many of the metrics. Its documentation
    is quite helpful to you. You will find a link to it on every page in the upper-right-hand
    corner.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们通过 *PhpMetrics* 的旅程结束。还有很多东西可以探索，例如，例如，*ClassRank*，其中使用了谷歌著名的 *PageRank*
    算法来根据其重要性（即与其他代码部分的交互数量）对类进行排名。在这本书中我们无法涵盖所有内容——然而，到目前为止，你已经了解了许多指标。它的文档对你非常有帮助。你可以在每一页的右上角找到它的链接。
- en: The pros and cons of using metrics
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指标的优点和缺点
- en: In the two previous chapters of this book, you have learned about many tools
    and metrics that exist solely to help you write better software. The knowledge
    and wisdom and countless hours of endeavor on the part of hundreds if not thousands
    of software engineers can be added to your project in a matter of minutes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前两章中，你已经了解了许多工具和指标，它们的存在只是为了帮助你编写更好的软件。成百上千的软件工程师的知识、智慧和无数小时的努力可以在几分钟内添加到你的项目中。
- en: The other side of the coin is that you might already feel completely overwhelmed
    by the sheer number of possibilities. Which tools should you choose? Which metrics
    should you focus on in the future?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你可能已经感到完全被众多的可能性所压倒。你应该选择哪些工具？你未来应该关注哪些指标？
- en: If you have that feeling already, do not worry. We will not leave you alone
    in all this mess but help you find a setup that fits your needs during the next
    chapters. To begin with, let us take the time to look at the pros but also cons
    of using code quality metrics.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你已经有了这种感觉，请不要担心。我们不会让你在这片混乱中孤立无援，但在接下来的章节中，我们会帮助你找到一个适合你需求的设置。首先，让我们花时间看看使用代码质量指标的优点和缺点。 '
- en: The pros
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点
- en: First, each software project is a unique piece of work. It grows based on certain
    circumstances, such as the skill sets of the developers and the available packages
    or frameworks at that time, but also external factors, such as deadlines, which
    often enough affect code quality negatively.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，每个软件项目都是一项独特的工作。它根据某些情况增长，例如开发者的技能组合和当时可用的包或框架，但也受到外部因素的影响，例如截止日期，这些因素往往会对代码质量产生负面影响。
- en: Code metrics help you to get an overview of the current state that a project
    is in. If you, for example, take over a project made by a former team member,
    you want to know what awaits you. By having an idea of the code quality, you can
    immediately adjust your estimated efforts on future tickets in whatever direction.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 代码指标帮助你了解项目当前的状态。例如，如果你接管了一个前团队成员的项目，你想要知道等待你的是什么。通过了解代码质量，你可以立即调整你对未来票据的预估工作量，无论方向如何。
- en: Code quality metrics also help you understand where code needs to be improved.
    It is excellent training to refactor your code, and by using the metrics, you
    know when you have succeeded. Regardless of whether you are working on your own
    pet project, you want to contribute to an open source project, or you work in
    a team, it is always a nice achievement to finally get some more green lights
    on the reports.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量指标也有助于你了解代码需要改进的地方。重构代码是一项极好的训练，通过使用指标，你知道何时取得了成功。无论你是在自己的项目上工作，想要为开源项目做出贡献，还是在团队中工作，最终在报告中获得更多的绿灯总是一件令人愉快的事情。
- en: If you found a piece of code that urgently needed refactoring for a valid reason,
    but your project manager did not want you to do it, you could use the metrics
    to show them how terrible things are and that it is just a judgement based your
    own opinion. Code metrics are unbiased and (painfully) honest.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现了一段代码迫切需要重构，有合理的理由，但你的项目经理不想让你这么做，你可以使用指标向他们展示情况有多么糟糕，以及这仅仅是你个人观点的判断。代码指标是客观的，并且（痛苦地）诚实。
- en: Finally, another important use case of these metrics is to prevent you from
    writing bad code in the first place. Sometimes, it might be a bit annoying to
    write code that adheres to all these rules but be assured that the effort pays
    off eventually.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这些指标的一个重要用途是防止你一开始就编写出糟糕的代码。有时候，编写遵循所有这些规则的代码可能会有些烦恼，但请放心，最终这些努力会得到回报。
- en: The cons
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺点
- en: Previously, we said that deadlines can harm code quality because they keep us
    from refactoring code smells or adding more tests. While this is true, we must
    be aware that once they start by measuring the quality of their code, some developers
    start to refactor a lot more code than necessary because they get rewarded with
    better metrics. Why is that problematic?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此前，我们提到过，截止日期可能会损害代码质量，因为它们让我们无法重构代码异味或添加更多测试。虽然这是真的，但我们必须意识到，一旦他们开始通过衡量代码质量来衡量，一些开发者会开始重构比必要的更多代码，因为他们得到了更好的指标作为奖励。这为什么会成为问题？
- en: For example, imagine there is a class in your current project that has a low
    maintainability index, high NPath complexity, and just by looking at it, you can
    immediately see how bad it is. However, it has matured over time, being fixed
    so often that at some point, it has proven to work without bugs. Now, your tools
    tell you that this class is of bad quality. Should you still jump on it and start
    refactoring it?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下，在你的当前项目中有一个类，它的可维护性指数低，NPath复杂性高，仅通过观察，你就可以立即看出它有多糟糕。然而，随着时间的推移，它已经变得成熟，经常被修复，到了某个时候，它已经证明可以无bug地工作。现在，你的工具告诉你这个类质量不好。你应该仍然跳上去开始重构它吗？
- en: There is, of course, no clear yes or no. As mentioned previously, if you work
    on code in your spare time, it makes sense (and is fun, too) to refactor a class
    to remove most of the code smells. If you are working on commercial projects,
    as in, working as a software engineer for a living, you will not always have the
    time to do so. There are bugs to squeeze, which make the users of your software
    unhappy, while on the other hand there are features to implement, for which they
    are desperately waiting. Overall, it is the satisfied customers who pay your bill.
    Finding the sweet spot between development speed and code quality is never easy
    – you just need to be aware that you sometimes have to take the bitter pill and
    leave bad code alone for now.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并没有明确的“是”或“否”。如前所述，如果你在业余时间编写代码，那么重构一个类以移除大部分代码异味是有意义的（而且也很有趣）。如果你在从事商业项目，也就是说，作为软件工程师谋生，你并不总是有足够的时间这样做。你需要解决bug，这会让你的软件用户感到不快，而另一方面，还有需要实现的功能，用户正焦急地等待着。总的来说，满意的客户才是支付你账单的人。在开发速度和代码质量之间找到最佳平衡点从来都不容易——你只需要意识到有时你必须吞下苦果，暂时放弃糟糕的代码。
- en: Do not use metrics to compete against colleagues, or worse, to talk badly about
    former developers who left you alone with the project. Be aware that everybody
    works as well as possible, based on their skills. Nobody deliberately tries to
    write bad code – often enough, it happens because the developers have never heard
    about clean coding principles or they were under such sheer time pressure that
    they had to do copy and paste coding to make their managers or customers happy.
    Your work environment should be a place of respect, helpfulness, and tolerance,
    not competition.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 不要用指标来与同事竞争，或者更糟的是，去说前开发者的坏话，他们已经让你独自承担项目。请记住，每个人都尽其所能工作，基于他们的技能。没有人故意尝试编写糟糕的代码——通常情况下，这是由于开发者从未听说过清洁编码原则，或者他们承受了巨大的时间压力，不得不进行复制粘贴式编程来让他们的经理或客户满意。你的工作环境应该是一个尊重、乐于助人和宽容的地方，而不是竞争。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to some of the most used code quality metrics in
    the PHP world. Furthermore, we presented you with the tools that help you gather
    them. Of course, there are many more that we could not cover in this book, but
    you do not have to know them all – you are now equipped with a solid understanding
    of code quality metrics that will help you in your daily working routine.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了PHP世界中一些最常用的代码质量指标。此外，我们还向您展示了帮助你收集这些指标的工具。当然，还有许多我们在这本书中没有涵盖的工具，但你不必知道它们全部——你现在已经拥有了扎实的代码质量指标理解，这将有助于你在日常工作中。
- en: Code quality tools and metrics are surely no silver bullet for all problems.
    On the one hand, they can be extremely helpful for improving your code. On the
    other hand, you should not take them as the ultimate measure. There are numerous
    examples of successful types of software that would never pass these quality checks,
    such as WordPress. Be sure, though, that the creators of WordPress would have
    done things differently if they had known beforehand.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量工具和指标当然不是所有问题的万能药。一方面，它们对于提高你的代码质量非常有帮助。另一方面，你不应该把它们当作终极衡量标准。有许多成功的软件类型在事先不知道的情况下永远不会通过这些质量检查，例如
    WordPress。不过，请确信，如果 WordPress 的创造者在事先知道的话，他们可能会采取不同的做法。
- en: In the next chapter, we will leave the realm of theory. We will learn how to
    organize the tools that we introduced in the last two chapters into our projects.
    Every project is unique, so we will offer you different flavors to fit your needs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将离开理论领域。我们将学习如何将上一两章中介绍的工具组织到我们的项目中。每个项目都是独特的，因此我们将提供不同的版本以满足你的需求。
- en: Further reading
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**dePHPend** ([https://dephpend.com/](https://dephpend.com/)) is a tool that
    can draw UML diagrams for your PHP code and be used to spot problems in your architecture.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dePHPend** ([https://dephpend.com/](https://dephpend.com/)) 是一个可以为你绘制 PHP
    代码 UML 图形并用于发现你架构中问题的工具。'
