- en: Chapter 3. Writing a Reddit Reader with RxPHP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 使用RxPHP编写Reddit阅读器
- en: In previous chapters, we talked a lot about asynchronous programming in PHP
    and how this relates to reactive programming, in particular, how to start using
    RxPHP, and how to use common PHP functions such as `proc_open()` and `cURL` asynchronously.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了很多关于PHP中的异步编程以及它与反应式编程的关系，特别是如何开始使用RxPHP，以及如何异步使用常见的PHP函数，如`proc_open()`和`cURL`。
- en: 'This chapter will cover writing a CLI Reddit reader app using RxPHP, Symfony
    Console, and Symfony Process components. We''re also going to use most of what
    we''ve learned in the previous chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖使用RxPHP、Symfony Console和Symfony Process组件编写CLI Reddit阅读器应用。我们还将使用上一章中学到的几乎所有内容：
- en: We'll look in more depth into what happens internally when creating Observable
    chains and subscribing to Observables.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将更深入地探讨在创建可观察对象链和订阅可观察对象时内部发生的事情。
- en: We'll see how Disposables are used in the default classes that come with RxPHP,
    and how these are going to be useful for unsubscribing from Observables in our
    app.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将了解Disposables在RxPHP默认类中的使用方式，以及这些如何在我们的应用中取消订阅可观察对象时变得有用。
- en: Subjects can sometimes simplify our lives when working with operator chains.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当与操作符链一起工作时，Subject有时可以简化我们的生活。
- en: How to use `Observable::create()` and `Observable::defer()` static methods to
    create new Observables with custom logic on subscription.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`Observable::create()`和`Observable::defer()`静态方法来创建具有自定义订阅逻辑的新可观察对象。
- en: Symfony Console library is going to be our tool of choice for most CLI interactions
    throughout this book. Before we start using it, we'll have a quick look at what
    its practical benefits are.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Symfony Console库将成为我们在本书中大多数CLI交互中的首选工具。在我们开始使用它之前，我们将快速看一下它的实际好处。
- en: The event loop from the previous chapter is going to be the center of our app.
    We're going to use it to make the app responsive (we could also say, reactive)
    at any given time.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一章的事件循环将成为我们应用的核心。我们将利用它使应用在任何给定时间都能做出响应（我们也可以说，是反应式的）。
- en: To easily work with subprocesses, we'll use Symfony Process component, which
    handles all the heavy work related to managing subprocesses for us.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了方便地处理子进程，我们将使用Symfony Process组件，它为我们处理所有与子进程管理相关的繁重工作。
- en: We'll use non-blocking stream handling we've seen already in practice, in combination
    with input from terminal and output from a subprocesses.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用我们在实践中已经看到的非阻塞流处理，结合来自终端的输入和来自子进程的输出。
- en: We'll list disposable classes provided by RxPHP.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将列出RxPHP提供的一次性类。
- en: Before we dive in, now is a good time to have a closer look at the internal
    functionality of RxPHP, which hasn't been very important thus far. Nonetheless,
    this knowledge is going to be crucial in this and most of the upcoming chapters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入之前，现在是仔细观察RxPHP内部功能的好时机，到目前为止这并不是很重要。然而，这种知识将在本章节和接下来的大多数章节中变得至关重要。
- en: Examining RxPHP's internals
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查RxPHP的内部结构
- en: 'In the previous chapter, we briefly mentioned disposables as a means for releasing
    resources used by observers, Observables, Subjects, and so on. In practice, a
    disposable is returned, for example, when subscribing to an Observable. Consider
    the following code from the default `Rx\Observable::subscribe()` method:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要提到了Disposables作为释放观察者、可观察对象、Subject等使用的资源的一种手段。在实践中，当订阅一个可观察对象时，会返回一个一次性操作，例如，以下是从默认的`Rx\Observable::subscribe()`方法中的代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This method first adds the observer to the array of all subscribed observers.
    It then marks this Observable as started (remember the difference between "cold"
    and "hot" Observables from [Chapter 2](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 2. Reactive Programming with RxPHP"), *Reactive Programming with RxPHP*)
    and, at the end, it returns a new instance of the `CallbackDisposable` class.
    This class takes a Closure as an argument and invokes it when it's disposed. This
    is probably the most common use case for disposables.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法首先将观察者添加到所有已订阅观察者的数组中。然后，它将此可观察对象标记为已启动（记住“冷”和“热”可观察对象之间的区别，参见[第2章](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "第2章. 使用RxPHP进行反应式编程")，*使用RxPHP进行反应式编程*)，最后，它返回一个`CallbackDisposable`类的新实例。这个类接受一个闭包作为参数，并在它被销毁时调用它。这可能是Disposables最常见的使用场景。
- en: This disposable just removes the observer from the array, and therefore, it
    receives no more values emitted from this Observable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一次性操作仅从数组中移除观察者，因此，它将不再接收从这个可观察对象发出的任何值。
- en: A closer look at subscribing to Observables
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细观察订阅可观察对象
- en: It should be obvious that Observables need to work in such a way that all their
    subscribed observers can be iterated. Then, unsubscribing via a disposable will
    need to remove one particular observer from the array of all subscribed observers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很明显，Observables需要以这种方式工作，以便所有订阅的观察者都可以迭代。然后，通过可取消订阅的实例取消订阅需要从所有已订阅观察者的数组中删除一个特定的观察者。
- en: 'However, if we have a look at how most of the default Observables work, we
    find out that they always override the `Observable::subscribe()` method and usually
    completely omit the part where it should hold an array of subscribers. Instead,
    they just emit all available values to the subscribed observer and finish with
    the `onComplete()` signal immediately after that. For example, we can have a look
    at the actual source code of the `subscribe()` method of the `Rx\ReturnObservable`
    class in RxPP 1:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们看看大多数默认的Observables是如何工作的，我们会发现它们总是覆盖`Observable::subscribe()`方法，并且通常完全省略应该持有订阅者数组的部分。相反，它们只是向已订阅的观察者发出所有可用的值，并在之后立即发出`onComplete()`信号。例如，我们可以查看RxPP
    1中`Rx\ReturnObservable`类的`subscribe()`方法的实际源代码：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `ReturnObservable` class takes a single value in its constructor and emits
    this value to every observer as they subscribe.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReturnObservable`类在其构造函数中接受一个单一值，并将此值发送给每个订阅的观察者。'
- en: 'The following is a nice example of how the lifecycle of an Observable might
    look:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个Observable的生命周期可能看起来很棒的例子：
- en: When an observer subscribes, it checks whether a Scheduler was also passed as
    an argument. Usually, it's not, so it creates an instance of`ImmediateScheduler`.
    Note that in RxPHP 2 the Scheduler can be set only in the class constructor.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当观察者订阅时，它会检查是否也传递了一个调度器作为参数。通常情况下，并没有传递调度器，因此它会创建一个`ImmediateScheduler`实例。请注意，在RxPHP
    2中，调度器只能在类构造函数中设置。
- en: Then, an instance of `CompositeDisposable` is created, which is going to keep
    an array of all disposables used by this method. When calling `CompositeDisposable::dispose()`,
    it iterates all disposables it contains and calls their respective `dispose()`
    methods.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，创建一个`CompositeDisposable`实例，它将保留这个方法使用的所有可取消订阅的实例数组。当调用`CompositeDisposable::dispose()`时，它会迭代它包含的所有可取消订阅的实例，并调用它们的相应`dispose()`方法。
- en: 'Right after that, we start populating our `CompositeDisposable` with the following:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此之后，我们开始用以下内容填充我们的`CompositeDisposable`：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is something we''ll see very often. The  `SchedulerInterface::schedule()` method
    returns a `DisposableInterface`, which is responsible for canceling the action
    and releasing resources. In this case, when we''re using `ImmediateScheduler`,
    which has no other logic, it just evaluates the Closure immediately:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是我们经常会看到的事情。`SchedulerInterface::schedule()`方法返回一个`DisposableInterface`，它负责取消操作并释放资源。在这种情况下，当我们使用没有其他逻辑的`ImmediateScheduler`时，它只是立即评估闭包：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since `ImmediateScheduler::schedule()` doesn't need to release any resources
    (it didn't use any), it just returns an instance of `Rx\Disposable\EmptyDisposable`
    that does literally nothing.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`ImmediateScheduler::schedule()`不需要释放任何资源（它没有使用任何资源），它只是返回一个`Rx\Disposable\EmptyDisposable`实例，这个实例实际上什么也不做。
- en: Then the disposable is returned, and could be used to unsubscribe from this
    Observable. However, as we saw in the preceding source code, this Observable doesn't
    let you unsubscribe, and if we think about it, it doesn't even make sense because `ReturnObservable`
    class's value is emitted immediately on subscription.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后返回一个可取消订阅的实例，可以用来从这个Observable中取消订阅。然而，正如我们在前面的源代码中看到的，这个Observable不允许你取消订阅，如果我们仔细想想，这甚至没有意义，因为`ReturnObservable`类的值在订阅时立即发出。
- en: The same applies to other similar `Observables`, such as `IteratorObservable`, `RangeObservable`
    or `ArrayObservable`. These just contain recursive calls with Schedulers, but
    the principle is the same.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的情况也适用于其他类似的`Observables`，例如`IteratorObservable`、`RangeObservable`或`ArrayObservable`。这些只是包含调度器的递归调用，但原理是相同的。
- en: 'A good question is, why on Earth is this so complicated? All the preceding
    code does could be stripped into the following three lines (assuming we''re not
    interested in using Schedulers):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好问题是，为什么这会如此复杂？所有前面的代码都可以简化为以下三行（假设我们不对使用调度器感兴趣）：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Well, for `ReturnObservable` this might be true, but in real applications, we
    very rarely use any of these primitive Observables. Another very important use
    case for Schedulers is testing. We can provide a test Scheduler that simulates
    delayed execution, to make sure our Observables and operators emit values in the
    correct order. We'll go into this topic in depth in [Chapter 5](part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d
    "Chapter 5. Testing RxPHP Code"), *Testing RxPHP Code*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，对于`ReturnObservable`来说这可能是对的，但在实际应用中，我们很少使用这些原始的Observables。调度器的另一个非常重要的用例是测试。我们可以提供一个模拟延迟执行的测试调度器，以确保我们的Observables和操作符按正确的顺序发出值。我们将在[第5章](part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d
    "第5章。测试RxPHP代码")深入探讨这个主题，*测试RxPHP代码*。
- en: The ability to unsubscribe from Observables or clean up any resources when unsubscribing
    is very important, and we'll use it in a few moments.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从Observables取消订阅或清理取消订阅时的任何资源的能力非常重要，我们将在不久的将来使用它。
- en: Emitting multiple values with Schedulers
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用调度器发出多个值
- en: We've seen how to use `RangeObservable` already. Now, when we know why using
    `Scheduler->schedule()` is important, we can for tutorial purposes think about
    how we could implement `RangeObservable` Observable's functionality ourselves.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用`RangeObservable`。现在，当我们知道为什么使用`Scheduler->schedule()`很重要时，为了教程的目的，我们可以考虑如何自己实现`RangeObservable`
    Observable的功能。
- en: 'For example, it could look like the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，它可能看起来像以下这样：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we run this example, we''ll see that it produces the correct results:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此示例时，我们将看到它产生了正确的结果：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, the original `RangeObservable` has one interesting feature. It's able
    to unsubscribe inside the loop, which means that we can stop generating values
    any time we want.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，原始的`RangeObservable`有一个有趣的功能。它能够在循环内部取消订阅，这意味着我们可以在任何时候停止生成值。
- en: 'Consider the following example, where we unsubscribe inside the observer''s
    callable:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，其中我们在观察者的可调用内部取消订阅：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This example emits only the first three values and then unsubscribes using `$disposable->dispose()`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例仅发出前三个值，然后使用`$disposable->dispose()`取消订阅。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We had to use an asynchronous `EventLoopScheduler`, because we want to start
    executing scheduled actions after we subscribe. With `EventLoopScheduler`, the
    execution starts by calling `$scheduler->start()`. If we use the default `ImmediateScheduler`,
    then the `$disposable` variable will always be null (unassigned), because all
    the scheduled actions would be executed inside `subscribeCallback()` method and
    the `$disposable` variable will never be assigned.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用异步的`EventLoopScheduler`，因为我们希望在订阅后开始执行计划的操作。使用`EventLoopScheduler`，执行是通过调用`$scheduler->start()`开始的。如果我们使用默认的`ImmediateScheduler`，那么`$disposable`变量将始终为null（未分配），因为所有计划的操作都将执行在`subscribeCallback()`方法中，并且`$disposable`变量永远不会被分配。
- en: 'When we run this demo we''ll see just the first three numbers:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此演示时，我们将看到仅前三个数字：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we try the same with our `CustomRangeObservable` we've just created, we'll
    see that it doesn't unsubscribe and we always receive all values. To deal with
    such use cases, Scheduler has a `scheduleRecursive()` method that behaves just
    like `schedule()` but its callable takes one argument, which is a callable itself
    to reschedule another emission.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用我们刚刚创建的`CustomRangeObservable`，我们会看到它不会取消订阅，并且我们总是接收到所有值。为了处理此类用例，调度器有一个`scheduleRecursive()`方法，其行为类似于`schedule()`，但其可调用参数是一个可调用的本身，用于重新调度另一个发射。
- en: 'In practice, we can rewrite `CustomRangeObservable::subscribe()` method to
    use `scheduleRecursive()` instead of `schedule()`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们可以重写`CustomRangeObservable::subscribe()`方法，使用`scheduleRecursive()`而不是`schedule()`：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice that we''re not creating any loops ourselves and we let `$reschedule()` recursively
    call itself. Now we can properly call `dispose()` on the disposable object returned
    from `$sched->scheduleRecursive()` to stop scheduling more actions. We can test
    this with the same scenario as we used with `RangeObservable`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有创建任何循环，而是让`$reschedule()`递归地调用自身。现在我们可以正确地调用从`$sched->scheduleRecursive()`返回的可处置对象的`dispose()`方法来停止调度更多操作。我们可以使用与`RangeObservable`相同的场景来测试这一点：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now it prints only the first three numbers:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它只打印前三个数字：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A closer look at operator chains
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入了解操作符链
- en: We already used operator chains in the previous chapter. Before we start writing
    our Reddit reader, we should talk briefly about an interesting situation that
    might occur, so that it doesn't catch us unprepared later.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中使用了操作符链。在我们开始编写Reddit阅读器之前，我们应该简要地讨论一下可能发生的一个有趣的情况，这样我们就不至于后来措手不及。
- en: 'We''re also going to introduce a new type of Observable, called `ConnectableObservable`.
    Consider this simple operator chain with two subscribers:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍一种新的Observable类型，称为`ConnectableObservable`。考虑这个简单的包含两个订阅者的操作符链：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `ConnectableObservable` class is a special type of Observable that behaves
    similarly to the Subject (in fact, internally, it really uses an instance of the `Subject`
    class). Any other Observable emits all available values right after you subscribe
    to it. However,  `ConnectableObservable` takes another Observable (the source
    Observable) as an argument and lets you subscribe observers to it without emitting
    anything. When you call  `ConnectableObservable::connect()`, it subscribes to
    the source Observables, and all values go one by one to all subscribers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConnectableObservable`类是一种特殊的Observable类型，其行为类似于Subject（实际上，在内部，它确实使用了一个`Subject`类的实例）。任何其他Observable都会在你订阅后立即发出所有可用值。然而，`ConnectableObservable`接受另一个Observable（源Observable）作为参数，并允许你订阅观察者而不发出任何内容。当你调用`ConnectableObservable::connect()`时，它订阅了源Observables，所有值依次发送给所有订阅者。'
- en: Internally, it contains an instance of the `Subject` class, and when we called
    the `subscribe()` method, it just subscribed each observer to its internal Subject.
    Then when we called the `connect()` method, it subscribed the internal Subject
    to the source Observable.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，它包含了一个`Subject`类的实例，当我们调用`subscribe()`方法时，它只是将每个观察者订阅到其内部的Subject。然后当我们调用`connect()`方法时，它将内部的Subject订阅到源Observable。
- en: In the `$filteredObs` variable we keep a reference to the Observable returned
    from `filter()` operator, which is an instance of `AnnonymousObservable` where,
    on the next few lines, we subscribe both observers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`$filteredObs`变量中，我们保存了从`filter()`操作符返回的`Observable`的引用，它是一个`AnnonymousObservable`的实例，在接下来的几行中，我们为两个观察者都调用了`subscribe()`方法。
- en: 'Now, let''s see what this operator chain prints:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个操作符链打印了什么：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we can see, all values went through both observers in the order they were
    emitted. Just out of curiosity, we can also have a look at what would happen if
    we didn''t use `ConnectableObservable`, and used just the `RangeObservable` instead:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，所有值都按照它们发出的顺序通过了两个观察者。出于好奇，我们也可以看看如果我们没有使用`ConnectableObservable`，而是使用`RangeObservable`会发生什么：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This time, `RangeObservable` emitted all values to the first observer and then,
    again, all values to the second observer. We can see that the source Observable
    had to generate all the values twice, which is inefficient, and with a large dataset,
    this might cause a performance bottleneck.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`RangeObservable`将所有值发送给了第一个观察者，然后，再次，将所有值发送给了第二个观察者。我们可以看到源Observable必须两次生成所有值，这是低效的，并且在大数据集上，这可能会造成性能瓶颈。
- en: Subscribing to ConnectableObservable
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订阅到ConnectableObservable
- en: 'Let''s go back to the first example with `ConnectableObservable`, and modify
    the `filter()` call so it prints all the values that go through:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到第一个`ConnectableObservable`的例子，并修改`filter()`调用，使其打印所有通过的数据：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we run the code again and see what happens:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们再次运行代码，看看会发生什么：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Well, this is unexpected! Each value is printed twice, even though we're using
    `ConnectableObservable`. This doesn't always mean that the Observable has to generate
    all the values twice, however (as we'll see in [Chapter 8](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d
    "Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension"), *Multicasting
    in RxPHP and PHP7 pthreads Extension*). It's not obvious at first sight what happened,
    but the problem is that we subscribed to the Observable at the end of the operator
    chain.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这很意外！每个值都被打印了两次，尽管我们使用了`ConnectableObservable`。但这并不意味着Observable必须两次生成所有值（正如我们将在[第8章](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d
    "第8章。RxPHP和PHP7 pthreads扩展中的多播")中看到的那样，“RxPHP和PHP7 pthreads扩展中的多播”)。一开始并不明显发生了什么，但问题是我们是在操作符链的末尾订阅了Observable。
- en: As stated previously, `$filteredObservable` is an instance of `AnnonymousObservable`
    that holds many nested Closures. By calling its `subscribe()` method, it runs
    a Closure that's created by its predecessor, and so on. This leads to the fact
    that every call to `subscribe()` has to invoke the entire chain. While this might
    not be an issue in many use cases, there are situations where we might want to
    do a special operation inside one of the filters.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`$filteredObservable`是一个包含许多嵌套闭包的`AnnonymousObservable`实例。通过调用其`subscribe()`方法，它运行由其前驱创建的闭包，依此类推。这导致每次调用`subscribe()`都必须调用整个链。虽然这可能在许多用例中不是问题，但在某些情况下，我们可能想在其中一个过滤器内部执行特殊操作。
- en: 'The operator chain for this example looks like the following diagram, where
    each subscription is represented by an arrow:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的操作符链看起来像以下图示，其中每个订阅都由一个箭头表示：
- en: '![Subscribing to ConnectableObservable](img/00010.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![订阅ConnectableObservable](img/00010.jpeg)'
- en: The most important consequence of all this is that neither operators nor `AnnonymousObservable`
    class share values that go through them. In fact, none of them keep track of subscribed
    observers either.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切最重要的后果是，操作符和`AnnonymousObservable`类都不共享通过它们传递的值。实际上，它们中的任何一个都没有跟踪订阅的观察者。
- en: Also, note that calls to the `subscribe()` method might be out of our control,
    performed by another developer who wanted to use an Observable we created for
    them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，对`subscribe()`方法的调用可能不受我们的控制，可能是由另一个想要使用我们为他们创建的可观察对象的其他开发者执行的。
- en: It's good to know that such a situation might occur and could lead to unwanted
    behavior.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这种情况可能发生并且可能导致不希望的行为是很好的。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's sometimes hard to see what's going on inside Observables. It's very easy
    to get lost, especially when we have to deal with multiple nested Closures in
    PHP. Schedulers are prime examples. Feel free to experiment with the examples
    shown here and use debugger to examine step-by-step what code gets executed and
    in what order.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候很难看到可观察对象内部发生了什么。特别是在我们必须处理PHP中的多个嵌套闭包时，很容易迷失方向。调度器是典型的例子。请随意尝试这里显示的示例，并使用调试器逐步检查代码的执行顺序和顺序。
- en: 'So, let''s figure out how to fix this. One way could be restructuring our code
    where we''ll turn `$filteredObservable` into `ConnectableObservable` and not `RangeObservable`
    directly. Consider the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们找出如何解决这个问题。一种方法是我们重构代码，将`$filteredObservable`转换为`ConnectableObservable`而不是直接转换为`RangeObservable`。考虑以下代码：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we run this code, we can see the `filter()` operator is called just once
    for each value:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此代码时，我们可以看到`filter()`操作符对每个值只调用一次：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To better understand what is different to the previous example, we can have
    a look at a diagram representing this operator chain:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解与上一个示例的不同之处，我们可以查看表示此操作符链的图示：
- en: '![Subscribing to ConnectableObservable](img/00011.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![订阅ConnectableObservable](img/00011.jpeg)'
- en: We can see that the `ConnectableObservable` was moved down the chain and it
    subscribes to the `filter()` operator instead of `RangeObservable`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`ConnectableObservable`被移动到链的下方，并订阅了`filter()`操作符而不是`RangeObservable`。
- en: Using Subject instead of ConnectableObservable
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Subject代替ConnectableObservable
- en: 'We said we don''t want to subscribe at the end of the chain multiple times,
    so we can create an instance of `Subject` class, where we''ll subscribe both observers,
    and the `Subject` class itself will subscribe to the `$filteredObservable`, as
    discussed a moment ago:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过我们不想在链的末端多次订阅，因此我们可以创建一个`Subject`类的实例，其中我们将订阅两个观察者，而`Subject`类本身将订阅`$filteredObservable`，正如刚才讨论的那样：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can run the script and see that it returns exactly the same output as the
    previous example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行脚本并看到它返回的输出与上一个示例完全相同：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This might look like an edge case, but soon we'll see that this issue, left
    unhandled, could lead to some very unpredictable behavior. We'll bring out both
    these issues (proper usage of disposables and operator chains) when we start writing
    our Reddit reader.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一个边缘情况，但很快我们会看到，如果这个问题没有得到妥善处理，可能会导致一些非常不可预测的行为。当我们开始编写我们的Reddit阅读器时，我们将讨论这两个问题（正确使用可处置对象和操作符链）。
- en: Observable::create() and Observable::defer()
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable::create() 和 Observable::defer()
- en: We know how to create Observables using `ReturnObservable` or `RangeObservable`.
    We've also written a custom `CURLObservable` as well. However, in some situations
    we might want to create an Observable with some custom logic that isn't easily
    reproducible with already existing Observable classes. Of course, we could write
    another Observable inheriting the base Observable class, but if we need to deal
    with a very specific, single use-case scenario, there's an easier way with static
    methods `Observable::create()` and `Observable::defer()`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何使用`ReturnObservable`或`RangeObservable`创建可观察对象。我们还编写了一个自定义的`CURLObservable`。然而，在某些情况下，我们可能希望创建一个具有某些自定义逻辑的可观察对象，这些逻辑不容易用现有的可观察对象类重现。当然，我们可以编写另一个继承基本可观察对象类的可观察对象，但如果我们需要处理一个非常具体、单次使用的场景，使用静态方法`Observable::create()`和`Observable::defer()`将更容易。
- en: Creating Observables with Observable::create()
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`Observable::create()`创建可观察对象
- en: 'With `Observable::create()`, we can create an Observable that automatically
    pushes values into each of its observers on subscription. Consider the following
    example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Observable::create()`，我们可以创建一个在订阅时自动将值推送到每个观察者的可观察对象。考虑以下示例：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The callable passed to `Observable::create()` takes as a parameter an observer
    where it can immediately start emitting values. It''s important to remember that
    this callable is going to be called for each observer. This example prints the
    following output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`Observable::create()`的可调用参数接受一个观察者作为参数，它可以直接开始发射值。重要的是要记住，这个可调用参数将为每个观察者调用。这个示例输出了以下内容：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that string `Observable::create` is printed twice. Also, notice we called
    `onCompleted` ourselves to properly complete the Observable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，字符串`Observable::create`被打印了两次。另外，注意我们亲自调用了`onCompleted`以正确完成可观察对象。
- en: 'The callable can optionally return an instance of `Rx\DisposableInterface`
    that''ll be disposed when unsubscribing/completing the Observable. We can modify
    the same example to return an instance of `CallbackDisposable`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可调用函数可以可选地返回一个`Rx\DisposableInterface`实例，该实例在取消订阅/完成可观察对象时将被销毁。我们可以修改相同的示例以返回`CallbackDisposable`实例：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now each `CallbackDisposable` will be called to properly cleanup resources for
    each observer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个`CallbackDisposable`都将被调用，以正确清理每个观察者的资源。
- en: Creating Observables with Observable::defer()
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`Observable::defer()`创建可观察对象
- en: Imagine a use case where we want to generate a random range of numbers for each
    observer that subscribes to our Observable. This means we want each observer to
    have a different range of numbers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个用例，我们希望为订阅我们可观察对象的每个观察者生成一个随机数字范围。这意味着我们希望每个观察者都有一个不同的数字范围。
- en: 'Lets see what would happen if we used just `RangeObservable`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们只使用`RangeObservable`会发生什么：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since we created a single source Observable, both observers will always receive
    the same range of numbers. Range dimensions are set once when calling `Observable::range()`.
    So, for example, the output from this script could look like the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们创建了一个单个源可观察对象，两个观察者将始终接收到相同的数字范围。范围维度在调用`Observable::range()`时设置一次。例如，这个脚本的输出可能如下所示：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We could of course create two source Observables, but there''s a more elegant
    way using `Observable::defer()` static method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以创建两个源可观察对象，但使用`Observable::defer()`静态方法有一个更优雅的方式：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Static method `Observable::defer()` takes as argument a callable that is called
    every time an observer subscribes similarly to `Observable::create()`. However,
    this callable needs to return another Observable where the observer will subscribe.
    Instead of creating a `RangeObservable` just once, we're creating a new one for
    each observer.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法`Observable::defer()`接受一个可调用参数，每次观察者订阅时都会调用该参数，类似于`Observable::create()`。然而，这个可调用参数需要返回另一个观察者将订阅的可观察对象。我们不是只创建一个`RangeObservable`，而是为每个观察者创建一个新的。
- en: 'The output for this example could look like the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的输出可能看起来像以下这样：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that each observer received a different range of numbers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个观察者接收到了不同的数字范围。
- en: Writing a Reddit reader using RxPHP
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RxPHP编写Reddit阅读器
- en: 'This and many upcoming apps we''re going to build will be pure CLI apps. That
    said, it''ll be helpful to have some unified library that''ll help us with things
    common in the CLI environment:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的许多即将到来的应用程序将是纯CLI应用程序。因此，拥有一个统一的库来帮助我们处理CLI环境中的常见问题将是有帮助的：
- en: '![Writing a Reddit reader using RxPHP](img/00012.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![使用RxPHP编写Reddit阅读器](img/00012.jpeg)'
- en: The tool of choice for us is going to be Symfony Console component ( [http://symfony.com/doc/current/components/console.html](http://symfony.com/doc/current/components/console.html)
    ). It's an  open-source library developed along with the Symfony framework, but
    it's designed to be used independently in any project, which is ideal for us.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用的工具将是Symfony Console组件（[http://symfony.com/doc/current/components/console.html](http://symfony.com/doc/current/components/console.html)）。这是一个与Symfony框架一起开发的开源库，但它被设计成可以在任何项目中独立使用，这对我们来说非常理想。
- en: 'It handles everything from inputs to outputs, and on top of that, it comes
    with a few very nifty helpers as well. In particular, we''re going to use the
    following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 它处理从输入到输出的所有事情，并且还附带了一些非常实用的助手。特别是，我们将使用以下内容：
- en: Coloring and formatting the console output
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色和格式化控制台输出
- en: Splitting a CLI app into multiple independent commands
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将CLI应用拆分为多个独立的命令
- en: Automatically generating help from an input parameter definition
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从输入参数定义中自动生成帮助信息
- en: Handling input parameters, including validation and default values
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理输入参数，包括验证和默认值
- en: Creating a unified set of functions to handle user input
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一组统一的函数来处理用户输入
- en: In this example, we're going to use just the first two bullet points, but in
    later chapters, we'll use all the features listed here.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将只使用前两个项目符号，但在后面的章节中，我们将使用这里列出的所有功能。
- en: Using the Symfony Console component
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Symfony Console组件
- en: 'Start by installing the Symfony Console component via composer:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过composer安装Symfony Console组件：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Each CLI app is divided into multiple commands that can be run on their own.
    We'll set one default command because our app is very simple and we can put all
    its logic into a single command.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每个CLI应用都被拆分为多个可以独立运行的命令。由于我们的应用非常简单，我们可以将所有逻辑放入一个命令中，因此我们将设置一个默认命令。
- en: 'The entrance point of our app is just going to register the command and then
    let the Console library handle everything for us:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的人口点只是注册命令，然后让Console库为我们处理所有事情：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Running the `$application::run()` method checks CLI parameters from PHP globals
    and chooses the right command based on that. Since our app has only one command,
    we don't need to pass any parameters from terminal; the app will use the default
    one, `RedditCommand`, which we'll start writing right now.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`$application::run()`方法会检查PHP的全局CLI参数，并根据这些参数选择正确的命令。由于我们的应用只有一个命令，我们不需要从终端传递任何参数；应用将使用默认的，即`RedditCommand`，我们现在就开始编写它。
- en: 'Each command inherits the `Symfony\Component\Console\Command` class and should
    at least define its name:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令都继承自`Symfony\Component\Console\Command`类，并且至少应该定义其名称：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This command's name is `reddit`, which needs to match the name we set using `setDefaultCommand()`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的名称是`reddit`，它需要与我们使用`setDefaultCommand()`设置的名称相匹配。
- en: 'Notice that we can use tags similar to HTML for some basic styling, which is
    very limited, but it''s enough for the purposes of typical CLI apps. There are
    four predefined colors that we''ll use, but if you want to go into more detail
    feel free to check the documentation on coloring outputs at  [http://symfony.com/doc/current/console/coloring.html](http://symfony.com/doc/current/console/coloring.html)
    :'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以使用类似于HTML的标签来进行一些基本的样式设置，虽然功能非常有限，但对于典型的CLI应用来说已经足够了。我们将使用四种预定义的颜色，但如果你想要更详细地了解，可以自由地查看有关在[http://symfony.com/doc/current/console/coloring.html](http://symfony.com/doc/current/console/coloring.html)上着色输出的文档：
- en: '`<info>` = `green`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<info>` = 绿色'
- en: '`<comment>` = `yellow`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<comment>` = 黄色'
- en: '`<question>` = `black` on cyan background'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<question>` = 在青色背景上显示黑色'
- en: '`<error>` = `white` text on red background'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<error>` = 在红色背景上显示白色文本'
- en: When Symfony Console library recognizes a command, it calls its `execute()`
    method while passing two objects used to handle inputs and outputs. We don't usually
    want to handle input or output by ourselves because there are inconsistencies
    across different platforms and Console library can do everything for us.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当Symfony Console库识别到一个命令时，它会调用其`execute()`方法，同时传递两个用于处理输入和输出的对象。我们通常不希望自己处理输入或输出，因为不同平台之间存在不一致，而Console库可以为我们做所有这些。
- en: 'One suitable exception is when we want to use non-blocking user input instead
    of the built-in question helper. As it happens, this is exactly what we''re going
    to do in a moment, but let''s first see how to run this command from terminal:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合适的例外是当我们想要使用非阻塞的用户输入而不是内置的提问助手。碰巧的是，这正是我们接下来要做的，但让我们先看看如何从终端运行这个命令：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since `RedditCommand` is also the default command, we didn''t have to set any
    CLI parameters to execute it. This is actually identical to running the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`RedditCommand`也是默认命令，所以我们不需要设置任何CLI参数来执行它。这实际上与运行以下命令相同：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'One CLI app can hold multiple commands, as stated previously. We can list all
    commands supported by this app with the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个CLI应用程序可以包含多个命令，如前所述。我们可以使用以下方法列出此应用程序支持的所有命令：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This prints a nicely colored overview of all commands, and some common options
    allowed by all apps by default:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出所有命令的彩色概览，以及所有应用程序默认允许的一些常见选项：
- en: '![Using the Symfony Console component](img/00013.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![使用Symfony控制台组件](img/00013.jpeg)'
- en: Among them, there's also our `reddit` command with the description we set above.
    We could also use the `help` command to get detailed information about a particular
    command, but since our `reddit` command has no input parameters, we won't see
    anything interesting, so we'll keep it for later.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，还有我们上面设置的描述的`reddit`命令。我们也可以使用`help`命令来获取有关特定命令的详细信息，但由于我们的`reddit`命令没有输入参数，我们不会看到任何有趣的内容，所以我们将它留到以后。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that `help` and `list` are just commands like any other.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`help`和`list`只是像其他任何命令一样。
- en: Non-blocking user input and an event loop
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非阻塞用户输入和事件循环
- en: At the end of the previous chapter, we talked about blocking and non-blocking
    streams in PHP using `proc_open()` and `stream_set_blocking()`. We also mentioned
    that we need some kind of event loop that, while periodically checking for user
    input, doesn't block the execution thread, in order to make the app responsive
    at any time.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的结尾，我们讨论了在PHP中使用`proc_open()`和`stream_set_blocking()`实现的阻塞和非阻塞流。我们还提到，我们需要某种类型的事件循环，它在定期检查用户输入的同时，不会阻塞执行线程，以便在任何时候使应用程序保持响应。
- en: 'The basic principles that we''re going to use for our command are as follows:
    We''ll create an Observable that emits a value for every line of input it receives
    (that''s a string followed by *Enter* key). This Observable will have multiple
    observers that will subscribe and unsubscribe based on the current app''s internal
    state. We''ll always have at least one observer active, which is going to look
    for the `q` (quit) string that terminates the event loop and ends the app.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的命令的基本原则如下：我们将创建一个Observable，它为接收到的每一行输入发出一个值（这是一个字符串，后跟*Enter*键）。这个Observable将具有多个观察者，它们将根据当前应用程序的内部状态进行订阅和取消订阅。我们将始终至少有一个活动观察者，它将寻找终止事件循环并结束应用程序的`q`（退出）字符串。
- en: 'Let''s extend the `execute()` method to read a user''s input from terminal
    and the event loop itself:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展`execute()`方法，以便从终端读取用户的输入以及事件循环本身：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There are already a few concepts used worth noting, so let''s take a look at
    each of them separately:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 已经使用了一些值得注意的概念，因此让我们分别查看每个概念：
- en: We opened an input stream with `fopen('php://stdin', 'r')` and made it non-blocking
    using the `stream_set_blocking()` function. This is exactly the same principle
    as we used in the previous chapter, with `proc_open()`.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`fopen('php://stdin', 'r')`打开了一个输入流，并使用`stream_set_blocking()`函数将其设置为非阻塞。这与我们在上一章中使用的`proc_open()`原理完全相同。
- en: The event loop works exactly the same way as we saw in the previous chapter.
    We use it here to create a stable timer that fires (or "ticks," as it's referred
    in `EventLoopScheduler`) every 100 ms.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环的工作方式与我们之前章节中看到的一样。我们在这里使用它来创建一个每100毫秒触发一次（或称为`EventLoopScheduler`中的“tick”）的稳定计时器。
- en: All user input is buffered, which means that `fread()` will always return an
    empty string until we hit the  ***Enter*** key.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有用户输入都被缓冲，这意味着`fread()`将始终返回一个空字符串，直到我们按下***Enter***键。
- en: With the `filter()` operator, we filter out all empty strings.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`filter()`运算符，我们可以过滤掉所有空字符串。
- en: Values that successfully go through this operator chain are then observed by
    a `Subject` class. This is the class where we'll subscribe our observers later,
    and it emits only valid user inputs.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过这个运算符链成功通过的价值将由一个`Subject`类观察。这就是我们将稍后订阅观察者的类，它只发出有效的用户输入。
- en: Using `EventLoopScheduler` is in fact very simple. It makes sure it emits values
    at precise intervals, even though there's always some code executed down the operator
    chain. It internally measures the time it fired the last time and the time it
    spent in propagating the value and then sleeps only for the interval necessary.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`EventLoopScheduler`实际上非常简单。它确保它在精确的时间间隔内发出值，尽管在运算符链中始终有一些代码被执行。它内部测量上次触发的时间和传播值所花费的时间，然后只睡眠必要的间隔。
- en: Note that we've already addressed the issue regarding operator chains we explained
    at the beginning of this chapter. The Observable where we'll subscribe/unsubscribe
    is always `$this->subject`, and never the `IntervalObservable` directly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在本章开头已经解释了关于操作符链的问题。我们将订阅/取消订阅的 Observable 总是 `$this->subject`，而不是直接使用
    `IntervalObservable`。
- en: Also, note that we're creating a `$disposable` variable that holds a `Disposable`
    object created by calling `subscribe($this->subject)`. This is basically the subscription
    to the `IntervalObservable`. If we unsubscribe (this means invoking `$disposable->dispose()`)
    the event loop will end automatically, and so will the entire app.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们创建了一个 `$disposable` 变量，它包含通过调用 `subscribe($this->subject)` 创建的 `Disposable`
    对象。这基本上是对 `IntervalObservable` 的订阅。如果我们取消订阅（这意味着调用 `$disposable->dispose()`），事件循环将自动结束，整个应用也将结束。
- en: Subscribing to user inputs
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订阅用户输入
- en: 'We''ve already mentioned that when a user enters `q`, the app should gracefully
    end. We can implement this functionality right now. Once we have our instance
    of Subject prepared, we can start subscribing to it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，当用户输入 `q` 时，应用应该优雅地结束。我们现在可以实施这个功能。一旦我们准备好了 Subject 的实例，我们就可以开始订阅它：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To save space and keep code examples short, we're omitting class name, indentation,
    and already defined methods that remain unchanged.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间并使代码示例简短，我们省略了类名、缩进和未更改的已定义方法。
- en: This works exactly the same as subscribing to any other Observable. What's interesting
    here is that we pass the `$disposable` variable to the Closure, where we call
    its `dispose()` method, which unsubscribes the Subject from the `IntervalObservable`
    and in turn terminates the event loop. This time, we don't need to keep any reference
    to a `Disposable` object return from `subscribeCallback()`, because we know we'll
    never want to unsubscribe this observer.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这与订阅任何其他 Observable 完全相同。这里有趣的是，我们将 `$disposable` 变量传递给 Closure，在其中调用其 `dispose()`
    方法，从而取消 Subject 对 `IntervalObservable` 的订阅，并最终终止事件循环。这次，我们不需要保留从 `subscribeCallback()`
    返回的任何 `Disposable` 对象的引用，因为我们知道我们永远不会想要取消这个观察者的订阅。
- en: Notice that we're using `take(1)` to accept always at most one quit signal.
    Then the following `subscribe()` call defines only one callable for complete signal
    and completely ignores the remaining two.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 `take(1)` 来接受最多一个退出信号。然后接下来的 `subscribe()` 调用只为完整信号定义了一个可调用对象，并完全忽略了剩余的两个。
- en: We addressed this at the beginning of this chapter when we talked about disposables
    and how these are, in fact, necessary.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开头讨论了可处置对象时提到了这个问题，实际上这些是必要的。
- en: 'We obviously want to let users choose their favorite `subreddit`. This is going
    to be just another subscriber to `$this->subject`, but this time we''ll keep its
    disposable, because later, we need to be able to subscribe other observers and
    unsubscribe this one, which needs to be subscribed only to enter `subreddit` name
    and nothing more:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然想让用户选择他们最喜欢的 `subreddit`。这将是 `$this->subject` 的另一个订阅者，但这次我们将保留其可处置对象，因为稍后我们需要能够订阅其他观察者并取消这个观察者的订阅，这个观察者只需要订阅
    `subreddit` 名称，不需要做更多：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Right before we start the event loop, we schedule an action that asks the user
    for the name of the `subreddit` they want to download and then subscribe a new
    observer. When it receives a valid value, we store it in the `$this->subreddit`
    variable and then it unsubscribes itself using `$this->subredditDisposable->dispose()`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始事件循环之前，我们安排了一个动作，要求用户输入他们想要下载的 `subreddit` 名称，然后订阅一个新的观察者。当它接收到有效值时，我们将它存储在
    `$this->subreddit` 变量中，然后它使用 `$this->subredditDisposable->dispose()` 来取消订阅自己。
- en: We can already see that there's a call to another method, called `refreshList()`.
    This method will download posts for this `subreddit` via Reddit API in JSON and
    print a list with their titles, where the user can choose which one of them they
    want to read by entering the post's index number.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经可以看到有一个调用另一个方法，名为 `refreshList()`。这个方法将通过 Reddit API 以 JSON 格式下载该 `subreddit`
    的帖子，并打印出一个包含标题的列表，用户可以通过输入帖子的索引号来选择他们想要阅读的帖子。
- en: 'To download the list, we''re going to use the cURL PHP module. We''ve already
    used it in [Chapter 2](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 2. Reactive Programming with RxPHP"), *Reactive Programming with RxPHP*,
    where we created `CURLObservable` for this purpose, which comes in handy here
    as well. Also, we''ve already written `JSONDecodeOperator` for decoding JSON strings,
    which we''ll also use:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了下载列表，我们将使用 cURL PHP 模块。我们已经在 [第 2 章](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "第 2 章。使用 RxPHP 进行响应式编程") *使用 RxPHP 进行响应式编程* 中使用过它，我们创建了 `CURLObservable` 来实现这个目的，这在这里也很有用。此外，我们已编写了
    `JSONDecodeOperator` 用于解码 JSON 字符串，我们也将使用它：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is what we've already seen and it should be very easy to follow. We use
    `CURLObservable` to download the URL, and then `JSONDecodeOperator` to decode
    it from a JSON to a PHP array. We then iterate the list of all articles it contains
    and print their indices and titles.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们已经看到的，应该很容易理解。我们使用 `CURLObservable` 下载 URL，然后使用 `JSONDecodeOperator` 将其从
    JSON 解码为 PHP 数组。然后我们遍历它包含的所有文章的列表，并打印它们的索引和标题。
- en: 'We introduced one more small method, called `printHelp()`, which only prints
    a hint that typing `q` and hitting  ***Enter*** will quit the app. We then append
    some more hints relative only to the current state, such as **[b] Back to the
    list**, as we can see in the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了一个名为 `printHelp()` 的小方法，它只打印一个提示，即输入 `q` 并按 ***Enter*** 键将退出应用。然后我们添加一些仅与当前状态相关的提示，例如 **[b]
    返回列表**，正如我们在下面的屏幕截图中所见：
- en: '![Subscribing to user inputs](img/00014.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![订阅用户输入](img/00014.jpeg)'
- en: Then, similarly, it calls `chooseArticleDetail()`, which lets the user enter
    the index number of the article they want to see.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，类似地，它调用 `chooseArticleDetail()`，允许用户输入他们想要查看的文章索引号。
- en: This could go on and on but the principle is always the same. We subscribe an
    observer to the main `Subject` class stored in `$this->subject`, check only values
    relevant to the current application state, perform some action, and then unsubscribe.
    It's probably not necessary to include the complete source code here because it
    would be very repetitive.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以一直进行下去，但原则始终相同。我们订阅一个观察者到存储在 `$this->subject` 中的主 `Subject` 类，只检查与当前应用程序状态相关的值，执行一些操作，然后取消订阅。可能没有必要在这里包含完整的源代码，因为这会非常重复。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to see all methods for this app implemented, then check out the
    full source codes for this chapter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看此应用的所有实现方法，请查看本章的完整源代码。
- en: Instead, let's focus on another thing related to `CURLObservable` and subprocesses,
    with Symfony Process component.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们关注与 `CURLObservable` 和子进程相关的事情，使用 Symfony Process 组件。
- en: Non-blocking CURLObservable
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非阻塞 CURLObservable
- en: In our Reddit reader app, we download data from a remote API using PHP's cURL.
    Even when using its asynchronous callbacks, such as `CURLOPT_PROGRESSFUNCTION`,
    it's important to keep in mind that `curl_exec()` is still a blocking call, no
    matter what options we choose.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Reddit 阅读器应用中，我们使用 PHP 的 cURL 从远程 API 下载数据。即使使用其异步回调，如 `CURLOPT_PROGRESSFUNCTION`，我们也必须记住，无论我们选择什么选项，`curl_exec()`
    仍然是一个阻塞调用。
- en: This is due to the fact that PHP runs in a single execution thread and when
    it starts executing `curl_exec()`, everything else needs to wait until it finishes.
    It's true that this method might call some callback functions, but if any of them
    got stuck, for example, in an infinite loop, the `curl_exec()` function would
    never end.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 PHP 在单个执行线程中运行，当它开始执行 `curl_exec()` 时，其他所有操作都需要等待它完成。虽然这个方法可能会调用一些回调函数，但如果其中任何一个卡住了，例如，在一个无限循环中，`curl_exec()`
    函数将永远不会结束。
- en: This has serious implications for the actual responsiveness of our Reddit reader.
    While `CURLObservable` is downloading data, it doesn't respond to any user input,
    which is probably not what we want.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们 Reddit 阅读器的实际响应能力有严重影响。当 `CURLObservable` 下载数据时，它不会响应用户输入，这可能不是我们想要的。
- en: When we talked about `IntervalObservable` and how it's able to keep the desired
    interval very precisely, we didn't mention that this is, in fact, a type of situation
    it can't handle.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论 `IntervalObservable` 以及它如何能够非常精确地保持所需的间隔时，我们没有提到的是，这实际上是一种它无法处理的情况。
- en: 'Let''s make a small script that demonstrates such behavior. We''ll use `IntervalObservable`
    to fire every second:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的脚本，演示这种行为。我们将使用 `IntervalObservable` 每秒触发一次：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This example prints the current time very precisely, including microseconds.
    If we keep it running for a while, we''ll still see that it holds to microseconds
    pretty well while incrementing by one second:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例非常精确地打印当前时间，包括微秒。如果我们让它运行一段时间，我们仍然会看到它在每增加一秒时仍然很好地保持到微秒：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can already observe that the `map()` operator is called shortly before the
    observer. Now, let''s add a `usleep(1250 * 1000);` call into the `map()` operator.
    We can see that the gap is even larger than the 1-second interval of `IntervalObservable`,
    which makes it completely out of sync:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经可以观察到 `map()` 操作符在观察者之前被调用。现在，让我们在 `map()` 操作符中添加一个 `usleep(1250 * 1000);`
    调用。我们可以看到，这个间隔甚至比 `IntervalObservable` 的1秒间隔还要大，这使得它完全不同步：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This implies that, even when we rely on `IntervalObservable` to do all the timing
    necessary, it can't do anything when there's code anywhere in the operator chain
    blocking the execution. This is what happened to us with `CURLObservable`, and
    the app not responding when `curl_exec()` is running.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，即使我们依赖于 `IntervalObservable` 来完成所有必要的定时，当操作符链中的任何地方有代码阻塞执行时，它也无法做任何事情。这就是我们使用
    `CURLObservable` 时发生的情况，当 `curl_exec()` 运行时，应用程序没有响应。
- en: Unfortunately, PHP itself, without any extra modules, doesn't give us many options
    to write non-blocking code.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，PHP本身（没有任何额外模块）并没有给我们提供很多编写非阻塞代码的选项。
- en: But in the previous chapter, we used `proc_open()` and `stream_set_blocking()`
    to run a non-blocking subprocess, so we can use the same technique and wrap `CURLObservable`
    into a standalone app that we can run as a subprocess.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 但在上一章中，我们使用了 `proc_open()` 和 `stream_set_blocking()` 来运行非阻塞子进程，因此我们可以使用相同的技巧，并将
    `CURLObservable` 包装成一个可以作为一个子进程运行的独立应用程序。
- en: 'Since we already know how to write CLI apps using Symfony Console component,
    we''re going to use it here as well:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经知道如何使用Symfony Console组件编写CLI应用程序，因此我们也将在这里使用它：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This command has one required argument, which is the URL it's supposed to download.
    It uses `CURLObservable` internally to download the URL, and then just prints
    the response to its standard output. It also sets proper UNIX return code when
    an error occurs.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令有一个必需的参数，即它应该下载的URL。它内部使用 `CURLObservable` 下载URL，然后将响应打印到其标准输出。如果发生错误，它还会设置正确的UNIX返回码。
- en: 'If we try to run the command without any arguments, it prints an error telling
    us that this command has to have exactly one argument:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在没有任何参数的情况下运行该命令，它会打印一个错误，告诉我们这个命令必须恰好有一个参数：
- en: '![Non-blocking CURLObservable](img/00015.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![非阻塞 CURLObservable](img/00015.jpeg)'
- en: 'We can test the command manually; for example with the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动测试这个命令；例如，使用以下命令：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, we could use `proc_open()` like in the previous chapter, but apart from
    just spawning the process, there are a lot of things to handle by ourselves, so
    it's easier to leave all the heavy work to another library.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像上一章中那样使用 `proc_open()`，但除了启动进程之外，还有很多事情需要我们自己处理，所以更容易将所有重工作交给另一个库。
- en: Using Symfony Process component
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Symfony Process组件
- en: 'As usual, we''ll install this library using composer:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们将使用composer安装这个库：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This library lets us create new processes, read their outputs in a non-blocking
    way, send inputs, send signals, use timeouts, terminate processes, and so on.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库让我们可以创建新的进程，以非阻塞的方式读取它们的输出，发送输入，发送信号，使用超时，终止进程等等。
- en: 'To test things out, we''ll make a small script that uses `IntervalObservable`
    to print a number every second while waiting for the subprocess to finish:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这些，我们将编写一个小脚本，使用 `IntervalObservable` 每秒打印一个数字，同时等待子进程完成：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `Process` class takes in its constructor a full command it's supposed to
    execute. Then, calling `Process::start()` will start the subprocess in an asynchronous
    non-blocking way, just like we did before. We can check for available output anytime
    with the `getOutput()` method. Then, the `isSuccessful()` and `isRunning()` methods
    return `true` when the process has successfully terminated (return code equals
    0), and whether the process is still running, respectively.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Process` 类在其构造函数中接受一个它应该执行的完整命令。然后，调用 `Process::start()` 将以异步非阻塞的方式启动子进程，就像我们之前做的那样。我们可以随时使用
    `getOutput()` 方法检查可用输出。然后，`isSuccessful()` 和 `isRunning()` 方法分别在进程成功终止（返回码等于0）时返回
    `true`，以及进程是否仍在运行。'
- en: The takeWhile() operator
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: takeWhile() 操作符
- en: 'We have also used one new operator, called `takeWhile()`. This operator takes
    a predicate Closure as an argument, which is executed for every value it receives.
    If the predicate returns `true`, it passes the value down the chain (by calling `onNext()`
    on its observer), but if the predicate returns `false`, it signals `onComplete()`,
    and therefore, the loop ends because there are no other observers subscribed to
    it. It''s exactly the same situation we saw earlier in this chapter, when we used
    disposable to unsubscribe from `IntervalObservable` and end the app. The following
    Marble diagram represents `takeWhile()` operator in RxJS ([http://reactivex.io/rxjs/class/es6/Observable.js](http://reactivex.io/rxjs/class/es6/Observable.js)):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一个新的操作符，称为 `takeWhile()`。这个操作符接受一个谓词闭包作为参数，为它接收到的每个值执行。如果谓词返回 `true`，它将值传递到链中（通过在其观察者上调用
    `onNext()`），但如果谓词返回 `false`，它将发出 `onComplete()` 信号，因此循环结束，因为没有其他观察者订阅它。这与本章前面我们使用可处置的从
    `IntervalObservable` 取消订阅并结束应用的情况完全相同。以下 Marble 图表示了 RxJS 中的 `takeWhile()` 操作符（[http://reactivex.io/rxjs/class/es6/Observable.js](http://reactivex.io/rxjs/class/es6/Observable.js)）：
- en: '![The takeWhile() operator](img/00016.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![takeWhile() 操作符](img/00016.jpeg)'
- en: If we run this example, it'll print a few ticks, then dump the entire response
    and end. This is exactly what we need. So, we can remove the temporary `printf()`
    statement and use this subprocess in our Reddit reader app.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个示例，它将打印几个滴答声，然后转储整个响应并结束。这正是我们所需要的。因此，我们可以删除临时的 `printf()` 语句并使用这个子进程在我们的
    Reddit 阅读器应用中。
- en: Implementing subprocesses into the Reddit reader app
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将子进程实现到 Reddit 阅读器应用中
- en: This final improvement will require some modifications to the existing code.
    First, the method `refreshList()` doesn't need to use either `CURLObservable`
    or `JSONDecodeOperator`, because we'll read the response from the instance of
    the `Process` class directly.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这次最终改进需要对现有代码进行一些修改。首先，`refreshList()` 方法不需要使用 `CURLObservable` 或 `JSONDecodeOperator`，因为我们将从
    `Process` 类的实例直接读取响应。
- en: 'Also, both the main `Subject` class checking for user input and the observer
    checking whether the subprocess has terminated need to use the same instance of
    Scheduler. It''s easier to share the same instance of `IntervalObservable` than
    create a new one every time we want to refresh the list of posts, so we''ll keep
    its reference as a `property` class in `$this->intervalObservable`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，检查用户输入的主要 `Subject` 类和检查子进程是否终止的观察者都需要使用相同的调度器实例。与每次刷新帖子列表时创建一个新的实例相比，共享同一个
    `IntervalObservable` 的实例更容易，所以我们将其引用作为 `property` 类保存在 `$this->intervalObservable`
    中：
- en: '[PRE45]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Then, when we want to quit the app, we have to make sure the subprocess has
    already terminated, or eventually terminate by ourselves. If we don't terminate
    it, the PHP interpreter will have to wait until it finishes.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们想要退出应用时，我们必须确保子进程已经终止，或者最终由我们自己终止。如果我们不终止它，PHP 解释器将不得不等待它完成。
- en: 'This is what the updated observer checking for the quit entry will look like:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是更新后的检查退出条目的观察者将看起来像：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: So, at the end, this all allows us to quit (or perform any other action) any
    time we want, even when cURL is downloading data at that very moment, because
    we run the download as a separate non-blocking process that we check periodically
    for a response in the same event loop as all user input.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终这使我们能够在任何时候退出（或执行任何其他操作），即使在这个时候 cURL 正在下载数据，因为我们以一个单独的非阻塞进程运行下载，并定期在同一事件循环中检查响应。
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In [Chapter 6](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "Chapter 6. PHP Streams API and Higher-Order Observables"), *PHP Streams API and
    Higher-Order Observables*, we'll see how to use `StreamSelectLoop` to directly
    read from file handles created with `fopen()`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d "第
    6 章。PHP Streams API 和高阶 Observables") 中，我们将看到如何使用 `StreamSelectLoop` 直接从使用 `fopen()`
    创建的文件句柄读取。
- en: Types of disposable classes
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可处置类的类型
- en: Throughout this chapter, we've been subscribing and unsubscribing to Observables
    a lot. Although we know what disposables are, we haven't talked about what different
    types of disposable classes are available out of the box in RxPHP.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一直在大量订阅和取消订阅 Observables。虽然我们知道什么是可处置的，但我们还没有讨论 RxPHP 中默认可用的不同类型的可处置类。
- en: We're not going to write examples for each one of them, because these are very
    simple classes and if you're not sure about their implementation details, feel
    free to check their source code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会为它们中的每一个都编写示例，因为这些类非常简单，如果你不确定它们的实现细节，请随时查看它们的源代码。
- en: '`BinaryDisposable`: A class internally containing two more disposable objects.
    Then by calling its `dispose()` it automatically calls `dispose()` on the two
    internal disposables as well.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BinaryDisposable`：一个内部包含两个更多可释放对象的类。然后通过调用它的`dispose()`，它将自动调用两个内部可释放对象的`dispose()`。'
- en: '`CallbackDisposable`: This class wraps a callable that is executed later when
    calling `dispose()`.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CallbackDisposable`：此类包装了一个在调用`dispose()`时稍后执行的调用。'
- en: '`CompositeDisposable`: A collection of disposables that''ll be disposed all
    together.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompositeDisposable`：一个包含可释放对象的集合，这些对象将一起释放。'
- en: '`EmptyDisposable`: A dummy disposable that does nothing. Sometimes it''s required
    to pass or return an instance of `DisposableInterface` even when we have nothing
    to dispose.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmptyDisposable`：一个不做任何事的可释放对象。有时即使我们没有什么可以释放的，也要求传递或返回`DisposableInterface`的实例。'
- en: '`RefCountDisposable`: A disposable containing another disposable and a counter
    that''ll be disposed when the counter reaches 0 (basically the same principle
    as automatic reference counting in programming languages).'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RefCountDisposable`：一个包含另一个可释放对象和计数器的可释放对象，当计数器达到0时将被释放（基本上与编程语言中的自动引用计数原理相同）。'
- en: '`ScheduledDisposable`: This class wraps another disposable that won''t be disposed
    directly but scheduled with `Scheduler::schedule()` instead.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScheduledDisposable`：此类包装另一个不会直接释放的可释放对象，而是通过`Scheduler::schedule()`进行调度。'
- en: '`SerialDisposable`: A collection of disposables where, when adding a new disposable,
    the previous one is automatically disposed (the `Scheduler::scheduleRecursive()`
    method returns this type of disposable).'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SerialDisposable`：一个包含可释放对象的集合，在添加新的可释放对象时，自动释放前一个（`Scheduler::scheduleRecursive()`方法返回此类可释放对象）。'
- en: '`SingleAssignmentDisposable`: A wrapper around another disposable that can
    be assigned only once. If we try to assign this disposable twice, it''ll result
    in exception.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SingleAssignmentDisposable`：这是一个包装另一个可释放对象的包装器，该对象只能分配一次。如果我们尝试将此可释放对象分配两次，将会引发异常。'
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since RxPHP is based mostly on RxJS 4, it uses its style of disposables. If
    you're coming from RxJS 5, you're used to always using only `Subscription` class,
    which is very similar to `CompositeDisposable`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RxPHP主要基于RxJS 4，它使用其可释放对象风格。如果你来自RxJS 5，你习惯于始终只使用`Subscription`类，它与`CompositeDisposable`非常相似。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked in more depth at how to use disposables and operators,
    how these work internally, and what it means for us. We also saw how to use `Observable::create()`
    and `Observable::defer()` to create new Observables with custom logic.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更深入地探讨了如何使用可释放对象和操作符，它们是如何在内部工作的，以及这对我们意味着什么。我们还看到了如何使用`Observable::create()`和`Observable::defer()`来创建具有自定义逻辑的新可观察对象。
- en: The app that we have built was meant to be a simple Reddit reader that combines
    all the aspects of RxPHP we've learned so far. We also saw how we can achieve
    a truly responsive app by making all long running tasks non-blocking. We used
    Symfony Console component to handle user input and output from terminal. Also,
    we used Symfony Process component to easily spawn and have control over subprocesses.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的应用程序旨在成为一个简单的Reddit阅读器，它结合了我们迄今为止学到的所有RxPHP方面。我们还看到了如何通过使所有长时间运行的任务非阻塞来实现真正响应的应用程序。我们使用Symfony
    Console组件来处理来自终端的用户输入和输出。此外，我们还使用了Symfony Process组件来轻松生成并控制子进程。
- en: We also looked at a couple of new classes from RxPHP, such as `ConnectableObservable`, `CompositeDisposable`,
    or `takeWhile()` operator.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了RxPHP的一些新类，例如`ConnectableObservable`、`CompositeDisposable`或`takeWhile()`操作符。
- en: In the following chapter, we'll work with some event-based systems used in popular
    PHP frameworks, such as Symfony, Silex, and Zend Framework, and see how we can
    combine them with the principles of reactive programming.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理一些在流行的PHP框架中使用的基于事件的系统，例如Symfony、Silex和Zend Framework，并了解我们如何将它们与响应式编程的原则结合起来。
