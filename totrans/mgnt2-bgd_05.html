<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;5.&#xA0;Using the Dependency Injection" id="147LC1-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Using the Dependency Injection</h1></div></div></div><p class="calibre7"><span class="strong"><strong class="calibre8">Dependency injection</strong></span> is a software design pattern via which one or more dependencies are injected<a id="id194" class="calibre1"/> or passed by reference into an object. What this exactly means on a practical level is shown in the following two simple examples:</p><div class="informalexample"><pre class="programlisting">public function getTotalCustomers()
{
    $database = new \PDO( … );
    $statement = $database-&gt;query('SELECT …');
    return $statement-&gt;fetchColumn();
}</pre></div><p class="calibre7">Here, you will see a simplified PHP example, where the <code class="email">$database</code> object is created in the <code class="email">getTotalCustomers</code> method. This means that the dependency on the database object is being locked in an object instance method. This makes for tight coupling, which has several disadvantages such as reduced reusability and a possible system-wide effect caused by changes made to some parts of the code.</p><p class="calibre7">A solution to this problem is to avoid methods with these sorts of dependencies by injecting a dependency into a method, as follows:</p><div class="informalexample"><pre class="programlisting">public function getTotalCustomers($database)
{
    $statement = $database-&gt;query('SELECT ...');
    return $statement-&gt;fetchColumn();
}</pre></div><p class="calibre7">Here, a <code class="email">$database</code> object is passed (injected) into a method. That's all that dependency injection is—a simple concept that makes code loosely coupled. While the concept is simple, it may not be easy to implement it across large platforms such as Magento.</p><p class="calibre7">Magento has its own object manager and dependency injection mechanism that we will soon look at in detail in the following sections:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The object manager</li><li class="listitem">Dependency injection</li><li class="listitem">Configuring<a id="id195" class="calibre1"/> class preferences</li><li class="listitem">Using virtual types</li></ul></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note13" class="calibre1"/>Note</h3><p class="calibre7">To follow and test the code examples given in the following sections, we can use the code available at <a class="calibre1" href="https://github.com/ajzele/B05032-Foggyline_Di">https://github.com/ajzele/B05032-Foggyline_Di</a>. To install it, we simply need to download it and put it in the <code class="email">app/code/Foggyline/Di</code> directory. Then, run the following set of commands <a id="id196" class="calibre1"/>on the console within Magento's root directory:</p><div class="informalexample"><pre class="programlisting">php bin/magento module:enable Foggyline_Di
php bin/magento setup:upgrade
php bin/magento foggy:di</pre></div><p class="calibre7">The last command can be used repeatedly when testing the snippets presented in the following section. When <code class="email">php bin/magento foggy:di</code> is run, it will run the code within the <code class="email">execute</code> method in the <code class="email">DiTestCommand</code> class. Therefore, we can use the <code class="email">__construct</code> and <code class="email">execute</code> methods from within the <code class="email">DiTestCommand</code> class and the <code class="email">di.xml</code> file itself as a playground for <span class="strong"><strong class="calibre8">DI</strong></span>.</p></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Using the Dependency Injection" id="147LC1-818f5224668745eb9070ddf1d85e6bfa">
<div class="book" title="The object manager"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec32" class="calibre1"/>The object manager</h1></div></div></div><p class="calibre7">The <a id="id197" class="calibre1"/>initializing of objects in Magento is done via what is called the <span class="strong"><strong class="calibre8">object manager</strong></span>. The object manager itself is an instance of the <code class="email">Magento\Framework\ObjectManager\ObjectManager</code> class that implements the <code class="email">Magento\Framework\ObjectManagerInterface</code> class. The <code class="email">ObjectManager</code> class defines the following three methods:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">create($type, array $arguments = [])</code>: This creates a new object instance</li><li class="listitem"><code class="email">get($type)</code>: This retrieves a cached object instance</li><li class="listitem"><code class="email">configure(array $configuration)</code>: This configures the <code class="email">di</code> instance</li></ul></div><p class="calibre7">The object manager can instantiate a PHP class, which can be a model, helper, or block object. Unless the class that we are working with has already received an instance of the object manager, we can receive it by passing <code class="email">ObjectManagerInterface</code> into the class constructor, as follows:</p><div class="informalexample"><pre class="programlisting">public function __construct(
    \Magento\Framework\ObjectManagerInterface $objectManager
)
{
    $this-&gt;_objectManager = $objectManager;
}</pre></div><p class="calibre7">Usually, we don't have to take care of the constructor parameter's order in Magento. The following example will also enable us to fetch an instance of the object manager:</p><div class="informalexample"><pre class="programlisting">public function __construct(
    $var1,
    \Magento\Framework\ObjectManagerInterface $objectManager,
    $var2 = []
)
{
    $this-&gt;_objectManager = $objectManager;
}</pre></div><p class="calibre7">Though we <a id="id198" class="calibre1"/>can still use plain old PHP to instantiate an object such as <code class="email">$object = new \Foggyline\Di\Model\Object()</code>, by using the object manager, we can take advantage of Magento's advanced object features such as automatic constructor dependency injection and object proxying.</p><p class="calibre7">Here are a few examples of using object manager's <code class="email">create</code> method to create new objects:</p><div class="informalexample"><pre class="programlisting">$this-&gt;_objectManager-&gt;create('Magento\Sales\Model\Order')
$this-&gt;_objectManager-&gt;create('Magento\Catalog\Model\Product\Image')
$this-&gt;_objectManager-&gt;create('Magento\Framework\UrlInterface')
$this-&gt;_objectManager-&gt;create('SoapServer', ['wsdl' =&gt; $url, 'options' =&gt; $options])</pre></div><p class="calibre7">The following are a few examples of using object manager's <code class="email">get</code> method to create new objects:</p><div class="informalexample"><pre class="programlisting">$this-&gt;_objectManager-&gt;get('Magento\Checkout\Model\Session')
$this-&gt;_objectManager-&gt;get('Psr\Log\LoggerInterface')-&gt;critical($e)
$this-&gt;_objectManager-&gt;get('Magento\Framework\Escaper')
$this-&gt;_objectManager-&gt;get('Magento\Sitemap\Helper\Data')</pre></div><p class="calibre7">The object manager's <code class="email">create</code> method always returns a new object instance, while the <code class="email">get</code> method returns a singleton.</p><p class="calibre7">Note how some of the string parameters passed to <code class="email">create</code> and <code class="email">get</code> are actually interface names and not strictly class names. We will soon see why this works with both class names and interface names. For now, it suffices to say that it works because of Magento's dependency injection implementation.</p></div></div>
<div class="book" title="Dependency injection"><div class="book" id="1565U2-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec33" class="calibre1"/>Dependency injection</h1></div></div></div><p class="calibre7">Until<a id="id199" class="calibre1"/> now, we have seen how the object manager has control over the instantiation of dependencies. However, by convention, the object manager isn't supposed to be used directly in Magento. Rather, it should be used for system-level things that bootstrap Magento. We are encouraged to use the module's <code class="email">etc/di.xml</code> file to instantiate objects.</p><p class="calibre7">Let's dissect one of the existing <code class="email">di.xml</code> entries, such as the one found under the <code class="email">vendor/magento/module-admin-notification/etc/adminhtml/di.xml</code> file for the <code class="email">Magento\Framework\Notification\MessageList</code> type:</p><div class="informalexample"><pre class="programlisting">&lt;type name="Magento\Framework\Notification\MessageList"&gt;
    &lt;arguments&gt;
        &lt;argument name="messages" xsi:type="array"&gt;
            &lt;item name="baseurl" xsi:type="string"&gt; Magento\AdminNotification\Model\System \Message\Baseurl&lt;/item&gt;
            &lt;item name="security" xsi:type="string"&gt; Magento\AdminNotification\Model\System\ Message\Security&lt;/item&gt;
            &lt;item name="cacheOutdated" xsi:type="string"&gt; Magento\AdminNotification\Model\System\ Message\CacheOutdated&lt;/item&gt;
            &lt;item name="media_synchronization_error" xsi:type="string"&gt;Magento\AdminNotification\Model\ System\Message\Media\Synchronization\Error&lt;/item&gt;
            &lt;item name="media_synchronization_success" xsi:type="string"&gt;Magento\AdminNotification\Model\ System\Message\Media\Synchronization\Success&lt;/item&gt;
        &lt;/argument&gt;
    &lt;/arguments&gt;
&lt;/type&gt;</pre></div><p class="calibre7">Basically, what this means is that whenever an instance of <code class="email">Magento\Framework\Notification\MessageList</code> is being created, the <code class="email">messages</code> parameter is passed on to the constructor. The <code class="email">messages</code> parameter is being defined as an array, which further consists of other string type items. In this case, values of these string type attributes are class names, as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">Magento\Framework\ObjectManager\ObjectManager</code></li><li class="listitem"><code class="email">Magento\AdminNotification\Model\System\Message\Baseurl</code></li><li class="listitem"><code class="email">Magento\AdminNotification\Model\System\Message\Security</code></li><li class="listitem"><code class="email">Magento\AdminNotification\Model\System\Message\CacheOutdated</code></li><li class="listitem"><code class="email">Magento\AdminNotification\Model\System\Message\Media\Synchronization\Error</code></li><li class="listitem"><code class="email">Magento\AdminNotification\Model\System\Message\Media\Synchronization\Success</code></li></ul></div><p class="calibre7">If you now take a look at the constructor of <code class="email">MessageList</code>, you will see that it is defined in the following way:</p><div class="informalexample"><pre class="programlisting">public function __construct(
    \Magento\Framework\ObjectManagerInterface $objectManager,
    $messages = []
)
{
    //Method body here...
}</pre></div><p class="calibre7">If we <a id="id200" class="calibre1"/>modify the <code class="email">MessageList</code> constructor as follows, the code will work:</p><div class="informalexample"><pre class="programlisting">public function __construct(
    \Magento\Framework\ObjectManagerInterface $objectManager,
    $someVarX = 'someDefaultValueX',
    $messages = []
)
{
    //Method body here...
}</pre></div><p class="calibre7">After modification:</p><div class="informalexample"><pre class="programlisting">public function __construct(
    \Magento\Framework\ObjectManagerInterface $objectManager,
    $someVarX = 'someDefaultValueX',
    $messages = [],
    $someVarY = 'someDefaultValueY'
)
{
    //Method body here...
}</pre></div><p class="calibre7">However, if we change the <code class="email">MessageList</code> constructor to one of the following variations, the code will fail to work:</p><div class="informalexample"><pre class="programlisting">public function __construct(
    \Magento\Framework\ObjectManagerInterface $objectManager,
    $Messages = []
)
{
    //Method body here...
}</pre></div><p class="calibre7">Another variation is as follows:</p><div class="informalexample"><pre class="programlisting">public function __construct(
    \Magento\Framework\ObjectManagerInterface $objectManager,
    $_messages = []
)
{
    //Method body here...
}</pre></div><p class="calibre7">The<a id="id201" class="calibre1"/> name of the <code class="email">$messages</code> parameter in the constructor of the PHP class has to exactly match the name of the argument within the arguments' list of <code class="email">di.xml</code>. The order of parameters in the constructor does not really matter as much as their naming.</p><p class="calibre7">Looking further in the <code class="email">MessageList</code> constructor, if we execute <code class="email">func_get_args</code> somewhere within it, the list of items within the $messages parameter will match and exceed the one shown in <code class="email">vendor/magento/module-admin-notification/etc/adminhtml/di.xml</code>. This is so because the list is not final, as Magento collects the DI definitions from across entire the platform and merges them. So, if another module is modifying the <code class="email">MessageList</code> type, the modifications will be reflected.</p><p class="calibre7">If we perform a string search within all the <code class="email">di.xml</code> files across the entire Magento code base for <code class="email">&lt;type name="Magento\Framework\Notification\MessageList"&gt;</code>, this will yield some additional <code class="email">di.xml</code> files that have their own additions to the <code class="email">MessageList</code> type, as follows:</p><div class="informalexample"><pre class="programlisting">//vendor/magento/module-indexer/etc/adminhtml/di.xml
&lt;type name="Magento\Framework\Notification\MessageList"&gt;
    &lt;arguments&gt;
        &lt;argument name="messages" xsi:type="array"&gt;
            &lt;item name="indexer_invalid_message" xsi:type="string"&gt;Magento\Indexer\Model\Message \Invalid&lt;/item&gt;
        &lt;/argument&gt;
    &lt;/arguments&gt;
&lt;/type&gt;

//vendor/magento/module-tax/etc/adminhtml/di.xml
&lt;type name="Magento\Framework\Notification\MessageList"&gt;
    &lt;arguments&gt;
        &lt;argument name="messages" xsi:type="array"&gt;
            &lt;item name="tax" xsi:type="string"&gt;Magento \Tax\Model\System\Message\Notifications&lt;/item&gt;
        &lt;/argument&gt;
    &lt;/arguments&gt;
&lt;/type&gt;</pre></div><p class="calibre7">What this means is that the <code class="email">Magento\Indexer\Model\Message\Invalid</code> and <code class="email">Magento\Tax\Model\System\Message\Notifications</code> string items are being added to the <code class="email">messages</code> argument and are being made available within the <code class="email">MessageList</code> constructor.</p><p class="calibre7">In the preceding DI example, we only had the <code class="email">$messages</code> parameter defined as one argument of the <code class="email">array</code> type, and the rest were its array items.</p><p class="calibre7">Let's take <a id="id202" class="calibre1"/>a look at a DI example for another type definition. This time, it is the one found under the <code class="email">vendor/magento/module-backend/etc/di.xml</code> file and which is defined as follows:</p><div class="informalexample"><pre class="programlisting">&lt;type name="Magento\Backend\Model\Url"&gt;
    &lt;arguments&gt;
        &lt;argument name="scopeResolver" xsi:type="object"&gt; Magento\Backend\Model\Url\ScopeResolver&lt;/argument&gt;
        &lt;argument name="authSession" xsi:type="object"&gt; Magento\Backend\Model\Auth\Session\Proxy&lt;/argument&gt;
        &lt;argument name="formKey" xsi:type="object"&gt; Magento\Framework\Data\Form\FormKey\Proxy&lt;/argument&gt;
        &lt;argument name="scopeType" xsi:type="const"&gt; Magento\Store\Model\ScopeInterface::SCOPE_STORE &lt;/argument&gt;
        &lt;argument name="backendHelper" xsi:type="object"&gt; Magento\Backend\Helper\Data\Proxy&lt;/argument&gt;
    &lt;/arguments&gt;
&lt;/type&gt;</pre></div><p class="calibre7">Here, you will see a type with several different arguments passed to the constructor of the <code class="email">Magento\Backend\Model\Url</code> class. If you now take a look at the constructor of the <code class="email">Url</code> class, you will see that it is defined in the following way:</p><div class="informalexample"><pre class="programlisting">public function __construct(
    \Magento\Framework\App\Route\ConfigInterface $routeConfig,
    \Magento\Framework\App\RequestInterface $request,
    \Magento\Framework\Url\SecurityInfoInterface $urlSecurityInfo,
    \Magento\Framework\Url\ScopeResolverInterface $scopeResolver,
    \Magento\Framework\Session\Generic $session,
    \Magento\Framework\Session\SidResolverInterface $sidResolver,
    \Magento\Framework\Url\RouteParamsResolverFactory $routeParamsResolverFactory,
    \Magento\Framework\Url\QueryParamsResolverInterface $queryParamsResolver,
    \Magento\Framework\App\Config\ScopeConfigInterface $scopeConfig,
    $scopeType,
    \Magento\Backend\Helper\Data $backendHelper,
    \Magento\Backend\Model\Menu\Config $menuConfig,
    \Magento\Framework\App\CacheInterface $cache,
    \Magento\Backend\Model\Auth\Session $authSession,
    \Magento\Framework\Encryption\EncryptorInterface $encryptor,
    \Magento\Store\Model\StoreFactory $storeFactory,
    \Magento\Framework\Data\Form\FormKey $formKey,
    array $data = []
) {
    //Method body here...
}</pre></div><p class="calibre7">The <code class="email">__construct</code> method here clearly has more parameters than what's defined in the <code class="email">di.xml</code> file. What <a id="id203" class="calibre1"/>this means is that the type argument entries in <code class="email">di.xml</code> do not necessarily cover all the class <code class="email">__construct</code> parameters. The arguments that are defined in <code class="email">di.xml</code> simply impose the types of individual parameters defined in the PHP class itself. This works as long as the <code class="email">di.xml</code> parameters are of the same type or descendants of the same type.</p><p class="calibre7">Ideally, we would not pass the class type but interface into the PHP constructor and then set the type in <code class="email">di.xml</code>. This is where the <code class="email">type</code>, <code class="email">preference</code>, and <code class="email">virtualType</code> play a major role in <code class="email">di.xml</code>. We have seen the role of <code class="email">type</code>. Now, let's go ahead and see what <code class="email">preference</code> does.</p></div>
<div class="book" title="Configuring class preferences" id="164MG1-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec34" class="calibre1"/>Configuring class preferences</h1></div></div></div><p class="calibre7">A great <a id="id204" class="calibre1"/>number of Magento's core classes pass interfaces around constructors. The benefit of this is that the object manager, with the help of <code class="email">di.xml</code>, can decide which class to actually instantiate for a given interface.</p><p class="calibre7">Let's imagine the <code class="email">Foggyline\Di\Console\Command\DiTestCommand</code> class with a constructor, as follows:</p><div class="informalexample"><pre class="programlisting">public function __construct(
    \Foggyline\Di\Model\TestInterface $myArg1,
    $myArg2,
    $name = null
)
{
    //Method body here...
}</pre></div><p class="calibre7">Note how <code class="email">$myArg1</code> is type hinted as the <code class="email">\Foggyline\Di\Model\TestInterface</code> interface. The object manager knows that it needs to look into the entire <code class="email">di.xml</code> for possible <code class="email">preference</code> definitions.</p><p class="calibre7">We can define <code class="email">preference</code> within the module's <code class="email">di.xml</code> file, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;preference
        for="Foggyline\Di\Model\TestInterface"
        type="Foggyline\Di\Model\Cart"/&gt;</pre></div><p class="calibre7">Here, we are basically saying that when someone asks for an instance of <code class="email">Foggyline\Di\Model\TestInterface</code>, give it an instance of the <code class="email">Foggyline\Di\Model\Cart</code> object. For this to work, the <code class="email">Cart</code> class has to implement <code class="email">TestInterface</code> itself. Once the preference definition is in place, <code class="email">$myArg1</code> shown in the preceding example becomes an object of the <code class="email">Cart</code> class.</p><p class="calibre7">Additionally, the <code class="email">preference</code> element is not reserved only to point out the preferred classes for <a id="id205" class="calibre1"/>some interfaces. We can use it to set the preferred class for some other class.</p><p class="calibre7">Now, let's have a look at the <code class="email">Foggyline\Di\Console\Command\DiTestCommand</code> class with a constructor:</p><div class="informalexample"><pre class="programlisting">public function __construct(
    \Foggyline\Di\Model\User $myArg1,
    $myArg2,
    $name = null
)
{
    //Method body here...
}</pre></div><p class="calibre7">Note how <code class="email">$myArg1</code> is now type hinted as the <code class="email">\Foggyline\Di\Model\User</code> class. Like in the previous example, the object manager will look into <code class="email">di.xml</code> for possible <code class="email">preference</code> definitions.</p><p class="calibre7">Let's define the <code class="email">preference</code> element within the module's <code class="email">di.xml</code> file, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;preference
    for="\Foggyline\Di\Model\User"
    type="Foggyline\Di\Model\Cart"/&gt;</pre></div><p class="calibre7">What this <code class="email">preference</code> definition is saying is that whenever an instance of the <code class="email">User</code> class is requested, pass an instance of the <code class="email">Cart</code> object. This will work only if the <code class="email">Cart</code> class extends from <code class="email">User</code>. This is a convenient way of rewriting a class, where the class is being passed directly into another class constructor in place of the interface.</p><p class="calibre7">Since the class <code class="email">__construct</code> parameters can be type hinted as either classes or interfaces and further manipulated via the <code class="email">di.xml</code> preference definition, a question rises as to what is better. Is it better to use interfaces or specific classes? While the answer might not be fully clear, it is always preferable to use interfaces to specify the dependencies we are injecting into the system.</p></div>
<div class="book" title="Using virtual types" id="173721-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec35" class="calibre1"/>Using virtual types</h1></div></div></div><p class="calibre7">Along<a id="id206" class="calibre1"/> with <code class="email">type</code> and <code class="email">preference</code>, there is another powerful feature of <code class="email">di.xml</code> that we can use. The <code class="email">virtualType</code> element enables us to define virtual types. Creating a virtual type is like creating a subclass of an existing class except for the fact that it's done in <code class="email">di.xml</code> and not in code.</p><p class="calibre7"><span class="strong"><strong class="calibre8">Virtual types</strong></span> are <a id="id207" class="calibre1"/>a way of injecting dependencies into some of the existing classes without affecting other classes. To explain this via a practical example, let's take a look at the following virtual type defined in the <code class="email">app/etc/di.xml</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;virtualType name="Magento\Framework\Message\Session\Storage" type="Magento\Framework\Session\Storage"&gt;
    &lt;arguments&gt;
        &lt;argument name="namespace" xsi:type="string"&gt; message&lt;/argument&gt;
    &lt;/arguments&gt;
&lt;/virtualType&gt;
&lt;type name="Magento\Framework\Message\Session"&gt;
    &lt;arguments&gt;
        &lt;argument name="storage" xsi:type="object"&gt; Magento\Framework\Message\Session\Storage&lt;/argument&gt;
    &lt;/arguments&gt;
&lt;/type&gt;</pre></div><p class="calibre7">The <code class="email">virtualType</code> definition in the preceding example is <code class="email">Magento\Framework\Message\Session\Storage</code>, which extends from <code class="email">Magento\Framework\Session\Storage</code> and overwrites the <code class="email">namespace</code> parameter to the <code class="email">message</code> string value. In <code class="email">virtualType,</code> the <code class="email">name</code> attribute defines the globally unique name of the virtual type, while the <code class="email">type</code> attribute matches the real PHP class that the virtual type is based on.</p><p class="calibre7">Now, if you look at the <code class="email">type</code> definition, you will see that its <code class="email">storage</code> argument is set to the object of <code class="email">Magento\Framework\Message\Session\Storage</code>. The <code class="email">Session\Storage</code> file is actually a virtual type. This allows <code class="email">Message\Session</code> to be customized without affecting other classes that also declare a dependency on <code class="email">Session\Storage</code>.</p><p class="calibre7">Virtual types allow us to effectively change the behavior of a dependency when it is used in a specific class.</p></div>
<div class="book" title="Summary" id="181NK1-818f5224668745eb9070ddf1d85e6bfa"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec36" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we had a look at the object manager and dependency injection, which are the foundations of Magento object management. We learned the meaning of the <code class="email">type</code> and <code class="email">preference</code> elements of dependency injection and how to use them to manipulate class construct parameters. Though there is much more to be said about dependency injection in Magento, the presented information should suffice and help us with other aspects of Magento.</p><p class="calibre7">In the next chapter, we will extend our journey into <code class="email">di.xml</code> via the concept of plugins.</p></div></body></html>