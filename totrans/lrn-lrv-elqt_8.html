<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;It's Not Enough! Extending Eloquent, Advanced Concepts"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. It's Not Enough! Extending Eloquent, Advanced Concepts</h1></div></div></div><p>Through this book, you learned that you can do many amazing things with Eloquent. It is a great active record implementation; it's easy to use, really flexible, and it offers many tools out of the box to improve your code base quality.</p><p>A developer usually must face two types of projects: <span class="emphasis"><em>Applications</em></span> and <span class="emphasis"><em>applications</em></span>, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For <span class="emphasis"><em>applications</em></span>, I intend something that you can do, maybe in a quick way, with some workarounds and some hacks, here and there. Also, I know that you know what I am talking about. That site you made for a friend, a little blog, and so on.</li><li class="listitem" style="list-style-type: disc">Let's be clear and serious, you can't make every application with the same, perfect care. Being honest, neither me nor probably any one does. Then, you have to deal with <span class="emphasis"><em>Applications</em></span>. Things can get really serious there, and you must be able to build a maintainable, awesome application structure.</li></ul></div><p>It's not just about something that works; in this case, I am thinking about something that can scale easily, with a good quality code base. It's not just about calling your models from controllers. That's not enough. You could stumble upon many issues: testability, maintainability, and also in following some principles.</p><p>In this chapter, we will explore two different ways to extend Eloquent more seriously.</p><p>In the very first part, you will learn how to extend the Eloquent Model class. Actually, the Model does many things, but what if we need something more? No problem: extending the existing Model class will be a bed of roses if standing on the shoulders of a giant.</p><p>Have you ever heard about the Ardent Project? It's a package for Laravel 4 that extends the Model class, adding some super powers: self-validating models and auto-hydrating from the request input data.</p><p>You'll make something similar for the Laravel 5 Eloquent Model, and I will show you how to do it step by step. Also, it is inspired by the work of Philip Brown in his blog (<a class="ulink" href="http://culttt.com/2013/08/05/extending-eloquent-in-laravel-4/">http://culttt.com/2013/08/05/extending-eloquent-in-laravel-4/</a>).</p><p>However, as mentioned earlier in this book, Laravel is mostly about freedom, especially when it comes to freedom in organizing your projects. Now, a really interesting trend is the <a id="id232" class="indexterm"/>
<span class="strong"><strong>repository pattern</strong></span>. It's a way to abstract your code in a better way and separate responsibilities. For a project bigger than the bakery's blog, it's a must-have in your knowledge base.</p><p>Also, the repository pattern is not something related to Laravel only. This means that you will learn something new that you will be able to reuse in the future, with other languages and products.</p><p>Alright, no more chitchat. It is time to get our hands dirty for the last time.</p><p>Come on, hero! We will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Extending the Model: Aweloquent !</li><li class="listitem" style="list-style-type: disc">Diving into the repository pattern</li><li class="listitem" style="list-style-type: disc">The summary</li></ul></div><div class="section" title="Extending the Model: Aweloquent!"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec50"/>Extending the Model: Aweloquent!</h1></div></div></div><p>The Eloquent Model <a id="id233" class="indexterm"/>can actually do tons of things in a very smart and easy way. However, something can be improved in terms of code to write every time you want to do a specific operation.</p><p>Usually, when<a id="id234" class="indexterm"/> creating a new model instance, you are probably using some data that the user previously typed in to a form.</p><p>Adding a new author to our database can be the perfect example. All you have to do is to insert the first and last names in to a form and then press <span class="strong"><strong>save</strong></span>.</p><p>Then, in the dedicated post route (or relative controller method), you will do something similar to the following:</p><div class="informalexample"><pre class="programlisting">&lt;?php


public function postAdd(Request $request)
{
  $author = new Author;

  $author-&gt;first_name = $request-&gt;input('first_name');
  $author-&gt;last_name = $request-&gt;input('last_name');

  $author-&gt;save();
}</pre></div><p>That's quite fine. However, you will probably also have to validate the user input.</p><p>So, assuming that <a id="id235" class="indexterm"/>you are still in a controller, you could add a controller validator call, just like this one:</p><div class="informalexample"><pre class="programlisting">&lt;?php


public function postAdd(Request $request)
{
  $this-&gt;validate($request, [
    'first_name' =&gt; 'required',
    'last_name' =&gt; 'required'
  ], [
    'first_name.required' =&gt; 'You forgot the first name!',
    'last_name.required' =&gt; 'You forgot the last name!'
  ]);

  $author = new Author;

  $author-&gt;first_name = $request-&gt;input('first_name');
  $author-&gt;last_name = $request-&gt;input('last_name');

  $author-&gt;save();
}</pre></div><p>Once again, saved the day!</p><p>Now, very often, developers debate the responsibilities of a single class in terms of what that class has to do and what not. Everyone has a thought about the topic.</p><p>The <a id="id236" class="indexterm"/>
<span class="strong"><strong>Single Responsibility Principle</strong></span>, a part of the SOLID principles, is very clear about that—put simply, the principle says that a class should do one and only one thing.</p><p>On the other hand, however, you will often find very big classes. The Eloquent Model is one of them. At the time of writing, the Illuminate\Database\Eloquent\Model counts 3,399 lines of code. Not exactly something small!</p><p>Obviously, the Model doesn't perform a single operation; it fills its own attributes, deals with relationships, and serializes its own attributes. Yes, it goes far beyond the principle you just read.</p><p>So, what's the deal with it?</p><p>Well, even if it is very big, a Model like this allows you to perform many operations using a single class.</p><p>A perfect example <a id="id237" class="indexterm"/>is how you can use a Model as a model, like this:</p><div class="informalexample"><pre class="programlisting">&lt;?php

$user = new User;

// using magic methods...
$user-&gt;first_name = 'Francesco';
$user-&gt;last_name = 'Malatesta';

...</pre></div><p>You can also use it as a factory (a class that is used to create instances in a more elegant and better way) using the <code class="literal">create()</code> method:</p><div class="informalexample"><pre class="programlisting">&lt;?php

$user = User::create([
  'first_name' =&gt; 'Francesco',
  'last_name' =&gt; 'Malatesta',
]);</pre></div><p>If this isn't enough, the Model also handles everything related to the persistence of the instance:</p><div class="informalexample"><pre class="programlisting">&lt;?php

$user = new User;

// some assignments...
$user-&gt;first_name = 'Francesco';
// ...

// and then save!
$user-&gt;save();</pre></div><p>All using a single class—that's the main advantage.</p><p>You are probably asking yourself what he is trying to say with all this stuff. The answer is really simple: there isn't always a single correct solution. Some people hate the Eloquent Model, some people love it.</p><p>So, in this specific situation, I will add new features to the existing Model class creating a new Eloquent Model… <span class="strong"><strong>the Aweloquent</strong></span>!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note44"/>Note</h3><p>Before we go any further, here's a clarification. I will repeat it again, but I also want to say it now. In the following part of this chapter, we will extend the Model class adding a feature that, in Laravel, is handled by the <code class="literal">Validator</code> class. I am not teaching you this because I want you to do this, but because I want to show you how to extend the Model class.</p><p>For instance, you will probably find the<a id="id238" class="indexterm"/> <span class="strong"><strong>smart password hashing</strong></span> feature stupid, but it's just an example. Extending Models and using repositories are two different techniques, which are totally separated. I am just giving you the knowledge, then you can choose what to do, and I am sure you will do the right thing, hero!</p></div></div><div class="section" title="The Aweloquent Model"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec59"/>The Aweloquent Model</h2></div></div></div><p>As I mentioned earlier, our powered-up <a id="id239" class="indexterm"/>Eloquent Model will be really similar to the Ardent Laravel 4 package-improved Model. I will also borrow some ideas from Philip Brown's Magniloquent project.</p><p>To be more precise, our <a id="id240" class="indexterm"/>improved Model will feature the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Auto Hydrate</li><li class="listitem" style="list-style-type: disc">Model self-validation</li><li class="listitem" style="list-style-type: disc">Smart password hashing</li><li class="listitem" style="list-style-type: disc">The autopurge of confirmation fields</li></ul></div><div class="section" title="Auto Hydrate"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec07"/>Auto Hydrate</h3></div></div></div><p>Instead of <a id="id241" class="indexterm"/>assigning attributes individually, or passing them in an array, the Aweloquent Model will be able to read the current request and autopopulate its attributes without any other code lines.</p><p>This means that you will be able to use the following:</p><div class="informalexample"><pre class="programlisting">&lt;?php

$user = new User;
$user-&gt;save();</pre></div><p>Instead of the more classic:</p><div class="informalexample"><pre class="programlisting">&lt;?php

$user = new User;

$user-&gt;first_name = 'Francesco';
$user-&gt;last_name = 'Malatesta';
// other assignments here...

$user-&gt;save();</pre></div></div><div class="section" title="Model self-validation"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec08"/>Model self-validation</h3></div></div></div><p>You will<a id="id242" class="indexterm"/> be able to specify validation rules and messages as static properties of a Model. Then, the Model will automatically perform the validation operation you need, without using any external classes or controller validators. You will be able, also, to assign a certain rule to a certain operation (the <code class="literal">'create'</code> or the <code class="literal">'update'</code> operation, or both).</p><p>So, in your Model, you will have something like this:</p><div class="informalexample"><pre class="programlisting">&lt;?php namespace App;

use App\Aweloquent\AweloquentModel;

class Author extends AweloquentModel {

  protected $fillable = [
    'first_name', 'last_name', 'bio'
  ];

  protected static $rules = [
    'everytime' =&gt; [
      'first_name' =&gt; 'required'
    ],

     'create' =&gt; [
      'last_name' =&gt; 'required'
    ],

    'update' =&gt; [
      'bio' =&gt; 'required'
    ],
  ];

  protected static $messages = [
    'first_name.required' =&gt; 'You forgot the first name!',
    'last_name.required' =&gt; 'You forgot the last name!',
    'bio.required' =&gt; 'You forgot the biography!'
  ];

}</pre></div></div><div class="section" title="Smart password hashing"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec09"/>Smart password hashing</h3></div></div></div><p>Another <a id="id243" class="indexterm"/>thing you have to do frequently is to <span class="strong"><strong>hash a password</strong></span>. Usually, you take the value from a <code class="literal">password</code> attribute. So, the Aweloquent Model automatically performs the hash operation on a <code class="literal">password</code> field, if present.</p></div><div class="section" title="The autopurge of confirmation fields"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec10"/>The autopurge of confirmation fields</h3></div></div></div><p>The Laravel<a id="id244" class="indexterm"/> validator has the confirmed rule, based on an <code class="literal">x_confirmation</code> attribute (where <code class="literal">x</code> is the name of the field). You have probably used it used it for a password confirmation field. The auto purge feature of the Aweloquent Model automatically removes (after validation, of course) every <code class="literal">_confirmation</code> field.</p><p>However, it's not over yet! The Aweloquent Model will automatically exclude the <code class="literal">'_token'</code> field, used by the <span class="strong"><strong>Cross Site Request Forgery</strong></span> (<span class="strong"><strong>CSRF</strong></span>)<a id="id245" class="indexterm"/> protection middleware.</p><p>Alright, that's all! Now you can write some code.</p></div></div><div class="section" title="Extending the class"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec60"/>Extending the class</h2></div></div></div><p>The first thing <a id="id246" class="indexterm"/>you have to do is to create a new class, the <code class="literal">AweloquentModel</code> class that extends the existing Eloquent Model one.</p><p>In my specific case, I made something really simple: I created a new folder called <code class="literal">Aweloquent</code> in the <code class="literal">app</code> one and then created an <code class="literal">AweloquentModel.php</code> file inside.</p><p>Here's the code you have to put into this file:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace App\Aweloquent;

use Illuminate\Database\Eloquent\Model;

class AweloquentModel extends Model {}</pre></div><p>Great! As a start, we have our new <code class="literal">AweloquentModel</code> class.</p><p>If you want, you can use it as a base for your future models. There are no changes here, just a simple extension.</p><p>Let's add the first feature: Auto Hydrate.</p></div><div class="section" title="The Auto Hydrate feature"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec61"/>The Auto Hydrate feature</h2></div></div></div><p>Before we <a id="id247" class="indexterm"/>implement this first feature, let's think about what we want as a result.</p><p>Actually, when you create a new model, you can quickly pass its attributes using the constructor:</p><div class="informalexample"><pre class="programlisting">&lt;?php

$user = new User([
  'first_name' =&gt; 'Francesco',
  'last_name' =&gt; 'Malatesta'
]);</pre></div><p>These parameters are passed from the constructor to another method called <code class="literal">fill()</code>:</p><div class="informalexample"><pre class="programlisting">/**
   * Create a new Eloquent model instance.
   *
   * @param  array  $attributes
   * @return void
   */

  public function __construct(array $attributes = array())
  {
    $this-&gt;bootIfNotBooted();

    $this-&gt;syncOriginal();

    $this-&gt;fill($attributes);
  }</pre></div><p>As a logical consequence, if we want to implement this Auto Hydrate feature, we will have to write a new constructor to deal with the auto hydrating there and then to call the parent class. So, let's go back to our <code class="literal">AweloquentModel</code> class. Here's the first implementation:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace App\Aweloquent;

use Illuminate\Database\Eloquent\Model;

class AweloquentModel extends Model {

  public function __construct(array $attributes = [])
  {
    $attributes = $this-&gt;autoHydrate($attributes);

    parent::__construct($attributes);
  }

  private function autoHydrate(array $attributes)
  {
    // getting the request instance using the service container
    $request = app('Illuminate\Http\Request');

    // getting the request form data, except the token
    $requestData = $request-&gt;except('_token');

    foreach($requestData as $name =&gt; $value)
    {
      // manually specified attribute has priority over auto- 
	  hydrated one.
      if(!isset($attributes[$name]))
      $attributes[$name] = $value;
    }

    return $attributes;
  }
}</pre></div><p>The <code class="literal">autoHydrate</code> method creates the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An instance of the current request to get the required data</li><li class="listitem" style="list-style-type: disc">After that, and for each cycle, it adds to the attributes array every element in the request data array (excluding the CSRF <code class="literal">'_token'</code>)</li></ul></div><p>Note that <a id="id248" class="indexterm"/>the explicit specified attribute (the one you can put in the Model constructor) has the priority over the request data array. So, you are still free to deal with the Model and decide what to define and what not, maybe to add some extra data that you are not getting from the form.</p><p>If you try to create a new user by setting up a basic form, the Auto Hydrate feature is already working.</p><p>Let's move forward!</p></div><div class="section" title="The Aweloquent Model self-validation feature – the basic version"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec62"/>The Aweloquent Model self-validation feature – the basic version</h2></div></div></div><p>It is time to implement the<a id="id249" class="indexterm"/> self-validation feature of our Aweloquent Model. The idea is quite simple: for every model, you will be able to declare (as properties) rules and related messages. So, it should look something like this:</p><div class="informalexample"><pre class="programlisting">&lt;?php namespace App;

use App\Aweloquent\AweloquentModel;

class Author extends AweloquentModel {

  protected $fillable = [
    'first_name', 'last_name', 'bio'
  ];

  protected static $rules = [
    'first_name' =&gt; 'required',
    'last_name' =&gt; 'required'
  ];

  protected static $messages = [
    'first_name.required' =&gt; 'You forgot the first name!',
    'last_name.required' =&gt; 'You forgot the last name!'
  ];

}</pre></div><p>These rules<a id="id250" class="indexterm"/> and message will be used automatically by a <code class="literal">validate()</code> dedicated method. What I want to achieve is something like this:</p><div class="informalexample"><pre class="programlisting">&lt;?php

$user = new User;

if(!$user-&gt;validate())
{
  dd($user-&gt;errors);
}</pre></div><p>So, let's open the <code class="literal">AweloquentModel.php</code> file and add some code:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace App\Aweloquent;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\Validator;

class AweloquentModel extends Model {

  protected static $rules = [];
  protected static $messages = [];

  public $errors;

  public function __construct(array $attributes = [])
  {
    $attributes = $this-&gt;autoHydrate($attributes);

    parent::__construct($attributes);
  }

  public function validate()
  {
    $validator = Validator::make($this-&gt;attributes, static::$rules, static::$messages);

    if($validator-&gt;fails())
    {
      $this-&gt;errors = $validator-&gt;messages();
      return false;
    }

    return true;
  }

  private function autoHydrate(array $attributes)
  {
    // auto hydrate method here...
  }

}</pre></div><p>Great! The <code class="literal">Validator</code> <code class="literal">Facadec</code> is <a id="id251" class="indexterm"/>used to instantiate a new validator. The static <code class="literal">$rules</code> and <code class="literal">$message</code> attributes are used for the <code class="literal">make()</code> method.</p><p>Then, the <code class="literal">$validator-&gt;fails()</code> call determines if the given model is valid or not. If not, the <code class="literal">$errors</code> property is populated using the validation errors <code class="literal">MessageBag</code> object.</p><p>Obviously, this is a very basic validation system. However, we could do something more. For instance, an implementation of an operation-based validation would be great.</p><p>Go ahead and try it, if you want! It already works!</p></div><div class="section" title="The Aweloquent Model self-validation feature – the operation-based version"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec63"/>The Aweloquent Model self-validation feature – the operation-based version</h2></div></div></div><p>In order to<a id="id252" class="indexterm"/> implement the advanced version of the self-validation system, we have to define the rule format for every model.</p><p>In this specific one, I have chosen something like this:</p><div class="informalexample"><pre class="programlisting">&lt;?php namespace App;

use App\Aweloquent\AweloquentModel;

class Author extends AweloquentModel {

  protected $fillable = [
    'first_name', 'last_name', 'bio'
  ];

  protected static $rules = [
    'everytime' =&gt; [
      'first_name' =&gt; 'required'
    ],

    'create' =&gt; [
      'last_name' =&gt; 'required'
    ],

    'update' =&gt; [
      'bio' =&gt; 'required'
    ],
  ];

  protected static $messages = [
    'first_name.required' =&gt; 'You forgot the first name!',
    'last_name.required' =&gt; 'You forgot the last name!',
    'bio.required' =&gt; 'You forgot the biography!'
  ];

}</pre></div><p>The <code class="literal">$message</code> property is left untouched. The only one that has to be modified is <code class="literal">$rules</code>, as you may easily imagine.</p><p>In this new version of <code class="literal">$rules</code>, you can define rules for a single operation, <code class="literal">'create'</code>, or both. If you want to use a rule in both of them, there is a dedicated <code class="literal">'everytime'</code> item to avoid the duplication of rules.</p><p>Of course, we <a id="id253" class="indexterm"/>have to edit our <code class="literal">AweloquentModel</code> once again. This time, we have to define a method that has to work with the existing validate one and understand if we are creating or updating it.</p><p>Then, merge the right rules in a single array and validate the model against those rules.</p><p>Let's see what we can do! Consider the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?php



class AweloquentModel extends Model {

  ...

  public function __construct(array $attributes = [])
  {
    // constructor remains the same…
  }

  public function validate()
  {
    static::$rules = $this-&gt;mergeValidationRules();

    $validator = Validator::make($this-&gt;attributes, static::$rules, static::$messages);

    if($validator-&gt;fails())
    {
      $this-&gt;errors = $validator-&gt;messages();
      return false;
    }

    return true;
  }

  private function mergeValidationRules()
  {
    // if updating, use "update" rules, "create" otherwise.
    if($this-&gt;exists)
      $mergedRules = array_merge_recursive(static::$rules['everytime'], static::$rules
      ['update']);
  else
    $mergedRules = array_merge_recursive(static::$rules['everytime'], static::$rules

    ['create']);

  $finalRules = [];

  foreach($mergedRules as $field =&gt; $rules){
    if(is_array($rules))
      $finalRules[$field] = implode("|", $rules);
    else
      $finalRules[$field] = $rules;
    }

    return $finalRules;
  }

}</pre></div><p>Great, we have it!</p><p>The <code class="literal">validate()</code> method <a id="id254" class="indexterm"/>doesn't change too much. The only big difference stands in the newly line:</p><div class="informalexample"><pre class="programlisting">static::$rules = $this-&gt;mergeValidationRules();</pre></div><p>Basically, we are saying, "Ok, now assign to the <code class="literal">$rules</code> property the result of this <code class="literal">mergeValidationRules()</code> method."</p><p>Then, in the <code class="literal">mergeValidationRules()</code> method, the first instruction to be used is:</p><div class="informalexample"><pre class="programlisting">if($this-&gt;exists)</pre></div><p>That is used to determine if the current operation is an insert or an update. Starting from this value, we can get the right rules array, merging them with the <code class="literal">everytime</code> rules.</p><p>Your new complex self-validating model is almost ready to be used.</p></div><div class="section" title="Smart password hashing and the confirmation fields autopurge method"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec64"/>Smart password hashing and the confirmation fields autopurge method</h2></div></div></div><p>The last features we have to implement are the<a id="id255" class="indexterm"/> smart password hashing and confirmation fields auto purge methods.</p><p>The first is very easy and intuitive:</p><div class="informalexample"><pre class="programlisting">private function smartPasswordHashing()
{
  if($this-&gt;attributes['password'])
    $this-&gt;attributes['password'] = Hash::make($this- &gt;attributes['password']);
}</pre></div><p>If a <code class="literal">'password'</code> field is present, hash it. Nothing more!</p><p>Even if, it's a little<a id="id256" class="indexterm"/> longer, the <code class="literal">purgeConfirmationFields()</code> isn't so hard to understand:</p><div class="informalexample"><pre class="programlisting">private function purgeConfirmationFields()
{
  foreach($this-&gt;attributes as $name =&gt; $value)
  {
    if(Str::endsWith($name, '_confirmation'))
      unset($this-&gt;attributes[$name]);
  }
}</pre></div><p>This time, I used the <code class="literal">Str</code> string utility class in order to use the <code class="literal">endsWith()</code> method, which is used to determine if a strings ends with a certain sequence of characters. Every <code class="literal">'_confirmation'</code> field is removed.</p></div><div class="section" title="Fixing the save() Model method"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec65"/>Fixing the save() Model method</h2></div></div></div><p>Now, the <a id="id257" class="indexterm"/>last thing that we need to fix is the <code class="literal">save()</code> method. Actually, the <code class="literal">save()</code> method totally ignores the validation procedure, and this is no good. So, this is my final version of the <code class="literal">AweloquentModel</code> class:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace App\Aweloquent;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Str;

class AweloquentModel extends Model {

  protected static $rules = [];
  protected static $messages = [];

  public $errors;

  public function __construct(array $attributes = [])
  {
    $attributes = $this-&gt;autoHydrate($attributes);

    parent::__construct($attributes);
  }

  public function save(array $options = [])
  {
    if($this-&gt;validate())
    {
      $this-&gt;smartPasswordHashing();
      $this-&gt;purgeConfirmationFields();

      return parent::save($options);
    }
    else
      return false;
  }

  public function validate()
  {
    static::$rules = $this-&gt;mergeValidationRules();

    $validator = Validator::make($this-&gt;attributes, static::$rules, static::$messages);

    if($validator-&gt;fails())
    {
      $this-&gt;errors = $validator-&gt;messages();
      return false;
    }

    return true;
  }

  private function autoHydrate(array $attributes)
  {
    // getting the request instance using the service container
    $request = app('Illuminate\Http\Request');

    // getting the request form data, except the token
    $requestData = $request-&gt;except('_token');

    foreach($requestData as $name =&gt; $value)
    {
      // manually specified attribute has priority over auto- 
	  hydrated one.
      if(!isset($attributes[$name]))
        $attributes[$name] = $value;
    }

    return $attributes;
  }

  private function mergeValidationRules()
  {
    // if updating, use "update" rules, "create" otherwise.
    if($this-&gt;exists)
      $mergedRules = array_merge_recursive(static::$rules['everytime'], static::$rules

      ['update']);
    else
      $mergedRules = array_merge_recursive(static::$rules['everytime'], static::$rules

    ['create']);

    $finalRules = [];

    foreach($mergedRules as $field =&gt; $rules){
      if(is_array($rules))
        $finalRules[$field] = implode("|", $rules);
      else
        $finalRules[$field] = $rules;
    }

    return $finalRules;
  }

  private function smartPasswordHashing()
  {
    if($this-&gt;attributes['password'])
      $this-&gt;attributes['password'] = Hash::make($this- &gt;attributes['password']);
  }

  private function purgeConfirmationFields()
  {
    foreach($this-&gt;attributes as $name =&gt; $value)
    {
      if(Str::endsWith($name, '_confirmation'))
        unset($this-&gt;attributes[$name]);
    }
  }
}</pre></div><p>Let's analyze the <code class="literal">save()</code> method in detail:</p><div class="informalexample"><pre class="programlisting">public function save(array $options = [])
{
  if($this-&gt;validate())
  {
    $this-&gt;smartPasswordHashing();
    $this-&gt;purgeConfirmationFields();

    return parent::save($options);
  }
  else
    return false;
}</pre></div><p>The first <a id="id258" class="indexterm"/>thing to do is to validate the entire input. After that, if everything is fine, passwords are hashed and the confirmation fields are purged, as we don't need them anymore.</p><p>Finally, the <code class="literal">parent::save()</code> method is called, and the operation is complete.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note45"/>Note</h3><p>In order to create a perfect continuity with the parent class, I declared the <code class="literal">save()</code> method with the same signature as its parent (including the <code class="literal">$options</code> array parameter).</p></div></div><p>That's it! The <code class="literal">AweloquentModel</code> class is finished, and you can use it as you want in your projects. You also learned how to go deep inside the <code class="literal">Model</code> class and extend it in order to add new methods, behaviors, and features.</p></div></div></div>
<div class="section" title="Diving into the repository pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec51"/>Diving into the repository pattern</h1></div></div></div><p>If you know<a id="id259" class="indexterm"/> a couple of things about good development and best practices, you have probably heard about software design patterns.</p><p>You can define them as useful solution templates for a certain kind of problem, or to be more precise:</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em>"In software engineering, a design pattern is a general reusable solution to a commonly occurring problem within a given context in software design. A design pattern is not a finished design that can be transformed directly into source or machine code. It is a description or template for how to solve a problem that can be used in many different situations. Patterns are formalized best practices that the programmer can use to solve common problems when designing an application or system."</em></span>
</p></blockquote></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note46"/>Note</h3><p>This extract is from the <a id="id260" class="indexterm"/>software design patterns page (<a class="ulink" href="http://en.wikipedia.org/wiki/Software_design_pattern">http://en.wikipedia.org/wiki/Software_design_pattern</a>) on Wikipedia.</p></div></div><p>Now, let's focus on the second sentence.</p><p>A<a id="id261" class="indexterm"/> design pattern is not something that can be transformed directly into source code.</p><p>That's the most important part because it explains many things. It is not something you learn specifically for Laravel or maybe for a certain language.</p><p>Absolutely, once you learned about design patterns, it is for life!</p><p>In the previous part of this chapter, you learned how to create an improved version of the Eloquent Model. You reached the objective by adding something to the existing model.</p><p>However, many people don't like that kind of approach. They strongly believe in the Single Responsibility Principle, so every class must do one and only one thing. Nothing more!</p><p>Let's be clear; I don't want to bore you by adding my useless opinion in this long-time debate.</p><p>In the final part of this chapter, I will introduce a specific design pattern that can be really useful for improving a Laravel application—the repository pattern.</p><div class="section" title="Hello, repository pattern!"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec66"/>Hello, repository pattern!</h2></div></div></div><p>You know <a id="id262" class="indexterm"/>that I like to explain a concepts with an example as a start. This is no exception.</p><p>Imagine that you are building an application for a warehouse. In this warehouse, you can store whatever you want and you probably have a model like this:</p><div class="informalexample"><pre class="programlisting">&lt;?php namespace Warehouse;

use Illuminate\Database\Eloquent\Model;

class Item extends Model {

  // properties and methods here...

}
You are probably using this model in a controller, like this one:
&lt;?php namespace Warehouse\Http\Controllers;

class ItemsController extends Controller {

  public function getIndex()
  {
    $items = \Warehouse\Item::orderBy('created_at', 'DESC')- &gt;paginate(30);

    return view('item.list', compact('items'));
  }

}</pre></div><p>There's nothing to say; it works, and you know it.</p><p>This is a cool solution for a simple project, the kind of project that you can call an <span class="emphasis"><em>application</em></span>. However, what happens if we don't have an <span class="emphasis"><em>Application</em></span>, instead?</p><p>Imagine that the business you're helping grows and the management decides to create a mobile application that must be used internally. You will probably need to implement an API for the other developers.</p><p>If you don't know how to deal with something like this, you will soon start to write duplicated code. In your Rest API, for sure, there will be an endpoint <code class="literal">\items</code> that does the same thing you did in the controller method such as:</p><div class="informalexample"><pre class="programlisting">$items = \Warehouse\Item::orderBy('created_at', 'DESC')-&gt;paginate(30);</pre></div><p>Repeating the same code many times isn't safe. You know it, right?</p><p>But no fear, hero! The solution is <a id="id263" class="indexterm"/>called a <span class="strong"><strong>repository pattern</strong></span>.</p><p>The best definition of this<a id="id264" class="indexterm"/> concept is the one you can find on Martin Fowler's website (<a class="ulink" href="http://martinfowler.com/eaaCatalog/repository.html">http://martinfowler.com/eaaCatalog/repository.html</a>):</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em>"A Repository mediates between the domain and data mapping layers, acting like an in-memory domain object collection. Client objects construct query specifications declaratively and submit them to Repository for satisfaction.</em></span>
</p><p>
<span class="emphasis"><em>Objects can be added to and removed from the Repository, as they can from a simple collection of objects, and the mapping code encapsulated by the Repository will carry out the appropriate operations behind the scenes."</em></span>
</p></blockquote></div><p>So, imagine <a id="id265" class="indexterm"/>a repository as something in between that abstracts all the necessary.</p><p>Going back to the previous example, imagine that we have a repository with a dedicated method <code class="literal">getRecent($perPage, $pageNumber)</code>.</p><p>We will use the same method in the controller:</p><div class="informalexample"><pre class="programlisting"> &lt;?php namespace Warehouse\Http\Controllers;

class ItemsController extends Controller {

  public function getIndex(ItemsRepository $itemsRepository)
  {
    // this is an example...
    $items = $itemsRepository-&gt;getRecent(30, 1);	

    return view('item.list', compact('items'));
  }

}</pre></div><p>In the Rest API, the following method is used:</p><div class="informalexample"><pre class="programlisting">&lt;?php

Route::get('api/v1/items', function(ItemsRepository $repo){

  return $repo-&gt;getRecent(30, 1);

});</pre></div><p>The same code is used twice and written once. However, there's more than this; let's see how to implement repositories in a Laravel project.</p></div><div class="section" title="Introducing repositories – a concrete implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec67"/>Introducing repositories – a concrete implementation</h2></div></div></div><p>The best way <a id="id266" class="indexterm"/>to start with repositories is to implement a concrete implementation. As I mentioned earlier, a repository stands between the controller and model. It is something in the middle.</p><p>When you build a repository, you must do it thinking about what you will need from the repository. Let's imagine something for our <code class="literal">Author</code> model.</p><p>I will probably need the following methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getAll($perPage, $pageNumber)</code>: This <a id="id267" class="indexterm"/>returns a paginated list of every author in my data source</li><li class="listitem" style="list-style-type: disc"><code class="literal">find($authorId)</code>: This <a id="id268" class="indexterm"/>returns a specific author with a certain primary key</li><li class="listitem" style="list-style-type: disc"><code class="literal">search($firstName, $lastName)</code>: This <a id="id269" class="indexterm"/>returns an array of results starting from the first name to the last name</li></ul></div><p>Enough of <a id="id270" class="indexterm"/>searching for and getting records! However, we will also need other methods, which are dedicated to data persistence:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">create($authorData)</code>: This<a id="id271" class="indexterm"/> will save a new author in the data source</li><li class="listitem" style="list-style-type: disc"><code class="literal">save($authorData, $authorId)</code>: This <a id="id272" class="indexterm"/>will update an existing author in the data source with a certain primary key</li></ul></div><p>Let's start!</p><p>First of all, create a new directory in the <code class="literal">app</code> folder. Name it <code class="literal">Repositories</code>. Inside it, create a new file called <code class="literal">DbAuthorsRepository.php</code>.</p><p>Here's the content:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace App\Repositories;

use App\Author;

class DbAuthorsRepository {

  private $model;

  public function __construct(Author $model)
  {
    $this-&gt;model = $model;
  }

  public function getAll($perPage, $pageNumber)
  {
    $authors = $this-&gt;model-&gt;skip(($pageNumber - 1) * $perPage)- &gt;take($perPage)-&gt;get();
    return $authors-&gt;toArray();
  }

  public function find($authorId)
  {
    return $this-&gt;model-&gt;find($authorId)-&gt;toArray();
  }

  public function search($firstName, $lastName)
  {
    return $this-&gt;model
    -&gt;where('first_name', 'LIKE', '%'.$firstName.'%')
    -&gt;where('last_name', 'LIKE', '%'.$lastName.'%')
    -&gt;get()
    -&gt;toArray();
  }

  public function create($authorData)
  {
    return $this-&gt;model-&gt;create($authorData);
  }

  public function update($authorData, $authorId)
  {
    return $this-&gt;model-&gt;find($authorId)-&gt;update($authorData);
  }

}</pre></div><p>This is how you <a id="id273" class="indexterm"/>can use it in some test routes:</p><div class="informalexample"><pre class="programlisting">&lt;?php

Route::get('authors', function(\App\Repositories\DbAuthorsRepository $repository){

  return $repository-&gt;getAll(10, 1);

});

Route::get('create_author', function(\App\Repositories\DbAuthorsRepository $repository){

  $repository-&gt;create([
    'first_name' =&gt; 'Francesco',
    'last_name' =&gt; 'Malatesta',
    'bio' =&gt; 'Lorem ipsum...'
  ]);

});

Route::get('update_author', function(\App\Repositories\DbAuthorsRepository $repository){

  $repository-&gt;update([
    'first_name' =&gt; 'Frank',
    'last_name' =&gt; 'Smith',
    'bio' =&gt; 'Other ipsum...'
  ], 6);

});</pre></div><p>Nothing more!</p><p>By creating a<a id="id274" class="indexterm"/> repository, you learned how to improve your software architecture and the abstraction level of your solution. Also, instead of what you saw earlier in this chapter with Aweloquent, this time you can feel a great separation of responsibilities.</p><p>However, this is not the end yet; the repository pattern hasn't yet shown all of its power.</p></div><div class="section" title="Coding on Abstractions"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec68"/>Coding on Abstractions</h2></div></div></div><p>I already<a id="id275" class="indexterm"/> introduced you to the SOLID principles earlier in this chapter. I mentioned the Single Responsibility Principle, the <span class="emphasis"><em>S</em></span> of SOLID. Now that we are close to the end, I will introduce the <span class="emphasis"><em>D</em></span>.</p><p>The dependency inversion principle is one of my favorites because it really highlights the importance of abstracting your code base the best you can.</p><p>Its definition is:</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em>"A. High-level modules should not depend on low-level modules. Both should depend on abstractions.</em></span>
</p><p>
<span class="emphasis"><em>B. Abstractions should not depend on details. Details should depend on abstractions."</em></span>
</p><p>
<span class="emphasis"><em>-Wikipedia (<a class="ulink" href="http://en.wikipedia.org/wiki/Dependency_inversion_principle">http://en.wikipedia.org/wiki/Dependency_inversion_principle</a>)</em></span>
</p></blockquote></div><p>In a few words, the concept is that you must code abstractions and should not depend on concrete classes. Else, a better way to say it: you must depend on abstractions and not on concrete classes.</p><p>In PHP, talking about abstraction refers to working with interfaces and contracts.</p><p>In a certain sense, Laravel itself widely uses this concept. The basic Laravel package is <code class="literal">Contracts</code>, that is made up of several interfaces that specify whatevery component must do and how it does it.</p><p>However, it's <a id="id276" class="indexterm"/>not just about a framework big thing. You can apply this principle in your everyday development. More specifically, you can apply the concept to repositories.</p><p>I will show you how!</p></div><div class="section" title="Repositories – a complete implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec69"/>Repositories – a complete implementation</h2></div></div></div><p>Before we dive in, let's<a id="id277" class="indexterm"/> introduce a little problem to our software.</p><p>Actually, our situation is the following: our controllers and routes use the <code class="literal">DbAuthorsRepository</code> class to get data, like this:</p><div class="informalexample"><pre class="programlisting">Route::get('authors', function(\App\Repositories\DbAuthorsRepository $repository){

  return $repository-&gt;getAll(10, 1);

});</pre></div><p>Then, the <code class="literal">DbAuthorsRepository</code> class uses the Author model in order to get the desired data from the physical storage:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace App\Repositories;

use App\Author;

class DbAuthorsRepository {

  private $model;

  public function __construct(Author $model)
  {
    $this-&gt;model = $model;
  }

  public function getAll($perPage, $pageNumber)
  {
    $authors = $this-&gt;model-&gt;skip(($pageNumber - 1) * $perPage)- &gt;take($perPage)-&gt;get();
    return $authors-&gt;toArray();
  }



}</pre></div><p>Now, let's imagine that our data sources change. For a certain reason (I know, that is quite paradoxical), the management wants to switch to a file-based storage.</p><p>You have two ways to deal with this problem:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You scream and are paralyzed by fear</li><li class="listitem" style="list-style-type: disc">Decide to organize your code base in a better way, introducing interfaces in to your repository workflow</li></ul></div><p>Here's the plan:</p><p>Using the Laravel service container, you can decide to bind a certain interface to a specific implementation.</p><p>So, if you<a id="id278" class="indexterm"/> create an interface for every repository, you will be able to write your code once and then write every concrete repository you need and, finally, to switch from one repository to another, you will have to change a single line of code.</p><p>However, let's make it step by step:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, let's define a standard behavior for our author's repository defining an <code class="literal">AuthorRepository</code> interface. Create a new <code class="literal">AuthorRepository.php</code> file in <code class="literal">app/Repositories/Contracts</code>. I will use the <code class="literal">Contracts</code> folder for interfaces.<p>Here're the contents of the fresh file:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace App\Repositories\Contracts;
interface AuthorsRepository {

  public function getAll($perPage, $pageNumber);

  public function find($authorId);

  public function search($firstName, $lastName);

  public function create($authorData);

  public function update($authorData, $authorId);

}</pre></div><p>Interfaces are pure abstraction. All we are saying here is, "When I build a new author repository, I don't care about the underlying implementation. I don't care if I am working with a NoSQL database or a flat file driver. All I want is that every repository implements all these methods."</p><p>Working in this manner means that we can define a standard format for every component (or repository, in this case) that we will use in the future.</p></li><li class="listitem">Now we can update our <code class="literal">DbAuthorsRepository</code> class in order to implement our interface. Consider the following line:<div class="informalexample"><pre class="programlisting">class DbAuthorsRepository {
It now becomes:
class DbAuthorsRepository implements AuthorsRepository {</pre></div><p>Ok. Now, let's see the power of the entire mechanism in action.</p></li><li class="listitem">First of <a id="id279" class="indexterm"/>all, open the <code class="literal">app/Providers/AppServiceProvider.php</code> file and add this binding to the <code class="literal">register()</code> method:<div class="informalexample"><pre class="programlisting">public function register()
{
  $this-&gt;app-&gt;bind(
    'App\Repositories\Contracts\AuthorsRepository',
    'App\Repositories\DbAuthorsRepository'
  );
}</pre></div><p>Laravel now knows that every time you will request an instance of <code class="literal">AuthorsRepository</code>, it will have to create an instance of the <code class="literal">DbAuthorsRepository</code> using the service container.</p></li><li class="listitem">To test our assumptions, open the routes file and add this:<div class="informalexample"><pre class="programlisting">&lt;?php

Route::get('authors', function(\App\Repositories\Contracts\AuthorsRepository $repository){

    return $repository-&gt;getAll(10, 1);

});</pre></div><p>The result will be exactly what we are expecting. Also, using the method injection technique, we don't have to explicitly call the service container.</p></li><li class="listitem">In fact, an<a id="id280" class="indexterm"/> alternative to this syntax would be the following:<div class="informalexample"><pre class="programlisting">Route::get('authors', function(){

    $repository = app('App\Repositories\Contracts\AuthorsRepository');

    return $repository-&gt;getAll(10, 1);

});</pre></div></li></ol></div><div class="section" title="Adding the new repository"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec11"/>Adding the new repository</h3></div></div></div><p>Finally, we<a id="id281" class="indexterm"/> are close to the end. Let's return to our main problem: we have to implement a new file-based author's repository.</p><p>At this point, it is quite easy:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, create a new file in <code class="literal">app/Repositories</code>, called <code class="literal">FileAuthorsRepository</code>. It will be a new class, of course.</li><li class="listitem">It will implement the AuthorsRepository interface, obviously.<p>Here are the class contents:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace App\Repositories;

use App\Repositories\Contracts\AuthorsRepository;

class FileAuthorsRepository implements AuthorsRepository {

  public function getAll($perPage, $pageNumber)
  {
    dd('getting all records from flat file driver...');
  }

  public function find($authorId)
  {
    dd('searching by id: ' . $authorId);
  }

  public function search($firstName, $lastName)
  {
    dd('searching by first and last name...', $firstName, $lastName);
  }

  public function create($authorData)
  {
    dd('creating new author ', $authorData);
  }

  public function update($authorData, $authorId)
  {
    dd('updating author ' . $authorId, $authorData);
  }

}</pre></div><p>As you can easily see, I have implemented all the required methods from the interface. This means that our application will be able to use the FileAuthorsRepository in the same way as the DbAuthorsRepository.</p></li><li class="listitem">I filled <a id="id282" class="indexterm"/>method bodies with some <code class="literal">dd</code> instructions, just to show you how the concept works. For our final step, go to the <code class="literal">AppServiceProvider</code> class and update the previous binding to the following:<div class="informalexample"><pre class="programlisting">public function register()
{
  $this-&gt;app-&gt;bind(
    'App\Repositories\Contracts\AuthorsRepository',
    'App\Repositories\FileAuthorsRepository'
  );
}</pre></div></li><li class="listitem">Now, browse to the <code class="literal">/authors</code> route. Yes, the output now is:<p>
<span class="strong"><strong>"getting all records from flat file driver..."</strong></span>
</p></li></ol></div><p>Yes, it worked!</p><p>Our route file will never know what repository it is using: the interface defines all the methods you need.</p><p>This is fantastic because, for instance, if you want to add a NoSQL repository to your application in the future, all you will have to do is to create a new <code class="literal">NoSQLAuthorsRepository</code> class that implements the <code class="literal">AuthorsRepository</code> interface. Then, in the <code class="literal">AppServiceProvider</code>, you will switch the binding with the one you need.</p><p>Easy, cool, and also testable!</p><p>Maybe I<a id="id283" class="indexterm"/> am a little repetitive, but focus your attention on this specific point: with the mentioned structure, you can abstract the way you work with your data from the way you access to it. I know that reading the same thing again and again is boring, but I need you to understand this concept.</p><p>It is probable that the first time you read about repositories you will think <span class="emphasis"><em>what am I doing here? What the hell?</em></span> I have done the same thing, so I totally understand your doubts. However, when you work on a more complex project, you will totally feel the difference.</p><p>That's the magic of repositories!</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec52"/>Summary</h1></div></div></div><p>We are done. In this final chapter, you learned about empowering your application in two different and separate ways: on one hand, adding features on an existing entity. In this case, the Eloquent Model.</p><p>On the other one, you learned how to structure your application in a different way using repositories in order to get a better code testability, maintainability, and a separation of purposes instead of delegating everything to a single class.</p><p>Now you have all the tools you need to build great applications using Eloquent and Laravel.</p><p>What are you waiting for? Go on and make me proud!</p></div></body></html>