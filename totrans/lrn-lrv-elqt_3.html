<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;The Most Important Element &#x2013; the Model!"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. The Most Important Element – the Model!</h1></div></div></div><p>Finally, I can say it: things are getting really, really serious from this moment. In the previous chapters, you studied everything you needed to make a start. Maybe it was a little annoying, but you knew that you would need it. Now, stop talking about the past; it's over. In this chapter, many amazing things await.</p><p>As you can imagine by the title, this part is going to be about the most important and atomic Eloquent element: <span class="strong"><strong>the model</strong></span>. We will analyze the <span class="emphasis"><em>M</em></span> in <span class="strong"><strong>MVC</strong></span>. Considering that you are reading a book about creating a data-based application, exactly, really important! However, I don't want to bore you anymore. Let's talk about what we are going to see in the next sections.</p><p>Usually, there is a <span class="emphasis"><em>standard</em></span> way to look at the Eloquent documentation. It's the same as you can see on the Laravel site. In my initial Laravel days, I used those pages but I felt a little <span class="emphasis"><em>incomplete</em></span>. So, I changed things a little bit but in a more simplified way. If you have ever developed a web application in your life, I'm quite sure that you made a data-based application with tables and records. Right? Well...</p><p>If you think about it, you can do four basic operations on them. Whenever you develop an application, there's a very high possibility that you are going to implement some <span class="emphasis"><em>create</em></span>, <span class="emphasis"><em>read</em></span>, <span class="emphasis"><em>update</em></span>, and <span class="emphasis"><em>delete</em></span> logic for your items. This is exactly what we are going to see in this chapter.</p><p>First of all, we will introduce the simple, basic model. It will be a single line of code! Then, we will talk about <a id="id75" class="indexterm"/>CRUD (<span class="strong"><strong>create, read, update, and delete</strong></span>) operations with Eloquent. After that point, you will have all the <span class="emphasis"><em>basics</em></span> and an overview of the mechanism. We will also deal with the <code class="literal">where()</code> method and everything related, unscrambling everything about conditions and selections.</p><p>After that, we will go deep into the <span class="strong"><strong>Model</strong></span> class, studying the mass assignment as another way to store and update our data. Then, we will discuss <span class="strong"><strong>timestamps</strong></span> and <span class="strong"><strong>soft deletes</strong></span>, and find out how Laravel and Eloquent deal with dates. After that, you will learn about query scopes and how to use them to improve your development process.</p><p>Also, we will take a look at many cool methods to transform our data in order to be shown (or stored) correctly: attributes casting, mutators, date mutators, and accessors. If that isn't enough, we will explore all the Model-related events that you can use to introduce new behaviors in your code without breaking it. Also, Model observers will be analyzed when an event isn't enough.</p><p>In the last part of this chapter, we will explore some useful methods and features of the Model class, diving directly into the basic Model class code! Not bad, huh? Let's start! Here are the topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a Model</li><li class="listitem" style="list-style-type: disc">Create, read, update, and delete operations basics</li><li class="listitem" style="list-style-type: disc">Where, aggregates, and other utilities</li><li class="listitem" style="list-style-type: disc">Mass assignment – for the masses</li><li class="listitem" style="list-style-type: disc">Query scopes</li><li class="listitem" style="list-style-type: disc">Attributes casting, accessors, and mutators</li><li class="listitem" style="list-style-type: disc">Model events and observers</li><li class="listitem" style="list-style-type: disc">Descending in the code</li></ul></div><div class="section" title="Creating a Model"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Creating a Model</h1></div></div></div><p>First of all, let's see <a id="id76" class="indexterm"/>how you can create a Model and how its basic structure is made.</p><p>The fastest way to create a Model is to use the following command, with a parameter that you can use to specify the model name:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php artisan make:model</strong></span>
</pre></div><p>So, let's imagine that you want to create a <code class="literal">Book</code> model. The steps are as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">All you have to do is use the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>php artisan make:model Book</strong></span>
</pre></div><p>Of course, you can also create it manually; usually, Laravel puts Models in the <code class="literal">app</code> folder.</p></li><li class="listitem">Once you have done this, let's open the <code class="literal">Book.php</code> file under <code class="literal">app</code> to see what's inside.<div class="mediaobject"><img src="graphics/3634_03_01.jpg" alt="Creating a Model"/></div></li></ol></div><p>Wait. What? An empty class? Seriously?</p><p>Yes.</p><p>Laravel is designed <a id="id77" class="indexterm"/>to create a great web application in very little time. Eloquent (and its models) are no exceptions. The class you can see here is ready to be used in your application; using it, you will be able to do everything related to your books.</p><p>Talking about SQL databases, you can think of a connection between every model and table. If you respect a certain <span class="emphasis"><em>convention</em></span>, Laravel automatically guesses the table name starting from the model name. So, if I have a model by the name of <code class="literal">Book</code>, Laravel will search for a <code class="literal">books</code> table on the database, without the need for specifying it explicitly.</p><p>If you need to bind a certain model with another table, you can specify the name adding it as a <code class="literal">$table</code> property, like this:</p><div class="informalexample"><pre class="programlisting">  &lt;?php 

namespace App;

use Illuminate\Database\Eloquent\Model;

class Book extends Model {

    protected $table = 'my_books';

}</pre></div><p>Alright, nothing more to say here. Now, let's play with our new model.</p></div></div>
<div class="section" title="Create, read, update, and delete operations basics"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Create, read, update, and delete operations basics</h1></div></div></div><p>Every single article<a id="id78" class="indexterm"/> I read about Eloquent usually starts with some reading operations. I don't like it. I will teach you how to create and insert new records, then we will fetch them with some reading operations.</p><p>No boring test inserts with some external administration tool.</p><div class="section" title="Creating operations"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Creating operations</h2></div></div></div><p>Let's create <a id="id79" class="indexterm"/>our first book! As a reference for the record <span class="emphasis"><em>structure</em></span>, we will use the <code class="literal">books</code> table that we created in the previous chapter. The table has a very simple structure: a title, page count (<code class="literal">pages_count</code>), price, and description.</p><p>The procedure is as easy as creating an object.</p><p>Well, actually it is exactly the same. Create a new <code class="literal">GET</code> route in <code class="literal">routes.php</code> file under <code class="literal">app/Http/</code>, named <code class="literal">book_create</code> and type this:</p><div class="informalexample"><pre class="programlisting">  Route::get('book_create', function(){

    $book = new \App\Book;

    $book-&gt;title = 'My First Book!';
    $book-&gt;pages_count = 230;
    $book-&gt;price = 10.5;
    $book-&gt;description = 'A very original lorem ipsum dolor sit amet...';


  });</pre></div><p>If you think about it, there is something strange here! After checking the Model file, you can see that there are no <code class="literal">title</code> or <code class="literal">pages_count</code> properties declared. Among other things, Eloquent heavily uses magic methods. When the final query is built Laravel will use the names of the properties as the table columns to fill. Big deal!</p><p>Now, if you run this code and then check your table, you will not find any record yet. You must add a single final instruction: the <code class="literal">save()</code> method call.</p><div class="informalexample"><pre class="programlisting">  Route::get('book_create', function() {

      $book = new \App\Book;

      $book-&gt;title = 'My First Book!';
      $book-&gt;pages_count = 230;
      $book-&gt;price = 10.5;
      $book-&gt;description = 'A very original lorem ipsum dolor sit amet...';

      $book-&gt;save();

  });</pre></div><p>Execute it. Now, your<a id="id80" class="indexterm"/> book is saved on the database.</p><p>If you want, you can access a specific record field even after you've saved it. Let's make another example.</p><div class="informalexample"><pre class="programlisting">  Route::get('book_create', function() {

      $book = new \App\Book;

      $book-&gt;title = 'My First Book!';
      $book-&gt;pages_count = 230;
      $book-&gt;price = 10.5;
      $book-&gt;description = 'A very original lorem ipsum dolor sit amet...';

      $book-&gt;save();

      echo 'Book: ' . $book-&gt;id;

  });</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>There is another little thing about Eloquent conventions; that is, every single table has an ID, autoincrementing a primary key.</p></div></div></div><div class="section" title="Reading operations"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Reading operations</h2></div></div></div><p>Now<a id="id81" class="indexterm"/> that we've created some example records, why don't we try to read them? An example is better than a thousand words.</p><div class="informalexample"><pre class="programlisting">  Route::get('book_get_all', function(){

    return \App\Book::all();

  });</pre></div><p>With a single instruction, here we are returning all the table records. The output is going to be very similar to this:</p><div class="informalexample"><pre class="programlisting">  [
    {
      id: 1,
      title: "My First Book!",
      pages_count: 230,
      price: "10.50",
      description: "A very original lorem ipsum dolor sit amet...",
      created_at: "2015-03-24 16:45:59",
      updated_at: "2015-03-24 16:45:59"
    }
  ]</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>If you feel strange about this, don't worry. If you return, in a route (or in a controller method) the results of an Eloquent model query, the results will be automatically transformed in JSON. It is a very useful shortcut if you are thinking about building a RESTful API.</p></div></div><p>Let's create<a id="id82" class="indexterm"/> another book, to give our tests more elements.</p><div class="informalexample"><pre class="programlisting">    $book = new \App\Book;

    $book-&gt;title = 'My Second Book!';
    $book-&gt;pages_count = 122;
    $book-&gt;price = 9.5;
    $book-&gt;description = 'Another very original lorem ipsum dolor sit amet...';

    $book-&gt;save();</pre></div><p>After this, again execute your code in the <code class="literal">book_get_all</code> route. The result will be like this:</p><div class="informalexample"><pre class="programlisting">  [
    {
      id: 1,
      title: "My First Book!",
      pages_count: 230,
      price: "10.50",
      description: "A very original lorem ipsum dolor sit amet...",
      created_at: "2015-03-24 16:45:59",
      updated_at: "2015-03-24 16:45:59"
    },
    {
      id: 2,
      title: "My Second Book!",
      pages_count: 122,
      price: "9.50",
      description: "Another very original lorem ipsum dolor sit amet...",
      created_at: "2015-03-24 16:57:15",
      updated_at: "2015-03-24 16:57:15"
    }
  ]</pre></div><p>However, we<a id="id83" class="indexterm"/> can do more. In fact, another great method is the <code class="literal">find()</code> method. You can use it like this:</p><div class="informalexample"><pre class="programlisting">  Route::get('book_get_2', function(){

      return \App\Book::find(2);

  });</pre></div><p>This method takes the primary ID as a parameter and returns the single record as an instance of the model.</p><p>Have a look at its output:</p><div class="informalexample"><pre class="programlisting">  {
    id: 2,
    title: "My Second Book!",
    pages_count: 122,
    price: "9.50",
    description: "Another very original lorem ipsum dolor sit amet...",
    created_at: "2015-03-24 16:57:15",
    updated_at: "2015-03-24 16:57:15"
  }</pre></div><p>Note that this time you don't have an array but a single object. These <span class="emphasis"><em>static</em></span> methods, of course, aren't all Eloquent has to offer. The cool part starts here.</p><p>Take a look at this:</p><div class="informalexample"><pre class="programlisting">  Route::get('book_get_where', function(){

      $result = \App\Book::where('pages_count', '&lt;', 1000)-&gt;get();
      return $result;

  });</pre></div><p>You can use the <code class="literal">where()</code> method to filter your results. Then, after specifying your criteria, the <code class="literal">get()</code> method retrieves the results from the database. For a better understanding, imagine that the <code class="literal">where()</code> method is building a query. The <code class="literal">get()</code> method executes it. This last one is a <span class="emphasis"><em>trigger</em></span> method.</p><p>If you just want <a id="id84" class="indexterm"/>to retrieve the first result instead of all of them, you can use the <code class="literal">first()</code> method instead of <code class="literal">get()</code>.</p><div class="informalexample"><pre class="programlisting">  Route::get('book_get_where', function(){

      $result = \App\Book::where('pages_count', '&lt;', 1000)-&gt;first();
      return $result;

  });</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>Before we go any further, here's a little reminder that can save you a lot of time. Actually, when you use <span class="emphasis"><em>trigger</em></span> methods such as <code class="literal">get()</code> or <code class="literal">first()</code>, you can get two different kinds of results.</p><p>When you use <code class="literal">first()</code>, you are selecting a single instance. So, you will receive as a result (if present) a single instance of a certain model. Otherwise, if you are using <code class="literal">all()</code>, or <code class="literal">get()</code>, you will get a collection of instances.</p></div></div><p>Getting back to our <code class="literal">where()</code>, you can chain as many calls as you wish.</p><div class="informalexample"><pre class="programlisting">  Route::get('book_get_where_chained', function(){

      $result = \App\Book::where('pages_count', '&lt;', 1000)
              -&gt;where('title', '=', 'My First Book!')
              -&gt;get();

      return $result;

  });</pre></div><p>You can iterate through results in a very simple way: simple for each is enough.</p><div class="informalexample"><pre class="programlisting">  Route::get('book_get_where_iterate', function(){

      $results = \App\Book::where('pages_count', '&lt;', 1000)-&gt;get();

      if(count($results) &gt; 0)
      {
        foreach($results as $book){

            echo 'Book: ' . $book-&gt;title . ' - Pages: ' . $book-&gt;pages_count . ' &lt;br/&gt;';

        }
      }
      else
        echo 'No Results!';

      return '';
  });</pre></div><p>The <code class="literal">$results</code> object is countable, so you can also check if you have results or not.</p><p>Have a look at this line:</p><div class="informalexample"><pre class="programlisting">  echo 'Book: ' . $book-&gt;title . ' - Pages: ' . $book-&gt;pages_count . ' &lt;br/&gt;';</pre></div><p>You <a id="id85" class="indexterm"/>probably already noted that you can access a single record field in the same way as you did for setting them: magic methods.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>If you like it, you can access record fields like an array.</p><p>Try to switch <code class="literal">$book-&gt;title</code> to <code class="literal">$book['title']</code> and see what happens.</p></div></div></div><div class="section" title="Updating operations"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Updating operations</h2></div></div></div><p>Updating<a id="id86" class="indexterm"/> a record is as easy as creating it. To be honest, it is exactly the same thing with a single change in the first instruction.</p><div class="informalexample"><pre class="programlisting">  Route::get('book_update', function() {

      $book = \App\Book::find(1);

      $book-&gt;title = 'My Updated First Book!';
      $book-&gt;pages_count = 150;

      $book-&gt;save();

  });</pre></div><p>Instead of creating it, we are retrieving from the database the instance of the Model we desired. After that, using magic methods, we modified and then saved it. As happened for the insert procedure, the change you make becomes persistent after the <code class="literal">save()</code> call.</p></div><div class="section" title="Deleting operations"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Deleting operations</h2></div></div></div><p>Deleting a <a id="id87" class="indexterm"/>record is the simplest thing.</p><div class="informalexample"><pre class="programlisting">  Route::get('book_delete_1', function() {

      \App\Book::find(1)-&gt;delete();

  });</pre></div><p>Time to die, <code class="literal">Book</code>!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Here's a key concept. When you use the <code class="literal">update()</code> and <code class="literal">delete()</code> methods, you are working on a Model instance, just like you did before while creating it.</p><p>So, if you run a <code class="literal">\App\Book::find(1)</code> instruction, you will get a <code class="literal">Book</code> class instance as a result. For some, it will be obvious, but many newcomers often have problems with this.</p></div></div></div></div>
<div class="section" title="where, aggregates, and other utilities"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>where, aggregates, and other utilities</h1></div></div></div><p>No doubt that the<a id="id88" class="indexterm"/> <code class="literal">where()</code> method will be one of your best friends while building queries and selecting records in your work with Eloquent. Don't you think it would be worth taking a look at it in detail?</p><p>Let's recap what we already know.</p><p>You can use the <code class="literal">where()</code> method to filter results. The correct syntax you have to use is this:</p><div class="informalexample"><pre class="programlisting">  where('field_name', 'operator', 'term')</pre></div><p>So, for example, you can filter all the books with less than 100 pages with</p><div class="informalexample"><pre class="programlisting">  where('pages_count', '&lt;', 100)</pre></div><p>Also, you can chain more <code class="literal">where</code> methods, one after another, to build more complex queries. Let's select all those books that have less than 100 pages, with a title that starts with an <span class="emphasis"><em>M</em></span>.</p><div class="informalexample"><pre class="programlisting">  where('pages_count', '&lt;', 100)-&gt;where('title', 'LIKE', 'M%')</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>Two chained conditions are equivalent to <code class="literal">condition1 AND condition2</code>.</p></div></div><p>Great!</p><div class="section" title="where and orWhere"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>where and orWhere</h2></div></div></div><p>However, you<a id="id89" class="indexterm"/> know that this is not enough. Usually, in a real-world application, you may have more complex conditions. First of all, you may need to get results that respect a condition OR another condition. The <code class="literal">AND</code> condition is not a standard; so, here's the solution: <code class="literal">orWhere()</code>.</p><div class="informalexample"><pre class="programlisting">  Route::get('book_get_where_complex', function(){

      $results = \App\Book::where('title', 'LIKE', '%Second%')
              -&gt;orWhere('pages_count', '&gt;', 140)
              -&gt;get();

      return $results;

  });</pre></div><p>In this code, we are telling Eloquent to take all the books that have the word <span class="emphasis"><em>Second</em></span> in the title or all the books with more than 140 pages.</p><p>Yeah, this is a little better than before.</p><p>Now let's try to imagine another more complex condition: we want to find all the books that have more than 120 pages and the word <span class="emphasis"><em>Book</em></span> in the title, or all the books that have less than 200 pages and an empty description.</p><div class="informalexample"><pre class="programlisting">  Route::get('book_get_where_more_complex', function(){

      $results = \App\Book::where(function($query){

          $query
              -&gt;where('pages_count', '&gt;', 120)
              -&gt;where('title', 'LIKE', '%Book%');

      })-&gt;orWhere(function($query){

          $query
              -&gt;where('pages_count', '&lt;', 200)
              -&gt;orWhere('description', '=', '');

      })-&gt;get();
      
      return $results;

  });</pre></div><p>Instead of specifying three parameters for <code class="literal">where()</code> and <code class="literal">orWhere()</code> methods, you can use a single closure parameter that takes a <code class="literal">$query</code> argument. Starting from that <code class="literal">$query</code> object, you will be able to do <a id="id90" class="indexterm"/>every selection and filtering in the way you prefer.</p><p>Of course, you can nest many of them:</p><div class="informalexample"><pre class="programlisting">  Route::get('...', function(){

      $results = \App\Book::where(function($query){

          $query
              -&gt;where(function($query){

                // other conditions here...

                $query-&gt;where(function($query){

                  // deeper and deeper in the seas of conditions...

                });

              })
              -&gt;orWhere('field', 'operator', 'condition');

      })-&gt;orWhere(function($query){

          $query
              -&gt;where('field', 'operator', 'condition')
              -&gt;orWhere(function($query){

          // other conditions here...

              });

      })-&gt;get();

      return $results;

  });</pre></div><p>Alright, stop. I think that the concept is quite clear now. Let's see some other forms of <code class="literal">where</code>.</p><p>First of all, here's <code class="literal">whereBetween</code> that you can use to filter some fields using a range, not only a single value.</p><div class="informalexample"><pre class="programlisting">  $results = \App\Book::whereBetween('pages_count', [100, 200])-&gt;get();</pre></div><p>With that, we just got all the books that have a page count between 100 and 200.</p><p>You can also use <code class="literal">whereIn</code> to check if a specific field is in an array of other values.</p><div class="informalexample"><pre class="programlisting">  $results = \App\Book::whereIn('title', ['My First Book!', 'My Second Book!'])-&gt;get();</pre></div><p>Finally, you can<a id="id91" class="indexterm"/> use <code class="literal">whereNull</code> if you want to get all the records with a certain column equal to null.</p><div class="informalexample"><pre class="programlisting">  $booksThatDontExist = \App\Book::whereNull('title')-&gt;get();</pre></div><div class="section" title="Magic wheres"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec05"/>Magic wheres</h3></div></div></div><p>Another great and <a id="id92" class="indexterm"/>cool feature is the <span class="emphasis"><em>magic</em></span> <code class="literal">where</code>. You know that everything in Laravel has a little bit of magic here and there. Obviously, Eloquent isn't an exception.</p><p>In fact, you can use an alternative syntax for your <code class="literal">where</code> clause, a magic syntax that lets you define the interested field as the method name.</p><p>You already know this syntax:</p><div class="informalexample"><pre class="programlisting">Route::get('book_get_where', function(){

      $result = \App\Book::where('pages_count', '=', 1000)-&gt;first();
      return $result;

  });</pre></div><p>Now, you can get the same result with this code:</p><div class="informalexample"><pre class="programlisting">Route::get('book_get_where', function(){

      $result = \App\Book::wherePagesCount(1000)-&gt;first();
      return $result;

  });</pre></div><p>Obviously, the <code class="literal">wherePagesCount</code> method doesn't exist but Laravel automatically creates a quick <code class="literal">where</code> clause using PHP magic methods. As you can see from the example (and as the syntax suggests), you cannot use this technique every time as it works only with the equal sign.</p><p>However, it's good to know a similar shortcut, right?</p></div></div><div class="section" title="Aggregates"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Aggregates</h2></div></div></div><p>Sometimes, you <a id="id93" class="indexterm"/>will need to use the aggregates functions. No problem! Here is how you can do it with Eloquent.</p><div class="informalexample"><pre class="programlisting">  \App\Book::count();</pre></div><p>This is an example of its practical use:</p><div class="informalexample"><pre class="programlisting">  Route::get('book_get_books_count', function(){

      $booksCount = \App\Book::count();
      return $booksCount;

  });</pre></div><p>Exactly as you saw before for <code class="literal">get()</code> and <code class="literal">first()</code> methods, you can use aggregate methods with <code class="literal">where</code> methods. Here, we are counting the number of the books with more than 140 pages.</p><div class="informalexample"><pre class="programlisting">  Route::get('book_get_books_count', function(){

      $booksCount = \App\Book::where('pages_count', '&gt;', 140)-&gt;count();
      return $booksCount;

  });</pre></div><p>Obviously, <code class="literal">count()</code> is not the only aggregate. Let's see them with some other <code class="literal">where()</code> examples to do more practice. This time, we are searching for the minimum number of pages (but the books with more than 120 pages, at least).</p><div class="informalexample"><pre class="programlisting">  Route::get('book_get_books_min_pages_count', function(){

      $minPagesCount = \App\Book::where('pages_count', '&gt;', 120)-&gt;min('pages_count');
      return $minPagesCount;

  });</pre></div><p>You can also do the same thing with <code class="literal">max()</code>:</p><div class="informalexample"><pre class="programlisting">  Route::get('book_get_books_max_pages_count', function(){

      $maxPagesCount = \App\Book::where('pages_count', '&gt;', 180)-&gt;max('pages_count');
      return $maxPagesCount;

  });</pre></div><p>Now, let's find the average price for all the books that have the <span class="emphasis"><em>Book</em></span> word in the name:</p><div class="informalexample"><pre class="programlisting">  Route::get('book_get_books_avg_price', function(){

    $avgPrice = \App\Book::where('title', 'LIKE', '%Book%')-&gt;avg('price');
      return $avgPrice;

  });</pre></div><p>Finally, let's get the sum <a id="id94" class="indexterm"/>of all the page counts for all the books with more than 100 pages.</p><div class="informalexample"><pre class="programlisting">  Route::get('book_get_books_avg_price', function(){

    $countTotal = \App\Book::where('pages_count', '&gt;', 100)-&gt;avg('price');
      return $countTotal;

  });</pre></div></div><div class="section" title="Utility methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Utility methods</h2></div></div></div><p>As you <a id="id95" class="indexterm"/>probably imagined, Eloquent has a lot of utilities and methods that can improve your life as a developer. Trying to cover every single method would be hard but besides the most common methods, there are a few other methods that deserve to be here.</p><p>First of all, the <code class="literal">skip()</code> and <code class="literal">take()</code> methods that are used to implement some pagination in your queries.</p><div class="informalexample"><pre class="programlisting">  $books = \App\Book::skip(10)-&gt;take(10)-&gt;get();</pre></div><p>We are telling Eloquent to take 10 records and skip 10 from the start. So, if <code class="literal">skip(0)-&gt;take(10)</code> will take records from 1 to 10, <code class="literal">skip(10)-&gt;take(10)</code> will take from 11 to 20, and so on.</p><p>Of course, you can't also miss the <code class="literal">orderBy</code>, <code class="literal">groupBy</code>, and <code class="literal">having</code> methods. If you know a little about SQL databases (and if you are here, I think you do) you won't have any problem understanding this code:</p><div class="informalexample"><pre class="programlisting">  // orderBy
  \App\Book::orderBy('title', 'asc')-&gt;get();

  // groupBy
  \App\Book::groupBy('price')-&gt;get();

  // having
  \App\Book::having('count', '&lt;', 20)-&gt;get();</pre></div></div></div>
<div class="section" title="Mass assignment... for the masses"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Mass assignment... for the masses</h1></div></div></div><p>You got the basics. Cool!</p><p>Now, you<a id="id96" class="indexterm"/> have to know about another couple of ways to insert a record with Eloquent.</p><p>The first is the Model constructor. You can pass an associative array as a parameter of the constructor call, something like this:</p><div class="informalexample"><pre class="programlisting">  $book = new \App\Book([
    'title' =&gt; $title,
    'pages_count' =&gt; $pagesCount,
    'price' =&gt; $price
  ]);</pre></div><p>Another is the <code class="literal">create()</code> method that you can call <span class="emphasis"><em>statically</em></span> from the model itself.</p><div class="informalexample"><pre class="programlisting">  $book = \App\Book::create([
    'title' =&gt; 'My First Book!',
    'price' =&gt; 10.50,
    'pages_count' =&gt; 150,
    'description' =&gt; 'My lorem ipsum dolor description here...'
  ]);</pre></div><p>Similar to the constructor, this <code class="literal">create()</code> method takes an associative array as a parameter and every key in this array corresponds to a column on the table (and a <code class="literal">magic</code> property on the model). The returned value (the one that is stored in <code class="literal">$book</code>) is an instance of the <code class="literal">Book</code> class.</p><p>This is called <span class="strong"><strong>mass assignment</strong></span> and, until this point, everything is fine except for a serious security issue. In fact, sometimes you could pass the entire request input array as a parameter. Trust me: sooner or later, you will do it.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>The <code class="literal">$request</code> object you are going to see in the following example is a request instance that you can use to deal with the current request data. I will use it to retrieve some hypothetical <code class="literal">POST</code> data from a form (with the <code class="literal">all()</code> method) we will use to create a new book.</p></div></div><p>Something like this can be used:</p><div class="informalexample"><pre class="programlisting">  $book = new \App\Book($request-&gt;all());

  // or...

  $book = \App\Book:create($request-&gt;all());</pre></div><p>Technically, you don't know exactly what's in <code class="literal">$request-&gt;all()</code> so it is not the best practice, right? However, you can resolve this issue quite easily by adding a single property to your model—<code class="literal">fillable</code> or <code class="literal">guarded</code>.</p><p>Let's take an <a id="id97" class="indexterm"/>example for a better understanding of the concept. Imagine that for some reason you specify other fields in the form you already use for a new book insert, maybe the current user ID for logging purposes.</p><p>However, you just want to insert four single fields: <code class="literal">title</code>, <code class="literal">pages_count</code>, <code class="literal">price</code>, and <code class="literal">description</code>. Nothing else!</p><p>The key property is <code class="literal">fillable</code>:</p><div class="informalexample"><pre class="programlisting">  &lt;?php 

  namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Book extends Model {

      protected $fillable = [
          'title',
          'price',
          'pages_count',
          'description'
      ];

  }</pre></div><p>You can execute the code like this:</p><div class="informalexample"><pre class="programlisting">  $book = \App\Book:create($request-&gt;all());</pre></div><p>From the moment you execute the code, the model will search for <code class="literal">title</code>, <code class="literal">pages_count</code>, <code class="literal">price</code>, and <code class="literal">description</code> items. Nothing more! If you also have a <code class="literal">user_id</code> field in your request data array, it will be ignored by the model.</p><p>Of course, be careful and check twice what you put in the <code class="literal">$fillable</code> array of your models. Sometimes, developers easily forget the rights fields, and they pass hours and hours after an empty database record.</p><p>So, if you actually get a problem with an empty database record, remember: check your <code class="literal">fillable</code>.</p><p>The <code class="literal">guarded</code> property has a similar behavior but does the opposite thing: if <code class="literal">fillable</code> is a whitelist, then <code class="literal">guarded</code> is a blacklist. A mechanism like a blacklist can be extremely useful if you store some important and sensible information that you don't want to get updated by the user in any way.</p><p>Also, sometimes you will need to guard every single attribute of your model. No problem, use<a id="id98" class="indexterm"/> <code class="literal">guarded</code> like this:</p><div class="informalexample"><pre class="programlisting">  &lt;?php 

  namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Book extends Model {

      protected $guarded = ['*'];

  }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>If you put a field both in the <code class="literal">fillable</code> and <code class="literal">guarded</code> arrays, the model behavior will give the precedence to <code class="literal">fillable</code> and the field will be filled in.</p><p>Also, use <code class="literal">fillable</code> and <code class="literal">guarded</code> wisely. Remember also, that if you are using the <code class="literal">guarded</code> array and you are passing a classic full request data array to your model, you could update some unwanted fields and get some really unwanted errors. </p><p>Boring errors! Avoid them.</p></div></div></div>
<div class="section" title="Timestamps and soft deletes"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Timestamps and soft deletes</h1></div></div></div><p>Time to <a id="id99" class="indexterm"/>cover two awesome features of the Model class: timestamps and soft deletes. How many times have you had to manually handle the creation date of a record and its last update time? Model timestamps are here to help.</p><p>Also, how many times have you had to create a delete feature while maintaining some information about your data, if not at all? Yeah, the soft deleting feature is here to help too.</p><div class="section" title="Timestamps"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Timestamps</h2></div></div></div><p>Do you remember the last method we called in our <code class="literal">books</code> table migrations? No?</p><p>Don't worry, here it is:</p><div class="informalexample"><pre class="programlisting">  Schema::create('books', function(Blueprint $table)
  {
    // other fields...

      $table-&gt;timestamps();
  });</pre></div><p>Exactly, it is the <code class="literal">timestamps()</code> method. This special Schema Builder method is used to create two separate fields: <code class="literal">created_at</code> and <code class="literal">updated_at</code>, both MySQL <code class="literal">DATETIME</code> or equivalent. Eloquent automatically handles these two fields when you create or update a record.</p><p>It can be extremely <a id="id100" class="indexterm"/>useful: how many times did you have to deal with some <span class="emphasis"><em>last edit</em></span> data on a specific table? Also, imagine how much easier it could be with these two fields to handle some scheduled article posting.</p><p>However, sometimes they are not so useful: you can disable them just by setting the <code class="literal">timestamps</code> property model  to false.</p><div class="informalexample"><pre class="programlisting">  &lt;?php

  namespace App;

  class Book extends Model {

      public $timestamps = false;

  }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>Obviously, if you plan to disable timestamps you can delete the corresponding <code class="literal">timestamps()</code> Schema Builder call in your migration. You are not going to need it anymore.</p></div></div><p>You can eventually <span class="emphasis"><em>specify the format of your timestamps</em></span>, if needed. Here's an example:</p><div class="informalexample"><pre class="programlisting">  &lt;?php

  namespace App;

  class Book extends Model {

      protected $table = 'books'';

      protected function getDateFormat()
      {
          // returining a different timestamp format!
          return 'd/m/Y';
      }

  }</pre></div><p>All you have to do is to implement the <code class="literal">getDateFormat</code> method in your model and let it return a string that describes the desired format.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>In the returned string, you can insert anything that is a valid format for the <code class="literal">date()</code> PHP function (you can find a complete reference at <a class="ulink" href="http://php.net/manual/en/function.date.php">http://php.net/manual/en/function.date.php</a>).</p></div></div></div><div class="section" title="Soft deleting"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Soft deleting</h2></div></div></div><p>The soft deleting feature<a id="id101" class="indexterm"/> is a really interesting feature that can be useful on many occasions.</p><p>If you decide to activate soft deleting, you will never really delete a record: instead, a <code class="literal">deleted_at</code> column will be updated with the date of the operation, but nothing more. Eloquent will work exactly like before but you will never lose anything.</p><p>It could be a perfect fit for an e-commerce database that handles orders. The customer could decide to <span class="emphasis"><em>clear</em></span> his order history. However, in order to keep accounts perfect, the shop owner would continuously need every single order detail.</p><p>As you can easily imagine, from the previous chapter, in order to activate the soft deleting feature, you will have to make a call to <code class="literal">softDeletes()</code> Schema Builder method.</p><div class="informalexample"><pre class="programlisting">  Schema::create('books', function(Blueprint $table)
  {
    // other fields...

      $table-&gt;softDeletes();
  });</pre></div><p>After this, you will have to include the <code class="literal">SoftDeletes</code> trait in the model.</p><div class="informalexample"><pre class="programlisting">  &lt;?php

  namespace App;

  use Illuminate\Database\Eloquent\SoftDeletes;

  class Book extends Model {

      use SoftDeletes;

      protected $dates = ['deleted_at'];

  }</pre></div><p>Nothing more!</p><p>Also, working with soft deleted data is really easy. Let's implement a simple example based on the situation <a id="id102" class="indexterm"/>we described before (the customer order's details and shop owner's need).</p><p>First of all, here's an example model:</p><div class="informalexample"><pre class="programlisting">  &lt;?php // Order.php

  namespace App;

  use Illuminate\Database\Eloquent\SoftDeletes;

  class Order extends Model {

      use SoftDeletes;

      protected $dates = ['deleted_at'];

  }</pre></div><p>In his/her order history, a customer should see only his/her <span class="emphasis"><em>existent</em></span> orders and not <span class="emphasis"><em>deleted</em></span> orders. I used quotation marks because we are talking about records that always exist.</p><div class="informalexample"><pre class="programlisting">  // getting all the orders

$orders = \App\Order::orderBy('created_at', 'desc')-&gt;get();</pre></div><p>Nothing really special!</p><p>What about the shop owner? The magical word is <code class="literal">withTrashed</code>:</p><div class="informalexample"><pre class="programlisting">  // getting all the orders, including the "deleted" ones...

$orders = \App\Order::withTrashed()-&gt;orderBy('created_at', 'desc')-&gt;get();</pre></div><p>The <code class="literal">withTrashed</code> method automatically includes every result that is actually present in the table, regardless of the <code class="literal">deleted_at</code> field value.</p><p>Also, if you need to see only the soft deleted fields, change <code class="literal">withTrashed</code> to <code class="literal">onlyTrashed</code>.</p><div class="informalexample"><pre class="programlisting">  $trashedOrders = \App\Order::onlyTrashed()-&gt;orderBy('created_at', 'desc')-&gt;get();</pre></div><p>Finally, you can restore a record that has been deleted with the <code class="literal">restore</code> method.</p><div class="informalexample"><pre class="programlisting">  $trashedOrder = \App\Order::find($trashedOrderId);
  $trashedOrder-&gt;restore();

  // $trashedOrder is not so trashed anymore...</pre></div><p>If you prefer, you can execute the restore operation using a query as a <code class="literal">filter</code>.</p><div class="informalexample"><pre class="programlisting">  \App\Order::where('customer_id', '=', $customerId)-&gt;restore();</pre></div><p>Alright, I know<a id="id103" class="indexterm"/> what you are thinking: this feature is cool but what if I want to really delete a field?</p><p>No problem; just use <code class="literal">forceDelete</code>.</p><div class="informalexample"><pre class="programlisting">  order = \App\Order::find($orderId);

  // bye bye... forever :'(
  $order-&gt;forceDelete();</pre></div></div></div>
<div class="section" title="Query scopes"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Query scopes</h1></div></div></div><p>Query scopes <a id="id104" class="indexterm"/>are very funny and also powerful. I really like them because, like many programmers out there, I am absolutely and overwhelmingly lazy. I also have a great justification for my laziness: the <span class="strong"><strong>Don't Repeat Yourself</strong></span> (<span class="strong"><strong>DRY</strong></span>) principle.</p><p>In a few words, they let you reuse some logic in your queries. It is useful if you have similar queries in your application and you don't want to write them again and again every single time.</p><p>Let's take an example.</p><div class="informalexample"><pre class="programlisting">  &lt;?php // Book.php

  namespace App;

  class Book extends Model {

      public function scopeCheapButBig($query)
      {
          return $query-&gt;where('price', '&lt;', 10)-&gt;where('pages_count', '&gt;', 300);
      }

  }</pre></div><p>What happened? I declared a <code class="literal">scopeCheaperButBig</code> method. The <code class="literal">scope</code> prefix is used to specify that this is going to be used as a scope.</p><p>Now, how can I use a scope?</p><p>Here it is:</p><div class="informalexample"><pre class="programlisting">  &lt;?php

  $bigAndCheaperBooks = \App\Book::cheapButBig()-&gt;get();</pre></div><p>It is a cool<a id="id105" class="indexterm"/> feature. If you also think that you can split your logic in a more intelligent way, you can do it as follows:</p><div class="informalexample"><pre class="programlisting">  &lt;?php // Book.php

  namespace App;

  class Book extends Model {

      public function scopeCheap($query)
      {
          return $query-&gt;where('price', '&lt;', 10);
      }

      public function scopeExpensive($query)
      {
      return $query-&gt;where('price', '&gt;', 100);
      }

      public function scopeLong($query)
      {
        return $query-&gt;where('pages_count', '&gt;', 700);
      }

      public function scopeShort($query)
      {
      return $query-&gt;where('pages_count', '&lt;', 100);
      }

  }</pre></div><p>Use it accordingly, reducing repeated code.</p><div class="informalexample"><pre class="programlisting">  &lt;?php

    // getting cheaper and longer books;
    $cheapAndLongBooks = \App\Book::cheap()-&gt;long()-&gt;get();

    // getting most expensive and longer books;
    $expensiveAndLongBooks = \App\Book::expensive()-&gt;long()-&gt;get();

    // getting cheaper and shorter books;
    $cheapAndShortBooks = \App\Book::cheap()-&gt;short()-&gt;get();

    // getting expensive and shorter books;
    $expensiveAndShortBooks = \App\Book::expensive()-&gt;short()-&gt;get();</pre></div><p>If you need it, you <a id="id106" class="indexterm"/>can also define dynamic scopes in order to pass parameters to your scopes. If you like it, calling a scope inside another is not a problem.</p><div class="informalexample"><pre class="programlisting">  &lt;?php // Book.php

  namespace App;

  class Book extends Model {

    public function scopeLong($query)
      {
        return $query-&gt;where('pages_count', '&gt;', 700);
      }

      public function scopeLongAndCheaperThan($query, $amount)
      {
          return $query-&gt;long()-&gt;where('price', '&lt;', $amount);
      }

  }</pre></div></div>
<div class="section" title="Attributes casting, accessors, and mutators"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Attributes casting, accessors, and mutators</h1></div></div></div><p>Eloquent <a id="id107" class="indexterm"/>has many ways to transform the model data into something more readable or usable (and vice versa). In this chapter, we are going to analyze three of them: attributes casting, accessors, and mutators.</p><div class="section" title="Attributes casting"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Attributes casting</h2></div></div></div><p>The easier<a id="id108" class="indexterm"/> way to transform your model attributes while accessing them is the attributes casting. In a few words, it lets you define what attribute you want to cast and what is going to be the <span class="emphasis"><em>destination</em></span> type.</p><p>Suppose that you have another integer field in your <code class="literal">books</code> table: <code class="literal">is_rare</code>. If the book is rare, this will be equal to <code class="literal">1</code>, <code class="literal">0</code> otherwise. However, when you work with it, the best thing would logically be as follows:</p><div class="informalexample"><pre class="programlisting">  if($book-&gt;is_rare)
  {
    // do wow things here...
  }
  else
  {
    // do common things here...
  }</pre></div><p>It will not be something like this:</p><div class="informalexample"><pre class="programlisting">  if($book-&gt;is_rare === 1)
  {
    // ...
  }</pre></div><p>Right? Good.</p><p>So, all you <a id="id109" class="indexterm"/>have to do to fix this problem is to specify, in your model, the <code class="literal">casts</code> array:</p><div class="informalexample"><pre class="programlisting">  &lt;?php // Book.php

  namespace App;

  class Book extends Model {

    protected $casts = [
        'is_rare' =&gt; 'boolean',
    ];

  }</pre></div><p>From this moment, every time you call the <code class="literal">is_rare</code> attribute, it will be automatically converted to the Boolean corresponding value and returned.</p><p>The supported types for casting are: integer, real, float, double, string, Boolean, object, and array.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>As also the documentation suggests, the <span class="emphasis"><em>array</em></span> casting type is useful when you have a JSON array stored in a specific table column and you want to work with it quickly.</p></div></div></div><div class="section" title="Accessors and mutators"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Accessors and mutators</h2></div></div></div><p>Attributes <a id="id110" class="indexterm"/>casting is very useful but has some limitations. Sometimes, starting from a simple value stored in the database, you need to do more complex work on it. Accessors and mutators are here to help.</p><p>To be more specific, an accessor is a method that is executed when the user reads a specific attribute. The accessor works on the attribute stored in the database and returns it. A mutator works in the opposite way: when you store a value, the mutator works, does its job and then saves it in the table. Let's say they are sorts of getters and setters.</p><p>Defining <a id="id111" class="indexterm"/>an accessor (or a mutator) is not so difficult: all you have to do is to follow a naming convention.</p><p>Let's start with something simple. Imagine that every time that you access the price of your book, you want to put the dollar symbol <span class="emphasis"><em>$</em></span> at the beginning of the string.</p><div class="informalexample"><pre class="programlisting">  &lt;?php // Book.php

    namespace App;

    class Book extends Model {

      public function getPriceAttribute()
        {
            return '$ ' . $value;
        }

    }</pre></div><p>The naming convention<a id="id112" class="indexterm"/> for an accessor is simple as shown:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The method name starts with <code class="literal">get</code></li><li class="listitem" style="list-style-type: disc">The middle part of the name is the attribute name, which is camel cased</li><li class="listitem" style="list-style-type: disc">The method name ends with <code class="literal">Attribute</code></li></ul></div><p>Nothing more.</p><p>Now, have a look at this:</p><div class="informalexample"><pre class="programlisting">  $book = \App\Book::find(1);

  echo $book-&gt;price;
  // output: $ 10.50</pre></div><p>Every time you have the preceding code, the mutator is very similar. This time, we want to store a lowercase version of the title.</p><div class="informalexample"><pre class="programlisting">  &lt;?php // Book.php

    namespace App;

    class Book extends Model {

      public function setTitleAttribute($value)
        {
            $this-&gt;attributes['title'] = strtolower($value);
        }

    }</pre></div><p>The convention isn't changed so much: the only difference is that the method name now starts with <code class="literal">set</code> and not <code class="literal">get</code>. It's all about getters and setters, my friend.</p><p>Another real <a id="id113" class="indexterm"/>common use of mutators is when the application stores the user's password. A mutator can be used to hash the chosen password and the result is then stored.</p><div class="informalexample"><pre class="programlisting">  &lt;?php // User.php

    namespace App;

    class User extends Model {

      public function setPasswordAttribute($value)
        {
            $this-&gt;attributes['password'] = \Hash::make($value);
        }

    }</pre></div></div></div>
<div class="section" title="Descending in the code"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Descending in the code</h1></div></div></div><p>In the previous text, we analyzed many aspects of the Eloquent model. If you think about your path, in a few pages you learned everything you needed to do many operations with your data. Also, you saw many interesting ways to add behaviors (from accessors and mutators to model observers) in order to improve your code usability, readability, and maintainability.</p><p>In this<a id="id114" class="indexterm"/> section you are going to read, I will go through the Model class and analyze it a little deeper than the usual. Nothing so advanced, so don't worry: I will just use the class code to show you what you can do with your models.</p><p>Take it as a <span class="emphasis"><em>list</em></span> of useful tips and tricks.</p><div class="section" title="A big file"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>A big file</h2></div></div></div><p>At the moment I am writing<a id="id115" class="indexterm"/> this chapter, the <code class="literal">Model</code> class under <code class="literal">Illuminate\Database\Eloquent</code> counts 3361 lines of code, which is a big class with many methods and features. However, this length is acceptable considering that we can do the same thing in many different ways (just think about the <code class="literal">save()</code> method, the <code class="literal">::create()</code> method, and the possibility to specify an associative array in the model constructor: three ways to insert a new record).</p><p>In the first part <a id="id116" class="indexterm"/>of the class you can see all the properties we saw before, set to their default values.</p><div class="informalexample"><pre class="programlisting">  ...

  protected $fillable = array();

  ...

  protected $guarded = array('*');

  ...

  protected $casts = array();

  ...</pre></div><p>Yes, by default every attribute is guarded. A <span class="emphasis"><em>total blacklist</em></span> for maximum security!</p></div><div class="section" title="Quick conversion to array or JSON"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Quick conversion to array or JSON</h2></div></div></div><p>Do you remember at the beginning of this chapter what I told you about the automatic conversion to<a id="id117" class="indexterm"/> JSON of<a id="id118" class="indexterm"/> your model attributes? If you take a look at the code into the model you will see two methods: <code class="literal">toArray</code> and <code class="literal">toJson</code>. These two<a id="id119" class="indexterm"/> methods are the ones that make the magic happen.</p><div class="informalexample"><pre class="programlisting">  // from the Illuminate\Database\Eloquent\Model class

  ...

  /**
   * Convert the model instance to an array.
   *
   * @return array
   */
  public function toArray()
  {
    $attributes = $this-&gt;attributesToArray();

    return array_merge($attributes, $this-&gt;relationsToArray());
  }

  ...

  /**
   * Convert the model instance to JSON.
   *
   * @param  int  $options
   * @return string
   */
  public function toJson($options = 0)
  {
    return json_encode($this-&gt;toArray(), $options);
  }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>You can also see that the second method uses the first. If you don't fear big files, I suggest you to take a deeper look at all the methods in this class. You will see some awesome examples of code reusing and function writing. In this chapter, we are just scratching the surface.</p></div></div><p>You can <a id="id120" class="indexterm"/>convert both single models and model collections to arrays or JSON:</p><div class="informalexample"><pre class="programlisting">  return \App\Book::all()-&gt;toJson();

  // or ...

  return \App\Book::where('title', 'LIKE', 'My%')-&gt;get()-&gt;toArray();

  // or

  return \App\Book::find(1)-&gt;toJson();</pre></div><p>Obviously, for security reasons, you can choose to mark some specific fields as <code class="literal">hidden</code>. They will not be shown when the record is converted to array or JSON.</p><div class="informalexample"><pre class="programlisting">  &lt;?php

  namespace App;

  use Illuminate\Database\Eloquent\Model;

  class User extends Model {

      protected $hidden = ['password', 'credit_card_number'];

  }</pre></div><p>In this case, with <code class="literal">hidden</code>, we <a id="id121" class="indexterm"/>specified a blacklist. You can also define a whitelist with the <code class="literal">visible</code> property.</p><div class="informalexample"><pre class="programlisting">  &lt;?php

  namespace App;

  use Illuminate\Database\Eloquent\Model;

  class User extends Model {

      protected $visible = ['first_name', 'last_name'];

  }</pre></div></div><div class="section" title="Imaginary attributes"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Imaginary attributes</h2></div></div></div><p>Using <a id="id122" class="indexterm"/>accessors and a specific property of the model, <code class="literal">appends</code>, you can create some attributes even if they don't exist as table columns.</p><p>For example purposes, let's assume that we want to create a <code class="literal">complete_name</code> attribute, made with the two attributes <code class="literal">first_name</code> and <code class="literal">last_name</code>.</p><p>First of all, let's create the appropriate accessor in the model:</p><div class="informalexample"><pre class="programlisting">  &lt;?php

  namespace App;

  use Illuminate\Database\Eloquent\Model;

  class User extends Model {

      public function getCompleteNameAttribute()
    {
        return $this-&gt;attributes['first_name']. ' ' . $this-&gt;attributes['last_name'];
    }

  }</pre></div><p>Then as the last step, we can include it in the <code class="literal">appends</code> array property.</p><div class="informalexample"><pre class="programlisting">  &lt;?php

  namespace App;

  use Illuminate\Database\Eloquent\Model;

  class User extends Model {

    protected $appends = ['complete_name'];

      public function getCompleteNameAttribute()
    {
        return $this-&gt;attributes['first_name']. ' ' . $this-&gt;attributes['last_name'];
    }

  }</pre></div><p>Nothing else!</p><p>Now we can <a id="id123" class="indexterm"/>use our attribute like this:</p><div class="informalexample"><pre class="programlisting">  echo $user-&gt;complete_name;
  // outputs: Francesco Malatesta</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>Every attribute that you create with the <code class="literal">appends</code> array respects the rules you specify eventually in the <code class="literal">visible</code> and <code class="literal">hidden</code> arrays.</p></div></div></div><div class="section" title="Route model binding"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Route model binding</h2></div></div></div><p>Another <a id="id124" class="indexterm"/>little cool shortcut is <span class="strong"><strong>model binding</strong></span>. In a few words, it lets you link a certain route parameter to an instance of a defined model.</p><p>Let's test it: first of all, go to <code class="literal">RouteServiceProvider</code> in <code class="literal">app/Providers</code> folder. Now follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add this line to the <code class="literal">boot</code> method:<div class="informalexample"><pre class="programlisting">  public function boot(Router $router)
  {
      parent::boot($router);

      $router-&gt;model('book', 'App\Book');
  }</pre></div></li><li class="listitem">Then go to your routes file and create a new route that uses this parameter:<div class="informalexample"><pre class="programlisting">  Route::get('books/{book}', function(App\Book $book)
  {
      return $book-&gt;title;
  });</pre></div></li><li class="listitem">So, calling the <code class="literal">books/1</code> URL will output something like this:<div class="informalexample"><pre class="programlisting">  My First Book!</pre></div></li></ol></div><p>What happened? Laravel resolved and automatically instantiated in the <code class="literal">$book</code> variable the desired object, using the given parameter (<code class="literal">1</code>) as the search term based on the primary ID. Then, the instance was used to output the title.</p><p>It's a little <a id="id125" class="indexterm"/>trick but sometimes it could be useful.</p><p>You can also customize the resolution logic: here's another example using the e-mail address instead.</p><div class="informalexample"><pre class="programlisting">  Route::bind('user', function($value)
  {
      return User::where('email', '=', $value)-&gt;first();
  });</pre></div><p>If the record with the specified primary ID doesn't exist, the application will return a <code class="literal">404 not found</code> error. Obviously, you can change this behavior by specifying a third parameter for the <code class="literal">model()</code> binding.</p><div class="informalexample"><pre class="programlisting">  Route::model('user', 'User', function()
  {
      throw new MyCustomNotFoundHttpException;
  });</pre></div></div><div class="section" title="Records chunking for memory optimization"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Records chunking for memory optimization</h2></div></div></div><p>Sometimes, you<a id="id126" class="indexterm"/> will need to process thousand and thousand of records. You know that those operations are very heavy for your RAM, but Eloquent has a useful method to chunk query results in <span class="emphasis"><em>blocks</em></span> to optimize your load.</p><div class="informalexample"><pre class="programlisting">  \App\Book::chunk(200, function($books)
  {
      foreach ($books as $book)
      {
          // heavy operations on the book here...
      }
  });</pre></div><p>The first parameter defines the size of the block you want to use. In this case, we will load 200 results, process them, unload them, and repeat the same thing with the next 200.</p><p>The second parameter is a closure that defines what to do with that chunk: the <code class="literal">books</code> closure parameter is the returned collection of records.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Summary</h1></div></div></div><p>Hey, we made it again! This first overview of Eloquent is completed and now you are able to make your first experiments on your own! Well actually you are able to do many experiments, not just the basics. We learned all about the CRUD, mass assignment, and many other interesting things.</p><p>If you feel overwhelmed by all this information, don't worry. Take your time to do many tests and get familiarized with all the mechanisms, including the conventions you found on your road. We are only at the third chapter!</p><p>In the next chapter, we will go deeper in one of the most amazing aspects of Eloquent: relations. You will experience the power of Eloquent and how it handles every kind of relationship between models, from the one-to-one to many-to-many, in all its beauty.</p><p>Go, go, go, hero!</p></div></body></html>