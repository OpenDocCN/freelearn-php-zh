<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Modules, Models, and Services"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Modules, Models, and Services</h1></div></div></div><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a new module</li><li class="listitem" style="list-style-type: disc">Using modules as a widget</li><li class="listitem" style="list-style-type: disc">A Model and a Hydrator</li><li class="listitem" style="list-style-type: disc">A basic service</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Introduction</h1></div></div></div><p>This chapter is all about making the most of our module, models, and services and their configuration. As Zend Framework 2 is a modular framework, the modules are obviously one of the most important features of it all. We will talk about customizing the configuration of the modules and how to go about working with models and services as well.</p></div></div>
<div class="section" title="Creating a new module"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Creating a new module</h1></div></div></div><p>The core <a id="id470" class="indexterm"/>of the <a id="id471" class="indexterm"/>Zend Framework 2 library is modular and everything is based around a module based system. That's why we will explain this thoroughly in this recipe, so that we can use it in its best way possible.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec84"/>Getting ready</h2></div></div></div><p>We will be using the Zend Framework skeleton application for creating new modules. As a reminder, the Zend Framework 2 skeleton application can be found at <a class="ulink" href="https://github.com/zendframework/ZendSkeletonApplication">https://github.com/zendframework/ZendSkeletonApplication</a>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec85"/>How to do it…</h2></div></div></div><p>Creating a new module is like starting a new drawing, it is exciting and fun to create a new functionality, <a id="id472" class="indexterm"/>but there are always rules we need to obey. In this recipe we will discuss what the rules are for setting up a new module.</p><div class="section" title="Creating the Module.php"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec165"/>Creating the Module.php</h3></div></div></div><p>We can <a id="id473" class="indexterm"/>start off with just a simple class file (that is, <code class="literal">/module/Sample/Module.php</code>) in the right namespace (<code class="literal">Sample</code>) with nothing in it, which is basically the only requirement there is for the module.</p><div class="informalexample"><pre class="programlisting">&lt;?php

  namespace Sample;

  class Module {}</pre></div><p>We can add the following method to our <code class="literal">Module</code> class:</p><div class="informalexample"><pre class="programlisting">  public function getConfig()
  {
    return include __DIR__ . '/config/module.config.php';
  }</pre></div><p>Let's just create a <code class="literal">/module/Sample/config/module.config.php</code> file now which will return an empty array for now, as we don't really have anything to configure at the moment.</p><div class="informalexample"><pre class="programlisting">&lt;?php

return array();</pre></div><p>To hook up to the bootstrap event, a module just have to have an <code class="literal">onBootstrap</code> method in our <code class="literal">Module.php</code> file which does all the bootstrapping for us, or we can define bootstrap events that are executed when the bootstrap has been called (my personal favorite).</p><p>Let's see both ways, beginning with the <a id="id474" class="indexterm"/>
<code class="literal">onBootstrap method</code>:</p><div class="informalexample"><pre class="programlisting">public function onBootstrap(MvcEvent $e)
{
  // Let's do something on the bootstrap!
}</pre></div><p>As we can see a simple method is enough to create bootstrapping, it bootstraps the module as soon as<a id="id475" class="indexterm"/> the bootstrap event of the application is being triggered.</p></div><div class="section" title="Attaching to the loadModules.postevent"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec166"/>Attaching to the loadModules.postevent</h3></div></div></div><p>The following <a id="id476" class="indexterm"/>example makes use of the <code class="literal">/module/Application/Module.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php 

namespace Application;

// Use the following classes
use Zend\ModuleManager\ModuleManager;
use Zend\ModuleManager\ModuleEvent;

class Module
{
  public function init(ModuleManager $moduleManager)
  {
    // We can get the event manager from our module manager
    $eventManager = $moduleManager-&gt;getEventManager();

    // Now we will attach ourselves to the event manager's event
    $eventManager-&gt;attach(
      ModuleEvent::EVENT_LOAD_MODULES_POST,
      function(ModuleEvent $event)
      {
        // Do something with our event, for example print the name  
        // of the module to the screen.
        echo '&lt;pre&gt;'. $event-&gt;moduleName. '&lt;/pre&gt;';
      },
      // Make sure the rest of the triggers all have been 
      // triggered already
      -1000
    );

  }
}</pre></div></div><div class="section" title="Implementing the getAutoloaderConfig"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec167"/>Implementing the getAutoloaderConfig</h3></div></div></div><p>The following<a id="id477" class="indexterm"/> example is part of the <code class="literal">Module.php</code> <code class="literal">Module</code> class:</p><div class="informalexample"><pre class="programlisting">public function getAutoloaderConfig()
{
  return array( 
    'Zend\Loader\StandardAutoloader' =&gt; array(
      'namespaces' =&gt; array(
        __NAMESPACE__ =&gt; __DIR__. '/src/'. __NAMESPACE__
      ),
    ),
  );
}</pre></div><p>Let's consider the following updated code snippet:</p><div class="informalexample"><pre class="programlisting">public function getAutoloaderConfig()
{
  return array(
    'Zend\Loader\ClassMapAutoloader' =&gt; array(
      __DIR__. '/autoload_classmap.php',
    ),
    'Zend\Loader\StandardAutoloader' =&gt; array(
      'namespaces' =&gt; array(
        __NAMESPACE__ =&gt; __DIR__. '/src/'. __NAMESPACE__
      ),
    ),
  );
}</pre></div><p>An example of a class map file (file <code class="literal">/module/Application/autoload_classmap.php</code>) is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php
return array(
  'Sample\Model\Test' =&gt; __DIR__. '/src/Sample/Model/Test.php', 
  'Sample\Model\Test2' =&gt; __DIR__. '/src/Sample/Model/Test2.php',
);</pre></div></div><div class="section" title="Implementing the getControllerConfig, getControllerPluginConfig and getViewHelperConfig"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec168"/>Implementing the getControllerConfig, getControllerPluginConfig and getViewHelperConfig</h3></div></div></div><p>Take a<a id="id478" class="indexterm"/> look <a id="id479" class="indexterm"/>at the <a id="id480" class="indexterm"/>following implementation of the <code class="literal">getViewHelperConfig</code> (in the <code class="literal">/module/Application/Module.php</code> file):</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Application;

// We need this for the view helper config to be picked up
use Zend\ModuleManager\Feature\ViewHelperProviderInterface;

class ModuleViewHelperProviderInterface
{
  public function getViewHelperConfig()   
  {
    // See if the class exists first, to show off that we can use 
    return array(
      'invokables' =&gt; array(
          // This is a non existing view helper, but is just to 
          // show off how to use it.
          // Note: You cannot use a closure as an invokable.
          'exampleHelp' =&gt; 'Application\View\Helper\Example',
       )
    );
  }
}</pre></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec86"/>How it works…</h2></div></div></div><p>Modules are instantiated by the framework once they are introduced in the <code class="literal">application.config.php</code> file. Adding a module's name the file will make the framework look for the <code class="literal">Module.php</code> file in a directory bearing the name of the module. The <code class="literal">Module.php</code> file has a selection of methods which will then be called by the framework at certain times, such as loading the configuration or running the module's bootstrap.</p><p>For our example we will create a module called <code class="literal">Sample</code>, which will have a simple controller and an action that outputs some text.</p><p>To make sure the <code class="literal">ModuleManager</code> of Zend Framework 2 picks up our new module, we need to understand how the <code class="literal">ModuleManager</code>
<a id="id481" class="indexterm"/> works. What the <code class="literal">ModuleManager</code> does is fulfill three operations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It collects the enabled modules</li><li class="listitem" style="list-style-type: disc">It initializes the module, if necessary</li><li class="listitem" style="list-style-type: disc">It collects the configuration from all the modules</li></ul></div><p>Although we can automatically create a whole new module with the <code class="literal">ZFTool</code>, it is still recommended that we know how to make and structure a module without it. We will now begin to create a module that makes sure the <code class="literal">ModuleManager</code> is happy with it.</p><div class="section" title="Creating a new module directory"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec169"/>Creating a new module directory</h3></div></div></div><p>When <a id="id482" class="indexterm"/>creating a new module, we will follow the recommended way as much as possible, so that we get the clearest view on how it all works. First things first, create a new directory in the module directory with the name <code class="literal">Sample</code>. This directory will be our main directory when it comes to code relating to the Sample module's namespace, that way we will have every related piece of code enclosed in this directory. </p></div><div class="section" title="Creating the Module.php"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec170"/>Creating the Module.php</h3></div></div></div><p>The most <a id="id483" class="indexterm"/>important file of every module is the <code class="literal">Module.php</code> file, which is not only required, but also feeds the framework with important information about things such as; where to find the code, and what the configuration is.</p><p>Although it won't actually initialize anything in the module, it is the basic requirement to have a module. Note that because of the lack of code inside <code class="literal">Module.php</code>, it is impossible for our application to reach any of the code inside the module as well.</p><p>The first thing we want to do is to make sure that the framework will read our configuration for our module. This can be done by defining a <code class="literal">getConfig</code> method in our <code class="literal">Module.php</code>. which requires an array as a return value.</p><p>Because laziness is a skill, we will simply return the complete <code class="literal">module.config.php</code> file to the <code class="literal">ModuleManager</code>. We don't have to do this, we can also just return an array with the configuration in as well, but for the purpose of maintainability it is best to keep the actual configuration separate from the code. This way we don't have to edit the code to edit the configuration.</p><p>Now we know that our <code class="literal">ModuleManager</code> will load our configuration, it is time to go over the bootstrapping <a id="id484" class="indexterm"/>of the module, which is sometimes necessary to initialize more after the configuration has loaded. This can be done either by using the <code class="literal">onBootstrap</code> method in the <code class="literal">Module.php</code> or attach to the <code class="literal">ModuleManager</code> events.</p></div><div class="section" title="Optionally act on ModuleManager events"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec171"/>Optionally act on ModuleManager events</h3></div></div></div><p>Another way of <a id="id485" class="indexterm"/>making sure additional pieces of code will be executed is by attaching them to one of the four other strategic events, namely: <code class="literal">loadModules</code>, <code class="literal">loadModules.resolve</code>, <code class="literal">loadModule</code>, and <code class="literal">loadModules.post</code>.</p><p>To explain them all a bit better, let's go through all of them briefly.</p></div><div class="section" title="Understanding the loadModules event"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec172"/>Understanding the loadModules event</h3></div></div></div><p>The <a id="id486" class="indexterm"/>
<code class="literal">loadModules</code> event <a id="id487" class="indexterm"/>will be triggered when the framework is loading the modules, so for initializing a module, this event is pretty much useless as it will never be called in the <code class="literal">Module.php</code> file (the event has already passed at that point).</p><p>At this point the framework is still loading the modules up and nothing has happened for our module yet. That is why this event is primarily used on the internal side of the framework and not on our development side. However, as this event is active throughout the whole process of loading the modules, it also does some extra things when all the other events have been done.</p><p>This event triggers the following functionality by default:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Zend\Loader\ModuleAutoloader::register</code>: This makes sure that the <code class="literal">Module</code> class can be found and initiated (It doesn't initiate it just yet, just checks).</li><li class="listitem" style="list-style-type: disc"><code class="literal">Zend\ModuleManager\Listener\ConfigListener</code> <code class="literal">::onLoadModulesPre</code> <code class="literal">::onLoadModulesPost</code>: This functionality merges the configuration files with the local configuration files found by the defined <code class="literal">glob()</code> in the application configuration when all the modules have been loaded, but only if the configuration is not cached internally (which is not the case by default).</li><li class="listitem" style="list-style-type: disc"><code class="literal">Zend\ModuleManager\Listener\LocatorRegistration::onLoadModulesPost</code>: This attaches the service of the modules to the <code class="literal">ServiceManager</code>, if the <code class="literal">Module</code> class implemented the <code class="literal">LocatorRegisteredInterface</code> interface, which will immediately add the <code class="literal">Module</code> class to the DI. This is done when all the modules are loaded up.</li></ul></div></div><div class="section" title="The loadModules.resolve event"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec173"/>The loadModules.resolve event</h3></div></div></div><p>Another<a id="id488" class="indexterm"/> internal event and not an event a module <a id="id489" class="indexterm"/>can make use of is this event, which is triggered for each module that is defined in our <code class="literal">application.config.php</code>. This event will actually try to find the <code class="literal">Module</code> class in the <code class="literal">Module.php</code> file of our module, so although not useful (yet) to our module, it is coming close!</p><p>This event triggers the following functionality by default:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Zend\ModuleManager\Listener\ModuleResolverListener::__invoke</code>: This initiates the <code class="literal">Module</code> class</li></ul></div></div><div class="section" title="The loadModule event"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec174"/>The loadModule event</h3></div></div></div><p>Now<a id="id490" class="indexterm"/> the <a id="id491" class="indexterm"/>object (of the <code class="literal">Module</code> class) has been created; the <code class="literal">loadModule</code> event will pass it along the other listeners. </p><p>This event triggers the following functionality by default:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Zend\ModuleManager\Listener\ConfigListener::onLoadModule</code>: This merges the configuration by getting all the getConfig() of the Module classes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Zend\ModuleManager\Listener\AutoloaderListener::__invoke</code>: This calls the <code class="literal">getAutoloaderConfig</code> in the <code class="literal">Module</code> class if available, so that we can get the autoloading going for our new module</li><li class="listitem" style="list-style-type: disc"><code class="literal">Zend\ModuleManager\Listener\InitTrigger::__invoke</code>: This calls the init method in the <code class="literal">Module</code> class if available.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Zend\ModuleManager\Listener\OnBootstrapListener::__invoke</code>: This attaches the <code class="literal">onBootstrap</code> method of the <code class="literal">Module</code> class to the bootstrap event of the application, so it will be run at that time.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Zend\ModuleManager\Listener\ServiceListener::onLoadModule</code>: This calls the following methods in the <code class="literal">Module</code> class if they exist (we will discuss these methods more extensively a bit further on in this recipe):<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getServiceConfig</code>: This gets the <code class="literal">ServiceManager</code> configuration from the Module class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">getControllerConfig</code>: This gets the controller configuration from the <code class="literal">Module</code> class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">getControllerPluginConfig</code>: This gets the controller plugin configuration from the <code class="literal">Module</code> class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">getViewHelperConfig</code>: This gets the view helper configuration from the <code class="literal">Module</code> class.</li></ul></div></li></ul></div><p>The flow chart showing a simplified version of the module loading is as follows:</p><div class="mediaobject"><img src="graphics/4841OS_06_01.jpg" alt="The loadModule event"/></div></div><div class="section" title="The loadModules.post"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec175"/>The loadModules.post</h3></div></div></div><p>The <a id="id492" class="indexterm"/>
<code class="literal">loadModules.post</code> event<a id="id493" class="indexterm"/> is triggered when the modules have successfully been loaded and the last bits are needed to be done to complete it all.</p><p>This event triggers the <code class="literal">Zend\ModuleManager\Listener\ServiceListener::onLoadModulesPost</code> functionality by default and instructs the <code class="literal">ServiceManager</code> to create more services if needed.</p></div><div class="section" title="Attaching to the loadModules.post event"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec176"/>Attaching to the loadModules.post event</h3></div></div></div><p>The <a id="id494" class="indexterm"/>
<code class="literal">loadModules.post</code> event is the first event we <a id="id495" class="indexterm"/>can attach a handler to in our application, as events before this one can only be used by the internal listeners of Zend Framework 2. That means there is not a good way of hooking up to those events without making extensions to the framework ourselves.</p><p>However, the <code class="literal">loadModules.post</code> event can still be useful, for example, to make sure that our modules are loaded correctly, or for something else modules config related. The best way of attaching ourselves to this event is by doing that as high up as we can get with the <code class="literal">EventManager</code>. In this case that would be in the <code class="literal">init()</code> method of the module, as that is being called during the <code class="literal">loadModule</code> event, and is the first one to contain an <code class="literal">EventManager</code>.</p></div><div class="section" title="More specific non configuration file Module configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec177"/>More specific non configuration file Module configuration</h3></div></div></div><p>Sometimes we choose not to use the <code class="literal">module.config.php</code> file all the time and we require a more dynamic instantiation, for example, of services or configurations. Luckily Zend Framework 2 fully supports any dynamic configuration functionality. As discussed before, there are five extra methods we can add to our <code class="literal">Module</code> class, which are picked up during the module instantiation, namely the <code class="literal">getAutoloaderConfig</code>, <code class="literal">getServiceConfig</code>, <code class="literal">getControllerConfig</code>, <code class="literal">getControllerPluginConfig</code>, and the <code class="literal">getViewHelperConfiguration</code>.</p></div><div class="section" title="The getAutoloaderConfig method"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec178"/>The getAutoloaderConfig method</h3></div></div></div><p>The <code class="literal">getAutoloaderConfig</code> method <a id="id496" class="indexterm"/>will load in the autoloader configuration for our module and expects an array that is compatible with the <code class="literal">AutoloaderFactory</code>. There are generally two accepted ways of autoloading in Zend Framework 2. The first one is to use the <code class="literal">StandardAutoloader</code>, which requires a namespace to load and a directory to recur in to. The second one is to use a <code class="literal">ClassMapAutoloader</code>, which is basically a file with an array where every full domain and class name is mentioned with a reference to a specific file.</p><p>Both of them are displayed in the examples, so please take a look at them to see the differences.</p><p>We use the <code class="literal">StandardAutoloader</code> in the first example because we just want our framework to load all the classes in the namespace <code class="literal">__NAMESPACE__</code> (which is <code class="literal">Sample</code> for our module) through the directory structure in the <code class="literal">[current directory]/src/Sample</code> directory. This means that a class that is fully called in <code class="literal">Sample\Model\Test</code>, will be searched in <code class="literal">/src/Sample/Model/Test.php</code>. Although this is very handy in a development environment, it isn't handy in a production environment <a id="id497" class="indexterm"/>because a large application will put a lot of strain on searching for the class names we need. In that case we can use this <code class="literal">StandardAutoloader</code>, but in addition (with a higher priority) we will also be using a <code class="literal">ClassMapAutoloader</code> that loads in a static file with all the class names mapped to a specific directory.</p><p>This tells PHP that when we search for the class <code class="literal">Sample\Model\Test</code>, it can be found in <code class="literal">/src/Sample/Model/Test.php</code> (or wherever really, as we point the PHP directly towards our file anyway). Both of the autoloaders are PSR-0, where PSR stands for PHP Standards Recommendation compliant.</p><p>In the second example we can see we prioritized our <code class="literal">autoload_classmap.php</code> file over our <code class="literal">StandardAutoloader</code>, which means that it will look first in our class map file before trying to find it on its own.</p><p>To make the framework use the <code class="literal">getAutoloaderConfig</code> method, we must make sure our <code class="literal">Module</code> class implements the <code class="literal">Zend\ModuleManager\Feature\AutoloaderProviderInterface</code> class as well as it consists of the single public method <code class="literal">getAutoloaderConfig()</code>, otherwise it will not try to execute it. Remember that simply implementing the method is not enough to make it fire as it specifically looks if we are implementing the interface.</p></div><div class="section" title="The getControllerConfig, getControllerPluginConfig, and getViewHelperConfig methods"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec179"/>The getControllerConfig, getControllerPluginConfig, and getViewHelperConfig methods</h3></div></div></div><p>Instead of <a id="id498" class="indexterm"/>loading the controller configuration through the <code class="literal">module.config.php</code> or as an override, we can also do it through the <code class="literal">get***Config</code> method. We can create <a id="id499" class="indexterm"/>the method the <a id="id500" class="indexterm"/>same way as the <code class="literal">getServiceConfig</code> method, as the return object can either be of the instance <code class="literal">Zend\ServiceManager\Config</code> or simply an array with the configuration like in the <code class="literal">module.config.php</code>.</p><p>If we want to use these methods, we should not forget to implement our class with the respective interfaces:</p><p>
<code class="literal">For the getControllerConfig method we need to implement the Zend\ModuleManager\Feature\ControllerProviderInterface interface.</code>
</p><p>
<code class="literal">For the getControllerPluginConfig method we need to implement the Zend\ModuleManager\Feature\ControllerPluginProviderInterface interface.</code>
</p><p>
<code class="literal">And lastly for the getViewHelperConfig method we need to implement the Zend\ModuleManager\Feature\ViewHelperProviderInterface interface.</code>
</p></div></div></div>
<div class="section" title="Using modules as a widget"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Using modules as a widget</h1></div></div></div><p>Widgetizing is a <a id="id501" class="indexterm"/>great method to use modules on different places in our <a id="id502" class="indexterm"/>applications. That's why this recipe will explain everything we need to know about doing this in the best way possible.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec87"/>Getting ready</h2></div></div></div><p>A working Zend Framework 2 skeleton application is needed to make full use of this recipe.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec88"/>How to do it…</h2></div></div></div><p>Widgets, they even sound great! We will explain in this recipe what they do and how they can be used.</p><div class="section" title="Creating the Comment/Controller/Index"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec180"/>Creating the Comment/Controller/Index</h3></div></div></div><p>We will create a small <a id="id503" class="indexterm"/>controller that will return some<a id="id504" class="indexterm"/> example comments, which are static and hardcoded for example only. First we should make sure we have a <code class="literal">Comment</code> module, so <a id="id505" class="indexterm"/>we create the following directories and files:</p><div class="informalexample"><pre class="programlisting">module/
   Comment/
      config/
         module.config.php
      src/
         Comment/
            Controller/
               IndexController.php
      view/
         comment/
            index/
               index.phtml
      Module.php</pre></div><p>Once we have the structure in place, we put the simplest code in the <code class="literal">/module/Comment/Module.php</code> as possible to initialize the module, which is shown as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Comment;

class Module
{
  // Get our module configuration
  public function getConfig()
  {
    return include __DIR__ 
         . '/config/module.config.php';
  }

  // Initialize our autoloader to load in our sources
  public function getAutoloaderConfig()
  {
    return array(
      'Zend\Loader\StandardAutoloader' =&gt; array(
        'namespaces' =&gt; array(
          __NAMESPACE__ =&gt; __DIR__. '/src/'
                         . __NAMESPACE__,
        ),
      ),
    );
  }
}</pre></div><p>As we can see this<a id="id506" class="indexterm"/> is the most basic <code class="literal">Module</code> class because we don't need it more advanced than this. Now let's quickly create our <code class="literal">module.config.phpconfiguration</code> file in the <code class="literal">/module/Comment/config</code> directory:</p><div class="informalexample"><pre class="programlisting">&lt;?php

return array(
  // Set up a quick route to our comment output
  'router' =&gt; array(
    'routes' =&gt; array(
      'comment' =&gt; array(
        'type' =&gt; 'Zend\Mvc\Router\Http\Literal',
        'options' =&gt; array(
          'route'    =&gt; '/comment',
          'defaults' =&gt; array(
            'controller' =&gt; 'Comment\Controller\Index',
            'action'     =&gt; 'index',
          ),
        ),
      ),
    ),
  ),

  // Make sure the controllers are invokable by us
  'controllers' =&gt; array(
    'invokables' =&gt; array(
      'Comment\Controller\Index' =&gt;
                    'Comment\Controller\IndexController'
    ),
  ),

  // Set the path to our view templates
  'view_manager' =&gt; array(
    'template_path_stack' =&gt; array(
       __DIR__ . '/../view',
    ),
  ),
);</pre></div><p>Now that we have set up a quick configuration with a route that responds to the <code class="literal">/</code>comment and <a id="id507" class="indexterm"/>maps to <code class="literal">Comment\Controller\IndexController::indexAction</code>, we can continue with the actual controller (present in the file <code class="literal">/module/Comment/src/Comment/Controller/IndexController.php</code>):</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Comment\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;

class IndexController extends AbstractActionController
{
  // This is the action that will be called whenever we 
  // browse to /comment
  public function indexAction()
  {
    // Initialize our view model
    $view = new ViewModel();
    $comments = array();

    // Create some static comments and put them in our 
    // comments array
    for ($i = 0; $i &lt; 10; $i++) {
      $comments[] = array(
          'name' =&gt; 'John Doe ('. $i. '),
          'comment' =&gt; 'Lorem ipsum dolor sit amet...'
      );
    }

    // Return our view with the comments and make sure 
    // the renderer doesn't output our layout 
    // (setTerminal(true) does that)
    return $view-&gt;setVariable('comments', $comments)
                -&gt;setTerminal(true);
  }
}</pre></div><p>After creating our<a id="id508" class="indexterm"/> controller, the only thing we still need to create is the view script (found in the file <code class="literal">/module/Comment/view/comment/index/index.phtml</code>) to actually output the data in an HTML table:</p><div class="informalexample"><pre class="programlisting">&lt;?php /* loop through the comments to display them */ ?&gt;
&lt;?php foreach ($this-&gt;comments as $comment) : ?&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;?php echo $comment['name'] ?&gt;:
    &lt;/td&gt;
    &lt;td&gt;
      &lt;?php echo $comment['comment'] ?&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;?php endforeach; ?&gt;</pre></div><p>Now that we <a id="id509" class="indexterm"/>have our module completely set up, we can go forth and display the comments in widget form.</p></div><div class="section" title="Using a view helper to display the comments statically"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec181"/>Using a view helper to display the comments statically</h3></div></div></div><p>First we want to <a id="id510" class="indexterm"/>create the view helper itself, let's do this in the <code class="literal">Comment</code> module (the file is <code class="literal">/module/Comment/src/Comment/View/Helper/Comments.php</code>) as the data comes from there anyway:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Comment\View\Helper;

use Zend\View\Helper\AbstractHelper;
use Comment\Controller\IndexController;

class Comments extends AbstractHelper
{
  public function __invoke()
  {
    // Instantiate the controller with the comments
    $controller = new IndexController();

    // Execute our indexAction to retrieve the 
    // ViewModel, and then add the template of that 
    // ViewModel so it renders fine
    $model = $controller-&gt;indexAction()-&gt;setTemplate(
              'comment/index/index'
    );

    // Now return our rendered view
    return $this-&gt;getView()
               -&gt;render($model);
  }
}</pre></div><p>Now all we need to do is add this view helper to our module configuration (the file is <code class="literal">/module/Comment/config/module.config.php</code>) before we are able to use it in our views:</p><div class="informalexample"><pre class="programlisting">  // Add our custom view helper to the configuration
  'view_helpers' =&gt; array(
    'invokables' =&gt; array(
      'comments' =&gt; 'Comment\View\Helper\Comments',
    ),
  ),</pre></div><p>Obviously we <a id="id511" class="indexterm"/>omitted the rest of the configuration here because we didn't want to repeat ourselves. All that is left now is to actually use the new view helper in the code. We can do that to put the following code line in our view script:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo $this-&gt;comments() ?&gt;</pre></div></div><div class="section" title="Using the forward to render the comments statically"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec182"/>Using the forward to render the comments statically</h3></div></div></div><p>Let's take a look <a id="id512" class="indexterm"/>at a code snippet of the action of a <code class="literal">forward()</code> in our <code class="literal">CommentController</code> (the file is <code class="literal">/module/Application/src/Application/Controller/CommentController.php</code>):</p><div class="informalexample"><pre class="programlisting">public function forwardAction()
{
  $view = new ViewModel();

  // Get the comments from the index action 
  $comments = $this-&gt;forward()
                   -&gt;dispatch(
    // Which controller do we want to invoke
    'Comment\Controller\Index', 

    // Any specific options we want to give it
    array('action' =&gt; 'index')
  );

  // If we keep this on true it will return an 
  // exception, so let us not do that
  $comments-&gt;setTerminal(false);

  // Return the view model with the comments as child
  return $view-&gt;addChild($comments, 'comments');
}</pre></div><p>This gets the<a id="id513" class="indexterm"/> dispatched state of a action in a specific controller (our <code class="literal">Comment\Controller\Index::indexAction</code>) and returns it to us as <code class="literal">$comments</code>, which is a <code class="literal">ViewModel</code> instance. We add that as a child to our current <code class="literal">ViewModel</code> instance and then we can simply output it in the view script with the following code snippet:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo $this-&gt;comments ?&gt;</pre></div><p>This is the same as outputting a normal variable, and although this gives the feeling of a clean solution, the <code class="literal">forward()</code> method is known to be horrible under stress.</p></div><div class="section" title="Getting the comments through AJAX"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec183"/>Getting the comments through AJAX</h3></div></div></div><p>Let's see <a id="id514" class="indexterm"/>what our view script looks like with JavaScript:</p><div class="informalexample"><pre class="programlisting">&lt;!-- our comments will load in here --&gt;
&lt;table class="comments"&gt;&lt;/table&gt;

&lt;!-- first we want to make sure that we load in the jQuery script that comes with the Zend Framework 2 skeleton application --&gt;
&lt;script src="&lt;?php echo $this-&gt;basePath('/js/jquery.min.js') ?&gt;"&gt;&lt;/script&gt;

&lt;!-- this is the JavaScript bit --&gt;
&lt;script&gt;
  // This means jQuery will execute this code whenever 
  // the document is done loading
  $(document).ready(function() {
    // We want to do a GET request in the background
    $.get(
      // We want to get this URL
      '/comment', 

      // This function will be executed when the 
      // data comes back from the server
      function(data) {
        // Put our data (the comments) in our 
        // comments table
       $('table.comments').html(data);
      }
    );
  });
&lt;/script&gt;</pre></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec89"/>How it works…</h2></div></div></div><p>This is the scenario: We have a page that contains a little story on which users should be able to comment. <a id="id515" class="indexterm"/>The comment section however is used at several other locations in the code and should therefore be reusable. There is one proviso though, the comment section doesn't change in layout, it will always need to be displayed in the same way.</p><p>What we are going to do is create three different but valid implementations of a module that is being used as a widget. The first two will give a more static feel to it all, while the third one will use JavaScript (jQuery to be exact) to load in the comments. We will also discuss a theoretic fourth solution that should be considered.</p><p>But first of all we will set up a small environment, which we will use in the examples of retrieving the comments.</p><p>We will set up the <code class="literal">Application/Controller/Comment</code> controller, which will have the <code class="literal">helperAction</code>, <code class="literal">forwardAction</code> and <code class="literal">ajaxAction</code> method defined. Then we will use this controller and actions to display the comments in the <code class="literal">Comment/Controller/Index</code>  controller and <code class="literal">indexAction</code> method.</p><div class="section" title="Using a view helper to display the comments statically"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec184"/>Using a view helper to display the comments statically</h3></div></div></div><p>The best option<a id="id516" class="indexterm"/> to display the comments in a statically way would be to create a view helper specific for this widget. What we are going to do is create a small view helper that will render our comments and return them to our view. This way we can use it everywhere in our view without using a lot of hassle like the <code class="literal">forward()</code> or the AJAX methods do.</p><p>As we can see in the example we instantiate our controller and manually retrieve the output of the action, and after that manually render it and return it to the view. It is not always this easy to do it like this, but it comes close to reality.</p></div><div class="section" title="Using the forward() method to render the comments statically"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec185"/>Using the forward() method to render the comments statically</h3></div></div></div><p>A not so <a id="id517" class="indexterm"/>great idea but worth mentioning also is getting the comments through the <code class="literal">forward()</code> method, which is brittle, but at least it doesn't go through the whole MVC initialization like the AJAX functionality does.</p></div><div class="section" title="Getting the comments through AJAX"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec186"/>Getting the comments through AJAX</h3></div></div></div><p>Last but not<a id="id518" class="indexterm"/> least, a more technical non-PHP solution is also at hand for when we want to be a little bit more creative, or when our environment just calls for an asynchronous AJAX implementation. The idea of this method is that we simply retrieve our comments from the URL through JavaScript, or to be specific the jQuery library.</p><p>This only requires us to input a bit of client-side JavaScript in the view script to make it work, which is nice because we don't have to fiddle around much in the code. It has one big con though, and that is that we will go through the whole MVC process again to receive the comments from the database. On the other hand it will speed up the response time from our main action as it doesn't have to load the comments statically. Another con would be that the user visiting the website needs a JavaScript enabled browser to see the comments, but we assume everyone has such browser nowadays.</p><p>As we can see from the example this is a pretty easy method of retrieving the comments as well, but it has afore mentioned cons attached to it. However, sometimes this might be the best option performance wise to get the data from somewhere else. It is all due to the architecture of the application.</p></div><div class="section" title="About Widgetizing"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec187"/>About Widgetizing</h3></div></div></div><p>Widgetizing <a id="id519" class="indexterm"/>a <a id="id520" class="indexterm"/>module is not something that is absolutely native to the framework, but as we can see in the paragraphs above, it is something we can easily achieve by using (not abusing) the framework as much as we can.</p><p>Especially, instantiating controllers and executing actions our self is a great method of dealing with data from other sections of the application. We want to be wary, however, that modules in itself should be independent (or at least as much as possible) from each other and we shouldn't rely too much on their existence.</p><p>But to be fair, a perfect situation is never to be found, and we just need to do some concessions some times. In our case this might be relying on modules that might not be there.</p></div></div></div>
<div class="section" title="A Model and a Hydrator"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec39"/>A Model and a Hydrator</h1></div></div></div><p>Models<a id="id521" class="indexterm"/> are a great way of providing functionality to our application, and they keep out the Controllers, nice and clean, from any critical logic. A hydrator<a id="id522" class="indexterm"/> is also great to transport properties and values from one model to another, that's why we will go into this a bit further to make optimal use of it.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec90"/>Getting ready</h2></div></div></div><p>For this recipe a working Zend Framework 2 skeleton application is necessary to make full use of the examples.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec91"/>How to do it…</h2></div></div></div><p>In this recipe we <a id="id523" class="indexterm"/>will set up a model and a method for hydrating data to and from our model, so that we have easy access of our data.</p><div class="section" title="Accessing the Model"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec188"/>Accessing the Model</h3></div></div></div><p>We can <a id="id524" class="indexterm"/>access the model anywhere in the application by simply adding a use statement at the top of our document:</p><div class="informalexample"><pre class="programlisting">use Application\Model\SampleModel;

$object = new SampleModel();</pre></div><p>Or by using the fully qualified name of the class including the namespace, shown as follows:</p><div class="informalexample"><pre class="programlisting">$object = new \Application\Model\SampleModel();</pre></div><p>If there is already a class <code class="literal">SampleModel</code> used, but from a different namespace, or if we just want to give it a more identifiable name, we can also use an alias (this is not model specific however, and we can use it in any namespaced class), as shown as follows:</p><div class="informalexample"><pre class="programlisting">use Application\Model\SampleModel as NewModel;

$object = new NewModel();</pre></div></div><div class="section" title="Creating a Hydrator"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec189"/>Creating a Hydrator</h3></div></div></div><p>First thing<a id="id525" class="indexterm"/> now is to set up an incredibly simple model (the file is <code class="literal">/module/Application/src/Application/Model/SampleModel.php</code>), which we will use to hydrate, as shown as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Application\Model;

class SampleModel 
{
  private $engine;
  private $primary;
  private $text;

  public function getEngine() {
    return $this-&gt;engine;
  }

  public function setEngine($engines) {
    $this-&gt;engine = $engines;
  }

  public function getPrimary() {
    return $this-&gt;primary;
  }

  public function setPrimary($primary) {
    $this-&gt;primary = $primary;
  }

  public function getText() {
    return $this-&gt;text;
  }
  public function setText($text) {
    $this-&gt;text = $text;
  }
}</pre></div><p>This incredibly <a id="id526" class="indexterm"/>basic model has nothing more than a couple of properties with the getters and setters for them, simple, but it will work for what we try to achieve next. What we are going to do in the following example is create a <code class="literal">Hydrator</code> for our imaginary database table and then we will hydrate our <code class="literal">SampleModel</code> (the file is <code class="literal">/module/Application/src/Application/Model/Hydrator/SampleModelHydrator.php</code>) with the data from the table:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Don't forget to namespace our class
namespace Application\Model\Hydrator;

// We extend from this class
use Zend\Stdlib\Hydrator\AbstractHydrator;

class SampleModelHydrator extends AbstractHydrator
{
  private $mapping = array(
    'id' =&gt; 'primary',
    'value' =&gt; 'engine',
    'description' =&gt; 'text',
  );

  // Extracts the hydrated model   
  public function extract($object) {}

  // Hydrates our values to our model
  public function hydrate(array $data, $object) {}
}</pre></div><p>We have now set up the very basic class of our hydrator, and the methods implemented are now only the <a id="id527" class="indexterm"/>definitions that we need to have because of the <code class="literal">AbstractHydrator</code> class<a id="id528" class="indexterm"/>. The next thing we want to do is to get some code in there to actually make it all work. The first thing we will implement further is the <code class="literal">hydrate()</code> method, which will make our <code class="literal">SampleModel</code> hydrated:</p><div class="informalexample"><pre class="programlisting">public function hydrate(array $data, $object) 
{
  // If we are not receiving an object, throw an 
  // exception
  if (is_object($object) === false) {
    throw new \Exception(
      "We expect object to be an actual object!"
    );
  }

  // Loop through the properties and values 
  foreach ($data as $property=&gt;$value) {
    // Check if the property exists in our mapping
    if (array_key_exists($property, $this-&gt;mapping)) {
      // Build the setter method from our property
      $setter = 'set'. ucfirst(
         $this-&gt;mapping[$property]
      );

    // Set the value of the property
    $object-&gt;$setter($value);
    }
  }

  // Now return our hydrated object
  return $object;
}</pre></div><p>Now let's use the <code class="literal">extract()</code> method, which extracts values from our <code class="literal">SampleModel</code> and puts them back<a id="id529" class="indexterm"/> in an array which is also formatted in the way we used to hydrate the object in the first place:</p><div class="informalexample"><pre class="programlisting">public function extract($object) 
{
  // If we are not receiving an object, throw an 
  // exception
  if (is_object($object) === false) {
    throw new \Exception(
         "We expect object to be an actual object!"
      );
  }

  $return = array();

  foreach ($this-&gt;mapping as $key=&gt;$map) {
    // Build the getter method from our property
    $getter = 'get'. ucfirst($map);

    // Get the property value from the object
    $return[$key] = $object-&gt;$getter();
  }

  return $return;
}</pre></div><p>And that is how we extract values from the hydrated object again.</p></div><div class="section" title="Creating a Hydrator strategy"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec190"/>Creating a Hydrator strategy</h3></div></div></div><p>If we<a id="id530" class="indexterm"/> change the setter of the primary property in the <code class="literal">SampleModel</code> (the file is <code class="literal">/module/Application/src/Application/Model/SampleModel.php</code>) a bit so that it reflects in the following code snippet:</p><div class="informalexample"><pre class="programlisting">public function setPrimary($primary) 
{
  // Throw an exception if there is no valid integer.
  if (!is_int($primary)) {
    throw new \Exception(
       "Primary ({$primary}) should be an integer!"
    );
  }

  $this-&gt;primary = $primary;
}</pre></div><p>Let's begin by creating our strategy first (the file is <code class="literal">/module/Application/src/Application/Model/Hydrator/Strategy/SampleHydratorStrategy.php</code>):</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Application\Model\Hydrator\Strategy;

// We need to implement this interface to make it 
// eligible to be a strategy
use Zend\Stdlib\Hydrator\Strategy\StrategyInterface;

class SampleHydratorStrategy implements StrategyInterface
{

  // This method is called every time an object is 
  // extracted
  public function extract($value) 
  {
    // Check if the value is an integer
    if (is_int($value) === true) { 
      return (int)$value;
    } else {
      // No integer, just randomly return an integer
      return rand(0, 10000);
    }
  }

  // This method is called just before the property of 
  // the object is hydrated
  public function hydrate($value) 
  {
    // Check if it is a valid integer
    if (is_int($value) === true) {
      return (int)$value;
    } else {
      // No integer, random integer is returned
      return rand(0, 10000);
    }
  }
}</pre></div><p>Now we<a id="id531" class="indexterm"/> need to change two things in our <code class="literal">Hydrator</code> class that we created, so that it also supports a hydrator strategy (the file is <code class="literal">/module/Application/src/Application/Model/Hydrator/SampleModelHydrator.php</code>):</p><div class="informalexample"><pre class="programlisting">public function extract($object)
{
  [.. current code in between ..]

  $return[$key] = $this-&gt;extractValue(
      $key, $object-&gt;$getter()
  );

  [.. rest of the code ..] 
}

public function hydrate(array $data, $object)
{
  [.. current code in between ..]

  $object-&gt;$setter($this-&gt;hydrateValue(
      $this-&gt;mapping[$property], $value)
  );

  [.. rest of the code ..]
}</pre></div><p>As we can see we just have to change the previously shown code lines to make sure it will use the <a id="id532" class="indexterm"/>hydrator strategy in our <code class="literal">Hydrator</code>.</p><p>In the next example we will use the <code class="literal">Hydrator</code> to hydrate our <code class="literal">SampleModel</code> into our controller (the file is <code class="literal">/module/Application/src/Application/Controller/IndexController.php</code>):</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Application\Controller;

use Application\Model\SampleModel;
use Application\Model\Hydrator\SampleModelHydrator;
use Application\Model\Hydrator\Strategy\SampleHydratorStrategy;
use Zend\Mvc\Controller\AbstractActionController;

class IndexController extends AbstractActionController
{
  public function indexAction()
  {
    // First initialize our model
    $model = new \Application\Model\SampleModel();

    // Now create a sample array of data to hydrate
    $data = array(
      'id' =&gt; 'Some Id',
      'value' =&gt; 'Some Awesome Value',
      'description' =&gt; 'Pecunia non olet',
    );
    // Now create our Hydrator
    $hydrator = new SampleModelHydrator();

    // Now add our strategy to it to check when the primary 
    // value is set (if we put id, it would be when the 
    // value would be retrieved)
    $hydrator-&gt;addStrategy(
        "primary", 
        new SampleHydratorStrategy()
    );

    // Now hydrate our model
    $newObject = $hydrator-&gt;hydrate($data, $model);

    // And if necessary extract the values again
    $extract = $hydrator-&gt;extract($newObject); 

    // Now output it to the browser
    echo "&lt;pre&gt;". print_r($extract, true). "&lt;/pre&gt;";
  }
}</pre></div><p>If we know to<a id="id533" class="indexterm"/> compare the extract with the original values, we can see that the ID has now changed to a random number, telling us that the hydrator strategy did its job.</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec92"/>How it works…</h2></div></div></div><div class="section" title="Think about the model's purpose"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec191"/>Think about the model's purpose</h3></div></div></div><p>By <a id="id534" class="indexterm"/>definition models should only have functionality related to one very specific bit of the application. This means that if we begin coding a model, we should be wary of this requirement and make our models lightweight and catering to a single purpose.</p><p>The idea of having loads of small pieces of code is that we can maintain them a lot easier and we only load in what we like to use. Instead of loading a 40k line long model with all the functionality we need, we would like to split them up into small functional classes that do only the thing they are named after.</p></div><div class="section" title="Think about the model's location"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec192"/>Think about the model's location</h3></div></div></div><p>The location of <a id="id535" class="indexterm"/>a model is especially important as we still want to be able to find it among our code. We should give it a name that resembles its functionality, and it should be as specific as possible.</p><p>If we name the model we need to put it in a location that makes sense as well, so when we look for certain functionality we can find it by just searching in the location it makes most sense.</p><p>For example let's take a look at the following namespace and class name:</p><div class="informalexample"><pre class="programlisting">Api\Model\Db\User\Information</pre></div><p>If we search for a method that retrieves user information then this class would be a great way to start searching.</p></div><div class="section" title="Think about the model's methods"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec193"/>Think about the model's methods</h3></div></div></div><p>The <a id="id536" class="indexterm"/>model's methods are obviously the most important part of the model, it is also one that is usually highly overlooked. For example, developers sometimes use the wrong visibility while defining their methods, which then ends up misused by other developers who think they could (or couldn't) use a specific method because of its visibility.</p><p>Sometimes the method is named incorrect or the visibility has been set up wrong and in turn we end up refactoring the code. All of which can be avoided by simply thinking about it beforehand.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>It is also wise to name your method right, put the visibility in correctly, and to use a strict naming convention in our application. </p><p>Method names should be named through <code class="literal">camelCase</code>, and only protected and private methods should be allowed to start with an underscore.</p></div></div></div><div class="section" title="Unit test the model"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec194"/>Unit test the model</h3></div></div></div><p>Testing <a id="id537" class="indexterm"/>your model is a great way of making sure the output of the methods always matches with the output we expect it to be. An even greater way (personally) of developing your model is to TDD (Test-Driven Development) the code so that you have an objective test, instead of a subjective one, if you write the test after you have written the method. We will talk more about unit testing and TDD in <a class="link" href="ch09.html" title="Chapter 9. Catching Bugs">Chapter 9</a>, <span class="emphasis"><em>Catching bugs</em></span>.</p></div><div class="section" title="Document your class"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec195"/>Document your class</h3></div></div></div><p>Usually documenting <a id="id538" class="indexterm"/>a class is overlooked and/or unmaintained while it should be something that exists in your routine. Even if we are the only developer on the project, and we know that in ten years time we would still be the only developer, it still is a great way to let the future us know why we created that method, what it does, and what we can expect back from it.</p><p>The PHP DocBlock<a id="id539" class="indexterm"/> or in short the PHPDoc<a id="id540" class="indexterm"/> is the formal standard of documenting our code in the comment format. First of all a docblocks can be identified by the following syntax:</p><div class="informalexample"><pre class="programlisting">/**
 * This is used to describe the method, file or class.
 *
 * <span class="strong"><strong>@param</strong></span> string $parameterOne Some description here.
 * <span class="strong"><strong>@result</strong></span> Boolean
 * <span class="strong"><strong>@throws</strong></span> Some\Exception
 * <span class="strong"><strong>@author</strong></span> J. Callaars &lt;bcallaars@gmail.com&gt;
 */
public function someMethod($parameterOne);</pre></div><p>As we<a id="id541" class="indexterm"/> can see, the difference between a normal comment block and a docblock is the two asterisks used at the beginning. After that the first line should always describe the current method, class, or file (whatever the context is). The lines' following that consists of tags, which are used to define certain properties of the docblock. For example, the <code class="literal">@param</code> tag is used to define parameters to a method, which have a type defined, and the name of the parameter behind it. The <code class="literal">@result</code> expresses the return value of the method call, and the <code class="literal">@throws</code> tells us an exception can occur in this method. And last but not least <code class="literal">@author</code> tells us who initially created the method/file/class.</p><p>Obviously there are dozens of other tags to use, of which most of them can be found at <a class="ulink" href="http://en.wikipedia.org/wiki/PHPDoc">http://en.wikipedia.org/wiki/PHPDoc</a>.</p><p>We would recommend using the <code class="literal">phpDocumenter</code> syntax to use as the standard of creating method and class documentation as it is an industry standard and gives us the option of generating a technical document quite easily.</p></div><div class="section" title="Creating a hydrator"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec196"/>Creating a hydrator</h3></div></div></div><p>Hydrators<a id="id542" class="indexterm"/> are the sort classes that can be used to hydrate a specific class with values given to the <code class="literal">Hydrator</code>.</p><p>This can be especially useful when retrieving data from a database table, and when we want to map it to another model, where the model doesn't have to know the mappings of the table and the <code class="literal">TableGateway</code> doesn't have to know how to map them to the model. In such cases a <code class="literal">Hydrator</code> is perfect for the job as an intermediary between the model and the data access layers.</p><p>The <code class="literal">mapping</code> property defines the mapping between the received array (which we use to hydrate) and the property on the object side. So, for example, if our array contains a key ID, we will set the property primary in the object. Obviously this is the most basic a <code class="literal">hydrate</code> method can possibly be as it simply checks if we have a valid object and then checks if we have the property name we want to set and sets it if it does.</p></div><div class="section" title="Creating a hydrator strategy"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec197"/>Creating a hydrator strategy</h3></div></div></div><p>Now that<a id="id543" class="indexterm"/> we have a simple hydrator, we might want to take a look at another amazing piece of the Zend Framework that is new: the hydrator strategy. The hydrator strategy is simply said a transformation of one value that is being parsed into the <code class="literal">Hydrator</code>.</p><p>We changed the primary setter of the hydrator now, so that when it receives something else than an integer it will throw an exception.</p><p>But our <code class="literal">Hydrator</code> is not familiar with the properties in our model, which in turn means that when an incompatible value is used and exception will be thrown. To overcome this (and many other) problem, we can use a hydrator strategy, which will have the last chance to set a value before it goes to the model.</p><p>Now the plan is that we will create a hydrator strategy which will check our primary property and make sure it returns an integer. As we can see further on, we basically created an <code class="literal">extract</code> and a <code class="literal">hydrate</code> method, which will check if there is an integer as value, and if not return a random integer. This way we safeguard ourselves so that any value that comes in to our model is at least the type we expect it to be.</p></div><div class="section" title="About models"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec198"/>About models</h3></div></div></div><p>Models <a id="id544" class="indexterm"/>are just regular classes which differ nothing from any other class. However, the principle behind a model is that all the business critical logic is defined in them. An MVC prefers to have skinny controllers (which means no or almost no logic) and fat models.</p><p>Hydrators, on the other hand, are classes that are used in between models, for example, when exchanging data from one model to another, or from a <code class="literal">TableGateway</code> to a model and vice versa. Obviously not every model we write would require a <code class="literal">Hydrator</code>, but as applications tend to grow, we like to implement new features without having to change the existing ones, and <code class="literal">Hydrator</code> can then serve as a key factor as they can serve as a proxy between objects.</p></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec93"/>There's more…</h2></div></div></div><p>There is a lot more to write about hydrators, and especially the different kinds of default hydrators that come with Zend Framework 2. If we want to know more about that we should check the documentation for the <code class="literal">Zend\Stdlib\Hydrator\ArraySerializable</code>, <code class="literal">Zend\Stdlib\Hydrator\ClassMethods</code>, and the <code class="literal">Zend\Stdlib\Hydrator\ObjectProperty</code> hydrator.</p></div></div>
<div class="section" title="A basic service"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>A basic service</h1></div></div></div><p>One of the<a id="id545" class="indexterm"/> biggest features of Zend Framework 2 is the <code class="literal">ServiceManager</code>
<a id="id546" class="indexterm"/>, and its influence in the framework can be seen from the initial bootstrap of our application. We don't need a reason to explain why this recipe goes deeper in this topic, do we?</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec94"/>Getting ready</h2></div></div></div><p>Again a Zend Framework 2 skeleton application should be running to make the full use of our examples in this recipe.</p><p>Before we continue let's get the difference between a service and a model. Although the definition of a service is sometimes a judgment call, it can be safely assumed that a service is a class between the controller and the model, which hides all the nasty logic from the controller, for example, checking the authentication or calling a method in a model. Another thing that is different is that the service in our case will be managed by the <code class="literal">ServiceManager</code>, and therefore, can be called from any controller (and other service) in our application.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec95"/>How to do it…</h2></div></div></div><p>Services are a great way of making sure our functionality can be accessed virtually anywhere in our application, and in this recipe we will show exactly how to do that!</p><div class="section" title="Creating a service"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec199"/>Creating a service</h3></div></div></div><p>We will <a id="id547" class="indexterm"/>create our service in the <code class="literal">/module/Application/src/Application/Service/Example.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Application\Service;

use Zend\ServiceManager\ServiceLocatorAwareInterface,
    Zend\ServiceManager\ServiceLocatorInterface;

class Example implements ServiceLocatorAwareInterface 
{
  protected $serviceLocator;

  // This is set by our initialization so we don't 
  // actually have to do this ourselves probably
  public function setServiceLocator(ServiceLocatorInterface $serviceLocator) 
  {
    $this-&gt;serviceLocator = $serviceLocator;
  }

  // Retrieve the service locator, handy if we want to 
  // read some configuration
  public function getServiceLocator() 
  {
    return $this-&gt;serviceLocator;
  }

  // Let's create a simple string to rot13 encoder as an 
  // example
  public function encodeMyString($string)
  {
    return str_rot13($string);
  }
}</pre></div><p>Now the only <a id="id548" class="indexterm"/>thing that left to do is to add this service to the module configuration (the file is <code class="literal">/module/Application/config/module.config.php</code>), so it can be reached by the rest of the application as well:</p><div class="informalexample"><pre class="programlisting">&lt;?php 
return array(
  'service_manager' =&gt; array(
    'invokables' =&gt; array(
      // We are going to call our service through the 
      // ExampleService name
      'ExampleService' =&gt; 'Application\Service\Example',
    ),
  ),
);</pre></div><p>Of course, this is again a snippet to show what needs to be added to the configuration. We can now <a id="id549" class="indexterm"/>easily retrieve the service in, for example, a controller by performing the following:</p><div class="informalexample"><pre class="programlisting">// This is an example from within a controller and 
// returns a rot13 encoded string
echo $this-&gt;getServiceLocator()
          -&gt;get('ExampleService')
          -&gt;encodeMyString("Service? Easily created!");</pre></div></div><div class="section" title="Getting a service from within a controller"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec200"/>Getting a service from within a controller</h3></div></div></div><p>This example <a id="id550" class="indexterm"/>shows that it is very easy to retrieve a service from a controller. From within a service we can also easily get our main application configuration by performing the following:</p><div class="informalexample"><pre class="programlisting">// This is executed from within a service class and will 
// return the configuration of the application
$config = $this-&gt;getServiceLocator()-&gt;get('config');</pre></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec96"/>How it works…</h2></div></div></div><p>We created a very basic service and added it to the configuration of our <code class="literal">Application</code> module. The idea behind it is that we can show how easy it is to create a service, activate it, and use it in the application. We will create a service that is going to be managed by the <code class="literal">ServiceManager</code> and does nothing more than rot13 encode on a string.</p><p>To create a service we only need to implement the <code class="literal">Zend\ServiceManager\ServiceLocatorAwareInterface</code> in our class, which predefines two methods, the <code class="literal">getServiceLocator</code> and the <code class="literal">setServiceLocator</code>. The <code class="literal">setServiceLocator</code> is called during instantiation, and most of the time (at least not when we add the service in our configuration) we don't have to do this manually.</p><p>The <code class="literal">getServiceLocator</code>
<a id="id551" class="indexterm"/> however is a method we can use to get the <code class="literal">ServiceLocator</code>, from which we can get useful things like other services, or perhaps the configuration of the application itself.</p><p>Services are instantiated either at the loading of the modules if they are in the module configuration, or just during some place in the application. However, when we instantiate the service, we know that we can always get it through the same easy <code class="literal">get()</code> method<a id="id552" class="indexterm"/> of the <code class="literal">ServiceLocator</code> anywhere else in the application once it has been instantiated.</p></div></div></body></html>