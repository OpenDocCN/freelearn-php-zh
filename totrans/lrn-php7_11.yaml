- en: Status codes in responses
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应中的状态码
- en: If HTTP methods are very important for requests, status codes are almost indispensable
    for responses. With just one number, the client will know what happened with the
    request. This is especially useful when you know that status codes are a standard,
    and they are extensively documented on the Internet.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTTP方法对于请求非常重要，状态码对于响应几乎是不可或缺的。仅仅一个数字，客户端就能知道请求发生了什么。这在你知道状态码是一个标准，并且在互联网上有广泛的文档记录时特别有用。
- en: We've already described the most important ones in [Chapter 2](part0019_split_000.html#I3QM2-edcc22b134104d5db0bf3aa086c86851
    "Chapter 2. Web Applications with PHP"), *Web Applications with PHP*, but let's
    list them again, adding a few more that are important for REST APIs. For the full
    list of status codes, you can visit [https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第2章](part0019_split_000.html#I3QM2-edcc22b134104d5db0bf3aa086c86851 "第2章。使用PHP的Web应用")中描述了最重要的状态码，*使用PHP的Web应用*，但让我们再次列出它们，并添加一些对REST
    API很重要的状态码。要查看状态码的完整列表，您可以访问[https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。
- en: 2xx – success
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2xx – 成功
- en: 'All the status codes that start with 2 are used for responses where the request
    was processed successfully, regardless of whether it was a GET or POST. Some of
    the most commonly used ones in this category are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有以2开头的状态码都用于请求处理成功的响应，无论它是GET还是POST。以下是一些这个类别中最常用的状态码：
- en: '**200 OK**: It is the generic "everything was OK" response. If you were asking
    for a resource, you will get it in the body of the response, and if you were updating
    a resource, this will mean that the new data has been successfully saved.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**200 OK**：这是通用的“一切正常”响应。如果你请求一个资源，你将在响应体中获取它，如果你更新一个资源，这将意味着新数据已成功保存。'
- en: '**201 created**: It is the response used when resources are created successfully
    with POST or PUT.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**201 created**：这是在POST或PUT操作成功创建资源时使用的响应。'
- en: '**202 accepted**: This response means that the request has been accepted, but
    it has not been processed yet. This might be useful when the client needs a straightforward
    response for a very heavy operation: the server sends the accepted response, and
    then starts processing it.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**202 accepted**：这个响应意味着请求已被接受，但尚未处理。当客户端需要一个简单的响应来处理一个非常重的操作时，这可能很有用：服务器发送接受的响应，然后开始处理它。'
- en: 3xx – redirection
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3xx – 重定向
- en: 'Even though you might think there is only one type of redirection, there are
    a few refinements:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你可能认为只有一种重定向类型，但实际上还有一些细微的差别：
- en: '**301 moved permanently**: This means that the resource has been moved to a
    different URL, so from then on, you should try to access it through the URL provided
    in the body of the response.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**301 moved permanently**：这意味着资源已经被移动到不同的URL，因此从那时起，你应该尝试通过响应正文中提供的URL来访问它。'
- en: '**303 see other**: This means that the request has been processed but, in order
    to see the response, you need to access the URL provided in the body of the response.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**303 see other**：这意味着请求已经处理，但为了看到响应，你需要访问响应正文中提供的URL。'
- en: 4xx – client error
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4xx – 客户端错误
- en: 'This category has status codes describing what went wrong due to the client''s
    request:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别包含描述由于客户端请求错误而导致的问题的状态码：
- en: '**400 bad request**: This is a generic response to a malformed request, that
    is, there is a syntax error in the endpoint, or some of the expected parameters
    were not provided.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**400 bad request**：这是对格式错误的请求的通用响应，即端点存在语法错误，或者没有提供一些预期的参数。'
- en: '**401 unauthorized**: This means the client has not been authenticated successfully
    yet, and the resource that it is trying to access needs this authentication.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**401 unauthorized**：这意味着客户端尚未成功认证，它试图访问的资源需要这种认证。'
- en: '**403 forbidden**: This error message means that even though the client has
    been authenticated, it does not have enough permissions to access that resource.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**403 forbidden**：这个错误消息意味着尽管客户端已经认证，但它没有足够的权限访问该资源。'
- en: '**404 not found**: The specific resource has not been found.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**404 not found**：特定的资源未找到。'
- en: '**405 method not allowed**: This means that the endpoint exists, but it does
    not accept the HTTP method used on the request, for example, we were trying to
    use PUT, but the endpoint only accepts POST requests.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**405 method not allowed**：这意味着端点存在，但它不接受请求中使用的HTTP方法，例如，我们试图使用PUT，但端点只接受POST请求。'
- en: 5xx – server error
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5xx – 服务器错误
- en: 'There are up to 11 different errors on the server side, but we are only interested
    in one: the **500 internal server** error. You could use this status code when
    something unexpected, like a database error, happens while processing the request.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端可能有多达 11 种不同的错误，但我们只对其中一种感兴趣：**500 内部服务器**错误。当在处理请求时发生意外情况，如数据库错误，你可以使用这个状态码。
- en: REST API security
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST API 安全性
- en: REST APIs are a powerful tool since they allow developers to retrieve and/or
    update data from the server. But with great power comes great responsibility,
    and when designing a REST API, you should think about making your data as secure
    as possible. Imagine— anyone could post tweets on your behalf with a simple HTTP
    request!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 是一种强大的工具，因为它们允许开发者从服务器检索和/或更新数据。但权力越大，责任越大，在设计 REST API 时，你应该考虑使你的数据尽可能安全。想象一下——任何人都可以通过简单的
    HTTP 请求代表你发布推文！
- en: 'Similar to using web applications, there are two concepts here: **authentication**
    and **authorization**. Authenticating someone is identifying who he or she is,
    that is, linking his or her request to a user in the database. On the other hand,
    authorizing someone is to allow that specific user to perform certain actions.
    You could think of authentication as the login of the user, and authorization
    as giving permissions.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于使用网络应用程序，这里有两个概念：**认证**和**授权**。认证某人就是识别他是谁，也就是说，将他的请求与数据库中的用户关联起来。另一方面，授权某人就是允许该特定用户执行某些操作。你可以把认证看作是用户的登录，而授权则是赋予权限。
- en: REST APIs need to manage these two concepts very carefully. Just because a developer
    has been authenticated does not mean he can access all the data on the server.
    Sometimes, users can access only their own data, whereas sometimes you would like
    to implement a roles system where each role has different access levels. It always
    depends on the type of application you are building.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 需要非常小心地管理这两个概念。仅仅因为开发者已经通过认证，并不意味着他可以访问服务器上的所有数据。有时，用户只能访问他们自己的数据，而有时你可能希望实现一个角色系统，其中每个角色有不同的访问级别。这始终取决于你正在构建的应用程序类型。
- en: Although authorization happens on the server side, that is, it's the server's
    database that will decide whether a given user can access a certain resource or
    not, authentications have to be triggered by the client. This means that the client
    has to know what authentication system the REST API is using in order to proceed
    with the authentication. Each REST API will implement its own authentication system,
    but there are some well known implementations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然授权发生在服务器端，即服务器数据库将决定给定的用户是否可以访问某个资源，但认证必须由客户端触发。这意味着客户端必须知道 REST API 使用的是哪种认证系统，以便进行认证。每个
    REST API 都将实现自己的认证系统，但有一些知名的实施方式。
- en: Basic access authentication
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本访问认证
- en: Basic access authentication—BA for short—is, as its name suggests, basic. The
    client adds the information about the user in the headers of each request, that
    is, username and password. The problem is that this information is only encoded
    using BASE64 but not encrypted, making it extremely easy for an intruder to decode
    the header and obtain the password in plain text. If you ever have to use it,
    since, to be honest, it is a very easy way of implementing some sort of authentication,
    we would recommend you to use it with HTTPS.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 基本访问认证——简称 BA——正如其名所示，非常基础。客户端在每个请求的头部添加关于用户的信息，即用户名和密码。问题是这些信息仅使用 BASE64 编码，而没有加密，这使得入侵者可以轻易解码头部并获取明文密码。如果你必须使用它，说实话，这是一种实现某种认证的非常简单的方法，我们建议你使用
    HTTPS。
- en: 'In order to use this method, you need to concatenate the username and password
    like `username:password`, encode the resultant string using Base64, and add the
    authorization header as:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这种方法，你需要将用户名和密码像 `username:password` 一样连接起来，使用 Base64 对结果字符串进行编码，并将授权头添加为：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: OAuth 2.0
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OAuth 2.0
- en: 'If basic authentication was very simple, and insecure, OAuth 2.0 is the most
    secure system that REST APIs use in order to authenticate, and so was the previous
    OAuth 1.0\. There are actually different versions of this standard, but all of
    them work on the same foundation:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果基本认证非常简单且不安全，OAuth 2.0 就是 REST API 用来进行认证的最安全系统，之前的 OAuth 1.0 也是如此。实际上，这个标准有多个版本，但它们都建立在相同的基础上：
- en: There are no usernames and passwords. Instead, the provider of the REST API
    assigns a pair of credentials—a token and the secret—to the developer.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有用户名和密码。相反，REST API的提供者会给开发者分配一对凭据——一个令牌和一个密钥。
- en: In order to authenticate, the developer needs to send a POST request to the
    "token" endpoint, which is different in each REST API but has the same concept.
    This request has to include the encoded developer credentials.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进行身份验证，开发者需要向“令牌”端点发送一个POST请求，每个REST API的端点都不同，但概念相同。这个请求必须包含编码的开发者凭据。
- en: The server replies to the previous request with a session token. This (and not
    the credentials mentioned in the first step) is to be included in each request
    that you make to the REST API. The session token expires for security reasons,
    so you will have to repeat the second step again when that happens.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器用会话令牌回复之前的请求。这个（而不是第一步中提到的凭据）需要包含在你向REST API发出的每个请求中。出于安全原因，会话令牌会过期，所以当这种情况发生时，你将不得不再次重复第二步。
- en: Even though this standard is kind of recent (2012 onwards), several big companies
    like Google or Facebook have already implemented it for their REST APIs. It might
    look a bit overcomplicated, but you will soon get to use it, and even implement
    it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个标准相对较新（从2012年开始），像谷歌或Facebook这样的几家大公司已经为它们的REST API实施了它。它可能看起来有点过于复杂，但你会很快学会使用它，甚至可以自己实现它。
- en: Using third-party APIs
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方API
- en: That was enough theory about REST APIs; it is time to dive into a real world
    example. In this section, we will write a small PHP application that interacts
    with Twitter's REST API; that includes requesting developer credentials, authenticating,
    and sending requests. The goal is to give you your first experience in working
    with REST APIs, and showing you that it is easier than you could expect. It will
    also help you to understand better how they work, so it will be easier to build
    your own later.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关于REST API的理论就到这里；现在是时候深入一个真实世界的例子了。在本节中，我们将编写一个小型的PHP应用程序，与Twitter的REST API进行交互；这包括请求开发者凭据、进行身份验证和发送请求。目标是让你获得使用REST
    API的第一手经验，并展示它比你预期的要简单。这也有助于你更好地理解它们是如何工作的，因此以后构建自己的API会更容易。
- en: Getting the application's credentials
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取应用程序的凭据
- en: REST APIs usually have the concept of application. An application is like an
    account on their development site that identifies who uses the API. The credentials
    that you will use to access the API will be linked to this application, which
    means that you can have multiple applications linked to the same account.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: REST API通常有应用程序的概念。应用程序就像它们开发网站上的一个账户，用于标识谁在使用API。你将用来访问API的凭据将与该应用程序相关联，这意味着你可以有多个应用程序与同一个账户相关联。
- en: Assuming that you have a Twitter account, go to [https://apps.twitter.com](https://apps.twitter.com)
    in order to create a new application. Click on the **Create New App** button in
    order to access the form for application details. The fields are very self-explanatory—just
    a name for the application, the description, and the website URL. The callback
    URL is not necessary here, since that will be used only for applications that
    require access to someone else's account. Agree with the terms and conditions
    in order to proceed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个Twitter账户，请访问[https://apps.twitter.com](https://apps.twitter.com)以创建一个新的应用程序。点击**创建新应用**按钮以访问应用程序详情表单。字段非常直观——只需为应用程序提供一个名称、描述和网站URL。回调URL在这里不是必需的，因为它仅用于需要访问他人账户的应用程序。同意条款和条件以继续。
- en: 'Once you have been redirected to your application''s page, you will see all
    sort of information that you can edit. Since this is just an example, let''s go
    straight to what matters: the credentials. Click on the **Keys and Access Tokens**
    tab to see the values of **Consumer key (API key)** and **Consumer Secret (API
    secret)**. There is nothing else that we need from here. You can save them on
    your filesystem, as `~/.twitter_php7.json`, for example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你被重定向到你的应用程序页面，你会看到各种可以编辑的信息。由于这是一个示例，让我们直接进入重点：凭据。点击**密钥和访问令牌**选项卡以查看**消费者密钥（API密钥）**和**消费者密钥（API密钥）**的值。这里我们不需要其他任何东西。你可以将它们保存在你的文件系统中，例如`~/.twitter_php7.json`：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Securing your credentials**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**保护你的凭据**'
- en: Securing your REST API credentials should be taken seriously. In fact, you should
    take care of all kinds of credentials, like the database ones. But the difference
    is that you will usually host your database in your server, which makes things
    slightly more difficult to whoever wants to attack. On the other hand, the third-party
    REST API is not part of your system, and someone with your credentials can use
    your account freely on your behalf.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 保护您的 REST API 凭据应受到重视。实际上，您应该注意所有类型的凭据，如数据库凭据。但区别在于您通常会在自己的服务器上托管数据库，这使得攻击者稍微困难一些。另一方面，第三方
    REST API 不是您系统的一部分，并且拥有您凭据的人可以代表您自由使用您的账户。
- en: Never include your credentials in your code base, especially if you have your
    code in GitHub or some other repository. One solution would be to have a file
    in your server, outside your code, with the credentials; if that file is encrypted,
    that is even better. And try to refresh your credentials regularly, which you
    can probably do on the provider's website.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要将您的凭据包含在代码库中，尤其是如果您在 GitHub 或其他存储库中有代码。一个解决方案是在您的服务器上创建一个文件，该文件位于您的代码之外，并包含凭据；如果该文件被加密，那就更好了。并且尝试定期刷新您的凭据，您可能可以在提供者的网站上完成此操作。
- en: Setting up the application
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置应用程序
- en: Our application will be extremely simple. It will consist of one class that
    will allow us to fetch tweets. This will be managed by our `app.php` script.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将非常简单。它将包含一个类，该类允许我们检索推文。这将由我们的 `app.php` 脚本管理。
- en: 'As we have to make HTTP requests, we can either write our own functions that
    use **cURL** (a set of PHP native functions), or make use of the famous PHP library,
    **Guzzle**. This library can be found in **Packagist**, so we will use Composer
    to include it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们必须进行 HTTP 请求，我们可以编写自己的函数，这些函数使用 **cURL**（一组 PHP 本地函数），或者使用著名的 PHP 库 **Guzzle**。这个库可以在
    **Packagist** 中找到，因此我们将使用 Composer 来包含它：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will have a `Twitter` class, which will get the credentials from the constructor,
    and one public method: `fetchTwits`. For now, just create the skeleton so that
    we can work with it; we will implement such methods in later sections. Add the
    following code to `src/Twitter.php`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个 `Twitter` 类，它将从构造函数中获取凭据，并且有一个公共方法：`fetchTwits`。目前，只需创建一个框架，以便我们可以使用它；我们将在后面的章节中实现这些方法。将以下代码添加到
    `src/Twitter.php`：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since we set the namespace `TwitterApp`, we need to update our `composer.json`
    file with the following addition. Remember to run `composer update` to update
    the autoloader.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们设置了命名空间 `TwitterApp`，我们需要更新我们的 `composer.json` 文件，并添加以下内容。请记住运行 `composer
    update` 以更新自动加载器。
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we will create a basic `app.php` file, which includes the Composer
    autoloader, reads the credentials file, and creates a Twitter instance:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个基本的 `app.php` 文件，该文件包含 Composer 自动加载器，读取凭据文件，并创建一个 Twitter 实例：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Requesting an access token
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求访问令牌
- en: In a real world application, you would probably want to separate the code related
    to authentication from the one that deals with operations like fetching or posting
    data. To keep things simple here, we will let the `Twitter` class know how to
    authenticate by itself.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，您可能希望将与认证相关的代码与处理数据检索或发布等操作的代码分开。为了保持简单，我们将让 `Twitter` 类知道如何自行进行认证。
- en: 'Let''s start by adding a `$client` property to the class which will contain
    an instance of Guzzle''s `Client` class. This instance will contain the base URI
    of the Twitter API, which we can have as the constant `TWITTER_API_BASE_URI`.
    Instantiate this property in the constructor so that the rest of the methods can
    make use of it. You can also add an `$accessToken` property which will contain
    the access token returned by the Twitter API when authenticating. All these changes
    are highlighted here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从给类添加一个 `$client` 属性开始，该属性将包含 Guzzle 的 `Client` 类的实例。这个实例将包含 Twitter API
    的基本 URI，我们可以将其作为常量 `TWITTER_API_BASE_URI`。在构造函数中实例化此属性，以便其他方法可以使用它。您还可以添加一个 `$accessToken`
    属性，该属性将包含 Twitter API 在认证时返回的访问令牌。所有这些更改在此处突出显示：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next step would be to write a method that, given the key and secret are
    provided, requests an access token to the provider. More specifically:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是编写一个方法，给定密钥和秘密后，向提供者请求访问令牌。更具体地说：
- en: Concatenate the key and the secret with a `:`. Encode the result using Base64.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将密钥和秘密使用 `:` 连接。使用 Base64 对结果进行编码。
- en: Send a POST request to `/oauth2/token` with the encoded credentials as the `Authorization`
    header. Also include a `Content-Type` header and a body (check the code for more
    information).
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`/oauth2/token`发送带有编码凭证的POST请求作为`Authorization`头。还要包括`Content-Type`头和体（更多信息请查看代码）。
- en: 'We now invoke the `post` method of Guzzle''s `client` instance sending two
    arguments: the endpoint string (`/oauth2/token`) and an array with options. These
    options include the headers and the body of the request, as you will see shortly.
    The response of this invocation is an object that identifies the HTTP response.
    You can extract the content (body) of the response with `getBody`. Twitter''s
    API response is a JSON with some arguments. The one that you care about the most
    is the `access_token`, the token that you will need to include in each subsequent
    request to the API. Extract it and save it. The full method looks as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在调用Guzzle的`client`实例的`post`方法，传递两个参数：端点字符串（`/oauth2/token`）和包含选项的数组。这些选项包括请求的头和体，您将很快看到。这个调用的响应是一个对象，它标识HTTP响应。您可以使用`getBody`提取响应的内容（体）。Twitter的API响应是一个带有一些参数的JSON。您最关心的参数是`access_token`，这是您需要在每个后续API请求中包含的令牌。提取它并保存。完整的方法如下：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can already try this code by adding these two lines at the end of the constructor:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在构造函数末尾添加这两行代码来尝试此代码：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the application in order to see the access token given by the provider using
    the following command. Remember to remove the preceding two lines in order to
    proceed with the section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行应用程序，以查看提供者提供的访问令牌。记住，为了继续本节，请删除前面的两行。
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Keep in mind that, even though having a key and secret and getting an access
    token is the same across all OAuth authentications, the specific way of encoding,
    the endpoint used, and the response received from the provider are exclusive from
    Twitter's API. It could be that several others are exactly the same, but always
    check the documentation for each one.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尽管拥有密钥和密钥并获取访问令牌在所有OAuth身份验证中都是相同的，但编码方式、使用的端点和从提供者收到的响应对于Twitter的API是独有的。可能还有其他几个是相同的，但始终检查每个的文档。
- en: Fetching tweets
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取推文
- en: 'We finally arrive to the section where we actually make use of the API. We
    will implement the `fetchTwits` method in order to get a list of the last *N*
    number of tweets for a given user. In order to perform requests, we need to add
    the `Authorization` header to each one, this time with the access token. Since
    we want to make this class as reusable as possible, let''s extract this to a private
    method:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终到达了实际使用API的部分。我们将实现`fetchTwits`方法，以获取给定用户的最后*N*条推文列表。为了执行请求，我们需要在每个请求中添加`Authorization`头，这次使用访问令牌。由于我们希望尽可能使这个类可重用，让我们将其提取到一个私有方法中：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, the preceding method also allows us to fetch the access token
    from the provider. This is useful, since if we make more than one request, we
    will just request the access token once, and we have one unique place to do so.
    Add now the following method implementation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面方法还允许我们从提供者那里获取访问令牌。这很有用，因为我们如果发出多个请求，我们只需请求一次访问令牌，并且有一个唯一的地方来做这件事。现在添加以下方法实现：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first part of the preceding method builds the `options` array with the access
    token headers and the query string arguments—in this case, with the number of
    tweets to retrieve and the user. We perform the GET request and decode the JSON
    response into an array. This array contains a lot of information that we might
    not need, so we iterate it in order to extract those fields that we really want—in
    this example, the date, the text, and the user.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法的第一个部分使用访问令牌头和查询字符串参数构建`options`数组——在这种情况下，包括要检索的推文数量和用户。我们执行GET请求并将JSON响应解码为数组。这个数组包含大量我们可能不需要的信息，因此我们迭代它以提取我们真正想要的字段——在这个例子中，日期、文本和用户。
- en: In order to test the application, just invoke the `fetchTwits` method at the
    end of the `app.php` file, specifying the Twitter ID of one of the people you
    are following, or yourself.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试应用程序，只需在`app.php`文件的末尾调用`fetchTwits`方法，指定您关注的某人的Twitter ID或您自己的ID。
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should get a response similar to ours, shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到一个类似于我们下面的响应，如以下截图所示：
- en: '![Fetching tweets](img/00044.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![获取推文](img/00044.jpeg)'
- en: 'One thing to keep in mind is that access tokens expire after some time, returning
    an HTTP response with a 4xx status code (usually, 401 unauthorized). Guzzle throws
    an exception when the status code is either 4xx or 5xx, so it is easy manage these
    scenarios. You could add this code when performing the GET request:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事情是，访问令牌在一段时间后会过期，返回一个带有4xx状态码的HTTP响应（通常是401未授权）。Guzzle在状态码为4xx或5xx时抛出异常，因此很容易管理这些场景。你可以在执行GET请求时添加此代码：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The toolkit of the REST API developer
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API开发者的工具集
- en: While you are developing your own REST API, or writing an integration for a
    third-party one, you might want to test it before you start writing your code.
    There are a handful of tools that will help you with this task, whether you want
    to use your browser, or you are a fan of the command line.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你正在开发自己的REST API，或者为第三方API编写集成时，你可能想在开始编写代码之前测试它。有一些工具可以帮助你完成这项任务，无论你是想使用浏览器，还是你是命令行的粉丝。
- en: Testing APIs with browsers
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用浏览器测试API
- en: 'There are actually several add-ons that allow you to perform HTTP requests
    from browsers, depending on which one you use. Some famous names are *Advanced
    Rest Client* for Chrome and *RESTClient* for Firefox. At the end of the day, all
    those clients allow you to perform the same HTTP requests, where you can specify
    the URL, the method, the headers, the body, and so on. These clients will also
    show you all the details you can imagine from the response, including the status
    code, the time spent, and the body. The following screenshot displays an example
    of a request using Chrome''s *Advanced Rest Client*:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有几个插件允许你从浏览器执行HTTP请求，具体取决于你使用的是哪一个。一些著名的名字是Chrome上的*Advanced Rest Client*和Firefox上的*RESTClient*。最终，所有这些客户端都允许你执行相同的HTTP请求，你可以指定URL、方法、头部、主体等。这些客户端还会显示你想象得到的所有响应细节，包括状态码、耗时和主体。以下截图显示了使用Chrome的*Advanced
    Rest Client*的一个请求示例：
- en: '![Testing APIs with browsers](img/00045.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![使用浏览器测试API](img/00045.jpeg)'
- en: If you want to test GET requests with your own API, and all that you need is
    the URL, that is, you do not need to send any headers, you can just use your browser
    as if you were trying to access any other website. If you do so, and if you are
    working with JSON responses, you can install another add-on to your browser that
    will help you in viewing your JSON in a more "beautiful" way. Look for *JSONView*
    on any browser for a really handy one.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用自己的API测试GET请求，而你需要的只是URL，也就是说，你不需要发送任何头部，你只需像访问任何其他网站一样使用你的浏览器。如果你这样做，并且如果你正在处理JSON响应，你可以安装另一个浏览器插件，这将帮助你以更“美观”的方式查看你的JSON。在任何浏览器上查找*JSONView*，以获得一个真正方便的工具。
- en: Testing APIs using the command line
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令行测试API
- en: 'Some people feel more comfortable using the command line; so luckily, for them
    there are tools that allow them to perform any HTTP request from their consoles.
    We will give a brief introduction to one of the most famous ones: cURL. This tool
    has quite a lot of features, but we will focus only on the ones that you will
    be using more often: the HTTP method, post parameters, and headers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人觉得使用命令行更舒服；幸运的是，对于他们来说，有一些工具允许他们从控制台执行任何HTTP请求。我们将简要介绍其中最著名的一个：cURL。这个工具有很多功能，但我们只会关注你更常使用的那些：HTTP方法、POST参数和头部：
- en: '`-X <method>`: This specifies the HTTP method to use'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-X <method>`：这指定了要使用的HTTP方法'
- en: '`--data`: This adds the parameters specified, which can be added as key-value
    pairs, JSON, plain text, and so on'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--data`：这添加了指定的参数，可以是键值对、JSON、纯文本等'
- en: '`--header`: This adds a header to the request'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--header`：这会给请求添加一个头部'
- en: 'The following is an example of the way to send a POST request with cURL:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用cURL发送POST请求的示例：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you are using a Unix system, you will probably be able to format the resulting
    JSON by appending `| python -m json.tool` so that it gets easier to read:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Unix系统，你可能会通过附加`| python -m json.tool`来格式化生成的JSON，这样它就更容易阅读了：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: cURL is quite a powerful tool that lets you do quite a few tricks. If you are
    interested, go ahead and check the documentation or some tutorial on how to use
    all its features.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: cURL是一个非常强大的工具，它让你可以做很多技巧。如果你感兴趣，请继续查看文档或一些教程，了解如何使用所有这些功能。
- en: Best practices with REST APIs
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REST API的最佳实践
- en: We've already gone through some of the best practices when writing REST APIs,
    like using HTTP methods properly, or choosing the correct status code for your
    responses. We also described two of the most used authentication systems. But
    there is still a lot to learn about creating proper REST APIs. Remember that they
    are meant to be used by developers like yourself, so they will always be grateful
    if you do things properly, and make their lives easier. Ready?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了一些编写REST API的最佳实践，比如正确使用HTTP方法，或者为你的响应选择正确的状态码。我们还描述了两种最常用的认证系统。但关于创建合适的REST
    API还有很多东西要学习。记住，它们是为了像你这样的开发者而设计的，所以如果你做得正确，会使他们的生活变得更轻松。准备好了吗？
- en: Consistency in your endpoints
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端点的一致性
- en: 'When deciding how to name your endpoints, try keeping them consistent. Even
    though you are free to choose, there is a set of spoken rules that will make your
    endpoints more intuitive and easy to understand. Let''s list some of them:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定如何命名你的端点时，尽量保持一致性。尽管你可以自由选择，但有一套口语化的规则可以使你的端点更加直观和易于理解。让我们列举一些：
- en: For starters, an endpoint should point to a specific resource (for example,
    books or tweets), and you should make that clear in your endpoint. If you have
    an endpoint that returns the list of all books, do not name it `/library`, as
    it is not obvious what it will be returning. Instead, name it `/books` or `/books/all`.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，一个端点应该指向一个特定的资源（例如，书籍或推文），你应该在你的端点中清楚地表明这一点。如果你有一个返回所有书籍列表的端点，不要命名为`/library`，因为它不明显会返回什么。相反，命名为`/books`或`/books/all`。
- en: The name of the resource can be either plural or singular, but make it consistent.
    If sometimes you use `/books` and sometimes `/user`, it might be confusing, and
    people will probably make mistakes. We personally prefer to use the plural form,
    but that is totally up to you.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源名称可以是复数也可以是单数，但请保持一致性。如果你有时使用`/books`，有时使用`/user`，可能会造成混淆，人们可能会犯错误。我们个人更喜欢使用复数形式，但这完全取决于你。
- en: When you want to retrieve a specific resource, do it by specifying the ID whenever
    possible. IDs must be unique in your system, and any other parameter might point
    to two different entities. Specify the ID next to the name of the resource, such
    as `/books/249234-234-23-42`.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想检索特定的资源时，如果可能的话，通过指定ID来执行。ID必须在你的系统中是唯一的，任何其他参数可能指向两个不同的实体。在资源名称旁边指定ID，例如`/books/249234-234-23-42`。
- en: If you can understand what an endpoint does by just the HTTP method, there is
    no need to add this information as part of the endpoint. For example, if you want
    to get a book, or you want to delete it, `/books/249234-234-23-42` along with
    the HTTP methods GET and DELETE are more than enough. If it is not obvious, state
    it as a verb at the end of the endpoint, like `/employee/9218379182/promote`.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你仅通过HTTP方法就能理解端点的作用，就没有必要将其作为端点的一部分添加信息。例如，如果你想获取一本书，或者删除它，使用`/books/249234-234-23-42`以及HTTP方法GET和DELETE就足够了。如果不明显，可以在端点末尾用动词表示，如`/employee/9218379182/promote`。
- en: Document as much as you can
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尽可能多地编写文档
- en: The title says everything. You are probably not going to be the one using the
    REST API, others will. Obviously, even if you design a very intuitive set of endpoints,
    developers will still need to know the whole set of available endpoints, what
    each of them does, what optional parameters are available, and so on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 标题应该包含所有信息。你很可能不会是使用REST API的人，其他人会。显然，即使你设计了一套非常直观的端点，开发者仍然需要知道所有可用的端点，每个端点的作用，可用的可选参数等等。
- en: Write as much documentation as possible, and keep it up to date. Take a look
    at other documented APIs to gather ideas on how to display the information. There
    are plenty of templates and tools that will help you deliver a well-presented
    documentation, but you are the one that has to be consistent and methodical. Developers
    have a special hate towards documenting anything, but we also like to find clear
    and beautifully presented documentation when we need to use someone else's APIs.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能多地编写文档，并保持其更新。看看其他已记录的API，以获取如何展示信息的想法。有许多模板和工具可以帮助你提供一份展示良好的文档，但你必须保持一致性和条理性。开发者特别讨厌编写文档，但当我们需要使用他人的API时，我们也喜欢找到清晰且美观展示的文档。
- en: Filters and pagination
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤和分页
- en: One of the common usages of an API is to list resources and filter them by some
    criteria. We already saw an example when we were building our own bookstore; we
    wanted to get the list of books that contained a certain string in their titles
    or authors.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: API的一种常见用途是列出资源并通过某些标准进行筛选。当我们构建自己的书店时，我们已经看到了一个例子；我们想要获取包含特定字符串在标题或作者中的书籍列表。
- en: 'Some developers try to have beautiful endpoints, which a priori is a good thing
    to do. Imagine that you want to filter just by title, you might end up having
    an endpoint like `/books/title/<string>`. We add also the ability to filter by
    author, and we now get two more endpoints: `/books/title/<string>/author/<string>`
    and `/books/author/<string>`. Now let''s add the description too—do you see where
    we are going?'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者试图拥有美观的端点，从先验的角度来看，这是一件好事。想象一下，如果你想仅通过标题进行筛选，你可能会得到一个像 `/books/title/<string>`
    这样的端点。我们还增加了通过作者进行筛选的能力，现在我们得到了两个额外的端点：`/books/title/<string>/author/<string>`
    和 `/books/author/<string>`。现在让我们也添加描述——你看到我们想要去哪里了吗？
- en: Even though some developers do not like to use query strings as arguments, there
    is nothing wrong with it. In fact, if you use them properly, you will end up with
    cleaner endpoints. You want to get books? Fine, just use `/books`, and add whichever
    filter you need using the query string.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一些开发者不喜欢使用查询字符串作为参数，但这并没有什么问题。事实上，如果你正确使用它们，你最终会得到更干净的端点。你想获取书籍？好的，只需使用 `/books`，并使用查询字符串添加你需要的任何过滤器。
- en: Pagination occurs when you have way too many resources of the same type to retrieve
    all at once. You should think of pagination as another optional filter to be specified
    as a GET parameter. You should have pages with a default size, let's say 10 books,
    but it is a good idea to give the developers the ability to define their own size.
    In this case, developers can specify the length and the number of pages to retrieve.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你一次需要检索大量同类型资源时，就会发生分页。你应该将分页视为另一个可选的过滤器，作为GET参数指定。你应该有默认大小的页面，比如10本书，但给开发者定义他们自己的大小是一个好主意。在这种情况下，开发者可以指定要检索的长度和页数。
- en: API versioning
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API版本控制
- en: Your API is a reflection of what your application can do. Chances are that your
    code will evolve, improving the already existing features or adding new ones.
    Your API should be updated too, exposing those new features, updating existing
    endpoints, or even removing some of them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你的API是你应用程序能做什么的反映。很可能会发生你的代码会进化，改进现有的功能或添加新的功能。你的API也应该更新，以暴露这些新功能，更新现有端点，甚至删除其中的一些。
- en: Imagine now that someone else is using your REST API, and their whole website
    relies on it. If you change your existing endpoints, their website will stop working!
    They will not be happy at all, and will try to find someone else that can do what
    you were doing. Not a good scenario, but then, how do you improve your API?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，有人正在使用你的REST API，并且他们的整个网站都依赖于它。如果你更改现有的端点，他们的网站将停止工作！他们不会感到高兴，并试图找到其他人来做你之前做的事情。这不是一个好的场景，但那么，你如何改进你的API呢？
- en: 'The solution is to use versioning. When you release a new version of the API,
    do not nuke down the existing one; you should give some time to the users to upgrade
    their integrations. And how can two different versions of the API coexist? You
    already saw one of the options—the one that we recommend you: by specifying the
    version of the API to use as part of the endpoint. Do you remember the endpoint
    of the Twitter API `/1.1/statuses/user_timeline.json`? The `1.1` refers to the
    version that we want to use.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用版本控制。当你发布API的新版本时，不要删除现有的版本；你应该给用户一些时间来升级他们的集成。那么，两个不同的API版本如何共存呢？你已经看到了一个选项——我们推荐你使用的那个：通过在端点中指定要使用的API版本。你还记得Twitter
    API的端点 `/1.1/statuses/user_timeline.json` 吗？其中的 `1.1` 指的是我们想要使用的版本。
- en: Using HTTP cache
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HTTP缓存
- en: If the main feature of REST APIs is that they make heavy use of HTTP, why not
    take advantage of HTTP cache? Well, there are actual reasons for not using it,
    but most of them are due to a lack of knowledge about using it properly. It is
    out of the scope of this book to explain every single detail of its implementation,
    but let's try to give a short introduction to the topic. Plenty of resources on
    the Internet can help you to understand the parts that you are more interested
    in.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 REST API 的主要功能是大量使用 HTTP，为什么不利用 HTTP 缓存呢？好吧，不使用它的实际原因有很多，但大多数都是由于缺乏正确使用它的知识。本书的范围不包括解释其实施的每一个细节，但让我们尝试对这个主题进行简要介绍。互联网上有大量的资源可以帮助你理解你更感兴趣的部分。
- en: HTTP responses can be divided as public and private. Public responses are shared
    between all users of the API, whereas the private ones are meant to be unique
    for each user. You can specify which type of response is yours using the `Cache-Control`
    header, allowing the response to be cached if the method of the request was a
    GET. This header can also expose the expiration of the cache, that is, you can
    specify the duration for which your response will remain the same, and thus, can
    be cached.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 响应可以分为公开和私有。公开响应在 API 的所有用户之间共享，而私有响应则针对每个用户是唯一的。你可以使用 `Cache-Control`
    头来指定你的响应类型，如果请求的方法是 GET，则允许缓存响应。此头还可以暴露缓存的过期时间，即你可以指定你的响应将保持相同的时间长度，因此可以被缓存。
- en: Other systems rely on generating a hash of the representation of a resource,
    and add it as the `ETag` (Entity tag) header in order to know if the resource
    has changed or not. In a similar way, you can set the `Last-Modified` header to
    let the client know when was the last time that the given resource changed. The
    idea behind those systems is to identify when the client already contains valid
    data. If so, the provider does not process the request, but returns an empty response
    with the status code 304 (not modified) instead. When the client gets that response,
    it uses its cached content.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 其他系统依赖于生成资源的表示的哈希值，并将其作为 `ETag`（实体标签）头添加，以便知道资源是否已更改。以类似的方式，你可以设置 `Last-Modified`
    头，让客户端知道给定资源最后一次更改的时间。这些系统背后的想法是确定客户端是否已经包含有效数据。如果是这样，提供者不会处理请求，而是返回一个状态码为 304（未修改）的空响应。当客户端收到这个响应时，它将使用其缓存的文件内容。
- en: Creating a REST API with Laravel
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Laravel 创建 REST API
- en: In this section, we will build a REST API with Laravel from scratch. This REST
    API will allow you to manage different clients at your bookstore, not only via
    the browser, but via the UI as well. You will be able to perform pretty much the
    same actions as before, that is, listing books, buying them, borrowing for free,
    and so on.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从头开始使用 Laravel 构建一个 REST API。这个 REST API 将允许你管理书店中的不同客户，不仅可以通过浏览器，还可以通过用户界面。你将能够执行与之前几乎相同的行为，即列出书籍、购买它们、免费借用，等等。
- en: Once the REST API is done, you should remove all the business logic from the
    bookstore that you built during the previous chapters. The reason is that you
    should have one unique place where you can actually manipulate your databases
    and the REST API, and the rest of the applications, like the web one, should able
    to communicate with the REST API for managing data. In doing so, you will be able
    to create other applications for different platforms, like mobile apps, that will
    use the REST API too, and both the website and the mobile app will always be synchronized,
    since they will be using the same sources.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 REST API 完成，你应该从之前章节中构建的书店中移除所有业务逻辑。原因是你应该有一个唯一的地方来实际操作你的数据库和 REST API，而其他应用程序，如网站，应该能够与
    REST API 通信来管理数据。这样做，你将能够为不同的平台创建其他应用程序，例如移动应用程序，它们也将使用 REST API，并且网站和移动应用程序将始终保持同步，因为它们将使用相同的来源。
- en: 'As with our previous Laravel example, in order to create a new project, you
    just need to run the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前的 Laravel 示例一样，为了创建一个新的项目，你只需要运行以下命令：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Setting OAuth2 authentication
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 OAuth2 认证
- en: The first thing that we are going to implement is the authentication layer.
    We will use OAuth2 in order to make our application more secure than basic authentication.
    Laravel does not provide support for OAuth2 out of the box, but there is a service
    provider which does that for us.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的第一件事是认证层。我们将使用 OAuth2 来使我们的应用程序比基本认证更安全。Laravel 并没有提供开箱即用的 OAuth2 支持，但有一个服务提供者为我们做了这件事。
- en: Installing OAuth2Server
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装OAuth2Server
- en: 'To install OAuth2, add it as a dependency to your project using Composer:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装OAuth2，请使用Composer将其作为项目依赖项添加：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This service provider needs quite a few changes. We will go through them without
    going into too much detail on how things work exactly. If you are more interested
    in the topic, or if you want to create your own service providers for Laravel,
    we recommend you to go though the extensive official documentation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务提供者需要进行相当多的更改。我们将简要介绍它们，而不会过多地深入到具体的工作原理。如果你对这个主题更感兴趣，或者如果你想为Laravel创建自己的服务提供者，我们建议你查阅详尽的官方文档。
- en: 'To start with, we need to add the new OAuth2Server service provider to the
    array of providers in the `config/app.php` file. Add the following lines at the
    end of the `providers` array:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将新的OAuth2Server服务提供者添加到`config/app.php`文件中的提供者数组中。在`providers`数组的末尾添加以下几行：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the same way, you need to add a new alias to the `aliases` array in the
    same file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，你需要在同一文件中的`aliases`数组中添加一个新的别名：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s move to the `app/Http/Kernel.php` file, where we need to make some changes
    too. Add the following entry to the `$middleware` array property of the `Kernel`
    class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到`app/Http/Kernel.php`文件，在那里我们还需要做一些更改。将以下条目添加到`Kernel`类的`$middleware`数组属性中：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the following key-value pairs to the `$routeMiddleware` array property
    of the same class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下键值对添加到同一类的`$routeMiddleware`数组属性中：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We added a CSRF token verifier to the `$routeMiddleware`, so we need to remove
    the one already defined in `$middlewareGroups`, since they are incompatible. Use
    the following line to do so:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的步骤中添加了CSRF令牌验证器到`$routeMiddleware`，因此我们需要从`$middlewareGroups`中移除已经定义的，因为它们是不兼容的。使用以下行来完成此操作：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Setting up the database
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置数据库
- en: Let's set up the database now. In this section, we will assume that you already
    have the bookstore database in your environment. If you do not have it, go back
    to [Chapter 5](part0045_split_000.html#1AT9A1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 5. Using Databases"), *Using Databases*, to create it in order to proceed
    with this setup.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们设置数据库。在本节中，我们假设你已经在你的环境中有了书店数据库。如果你没有，请回到[第5章](part0045_split_000.html#1AT9A1-edcc22b134104d5db0bf3aa086c86851
    "第5章。使用数据库")，*使用数据库*，以创建它以便继续此设置。
- en: 'The first thing to do is to update the database credentials in the `.env` file.
    They should look something similar to the following lines, but with your username
    and password:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的事情是在`.env`文件中更新数据库凭证。它们应该看起来类似于以下几行，但需要使用你的用户名和密码：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order to prepare the configuration and database migration files from the
    OAuth2Server service provider, we need to publish it. In Laravel, you do it by
    executing the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备OAuth2Server服务提供者的配置和数据库迁移文件，我们需要发布它。在Laravel中，你可以通过执行以下命令来完成：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now the `database/migrations` directory contains all the necessary migration
    files that will create the necessary tables related to OAuth2 in our database.
    To execute them, we run the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`database/migrations`目录包含了所有必要的迁移文件，这些文件将在我们的数据库中创建与OAuth2相关的必要表。要执行它们，我们运行以下命令：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We need to add at least one client to the `oauth_clients` table, which is the
    table that stores the key and secrets for all clients that want to connect to
    our REST API. This new client will be the one that you will use during the development
    process in order to test what you have done. We can set a random ID—the key—and
    the secret as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要至少向`oauth_clients`表添加一个客户端，这是存储所有想要连接到我们的REST API的客户端的密钥和秘密的表。这个新的客户端将是你将在开发过程中用来测试你所做事情的一个。我们可以设置一个随机的ID——密钥——以及秘密如下：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Enabling client-credentials authentication
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用客户端凭证认证
- en: 'Since we published the plugins in `vendor` in the previous step, now we have
    the configuration files for the OAuth2Server. This plugin allows us different
    authentication systems (all of them with OAuth2), depending on our necessities.
    The one that we are interested in for our project is the `client_credentials`
    type. To let Laravel know, add the following lines at the end of the array in
    the `config/oauth2.php` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在上一步中发布了`vendor`中的插件，现在我们有了OAuth2Server的配置文件。此插件允许我们根据需要使用不同的认证系统（所有这些系统都使用OAuth2）。我们感兴趣的是我们的项目中的`client_credentials`类型。为了让Laravel知道，请在`config/oauth2.php`文件中的数组末尾添加以下几行：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These preceding lines grant access to the `client_credentials` type, which are
    managed by the `ClientCredentialsGrant` class. The `access_token_ttl` value refers
    to the time period of the access token, that is, for how long someone can use
    it. In this case, it is set to 1 hour, that is, 3,600 seconds.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的这些行授予了 `client_credentials` 类型的访问权限，这些权限由 `ClientCredentialsGrant` 类管理。`access_token_ttl`
    值指的是访问令牌的时间段，即某人可以使用它多长时间。在这种情况下，它被设置为 1 小时，即 3,600 秒。
- en: 'Finally, we need to enable a route so we can post our credentials in exchange
    for an access token. Add the following route to the routes file in `app/Http/routes.php`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要启用一个路由，以便我们可以通过提交凭证来交换访问令牌。将以下路由添加到 `app/Http/routes.php` 文件中的路由文件：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Requesting an access token
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求访问令牌
- en: 'It is time to test what we have done so far. To do so, we need to send a POST
    request to the `/oauth/access_token` endpoint that we enabled just now. This request
    needs the following POST parameters:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候测试我们到目前为止所做的工作了。为此，我们需要向刚才启用的 `/oauth/access_token` 端点发送一个 POST 请求。此请求需要以下
    POST 参数：
- en: '`client_id` with the key from the database'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据库中的密钥来指定 `client_id`
- en: '`client_secret` with the secret from the database'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据库中的密钥来指定 `client_secret`
- en: '`grant_type` to specify the type of authentication that we are trying to perform,
    in this case `client_credentials`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `grant_type` 来指定我们尝试执行的认证类型，在这种情况下是 `client_credentials`
- en: 'The request issued using the *Advanced REST Client* add-on from Chrome looks
    as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Chrome 的 *Advanced REST Client* 插件发出的请求如下所示：
- en: '![Requesting an access token](img/00046.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![请求访问令牌](img/00046.jpeg)'
- en: 'The response that you should get should have the same format as this one:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到的响应应该与这个格式相同：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note that this is a different way of requesting for an access token than what
    the Twitter API does, but the idea is still the same: given a key and a secret,
    the provider gives us an access token that will allow us to use the API for some
    time.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这与 Twitter API 请求访问令牌的方式不同，但理念仍然是相同的：给定一个密钥和一个密钥，提供者会给我们一个访问令牌，这将允许我们在一段时间内使用该
    API。
- en: Preparing the database
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备数据库
- en: 'Even though we''ve already done the same in the previous chapter, you might
    think: "Why do we start by preparing the database?". We could argue that you first
    need to know the kind of endpoints you want to expose in your REST API, and only
    then you can start thinking about what your database should look like. But you
    could also think that, since we are working with an API, each endpoint should
    manage one resource, so first you need to define the resources you are dealing
    with. This *code first versus database/model first* is an ongoing war on the Internet.
    But whichever way you think is better, the fact is that we already know what the
    users will need to do with our REST API, since we already built the UI previously;
    so it does not really matter.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在上一章中已经做了同样的事情，你可能会想：“为什么我们要先准备数据库？”我们可以争论说，你首先需要知道你想要在 REST API 中公开的端点类型，然后你才能开始考虑你的数据库应该是什么样子。但你也可能会认为，因为我们正在使用
    API，每个端点应该管理一个资源，所以首先你需要定义你正在处理的数据。这种 *代码优先与数据库/模型优先* 是互联网上持续进行的战争。但无论你认为哪种方式更好，事实是，我们已经知道用户将如何使用我们的
    REST API，因为我们之前已经构建了 UI；所以这并不真正重要。
- en: 'We need to create four tables: `books`, `sales`, `sales_books`, and `borrowed_books`.
    Remember that Laravel already provides a `users` table, which we can use as our
    customers. Run the following four commands to create the migrations files:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建四个表：`books`、`sales`、`sales_books` 和 `borrowed_books`。请记住，Laravel 已经提供了一个
    `users` 表，我们可以将其用作我们的客户。运行以下四个命令来创建迁移文件：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we have to go file by file to define what each table should look like.
    We will try to replicate the data structure from [Chapter 5](part0045_split_000.html#1AT9A1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 5. Using Databases"), *Using Databases*, as much as possible. Remember
    that the migration files can be found inside the `database/migrations` directory.
    The first file that we can edit is the `create_books_table.php`. Replace the existing
    empty `up` method by the following one:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要逐个文件地定义每个表应该是什么样子。我们将尽可能复制 [第 5 章](part0045_split_000.html#1AT9A1-edcc22b134104d5db0bf3aa086c86851
    "第 5 章。使用数据库") 中的数据结构，即 *使用数据库*。请记住，迁移文件可以在 `database/migrations` 目录中找到。我们可以编辑的第一个文件是
    `create_books_table.php`。用以下方法替换现有的空 `up` 方法：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The next one in the list is `create_sales_table.php`. Remember that this one
    has a foreign key pointing to the `users` table. You can use `references(field)->on(tablename)`
    to define this constraint.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的下一个是 `create_sales_table.php`。请记住，这个文件有一个外键指向 `users` 表。您可以使用 `references(field)->on(tablename)`
    来定义这个约束。
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `create_sales_books_table.php` file contains two foreign keys: one pointing
    to the ID of the sale, and one to the ID of the book. Replace the existing `up`
    method by the following one:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_sales_books_table.php` 文件包含两个外键：一个指向销售记录的ID，另一个指向书籍的ID。将现有的 `up` 方法替换为以下内容：'
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, edit the `create_borrowed_books_table.php` file, which has the `book_id`
    foreign key and the `start` and `end` timestamps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，编辑 `create_borrowed_books_table.php` 文件，该文件包含 `book_id` 外键以及 `start` 和 `end`
    时间戳：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The migration files are ready so we just need to migrate them in order to create
    the database tables. Run the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移文件已经准备好了，所以我们只需按顺序迁移它们以创建数据库表。运行以下命令：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Also, add some books to the database manually so that you can test later. For
    example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，手动添加一些书籍到数据库中，以便您可以稍后进行测试。例如：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Setting up the models
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置模型
- en: 'The next thing to do on the list is to add the relationships that our data
    has, that is, to translate the foreign keys from the database to the models. First
    of all, we need to create those models, and for that we just run the following
    commands:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的下一件事是添加我们的数据具有的关系，即从数据库将外键转换为模型。首先，我们需要创建这些模型，为此我们只需运行以下命令：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we have to go model by model, and add the one to one and one to many relationships
    as we did in the previous chapter. For `BookModel`, we will only specify that
    the model does not have timestamps, since they come by default. To do so, add
    the following highlighted line to your `app/Book.php` file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须逐个模型进行操作，并添加一对一和多对一关系，就像我们在上一章中做的那样。对于 `BookModel`，我们只需指定该模型没有时间戳，因为它们默认就有。为此，将以下高亮行添加到您的
    `app/Book.php` 文件中：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For the `BorrowedBook` model, we need to specify that it has one book, and
    it belongs to a user. We also need to specify the fields we will fill once we
    need to create the object—in this case, `book_id` and `start`. Add the following
    two methods in `app/BorrowedBook.php`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `BorrowedBook` 模型，我们需要指定它有一个书籍，并且属于一个用户。我们还需要指定在创建对象时需要填充的字段——在这种情况下，`book_id`
    和 `start`。在 `app/BorrowedBook.php` 中添加以下两个方法：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Sales can have many "sale books" (we know it might sound a little awkward),
    and they also belong to just one user. Add the following to your `app/Sale.php`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 销售记录可以有多个“销售书籍”（我们知道这可能听起来有点别扭），它们也只属于一个用户。将以下内容添加到您的 `app/Sale.php` 文件中：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Like borrowed books, sale books can have one book and belong to one sale instead
    of to one user. The following lines should be added to `app/SalesBook.php`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与借阅书籍一样，销售书籍可以有一个书籍和一个销售记录，而不是一个用户。以下行应添加到 `app/SalesBook.php` 文件中：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, the last model that we need to update is the `User` model. We need
    to add the opposite relationship to the `belongs` we used earlier in `Sale` and
    `BorrowedBook`. Add these two functions, and leave the rest of the class intact:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新的最后一个模型是 `User` 模型。我们需要添加与之前在 `Sale` 和 `BorrowedBook` 中使用的 `belongs`
    相反的关系。添加这两个函数，并保持类的其余部分不变：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Designing endpoints
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计端点
- en: 'In this section, we need to come up with the list of endpoints that we want
    to expose to the REST API clients. Keep in mind the "rules" explained in the *Best
    practices with REST APIs* section. In short, keep the following rules in mind:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们需要想出我们想要向REST API客户端公开的端点列表。请记住在“REST API最佳实践”部分中解释的“规则”。简而言之，请记住以下规则：
- en: One endpoint interacts with one resource
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个端点与一个资源交互
- en: A possible schema could be `<API version>/<resource name>/<optional id>/<optional
    action>`
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的架构可以是 `<API版本>/<资源名称>/<可选ID>/<可选操作>`
- en: Use GET parameters for filtering and pagination
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GET参数进行过滤和分页
- en: 'So what will the user need to do? We already have a good idea about that, since
    we created the UI. A brief summary would be as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，用户需要做什么呢？由于我们已经创建了UI，所以我们已经有了很好的想法。简要总结如下：
- en: List all the available books with some filtering (by title and author), and
    paginated when necessary. Also retrieve the information on a specific book, given
    the ID.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有可用的书籍，并按标题和作者进行过滤，必要时进行分页。也可以根据ID检索特定书籍的信息。
- en: Allow the user to borrow a specific book if available. In the same way, the
    user should be able to return books, and list the history of borrowed books too
    (filtered by date and paginated).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有可用，允许用户借阅特定的书籍。同样，用户应该能够归还书籍，并列出借阅书籍的历史记录（按日期过滤并分页）。
- en: Allow the user to buy a list of books. This could be improved, but for now let's
    force the user to buy books with just one request, including the full list of
    books in the body. Also, list the sales of the user following the same rules as
    that with borrowed books.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户购买一系列书籍。这可以改进，但现在让我们强制用户通过一个请求购买书籍，包括书籍的完整列表。同样，列出用户的销售记录也遵循与借阅书籍相同的规则。
- en: We will start straightaway with our list of endpoints, specifying the path,
    the HTTP method, and the optional parameters. It will also give you an idea on
    how to document your REST APIs.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将立即开始我们的端点列表，指定路径、HTTP方法和可选参数。它还将给你一个如何记录REST API的想法。
- en: GET `/books`
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET `/books`
- en: '`title`: Optional and filters by title'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`: 可选，按标题过滤'
- en: '`author`: Optional and filters by author'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`author`: 可选，按作者过滤'
- en: '`page`: Optional, default is 1, and specifies the page to return'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page`: 可选，默认为1，指定要返回的页面'
- en: '`page-size`: Optional, default is 50, and specifies the page size to return'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page-size`: 可选，默认为50，指定返回的页面大小'
- en: GET `/books/<book id>`
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET `/books/<book id>`
- en: POST `/borrowed-books`
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST `/borrowed-books`
- en: '`book-id`: Mandatory and specifies the ID of the book to borrow'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`book-id`: 必须指定，用于借阅书籍的ID'
- en: GET `/borrowed-books`
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET `/borrowed-books`
- en: '`from`: Optional and returns borrowed books from the specified date'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from`: 可选，从指定的日期返回借阅的书籍'
- en: '`page`: Optional, default is 1, and specifies the page to return'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page`: 可选，默认为1，指定要返回的页面'
- en: '`page-size`: Optional, default is 50, and specifies the number of borrowed
    books per page'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page-size`: 可选，默认为50，指定每页的借阅书籍数量'
- en: PUT `/borrowed-books/<borrowed book id>/return`
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PUT `/borrowed-books/<borrowed book id>/return`
- en: POST `/sales`
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST `/sales`
- en: '`books`: Mandatory and it is an array listing the book IDs to buy and their
    amounts, that is, *{"book-id-1": amount, "book-id-2": amount, ...}*'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`books`: 必须指定，它是一个数组，列出要购买的书籍ID及其数量，即*{"book-id-1": 数量, "book-id-2": 数量, ...}*'
- en: GET `/sales`
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET `/sales`
- en: '`from`: Optional and returns borrowed books from the specified date'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from`: 可选，从指定的日期返回借阅的书籍'
- en: '`page`: Optional, default is 1, and specifies the page to return'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page`: 可选，默认为1，指定要返回的页面'
- en: '`page-size`: Optional, default is 50, and specifies the number of sales per
    page'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`page-size`: 可选，默认为50，指定每页的销售数量'
- en: GET `/sales/<sales id>`
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET `/sales/<sales id>`
- en: 'We use POST requests when creating sales and borrowed books, since we do not
    know the ID of the resource that we want to create a priori, and posting the same
    request will create multiple resources. On the other hand, when returning a book,
    we do know the ID of the borrowed book, and sending the same request multiple
    times will leave the database in the same state. Let''s translate these endpoints
    to routes in `app/Http/routes.php`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建销售和借阅书籍时使用POST请求，因为我们事先不知道要创建的资源ID，发送相同的请求将创建多个资源。另一方面，在归还书籍时，我们知道借阅书籍的ID，发送相同的请求多次将使数据库保持相同的状态。让我们将这些端点翻译为`app/Http/routes.php`中的路由：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code, note how we added the middleware `oauth` to all the endpoints.
    This will require the user to provide a valid access token in order to access
    them.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，注意我们如何向所有端点添加了中间件`oauth`。这将要求用户提供有效的访问令牌才能访问它们。
- en: Adding the controllers
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加控制器
- en: 'From the previous section, you can imagine that we need to create three controllers:
    `BookController`, `BorrowedBookController`, and `SalesController`. Let''s start
    with the easiest one: returning the information of a book given the ID. Create
    the file `app/Http/Controllers/BookController.php`, and add the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的部分，你可以想象我们需要创建三个控制器：`BookController`、`BorrowedBookController`和`SalesController`。让我们从最简单的一个开始：根据ID返回书籍的信息。创建文件`app/Http/Controllers/BookController.php`，并添加以下代码：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Even though this preceding example is quite easy, it contains most of what we
    will need for the rest of the endpoints. We try to fetch a book given the ID from
    the URL, and when not found, we reply with a 404 (not found) empty response—the
    constant `Response::HTTP_NOT_FOUND` is 404\. In case we have the book, we return
    it as JSON with `response->json()`. Note how we add the seemingly unnecessary
    key `book`; it is true that we do not return anything else and, since we ask for
    the book, the user will know what we are talking about, but as it does not really
    hurt, it is good to be as explicit as possible.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的例子很简单，但它包含了我们接下来需要的大部分内容。我们尝试根据URL中的ID获取一本书，如果没有找到，我们回复一个404（未找到）的空响应——常量`Response::HTTP_NOT_FOUND`是404。如果我们有这本书，我们用`response->json()`将其作为JSON返回。注意我们添加了看似不必要的键`book`；确实我们没有返回其他任何内容，并且由于我们请求了书籍，用户会知道我们在说什么，但既然这并不会造成伤害，最好尽可能明确。
- en: 'Let''s test it! You already know how to get an access token—check the *Requesting
    an access token* section. So get one, and try to access the following URLs:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下！你已经知道如何获取访问令牌——查看“请求访问令牌”部分。所以获取一个，并尝试访问以下URL：
- en: '`http://localhost/books/0?access_token=12345`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost/books/0?access_token=12345`'
- en: '`http://localhost/books/1?access_token=12345`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost/books/1?access_token=12345`'
- en: 'Assuming that `12345` is your access token, that you have a book in the database
    with ID `1`, and you do not have a book with ID `0`, the first URL should return
    a 404 response, and the second one, a response something similar to the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`12345`是你的访问令牌，你有一个ID为`1`的书籍在数据库中，你没有ID为`0`的书籍，第一个URL应该返回一个404响应，第二个URL，返回的响应类似于以下内容：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s now add the method to get all the books with filters and pagination.
    It looks quite verbose, but the logic that we use is quite simple:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加一个方法来获取带有过滤器和分页的所有书籍。这看起来相当冗长，但我们使用的逻辑相当简单：
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We get all the parameters that can come from the request, and set the default
    values of each one in case the user does not include them (since they are optional).
    Then, we use the Eloquent ORM to filter by title and author using `where()`, and
    limiting the results with `take()->skip()`. We return the JSON in the same way
    we did with the previous method. In this one though, we do not need any extra
    check; if the query does not return any book, it is not really a problem.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取所有可能从请求中来的参数，并在用户没有包含它们的情况下设置每个参数的默认值（因为它们是可选的）。然后，我们使用Eloquent ORM通过`where()`过滤标题和作者，并使用`take()->skip()`限制结果。我们以与之前相同的方式返回JSON。不过，在这个方法中，我们不需要任何额外的检查；如果查询没有返回任何书籍，这并不是真正的问题。
- en: 'You can now play with your REST API, sending different requests with different
    filters. The following are some examples:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以玩转你的REST API了，发送带有不同过滤器的不同请求。以下是一些示例：
- en: '`http://localhost/books?access_token=12345`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost/books?access_token=12345`'
- en: '`http://localhost/books?access_token=12345&title=19&page-size=1`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost/books?access_token=12345&title=19&page-size=1`'
- en: '`http://localhost/books?access_token=12345&page=2`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost/books?access_token=12345&page=2`'
- en: 'The next controller in the list is `BorrowedBookController`. We need to add
    three methods: `borrow`, `get`, and `returnBook`. As you already know how to work
    with requests, responses, status codes, and the Eloquent ORM, we will write the
    entire class straightaway:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的下一个控制器是`BorrowedBookController`。我们需要添加三个方法：`borrow`、`get`和`returnBook`。既然你已经知道如何处理请求、响应、状态码和Eloquent
    ORM，我们将直接编写整个类：
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The only thing to note in the preceding code is how we also update the stock
    of the book by increasing or decreasing the stock, and invoke the `save` method
    to save the changes in the database. We also return the borrowed book object as
    the response when borrowing a book so that the user can know the borrowed book
    ID, and use it when querying or returning the book.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中需要注意的唯一一点是我们如何更新书籍的库存（增加或减少库存），并调用`save`方法来保存数据库中的更改。在借阅书籍时，我们还返回借阅的书籍对象作为响应，以便用户可以知道借阅的书籍ID，并在查询或归还书籍时使用它。
- en: 'You can test how this set of endpoints works with the following use cases:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下用例来测试这组端点的工作方式：
- en: Borrow a book. Check that you get a valid response.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 借一本书。确认你得到了有效的响应。
- en: Get the list of borrowed books. The one that you just created should be there
    with a valid starting date and an empty end date.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取借阅书籍的列表。你刚刚创建的书籍应该在那里，有一个有效的开始日期和一个空结束日期。
- en: Get the information of the book you borrowed. The stock should be one less.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取你借阅的书籍信息。库存应该少一本。
- en: Return the book. Fetch the list of borrowed books to check the end date and
    the returned book to check the stock.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归还书籍。获取借阅书籍列表以检查结束日期和归还的书籍以检查库存。
- en: Of course, you can always try to trick the API and ask for books without stock,
    non-existing borrowed books, and the like. All these edge cases should respond
    with the correct status codes and error messages.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你总是可以尝试欺骗API，请求没有库存的书、不存在的借阅书籍等。所有这些边缘情况都应该返回正确的状态码和错误信息。
- en: 'We finish this section, and the REST API, by creating the `SalesController`.
    This controller is the one that contains more logic, since creating a sale implies
    adding entries to the sales books table, prior to checking for enough stock for
    each one. Add the following code to `app/Html/SalesController.php`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建`SalesController`来完成本节和REST API。这个控制器包含更多的逻辑，因为创建销售意味着在检查每个书的库存是否足够之前，先向销售账本表添加条目。将以下代码添加到`app/Http/SalesController.php`：
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding code, note how we first check the availability of all the books
    before creating the sales entry. This way, we make sure that we do not leave any
    unfinished sale in the database when returning an error to the user. You could
    change this, and use transactions instead, and if a book is not valid, just roll
    back the transaction.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，注意我们首先检查所有书的可用性，然后再创建销售条目。这样，我们确保在向用户返回错误时，数据库中没有未完成的销售记录。你可以改变这一点，使用事务代替，如果一本书无效，只需回滚事务。
- en: 'In order to test this, we can follow similar steps as we did with borrowed
    books. Just remember that the `books` parameter, when posting a sale, is a JSON
    map; for example, `{"1": 2, "4": 1}` means that I am trying to buy two books with
    ID `1` and one book with ID `4`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '为了测试这一点，我们可以遵循与借阅书籍类似的步骤。记住，在发布销售时，`books`参数是一个JSON映射；例如，`{"1": 2, "4": 1}`表示我正在尝试购买ID为`1`的两本书和一本ID为`4`的书。'
- en: Testing your REST APIs
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的REST API
- en: You have already been testing your REST API after finishing each controller
    by making some request and expecting a response. As you might imagine, this can
    be handy sometimes, but it is for sure not the way to go. Testing should be automatic,
    and should cover as much as possible. We will have to think of a solution similar
    to unit testing.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在完成每个控制器后通过发起一些请求并期望得到响应来测试你的REST API。正如你可能想象的那样，这有时可能很有用，但肯定不是最佳做法。测试应该是自动化的，并且应该尽可能覆盖更多内容。我们必须考虑一个类似于单元测试的解决方案。
- en: In [Chapter 10](part0088_split_000.html#2JTHG2-edcc22b134104d5db0bf3aa086c86851
    "Chapter 10. Behavioral Testing"), *Behavioral Testing*, you will learn more methodologies
    and tools for testing an application end to end, and that will include REST APIs.
    However, due to the simplicity of our REST API, we can add some pretty good tests
    with what Laravel provides us as well. Actually, the idea is very similar to the
    tests that we wrote in [Chapter 8](part0071_split_000.html#23MNU1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 8. Using Existing PHP Frameworks"), *Using Existing PHP Frameworks*,
    where we made a request to some endpoint, and expected a response. The only difference
    will be in the kind of assertions that we use (which can check if a JSON response
    is OK), and the way we perform requests.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](part0088_split_000.html#2JTHG2-edcc22b134104d5db0bf3aa086c86851 "第10章。行为测试")中，*行为测试*，你将学习更多关于端到端测试应用程序的方法和工具，这包括REST
    API。然而，由于我们的REST API很简单，我们可以使用Laravel为我们提供的功能添加一些相当不错的测试。实际上，这个想法与我们在[第8章](part0071_split_000.html#23MNU1-edcc22b134104d5db0bf3aa086c86851
    "第8章。使用现有的PHP框架")中写的测试非常相似，*使用现有的PHP框架*，我们在某个端点发起请求，并期望得到响应。唯一的区别将是我们使用的断言类型（可以检查JSON响应是否正常），以及我们执行请求的方式。
- en: 'Let''s add some tests to the set of endpoints related to books. We need some
    books in the database in order to query them, so we will have to populate the
    database before each test, that is, use the `setUp` method. Remember that in order
    to leave the database clean of test data, we need to use the trait `DatabaseTransactions`.
    Add the following code to `tests/BooksTest.php`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在与书籍相关的端点集合中添加一些测试。我们需要在数据库中有一些书籍以便查询，因此我们将在每个测试之前填充数据库，即使用`setUp`方法。记住，为了在测试后保持数据库干净，我们需要使用`DatabaseTransactions`特质。将以下代码添加到`tests/BooksTest.php`：
- en: '[PRE49]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see in the preceding code, we add three books to the database, and
    to the class property `$books` too. We will need them when we want to assert that
    a response is valid. Also note the use of the `fresh` method; this method synchronizes
    the model that we have with the content in the database. We need to do this in
    order to get the ID inserted in the database, since we do not know it a priori.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中看到的，我们向数据库中添加了三本书，同时也添加到了类属性 `$books` 中。当我们想要断言一个响应是有效的时，我们将需要这些书。此外，请注意
    `fresh` 方法的使用；这个方法将我们拥有的模型与数据库中的内容同步。我们需要这样做是为了获取数据库中插入的 ID，因为我们事先并不知道它。
- en: 'There is another thing we need to do before we run each test: authenticating
    our client. We will need to make a POST request to the access token generation
    endpoint sending valid credentials, and storing the access token that we receive
    so that it can be used in the remaining requests. You are free to choose how to
    provide the credentials, since there are different ways to do it. In our case,
    we just provide the credentials of a client test that we know exists in the database,
    but you might prefer to insert that client into the database each time. Update
    the test with the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行每个测试之前，我们还需要做另一件事：验证我们的客户端。我们需要向访问令牌生成端点发送有效的凭据，并存储我们收到的访问令牌，以便可以在剩余的请求中使用它。您可以选择如何提供凭据，因为有不同的方法可以做到这一点。在我们的情况下，我们只是提供了一个已知存在于数据库中的客户端测试的凭据，但您可能更喜欢每次都将该客户端插入数据库。使用以下代码更新测试：
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding code, we use the `post` method in order to send a POST request.
    This method accepts a string with the endpoint, and an array with the parameters
    to be included. After making a request, Laravel saves the response object into
    the `$response` property. We can JSON-decode it, and extract the access token
    that we need.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `post` 方法来发送 POST 请求。此方法接受一个包含端点的字符串和一个包含要包含的参数的数组。在发出请求后，Laravel
    将响应对象保存到 `$response` 属性中。我们可以对其进行 JSON 解码，并提取所需的访问令牌。
- en: 'It is time to add some tests. Let''s start with an easy one: requesting a book
    given an ID. The ID is used to make the GET requests with the ID of the book (do
    not forget the access token), and check if the response matches the expected one.
    Remember that we have the `$books` array already, so it will be pretty easy to
    perform these checks.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加一些测试了。让我们从一个简单的测试开始：根据 ID 请求一本书。ID 用于使用书籍的 ID 进行 GET 请求（不要忘记访问令牌），并检查响应是否与预期的匹配。记住，我们已经有
    `$books` 数组了，所以执行这些检查将会非常简单。
- en: 'We will be using two assertions: `seeJson`, which compares the received JSON
    response with the one that we provide, and `assertResponseOk`, which you already
    know from previous tests—it just checks that the response has a 200 status code.
    Add this test to the class:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个断言：`seeJson`，它比较接收到的 JSON 响应与我们提供的响应，以及您已经从之前的测试中了解到的 `assertResponseOk`——它只是检查响应是否有
    200 状态码。将以下测试添加到类中：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We use the `get` method instead of `post`, since this is a GET request. Also
    note that we use the `getCredentials` helper, since we will have to use it in
    each test. To see another example, let''s add a test that checks the response
    when requesting the books that contain the given title:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `get` 方法而不是 `post`，因为这是一个 GET 请求。此外，请注意我们使用了 `getCredentials` 辅助函数，因为我们将在每个测试中使用它。为了查看另一个示例，让我们添加一个测试来检查请求包含给定标题的书籍时的响应：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The preceding test is pretty much the same as the previous one, isn't it? The
    only changes are the endpoint and the expected response. Well, the remaining tests
    will all follow the same pattern, since so far, we can only fetch books and filter
    them.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试几乎与之前的测试相同，不是吗？唯一的变化是端点和预期的响应。嗯，剩余的测试都将遵循相同的模式，因为到目前为止，我们只能获取书籍并对其进行筛选。
- en: To see something different, let's check how to test an endpoint that creates
    resources. There are different options, one of them being to first make the request,
    and then going to the database to check that the resource has been created. Another
    option, the one that we prefer, is to first send the request that creates the
    resource, and then, with the information in the response, send a request to fetch
    the newly created resource. This is preferable, since we are testing only the
    REST API, and we do not need to know the specific schema that the database is
    using. Also, if the REST API changes its database, the tests will keep passing—and
    they should—since we test through the interface only.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到一些不同之处，让我们来看看如何测试创建资源的端点。有几种不同的选择，其中之一是首先发出请求，然后去数据库检查资源是否已创建。另一个选择，我们更倾向于使用的方法，是首先发送创建资源的请求，然后，使用响应中的信息，发送一个请求来获取新创建的资源。这是更可取的，因为我们只测试REST
    API，我们不需要知道数据库使用的具体模式。此外，如果REST API更改其数据库，测试将保持通过——它们应该保持通过——因为我们只通过接口进行测试。
- en: 'One good example could be borrowing a book. The test should first send a POST
    in order to borrow the book, specifying the book ID, then extract the borrowed
    book ID from the response, and finally send a GET request asking for that borrowed
    book. To save time, you can add the following test to the already existing `tests/BooksTest.php`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子可能是借一本书。测试应该首先发送一个POST请求来借书，指定书籍ID，然后从响应中提取借出的书籍ID，最后发送一个GET请求请求那本借出的书。为了节省时间，你可以将以下测试添加到现有的`tests/BooksTest.php`中：
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the importance of REST APIs in the web world. Now
    you are able not only to use them, but also write your own REST APIs, which has
    turned you into a more resourceful developer. You can also integrate your applications
    with third-party APIs to give more features to your users, and for making your
    websites more interesting and useful.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了REST API在Web世界中的重要性。现在你不仅能够使用它们，还能够编写自己的REST API，这使得你成为一个更加多才多艺的开发者。你还可以将你的应用程序与第三方API集成，为用户提供更多功能，并使你的网站更加有趣和有用。
- en: 'In the next and last chapter, we will end this book discovering a type of testing
    other than unit testing: behavioral testing, which improves the quality and reliability
    of your web applications.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将通过发现一种除单元测试之外的其他测试类型来结束这本书：行为测试，这可以提高你Web应用程序的质量和可靠性。
