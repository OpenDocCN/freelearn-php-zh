- en: Status codes in responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If HTTP methods are very important for requests, status codes are almost indispensable
    for responses. With just one number, the client will know what happened with the
    request. This is especially useful when you know that status codes are a standard,
    and they are extensively documented on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: We've already described the most important ones in [Chapter 2](part0019_split_000.html#I3QM2-edcc22b134104d5db0bf3aa086c86851
    "Chapter 2. Web Applications with PHP"), *Web Applications with PHP*, but let's
    list them again, adding a few more that are important for REST APIs. For the full
    list of status codes, you can visit [https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html).
  prefs: []
  type: TYPE_NORMAL
- en: 2xx – success
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All the status codes that start with 2 are used for responses where the request
    was processed successfully, regardless of whether it was a GET or POST. Some of
    the most commonly used ones in this category are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**200 OK**: It is the generic "everything was OK" response. If you were asking
    for a resource, you will get it in the body of the response, and if you were updating
    a resource, this will mean that the new data has been successfully saved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**201 created**: It is the response used when resources are created successfully
    with POST or PUT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**202 accepted**: This response means that the request has been accepted, but
    it has not been processed yet. This might be useful when the client needs a straightforward
    response for a very heavy operation: the server sends the accepted response, and
    then starts processing it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3xx – redirection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even though you might think there is only one type of redirection, there are
    a few refinements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**301 moved permanently**: This means that the resource has been moved to a
    different URL, so from then on, you should try to access it through the URL provided
    in the body of the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**303 see other**: This means that the request has been processed but, in order
    to see the response, you need to access the URL provided in the body of the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4xx – client error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This category has status codes describing what went wrong due to the client''s
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '**400 bad request**: This is a generic response to a malformed request, that
    is, there is a syntax error in the endpoint, or some of the expected parameters
    were not provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**401 unauthorized**: This means the client has not been authenticated successfully
    yet, and the resource that it is trying to access needs this authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**403 forbidden**: This error message means that even though the client has
    been authenticated, it does not have enough permissions to access that resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**404 not found**: The specific resource has not been found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**405 method not allowed**: This means that the endpoint exists, but it does
    not accept the HTTP method used on the request, for example, we were trying to
    use PUT, but the endpoint only accepts POST requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5xx – server error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are up to 11 different errors on the server side, but we are only interested
    in one: the **500 internal server** error. You could use this status code when
    something unexpected, like a database error, happens while processing the request.'
  prefs: []
  type: TYPE_NORMAL
- en: REST API security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST APIs are a powerful tool since they allow developers to retrieve and/or
    update data from the server. But with great power comes great responsibility,
    and when designing a REST API, you should think about making your data as secure
    as possible. Imagine— anyone could post tweets on your behalf with a simple HTTP
    request!
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to using web applications, there are two concepts here: **authentication**
    and **authorization**. Authenticating someone is identifying who he or she is,
    that is, linking his or her request to a user in the database. On the other hand,
    authorizing someone is to allow that specific user to perform certain actions.
    You could think of authentication as the login of the user, and authorization
    as giving permissions.'
  prefs: []
  type: TYPE_NORMAL
- en: REST APIs need to manage these two concepts very carefully. Just because a developer
    has been authenticated does not mean he can access all the data on the server.
    Sometimes, users can access only their own data, whereas sometimes you would like
    to implement a roles system where each role has different access levels. It always
    depends on the type of application you are building.
  prefs: []
  type: TYPE_NORMAL
- en: Although authorization happens on the server side, that is, it's the server's
    database that will decide whether a given user can access a certain resource or
    not, authentications have to be triggered by the client. This means that the client
    has to know what authentication system the REST API is using in order to proceed
    with the authentication. Each REST API will implement its own authentication system,
    but there are some well known implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Basic access authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Basic access authentication—BA for short—is, as its name suggests, basic. The
    client adds the information about the user in the headers of each request, that
    is, username and password. The problem is that this information is only encoded
    using BASE64 but not encrypted, making it extremely easy for an intruder to decode
    the header and obtain the password in plain text. If you ever have to use it,
    since, to be honest, it is a very easy way of implementing some sort of authentication,
    we would recommend you to use it with HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use this method, you need to concatenate the username and password
    like `username:password`, encode the resultant string using Base64, and add the
    authorization header as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: OAuth 2.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If basic authentication was very simple, and insecure, OAuth 2.0 is the most
    secure system that REST APIs use in order to authenticate, and so was the previous
    OAuth 1.0\. There are actually different versions of this standard, but all of
    them work on the same foundation:'
  prefs: []
  type: TYPE_NORMAL
- en: There are no usernames and passwords. Instead, the provider of the REST API
    assigns a pair of credentials—a token and the secret—to the developer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to authenticate, the developer needs to send a POST request to the
    "token" endpoint, which is different in each REST API but has the same concept.
    This request has to include the encoded developer credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server replies to the previous request with a session token. This (and not
    the credentials mentioned in the first step) is to be included in each request
    that you make to the REST API. The session token expires for security reasons,
    so you will have to repeat the second step again when that happens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even though this standard is kind of recent (2012 onwards), several big companies
    like Google or Facebook have already implemented it for their REST APIs. It might
    look a bit overcomplicated, but you will soon get to use it, and even implement
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That was enough theory about REST APIs; it is time to dive into a real world
    example. In this section, we will write a small PHP application that interacts
    with Twitter's REST API; that includes requesting developer credentials, authenticating,
    and sending requests. The goal is to give you your first experience in working
    with REST APIs, and showing you that it is easier than you could expect. It will
    also help you to understand better how they work, so it will be easier to build
    your own later.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the application's credentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST APIs usually have the concept of application. An application is like an
    account on their development site that identifies who uses the API. The credentials
    that you will use to access the API will be linked to this application, which
    means that you can have multiple applications linked to the same account.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that you have a Twitter account, go to [https://apps.twitter.com](https://apps.twitter.com)
    in order to create a new application. Click on the **Create New App** button in
    order to access the form for application details. The fields are very self-explanatory—just
    a name for the application, the description, and the website URL. The callback
    URL is not necessary here, since that will be used only for applications that
    require access to someone else's account. Agree with the terms and conditions
    in order to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have been redirected to your application''s page, you will see all
    sort of information that you can edit. Since this is just an example, let''s go
    straight to what matters: the credentials. Click on the **Keys and Access Tokens**
    tab to see the values of **Consumer key (API key)** and **Consumer Secret (API
    secret)**. There is nothing else that we need from here. You can save them on
    your filesystem, as `~/.twitter_php7.json`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Securing your credentials**'
  prefs: []
  type: TYPE_NORMAL
- en: Securing your REST API credentials should be taken seriously. In fact, you should
    take care of all kinds of credentials, like the database ones. But the difference
    is that you will usually host your database in your server, which makes things
    slightly more difficult to whoever wants to attack. On the other hand, the third-party
    REST API is not part of your system, and someone with your credentials can use
    your account freely on your behalf.
  prefs: []
  type: TYPE_NORMAL
- en: Never include your credentials in your code base, especially if you have your
    code in GitHub or some other repository. One solution would be to have a file
    in your server, outside your code, with the credentials; if that file is encrypted,
    that is even better. And try to refresh your credentials regularly, which you
    can probably do on the provider's website.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our application will be extremely simple. It will consist of one class that
    will allow us to fetch tweets. This will be managed by our `app.php` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have to make HTTP requests, we can either write our own functions that
    use **cURL** (a set of PHP native functions), or make use of the famous PHP library,
    **Guzzle**. This library can be found in **Packagist**, so we will use Composer
    to include it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have a `Twitter` class, which will get the credentials from the constructor,
    and one public method: `fetchTwits`. For now, just create the skeleton so that
    we can work with it; we will implement such methods in later sections. Add the
    following code to `src/Twitter.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since we set the namespace `TwitterApp`, we need to update our `composer.json`
    file with the following addition. Remember to run `composer update` to update
    the autoloader.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will create a basic `app.php` file, which includes the Composer
    autoloader, reads the credentials file, and creates a Twitter instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Requesting an access token
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a real world application, you would probably want to separate the code related
    to authentication from the one that deals with operations like fetching or posting
    data. To keep things simple here, we will let the `Twitter` class know how to
    authenticate by itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding a `$client` property to the class which will contain
    an instance of Guzzle''s `Client` class. This instance will contain the base URI
    of the Twitter API, which we can have as the constant `TWITTER_API_BASE_URI`.
    Instantiate this property in the constructor so that the rest of the methods can
    make use of it. You can also add an `$accessToken` property which will contain
    the access token returned by the Twitter API when authenticating. All these changes
    are highlighted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step would be to write a method that, given the key and secret are
    provided, requests an access token to the provider. More specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: Concatenate the key and the secret with a `:`. Encode the result using Base64.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send a POST request to `/oauth2/token` with the encoded credentials as the `Authorization`
    header. Also include a `Content-Type` header and a body (check the code for more
    information).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We now invoke the `post` method of Guzzle''s `client` instance sending two
    arguments: the endpoint string (`/oauth2/token`) and an array with options. These
    options include the headers and the body of the request, as you will see shortly.
    The response of this invocation is an object that identifies the HTTP response.
    You can extract the content (body) of the response with `getBody`. Twitter''s
    API response is a JSON with some arguments. The one that you care about the most
    is the `access_token`, the token that you will need to include in each subsequent
    request to the API. Extract it and save it. The full method looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can already try this code by adding these two lines at the end of the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Run the application in order to see the access token given by the provider using
    the following command. Remember to remove the preceding two lines in order to
    proceed with the section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that, even though having a key and secret and getting an access
    token is the same across all OAuth authentications, the specific way of encoding,
    the endpoint used, and the response received from the provider are exclusive from
    Twitter's API. It could be that several others are exactly the same, but always
    check the documentation for each one.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching tweets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We finally arrive to the section where we actually make use of the API. We
    will implement the `fetchTwits` method in order to get a list of the last *N*
    number of tweets for a given user. In order to perform requests, we need to add
    the `Authorization` header to each one, this time with the access token. Since
    we want to make this class as reusable as possible, let''s extract this to a private
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the preceding method also allows us to fetch the access token
    from the provider. This is useful, since if we make more than one request, we
    will just request the access token once, and we have one unique place to do so.
    Add now the following method implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first part of the preceding method builds the `options` array with the access
    token headers and the query string arguments—in this case, with the number of
    tweets to retrieve and the user. We perform the GET request and decode the JSON
    response into an array. This array contains a lot of information that we might
    not need, so we iterate it in order to extract those fields that we really want—in
    this example, the date, the text, and the user.
  prefs: []
  type: TYPE_NORMAL
- en: In order to test the application, just invoke the `fetchTwits` method at the
    end of the `app.php` file, specifying the Twitter ID of one of the people you
    are following, or yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get a response similar to ours, shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fetching tweets](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'One thing to keep in mind is that access tokens expire after some time, returning
    an HTTP response with a 4xx status code (usually, 401 unauthorized). Guzzle throws
    an exception when the status code is either 4xx or 5xx, so it is easy manage these
    scenarios. You could add this code when performing the GET request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The toolkit of the REST API developer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you are developing your own REST API, or writing an integration for a
    third-party one, you might want to test it before you start writing your code.
    There are a handful of tools that will help you with this task, whether you want
    to use your browser, or you are a fan of the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Testing APIs with browsers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are actually several add-ons that allow you to perform HTTP requests
    from browsers, depending on which one you use. Some famous names are *Advanced
    Rest Client* for Chrome and *RESTClient* for Firefox. At the end of the day, all
    those clients allow you to perform the same HTTP requests, where you can specify
    the URL, the method, the headers, the body, and so on. These clients will also
    show you all the details you can imagine from the response, including the status
    code, the time spent, and the body. The following screenshot displays an example
    of a request using Chrome''s *Advanced Rest Client*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing APIs with browsers](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to test GET requests with your own API, and all that you need is
    the URL, that is, you do not need to send any headers, you can just use your browser
    as if you were trying to access any other website. If you do so, and if you are
    working with JSON responses, you can install another add-on to your browser that
    will help you in viewing your JSON in a more "beautiful" way. Look for *JSONView*
    on any browser for a really handy one.
  prefs: []
  type: TYPE_NORMAL
- en: Testing APIs using the command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some people feel more comfortable using the command line; so luckily, for them
    there are tools that allow them to perform any HTTP request from their consoles.
    We will give a brief introduction to one of the most famous ones: cURL. This tool
    has quite a lot of features, but we will focus only on the ones that you will
    be using more often: the HTTP method, post parameters, and headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-X <method>`: This specifies the HTTP method to use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--data`: This adds the parameters specified, which can be added as key-value
    pairs, JSON, plain text, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--header`: This adds a header to the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of the way to send a POST request with cURL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using a Unix system, you will probably be able to format the resulting
    JSON by appending `| python -m json.tool` so that it gets easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: cURL is quite a powerful tool that lets you do quite a few tricks. If you are
    interested, go ahead and check the documentation or some tutorial on how to use
    all its features.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices with REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already gone through some of the best practices when writing REST APIs,
    like using HTTP methods properly, or choosing the correct status code for your
    responses. We also described two of the most used authentication systems. But
    there is still a lot to learn about creating proper REST APIs. Remember that they
    are meant to be used by developers like yourself, so they will always be grateful
    if you do things properly, and make their lives easier. Ready?
  prefs: []
  type: TYPE_NORMAL
- en: Consistency in your endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When deciding how to name your endpoints, try keeping them consistent. Even
    though you are free to choose, there is a set of spoken rules that will make your
    endpoints more intuitive and easy to understand. Let''s list some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: For starters, an endpoint should point to a specific resource (for example,
    books or tweets), and you should make that clear in your endpoint. If you have
    an endpoint that returns the list of all books, do not name it `/library`, as
    it is not obvious what it will be returning. Instead, name it `/books` or `/books/all`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the resource can be either plural or singular, but make it consistent.
    If sometimes you use `/books` and sometimes `/user`, it might be confusing, and
    people will probably make mistakes. We personally prefer to use the plural form,
    but that is totally up to you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to retrieve a specific resource, do it by specifying the ID whenever
    possible. IDs must be unique in your system, and any other parameter might point
    to two different entities. Specify the ID next to the name of the resource, such
    as `/books/249234-234-23-42`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you can understand what an endpoint does by just the HTTP method, there is
    no need to add this information as part of the endpoint. For example, if you want
    to get a book, or you want to delete it, `/books/249234-234-23-42` along with
    the HTTP methods GET and DELETE are more than enough. If it is not obvious, state
    it as a verb at the end of the endpoint, like `/employee/9218379182/promote`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document as much as you can
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The title says everything. You are probably not going to be the one using the
    REST API, others will. Obviously, even if you design a very intuitive set of endpoints,
    developers will still need to know the whole set of available endpoints, what
    each of them does, what optional parameters are available, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Write as much documentation as possible, and keep it up to date. Take a look
    at other documented APIs to gather ideas on how to display the information. There
    are plenty of templates and tools that will help you deliver a well-presented
    documentation, but you are the one that has to be consistent and methodical. Developers
    have a special hate towards documenting anything, but we also like to find clear
    and beautifully presented documentation when we need to use someone else's APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Filters and pagination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the common usages of an API is to list resources and filter them by some
    criteria. We already saw an example when we were building our own bookstore; we
    wanted to get the list of books that contained a certain string in their titles
    or authors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some developers try to have beautiful endpoints, which a priori is a good thing
    to do. Imagine that you want to filter just by title, you might end up having
    an endpoint like `/books/title/<string>`. We add also the ability to filter by
    author, and we now get two more endpoints: `/books/title/<string>/author/<string>`
    and `/books/author/<string>`. Now let''s add the description too—do you see where
    we are going?'
  prefs: []
  type: TYPE_NORMAL
- en: Even though some developers do not like to use query strings as arguments, there
    is nothing wrong with it. In fact, if you use them properly, you will end up with
    cleaner endpoints. You want to get books? Fine, just use `/books`, and add whichever
    filter you need using the query string.
  prefs: []
  type: TYPE_NORMAL
- en: Pagination occurs when you have way too many resources of the same type to retrieve
    all at once. You should think of pagination as another optional filter to be specified
    as a GET parameter. You should have pages with a default size, let's say 10 books,
    but it is a good idea to give the developers the ability to define their own size.
    In this case, developers can specify the length and the number of pages to retrieve.
  prefs: []
  type: TYPE_NORMAL
- en: API versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your API is a reflection of what your application can do. Chances are that your
    code will evolve, improving the already existing features or adding new ones.
    Your API should be updated too, exposing those new features, updating existing
    endpoints, or even removing some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine now that someone else is using your REST API, and their whole website
    relies on it. If you change your existing endpoints, their website will stop working!
    They will not be happy at all, and will try to find someone else that can do what
    you were doing. Not a good scenario, but then, how do you improve your API?
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to use versioning. When you release a new version of the API,
    do not nuke down the existing one; you should give some time to the users to upgrade
    their integrations. And how can two different versions of the API coexist? You
    already saw one of the options—the one that we recommend you: by specifying the
    version of the API to use as part of the endpoint. Do you remember the endpoint
    of the Twitter API `/1.1/statuses/user_timeline.json`? The `1.1` refers to the
    version that we want to use.'
  prefs: []
  type: TYPE_NORMAL
- en: Using HTTP cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the main feature of REST APIs is that they make heavy use of HTTP, why not
    take advantage of HTTP cache? Well, there are actual reasons for not using it,
    but most of them are due to a lack of knowledge about using it properly. It is
    out of the scope of this book to explain every single detail of its implementation,
    but let's try to give a short introduction to the topic. Plenty of resources on
    the Internet can help you to understand the parts that you are more interested
    in.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP responses can be divided as public and private. Public responses are shared
    between all users of the API, whereas the private ones are meant to be unique
    for each user. You can specify which type of response is yours using the `Cache-Control`
    header, allowing the response to be cached if the method of the request was a
    GET. This header can also expose the expiration of the cache, that is, you can
    specify the duration for which your response will remain the same, and thus, can
    be cached.
  prefs: []
  type: TYPE_NORMAL
- en: Other systems rely on generating a hash of the representation of a resource,
    and add it as the `ETag` (Entity tag) header in order to know if the resource
    has changed or not. In a similar way, you can set the `Last-Modified` header to
    let the client know when was the last time that the given resource changed. The
    idea behind those systems is to identify when the client already contains valid
    data. If so, the provider does not process the request, but returns an empty response
    with the status code 304 (not modified) instead. When the client gets that response,
    it uses its cached content.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a REST API with Laravel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build a REST API with Laravel from scratch. This REST
    API will allow you to manage different clients at your bookstore, not only via
    the browser, but via the UI as well. You will be able to perform pretty much the
    same actions as before, that is, listing books, buying them, borrowing for free,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Once the REST API is done, you should remove all the business logic from the
    bookstore that you built during the previous chapters. The reason is that you
    should have one unique place where you can actually manipulate your databases
    and the REST API, and the rest of the applications, like the web one, should able
    to communicate with the REST API for managing data. In doing so, you will be able
    to create other applications for different platforms, like mobile apps, that will
    use the REST API too, and both the website and the mobile app will always be synchronized,
    since they will be using the same sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with our previous Laravel example, in order to create a new project, you
    just need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Setting OAuth2 authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing that we are going to implement is the authentication layer.
    We will use OAuth2 in order to make our application more secure than basic authentication.
    Laravel does not provide support for OAuth2 out of the box, but there is a service
    provider which does that for us.
  prefs: []
  type: TYPE_NORMAL
- en: Installing OAuth2Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install OAuth2, add it as a dependency to your project using Composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This service provider needs quite a few changes. We will go through them without
    going into too much detail on how things work exactly. If you are more interested
    in the topic, or if you want to create your own service providers for Laravel,
    we recommend you to go though the extensive official documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we need to add the new OAuth2Server service provider to the
    array of providers in the `config/app.php` file. Add the following lines at the
    end of the `providers` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, you need to add a new alias to the `aliases` array in the
    same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move to the `app/Http/Kernel.php` file, where we need to make some changes
    too. Add the following entry to the `$middleware` array property of the `Kernel`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following key-value pairs to the `$routeMiddleware` array property
    of the same class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We added a CSRF token verifier to the `$routeMiddleware`, so we need to remove
    the one already defined in `$middlewareGroups`, since they are incompatible. Use
    the following line to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's set up the database now. In this section, we will assume that you already
    have the bookstore database in your environment. If you do not have it, go back
    to [Chapter 5](part0045_split_000.html#1AT9A1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 5. Using Databases"), *Using Databases*, to create it in order to proceed
    with this setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is to update the database credentials in the `.env` file.
    They should look something similar to the following lines, but with your username
    and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to prepare the configuration and database migration files from the
    OAuth2Server service provider, we need to publish it. In Laravel, you do it by
    executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `database/migrations` directory contains all the necessary migration
    files that will create the necessary tables related to OAuth2 in our database.
    To execute them, we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add at least one client to the `oauth_clients` table, which is the
    table that stores the key and secrets for all clients that want to connect to
    our REST API. This new client will be the one that you will use during the development
    process in order to test what you have done. We can set a random ID—the key—and
    the secret as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Enabling client-credentials authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since we published the plugins in `vendor` in the previous step, now we have
    the configuration files for the OAuth2Server. This plugin allows us different
    authentication systems (all of them with OAuth2), depending on our necessities.
    The one that we are interested in for our project is the `client_credentials`
    type. To let Laravel know, add the following lines at the end of the array in
    the `config/oauth2.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These preceding lines grant access to the `client_credentials` type, which are
    managed by the `ClientCredentialsGrant` class. The `access_token_ttl` value refers
    to the time period of the access token, that is, for how long someone can use
    it. In this case, it is set to 1 hour, that is, 3,600 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to enable a route so we can post our credentials in exchange
    for an access token. Add the following route to the routes file in `app/Http/routes.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Requesting an access token
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is time to test what we have done so far. To do so, we need to send a POST
    request to the `/oauth/access_token` endpoint that we enabled just now. This request
    needs the following POST parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`client_id` with the key from the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`client_secret` with the secret from the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grant_type` to specify the type of authentication that we are trying to perform,
    in this case `client_credentials`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The request issued using the *Advanced REST Client* add-on from Chrome looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Requesting an access token](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The response that you should get should have the same format as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this is a different way of requesting for an access token than what
    the Twitter API does, but the idea is still the same: given a key and a secret,
    the provider gives us an access token that will allow us to use the API for some
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though we''ve already done the same in the previous chapter, you might
    think: "Why do we start by preparing the database?". We could argue that you first
    need to know the kind of endpoints you want to expose in your REST API, and only
    then you can start thinking about what your database should look like. But you
    could also think that, since we are working with an API, each endpoint should
    manage one resource, so first you need to define the resources you are dealing
    with. This *code first versus database/model first* is an ongoing war on the Internet.
    But whichever way you think is better, the fact is that we already know what the
    users will need to do with our REST API, since we already built the UI previously;
    so it does not really matter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create four tables: `books`, `sales`, `sales_books`, and `borrowed_books`.
    Remember that Laravel already provides a `users` table, which we can use as our
    customers. Run the following four commands to create the migrations files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have to go file by file to define what each table should look like.
    We will try to replicate the data structure from [Chapter 5](part0045_split_000.html#1AT9A1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 5. Using Databases"), *Using Databases*, as much as possible. Remember
    that the migration files can be found inside the `database/migrations` directory.
    The first file that we can edit is the `create_books_table.php`. Replace the existing
    empty `up` method by the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The next one in the list is `create_sales_table.php`. Remember that this one
    has a foreign key pointing to the `users` table. You can use `references(field)->on(tablename)`
    to define this constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `create_sales_books_table.php` file contains two foreign keys: one pointing
    to the ID of the sale, and one to the ID of the book. Replace the existing `up`
    method by the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, edit the `create_borrowed_books_table.php` file, which has the `book_id`
    foreign key and the `start` and `end` timestamps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The migration files are ready so we just need to migrate them in order to create
    the database tables. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add some books to the database manually so that you can test later. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next thing to do on the list is to add the relationships that our data
    has, that is, to translate the foreign keys from the database to the models. First
    of all, we need to create those models, and for that we just run the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have to go model by model, and add the one to one and one to many relationships
    as we did in the previous chapter. For `BookModel`, we will only specify that
    the model does not have timestamps, since they come by default. To do so, add
    the following highlighted line to your `app/Book.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `BorrowedBook` model, we need to specify that it has one book, and
    it belongs to a user. We also need to specify the fields we will fill once we
    need to create the object—in this case, `book_id` and `start`. Add the following
    two methods in `app/BorrowedBook.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Sales can have many "sale books" (we know it might sound a little awkward),
    and they also belong to just one user. Add the following to your `app/Sale.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Like borrowed books, sale books can have one book and belong to one sale instead
    of to one user. The following lines should be added to `app/SalesBook.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the last model that we need to update is the `User` model. We need
    to add the opposite relationship to the `belongs` we used earlier in `Sale` and
    `BorrowedBook`. Add these two functions, and leave the rest of the class intact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Designing endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we need to come up with the list of endpoints that we want
    to expose to the REST API clients. Keep in mind the "rules" explained in the *Best
    practices with REST APIs* section. In short, keep the following rules in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: One endpoint interacts with one resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A possible schema could be `<API version>/<resource name>/<optional id>/<optional
    action>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use GET parameters for filtering and pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So what will the user need to do? We already have a good idea about that, since
    we created the UI. A brief summary would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: List all the available books with some filtering (by title and author), and
    paginated when necessary. Also retrieve the information on a specific book, given
    the ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the user to borrow a specific book if available. In the same way, the
    user should be able to return books, and list the history of borrowed books too
    (filtered by date and paginated).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the user to buy a list of books. This could be improved, but for now let's
    force the user to buy books with just one request, including the full list of
    books in the body. Also, list the sales of the user following the same rules as
    that with borrowed books.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start straightaway with our list of endpoints, specifying the path,
    the HTTP method, and the optional parameters. It will also give you an idea on
    how to document your REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: GET `/books`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: Optional and filters by title'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author`: Optional and filters by author'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page`: Optional, default is 1, and specifies the page to return'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page-size`: Optional, default is 50, and specifies the page size to return'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: GET `/books/<book id>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POST `/borrowed-books`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`book-id`: Mandatory and specifies the ID of the book to borrow'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: GET `/borrowed-books`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from`: Optional and returns borrowed books from the specified date'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page`: Optional, default is 1, and specifies the page to return'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page-size`: Optional, default is 50, and specifies the number of borrowed
    books per page'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: PUT `/borrowed-books/<borrowed book id>/return`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POST `/sales`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`books`: Mandatory and it is an array listing the book IDs to buy and their
    amounts, that is, *{"book-id-1": amount, "book-id-2": amount, ...}*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: GET `/sales`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from`: Optional and returns borrowed books from the specified date'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page`: Optional, default is 1, and specifies the page to return'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page-size`: Optional, default is 50, and specifies the number of sales per
    page'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: GET `/sales/<sales id>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use POST requests when creating sales and borrowed books, since we do not
    know the ID of the resource that we want to create a priori, and posting the same
    request will create multiple resources. On the other hand, when returning a book,
    we do know the ID of the borrowed book, and sending the same request multiple
    times will leave the database in the same state. Let''s translate these endpoints
    to routes in `app/Http/routes.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, note how we added the middleware `oauth` to all the endpoints.
    This will require the user to provide a valid access token in order to access
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the previous section, you can imagine that we need to create three controllers:
    `BookController`, `BorrowedBookController`, and `SalesController`. Let''s start
    with the easiest one: returning the information of a book given the ID. Create
    the file `app/Http/Controllers/BookController.php`, and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Even though this preceding example is quite easy, it contains most of what we
    will need for the rest of the endpoints. We try to fetch a book given the ID from
    the URL, and when not found, we reply with a 404 (not found) empty response—the
    constant `Response::HTTP_NOT_FOUND` is 404\. In case we have the book, we return
    it as JSON with `response->json()`. Note how we add the seemingly unnecessary
    key `book`; it is true that we do not return anything else and, since we ask for
    the book, the user will know what we are talking about, but as it does not really
    hurt, it is good to be as explicit as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test it! You already know how to get an access token—check the *Requesting
    an access token* section. So get one, and try to access the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost/books/0?access_token=12345`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost/books/1?access_token=12345`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assuming that `12345` is your access token, that you have a book in the database
    with ID `1`, and you do not have a book with ID `0`, the first URL should return
    a 404 response, and the second one, a response something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now add the method to get all the books with filters and pagination.
    It looks quite verbose, but the logic that we use is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We get all the parameters that can come from the request, and set the default
    values of each one in case the user does not include them (since they are optional).
    Then, we use the Eloquent ORM to filter by title and author using `where()`, and
    limiting the results with `take()->skip()`. We return the JSON in the same way
    we did with the previous method. In this one though, we do not need any extra
    check; if the query does not return any book, it is not really a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now play with your REST API, sending different requests with different
    filters. The following are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost/books?access_token=12345`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost/books?access_token=12345&title=19&page-size=1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost/books?access_token=12345&page=2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next controller in the list is `BorrowedBookController`. We need to add
    three methods: `borrow`, `get`, and `returnBook`. As you already know how to work
    with requests, responses, status codes, and the Eloquent ORM, we will write the
    entire class straightaway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The only thing to note in the preceding code is how we also update the stock
    of the book by increasing or decreasing the stock, and invoke the `save` method
    to save the changes in the database. We also return the borrowed book object as
    the response when borrowing a book so that the user can know the borrowed book
    ID, and use it when querying or returning the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test how this set of endpoints works with the following use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Borrow a book. Check that you get a valid response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the list of borrowed books. The one that you just created should be there
    with a valid starting date and an empty end date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the information of the book you borrowed. The stock should be one less.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the book. Fetch the list of borrowed books to check the end date and
    the returned book to check the stock.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, you can always try to trick the API and ask for books without stock,
    non-existing borrowed books, and the like. All these edge cases should respond
    with the correct status codes and error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'We finish this section, and the REST API, by creating the `SalesController`.
    This controller is the one that contains more logic, since creating a sale implies
    adding entries to the sales books table, prior to checking for enough stock for
    each one. Add the following code to `app/Html/SalesController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, note how we first check the availability of all the books
    before creating the sales entry. This way, we make sure that we do not leave any
    unfinished sale in the database when returning an error to the user. You could
    change this, and use transactions instead, and if a book is not valid, just roll
    back the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to test this, we can follow similar steps as we did with borrowed
    books. Just remember that the `books` parameter, when posting a sale, is a JSON
    map; for example, `{"1": 2, "4": 1}` means that I am trying to buy two books with
    ID `1` and one book with ID `4`.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing your REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have already been testing your REST API after finishing each controller
    by making some request and expecting a response. As you might imagine, this can
    be handy sometimes, but it is for sure not the way to go. Testing should be automatic,
    and should cover as much as possible. We will have to think of a solution similar
    to unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](part0088_split_000.html#2JTHG2-edcc22b134104d5db0bf3aa086c86851
    "Chapter 10. Behavioral Testing"), *Behavioral Testing*, you will learn more methodologies
    and tools for testing an application end to end, and that will include REST APIs.
    However, due to the simplicity of our REST API, we can add some pretty good tests
    with what Laravel provides us as well. Actually, the idea is very similar to the
    tests that we wrote in [Chapter 8](part0071_split_000.html#23MNU1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 8. Using Existing PHP Frameworks"), *Using Existing PHP Frameworks*,
    where we made a request to some endpoint, and expected a response. The only difference
    will be in the kind of assertions that we use (which can check if a JSON response
    is OK), and the way we perform requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some tests to the set of endpoints related to books. We need some
    books in the database in order to query them, so we will have to populate the
    database before each test, that is, use the `setUp` method. Remember that in order
    to leave the database clean of test data, we need to use the trait `DatabaseTransactions`.
    Add the following code to `tests/BooksTest.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we add three books to the database, and
    to the class property `$books` too. We will need them when we want to assert that
    a response is valid. Also note the use of the `fresh` method; this method synchronizes
    the model that we have with the content in the database. We need to do this in
    order to get the ID inserted in the database, since we do not know it a priori.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another thing we need to do before we run each test: authenticating
    our client. We will need to make a POST request to the access token generation
    endpoint sending valid credentials, and storing the access token that we receive
    so that it can be used in the remaining requests. You are free to choose how to
    provide the credentials, since there are different ways to do it. In our case,
    we just provide the credentials of a client test that we know exists in the database,
    but you might prefer to insert that client into the database each time. Update
    the test with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the `post` method in order to send a POST request.
    This method accepts a string with the endpoint, and an array with the parameters
    to be included. After making a request, Laravel saves the response object into
    the `$response` property. We can JSON-decode it, and extract the access token
    that we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to add some tests. Let''s start with an easy one: requesting a book
    given an ID. The ID is used to make the GET requests with the ID of the book (do
    not forget the access token), and check if the response matches the expected one.
    Remember that we have the `$books` array already, so it will be pretty easy to
    perform these checks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using two assertions: `seeJson`, which compares the received JSON
    response with the one that we provide, and `assertResponseOk`, which you already
    know from previous tests—it just checks that the response has a 200 status code.
    Add this test to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `get` method instead of `post`, since this is a GET request. Also
    note that we use the `getCredentials` helper, since we will have to use it in
    each test. To see another example, let''s add a test that checks the response
    when requesting the books that contain the given title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The preceding test is pretty much the same as the previous one, isn't it? The
    only changes are the endpoint and the expected response. Well, the remaining tests
    will all follow the same pattern, since so far, we can only fetch books and filter
    them.
  prefs: []
  type: TYPE_NORMAL
- en: To see something different, let's check how to test an endpoint that creates
    resources. There are different options, one of them being to first make the request,
    and then going to the database to check that the resource has been created. Another
    option, the one that we prefer, is to first send the request that creates the
    resource, and then, with the information in the response, send a request to fetch
    the newly created resource. This is preferable, since we are testing only the
    REST API, and we do not need to know the specific schema that the database is
    using. Also, if the REST API changes its database, the tests will keep passing—and
    they should—since we test through the interface only.
  prefs: []
  type: TYPE_NORMAL
- en: 'One good example could be borrowing a book. The test should first send a POST
    in order to borrow the book, specifying the book ID, then extract the borrowed
    book ID from the response, and finally send a GET request asking for that borrowed
    book. To save time, you can add the following test to the already existing `tests/BooksTest.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the importance of REST APIs in the web world. Now
    you are able not only to use them, but also write your own REST APIs, which has
    turned you into a more resourceful developer. You can also integrate your applications
    with third-party APIs to give more features to your users, and for making your
    websites more interesting and useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next and last chapter, we will end this book discovering a type of testing
    other than unit testing: behavioral testing, which improves the quality and reliability
    of your web applications.'
  prefs: []
  type: TYPE_NORMAL
