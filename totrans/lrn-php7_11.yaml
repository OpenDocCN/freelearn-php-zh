- en: Status codes in responses
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应中的状态码
- en: If HTTP methods are very important for requests, status codes are almost indispensable
    for responses. With just one number, the client will know what happened with the
    request. This is especially useful when you know that status codes are a standard,
    and they are extensively documented on the Internet.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTTP方法对于请求非常重要，状态码对于响应几乎是不可或缺的。仅仅一个数字，客户端就能知道请求发生了什么。这在你知道状态码是一个标准，并且在互联网上有广泛的文档记录时特别有用。
- en: We've already described the most important ones in [Chapter 2](part0019_split_000.html#I3QM2-edcc22b134104d5db0bf3aa086c86851
    "Chapter 2. Web Applications with PHP"), *Web Applications with PHP*, but let's
    list them again, adding a few more that are important for REST APIs. For the full
    list of status codes, you can visit [https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第2章](part0019_split_000.html#I3QM2-edcc22b134104d5db0bf3aa086c86851 "第2章。使用PHP的Web应用")中描述了最重要的状态码，*使用PHP的Web应用*，但让我们再次列出它们，并添加一些对REST
    API很重要的状态码。要查看状态码的完整列表，您可以访问[https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。
- en: 2xx – success
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2xx – 成功
- en: 'All the status codes that start with 2 are used for responses where the request
    was processed successfully, regardless of whether it was a GET or POST. Some of
    the most commonly used ones in this category are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有以2开头的状态码都用于请求处理成功的响应，无论它是GET还是POST。以下是一些这个类别中最常用的状态码：
- en: '**200 OK**: It is the generic "everything was OK" response. If you were asking
    for a resource, you will get it in the body of the response, and if you were updating
    a resource, this will mean that the new data has been successfully saved.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**200 OK**：这是通用的“一切正常”响应。如果你请求一个资源，你将在响应体中获取它，如果你更新一个资源，这将意味着新数据已成功保存。'
- en: '**201 created**: It is the response used when resources are created successfully
    with POST or PUT.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**201 created**：这是在POST或PUT操作成功创建资源时使用的响应。'
- en: '**202 accepted**: This response means that the request has been accepted, but
    it has not been processed yet. This might be useful when the client needs a straightforward
    response for a very heavy operation: the server sends the accepted response, and
    then starts processing it.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**202 accepted**：这个响应意味着请求已被接受，但尚未处理。当客户端需要一个简单的响应来处理一个非常重的操作时，这可能很有用：服务器发送接受的响应，然后开始处理它。'
- en: 3xx – redirection
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3xx – 重定向
- en: 'Even though you might think there is only one type of redirection, there are
    a few refinements:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你可能认为只有一种重定向类型，但实际上还有一些细微的差别：
- en: '**301 moved permanently**: This means that the resource has been moved to a
    different URL, so from then on, you should try to access it through the URL provided
    in the body of the response.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**301 moved permanently**：这意味着资源已经被移动到不同的URL，因此从那时起，你应该尝试通过响应正文中提供的URL来访问它。'
- en: '**303 see other**: This means that the request has been processed but, in order
    to see the response, you need to access the URL provided in the body of the response.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**303 see other**：这意味着请求已经处理，但为了看到响应，你需要访问响应正文中提供的URL。'
- en: 4xx – client error
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4xx – 客户端错误
- en: 'This category has status codes describing what went wrong due to the client''s
    request:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别包含描述由于客户端请求错误而导致的问题的状态码：
- en: '**400 bad request**: This is a generic response to a malformed request, that
    is, there is a syntax error in the endpoint, or some of the expected parameters
    were not provided.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**400 bad request**：这是对格式错误的请求的通用响应，即端点存在语法错误，或者没有提供一些预期的参数。'
- en: '**401 unauthorized**: This means the client has not been authenticated successfully
    yet, and the resource that it is trying to access needs this authentication.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**401 unauthorized**：这意味着客户端尚未成功认证，它试图访问的资源需要这种认证。'
- en: '**403 forbidden**: This error message means that even though the client has
    been authenticated, it does not have enough permissions to access that resource.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**403 forbidden**：这个错误消息意味着尽管客户端已经认证，但它没有足够的权限访问该资源。'
- en: '**404 not found**: The specific resource has not been found.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**404 not found**：特定的资源未找到。'
- en: '**405 method not allowed**: This means that the endpoint exists, but it does
    not accept the HTTP method used on the request, for example, we were trying to
    use PUT, but the endpoint only accepts POST requests.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**405 method not allowed**：这意味着端点存在，但它不接受请求中使用的HTTP方法，例如，我们试图使用PUT，但端点只接受POST请求。'
- en: 5xx – server error
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5xx – 服务器错误
- en: 'There are up to 11 different errors on the server side, but we are only interested
    in one: the **500 internal server** error. You could use this status code when
    something unexpected, like a database error, happens while processing the request.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端可能有多达 11 种不同的错误，但我们只对其中一种感兴趣：**500 内部服务器**错误。当在处理请求时发生意外情况，如数据库错误，你可以使用这个状态码。
- en: REST API security
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST API 安全性
- en: REST APIs are a powerful tool since they allow developers to retrieve and/or
    update data from the server. But with great power comes great responsibility,
    and when designing a REST API, you should think about making your data as secure
    as possible. Imagine— anyone could post tweets on your behalf with a simple HTTP
    request!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 是一种强大的工具，因为它们允许开发者从服务器检索和/或更新数据。但权力越大，责任越大，在设计 REST API 时，你应该考虑使你的数据尽可能安全。想象一下——任何人都可以通过简单的
    HTTP 请求代表你发布推文！
- en: 'Similar to using web applications, there are two concepts here: **authentication**
    and **authorization**. Authenticating someone is identifying who he or she is,
    that is, linking his or her request to a user in the database. On the other hand,
    authorizing someone is to allow that specific user to perform certain actions.
    You could think of authentication as the login of the user, and authorization
    as giving permissions.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于使用网络应用程序，这里有两个概念：**认证**和**授权**。认证某人就是识别他是谁，也就是说，将他的请求与数据库中的用户关联起来。另一方面，授权某人就是允许该特定用户执行某些操作。你可以把认证看作是用户的登录，而授权则是赋予权限。
- en: REST APIs need to manage these two concepts very carefully. Just because a developer
    has been authenticated does not mean he can access all the data on the server.
    Sometimes, users can access only their own data, whereas sometimes you would like
    to implement a roles system where each role has different access levels. It always
    depends on the type of application you are building.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 需要非常小心地管理这两个概念。仅仅因为开发者已经通过认证，并不意味着他可以访问服务器上的所有数据。有时，用户只能访问他们自己的数据，而有时你可能希望实现一个角色系统，其中每个角色有不同的访问级别。这始终取决于你正在构建的应用程序类型。
- en: Although authorization happens on the server side, that is, it's the server's
    database that will decide whether a given user can access a certain resource or
    not, authentications have to be triggered by the client. This means that the client
    has to know what authentication system the REST API is using in order to proceed
    with the authentication. Each REST API will implement its own authentication system,
    but there are some well known implementations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然授权发生在服务器端，即服务器数据库将决定给定的用户是否可以访问某个资源，但认证必须由客户端触发。这意味着客户端必须知道 REST API 使用的是哪种认证系统，以便进行认证。每个
    REST API 都将实现自己的认证系统，但有一些知名的实施方式。
- en: Basic access authentication
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本访问认证
- en: Basic access authentication—BA for short—is, as its name suggests, basic. The
    client adds the information about the user in the headers of each request, that
    is, username and password. The problem is that this information is only encoded
    using BASE64 but not encrypted, making it extremely easy for an intruder to decode
    the header and obtain the password in plain text. If you ever have to use it,
    since, to be honest, it is a very easy way of implementing some sort of authentication,
    we would recommend you to use it with HTTPS.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 基本访问认证——简称 BA——正如其名所示，非常基础。客户端在每个请求的头部添加关于用户的信息，即用户名和密码。问题是这些信息仅使用 BASE64 编码，而没有加密，这使得入侵者可以轻易解码头部并获取明文密码。如果你必须使用它，说实话，这是一种实现某种认证的非常简单的方法，我们建议你使用
    HTTPS。
- en: 'In order to use this method, you need to concatenate the username and password
    like `username:password`, encode the resultant string using Base64, and add the
    authorization header as:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这种方法，你需要将用户名和密码像 `username:password` 一样连接起来，使用 Base64 对结果字符串进行编码，并将授权头添加为：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: OAuth 2.0
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OAuth 2.0
- en: 'If basic authentication was very simple, and insecure, OAuth 2.0 is the most
    secure system that REST APIs use in order to authenticate, and so was the previous
    OAuth 1.0\. There are actually different versions of this standard, but all of
    them work on the same foundation:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果基本认证非常简单且不安全，OAuth 2.0 就是 REST API 用来进行认证的最安全系统，之前的 OAuth 1.0 也是如此。实际上，这个标准有多个版本，但它们都建立在相同的基础上：
- en: There are no usernames and passwords. Instead, the provider of the REST API
    assigns a pair of credentials—a token and the secret—to the developer.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有用户名和密码。相反，REST API的提供者会给开发者分配一对凭据——一个令牌和一个密钥。
- en: In order to authenticate, the developer needs to send a POST request to the
    "token" endpoint, which is different in each REST API but has the same concept.
    This request has to include the encoded developer credentials.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进行身份验证，开发者需要向“令牌”端点发送一个POST请求，每个REST API的端点都不同，但概念相同。这个请求必须包含编码的开发者凭据。
- en: The server replies to the previous request with a session token. This (and not
    the credentials mentioned in the first step) is to be included in each request
    that you make to the REST API. The session token expires for security reasons,
    so you will have to repeat the second step again when that happens.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器用会话令牌回复之前的请求。这个（而不是第一步中提到的凭据）需要包含在你向REST API发出的每个请求中。出于安全原因，会话令牌会过期，所以当这种情况发生时，你将不得不再次重复第二步。
- en: Even though this standard is kind of recent (2012 onwards), several big companies
    like Google or Facebook have already implemented it for their REST APIs. It might
    look a bit overcomplicated, but you will soon get to use it, and even implement
    it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个标准相对较新（从2012年开始），像谷歌或Facebook这样的几家大公司已经为它们的REST API实施了它。它可能看起来有点过于复杂，但你会很快学会使用它，甚至可以自己实现它。
- en: Using third-party APIs
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方API
- en: That was enough theory about REST APIs; it is time to dive into a real world
    example. In this section, we will write a small PHP application that interacts
    with Twitter's REST API; that includes requesting developer credentials, authenticating,
    and sending requests. The goal is to give you your first experience in working
    with REST APIs, and showing you that it is easier than you could expect. It will
    also help you to understand better how they work, so it will be easier to build
    your own later.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关于REST API的理论就到这里；现在是时候深入一个真实世界的例子了。在本节中，我们将编写一个小型的PHP应用程序，与Twitter的REST API进行交互；这包括请求开发者凭据、进行身份验证和发送请求。目标是让你获得使用REST
    API的第一手经验，并展示它比你预期的要简单。这也有助于你更好地理解它们是如何工作的，因此以后构建自己的API会更容易。
- en: Getting the application's credentials
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取应用程序的凭据
- en: REST APIs usually have the concept of application. An application is like an
    account on their development site that identifies who uses the API. The credentials
    that you will use to access the API will be linked to this application, which
    means that you can have multiple applications linked to the same account.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: REST API通常有应用程序的概念。应用程序就像它们开发网站上的一个账户，用于标识谁在使用API。你将用来访问API的凭据将与该应用程序相关联，这意味着你可以有多个应用程序与同一个账户相关联。
- en: Assuming that you have a Twitter account, go to [https://apps.twitter.com](https://apps.twitter.com)
    in order to create a new application. Click on the **Create New App** button in
    order to access the form for application details. The fields are very self-explanatory—just
    a name for the application, the description, and the website URL. The callback
    URL is not necessary here, since that will be used only for applications that
    require access to someone else's account. Agree with the terms and conditions
    in order to proceed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个Twitter账户，请访问[https://apps.twitter.com](https://apps.twitter.com)以创建一个新的应用程序。点击**创建新应用**按钮以访问应用程序详情表单。字段非常直观——只需为应用程序提供一个名称、描述和网站URL。回调URL在这里不是必需的，因为它仅用于需要访问他人账户的应用程序。同意条款和条件以继续。
- en: 'Once you have been redirected to your application''s page, you will see all
    sort of information that you can edit. Since this is just an example, let''s go
    straight to what matters: the credentials. Click on the **Keys and Access Tokens**
    tab to see the values of **Consumer key (API key)** and **Consumer Secret (API
    secret)**. There is nothing else that we need from here. You can save them on
    your filesystem, as `~/.twitter_php7.json`, for example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你被重定向到你的应用程序页面，你会看到各种可以编辑的信息。由于这是一个示例，让我们直接进入重点：凭据。点击**密钥和访问令牌**选项卡以查看**消费者密钥（API密钥）**和**消费者密钥（API密钥）**的值。这里我们不需要其他任何东西。你可以将它们保存在你的文件系统中，例如`~/.twitter_php7.json`：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Securing your credentials**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**保护你的凭据**'
- en: Securing your REST API credentials should be taken seriously. In fact, you should
    take care of all kinds of credentials, like the database ones. But the difference
    is that you will usually host your database in your server, which makes things
    slightly more difficult to whoever wants to attack. On the other hand, the third-party
    REST API is not part of your system, and someone with your credentials can use
    your account freely on your behalf.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Never include your credentials in your code base, especially if you have your
    code in GitHub or some other repository. One solution would be to have a file
    in your server, outside your code, with the credentials; if that file is encrypted,
    that is even better. And try to refresh your credentials regularly, which you
    can probably do on the provider's website.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the application
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our application will be extremely simple. It will consist of one class that
    will allow us to fetch tweets. This will be managed by our `app.php` script.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have to make HTTP requests, we can either write our own functions that
    use **cURL** (a set of PHP native functions), or make use of the famous PHP library,
    **Guzzle**. This library can be found in **Packagist**, so we will use Composer
    to include it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will have a `Twitter` class, which will get the credentials from the constructor,
    and one public method: `fetchTwits`. For now, just create the skeleton so that
    we can work with it; we will implement such methods in later sections. Add the
    following code to `src/Twitter.php`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since we set the namespace `TwitterApp`, we need to update our `composer.json`
    file with the following addition. Remember to run `composer update` to update
    the autoloader.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we will create a basic `app.php` file, which includes the Composer
    autoloader, reads the credentials file, and creates a Twitter instance:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Requesting an access token
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a real world application, you would probably want to separate the code related
    to authentication from the one that deals with operations like fetching or posting
    data. To keep things simple here, we will let the `Twitter` class know how to
    authenticate by itself.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding a `$client` property to the class which will contain
    an instance of Guzzle''s `Client` class. This instance will contain the base URI
    of the Twitter API, which we can have as the constant `TWITTER_API_BASE_URI`.
    Instantiate this property in the constructor so that the rest of the methods can
    make use of it. You can also add an `$accessToken` property which will contain
    the access token returned by the Twitter API when authenticating. All these changes
    are highlighted here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next step would be to write a method that, given the key and secret are
    provided, requests an access token to the provider. More specifically:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Concatenate the key and the secret with a `:`. Encode the result using Base64.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send a POST request to `/oauth2/token` with the encoded credentials as the `Authorization`
    header. Also include a `Content-Type` header and a body (check the code for more
    information).
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`/oauth2/token`发送带有编码凭证的POST请求作为`Authorization`头。还要包括`Content-Type`头和体（更多信息请查看代码）。
- en: 'We now invoke the `post` method of Guzzle''s `client` instance sending two
    arguments: the endpoint string (`/oauth2/token`) and an array with options. These
    options include the headers and the body of the request, as you will see shortly.
    The response of this invocation is an object that identifies the HTTP response.
    You can extract the content (body) of the response with `getBody`. Twitter''s
    API response is a JSON with some arguments. The one that you care about the most
    is the `access_token`, the token that you will need to include in each subsequent
    request to the API. Extract it and save it. The full method looks as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在调用Guzzle的`client`实例的`post`方法，传递两个参数：端点字符串（`/oauth2/token`）和包含选项的数组。这些选项包括请求的头和体，您将很快看到。这个调用的响应是一个对象，它标识HTTP响应。您可以使用`getBody`提取响应的内容（体）。Twitter的API响应是一个带有一些参数的JSON。您最关心的参数是`access_token`，这是您需要在每个后续API请求中包含的令牌。提取它并保存。完整的方法如下：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can already try this code by adding these two lines at the end of the constructor:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在构造函数末尾添加这两行代码来尝试此代码：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the application in order to see the access token given by the provider using
    the following command. Remember to remove the preceding two lines in order to
    proceed with the section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行应用程序，以查看提供者提供的访问令牌。记住，为了继续本节，请删除前面的两行。
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Keep in mind that, even though having a key and secret and getting an access
    token is the same across all OAuth authentications, the specific way of encoding,
    the endpoint used, and the response received from the provider are exclusive from
    Twitter's API. It could be that several others are exactly the same, but always
    check the documentation for each one.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尽管拥有密钥和密钥并获取访问令牌在所有OAuth身份验证中都是相同的，但编码方式、使用的端点和从提供者收到的响应对于Twitter的API是独有的。可能还有其他几个是相同的，但始终检查每个的文档。
- en: Fetching tweets
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取推文
- en: 'We finally arrive to the section where we actually make use of the API. We
    will implement the `fetchTwits` method in order to get a list of the last *N*
    number of tweets for a given user. In order to perform requests, we need to add
    the `Authorization` header to each one, this time with the access token. Since
    we want to make this class as reusable as possible, let''s extract this to a private
    method:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终到达了实际使用API的部分。我们将实现`fetchTwits`方法，以获取给定用户的最后*N*条推文列表。为了执行请求，我们需要在每个请求中添加`Authorization`头，这次使用访问令牌。由于我们希望尽可能使这个类可重用，让我们将其提取到一个私有方法中：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, the preceding method also allows us to fetch the access token
    from the provider. This is useful, since if we make more than one request, we
    will just request the access token once, and we have one unique place to do so.
    Add now the following method implementation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面方法还允许我们从提供者那里获取访问令牌。这很有用，因为我们如果发出多个请求，我们只需请求一次访问令牌，并且有一个唯一的地方来做这件事。现在添加以下方法实现：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first part of the preceding method builds the `options` array with the access
    token headers and the query string arguments—in this case, with the number of
    tweets to retrieve and the user. We perform the GET request and decode the JSON
    response into an array. This array contains a lot of information that we might
    not need, so we iterate it in order to extract those fields that we really want—in
    this example, the date, the text, and the user.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法的第一个部分使用访问令牌头和查询字符串参数构建`options`数组——在这种情况下，包括要检索的推文数量和用户。我们执行GET请求并将JSON响应解码为数组。这个数组包含大量我们可能不需要的信息，因此我们迭代它以提取我们真正想要的字段——在这个例子中，日期、文本和用户。
- en: In order to test the application, just invoke the `fetchTwits` method at the
    end of the `app.php` file, specifying the Twitter ID of one of the people you
    are following, or yourself.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试应用程序，只需在`app.php`文件的末尾调用`fetchTwits`方法，指定您关注的某人的Twitter ID或您自己的ID。
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should get a response similar to ours, shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到一个类似于我们下面的响应，如以下截图所示：
- en: '![Fetching tweets](img/00044.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![获取推文](img/00044.jpeg)'
- en: 'One thing to keep in mind is that access tokens expire after some time, returning
    an HTTP response with a 4xx status code (usually, 401 unauthorized). Guzzle throws
    an exception when the status code is either 4xx or 5xx, so it is easy manage these
    scenarios. You could add this code when performing the GET request:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事情是，访问令牌在一段时间后会过期，返回一个带有4xx状态码的HTTP响应（通常是401未授权）。Guzzle在状态码为4xx或5xx时抛出异常，因此很容易管理这些场景。你可以在执行GET请求时添加此代码：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The toolkit of the REST API developer
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API开发者的工具集
- en: While you are developing your own REST API, or writing an integration for a
    third-party one, you might want to test it before you start writing your code.
    There are a handful of tools that will help you with this task, whether you want
    to use your browser, or you are a fan of the command line.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你正在开发自己的REST API，或者为第三方API编写集成时，你可能想在开始编写代码之前测试它。有一些工具可以帮助你完成这项任务，无论你是想使用浏览器，还是你是命令行的粉丝。
- en: Testing APIs with browsers
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用浏览器测试API
- en: 'There are actually several add-ons that allow you to perform HTTP requests
    from browsers, depending on which one you use. Some famous names are *Advanced
    Rest Client* for Chrome and *RESTClient* for Firefox. At the end of the day, all
    those clients allow you to perform the same HTTP requests, where you can specify
    the URL, the method, the headers, the body, and so on. These clients will also
    show you all the details you can imagine from the response, including the status
    code, the time spent, and the body. The following screenshot displays an example
    of a request using Chrome''s *Advanced Rest Client*:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有几个插件允许你从浏览器执行HTTP请求，具体取决于你使用的是哪一个。一些著名的名字是Chrome上的*Advanced Rest Client*和Firefox上的*RESTClient*。最终，所有这些客户端都允许你执行相同的HTTP请求，你可以指定URL、方法、头部、主体等。这些客户端还会显示你想象得到的所有响应细节，包括状态码、耗时和主体。以下截图显示了使用Chrome的*Advanced
    Rest Client*的一个请求示例：
- en: '![Testing APIs with browsers](img/00045.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![使用浏览器测试API](img/00045.jpeg)'
- en: If you want to test GET requests with your own API, and all that you need is
    the URL, that is, you do not need to send any headers, you can just use your browser
    as if you were trying to access any other website. If you do so, and if you are
    working with JSON responses, you can install another add-on to your browser that
    will help you in viewing your JSON in a more "beautiful" way. Look for *JSONView*
    on any browser for a really handy one.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用自己的API测试GET请求，而你需要的只是URL，也就是说，你不需要发送任何头部，你只需像访问任何其他网站一样使用你的浏览器。如果你这样做，并且如果你正在处理JSON响应，你可以安装另一个浏览器插件，这将帮助你以更“美观”的方式查看你的JSON。在任何浏览器上查找*JSONView*，以获得一个真正方便的工具。
- en: Testing APIs using the command line
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令行测试API
- en: 'Some people feel more comfortable using the command line; so luckily, for them
    there are tools that allow them to perform any HTTP request from their consoles.
    We will give a brief introduction to one of the most famous ones: cURL. This tool
    has quite a lot of features, but we will focus only on the ones that you will
    be using more often: the HTTP method, post parameters, and headers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人觉得使用命令行更舒服；幸运的是，对于他们来说，有一些工具允许他们从控制台执行任何HTTP请求。我们将简要介绍其中最著名的一个：cURL。这个工具有很多功能，但我们只会关注你更常使用的那些：HTTP方法、POST参数和头部：
- en: '`-X <method>`: This specifies the HTTP method to use'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-X <method>`：这指定了要使用的HTTP方法'
- en: '`--data`: This adds the parameters specified, which can be added as key-value
    pairs, JSON, plain text, and so on'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--data`：这添加了指定的参数，可以是键值对、JSON、纯文本等'
- en: '`--header`: This adds a header to the request'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--header`：这会给请求添加一个头部'
- en: 'The following is an example of the way to send a POST request with cURL:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用cURL发送POST请求的示例：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you are using a Unix system, you will probably be able to format the resulting
    JSON by appending `| python -m json.tool` so that it gets easier to read:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Unix系统，你可能会通过附加`| python -m json.tool`来格式化生成的JSON，这样它就更容易阅读了：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: cURL is quite a powerful tool that lets you do quite a few tricks. If you are
    interested, go ahead and check the documentation or some tutorial on how to use
    all its features.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: cURL是一个非常强大的工具，它让你可以做很多技巧。如果你感兴趣，请继续查看文档或一些教程，了解如何使用所有这些功能。
- en: Best practices with REST APIs
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REST API的最佳实践
- en: We've already gone through some of the best practices when writing REST APIs,
    like using HTTP methods properly, or choosing the correct status code for your
    responses. We also described two of the most used authentication systems. But
    there is still a lot to learn about creating proper REST APIs. Remember that they
    are meant to be used by developers like yourself, so they will always be grateful
    if you do things properly, and make their lives easier. Ready?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了一些编写REST API的最佳实践，比如正确使用HTTP方法，或者为你的响应选择正确的状态码。我们还描述了两种最常用的认证系统。但关于创建合适的REST
    API还有很多东西要学习。记住，它们是为了像你这样的开发者而设计的，所以如果你做得正确，会使他们的生活变得更轻松。准备好了吗？
- en: Consistency in your endpoints
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端点的一致性
- en: 'When deciding how to name your endpoints, try keeping them consistent. Even
    though you are free to choose, there is a set of spoken rules that will make your
    endpoints more intuitive and easy to understand. Let''s list some of them:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定如何命名你的端点时，尽量保持一致性。尽管你可以自由选择，但有一套口语化的规则可以使你的端点更加直观和易于理解。让我们列举一些：
- en: For starters, an endpoint should point to a specific resource (for example,
    books or tweets), and you should make that clear in your endpoint. If you have
    an endpoint that returns the list of all books, do not name it `/library`, as
    it is not obvious what it will be returning. Instead, name it `/books` or `/books/all`.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，一个端点应该指向一个特定的资源（例如，书籍或推文），你应该在你的端点中清楚地表明这一点。如果你有一个返回所有书籍列表的端点，不要命名为`/library`，因为它不明显会返回什么。相反，命名为`/books`或`/books/all`。
- en: The name of the resource can be either plural or singular, but make it consistent.
    If sometimes you use `/books` and sometimes `/user`, it might be confusing, and
    people will probably make mistakes. We personally prefer to use the plural form,
    but that is totally up to you.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源名称可以是复数也可以是单数，但请保持一致性。如果你有时使用`/books`，有时使用`/user`，可能会造成混淆，人们可能会犯错误。我们个人更喜欢使用复数形式，但这完全取决于你。
- en: When you want to retrieve a specific resource, do it by specifying the ID whenever
    possible. IDs must be unique in your system, and any other parameter might point
    to two different entities. Specify the ID next to the name of the resource, such
    as `/books/249234-234-23-42`.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想检索特定的资源时，如果可能的话，通过指定ID来执行。ID必须在你的系统中是唯一的，任何其他参数可能指向两个不同的实体。在资源名称旁边指定ID，例如`/books/249234-234-23-42`。
- en: If you can understand what an endpoint does by just the HTTP method, there is
    no need to add this information as part of the endpoint. For example, if you want
    to get a book, or you want to delete it, `/books/249234-234-23-42` along with
    the HTTP methods GET and DELETE are more than enough. If it is not obvious, state
    it as a verb at the end of the endpoint, like `/employee/9218379182/promote`.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你仅通过HTTP方法就能理解端点的作用，就没有必要将其作为端点的一部分添加信息。例如，如果你想获取一本书，或者删除它，使用`/books/249234-234-23-42`以及HTTP方法GET和DELETE就足够了。如果不明显，可以在端点末尾用动词表示，如`/employee/9218379182/promote`。
- en: Document as much as you can
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尽可能多地编写文档
- en: The title says everything. You are probably not going to be the one using the
    REST API, others will. Obviously, even if you design a very intuitive set of endpoints,
    developers will still need to know the whole set of available endpoints, what
    each of them does, what optional parameters are available, and so on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 标题应该包含所有信息。你很可能不会是使用REST API的人，其他人会。显然，即使你设计了一套非常直观的端点，开发者仍然需要知道所有可用的端点，每个端点的作用，可用的可选参数等等。
- en: Write as much documentation as possible, and keep it up to date. Take a look
    at other documented APIs to gather ideas on how to display the information. There
    are plenty of templates and tools that will help you deliver a well-presented
    documentation, but you are the one that has to be consistent and methodical. Developers
    have a special hate towards documenting anything, but we also like to find clear
    and beautifully presented documentation when we need to use someone else's APIs.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能多地编写文档，并保持其更新。看看其他已记录的API，以获取如何展示信息的想法。有许多模板和工具可以帮助你提供一份展示良好的文档，但你必须保持一致性和条理性。开发者特别讨厌编写文档，但当我们需要使用他人的API时，我们也喜欢找到清晰且美观展示的文档。
- en: Filters and pagination
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤和分页
- en: One of the common usages of an API is to list resources and filter them by some
    criteria. We already saw an example when we were building our own bookstore; we
    wanted to get the list of books that contained a certain string in their titles
    or authors.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: API的一种常见用途是列出资源并通过某些标准进行筛选。当我们构建自己的书店时，我们已经看到了一个例子；我们想要获取包含特定字符串在标题或作者中的书籍列表。
- en: 'Some developers try to have beautiful endpoints, which a priori is a good thing
    to do. Imagine that you want to filter just by title, you might end up having
    an endpoint like `/books/title/<string>`. We add also the ability to filter by
    author, and we now get two more endpoints: `/books/title/<string>/author/<string>`
    and `/books/author/<string>`. Now let''s add the description too—do you see where
    we are going?'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者试图拥有美观的端点，从先验的角度来看，这是一件好事。想象一下，如果你想仅通过标题进行筛选，你可能会得到一个像 `/books/title/<string>`
    这样的端点。我们还增加了通过作者进行筛选的能力，现在我们得到了两个额外的端点：`/books/title/<string>/author/<string>`
    和 `/books/author/<string>`。现在让我们也添加描述——你看到我们想要去哪里了吗？
- en: Even though some developers do not like to use query strings as arguments, there
    is nothing wrong with it. In fact, if you use them properly, you will end up with
    cleaner endpoints. You want to get books? Fine, just use `/books`, and add whichever
    filter you need using the query string.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一些开发者不喜欢使用查询字符串作为参数，但这并没有什么问题。事实上，如果你正确使用它们，你最终会得到更干净的端点。你想获取书籍？好的，只需使用 `/books`，并使用查询字符串添加你需要的任何过滤器。
- en: Pagination occurs when you have way too many resources of the same type to retrieve
    all at once. You should think of pagination as another optional filter to be specified
    as a GET parameter. You should have pages with a default size, let's say 10 books,
    but it is a good idea to give the developers the ability to define their own size.
    In this case, developers can specify the length and the number of pages to retrieve.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你一次需要检索大量同类型资源时，就会发生分页。你应该将分页视为另一个可选的过滤器，作为GET参数指定。你应该有默认大小的页面，比如10本书，但给开发者定义他们自己的大小是一个好主意。在这种情况下，开发者可以指定要检索的长度和页数。
- en: API versioning
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API版本控制
- en: Your API is a reflection of what your application can do. Chances are that your
    code will evolve, improving the already existing features or adding new ones.
    Your API should be updated too, exposing those new features, updating existing
    endpoints, or even removing some of them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你的API是你应用程序能做什么的反映。很可能会发生你的代码会进化，改进现有的功能或添加新的功能。你的API也应该更新，以暴露这些新功能，更新现有端点，甚至删除其中的一些。
- en: Imagine now that someone else is using your REST API, and their whole website
    relies on it. If you change your existing endpoints, their website will stop working!
    They will not be happy at all, and will try to find someone else that can do what
    you were doing. Not a good scenario, but then, how do you improve your API?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，有人正在使用你的REST API，并且他们的整个网站都依赖于它。如果你更改现有的端点，他们的网站将停止工作！他们不会感到高兴，并试图找到其他人来做你之前做的事情。这不是一个好的场景，但那么，你如何改进你的API呢？
- en: 'The solution is to use versioning. When you release a new version of the API,
    do not nuke down the existing one; you should give some time to the users to upgrade
    their integrations. And how can two different versions of the API coexist? You
    already saw one of the options—the one that we recommend you: by specifying the
    version of the API to use as part of the endpoint. Do you remember the endpoint
    of the Twitter API `/1.1/statuses/user_timeline.json`? The `1.1` refers to the
    version that we want to use.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用版本控制。当你发布API的新版本时，不要删除现有的版本；你应该给用户一些时间来升级他们的集成。那么，两个不同的API版本如何共存呢？你已经看到了一个选项——我们推荐你使用的那个：通过在端点中指定要使用的API版本。你还记得Twitter
    API的端点 `/1.1/statuses/user_timeline.json` 吗？其中的 `1.1` 指的是我们想要使用的版本。
- en: Using HTTP cache
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HTTP缓存
- en: If the main feature of REST APIs is that they make heavy use of HTTP, why not
    take advantage of HTTP cache? Well, there are actual reasons for not using it,
    but most of them are due to a lack of knowledge about using it properly. It is
    out of the scope of this book to explain every single detail of its implementation,
    but let's try to give a short introduction to the topic. Plenty of resources on
    the Internet can help you to understand the parts that you are more interested
    in.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: HTTP responses can be divided as public and private. Public responses are shared
    between all users of the API, whereas the private ones are meant to be unique
    for each user. You can specify which type of response is yours using the `Cache-Control`
    header, allowing the response to be cached if the method of the request was a
    GET. This header can also expose the expiration of the cache, that is, you can
    specify the duration for which your response will remain the same, and thus, can
    be cached.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Other systems rely on generating a hash of the representation of a resource,
    and add it as the `ETag` (Entity tag) header in order to know if the resource
    has changed or not. In a similar way, you can set the `Last-Modified` header to
    let the client know when was the last time that the given resource changed. The
    idea behind those systems is to identify when the client already contains valid
    data. If so, the provider does not process the request, but returns an empty response
    with the status code 304 (not modified) instead. When the client gets that response,
    it uses its cached content.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Creating a REST API with Laravel
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build a REST API with Laravel from scratch. This REST
    API will allow you to manage different clients at your bookstore, not only via
    the browser, but via the UI as well. You will be able to perform pretty much the
    same actions as before, that is, listing books, buying them, borrowing for free,
    and so on.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Once the REST API is done, you should remove all the business logic from the
    bookstore that you built during the previous chapters. The reason is that you
    should have one unique place where you can actually manipulate your databases
    and the REST API, and the rest of the applications, like the web one, should able
    to communicate with the REST API for managing data. In doing so, you will be able
    to create other applications for different platforms, like mobile apps, that will
    use the REST API too, and both the website and the mobile app will always be synchronized,
    since they will be using the same sources.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'As with our previous Laravel example, in order to create a new project, you
    just need to run the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Setting OAuth2 authentication
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing that we are going to implement is the authentication layer.
    We will use OAuth2 in order to make our application more secure than basic authentication.
    Laravel does not provide support for OAuth2 out of the box, but there is a service
    provider which does that for us.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Installing OAuth2Server
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install OAuth2, add it as a dependency to your project using Composer:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This service provider needs quite a few changes. We will go through them without
    going into too much detail on how things work exactly. If you are more interested
    in the topic, or if you want to create your own service providers for Laravel,
    we recommend you to go though the extensive official documentation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we need to add the new OAuth2Server service provider to the
    array of providers in the `config/app.php` file. Add the following lines at the
    end of the `providers` array:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the same way, you need to add a new alias to the `aliases` array in the
    same file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s move to the `app/Http/Kernel.php` file, where we need to make some changes
    too. Add the following entry to the `$middleware` array property of the `Kernel`
    class:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the following key-value pairs to the `$routeMiddleware` array property
    of the same class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We added a CSRF token verifier to the `$routeMiddleware`, so we need to remove
    the one already defined in `$middlewareGroups`, since they are incompatible. Use
    the following line to do so:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Setting up the database
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's set up the database now. In this section, we will assume that you already
    have the bookstore database in your environment. If you do not have it, go back
    to [Chapter 5](part0045_split_000.html#1AT9A1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 5. Using Databases"), *Using Databases*, to create it in order to proceed
    with this setup.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is to update the database credentials in the `.env` file.
    They should look something similar to the following lines, but with your username
    and password:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order to prepare the configuration and database migration files from the
    OAuth2Server service provider, we need to publish it. In Laravel, you do it by
    executing the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now the `database/migrations` directory contains all the necessary migration
    files that will create the necessary tables related to OAuth2 in our database.
    To execute them, we run the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We need to add at least one client to the `oauth_clients` table, which is the
    table that stores the key and secrets for all clients that want to connect to
    our REST API. This new client will be the one that you will use during the development
    process in order to test what you have done. We can set a random ID—the key—and
    the secret as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Enabling client-credentials authentication
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since we published the plugins in `vendor` in the previous step, now we have
    the configuration files for the OAuth2Server. This plugin allows us different
    authentication systems (all of them with OAuth2), depending on our necessities.
    The one that we are interested in for our project is the `client_credentials`
    type. To let Laravel know, add the following lines at the end of the array in
    the `config/oauth2.php` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These preceding lines grant access to the `client_credentials` type, which are
    managed by the `ClientCredentialsGrant` class. The `access_token_ttl` value refers
    to the time period of the access token, that is, for how long someone can use
    it. In this case, it is set to 1 hour, that is, 3,600 seconds.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to enable a route so we can post our credentials in exchange
    for an access token. Add the following route to the routes file in `app/Http/routes.php`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Requesting an access token
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is time to test what we have done so far. To do so, we need to send a POST
    request to the `/oauth/access_token` endpoint that we enabled just now. This request
    needs the following POST parameters:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '`client_id` with the key from the database'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`client_secret` with the secret from the database'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grant_type` to specify the type of authentication that we are trying to perform,
    in this case `client_credentials`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The request issued using the *Advanced REST Client* add-on from Chrome looks
    as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Requesting an access token](img/00046.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: 'The response that you should get should have the same format as this one:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note that this is a different way of requesting for an access token than what
    the Twitter API does, but the idea is still the same: given a key and a secret,
    the provider gives us an access token that will allow us to use the API for some
    time.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the database
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though we''ve already done the same in the previous chapter, you might
    think: "Why do we start by preparing the database?". We could argue that you first
    need to know the kind of endpoints you want to expose in your REST API, and only
    then you can start thinking about what your database should look like. But you
    could also think that, since we are working with an API, each endpoint should
    manage one resource, so first you need to define the resources you are dealing
    with. This *code first versus database/model first* is an ongoing war on the Internet.
    But whichever way you think is better, the fact is that we already know what the
    users will need to do with our REST API, since we already built the UI previously;
    so it does not really matter.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create four tables: `books`, `sales`, `sales_books`, and `borrowed_books`.
    Remember that Laravel already provides a `users` table, which we can use as our
    customers. Run the following four commands to create the migrations files:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we have to go file by file to define what each table should look like.
    We will try to replicate the data structure from [Chapter 5](part0045_split_000.html#1AT9A1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 5. Using Databases"), *Using Databases*, as much as possible. Remember
    that the migration files can be found inside the `database/migrations` directory.
    The first file that we can edit is the `create_books_table.php`. Replace the existing
    empty `up` method by the following one:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The next one in the list is `create_sales_table.php`. Remember that this one
    has a foreign key pointing to the `users` table. You can use `references(field)->on(tablename)`
    to define this constraint.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `create_sales_books_table.php` file contains two foreign keys: one pointing
    to the ID of the sale, and one to the ID of the book. Replace the existing `up`
    method by the following one:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, edit the `create_borrowed_books_table.php` file, which has the `book_id`
    foreign key and the `start` and `end` timestamps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The migration files are ready so we just need to migrate them in order to create
    the database tables. Run the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Also, add some books to the database manually so that you can test later. For
    example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Setting up the models
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next thing to do on the list is to add the relationships that our data
    has, that is, to translate the foreign keys from the database to the models. First
    of all, we need to create those models, and for that we just run the following
    commands:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we have to go model by model, and add the one to one and one to many relationships
    as we did in the previous chapter. For `BookModel`, we will only specify that
    the model does not have timestamps, since they come by default. To do so, add
    the following highlighted line to your `app/Book.php` file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For the `BorrowedBook` model, we need to specify that it has one book, and
    it belongs to a user. We also need to specify the fields we will fill once we
    need to create the object—in this case, `book_id` and `start`. Add the following
    two methods in `app/BorrowedBook.php`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Sales can have many "sale books" (we know it might sound a little awkward),
    and they also belong to just one user. Add the following to your `app/Sale.php`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Like borrowed books, sale books can have one book and belong to one sale instead
    of to one user. The following lines should be added to `app/SalesBook.php`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, the last model that we need to update is the `User` model. We need
    to add the opposite relationship to the `belongs` we used earlier in `Sale` and
    `BorrowedBook`. Add these two functions, and leave the rest of the class intact:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Designing endpoints
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we need to come up with the list of endpoints that we want
    to expose to the REST API clients. Keep in mind the "rules" explained in the *Best
    practices with REST APIs* section. In short, keep the following rules in mind:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: One endpoint interacts with one resource
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A possible schema could be `<API version>/<resource name>/<optional id>/<optional
    action>`
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use GET parameters for filtering and pagination
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So what will the user need to do? We already have a good idea about that, since
    we created the UI. A brief summary would be as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: List all the available books with some filtering (by title and author), and
    paginated when necessary. Also retrieve the information on a specific book, given
    the ID.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the user to borrow a specific book if available. In the same way, the
    user should be able to return books, and list the history of borrowed books too
    (filtered by date and paginated).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the user to buy a list of books. This could be improved, but for now let's
    force the user to buy books with just one request, including the full list of
    books in the body. Also, list the sales of the user following the same rules as
    that with borrowed books.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start straightaway with our list of endpoints, specifying the path,
    the HTTP method, and the optional parameters. It will also give you an idea on
    how to document your REST APIs.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: GET `/books`
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: Optional and filters by title'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author`: Optional and filters by author'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page`: Optional, default is 1, and specifies the page to return'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page-size`: Optional, default is 50, and specifies the page size to return'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: GET `/books/<book id>`
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POST `/borrowed-books`
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`book-id`: Mandatory and specifies the ID of the book to borrow'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: GET `/borrowed-books`
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from`: Optional and returns borrowed books from the specified date'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page`: Optional, default is 1, and specifies the page to return'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page-size`: Optional, default is 50, and specifies the number of borrowed
    books per page'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: PUT `/borrowed-books/<borrowed book id>/return`
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POST `/sales`
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`books`: Mandatory and it is an array listing the book IDs to buy and their
    amounts, that is, *{"book-id-1": amount, "book-id-2": amount, ...}*'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: GET `/sales`
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from`: Optional and returns borrowed books from the specified date'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page`: Optional, default is 1, and specifies the page to return'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page-size`: Optional, default is 50, and specifies the number of sales per
    page'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: GET `/sales/<sales id>`
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use POST requests when creating sales and borrowed books, since we do not
    know the ID of the resource that we want to create a priori, and posting the same
    request will create multiple resources. On the other hand, when returning a book,
    we do know the ID of the borrowed book, and sending the same request multiple
    times will leave the database in the same state. Let''s translate these endpoints
    to routes in `app/Http/routes.php`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code, note how we added the middleware `oauth` to all the endpoints.
    This will require the user to provide a valid access token in order to access
    them.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Adding the controllers
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the previous section, you can imagine that we need to create three controllers:
    `BookController`, `BorrowedBookController`, and `SalesController`. Let''s start
    with the easiest one: returning the information of a book given the ID. Create
    the file `app/Http/Controllers/BookController.php`, and add the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Even though this preceding example is quite easy, it contains most of what we
    will need for the rest of the endpoints. We try to fetch a book given the ID from
    the URL, and when not found, we reply with a 404 (not found) empty response—the
    constant `Response::HTTP_NOT_FOUND` is 404\. In case we have the book, we return
    it as JSON with `response->json()`. Note how we add the seemingly unnecessary
    key `book`; it is true that we do not return anything else and, since we ask for
    the book, the user will know what we are talking about, but as it does not really
    hurt, it is good to be as explicit as possible.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test it! You already know how to get an access token—check the *Requesting
    an access token* section. So get one, and try to access the following URLs:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost/books/0?access_token=12345`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost/books/1?access_token=12345`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assuming that `12345` is your access token, that you have a book in the database
    with ID `1`, and you do not have a book with ID `0`, the first URL should return
    a 404 response, and the second one, a response something similar to the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s now add the method to get all the books with filters and pagination.
    It looks quite verbose, but the logic that we use is quite simple:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We get all the parameters that can come from the request, and set the default
    values of each one in case the user does not include them (since they are optional).
    Then, we use the Eloquent ORM to filter by title and author using `where()`, and
    limiting the results with `take()->skip()`. We return the JSON in the same way
    we did with the previous method. In this one though, we do not need any extra
    check; if the query does not return any book, it is not really a problem.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now play with your REST API, sending different requests with different
    filters. The following are some examples:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost/books?access_token=12345`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost/books?access_token=12345&title=19&page-size=1`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost/books?access_token=12345&page=2`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next controller in the list is `BorrowedBookController`. We need to add
    three methods: `borrow`, `get`, and `returnBook`. As you already know how to work
    with requests, responses, status codes, and the Eloquent ORM, we will write the
    entire class straightaway:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The only thing to note in the preceding code is how we also update the stock
    of the book by increasing or decreasing the stock, and invoke the `save` method
    to save the changes in the database. We also return the borrowed book object as
    the response when borrowing a book so that the user can know the borrowed book
    ID, and use it when querying or returning the book.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test how this set of endpoints works with the following use cases:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Borrow a book. Check that you get a valid response.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the list of borrowed books. The one that you just created should be there
    with a valid starting date and an empty end date.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the information of the book you borrowed. The stock should be one less.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the book. Fetch the list of borrowed books to check the end date and
    the returned book to check the stock.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, you can always try to trick the API and ask for books without stock,
    non-existing borrowed books, and the like. All these edge cases should respond
    with the correct status codes and error messages.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'We finish this section, and the REST API, by creating the `SalesController`.
    This controller is the one that contains more logic, since creating a sale implies
    adding entries to the sales books table, prior to checking for enough stock for
    each one. Add the following code to `app/Html/SalesController.php`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding code, note how we first check the availability of all the books
    before creating the sales entry. This way, we make sure that we do not leave any
    unfinished sale in the database when returning an error to the user. You could
    change this, and use transactions instead, and if a book is not valid, just roll
    back the transaction.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to test this, we can follow similar steps as we did with borrowed
    books. Just remember that the `books` parameter, when posting a sale, is a JSON
    map; for example, `{"1": 2, "4": 1}` means that I am trying to buy two books with
    ID `1` and one book with ID `4`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Testing your REST APIs
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have already been testing your REST API after finishing each controller
    by making some request and expecting a response. As you might imagine, this can
    be handy sometimes, but it is for sure not the way to go. Testing should be automatic,
    and should cover as much as possible. We will have to think of a solution similar
    to unit testing.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](part0088_split_000.html#2JTHG2-edcc22b134104d5db0bf3aa086c86851
    "Chapter 10. Behavioral Testing"), *Behavioral Testing*, you will learn more methodologies
    and tools for testing an application end to end, and that will include REST APIs.
    However, due to the simplicity of our REST API, we can add some pretty good tests
    with what Laravel provides us as well. Actually, the idea is very similar to the
    tests that we wrote in [Chapter 8](part0071_split_000.html#23MNU1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 8. Using Existing PHP Frameworks"), *Using Existing PHP Frameworks*,
    where we made a request to some endpoint, and expected a response. The only difference
    will be in the kind of assertions that we use (which can check if a JSON response
    is OK), and the way we perform requests.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some tests to the set of endpoints related to books. We need some
    books in the database in order to query them, so we will have to populate the
    database before each test, that is, use the `setUp` method. Remember that in order
    to leave the database clean of test data, we need to use the trait `DatabaseTransactions`.
    Add the following code to `tests/BooksTest.php`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see in the preceding code, we add three books to the database, and
    to the class property `$books` too. We will need them when we want to assert that
    a response is valid. Also note the use of the `fresh` method; this method synchronizes
    the model that we have with the content in the database. We need to do this in
    order to get the ID inserted in the database, since we do not know it a priori.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another thing we need to do before we run each test: authenticating
    our client. We will need to make a POST request to the access token generation
    endpoint sending valid credentials, and storing the access token that we receive
    so that it can be used in the remaining requests. You are free to choose how to
    provide the credentials, since there are different ways to do it. In our case,
    we just provide the credentials of a client test that we know exists in the database,
    but you might prefer to insert that client into the database each time. Update
    the test with the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding code, we use the `post` method in order to send a POST request.
    This method accepts a string with the endpoint, and an array with the parameters
    to be included. After making a request, Laravel saves the response object into
    the `$response` property. We can JSON-decode it, and extract the access token
    that we need.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to add some tests. Let''s start with an easy one: requesting a book
    given an ID. The ID is used to make the GET requests with the ID of the book (do
    not forget the access token), and check if the response matches the expected one.
    Remember that we have the `$books` array already, so it will be pretty easy to
    perform these checks.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using two assertions: `seeJson`, which compares the received JSON
    response with the one that we provide, and `assertResponseOk`, which you already
    know from previous tests—it just checks that the response has a 200 status code.
    Add this test to the class:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We use the `get` method instead of `post`, since this is a GET request. Also
    note that we use the `getCredentials` helper, since we will have to use it in
    each test. To see another example, let''s add a test that checks the response
    when requesting the books that contain the given title:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The preceding test is pretty much the same as the previous one, isn't it? The
    only changes are the endpoint and the expected response. Well, the remaining tests
    will all follow the same pattern, since so far, we can only fetch books and filter
    them.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: To see something different, let's check how to test an endpoint that creates
    resources. There are different options, one of them being to first make the request,
    and then going to the database to check that the resource has been created. Another
    option, the one that we prefer, is to first send the request that creates the
    resource, and then, with the information in the response, send a request to fetch
    the newly created resource. This is preferable, since we are testing only the
    REST API, and we do not need to know the specific schema that the database is
    using. Also, if the REST API changes its database, the tests will keep passing—and
    they should—since we test through the interface only.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'One good example could be borrowing a book. The test should first send a POST
    in order to borrow the book, specifying the book ID, then extract the borrowed
    book ID from the response, and finally send a GET request asking for that borrowed
    book. To save time, you can add the following test to the already existing `tests/BooksTest.php`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the importance of REST APIs in the web world. Now
    you are able not only to use them, but also write your own REST APIs, which has
    turned you into a more resourceful developer. You can also integrate your applications
    with third-party APIs to give more features to your users, and for making your
    websites more interesting and useful.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next and last chapter, we will end this book discovering a type of testing
    other than unit testing: behavioral testing, which improves the quality and reliability
    of your web applications.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
