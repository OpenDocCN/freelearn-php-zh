["```php\npublic function __construct(\n  // The Zend\\Db\\Adapter\\Adapter\n  DbAdapter $zendDb,\n\n  // The table table name to query on\n  $tableName = null,\n\n  // The column that serves as 'username'\n  $identityColumn = null,\n\n  // The column that serves as 'password'\n  $credentialColumn = null,\n\n  // Any optional treatment of the password before \n  // checking, such as MD5(?), SHA1(?), etcetera\n  $credentialTreatment = null\n);\n```", "```php\n<?php\n\nnamespace Application;\n\n// Use the FileResolver, and also the Http \n// authentication adapter.\nuse Zend\\Authentication\\Adapter\\Http\\FileResolver;\nuse Zend\\Authentication\\Adapter\\Http;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass IndexController extends AbstractActionController\n{\n  public function indexAction()\n  {\n    // Create a new FileResolver and read in our file to use \n    // in the Basic authentication\n    $basicResolver = new FileResolver();\n    $basicResolver->setFile(\n      '/some/file/with/credentials.txt'\n    );\n\n    // Now create a FileResolver to read in our Digest file\n    $digestResolver = new FileResolver();\n    $digestResolver->setFile(\n      '/some/other/file/with/credentials.txt'\n    );\n\n    // Options doesn't really matter at this point, we can \n    // fill them in to anything we like\n    $adapter = new Http($options);\n\n    // Now set our DigestResolver/BasicResolver, depending \n    // on our $options set\n    $adapter->setBasicResolver($basicResolver);\n    $adapter->setDigestResolver($digestResolver);\n  }\n}\n```", "```php\nSELECT * FROM `users` WHERE `username` = 'some_user' AND `password` = MD5('some_password');\n```", "```php\nSELECT * FROM `users` WHERE `username` = 'some_user' AND `password` = 'some_password';\n```", "```php\npublic function __construct(array $config);\n```", "```php\nusername:realm:credentials\n```", "```php\nsome_user:My Awesome Realm:clear text password\n```", "```php\npublic function __construct($filename = null, $realm = null, $identity = null, $credential = null);\n```", "```php\npublic function __construct(array $options = array(), $identity = null, $credential = null);\n```", "```php\n// We can assume the rest of the Module class file is \n// exactly the same as the default \n// Application/Module.php file, except of course the \n// namespace.\npublic function onBootstrap(MvcEvent $e)\n{\n  // This is also default    \n  $eventManager = $e->getApplication()->getEventManager();\n  $moduleRouteListener = new ModuleRouteListener();\n  $moduleRouteListener->attach($eventManager);\n  // And now we let the magic happen (this is the bit we \n  // will insert)\n  $eventManager->attach(\n    // We want to attach to the route event, which means   \n    // it happens before our controllers are initialized \n    // (because that would mean we already found the \n    // route)\n    MvcEvent::EVENT_ROUTE,\n\n    // We are using this function as our callback \n    function (MvcEvent $event) \n    {\n     // Get the database adapter from the configuration\n     $dbAdapter = $event->getApplication()\n                         ->getServiceManager()\n                         ->get('db');\n\n     // Our example is an in memory database, so the \n     // table never exists, but better sure than sorry\n     $result = $dbAdapter->query(\"\n             SELECT name \n            FROM sqlite_master \n           WHERE type='table' AND name='users'\n     \")->execute();\n\n      // If we couldn't find a users table, we will \n      // create one now (with an in memory db this is \n      // always the case)\n     if ($result->current() === false) {\n       try {\n         // The user table doesn't exist yet, so let's \n         // just create some sample data\n         $result = $dbAdapter->query(\"\n            CREATE TABLE `users` (\n              `id` INT(10) NOT NULL,\n              `username` VARCHAR(20) NOT NULL,\n              `password` CHAR(32) NOT NULL,\n            PRIMARY KEY (`id`)\n            )\n           \")->execute();\n\n         // Now insert some users\n         $dbAdapter->query(\"\n         INSERT INTO `users` VALUES \n           (1, 'admin', '\". md5(\"adminpassword\"). \"')\n          \")->execute();\n\n         $dbAdapter->query(\"\n           INSERT INTO `users` VALUES \n             (2, 'test', '\". md5(\"testpassword\"). \"')\n             \")->execute();\t\t\n        } catch (\\Exception $e) {\n        \\Zend\\Debug\\Debug::dump($e->getMessage());\n      }\n    }\n  });\n}\n```", "```php\n<?php\n\nreturn array(\n  // Let's initialize the ServiceManager\n  'service_manager' => array(\n    'factories' => array(\n      // Create a Db Adapter on initialization of the \n      // ServiceManager\n      'Zend\\Db\\Adapter\\Adapter' =>\n          'Zend\\Db\\Adapter\\AdapterServiceFactory',\n    ),\n\n    // Let's give this Db Adapter the alias db\n    'aliases' => array(\n      'db' => 'Zend\\Db\\Adapter\\Adapter',\n    ),\n  ),\n\n  // We will now configure our Sqlite database, for \n  // which we only need these two lines\n  'db' => array(\n    'driver' => 'Pdo_Sqlite',\n    'database' => ':memory:',\n  ),\n);\n```", "```php\n<?php\n\n// Set the namespace\nnamespace Authentication\\Service;\n\nuse Zend\\ServiceManager\\ServiceLocatorAwareInterface;\n\n// We give this one an alias, because otherwise \n// DbTable might confuse us in thinking that it is  \n// an actual db table\nuse Zend\\Authentication\\Adapter\\DbTable as AuthDbTable;\nuse Zend\\Authentication\\Storage\\Session;\n\n// We want to make a service, so we implement the \n// ServiceLocatorAwareInterface for that as well\nclass Authentication implements ServiceLocatorAwareInterface\n{\n  // Storage for our service locator\n  private $servicelocator;\n\n  // Get the ServiceManager\n  public function getServiceLocator() \n  {\n    return $this->servicelocator;\n  }\n\n  // Set the ServiceManager\n  public function setServiceLocator(\\Zend\\ServiceManager\\ServiceLocatorInterface $serviceLocator) \n  {\n    $this->servicelocator = $serviceLocator;\n  }\n```", "```php\n  /**\n   * Lets us know if we are authenticated or not.\n   * \n   * @return boolean\n   */\n  public function isAuthenticated()\n  {\n    // Check if the authentication session is empty, if \n    // not we assume we are authenticated\n    $session = new Session();\n\n    // Return false if the session IS empty, and true if \n    // the session ISN'T empty\n    return !$session->isEmpty();\n  }\n```", "```php\n  /**\n   * Authenticates the user against the Authentication \n   * adapter.\n   * \n   * @param string $username\n   * @param string $password\n   * @return boolean\n   */\n  public function authenticate($username, $password)\n  {\n    // Create our authentication adapter, and set our \n    // DbAdapter (the one we created before) by getting \n    // it from the ServiceManager. Also tell the adapter \n    // to use table 'users', where 'username' is the \n    // identity and 'password' is the credential column\n    $authentication = new AuthDbTable(\n      $this->getServiceLocator()->get('db'),\n      'users',\n      'username',\n      'password'\n    );\n\n    // We use md5 in here because SQLite doesn't have \n    // any functionality to encrypt strings\n    $result = $authentication->setIdentity($username)\n                             ->setCredential(md5($password))\n                             ->authenticate();\n\n    // Check if we are successfully authenticated or not\n    if ($result->isValid() === true) {\n      // Now save the identity to the session\n      $session = new Session();\n      $session->write($result->getIdentity());\n    }\n\n    return $result->isValid();\n  }\n```", "```php\n  /**\n   * Gets the identity of the user, if available, \n   * otherwise returns false.\n   * @return array\n   */\n  public function getIdentity()\n  {\n    // Clear out the session, we are done here\n    $session = new Session();\n\n    // Check if the session is empty, if not return the \n    // identity of the logged in user\n    if ($session->isEmpty() === false) {\n      return $session->read();\n    } else {\n      return false;\n    }\n  }\n```", "```php\n  /**\n   * Logs the user out by clearing the session.\n   */\n  public function logout()\n  {\n    // Clear out the session, we are done here\n    $session = new Session();\n    $session->clear();\n  }\n\n  // This is our last method, close the bracket for the \n  // class as well!\n}\n```", "```php\n<?php\nreturn array(\n  'service_manager' => array(\n    // [The rest of the service manager configuration \n    // comes here]\n\n    // And our new invokable can be put here\n    'invokables' => array(\n    'AuthService' => 'Authentication\\Service\\Authentication',\n    ),\n  ),\n);\n```", "```php\n<?php\nreturn array(\n  // [The configuration that we have now resides here..]\n\n  // And our route configuration comes here..\n  'router' => array(\n    'routes' => array(\n      'authentication' => array(\n        'type'    => 'Literal',\n        'options' => array(\n          'route'    => '/authentication',\n          'defaults' => array(\n          '__NAMESPACE__' => \n                  'Authentication\\Controller',\n          'controller'    => 'Index',\n          'action'        => 'login',\n        ),\n      ),\n      'may_terminate' => true,\n      'child_routes' => array(\n        'default' => array(\n          'type'    => 'Segment',\n          'options' => array(\n            'route'    => '[/:action]',\n            'constraints' => array(\n              'action'     => '[a-zA-Z][a-zA-Z0-9_-]*',\n            ),\n            'defaults' => array(),\n          ),\n        ),\n      ),\n    ),\n  ),\n),\n\n// Make our controller invokable\n'controllers' => array(\n  'invokables' => array(\n    'Authentication\\Controller\\Index' =>   \n          'Authentication\\Controller\\IndexController'\n    ),\n  ),\n\n  // Make sure our template path is set correctly\n  'view_manager' => array(\n    'template_path_stack' => array(\n      __DIR__ . '/../view',\n    ),\n  ),\n\n);\n```", "```php\n<?php\n\nnamespace Authentication\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass IndexController extends AbstractActionController\n{\n}\n```", "```php\npublic function logoutAction()\n{\n  // Log out the user\n  $this->getServiceLocator()\n       ->get('AuthService')\n       ->logout();\n\n  // Redirect the user back to the login screen\n  $this->redirect()\n       ->toRoute('authentication');\n}\n```", "```php\npublic function loginAction()\n{\n  // See if we are trying to authenticate\n  if ($this->params()->fromPost('username') !== null) {\n    // Try to authenticate with our post variables from \n    // the form we just send\n    $done = $this->getServiceLocator()\n                 ->get('AuthService')\n                 ->authenticate(\n        $this->params()->fromPost('username'),\n        $this->params()->fromPost('password')\n    );\n\n    if ($done === true) {\n      $this->redirect()\n           ->toRoute('application');\n    } else {\n      \\Zend\\Debug\\Debug::dump(\n        \"Username/password unknown!\"\n      );\n    }\n  }\n\n  // On an unsuccessful attempt or just a get request \n  // show the form.\n  return new ViewModel();\n}\n```", "```php\n<form action=\"/authentication\" method=\"post\">\n  <label for=\"username\">Username:</label>\n  <input type=\"text\" name=\"username\" />\n\n  <label for=\"password\">Password:</label>\n  <input type=\"password\" name=\"password\" />\n\n  <button type=\"submit\">Login</button>\n</form>\n```", "```php\npublic function onBootstrap(MvcEvent $e)\n{\n  // Get the event manager from the event\n  $eventManager = $e->getApplication()->getEventManager();\n\n  // Attach the module route listeners\n  $moduleRouteListener = new ModuleRouteListener();\n  $moduleRouteListener->attach($eventManager);\n\n  // Do this event when dispatch is triggered, on the \n  // highest priority (1)\n  $eventManager->attach(\n      MvcEvent::EVENT_DISPATCH, \n      function (MvcEvent $event) {\n      // We don't have to redirect if we are in a \n      // 'public' area, so don't even try\n      if ($event->getRouteMatch()->getMatchedRouteName() \n                  === 'authentication') return;\n\n      // See if we are authenticated, if not lets \n      // redirect to our login page\n      if ($event->getApplication()->getServiceManager()\n                ->get('AuthService')->isAuthenticated() === \n          false) \n      {\n        // Get the response from the event\n        $response = $event->getResponse();\n\n        // Clear current headers and add our Location \n        // redirection\n        $response->getHeaders()\n                 ->clearHeaders()\n                 ->addHeaderLine(\n             'Location', '/authentication'\n        );\n\n        // Set the status code to redirect\n        $response->setStatusCode(302)\n                 ->sendHeaders();\n\n        // Don't forget to exit the application, as we \n        // don't want anything to overrule at this point\n        exit;\n      }\n  }, \n\n  // Give this event priority 1\n  1);\n}\n```", "```php\n# Only execute the following code when mod_ssl is \n# enabled\n<IfModule mod_ssl.c>\n  # This means the client can present their \n  # certificate, but it doesn't need to be verifiable \n  # by the server\n  SSLVerifyClient optional_no_ca\n\n  # This depth means the certificate can only be self-\n  # signed otherwise it will be denied\n  SSLVerifyDepth 0\n\n  # We want to export the standard variables but also \n  # the certificate data as well to use in PHP\n  SSLOptions +StdEnvVars +ExportCertData \n</IfModule>\n```", "```php\n// Set the right namespace\nnamespace Authentication\\Adapter;\n\n// We will use this to implement the right methods\nuse Zend\\Authentication\\Adapter\\AdapterInterface;\n\n// Out class name, not to forget the implementation\nclass Certificate implements AdapterInterface\n{\n  // Currently authenticate is the only method required \n  // for the AdapterInterface; lucky us!\n  public function authenticate() {}\n}\n```", "```php\n// After coding the adapter we found the following \n// errors that need to be relayed to the user/developer\n\n// Invalid certificate, there is no certificate set\nconst AUTH_FAIL_INV_CERT = 0;\n\n// Insecure connection, no HTTPS\nconst AUTH_FAIL_NO_HTTPS = 1;\n\n// Couldn't parse the certificate, invalid certificate\nconst AUTH_FAIL_PARSE_CERT = 2;\n\n// Certificate is expired\nconst AUTH_FAIL_EXP_CERT = 3;\n\n// Not all the required fields we need are in the \n// certificate, thus rendering it invalid\nconst AUTH_FAIL_NOT_ALL_FIELDS = 4;\n\n// No Database adapter was provided\nconst AUTH_FAIL_NO_DB_ADAPTER = 5;\n\n// An error occurred in the SQL\nconst AUTH_FAIL_SQL_ERR = 6;\n\n// The user requested couldn't be found\nconst AUTH_FAIL_NO_USER = 7;\n\n// By default we have no error\nprivate $error = -1;\n```", "```php\n/**\n * Sets an error.\n * \n * @param int $error\n */\nprivate function setError($error) \n{\n  $this->error = $error;\n}\n```", "```php\n/**\n * Gets the latest error message back.\n * \n * @return string\n */\npublic function getErrorMessage() \n{\n  switch ($this->error) {\n    case self::AUTH_FAIL_SQL_ERR:\n      $retval = \"SQL error occurred while checking \" \n              . \"for the user.\";\n      break;\n    case self::AUTH_FAIL_INV_CERT:\n      $retval = \"Certificate provided is invalid.\";\n      break;\n    case self::AUTH_FAIL_PARSE_CERT:\n      $retval = \"Certificate provided couldn't be \"\n              . \"parsed.\";\n      break;\n    case self::AUTH_FAIL_EXP_CERT:\n      $retval = \"Certificate has expired.\";\n      break;\n    case self::AUTH_FAIL_NO_DB_ADAPTER:\n      $retval = \"No Database adapter set.\";\n      break;\n    case self::AUTH_FAIL_NOT_ALL_FIELDS:\n      $retval = \"Not all the fields required are \" \n              . \"available.\";\n      break;\n    case self::AUTH_FAIL_NO_USER:\n      $retval = \"The user could not be found.\";\n      break;\n    case self::AUTH_FAIL_NO_HTTPS:\n      $retval = \"Connection is not secure.\";\n      break;\n    case -1:\n      $retval = \"No error occurred.\";\n      break;\n    default:\n      $retval = \"Unknown error occurred.\";\n      break;\n  }\n\n  // Reset the error\n  $this->error = -1;\n\n  // Return the string with the error message\n  return $retval;\n}\n```", "```php\n/**\n * Returns true if the current connection is through \n * HTTPS.\n * \n * @return boolean\n */\nprivate function isHTTPS()\n{\n  return isset($_SERVER['HTTPS']) ? true : false;\n} \n```", "```php\n// This property will store our certificate array\nprivate $certificate;\n\n/**\n * Sets (and parses) a certificate, returns false if the \n * certificate couldn't be parsed.\n * \n * @param string $certificateContent\n * @return boolean\n */\npublic function setCertificate($certificateContent) \n{\n  // This function is part of the OpenSSL extension in \n  // PHP. This means that if OpenSSL is not installed \n  // into PHP this function will not exist and thus give \n  // a fatal error. This function deciphers the \n  // information received in the certificate to a great \n  // array with variables.\n  $certificate = openssl_x509_parse(\n               $certificateContent\n  );\n\n  // If the certificate can't be parsed (i.e. it is \n  // invalid) the function above will return false\n  if ($certificate !== false) {\n    // We can be sure the certificate is valid at least \n    // in raw state now\n    $this->certificate = $certificate;\n\n    // Done here\n    return true;\n  } else {\n    // Use the failure to parse certificate here to make \n    // sure the developer/user will know what is going \n    // on\n    $this->setError(self::AUTH_FAIL_PARSE_CERT);\n    return false;\n  }\n}\n```", "```php\n/**\n * Checks if all our fields (issuer, issuer[O], \n * issuer[CN], issuer[emailAddress], serialNumber) are \n * in the certificate.\n * \n * @return boolean\n */\nprivate function checkRequiredFields()\n{\n  // First get our certificate\n  $certificate = $this->getCertificate();\n\n  // Check if our certificate at least is valid\n  if ($certificate !== false) {\n    // We want to check if the following fields (and \n    // subfields) are in the certificate\n    $required = array(\n      'issuer' => array('O', 'CN', 'emailAddress'), \n      'serialNumber' => null\n    );\n\n    // Loop through the primary fields\n    foreach ($required as $field=>$value) {\n      if (in_array($field, $certificate) === true) {\n        // The primary field is in there, check if \n        // there are any secondary fields we need to \n        // check\n        if (is_array($value && is_array($certificate[$field) {\n          // Loop through the secondary fields\n          foreach ($value as $key) {\n            // Now check of our values are in there\n            if (in_array(\n              $key, \n              array_keys(\n                $certificate[$field])) === false) \n              {\n                return false;\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n      }\n\n      // If we reach this point, we are always ok to go\n      $retval = true;\n\n      unset($required);\n    }\n\n  unset($certificate);\n\n  return isset($retval) ? $retval : false;\n}\n```", "```php\n/**\n * Checks if the current certificate is valid or not.\n * \n * @return boolean\n */\nprivate function isCertificateValid()\n{\n  // Get our certificate again\n  $certificate = $this->getCertificate();\n\n  // Again make sure it is not false (highly unlikely \n  // here, but hey, never be sure\n  if ($certificate !== false) {\n    // Check if the valid from and to fields are set, \n    // because if they are not, we won't be able to \n    // check if the certificate is valid or not\n    if (isset($certificate['validFrom_time_t']) === true && isset($certificate['validTo_time_t']) === true)  \n    { \n      // Check if the from time is smaller than our \n      // current time and the to time is bigger than the \n      // current time\n    if (time() >= $certificate['validFrom_time_t'] && time() < $certificate['validTo_time_t']) \n      {\n        $retval = true;\n      }\n    }\n  }\n\n  unset($certificate);\n\n  return isset($retval) ? $retval : false;\n}\n```", "```php\n/**\n * Our Database adapter property.\n * \n * @var \\Zend\\Db\\Adapter\\Adapter\n */\nprivate $dbAdapter;\n\n/**\n * Sets the Db adapter.\n *\t\n * @param \\Zend\\Db\\Adapter\\Adapter $db\n */\npublic function setDbAdapter(\\Zend\\Db\\Adapter\\Adapter $db) \n{\n  $this->dbAdapter = $db;\n}\n\n/**\n * Returns the Db adapter.\n * \n * @return \\Zend\\Db\\Adapter\\Adapter\n */\nprivate function getDbAdapter()\n{\n  return $this->dbAdapter;\n}\n```", "```php\n// We will store our identity in here, once \n// authenticated\nprivate $identity;\n\n/**\n * Retrieves a variable from the certificate, returns \n * null if not found.\n * \n * @param string $variable\n * @return string\n */\nprivate function getCertificateVariable($variable)\n{\n  if (is_array($this->certificate) === true && isset($this->certificate[$variable]) === true) \n  {\n    return $this->certificate[$variable];\n  } else if (is_array($this->certificate) === true && isset($this->certificate['issuer'][$variable) \n  {\n    return $this->certificate['issuer'][$variable];\n  } else {\n    return null;\n  }\n}\n\n/**\n * Retrieves the identity of the user.\n * \n * @return array\n */\npublic function getIdentity() \n{\n  return $this->identity;\n}\n```", "```php\n/**\n * Tries to authenticate the user through the \n * certificate.\n * \n * @return boolean\n */\npublic function authenticate() \n{\n  $continue = true;\n\n  if ($this->getDbAdapter() !== null) {\n    // Check if we are on a secure connection\n    if ($this->isHTTPS() === true) {\n      // Check if the certificate is valid\n      if ($this->getCertificate() !== false) {\n        // Check if the fields we require are available\n        if ($this->checkRequiredFields() === true) {\n          // Check if the certificate isn't expired\n          if ($this->isCertificateValid() === false) {\n            // Certificate is expired!\n            $this->setError(self::AUTH_FAIL_EXP_CERT);\n            $continue = false;\n          }\n        } else {\n          // Not all the fields are available\n          $this->setError(\n              self::AUTH_FAIL_NOT_ALL_FIELDS\n          );\n          $continue = false;\n        }\n      } else {\n        // This is an invalid certificate\n        $this->setError(self::AUTH_FAIL_INV_CERT);\n        $continue = false;\n      }\n    } else {\n      // Oh, oh, no secure connection\n      $this->setError(self::AUTH_FAIL_NO_HTTPS);\n      $continue = false;\n    }\n  } else {\n    // We don't have a db adapter\n    $this->setError(self::AUTH_FAIL_NO_DB_ADAPTER);\n    $continue = false;\n  }\n\n  if ($continue === true) {\n    // Now we are going to check with the database if \n    // the email address is in there\n    $statement = $this->getDbAdapter()->createStatement(\n      \"SELECT * FROM users WHERE email = :email\"\n    );\n\n    try { \n      // Input the email address in the statement and \n      // execute it on the database adapter\n      $result = $statement->execute(array(\n        'email' => $this->getCertificateVariable(\n            'emailAddress'\n        )\n      ));\n\n      // Check if we have one result\n      if ($result->count() === 1) {\n        // One result found, put it in the identity kit\n        $this->identity = $result->current();\n\n        // Because we are super-cool add some of our \n        // certificate variables as well\n        $this->identity['serialNumber'] = \n          $this->getCertificateVariable('serialNumber');\n\n        $this->identity['organization'] = \n          $this->getCertificateVariable('O');\n\n        $this->identity['commonName'] = \n          $this->getCertificateVariable('CN');\n\n        // We successfully found our user\n        $retval = true;\n      } else {\n        $this->setError(self::AUTH_FAIL_NO_USER);\n      }\n    } catch (\\Exception $e) {\n      $this->setError(self::AUTH_FAIL_SQL_ERR);\n      error_log($e->getMessage());\n    }\n  }\n\n  // Return the retval is we have one, otherwise just \n  // false\n  return isset($retval) ? $retval : false;\n}\n```"]