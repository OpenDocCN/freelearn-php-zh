- en: Chapter 4. Creating Clean Code with OOP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：使用OOP创建整洁的代码
- en: When applications start growing, representing more complex data structures becomes
    necessary. Primitive types like integers, strings, or arrays are not enough when
    you want to associate specific behavior to data. More than half a century ago,
    computer scientists started using the concept of objects to refer to the encapsulation
    of properties and functionality that represented an object in real life.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序开始增长，表示更复杂的数据结构变得必要。当你想要将特定行为与数据关联时，原始类型如整数、字符串或数组就不够了。半个多世纪以前，计算机科学家开始使用对象的概念来指代在现实生活中表示属性和功能封装的概念。
- en: Nowadays, OOP is one of the most used programming paradigms, and you will be
    glad to know that PHP supports it. Knowing OOP is not just a matter of knowing
    the syntax of the language, but knowing when and how to use it. But do not worry,
    after this chapter and a bit of practice, you will become a confident OOP developer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，面向对象编程（OOP）是使用最广泛的编程范式之一，你可能会很高兴地知道PHP支持它。了解OOP不仅仅是了解语言的语法，而是了解何时以及如何使用它。但不要担心，在本章和一些实践之后，你将成为一个自信的OOP开发者。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Classes and objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和对象
- en: Visibility, static properties, and methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可见性、静态属性和方法
- en: Namespaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Autoloading classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动加载类
- en: Inheritance, interfaces, and traits
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承、接口和特性
- en: Handling exceptions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异常
- en: Design patterns
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式
- en: Anonymous functions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数
- en: Classes and objects
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和对象
- en: '**Objects** are representations of real-life elements. Each object has a set
    of attributes that differentiates it from the rest of the objects of the same
    class, and is capable of a set of actions. A **class** is the definition of what
    an object looks like and what it can do, like a pattern for objects.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象**是现实生活元素的表示。每个对象都有一些属性，这些属性将其与其他相同类的其他对象区分开来，并且能够执行一系列操作。**类**是定义对象外观和功能的定义，就像对象的模式一样。'
- en: 'Let''s take our bookstore example, and think of the kind of real-life objects
    it contains. We store books, and let people take them if they are available. We
    could think of two types of objects: books and customers. We can define these
    two classes as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以我们的书店为例，并思考它包含的真实的对象类型。我们存储书籍，并允许人们在它们可用时取走它们。我们可以考虑两种类型的对象：书籍和客户。我们可以定义这两个类如下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A class is defined by the keyword `class` followed by a valid class name—that
    follows the same rules as any other PHP label, like variable names—and a block
    of code. But if we want to have a specific book, that is, an object `Book`—or
    instance of the class `Book`—we have to instantiate it. To instantiate an object,
    we use the keyword `new` followed by the name of the class. We assign the instance
    to a variable, as if it was a primitive type:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 类是通过关键字`class`定义的，后跟一个有效的类名——它遵循任何其他PHP标签（如变量名）的相同规则，以及一段代码块。但如果我们想要一个特定的书籍，即对象`Book`——或者`Book`类的实例——我们必须实例化它。要实例化一个对象，我们使用关键字`new`后跟类名。我们将实例分配给一个变量，就像它是一个原始类型一样：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can create as many instances as you need, as long as you assign them to
    different variables:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建你需要的任何数量的实例，只要将它们分配给不同的变量：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Class properties
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类属性
- en: 'Let''s think about the properties of books first: they have a title, an author,
    and an ISBN. They can also be available or unavailable. Write the following code
    inside `Book.php`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们思考一下书籍的特性：它们有一个标题、一个作者和一个ISBN。它们也可以是可用或不可用的。请在`Book.php`文件内编写以下代码：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Printing the object shows the value of each of its properties, in a way similar
    to the way arrays do with their keys. You can see that properties have a type
    at the moment of printing, but we did not define this type explicitly; instead,
    the variable took the type of the value assigned. This works exactly the same
    way that normal variables do.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 打印对象会显示其每个属性的值，方式类似于数组打印其键的方式。你可以看到属性在打印时有一个类型，但我们没有明确定义这个类型；相反，变量取了分配的值的类型。这正好与正常变量一样工作。
- en: 'When creating multiple instances of an object and assigning values to their
    properties, each object will have their own values, so you will not override them.
    The next bit of code shows you how this works:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建多个对象实例并为其属性赋值时，每个对象将有自己的值，因此你不会覆盖它们。下面的代码片段展示了这是如何工作的：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Class methods
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类方法
- en: '**Methods** are functions defined inside a class. Like functions, methods get
    some arguments and perform some actions, optionally returning a value. The advantage
    of methods is that they can use the properties of the object that invoked them.
    Thus, calling the same method in two different objects might have two different
    results.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法**是在类内部定义的函数。像函数一样，方法接收一些参数并执行一些操作，可选地返回一个值。方法的优势在于它们可以使用调用它们的对象的属性。因此，在两个不同的对象中调用相同的方法可能会有两个不同的结果。'
- en: 'Even though it is usually a bad idea to mix HTML with PHP, for the sake of
    learning, let''s add a method in our class `Book` that returns the book as in
    our already existing function `printableTitle`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常将HTML与PHP混合使用不是一个好主意，但为了学习的目的，让我们在我们的`Book`类中添加一个方法，该方法返回书籍，就像我们已存在的`printableTitle`函数一样：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As with properties, we add the keyword `public` at the beginning of the function,
    but other than that, the rest looks just as a normal function. The other special
    bit is the use of `$this`: it represents the object itself, and allows you to
    access the properties and methods of that same object. Note how we refer to the
    title, author, and available properties.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与属性一样，我们在函数的开始处添加关键字`public`，但除此之外，其余部分看起来就像一个普通函数。另一个特殊之处在于使用`$this`：它代表对象本身，允许你访问该对象的属性和方法。注意我们是如何引用标题、作者和可用的属性的。
- en: 'You can also update the values of the current object from one of its functions.
    Let''s use the available property as an integer that shows the number of units
    available instead of just a Boolean. With that, we can allow multiple customers
    to borrow different copies of the same book. Let''s add a method to give one copy
    of a book to a customer, updating the number of units available:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过其函数之一更新当前对象的价值。让我们使用可用的属性作为一个整数，显示可用的单位数量，而不是仅仅是一个布尔值。有了这个，我们可以允许多个客户借阅同一本书的不同副本。让我们添加一个方法，给客户一本书的副本，更新可用的单位数量：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this preceding method, we first check if we have at least one available
    unit. If we do not, we return `false` to let them know that the operation was
    not successful. If we do have a unit for the customer, we decrease the number
    of available units, and then return `true`, letting them know that the operation
    was successful. Let''s see how you can use this class:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个先前的方法中，我们首先检查我们是否至少有一个可用的单位。如果没有，我们返回`false`以让他们知道操作未成功。如果我们有客户的一个单位，我们减少可用的单位数量，然后返回`true`，让他们知道操作成功。让我们看看如何使用这个类：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What would this last piece of code print? Exactly, **Here, your copy.** But
    what would be the value of the property available? It would be 11, which is the
    result of the invocation of `getCopy`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会打印什么？正是，**这里，你的副本**。但是属性`available`的值会是什么？它将是11，这是`getCopy`调用的结果。
- en: Class constructors
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类构造函数
- en: 'You might have noticed that it looks like a pain to instantiate the `Book`
    class, and set all its values each time. What if our class has 30 properties instead
    of four? Well, hopefully, you will never do that, as it is very bad practice.
    Still, there is a way to mitigate that pain: **constructors**.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，实例化`Book`类并设置所有值似乎很麻烦。如果我们类的属性有30个而不是4个呢？好吧，希望你永远不会这样做，因为这非常不好。尽管如此，有一种方法可以减轻这种痛苦：**构造函数**。
- en: 'Constructors are functions that are invoked when someone creates a new instance
    of the class. They look like normal methods, with the exception that their name
    is always `__construct`, and that they do not have a `return` statement, as they
    always have to return the new instance. Let''s see an example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是在创建类的新实例时调用的函数。它们看起来像普通方法，但它们的名称总是`__construct`，并且它们没有`return`语句，因为它们总是必须返回新实例。让我们看看一个例子：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The constructor takes four arguments, and then assigns the value of one of
    the arguments to each of the properties of the instance. To instantiate the `Book`
    class, we use the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接收四个参数，然后将其中一个参数的值分配给实例的每个属性。要实例化`Book`类，我们使用以下方法：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This object is exactly the same as the object when we set the value to each
    of its properties manually. But this one looks cleaner, right? This does not mean
    you cannot set new values to this object manually, it just helps you in constructing
    new objects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象与我们手动设置每个属性值的对象完全相同。但这个看起来更干净，对吧？这并不意味着你不能手动设置这个对象的新值，它只是帮助你构建新的对象。
- en: 'As a constructor is still a function, it can use default arguments. Imagine
    that the number of units will usually be 0 when creating the object, and later,
    the librarian will add units when available. We could set a default value to the
    `$available` argument of the constructor, so if we do not send the number of units
    when creating the object, the object will be instantiated with its default value:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构造函数仍然是函数，因此它可以使用默认参数。想象一下，在创建对象时，单位数量通常为0，然后图书管理员会在有可用时添加单位。我们可以将默认值设置为构造函数的`$available`参数，这样如果我们创建对象时不发送单位数量，对象将以默认值实例化：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We could use the preceding constructor in two different ways:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面的构造函数以两种不同的方式：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`$book1` will set the number of units available to `12`, whereas `$book2` will
    set it to the default value of 0\. But do not trust me; try it by yourself!'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`$book1`将设置可用的单位数量为`12`，而`$book2`将设置为默认值0。但不要相信我；自己试试看！'
- en: Magic methods
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 魔法方法
- en: 'There is a special group of methods that have a different behavior than the
    normal ones. Those methods are called **magic methods**, and they usually are
    triggered by the interaction of the class or object, and not by invocations. You
    have already seen one of them, the constructor of the class, `__construct`. This
    method is not invoked directly, but rather used when creating a new instance with
    `new`. You can easily identify magic methods, because they start with `__`. The
    following are some of the most used magic methods:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊的方法组，它们的行为与普通方法不同。这些方法被称为**魔法方法**，它们通常是由类或对象的交互触发的，而不是由调用触发的。您已经看到了其中之一，即类的构造函数`__construct`。此方法不是直接调用的，而是在使用`new`创建新实例时使用的。您可以通过它们以`__`开头轻松识别魔法方法。以下是一些最常用的魔法方法：
- en: '`__toString`: This method is invoked when we try to cast an object to a string.
    It takes no parameters, and it is expected to return a string.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__toString`: 当我们尝试将对象转换为字符串时，将调用此方法。它不接受任何参数，并期望返回一个字符串。'
- en: '`__call`: This is the method that PHP calls when you try to invoke a method
    on a class that does not exist. It gets the name of the method as a string and
    the list of parameters used in the invocation as an array, through the argument.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__call`: 这是当您尝试在不存在的方法的类上调用方法时，PHP调用的方法。它通过参数获取方法名称作为字符串和调用中使用的参数列表作为数组。'
- en: '`__get`: This is a version of `__call` for properties. It gets the name of
    the property that the user was trying to access through parameters, and it can
    return anything.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__get`: 这是`__call`属性版本。它通过参数获取用户试图通过属性访问的名称，并且可以返回任何内容。'
- en: 'You could use the `__toString` method to replace the current `getPrintableTitle`
    method in our `Book` class. To do that, just change the name of the method as
    follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`__toString`方法替换我们`Book`类中的当前`getPrintableTitle`方法。为此，只需按以下方式更改方法名称：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As the name suggests, those are magic methods, so most of the time their features
    will look like magic. For obvious reasons, we personally encourage developers
    to use constructors and maybe `__toString`, but be careful about when to use the
    rest, as you might make your code quite unpredictable for people not familiar
    with it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，这些是魔法方法，所以它们的功能大多数时候看起来像魔法。出于明显的原因，我们个人鼓励开发者使用构造函数以及可能`__toString`，但请注意何时使用其余部分，因为您可能会使您的代码对不熟悉它的人来说非常不可预测。
- en: Properties and methods visibility
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性和方法可见性
- en: 'So far, all the properties and methods defined in our `Book` class were tagged
    as `public`. That means that they are accessible to anyone, or more precisely,
    from anywhere. This is called the **visibility** of the property or method, and
    there are three types of visibility. In the order of being more restrictive to
    less, they are as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在`Book`类中定义的所有属性和方法都被标记为`public`。这意味着它们对任何人或更确切地说，从任何地方都是可访问的。这被称为属性或方法的**可见性**，并且有三种类型的可见性。从更严格到更宽松的顺序如下：
- en: '`private`: This type allows access only to members of the same class. If A
    and B are instances of the class C, A can access the properties and methods of
    B.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`: 此类型允许只有同一类的成员可以访问。如果A和B是类C的实例，A可以访问B的属性和方法。'
- en: '`protected`: This type allows access to members of the same class and instances
    from classes that inherit from that one only. You will see inheritance in the
    next section.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected`: 此类型允许同一类的成员和从该类继承的类的实例访问。您将在下一节中看到继承。'
- en: '`public`: This type refers to a property or method that is accessible from
    anywhere. Any classes or code in general from outside the class can access it.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`：此类指代一个可以从任何地方访问的属性或方法。任何来自类外部的类或一般代码都可以访问它。'
- en: 'In order to show some examples, let''s first create a second class in our application.
    Save this into a `Customer.php` file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示一些示例，让我们首先在我们的应用程序中创建第二个类。将其保存到`Customer.php`文件中：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This class represents a customer, and its properties consist of the general
    information that the bookstores usually know about their customers. But for security
    reasons, we cannot let everybody know about the personal data of our customers,
    so we set every property as `private`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类代表一个客户，其属性包括书店通常了解的客户的一般信息。但出于安全原因，我们不能让每个人都了解我们客户的个人信息，所以我们把每个属性都设置为`private`。
- en: So far, we have been adding the code to create objects in the same `Book.php`
    file, but since now we have two classes, it seems natural to leave the classes
    in their respective files, and create and play with objects in a separate file.
    Let's name this third file `init.php`. In order to instantiate objects of a given
    class, PHP needs to know where the class is. For that, just include the file with
    `require_once`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在同一个`Book.php`文件中添加创建对象的代码，但既然现在有两个类，似乎很自然地让这些类留在各自的文件中，并在一个单独的文件中创建和操作对象。让我们把这个第三个文件命名为`init.php`。为了实例化给定类的对象，PHP需要知道类在哪里。为此，只需使用`require_once`包含该文件即可。
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You do not need to include the files every single time. Once you include them,
    PHP will know where to find the classes, even though your code is in a different
    file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要每次都包含文件。一旦你包含了它们，PHP就会知道在哪里找到类，即使你的代码在不同的文件中。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Conventions for classes**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**类的约定**'
- en: 'When working with classes, you should know that there are some conventions
    that everyone tries to follow in order to ensure clean code which is easy to maintain.
    The most important ones are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当与类一起工作时，你应该知道有一些约定，每个人都试图遵循以确保代码整洁且易于维护。其中最重要的如下：
- en: Each class should be in a file named the same as the class along with the `.php`
    extension
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个类都应该在一个与类名相同的文件中，并带有`.php`扩展名
- en: Class names should be in CamelCase, that is, each word should start with an
    uppercase letter, followed by the rest of the word in lowercase
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名应该使用驼峰式命名法，即每个单词的首字母大写，其余部分小写
- en: A file should contain only the code of one class
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文件应该只包含一个类的代码
- en: Inside a class, you should first place the properties, then the constructor,
    and finally, the rest of the methods
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类内部，你应该首先放置属性，然后是构造函数，最后是其他方法
- en: 'To show how visibility works, let''s try the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示可见性是如何工作的，让我们尝试以下代码：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We already know that the properties of the `Book` class' objects are public,
    and therefore, editable from outside. But when trying to change a value from `Customer`,
    PHP complains, as its properties are private.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道`Book`类对象的属性是公开的，因此可以从外部编辑。但当我们尝试从`Customer`中更改值时，PHP会抱怨，因为它的属性是私有的。
- en: Encapsulation
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装
- en: When working with objects, one of the most important concepts you have to know
    and apply is **encapsulation**. Encapsulation tries to group the data of the object
    with its methods in an attempt to hide the internal structure of the object from
    the rest of the world. In simple words, you could say that you use encapsulation
    if the properties of an object are private, and the only way to update them is
    through public methods.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当与对象一起工作时，你必须知道并应用的一个重要概念是**封装**。封装试图将对象的数据与其方法组合在一起，以尝试隐藏对象的内部结构。简单来说，如果你说一个对象的属性是私有的，并且唯一更新它们的方式是通过公共方法，那么你就是在使用封装。
- en: The reason for using encapsulation is to make it easier for a developer to make
    changes to the internal structure of the class without directly affecting the
    external code that uses that class. For example, imagine that our `Customer` class,
    that now has two properties to define its name—`firstname` and `surname`—has to
    change. From now on, we only have one property name that contains both. If we
    were accessing its properties straightaway, we should change all of those accesses!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用封装的原因是为了让开发者更容易修改类的内部结构，而不会直接影响到使用该类的外部代码。例如，想象一下我们的`Customer`类，现在有两个属性来定义其姓名——`firstname`和`surname`——需要更改。从现在起，我们只有一个包含两者的属性名。如果我们直接访问其属性，我们应该更改所有这些访问！
- en: Instead, if we set the properties as private and enable two public methods,
    `getFirstname` and `getSurname`, even if we have to change the internal structure
    of the class, we could just change the implementation of those two methods—which
    is at one place only—and the rest of the code that uses our class will not be
    affected at all. This concept is also known as **information hiding**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果我们把属性设置为私有，并启用两个公共方法，`getFirstname`和`getSurname`，即使我们必须更改类的内部结构，我们也可以只更改这两个方法的实现——这只有一个地方——而使用我们类的其余代码将不会受到影响。这个概念也被称为**信息隐藏**。
- en: 'The easiest way to implement this idea is by setting all the properties of
    the class as private and enabling two methods for each of the properties: one
    will get the current value (also known as **getter**), and the other will allow
    you to set a new value (known as **setter**). That''s at least the most common
    and easy way to encapsulate data.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个想法的最简单方法是将类的所有属性都设置为私有，并为每个属性启用两个方法：一个将获取当前值（也称为**获取器**），另一个将允许你设置新值（称为**设置器**）。这至少是最常见和简单的方法来封装数据。
- en: 'But let''s go one step further: when defining a class, think of the data that
    you want the user to be able to change and to retrieve, and only add setters and
    getters for them. For example, customers might change their e-mail address, but
    their name, surname, and ID remains the same once we create them. The new definition
    of the class would look like the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们更进一步：在定义一个类时，考虑你想让用户能够更改和检索的数据，并且只为它们添加设置器和获取器。例如，客户可能会更改他们的电子邮件地址，但一旦创建，他们的名字、姓氏和ID就保持不变。类的新的定义如下所示：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On the other hand, our books also remain almost the same. The only change possible
    is the number of available units. But we usually take or add one book at a time
    instead of setting the specific number of units available, so a setter here is
    not really useful. We already have the `getCopy` method that takes one copy when
    possible; let''s add an `addCopy` method, plus the rest of the getters:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们的书籍几乎保持不变。唯一可能的变化是可用的单元数量。但我们通常一次拿或添加一本书，而不是设置具体的单元数量，因此这里的设置器并不是很有用。我们已经有了一个`getCopy`方法，当可能时取一个副本；让我们添加一个`addCopy`方法，以及其余的获取器：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the number of classes in your application, and with it, the number of
    relationships between classes increases, it is helpful to represent these classes
    in a diagram. Let''s call this diagram a UML diagram of classes, or just an hierarchic
    tree. The hierarchic tree for our two classes would look as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序中的类数量以及随之而来的类之间的关系数量增加时，将这些类以图表的形式表示出来是有帮助的。我们可以称这个图表为类的UML图，或者简单地称为层次树。我们两个类的层次树看起来如下所示：
- en: '![Encapsulation](img/00016.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![封装](img/00016.jpeg)'
- en: We only show public methods, as the protected or private ones cannot be called
    from outside the class, and thus, they are not useful for a developer who just
    wants to use these classes externally.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只显示公共方法，因为受保护的或私有的方法不能从类外部调用，因此对于只想外部使用这些类的开发者来说，它们并不有用。
- en: Static properties and methods
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态属性和方法
- en: So far, all the properties and methods were linked to a specific instance; so
    two different instances could have two different values for the same property.
    PHP allows you to have properties and methods linked to the class itself rather
    than to the object. These properties and methods are defined with the keyword
    `static`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有的属性和方法都与特定的实例相关联；因此，两个不同的实例可以为相同的属性有不同的值。PHP允许你将属性和方法与类本身相关联，而不是与对象相关联。这些属性和方法使用关键字`static`定义。
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the preceding property to the `Customer` class. This property shows the
    last ID assigned to a user, and is useful in order to know the ID that should
    be assigned to a new user. Let''s change the constructor of our class as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的属性添加到`Customer`类中。这个属性显示了分配给用户的最后一个ID，这对于知道应该分配给新用户的ID是有用的。让我们将我们类的构造函数修改如下：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that when referring to a static property, we do not use the variable `$this`.
    Instead, we use `self::`, which is not tied to any instance but to the class itself.
    In this last constructor, we have two options. We are either provided with an
    ID value that is not null, or we send a null in its place. When the received ID
    is null, we use the static property `$lastId` to know the last ID used, increase
    it by one, and assign it to the property `$id`. If the last ID we inserted was
    5, this will update the static property to 6, and then assign it to the instance
    property. Next time we create a new customer, the `$lastId` static property will
    be 6\. Instead, if we get a valid ID as part of the arguments, we assign it, and
    check if the assigned `$id` is greater than the static `$lastId`. If it is, we
    update it. Let''s see how we would use this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当引用静态属性时，我们不使用变量 `$this`。相反，我们使用 `self::`，它不是绑定到任何实例，而是绑定到类本身。在这个最后的构造函数中，我们有两种选择。我们要么提供一个非空的
    ID 值，要么用 null 代替。当接收到的 ID 为 null 时，我们使用静态属性 `$lastId` 来知道最后一个使用的 ID，将其增加 1，并将其分配给属性
    `$id`。如果我们插入的最后一个 ID 是 5，这将更新静态属性为 6，然后将其分配给实例属性。下次我们创建一个新的客户时，`$lastId` 静态属性将是
    6。相反，如果我们作为参数的一部分得到一个有效的 ID，我们将其分配，并检查分配的 `$id` 是否大于静态的 `$lastId`。如果是，我们更新它。让我们看看我们如何使用它：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, `$customer1` specifies that his ID is 3, probably
    because he is an existing customer and wants to keep the same ID. That sets both
    his ID and the last static ID to 3\. When creating the second customer, we do
    not specify the ID, so the constructor will take the last ID, increase it by 1,
    and assign it to the customer. So `$customer2` will have the ID 4, and the latest
    ID will be 4 too. Finally, our secret agent knows what he wants, so he forces
    the system to have the ID as 7\. The latest ID will be updated to 7 too.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`$customer1` 指定他的 ID 是 3，可能是因为他是一位现有客户，并希望保持相同的 ID。这设置了他的 ID 和最后一个静态
    ID 都是 3。当创建第二个客户时，我们没有指定 ID，因此构造函数将取最后一个 ID，增加 1，并将其分配给客户。所以 `$customer2` 将有 ID
    4，最新的 ID 也将是 4。最后，我们的秘密特工知道他想要什么，所以他强迫系统将 ID 设置为 7。最新的 ID 也将更新为 7。
- en: 'Another benefit of static properties and methods is that we do not need an
    object to use them. You can refer to a static property or method by specifying
    the name of the class, followed by `::`, and the name of the property/method.
    That is, of course, if the visibility rules allow you to do that, which, in this
    case, it does not, as the property is private. Let''s add a public static method
    to retrieve the last ID:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 静态属性和方法的好处之一是，我们不需要对象就可以使用它们。你可以通过指定类的名称，然后是 `::`，以及属性/方法的名称来引用静态属性或方法。当然，如果可见性规则允许你这样做，这在当前情况下是不允许的，因为属性是私有的。让我们添加一个公共静态方法来检索最后一个
    ID：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can reference it either using the class name or an existing instance, from
    anywhere in the code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从代码的任何地方使用类名或现有的实例来引用它：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Namespaces
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: You know that you cannot have two classes with the same name, since PHP would
    not know which one is being referred to when creating a new object. To solve this
    issue, PHP allows the use of **namespaces**, which act as paths in a filesystem.
    In this way, you can have as many classes with the same name as you need, as long
    as they are all defined in different namespaces. It is worth noting that, even
    though namespaces and the file path will usually be the same, this is enforced
    by the developer rather than by the language; you could actually use any namespace
    that has nothing to do with the filesystem.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你不能有两个具有相同名称的类，因为 PHP 在创建新对象时不知道应该引用哪一个。为了解决这个问题，PHP 允许使用 **命名空间**，它们在文件系统中充当路径。这样，你可以拥有你需要的任何数量的具有相同名称的类，只要它们都定义在不同的命名空间中。值得注意的是，尽管命名空间和文件路径通常会是相同的，但这是由开发者强制执行的，而不是由语言强制执行的；你实际上可以使用与文件系统无关的任何命名空间。
- en: 'Specifying a namespace has to be the first thing that you do in a file. In
    order to do that, use the `namespace` keyword followed by the namespace. Each
    section of the namespace is separated by `\`, as if it was a different directory.
    If you do not specify the namespace, the class will belong to the base namespace,
    or root. At the beginning of both files—`Book.php` and `Customer.php`—add the
    following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 指定命名空间必须在文件中做的第一件事。为了做到这一点，使用 `namespace` 关键字后跟命名空间。命名空间的每个部分都由 `\` 分隔，就像它是不同的目录一样。如果你没有指定命名空间，则类将属于基础命名空间，或根。在两个文件的开头——`Book.php`
    和 `Customer.php`——添加以下内容：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding line of code sets the namespace of our classes as `Bookstore\Domain`.
    The full name of our classes then is `Bookstore\Domain\Book` and `Bookstore\Domain\Customer`.
    If you try to access the `init.php` file from your browser, you will see an error
    saying that either the class `Book` or the class `Customer` were not found. But
    we included the files, right? That happens because PHP thinks that you are trying
    to access `\Book` and `\Customer` from the root. Do not worry, there are several
    ways to amend this.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码将我们类的命名空间设置为 `Bookstore\Domain`。我们类的完整名称因此是 `Bookstore\Domain\Book` 和 `Bookstore\Domain\Customer`。如果你尝试从浏览器访问
    `init.php` 文件，你会看到一个错误，说找不到 `Book` 或 `Customer` 类。但我们不是已经包含了这些文件吗？这是因为 PHP 认为你正在尝试从根目录访问
    `\Book` 和 `\Customer`。不要担心，有几种方法可以修正这个问题。
- en: One way would be to specify the full name of the classes when referencing them,
    that is, using `$customer = new Bookstore\Domain\Book();` instead of `$book =
    new Book();`. But that does not sound practical, does it?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是在引用类时指定类的完整名称，即使用 `$customer = new Bookstore\Domain\Book();` 而不是 `$book
    = new Book();`。但这听起来并不实用，对吧？
- en: Another way would be to say that the `init.php` file belongs to the `BookStore\Domain`
    namespace. That means that all the references to classes inside `init.php` will
    have the `BookStore\Domain` prefixed to them, and you will be able to use `Book`
    and `Customer`. The downside of this solution is that you cannot easily reference
    other classes from other namespaces, as any reference to a class will be prefixed
    with that namespace.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将 `init.php` 文件归属到 `BookStore\Domain` 命名空间。这意味着 `init.php` 内部所有类的引用都将带有
    `BookStore\Domain` 前缀，你将能够使用 `Book` 和 `Customer`。这种解决方案的缺点是，你不能轻易地引用其他命名空间中的类，因为任何类的引用都将带有该命名空间的前缀。
- en: 'The best solution is to use the keyword `use`. This keyword allows you to specify
    a full class name at the beginning of the file, and then use the simple name of
    the class in the rest of that file. Let''s see an example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳解决方案是使用关键字 `use`。这个关键字允许你在文件的开头指定一个完整的类名，然后在文件的其余部分使用类的简单名称。让我们看看一个例子：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding file, each time that we reference `Book` or `Customer`, PHP
    will know that we actually want to use the full class name, that is, with `Bookstore\Domain\`
    prefixed to it. This solution allows you to have a clean code when referencing
    those classes, and at the same time, to be able to reference classes from other
    namespaces if needed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的文件中，每次我们引用 `Book` 或 `Customer` 时，PHP 会知道我们实际上想要使用完整的类名，即在其前面加上 `Bookstore\Domain\`
    前缀。这种解决方案允许你在引用这些类时拥有干净的代码，同时，如果需要的话，也能引用其他命名空间中的类。
- en: But what if you want to include two different classes with the same name in
    the same file? If you set two `use` statements, PHP will not know which one to
    choose, so we still have the same problem as before! To fix that, either you use
    the full class name—with namespace—each time you want to reference any of the
    classes, or you use aliases.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想在同一个文件中包含两个具有相同名称的不同类呢？如果你设置了两个 `use` 语句，PHP 将不知道选择哪一个，所以我们仍然面临之前的问题！为了解决这个问题，你可以每次引用任何类时都使用完整的类名——带有命名空间——或者你可以使用别名。
- en: 'Imagine that we have two `Book` classes, the first one in the namespace `Bookstore\Domain`
    and the second one in `Library\Domain`. To solve the conflict, you could do as
    follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个 `Book` 类，第一个在 `Bookstore\Domain` 命名空间中，第二个在 `Library\Domain` 命名空间中。为了解决冲突，你可以这样做：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The keyword `as` sets an alias to that class. In that file, whenever you reference
    the class `LibraryBook`, you will actually be referencing the class `Library\Domain\Book`.
    And when referencing `Book`, PHP will just use the one from `Bookstore`. Problem
    solved!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `as` 为该类设置了一个别名。在那个文件中，每次你引用 `LibraryBook` 类时，实际上你引用的是 `Library\Domain\Book`
    类。而当你引用 `Book` 时，PHP 将只使用来自 `Bookstore` 的那个。问题解决了！
- en: Autoloading classes
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类的自动加载
- en: As you already know, in order to use a class, you need to include the file that
    defines it. So far, we have been including the files manually, as we only had
    a couple of classes and used them in one file. But what happens when we use several
    classes in several files? There must be a smarter way, right? Indeed there is.
    **Autoloading** to the rescue!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，为了使用一个类，你需要包含定义它的文件。到目前为止，我们一直是手动包含这些文件的，因为我们只有几个类，并且在一个文件中使用它们。但当我们使用多个文件中的多个类时会发生什么呢？肯定有更聪明的方法，对吧？确实有。**自动加载**来拯救我们！
- en: Autoloading is a PHP feature that allows your program to search and load files
    automatically given some set of predefined rules. Each time you reference a class
    that PHP does not know about, it will ask the **autoloader**. If the autoloader
    can figure out which file that class is in, it will load it, and the execution
    of the program will continue as normal. If it does not, PHP will stop the execution.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 自动加载是 PHP 的一个特性，它允许你的程序根据一组预定义的规则自动搜索和加载文件。每次当你引用 PHP 不认识的类时，它都会询问 **自动加载器**。如果自动加载器能够确定该类所在的文件，它将加载该文件，并且程序的执行将继续正常进行。如果它不能，PHP
    将停止执行。
- en: 'So, what is the autoloader? It is no more than a PHP function that gets a class
    name as a parameter, and it is expected to load a file. There are two ways of
    implementing an autoloader: either by using the `__autoload` function or the `spl_autoload_register`
    one.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '那么，自动加载器是什么？它不过是一个接收类名作为参数的 PHP 函数，并且它被期望加载一个文件。实现自动加载有两种方式：要么使用 `__autoload`
    函数，要么使用 `spl_autoload_register`。 '
- en: Using the __autoload function
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 __autoload 函数
- en: 'Defining a function named `__autoload` tells PHP that the function is the autoloader
    that it must use. You could implement an easy solution:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为 `__autoload` 的函数告诉 PHP 该函数是它必须使用的自动加载器。你可以实现一个简单的解决方案：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Our intention is to keep all PHP files in `src`, that is, the source. Inside
    this directory, the directory tree will emulate the namespace tree of the classes
    excluding the first section `BookStore`, which is useful as a namespace but not
    necessary as a directory. That means that our `Book` class, with full class name
    `BookStore\Domain\Book`, will be in `src/Domain/Book.php`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的意图是将所有 PHP 文件都放在 `src` 目录中，即源目录。在这个目录内部，目录树将模拟类的命名空间树，除了第一个部分 `BookStore`，它作为一个命名空间是有用的，但作为一个目录则不是必要的。这意味着我们的
    `Book` 类，全称 `BookStore\Domain\Book`，将位于 `src/Domain/Book.php`。
- en: In order to achieve that, our `__autoload` function tries to find the first
    occurrence of the backslash `\` with `strpos`, and then extracts from that position
    until the end with `substr`. This, in practice, just removes the first section
    of the namespace, `BookStore`. After that, we replace all `\` by `/` so that the
    filesystem can understand the path. Finally, we concatenate the current directory,
    the class name as a directory, and the `.php` extension.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们的 `__autoload` 函数尝试使用 `strpos` 找到反斜杠 `\` 的第一个出现位置，然后使用 `substr` 从该位置提取到文件末尾。实际上，这仅仅移除了命名空间的第一部分，`BookStore`。之后，我们将所有的
    `\` 替换为 `/`，这样文件系统就能理解路径了。最后，我们将当前目录、类名作为目录以及 `.php` 扩展名连接起来。
- en: 'Before trying that, remember to create the `src/Domain` directory and move
    the two classes inside it. Also, to make sure that we are testing the autoloader,
    save the following as your `init.php`, and go to `http://localhost:8000/init.php`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试之前，请记住创建 `src/Domain` 目录并将两个类移动到其中。同时，为了确保我们在测试自动加载器，请将以下内容保存为你的 `init.php`
    文件，并访问 `http://localhost:8000/init.php`：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The browser does not complain now, and there is no explicit `require_once`.
    Also remember that the `__autoload` function has to be defined only once, not
    in each file. So from now on, when you want to use your classes, as soon as the
    class is in a namespace and file that follows the convention, you only need to
    define the `use` statement. Way cleaner than before, right?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器现在不再抱怨，也没有显式的 `require_once`。同时记住，`__autoload` 函数只需要定义一次，而不是在每个文件中。所以从现在开始，当你想要使用你的类时，只要类位于一个遵循约定的命名空间和文件中，你只需要定义
    `use` 语句。比以前干净多了，对吧？
- en: Using the spl_autoload_register function
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 spl_autoload_register 函数
- en: 'The `__autoload` solution looks pretty good, but it has a small problem: what
    if our code is so complex that we do not have only one convention, and we need
    more than one implementation of the `__autoload` function? As we cannot define
    two functions with the same name, we need a way to tell PHP to keep a list of
    possible implementations of the autoloader, so it can try all of them until one
    works.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`__autoload` 解决方案看起来相当不错，但有一个小问题：如果我们的代码非常复杂，我们不仅仅只有一个约定，我们需要多个 `__autoload`
    函数的实现？因为我们不能定义两个同名函数，我们需要一种方法告诉 PHP 保留自动加载器的可能实现列表，这样它就可以尝试所有这些实现，直到找到一个有效的。'
- en: 'That is the job of `spl_autoload_register`. You define your autoloader function
    with a valid name, and then invoke the function `spl_autoload_register`, sending
    the name of your autoloader as an argument. You can call this function as many
    times as the different autoloaders you have in your code. In fact, even if you
    have only one autoloader, using this system is still a better option than the
    `__autoload` one, as you make it easier for someone else who has to add a new
    autoloader later:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `spl_autoload_register` 的作用。你定义你的自动加载函数并使用一个有效的名称，然后调用 `spl_autoload_register`
    函数，将你的自动加载函数名称作为参数传递。你可以根据你代码中的不同自动加载器多次调用这个函数。实际上，即使你只有一个自动加载器，使用这个系统也比使用 `__autoload`
    更好，因为它使其他人将来添加新自动加载器更容易：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Inheritance
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: We have presented the object-oriented paradigm as the panacea for complex data
    structures, and even though we have shown that we can define objects with properties
    and methods, and it looks pretty and fancy, it is not something that we could
    not solve with arrays. Encapsulation was one feature that made objects more useful
    than arrays, but their true power lies in inheritance.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将面向对象范式视为复杂数据结构的万能药，尽管我们已经展示了我们可以定义具有属性和方法的对象，看起来很漂亮，也很高级，但这并不是我们不能用数组解决的问题。封装是使对象比数组更有用的一项特性，但它们的真正力量在于继承。
- en: Introducing inheritance
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍继承
- en: Inheritance in OOP is the ability to pass the implementation of the class from
    parents to children. Yes, classes can have parents, and the technical way of referring
    to this feature is that a class *extends* from another class. When extending a
    class, we get all the properties and methods that are not defined as private,
    and the child class can use them as if they were its own. The limitation is that
    a class can only extend from one parent.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程中的继承是指将类的实现从父类传递给子类的功能。是的，类可以有父类，而技术上将这一特性称为一个类 *继承* 自另一个类。当我们扩展一个类时，我们会获得所有未定义为私有的属性和方法，子类可以像使用自己的属性和方法一样使用它们。限制是，一个类只能从一个父类继承。
- en: 'To show an example, let''s consider our `Customer` class. It contains the properties
    `firstname`, `surname`, `email`, and `id`. A customer is actually a specific type
    of person, one that is registered in our system, so he/she can get books. But
    there can be other types of persons in our system, like librarian or guest. And
    all of them would have some common properties to all people, that is, `firstname`
    and `surname`. So it would make sense if we create a `Person` class, and make
    the `Customer` class extend from it. The hierarchic tree would look as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，让我们考虑我们的 `Customer` 类。它包含属性 `firstname`、`surname`、`email` 和 `id`。客户实际上是一种特定类型的人，他/她在我们的系统中注册，因此可以借阅书籍。但我们的系统中可能有其他类型的人，如图书管理员或访客。他们都会有一些对所有人的共同属性，即
    `firstname` 和 `surname`。因此，如果我们创建一个 `Person` 类，并使 `Customer` 类从它继承，那就很有意义了。层次结构树将如下所示：
- en: '![Introducing inheritance](img/00017.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![介绍继承](img/00017.jpeg)'
- en: 'Note how `Customer` is connected to `Person`. The methods in `Person` are not
    defined in `Customer`, as they are implicit from the extension. Now save the new
    class in `src/Domain/Person.php`, following our convention:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `Customer` 如何与 `Person` 相连。`Person` 中的方法在 `Customer` 中没有定义，因为它们是从扩展中隐含的。现在按照我们的约定，将新类保存在
    `src/Domain/Person.php` 中：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note the new keyword `extends`; it tells PHP that this class is a child of the
    `Person` class. As both `Person` and `Customer` are in the same namespace, you
    do not have to add any `use` statement, but if they were not, you should let it
    know how to find the parent. This code works fine, but we can see that there is
    a bit of duplication of code. The constructor of the `Customer` class is doing
    the same job as the constructor of the `Person` class! We will try to fix it really
    soon.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意新关键字 `extends`；它告诉 PHP 这个类是 `Person` 类的子类。由于 `Person` 和 `Customer` 都在同一个命名空间中，你不需要添加任何
    `use` 语句，但如果它们不在同一个命名空间中，你应该让它知道如何找到父类。这段代码运行正常，但我们可以看出，这里有一些代码重复。`Customer` 类的构造函数正在做与
    `Person` 类构造函数相同的工作！我们将会尽快修复这个问题。
- en: 'In order to reference a method or property of the parent class from the child,
    you can use `$this` as if the property or method was in the same class. In fact,
    you could say it actually is. But PHP allows you to redefine a method in the child
    class that was already present in the parent. If you want to reference the parent''s
    implementation, you cannot use `$this`, as PHP will invoke the one in the child.
    To force PHP to use the parent''s method, use the keyword `parent::` instead of
    `$this`. Update the constructor of the `Customer` class as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从子类中引用父类的方法或属性，你可以使用`$this`，就像属性或方法在同一个类中一样。实际上，你可以说它实际上就是。但PHP允许你在子类中重新定义已经在父类中存在的方法。如果你想引用父类的实现，你不能使用`$this`，因为PHP将调用子类中的那个。要强制PHP使用父类的方法，请使用关键字`parent::`而不是`$this`。按照以下方式更新`Customer`类的构造函数：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This new constructor does not duplicate code. Instead, it calls the constructor
    of the parent class `Person`, sending `$firstname` and `$surname`, and letting
    the parent do what it already knows how to do. We avoid code duplication and,
    on top of that, we make it easier for any future changes to be made in the constructor
    of `Person`. If we need to change the implementation of the constructor of `Person`,
    we will change it in one place only, instead of in all the children.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的构造函数并没有复制代码。相反，它调用父类`Person`的构造函数，传递`$firstname`和`$surname`，并让父类做它已经知道如何做的事情。我们避免了代码重复，并且在此基础上，我们还使得对`Person`构造函数的任何未来更改都变得更加容易。如果我们需要更改`Person`构造函数的实现，我们只需在一个地方更改，而不是在所有子类中更改。
- en: Overriding methods
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖方法
- en: As said before, when extending from a class, we get all the methods of the parent
    class. That is implicit, so they are not actually written down inside the child's
    class. What would happen if you implement another method with the same signature
    and/or name? You will be *overriding the method*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当我们从一个类扩展时，我们得到父类的所有方法。这是隐式的，所以它们实际上并没有在子类的类中写下来。如果你实现了一个具有相同签名和/或名称的另一个方法会发生什么？你将*覆盖方法*。
- en: 'As we do not need this feature in our classes, let''s just add some code in
    our `init.php` file to show this behavior, and then you can just remove it. Let''s
    define a class `Pops`, a class `Child` that extends from the parent, and a `sayHi`
    method in both of them:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不需要这个功能在我们的类中，我们只需在我们的`init.php`文件中添加一些代码来展示这种行为，然后你可以简单地删除它。让我们定义一个类`Pops`，一个从父类扩展的类`Child`，以及它们两个中的`sayHi`方法：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The highlighted code shows you that the method has been overridden, so when
    invoking it from a child''s point of view, we will be using it rather than the
    one inherited from its father. But what happens if we want to reference the inherited
    one too? You can always reference it with the keyword `parent`. Let''s see how
    it works:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码显示该方法已被覆盖，因此当我们从子类的角度调用它时，我们将使用它而不是从其父类继承来的那个。但如果我们还想引用继承来的那个呢？你可以始终使用关键字`parent`来引用它。让我们看看它是如何工作的：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now the child is saying `hi` for both himself and his father. It seems very
    easy and handy, right? Well, there is a restriction. Imagine that, as in real
    life, the child was very shy, and he would not say hi to everybody. We could try
    to set the visibility of the method as protected, but see what happens:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在子类在对自己和他父亲都说`hi`。这似乎非常简单和方便，对吧？但是有一个限制。想象一下，就像现实生活中，这个孩子非常害羞，他不会对每个人都打招呼。我们可以尝试将方法的可见性设置为受保护的，但看看会发生什么：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When trying this code, even without trying to instantiate it, you will get a
    fatal error complaining about the access level of that method. The reason is that
    when overriding, the method has to have at least as much visibility as the one
    inherited. That means that if we inherit a protected one, we can override it with
    another protected or a public one, but never with a private one.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这段代码时，即使没有尝试实例化它，你也会得到一个关于该方法访问级别的致命错误。原因是当覆盖时，方法必须至少与继承的方法有相同的可见性。这意味着如果我们继承了一个受保护的，我们可以用另一个受保护的或公共的来覆盖它，但不能用私有的来覆盖。
- en: Abstract classes
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类
- en: 'Remember that you can extend only from one parent class each time. That means
    that `Customer` can only extend from `Person`. But if we want to make this hierarchic
    tree more complex, we can create children classes that extend from `Customer`,
    and those classes will extend implicitly from `Person` too. Let''s create two
    types of customer: basic and premium. These two customers will have the same properties
    and methods from `Customer` and from `Person`, plus the new ones that we implement
    in each one of them.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每次只能从一个父类扩展。这意味着`Customer`只能从`Person`扩展。但如果我们想使这个层次树更复杂，我们可以创建从`Customer`扩展的子类，这些类也将隐式地从`Person`扩展。让我们创建两种类型的客户：基本和高级。这两种客户将具有来自`Customer`和`Person`的相同属性和方法，以及我们在每个中实现的新方法。
- en: 'Save the following code as `src/Domain/Customer/Basic.php`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码保存为`src/Domain/Customer/Basic.php`：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And the following code as `src/Domain/Customer/Premium.php`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码作为`src/Domain/Customer/Premium.php`：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Things to note in the preceding two codes are that we extend from `Customer`
    in two different classes, and it is perfectly legal— we can extend from classes
    in different namespaces. With this addition, the hierarchic tree for `Person`
    would look as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个代码中需要注意的事项是，我们从两个不同的类中扩展了`Customer`，这是完全合法的——我们可以从不同命名空间中的类扩展。有了这个添加，`Person`的层次树将如下所示：
- en: '![Abstract classes](img/00018.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![抽象类](img/00018.jpeg)'
- en: We define the same methods in these two classes, but their implementations are
    different. The aim of this approach is to use both types of customers indistinctively,
    without knowing which one it is each time. For example, we could temporally have
    the following code in our `init.php`. Remember to add the `use` statement to import
    the class `Customer` if you do not have it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这两个类中定义了相同的方法，但它们的实现是不同的。这种方法的目的是在不了解每次是哪一个的情况下，无差别地使用这两种类型的客户。例如，我们可以在`init.php`中暂时有以下代码。记住，如果你没有导入`Customer`类，请添加`use`语句。
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding function would tell us if a given customer could borrow all the
    books in the array. Notice that the type hinting of the method says `Customer`,
    without specifying which one. This will accept objects that are instances of `Customer`
    or any class that extends from `Customer`, that is, `Basic` or `Premium`. Looks
    legit, right? Let''s try to use it then:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数会告诉我们一个给定的客户是否可以借阅数组中的所有书籍。注意，该方法类型提示为`Customer`，但没有指定具体是哪一个。这将接受任何是`Customer`实例或从`Customer`扩展的类的对象，即`Basic`或`Premium`。看起来很合理，对吧？那么让我们试试看：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first invocation works as expected, but the second one fails, even though
    we are sending a `Customer` object. The problem arises because the parent does
    not know about any `getAmountToBorrow` method! It also looks dangerous that we
    rely on the children to always implement that method. The solution lies in using
    abstract classes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用按预期工作，但第二次调用失败，即使我们发送了一个`Customer`对象。问题在于父类不知道任何`getAmountToBorrow`方法！而且，我们依赖于子类始终实现该方法看起来也很危险。解决方案在于使用抽象类。
- en: 'An **abstract class** is a class that cannot be instantiated. Its sole purpose
    is to make sure that its children are correctly implemented. Declaring a class
    as abstract is done with the keyword `abstract`, followed by the definition of
    a normal class. We can also specify the methods that the children are forced to
    implement, without implementing them in the parent class. Those methods are called
    abstract methods, and are defined with the keyword `abstract` at the beginning.
    Of course, the rest of the normal methods can stay there too, and will be inherited
    by its children:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象类**是一个不能实例化的类。它的唯一目的是确保其子类被正确实现。将类声明为抽象是通过使用关键字`abstract`，然后是正常类的定义来完成的。我们还可以指定子类必须实现的方法，而不在父类中实现它们。这些方法被称为抽象方法，并且使用关键字`abstract`在开头定义。当然，其余的正常方法也可以保留在那里，并将由其子类继承：'
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The preceding abstraction solves both problems. First, we will not be able to
    send any instance of the class `Customer`, because we cannot instantiate it. That
    means that all the objects that the `checkIfValid` method is going to accept are
    only the children from `Customer`. On the other hand, declaring abstract methods
    forces all the children that extend the class to implement them. With that, we
    make sure that all objects will implement `getAmountToBorrow`, and our code is
    safe.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上述抽象解决了两个问题。首先，我们将无法发送 `Customer` 类的任何实例，因为我们不能实例化它。这意味着 `checkIfValid` 方法将要接受的所有对象都只能是
    `Customer` 的子类。另一方面，声明抽象方法迫使所有扩展该类的子类实现它们。通过这种方式，我们确保所有对象都将实现 `getAmountToBorrow`，并且我们的代码是安全的。
- en: 'The new hierarchic tree will define the three abstract methods in `Customer`,
    and will omit them for its children. It is true that we are implementing them
    in the children, but as they are enforced by `Customer`, and thanks to abstraction,
    we are sure that all classes extending from it will have to implement them, and
    that it is safe to do so. Let''s see how this is done:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 新的层次结构树将在 `Customer` 中定义三个抽象方法，并为其子类省略它们。虽然我们在子类中实现了它们，但它们由 `Customer` 强制执行，并且由于抽象的存在，我们确信所有从它扩展的类都必须实现它们，这样做是安全的。让我们看看这是如何完成的：
- en: '![Abstract classes](img/00019.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![抽象类](img/00019.jpeg)'
- en: With the last new addition, your `init.php` file should fail. The reason is
    that it is trying to instantiate the class `Customer`, but now it is abstract,
    so you cannot. Instantiate a concrete class, that is, one that is not abstract,
    to solve the problem.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的新添加中，你的 `init.php` 文件应该会失败。原因是它试图实例化 `Customer` 类，但现在它是抽象的，所以你不能。实例化一个具体的类，即一个非抽象的类，来解决这个问题。
- en: Interfaces
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: An **interface** is an OOP element that groups a set of function declarations
    without implementing them, that is, it specifies the name, return type, and arguments,
    but not the block of code. Interfaces are different from abstract classes, since
    they cannot contain any implementation at all, whereas abstract classes could
    mix both method definitions and implemented ones. The purpose of interfaces is
    to state what a class can do, but not how it is done.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口** 是一个 OOP 元素，它将一组函数声明分组，但不实现它们，即它指定了名称、返回类型和参数，但没有代码块。接口与抽象类不同，因为它们根本不能包含任何实现，而抽象类可以混合方法定义和实现。接口的目的是声明一个类可以做什么，但不是如何做。'
- en: 'From our code, we can identify a potential usage of interfaces. Customers have
    an expected behavior, but its implementation changes depending on the type of
    customer. So, `Customer` could be an interface instead of an abstract class. But
    as an interface cannot implement any function, nor can it contain properties,
    we will have to move the concrete code from the `Customer` class to somewhere
    else. For now, let''s move it up to the `Person` class. Edit the `Person` class
    as shown:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的代码中，我们可以识别出接口的潜在用途。客户有一个预期的行为，但它的实现取决于客户类型。因此，`Customer` 可以是一个接口而不是一个抽象类。但是，由于接口不能实现任何函数，也不能包含属性，我们必须将具体的代码从
    `Customer` 类移动到其他地方。目前，让我们将其移动到 `Person` 类。按照以下方式编辑 `Person` 类：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Complicating things more than necessary**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**使事情比必要的更复杂**'
- en: Interfaces are very useful, but there is always a place and a time for everything.
    As our application is very simple due to its didactic nature, there is no real
    place for them. The abstract class already defined in the previous section is
    the best approach for our scenario. But just for the sake of showing how interfaces
    work, we will be adapting our code to them.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接口非常有用，但万事万物都有其合适的时间和地点。由于我们的应用程序由于其教学性质而非常简单，实际上没有它们的真正位置。前一个部分中已经定义的抽象类是我们场景的最佳方法。但只是为了展示接口是如何工作的，我们将调整我们的代码以适应它们。
- en: Do not worry though, as most of the code that we are going to introduce now
    will be replaced by better practices once we introduce databases and the MVC pattern
    in [Chapter 5](part0045_split_000.html#1AT9A1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 5. Using Databases"), *Using Databases*, and [Chapter 6](part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 6. Adapting to MVC"), *Adapting to MVC*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心，因为我们将要引入的大多数代码，一旦我们在第 5 章“使用数据库”（[Chapter 5](part0045_split_000.html#1AT9A1-edcc22b134104d5db0bf3aa086c86851)）和第
    6 章“适应 MVC”（[Chapter 6](part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851)）中引入数据库和
    MVC 模式后，将被更好的实践所取代。
- en: When writing your own applications, do not try to complicate things more than
    necessary. It is a common pattern to see very complex code from developers that
    try to show up all the skills they have in a very simple scenario. Use only the
    necessary tools to leave clean code that is easy to maintain, and of course, that
    works as expected.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写自己的应用程序时，不要试图使事情比必要的更复杂。看到开发者试图在一个非常简单的场景中展示他们所有技能而编写非常复杂的代码是一种常见的模式。只使用必要的工具来留下干净、易于维护的代码，当然，这样的代码应该按预期工作。
- en: 'Change the content of `Customer.php` with the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下内容更改`Customer.php`的内容：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that an interface is very similar to an abstract class. The differences
    are that it is defined with the keyword `interface`, and that its methods do not
    have the word `abstract`. Interfaces cannot be instantiated, since their methods
    are not implemented as with abstract classes. The only thing you can do with them
    is make a class to implement them.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，接口与抽象类非常相似。区别在于它是用关键字`interface`定义的，并且它的方法没有`abstract`这个词。接口不能被实例化，因为它们的实现方式与抽象类不同。你可以用它们做的唯一一件事就是创建一个类来实现它们。
- en: '*Implementing* an interface means implementing all the methods defined in it,
    like when we extended an abstract class. It has all the benefits of the extension
    of abstract classes, such as belonging to that type—useful when type hinting.
    From the developer''s point of view, using a class that implements an interface
    is like writing a contract: you ensure that your class will always have the methods
    declared in the interface, regardless of the implementation. Because of that,
    interfaces only care about public methods, which are the ones that other developers
    can use. The only change you need to make in your code is to replace the keywords
    `extends` by `implements`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*实现*一个接口意味着实现其中定义的所有方法，就像我们扩展抽象类时一样。它具有扩展抽象类的所有好处，例如属于那个类型——在类型提示时很有用。从开发者的角度来看，使用实现接口的类就像编写一个合同：你确保你的类将始终拥有接口中声明的那些方法，无论实现如何。正因为如此，接口只关心公共方法，这是其他开发者可以使用的那些方法。你需要在代码中做的唯一改变是将关键字`extends`替换为`implements`：'
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'So, why would someone use an interface if we could always use an abstract class
    that not only enforces the implementation of methods, but also allows inheriting
    code as well? The reason is that you can only extend from one class, but you can
    implement multiple instances at the same time. Imagine that you had another interface
    that defined payers. This could identify someone that has the ability to pay something,
    regardless of what it is. Save the following code in `src/Domain/Payer.php`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么有人会使用接口，如果我们总能使用一个不仅强制实现方法，还允许继承代码的抽象类呢？原因在于你只能从一个类扩展，但你可以在同一时间实现多个实例。想象一下，如果你还有一个定义付款人的接口。这可以识别出有支付能力的人，无论是什么。将以下代码保存到`src/Domain/Payer.php`：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now our basic and premium customers can implement both the interfaces. The
    basic customer will look like the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基本客户和高级客户都可以实现这两个接口。基本客户将看起来如下：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And the premium customer will change in the same way:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 高级客户也会以同样的方式改变：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You should see that this code would no longer work. The reason is that although
    we implement a second interface, the methods are not implemented. Add these two
    methods to the basic customer class:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到这段代码将不再工作。原因是尽管我们实现了第二个接口，但方法并没有实现。将这两个方法添加到基本客户类中：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add these two methods to the premium customer class:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个方法添加到高级客户类中：
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If you know that *all* customers will have to be payers, you could even make
    the `Customer` interface to inherit from the `Payer` interface:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道所有客户都必须是付款人，你甚至可以让`Customer`接口继承自`Payer`接口：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This change does not affect the usage of our classes at all. Other developers
    will see that our basic and premium customers inherit from `Payer` and `Customer`,
    and so they contain all the necessary methods. That these interfaces are independent,
    or they extend from each other is something that will not affect too much.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变根本不影响我们类的使用。其他开发者会看到我们的基本客户和高级客户继承自`Payer`和`Customer`，因此它们包含所有必要的方法。这些接口是独立的，或者它们相互扩展，这不会影响太多。
- en: Interfaces can only extend from other interfaces, and classes can only extend
    from other classes. The only way to mix them is when a class implements an interface,
    but neither does a class extend from an interface, nor does an interface extend
    from a class. But from the point of view of type hinting, they can be used interchangeably.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接口只能从其他接口扩展，类只能从其他类扩展。唯一混合它们的方式是一个类实现一个接口，但类不扩展接口，接口也不扩展类。但从类型提示的角度来看，它们可以互换使用。
- en: To summarize this section and make things clear, let's show what the hierarchic
    tree looks like after all the new additions. As in abstract classes, the methods
    declared in an interface are shown in the interface rather than in each of the
    classes that implement it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本节内容并使事情清晰，让我们展示在所有新添加之后层次树的样子。与抽象类一样，接口中声明的方法显示在接口中，而不是在实现它的每个类中。
- en: '![Interfaces](img/00020.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![接口](img/00020.jpeg)'
- en: Polymorphism
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态
- en: '**Polymorphism** is an OOP feature that allows us to work with different classes
    that implement the same interface. It is one of the beauties of object-oriented
    programming. It allows the developer to create a complex system of classes and
    hierarchic trees, but offers a simple way of working with them.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**多态**是面向对象编程的一个特性，它允许我们与实现相同接口的不同类一起工作。它是面向对象编程的美丽之处之一。它允许开发者创建一个复杂的类和层次树系统，但提供了简单的工作方式。'
- en: 'Imagine that we have a function that, given a payer, checks whether it is exempt
    of taxes or not, and makes it pay some amount of money. This piece of code does
    not really mind if the payer is a customer, a librarian, or someone who has nothing
    to do with the bookstore. The only thing that it cares about is that the payer
    has the ability to pay. The function could be as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个函数，给定一个付款人，检查它是否免税，并使其支付一定金额的钱。这段代码并不关心付款人是客户、图书管理员还是与书店无关的人。它唯一关心的是付款人是否有支付的能力。这个函数可以是这样的：
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You could send basic or premium customers to this function, and the behavior
    will be different. But, as both implement the `Payer` interface, both objects
    provided are valid types, and both are capable of performing the actions needed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将基本客户或高级客户发送到这个功能，行为会有所不同。但是，由于两者都实现了`Payer`接口，提供的两个对象都是有效的类型，并且两者都能够执行所需的操作。
- en: The `checkIfValid` function takes a customer and a list of books. We already
    saw that sending any kind of customer makes the function work as expected. But
    what happens if we send an object of the class `Librarian`, which extends from
    `Payer`? As `Payer` does not know about `Customer` (it is rather the other way
    around), the function will complain as the type hinting is not accomplished.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkIfValid`函数接受一个客户和一个书籍列表。我们已经看到发送任何类型的客户都会使函数按预期工作。但是，如果我们发送一个从`Payer`扩展的`Librarian`类的对象会发生什么？由于`Payer`不了解`Customer`（情况正好相反），函数会抱怨，因为类型提示没有完成。'
- en: 'One useful feature that comes with PHP is the ability to check whether an object
    is an instance of a specific class or interface. The way to use it is to specify
    the variable followed by the keyword `instanceof` and the name of the class or
    interface. It returns a Boolean, which is `true` if the object is from a class
    that extends or implements the specified one, or `false` otherwise. Let''s see
    some examples:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: PHP附带的一个有用特性是检查一个对象是否是特定类或接口的实例。使用它的方法是指定变量后跟关键字`instanceof`和类或接口的名称。它返回一个布尔值，如果对象来自扩展或实现指定类的类，则为`true`，否则为`false`。让我们看看一些例子：
- en: '[PRE55]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Remember to add all the `use` statements for each of the class or interface,
    otherwise PHP will understand that the specified class name is inside the namespace
    of the file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 记得为每个类或接口添加所有的`use`语句，否则PHP会理解指定的类名在文件的作用域内。
- en: Traits
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特型
- en: So far, you have learned that extending from classes allows you to inherit code
    (properties and method implementations), but it has the limitation of extending
    only from one class each time. On the other hand, you can use interfaces to implement
    multiple behaviors from the same class, but you cannot inherit code in this way.
    To fill this gap, that is, to be able to inherit code from multiple places, you
    have traits.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经了解到从类扩展可以使您继承代码（属性和方法实现），但它有一个限制，即每次只能从一个类扩展。另一方面，您可以使用接口从同一个类实现多个行为，但您不能以这种方式继承代码。为了填补这个差距，即能够从多个地方继承代码，您有特型。
- en: '**Traits** are mechanisms that allow you to reuse code, "inheriting", or rather
    copy-pasting code, from multiple sources at the same time. Traits, as abstract
    classes or interfaces, cannot be instantiated; they are just containers of functionality
    that can be used from other classes.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**特质**是允许你同时从多个来源重用代码的机制，或者说“继承”，或者说复制粘贴代码。特质，作为抽象类或接口，不能被实例化；它们只是包含可以由其他类使用的功能的功能容器。'
- en: If you remember, we have some code in the `Person` class that manages the assignment
    of IDs. This code is not really part of a person, but rather part of an ID system
    that could be used by some other entity that has to be identified with IDs too.
    One way to extract this functionality from `Person`—and we are not saying that
    it is the best way to do so, but for the sake of seeing traits in action, we choose
    this one—is to move it to a trait.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，我们在`Person`类中有些代码用于管理ID的分配。这段代码实际上并不属于个人，而是属于一个ID系统，该系统可以被其他需要用ID进行标识的实体使用。从`Person`类中提取这种功能的一种方法——我们并不是说这是最好的方法，但为了看到特质的实际应用，我们选择了这种方法——是将它移动到一个特质中。
- en: 'To define a trait, do as if you were defining a class, just use the keyword
    `trait` instead of `class`. Define its namespace, add the `use` statements needed,
    declare its properties and implement its methods, and place everything in a file
    that follows the same conventions. Add the following code to the `src/Utils/Unique.php`
    file:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个特质，就像定义一个类一样做，只是用关键字`trait`代替`class`。定义其命名空间，添加所需的`use`语句，声明其属性并实现其方法，并将所有内容放在遵循相同约定的文件中。将以下代码添加到`src/Utils/Unique.php`文件中：
- en: '[PRE56]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Observe that the namespace is not the same as usual, since we are storing this
    code in a different file. This is a matter of conventions, but you are entirely
    free to use the file structure that you consider better for each case. In this
    case, we do not think that this trait represents "business logic" like customers
    and books do; instead, it represents a utility for managing the assignment of
    IDs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，命名空间与通常不同，因为我们把这段代码存储在不同的文件中。这是一个关于约定的问题，但你完全可以根据每个案例考虑更好的文件结构。在这种情况下，我们认为这个特质并不代表像客户和书籍那样的“业务逻辑”，而是一个用于管理ID分配的实用工具。
- en: We include all the code related to IDs from `Person`. That includes the properties,
    the getters, and the code inside the constructor. As the trait cannot be instantiated,
    we cannot add a constructor. Instead, we added a `setId` method that contains
    the code. When constructing a new instance that uses this trait, we can invoke
    this `setId` method to set the ID based on what the user sends as an argument.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了与ID相关的所有代码，包括属性、获取器和构造函数中的代码。由于特质不能被实例化，我们不能添加构造函数。相反，我们添加了一个`setId`方法，其中包含代码。当构造使用此特质的新实例时，我们可以调用此`setId`方法来根据用户提供的参数设置ID。
- en: 'The class `Person` will have to change too. We have to remove all references
    to IDs and we will have to define somehow that the class is using the trait. To
    do that, we use the keyword `use`, like in namespaces, but inside the class. Let''s
    see what it would look like:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`类也需要做出改变。我们必须删除所有与ID相关的引用，并且必须以某种方式定义该类正在使用特质。为此，我们使用关键字`use`，就像在命名空间中一样，但要在类内部。让我们看看它将是什么样子：'
- en: '[PRE57]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We add the `use Unique;` statement to let the class know that it is using the
    trait. We remove everything related to IDs, even inside the constructor. We still
    get an ID as the first argument of the constructor, but we ask the method `setId`
    from the trait to do everything for us. Note that we refer to that method with
    `$this`, as if the method was inside the class. The updated hierarchic tree would
    look like the following (note that we are not adding all the methods for all the
    classes or interfaces that are not involved in the recent changes in order to
    keep the diagram as small and readable as possible):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`use Unique;`语句，让类知道它正在使用特质。我们删除了与ID相关的一切，即使在构造函数中也是如此。我们仍然将ID作为构造函数的第一个参数，但我们要求特质的`setId`方法为我们做所有事情。注意，我们用`$this`来引用该方法，就像该方法在类内部一样。更新后的层次结构树将如下所示（注意，我们没有添加所有不涉及最近更改的类或接口的方法，以使图表尽可能小和可读）：
- en: '![Traits](img/00021.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![特质](img/00021.jpeg)'
- en: 'Let''s see how it works, even though it does so in the way that you probably
    expect. Add this code into your `init.php` file, include the necessary `use` statements,
    and execute it in your browser:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的，即使它以你可能预期的这种方式进行。将以下代码添加到你的`init.php`文件中，包含必要的`use`语句，并在浏览器中执行：
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The preceding code instantiates two customers. The first of them has a specific
    ID, whereas the second one lets the system choose an ID for it. The result is
    that the second basic customer has the ID 2\. That is to be expected, as both
    customers are basic. But what would happen if the customers are of different types?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了两个客户实例。第一个客户有一个特定的 ID，而第二个客户让系统为它选择一个 ID。结果是第二个基本客户的 ID 为 2。这是预期的，因为两个客户都是基本的。但如果客户类型不同会发生什么呢？
- en: '[PRE59]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The IDs are still the same. That is to be expected, as the trait is included
    in the `Person` class, so the static property `$lastId` will be shared across
    all the instances of the class `Person`, including `Basic` and `Premium` customers.
    If you used the trait from `Basic` and `Premium` customer instead of `Person`
    (but you should not), you would have the following result:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ID 仍然相同。这是预期的，因为特性包含在 `Person` 类中，所以静态属性 `$lastId` 将在 `Person` 类的所有实例之间共享，包括
    `Basic` 和 `Premium` 客户。如果你使用 `Basic` 和 `Premium` 客户端的特性而不是 `Person`（但你不应这样做），你会得到以下结果：
- en: '[PRE60]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Each class will have its own static property. All `Basic` instances will share
    the same `$lastId`, different from the `$lastId` of `Premium` instances. This
    should make clear that the static members in traits are linked to whichever class
    uses them, rather than the trait itself. That could also be reflected on testing
    the following code which uses our original scenario where the trait is used from
    `Person`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都将有自己的静态属性。所有 `Basic` 实例将共享相同的 `$lastId`，与 `Premium` 实例的 `$lastId` 不同。这应该清楚地表明，特性中的静态成员与使用它们的类相关联，而不是特性本身。这也可以从以下代码的测试中反映出来，该代码使用我们原始的场景，其中特性从
    `Person` 使用：
- en: '[PRE61]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If you have a good eye for problems, you might start thinking about some potential
    issues around the usage of traits. What happens if we use two traits that contain
    the same method? Or what happens if you use a trait that contains a method that
    is already implemented in that class?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你善于发现问题，你可能会开始思考关于特性使用的一些潜在问题。如果我们使用包含相同方法的两个特性会发生什么？或者如果你使用一个包含已在类中实现的方法的特性会发生什么？
- en: Ideally, you should avoid running into these kinds of situations; they are warning
    lights for possible bad design. But as there will always be extraordinary cases,
    let's see some isolated examples on how they would behave.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应该避免遇到这类情况；它们是可能存在不良设计的警告信号。但既然总会有些特殊情况，让我们看看一些孤立示例，看看它们会如何表现。
- en: 'The scenario where the trait and the class implement the same method is easy.
    The method implemented explicitly in the class is the one with more precedence,
    followed by the method implemented in the trait, and finally, the method inherited
    from the parent class. Let''s see how it works. Take for example the following
    trait and class definitions:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当特性和类实现相同的方法时，这种情况很简单。在类中显式实现的方法具有更高的优先级，其次是特性中实现的方法，最后是从父类继承的方法。让我们看看它是如何工作的。以以下特性和类定义为例：
- en: '[PRE62]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Both implement the `sign` method, which means that we have to apply the precedence
    rules defined previously. The method defined in the class takes precedence over
    the one from the trait, so in this case, the executed method will be the one from
    the class:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 两个都实现了 `sign` 方法，这意味着我们必须应用之前定义的优先级规则。类中定义的方法比特性中的方法具有更高的优先级，所以在这种情况下，执行的方法将是类中的方法：
- en: '[PRE63]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The most complicated scenario would be one where a class uses two traits with
    the same method. There are no rules that solve the conflict automatically, so
    you have to solve it explicitly. Check the following code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最复杂的情况是，一个类使用两个具有相同方法的特点。没有规则可以自动解决冲突，所以你必须显式地解决它。查看以下代码：
- en: '[PRE64]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The preceding code throws a fatal error, as both traits implement the same
    method. To choose the one you want to use, you have to use the operator `insteadof`.
    To use it, state the trait name and the method that you want to use, followed
    by `insteadof` and the trait that you are rejecting for use. Optionally, use the
    keyword `as` to add an alias like we did with namespaces so that you can use both
    the methods:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码抛出一个致命错误，因为两个特性实现了相同的方法。要选择你想要使用的方法，你必须使用操作符 `insteadof`。要使用它，声明你想要使用的特性和方法，然后是
    `insteadof` 和你想要拒绝使用的特性。可选地，使用关键字 `as` 添加一个别名，就像我们使用命名空间一样，这样你就可以使用两个方法：
- en: '[PRE65]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: You can see how we decided to use the method of `Contract` instead of `Communicator`,
    but added the alias so that both methods are available. Hopefully, you can see
    that even the conflicts can be solved, and there are specific cases where there
    is nothing to do but deal with them; in general, they look like a bad sign—no
    pun intended.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们决定使用`Contract`方法而不是`Communicator`方法，但添加了别名，以便两种方法都可以使用。希望你能看到，即使冲突也可以解决，并且存在一些特定的情况，除了处理它们之外没有其他事情可做；一般来说，它们看起来像是一个坏信号——不是字面意义上的。
- en: Handling exceptions
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: 'It does not matter how easy and intuitive your application is designed to be,
    there will be bad usage from the user or just random errors of connectivity, and
    your code has to be ready to handle these scenarios so that the user experience
    is a good as possible. We call these scenarios **exceptions**: an element of the
    language that identifies a case that is not as we expected.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的应用程序设计得多简单直观，用户都会有不恰当的使用或仅仅是随机的连接错误，你的代码必须准备好处理这些场景，以便用户体验尽可能好。我们把这些场景称为**异常**：语言中的一个元素，用于标识一个不符合预期的案例。
- en: The try…catch block
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: try…catch块
- en: 'Your code can throw exceptions manually whenever you think it necessary. For
    example, take the `setId` method from the `Unique` trait. Thanks to type hinting,
    we are enforcing the ID to be a numeric one, but that is as far as it goes. What
    would happen if someone tries to set an ID that is a negative number? The code
    right now allows it to go through, but depending on your preferences, you would
    like to avoid it. That would be a good place for an exception to happen. Let''s
    see how we would add this check and consequent exception:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当你认为必要时，你的代码可以手动抛出异常。例如，从`Unique`特质中获取`setId`方法。多亏了类型提示，我们强制ID必须是数字，但这只是第一步。如果有人尝试设置一个负数的ID会发生什么？目前的代码允许它通过，但根据你的偏好，你可能希望避免这种情况。那将是一个异常发生的好地方。让我们看看我们如何添加这个检查和随后的异常：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As you can see, exceptions are objects of the class exception. Remember adding
    the backslash to the name of the class, unless you want to include it with `use
    Exception;` at the top of the file. The constructor of the `Exception` class takes
    some optional arguments, the first one of them being the message of the exception.
    Instances of the class `Exception` do nothing by themselves; they have to be thrown
    in order to be noticed by the program.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，异常是`exception`类的对象。记住，除非你想要在文件顶部使用`use Exception;`包含它，否则需要在类名前添加反斜杠。`Exception`类的构造函数接受一些可选参数，其中第一个是异常的消息。`Exception`类的实例本身并不做任何事情；它们必须被抛出才能被程序注意到。
- en: 'Let''s try forcing our program to throw this exception. In order to do that,
    let''s try to create a customer with a negative ID. In your `init.php` file, add
    the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试强制我们的程序抛出这个异常。为了做到这一点，让我们尝试创建一个ID为负数的客户。在你的`init.php`文件中，添加以下内容：
- en: '[PRE67]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If you try it now in your browser, PHP will throw a fatal error saying that
    there was an uncaught exception, which is the expected behavior. For PHP, an exception
    is something from what it cannot recover, so it will stop execution. That is far
    from ideal, as you would like to just display an error message to the user, and
    let them try again.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在在浏览器中尝试，PHP将抛出一个致命错误，表示存在未捕获的异常，这是预期的行为。对于PHP来说，异常是它无法恢复的东西，所以它会停止执行。这远非理想，因为你希望只是向用户显示一个错误消息，并让他们再次尝试。
- en: 'You can—and should—capture exceptions using the `try…catch` blocks. You insert
    the code that might throw an exception in the `try` block and if an exception
    happens, PHP will jump to the `catch` block. Let''s see how it works:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以——并且应该——使用`try…catch`块来捕获异常。你将可能抛出异常的代码放入`try`块中，如果发生异常，PHP将跳转到`catch`块。让我们看看它是如何工作的：
- en: '[PRE68]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note that after the exception is thrown, nothing else inside the `try` block
    is executed; PHP goes straight to the `catch` block. Additionally, the block gets
    an argument, which is the exception thrown. Here, type hinting is mandatory—you
    will see why very soon. Naming the argument as `$e` is a widely used convention,
    even though it is not a good practice to use poor descriptive names for variables.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在抛出异常之后，`try`块内的其他代码将不会执行；PHP会直接跳转到`catch`块。此外，该块会接收到一个参数，即抛出的异常。在这里，类型提示是强制性的——你很快就会明白原因。将参数命名为`$e`是一个广泛使用的约定，尽管使用不具描述性的变量名并不是一个好的实践。
- en: 'Being a bit critical, so far, there is not any real advantage to be seen in
    using exceptions in this example. A simple `if…else` block would do exactly the
    same job, right? But the real power of exceptions lies in the ability to be propagated
    across methods. That is, the exception thrown on the `setId` method, if not captured,
    will be propagated to wherever the method was invoked, allowing us to capture
    it there. This is very useful, as different places in the code might want to handle
    the exception in a different way. To see how this is done, let''s remove the `try…catch`
    inserted in `setId`, and place the following piece of code in your `init.php`
    file, instead:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点批评性的看法，到目前为止，在这个例子中使用异常并没有看到任何真正的优势。一个简单的`if…else`块就能完成同样的工作，对吧？但异常的真正力量在于它们能够在方法之间传播。也就是说，如果在`setId`方法上抛出的异常没有被捕获，它将会传播到方法被调用的任何地方，这样我们就可以在那里捕获它。这非常有用，因为代码的不同地方可能需要以不同的方式处理异常。为了看到这是如何完成的，让我们从`setId`中移除插入的`try…catch`，并将以下代码片段放入你的`init.php`文件中，代替它：
- en: '[PRE70]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The preceding example shows how useful it is to catch propagated exceptions:
    we can be more specific of what happens, as we know what the user was trying to
    do when the exception was thrown. In this case, we know that we were trying to
    create the customer, but this exception might have been thrown when trying to
    update the ID of an existing customer, which would need a different error message.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子展示了捕获传播的异常是多么有用：我们可以更具体地了解发生了什么，因为我们知道当异常抛出时用户正在尝试做什么。在这种情况下，我们知道我们正在尝试创建客户，但这个异常可能是在尝试更新现有客户的ID时抛出的，这将需要一个不同的错误消息。
- en: The finally block
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`finally`块'
- en: 'There is a third block that you can use when dealing with exceptions: the `finally`
    block. This block is added after the `try…catch` one, and it is optional. In fact,
    the `catch` block is optional too; the restriction is that a `try` must be followed
    by at least one of them. So you could have these three scenarios:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理异常时，你可以使用第三个块：`finally`块。这个块是在`try…catch`块之后添加的，它是可选的。事实上，`catch`块也是可选的；限制是`try`之后必须至少跟有一个。所以你可以有这三种情况：
- en: '[PRE71]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If you try this, your browser will show you the following output—remember to
    display the source code of the page to see it formatted prettily:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试这样做，你的浏览器将显示以下输出——记得显示页面的源代码以看到它格式得很好：
- en: '![The finally block](img/00022.jpeg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![The finally block](img/00022.jpeg)'
- en: The result might not be the one you expected. The first time we invoke the function,
    we are able to create the object without an issue, and that means we execute the
    `return` statement. In a normal function, this should be the end of it, but since
    we are inside the `try…catch…finally` block, we still need to execute the `finally`
    code! The second example looks more intuitive, jumping from the `try` to the `catch`,
    and then to the `finally` block.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能不是你所预期的。第一次调用函数时，我们能够无问题地创建对象，这意味着我们执行了`return`语句。在一个正常的函数中，这应该是结束的地方，但由于我们处于`try…catch…finally`块中，我们仍然需要执行`finally`代码！第二个例子看起来更直观，从`try`跳到`catch`，然后到`finally`块。
- en: The `finally` block is very useful when dealing with expensive resources like
    database connections. In [Chapter 5](part0045_split_000.html#1AT9A1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 5. Using Databases"), *Using Databases*, you will see how to use them.
    Depending on the type of connection, you will have to close it after use for allowing
    other users to connect. The `finally` block is used for closing those connections,
    regardless of whether the function throws an exception or not.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`块在处理像数据库连接这样的昂贵资源时非常有用。在[第5章](part0045_split_000.html#1AT9A1-edcc22b134104d5db0bf3aa086c86851
    "第5章。使用数据库")“使用数据库”中，你将看到如何使用它们。根据连接的类型，你将需要在使用后关闭它，以便其他用户可以连接。`finally`块用于关闭这些连接，无论函数是否抛出异常。'
- en: Catching different types of exceptions
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获不同类型的异常
- en: 'Exceptions have already been proven useful, but there is still one important
    feature to show: catching different types of exceptions. As you already know,
    exceptions are instances of the class `Exception`, and as with any other class,
    they can be extended. The main goal of extending from this class is to create
    different types of exceptions, but we will not add any logic inside—even though
    you can, of course. Let''s create a class that extends from `Exception`, and which
    identifies exceptions related to invalid IDs. Put this code inside the `src/Exceptions/InvalidIdException.php`
    file:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 异常已经被证明是有用的，但还有一个重要的特性要展示：捕获不同类型的异常。正如你所知道的那样，异常是 `Exception` 类的实例，并且像任何其他类一样，它们可以被扩展。从该类扩展的主要目标是创建不同类型的异常，但我们不会在其中添加任何逻辑——尽管你当然可以。让我们创建一个从
    `Exception` 扩展的类，并标识与无效ID相关的异常。将此代码放入 `src/Exceptions/InvalidIdException.php`
    文件中：
- en: '[PRE74]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `InvalidIdException` class extends from the class `Exception`, and so it
    can be thrown as one. The constructor of the class takes an optional argument,
    `$message`. The following two lines inside it contain interesting code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvalidIdException` 类从 `Exception` 类扩展，因此它可以被抛出。该类的构造函数接受一个可选参数 `$message`。它内部的以下两行代码很有趣：'
- en: 'The `?:` operator is a shorter version of a conditional, and works like this:
    the expression on the left is returned if it does not evaluate to `false`, otherwise,
    the expression on the right will be returned. What we want here is to use the
    message given by the user, or a default one in case the user does not provide
    any. For more information and usages, you can visit the PHP documentation at [http://php.net/manual/en/language.operators.comparison.php](http://php.net/manual/en/language.operators.comparison.php).'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?:` 运算符是条件运算符的简短版本，其工作方式如下：如果左边的表达式不评估为 `false`，则返回该表达式，否则返回右边的表达式。我们在这里想要使用用户给出的消息，或者在没有提供任何消息的情况下使用默认消息。有关更多信息和使用方法，你可以访问
    PHP 文档 [http://php.net/manual/en/language.operators.comparison.php](http://php.net/manual/en/language.operators.comparison.php)。'
- en: '`parent::__construct` will invoke the parent''s constructor, that is, the constructor
    of the class `Exception`. As you already know, this constructor gets the message
    of the exception as the first argument. You could argue that, as we are extending
    from the `Exception` class, we do not really need to call any functions, as we
    can edit the properties of the class straightaway. The reason for avoiding this
    is to let the parent class manage its own properties. Imagine that, for some reason,
    in a future version of PHP, `Exception` changes the name of the property for the
    message. If you modify it directly, you will have to change that in your code,
    but if you use the constructor, you have nothing to fear. Internal implementations
    are more likely to change than external interfaces.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent::__construct` 将调用父类的构造函数，即 `Exception` 类的构造函数。正如你所知道的那样，这个构造函数将异常的消息作为第一个参数。你可以争论，因为我们是从
    `Exception` 类扩展的，所以我们实际上不需要调用任何函数，因为我们可以直接编辑类的属性。避免这样做的原因是让父类管理自己的属性。想象一下，由于某种原因，在
    PHP 的未来版本中，`Exception` 改变了消息属性的名字。如果你直接修改它，你将不得不在代码中做相应的更改，但如果你使用构造函数，你就不必担心。内部实现比外部接口更可能发生变化。'
- en: 'We can use this new exception instead of the generic one. Replace it in your
    `Unique` trait as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个新的异常代替通用的异常。在你的 `Unique` 特性中按照以下方式替换它：
- en: '[PRE75]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You can see that we are still sending a message: that is because we want to
    be even more specific. But the exception would work as well without one. Try your
    code again, and you will see that nothing changes.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们仍在发送消息：这是因为我们想要更加具体。但即使没有消息，异常也能正常工作。再次尝试你的代码，你会看到没有任何变化。
- en: 'Now imagine that we have a very small database and we cannot allow more than
    50 users. We can create a new exception that identifies this case, let''s say,
    as `src/Exceptions/ExceededMaxAllowedException.php`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们有一个非常小的数据库，我们不允许超过50个用户。我们可以创建一个新的异常来标识这种情况，比如说，作为 `src/Exceptions/ExceededMaxAllowedException.php`：
- en: '[PRE76]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let''s modify our trait in order to check for this case. When setting an ID,
    if this ID is greater than 50, we can assume that we''ve reached the maximum number
    of users:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的特性，以便检查这种情况。当设置ID时，如果这个ID大于50，我们可以假设我们已经达到了用户数量的最大值：
- en: '[PRE77]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now the preceding function throws two different exceptions: `InvalidIdException`
    and `ExceededMaxAllowedException`. When catching them, you might want to behave
    in a different way depending on the type of exception caught. Remember how you
    have to declare an argument in your `catch` block? Well, you can add as many `catch`
    blocks as needed, specifying a different exception class in each of them. The
    code could look like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在先前的函数抛出了两种不同的异常：`InvalidIdException`和`ExceededMaxAllowedException`。在捕获它们时，你可能希望根据捕获到的异常类型以不同的方式行事。还记得你必须在`catch`块中声明一个参数吗？嗯，你可以根据需要添加尽可能多的`catch`块，在每个块中指定不同的异常类。代码可能看起来像这样：
- en: '[PRE78]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'If you try this code, you should see the following output:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试这段代码，你应该看到以下输出：
- en: '![Catching different types of exceptions](img/00023.jpeg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![捕获不同类型的异常](img/00023.jpeg)'
- en: 'Note that we catch three exceptions here: our two new exceptions and the generic
    one. The reason for doing this is that it might happen that some other piece of
    code throws an exception of a different type than the ones we defined, and we
    need to define a `catch` block with the generic `Exception` class to get it, as
    all exceptions will extend from it. Of course, this is absolutely optional, and
    if you do not do it, the exception will be just propagated.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里我们捕获了三种异常：我们定义的两个新异常和通用的一个。这样做的原因是，可能存在其他代码块抛出与我们定义的类型不同的异常，我们需要定义一个带有通用`Exception`类的`catch`块来捕获它，因为所有异常都将从这个类扩展出来。当然，这完全是可选的，如果你不这样做，异常将只是被传播。
- en: 'Bear in mind the order of the `catch` blocks. PHP tries to use the `catch`
    blocks in the order that you defined them. So, if your first catch is for `Exception`,
    the rest of the blocks will be never executed, as all exceptions extend from that
    class. Try it with the following code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住`catch`块的顺序。PHP会尝试按照你定义的顺序使用`catch`块。所以，如果你的第一个`catch`是针对`Exception`的，那么其余的块将永远不会被执行，因为所有异常都从这个类扩展出来。尝试以下代码：
- en: '[PRE79]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The result that you get from the browser will always be from the first catch:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器返回的结果始终来自第一个`catch`：
- en: '![Catching different types of exceptions](img/00024.jpeg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![捕获不同类型的异常](img/00024.jpeg)'
- en: Design patterns
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: Developers have been creating code since way before the appearance of with Internet,
    and they have been working on a number of different areas, not just web applications.
    Because of that, a lot of people have already had to confront similar scenarios,
    carrying the experience of previous attempts for fixing the same thing. In short,
    it means that almost surely, someone has already designed a good way of solving
    the problem that you are facing now.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者早在互联网出现之前就已经开始编写代码了，他们一直在多个不同的领域工作，而不仅仅是网页应用。正因为如此，很多人已经不得不面对类似的场景，带着之前尝试修复同样问题的经验。简而言之，这意味着几乎可以肯定，有人已经设计了一种很好的解决你现在面临问题的方法。
- en: A lot of books have been written trying to group solutions to common problems,
    also known as **design patterns**. Design patterns are not algorithms that you
    copy and paste into your program, showing how to fix something step-by-step, but
    rather recipes that show you, in a heuristic way, how to look for the answer.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有很多书籍被写出来，试图将常见问题的解决方案分组，也称为**设计模式**。设计模式不是你可以复制粘贴到程序中的算法，展示如何一步一步地修复某个问题，而是一系列食谱，以启发式的方式向你展示如何寻找答案。
- en: Studying them is essential if you want to become a professional developer, not
    only for solving problems, but also for communicating with other developers. It
    is very common to get an answer like "You could use a factory here", when discussing
    your program design. It saves a lot of time knowing what a factory is, rather
    than explaining the pattern each time someone mentions it.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要成为一名专业开发者，研究它们是必不可少的，这不仅是为了解决问题，也是为了与其他开发者沟通。在讨论你的程序设计时，得到一个像“这里你可以使用工厂”这样的答案是非常常见的。知道工厂是什么，而不是每次有人提到它时都解释模式，可以节省很多时间。
- en: As we said, there are entire books that talk about design patterns, and we highly
    recommend you to have a look at some of them. The goal of this section is to show
    you what a design pattern is and how you can use it. Additionally, we will show
    you some of the most common design patterns used with PHP when writing web applications,
    excluding the MVC pattern, which we will study in [Chapter 6](part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 6. Adapting to MVC"), *Adapting to MVC*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，有整本书都在讨论设计模式，我们强烈建议您看看其中的一些。本节的目标是向您展示什么是设计模式以及如何使用它。此外，我们还将向您展示一些在编写Web应用程序时使用PHP的常见设计模式，不包括MVC模式，我们将在[第6章](part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851
    "第6章。适应MVC")，*适应MVC*中学习。
- en: Other than books, you could also visit the open source project **DesignPatternsPHP**
    at [http://designpatternsphp.readthedocs.org/en/latest/README.html](http://designpatternsphp.readthedocs.org/en/latest/README.html).
    There is a good collection of them, and they are implemented in PHP, so it would
    be easier for you to adapt.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 除了书籍之外，您还可以访问开源项目**DesignPatternsPHP**，网址为[http://designpatternsphp.readthedocs.org/en/latest/README.html](http://designpatternsphp.readthedocs.org/en/latest/README.html)。那里有很好的集合，并且它们是用PHP实现的，因此您更容易适应。
- en: Factory
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂
- en: A **factory** is a design pattern of the creational group, which means that
    it allows you to create objects. You might think that we do not need such a thing,
    as creating an object is as easy as using the `new` keyword, the class, and its
    arguments. But letting the user do that is dangerous for different reasons. Apart
    from the increased difficulty caused by using `new` when unit testing our code
    (you will learn about unit testing in [Chapter 7](part0064_split_000.html#1T1402-edcc22b134104d5db0bf3aa086c86851
    "Chapter 7. Testing Web Applications"), *Testing Web Applications*), a lot of
    coupling too gets added into our code.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**工厂**是创建型设计模式之一，这意味着它允许您创建对象。您可能会想，我们不需要这样的东西，因为创建一个对象就像使用`new`关键字、类及其参数一样简单。但是让用户这样做是有危险的，原因有很多。除了使用`new`进行单元测试时增加的难度（您将在[第7章](part0064_split_000.html#1T1402-edcc22b134104d5db0bf3aa086c86851
    "第7章。测试Web应用程序")中学习单元测试），*测试Web应用程序*），我们的代码中还会增加很多耦合。'
- en: When we discussed encapsulation, you learned that it is better to hide the internal
    implementation of a class, and you could consider the constructor as part of it.
    The reason is that the user needs to know at all times how to create objects,
    including what the arguments of the constructor are. And what if we want to change
    our constructor to accept different arguments? We need to go one by one to all
    the places where we have created objects and update them.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论封装时，您了解到隐藏类的内部实现是更好的做法，您可以将构造函数视为其中的一部分。原因是用户需要始终知道如何创建对象，包括构造函数的参数是什么。如果我们想改变构造函数以接受不同的参数怎么办？我们需要逐个检查所有创建对象的地方并更新它们。
- en: Another reason for using factories is to manage different classes that inherit
    a super class or implement the same interface. As you know, thanks to polymorphism,
    you can use one object without knowing the specific class that it instantiates,
    as long as you know the interface being implemented. It might so happen that your
    code needs to instantiate an object that implements an interface and use it, but
    the concrete class of the object may not be important at all.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工厂的另一个原因是管理继承自超类或实现相同接口的不同类。正如您所知，多态性使得您可以使用一个对象，而无需知道它实例化的具体类，只要您知道正在实现的接口。可能发生的情况是，您的代码需要实例化一个实现接口的对象并使用它，但该对象的实际类可能根本不重要。
- en: 'Think about our bookstore example. We have two types of customers: basic and
    premium. But for most of the code, we do not really care what type of customer
    a specific instance is. In fact, we should implement our code to use objects that
    implement the `Customer` interface, being unaware of the specific type. So, if
    we decide in the future to add a new type, as long as it implements the correct
    interface, our code will work without an issue. But, if that is the case, what
    do we do when we need to create a new customer? We cannot instantiate an interface,
    so let''s use the factory pattern. Add the following code into `src/Domain/Customer/CustomerFactory.php`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 想想我们的书店例子。我们有两种类型的客户：基本和高级。但在大多数代码中，我们并不真正关心特定实例是哪种类型的客户。事实上，我们应该编写我们的代码以使用实现`Customer`接口的对象，而无需了解具体的类型。所以，如果我们决定将来添加一个新类型，只要它实现了正确的接口，我们的代码将无问题地工作。但是，如果是这种情况，当我们需要创建一个新的客户时，我们无法实例化一个接口，所以让我们使用工厂模式。将以下代码添加到`src/Domain/Customer/CustomerFactory.php`中：
- en: '[PRE80]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The factory in the preceding code is less than ideal for different reasons.
    In the first one, we use a `switch`, and add a case for all the existing customer
    types. Two types do not make much difference, but what if we have 19? Let's try
    to make this factory method a bit more dynamic.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码中的工厂由于不同的原因并不理想。首先，我们使用了一个`switch`语句，并为所有现有的客户类型添加了一个情况。两种类型并不算多，但如果我们有19种呢？让我们尝试使这个工厂方法更加动态。
- en: '[PRE81]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Yes, you can do what we did in the preceding code in PHP. Instantiating classes
    dynamically, that is, using the content of a variable as the name of the class,
    is one of the things that makes PHP so flexible… and dangerous. Used wrongly,
    it will make your code horribly difficult to read and maintain, so be careful
    about it. Note too the constant `__NAMESPACE__`, which contains the namespace
    of the current file.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你可以在PHP中做我们之前代码中所做的那样。动态实例化类，即使用变量的内容作为类的名称，是PHP如此灵活……以及危险的原因之一。使用不当，它会使你的代码难以阅读和维护，所以对此要小心。还要注意常量`__NAMESPACE__`，它包含当前文件的作用域。
- en: Now this factory looks cleaner, and it is also very dynamic. You could add more
    customer types and, as long as they are inside the correct namespace and implement
    the interface, there is nothing to change on the factory side, nor in the usage
    of the factory.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个工厂看起来更简洁，而且它也非常灵活。你可以添加更多客户类型，只要它们在正确的命名空间内并实现了接口，那么在工厂的这一侧以及工厂的使用上就无需做任何更改。
- en: 'In order to use it, let''s change our `init.php` file. You can remove all our
    tests, and just leave the autoloader code. Then, add the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用它，让我们更改我们的`init.php`文件。你可以移除所有的测试，只留下自动加载的代码。然后，添加以下内容：
- en: '[PRE82]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The factory design pattern can be as complex as you need. There are different
    variants of it, and each one has its own place and time, but the general idea
    is always the same.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂设计模式可以像你需要的那样复杂。它有不同的变体，每一种都有其合适的时间和地点，但总体思想始终相同。
- en: Singleton
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例
- en: If someone with a bit of experience with design patterns, or web development
    in general, reads the title of this section, they will probably start tearing
    their hair out and claiming that singleton is the worst example of a design pattern.
    But just bear with me.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人对设计模式或一般意义上的Web开发有一些经验，他们看到这个章节的标题时，可能会开始拔自己的头发并声称单例是设计模式中最糟糕的例子。但请耐心听我说。
- en: When explaining interfaces, I added a note about how developers tend to complicate
    their code too much just so they can use all the tools they know. Using design
    patterns is one of the cases where this happens. They have been so famous, and
    people claimed that good use of them is directly linked to great developers, that
    everybody that learns them tries to use them absolutely everywhere.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当解释接口时，我添加了一条关于开发者倾向于使他们的代码过于复杂，仅仅是为了能够使用他们所知道的所有工具的注释。使用设计模式就是这种情况之一。它们已经非常著名，人们声称对它们的良好使用与优秀开发者直接相关，因此每一个学习它们的人都会试图在绝对任何地方使用它们。
- en: The singleton pattern is probably the most infamous of the design patterns used
    in PHP for web development. This pattern has a very specific purpose, and when
    that is the case, the pattern proves to be very useful. But this pattern is so
    easy to implement that developers continuously try to add singletons everywhere,
    turning their code into something unmaintainable. It is for this reason that people
    call this an anti-pattern, something that should be avoided rather than used.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: I do agree with this point of view, but I still think that you should be very
    familiar with this design pattern. Even though you should avoid its overuse, people
    still use it everywhere, and they refer to it countless times, so you should be
    in a position to either agree with them or rather have enough reasons to discourage
    them to use it. Having said that, let's see what the aim of the singleton pattern
    is.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is simple: singletons are used when you want one class to always have
    one unique instance. Every time, and everywhere you use that class, it has to
    be through the same instance. The reason is to avoid having too many instances
    of some heavy resource, or to keep always the same state everywhere—to be global.
    Examples of this are database connections or configuration handlers.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that in order to run, our application needs some configuration, such
    as credentials for the database, URLs of special endpoints, directory paths for
    finding libraries or important files, and so on. When you receive a request, the
    first thing you do is to load this configuration from the filesystem, and then
    you store it as an array or some other data structure. Save the following code
    as your `src/Utils/Config.php` file:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'As you can see, this class uses a new exception. Create it under `src/Utils/NotFoundException.php`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Also, the class reads a file, `config/app.json`. You could add the following
    JSON map inside it:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In order to use this configuration, let's add the following code into your `init.php`
    file.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: That seems a very good way to read configuration, right? But pay attention to
    the highlighted line. We instantiate the `Config` object, hence, we read a file,
    transform its contents from JSON to array, and store it. What if the file contains
    hundreds of lines instead of just six? You should notice then that instantiating
    this class is very expensive.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: You do not want to read the files and transform them into arrays each time you
    ask for some data from your configuration. That is way too expensive! But, for
    sure, you will need the configuration array in very different places of your code,
    and you cannot carry this array everywhere you go. If you understood static properties
    and methods, you could argue that implementing a static array inside the object
    should fix the problem. You instantiate it once, and then just call a static method
    that will access an already populated static property. Theoretically, we skip
    the instantiation, right?
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This seems to be a good idea, but it is highly dangerous. How can you be absolutely
    sure that the array has already been populated? And how can you be sure that,
    even using a static context, the user will not keep instantiating this class again
    and again? That is where singletons come in handy.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing a singleton implies the following points:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Make the constructor of the class private, so absolutely no one from outside
    the class can ever instantiate that class.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a static property named `$instance`, which will contain an instance of
    itself—that is, in our `Config` class, the `$instance` property will contain an
    instance of the class `Config`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a static method, `getInstance`, which will check if `$instance` is null,
    and if it is, it will create a new instance using the private constructor. Either
    way, it will return the `$instance` property.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see what the singleton class would look like:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If you run this code right now, it will throw you an error, as the constructor
    of this class is private. First achievement unlocked! Let''s use this class properly:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Does it convince you? It proves to be very handy indeed. But I cannot emphasize
    this enough: be careful when you use this design pattern, as it has very, very,
    specific use cases. Avoid falling into the trap of implementing it everywhere!'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Anonymous functions**, or **lambda functions**, are functions without a name.
    As they do not have a name, in order to be able to invoke them, we need to store
    them as variables. It might be strange at the beginning, but the idea is quite
    simple. At this point of time, we do not really need any anonymous function, so
    let''s just add the code into `init.php`, and then remove it:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This preceding anonymous function gets assigned to the variable `$addTaxes`.
    It expects three arguments: `$book` (an array as a reference), `$index` (not used),
    and `$percentage`. The function adds taxes to the price key of the book, rounded
    to 2 decimal places (`round` is a native PHP function). Do not mind the argument
    `$index`, it is not used in this function, but forced by how we will use it, as
    you will see.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'You could instantiate a list of books as an array, iterate them, and then call
    this function each time. An example could be as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'In order to use the function, you just invoke it as if `$addTaxes` contained
    the name of the function to be invoked. The rest of the function works as if it
    was a normal function: it receives arguments, it can return a value, and it has
    a scope. What is the benefit of defining it in this way? One possible application
    would be to use it as a **callable**. A callable is a variable type that identifies
    a function that PHP can call. You send this callable variable as an argument,
    and the function that receives it can invoke it. Take the PHP native function,
    `array_walk`. It gets an array, a callable, and some extra arguments. PHP will
    iterate the array, and for each element, it will invoke the callable function
    (just like the `foreach` loop). So, you can replace the whole loop by just the
    following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The callable that `array_walk` receives needs to take at least two arguments:
    the value and the index of the current element of the array, and thus, the `$index`
    argument that we were forced to implement previously. It can optionally take extra
    arguments, which will be the extra arguments sent to `array_walk`—in this case,
    the 0.16 as `$percentage`.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, anonymous functions are not the only callable in PHP. You can send
    normal functions and even class methods. Let''s see how:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In the preceding example, you can see how we can use each case as a callable.
    For normal methods, just send the name of the method as a string. For static methods
    of a class, send an array with the name of the class in a way that PHP understands
    (either the full name including namespace, or adding the `use` keyword beforehand),
    and the name of the method, both as strings. To use a normal method of a class,
    you need to send an array with an instance of that class and the method name as
    a string.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: OK, so anonymous functions can be used as callable, just as any other function
    or method can. So what is so special about them? One of the things is that anonymous
    functions are variables, and so they have all the advantages—or disadvantages—that
    a variable has. That includes scope—that is, the function is defined inside a
    scope, and as soon as this scope ends, the function will no longer be accessible.
    That can be useful if your function is extremely specific to that bit of code,
    and there is no way you will want to reuse it somewhere else. Moreover, as it
    is nameless, you will not have conflicts with any other existing function.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another benefit in using anonymous functions: inheriting variables
    from the parent scope. When you define an anonymous function, you can specify
    some variable from the scope where it is defined with the keyword `use`, and use
    it inside the function. The value of the variable will be the one it had at the
    moment of declaring the function, even if it is updated later. Let''s see an example:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The preceding example shows you how to use the keyword `use`. Even when we
    update `$percentage` after defining the function, the result shows you that the
    taxes were only 16%. This is useful, as it liberates you from having to send `$percentage`
    everywhere you want to use the function `$addTaxes`. If there is a scenario where
    you really need to have the updated value of the used variables, you can declare
    them as a reference as you would with a normal function''s argument:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子展示了如何使用关键字`use`。即使我们在定义函数后更新`$percentage`，结果也会显示税率仅为16%。这很有用，因为它让你不必在想要使用函数`$addTaxes`的任何地方都发送`$percentage`。如果确实有需要使用已更新变量值的场景，你可以像在普通函数的参数中那样，将它们声明为引用：
- en: '[PRE95]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: In this last example, the first `array_walk` used the original value 0.16, as
    that was still the value of the variable. But on the second call, `$percentage`
    had already changed, and it affected the result of the anonymous function.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的例子中，第一个`array_walk`使用了原始值0.16，因为那时变量的值仍然是这个。但在第二次调用时，`$percentage`已经改变，这影响了匿名函数的结果。
- en: Summary
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned what object-oriented programming is, and how
    to apply it to our web application for creating a clean code, which is easy to
    maintain. You also know how to manage exceptions properly, the design patterns
    that are used the most, and how to use anonymous functions when necessary.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学习了什么是面向对象编程，以及如何将其应用于我们的Web应用程序以创建易于维护的清晰代码。你还知道了如何正确地管理异常，最常用的设计模式，以及何时使用匿名函数。
- en: In the next chapter, we will explain how to manage the data of your application
    using databases so that you can completely separate data from code.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将解释如何使用数据库来管理你的应用程序数据，这样你就可以完全将数据与代码分离。
