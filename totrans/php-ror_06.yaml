- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging Ruby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like with any other significant programming language, Ruby has a number
    of tools to help us analyze, fix, and improve our code. According to a software
    architect I encountered many years ago, the disparity between a programmer who
    possesses debugging skills and one who lacks them equates to the distinction between
    a junior programmer and a senior programmer. By using the right tools to debug
    our code, we can both improve our code and improve our understanding of how the
    language is interpreted, which in the long run, is beneficial to our path as developers.
    Let’s take a look at the tools that come with Ruby out of the box, as well as
    the gems that the Ruby community has developed to debug our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'With debugging in mind, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging functions in Ruby versus PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gems for debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding **Interactive Ruby** (IRB)’s usefulness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Any IDE to view/edit code (e.g., Sublime Text, Visual Studio Code, Notepad++,
    Vim, Emacs, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For macOS users, you will also need to have Xcode Command Line Tools installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby version 2.6 or later installed and ready to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code presented in this chapter is available at [https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/).
  prefs: []
  type: TYPE_NORMAL
- en: Debugging functions in Ruby versus PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we’ve made scripts and code snippets making sure that our code works
    correctly every time. However, in the real world, we’ll come into contact with
    code that someone else has created and either wasn’t tested, or it wasn’t tested
    in a scenario that hadn’t come up until now. This happens more often than not,
    and we should be prepared to get our hands dirty to fix these types of issues.
    In PHP, we have a couple of functions that will help us debug in the simplest
    way. You are welcome to just read the following example and not follow along.
    For now, let’s take a look at PHP’s `var_dump()` function. We can open a command
    shell and create a file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s say we ran the following PHP script on our shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It should output something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'At first glance, we may or may not see the error within the code. If you saw
    the error at first glance, congratulations, you’re off to a good start. But for
    those who didn’t see the error at first glance, let’s use the `var_dump()` function.
    Let’s comment out the last line and add this to the ending line of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And let’s run this script again from our shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP, the `var_dump()` function is super useful as it outputs variables,
    its contents, and its content types. Notice that in this case, `var_dump($person)`
    is telling us that we have an array, and said array has two elements. These two
    elements in the array are strings. We also notice that the first associative element
    (`["firSt"]`) looks strange. It has a capital “S” in the middle. So, let’s make
    the correction and remove our debugging code. Our code should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We run it once more in our shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'While this might not be the best debugging tool, it certainly is a very straightforward
    way to debug code in PHP. I personally am quite fond of this function as it was
    the very first function I used to debug in my life. Additionally, this is an oversimplified
    example, but in essence portrays real scenarios, especially when you debug during
    web development as sometimes you don’t know what is being sent to your script.
    If you are more interested in this function, you should take a look at the function’s
    documentation page: [https://www.php.net/manual/en/function.var-dump.php](https://www.php.net/manual/en/function.var-dump.php).'
  prefs: []
  type: TYPE_NORMAL
- en: You may also want to take a look at the `print_r()` and `var_export()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Ruby, we don’t really have a `var_dump()` function, but instead, every object
    has a method already available called `inspect()`. The `inspect()` method converts
    the contents of an object to a string and returns it. Let’s redo the same example
    but in Ruby. Let’s create a file called `buggy_code.rb` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s say we were to run this script on our shell with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We would get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We know ahead of time what the error is, but for educational purposes, let’s
    debug the `person` object by adding the following to our code so that it will
    now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We run this script on the shell with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: While we could accomplish the same effect by just using `print()`, this is only
    true because we’re analyzing the contents of a hash in this example. If the previous
    example had a class object, the `print()` function would not show us all of the
    contents of an object. The `inspect()` method is more generic as it outputs the
    contents of any type of object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we already know the fix, we can just go ahead and fix the example. Our
    code should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we can run it again just to verify that our script runs correctly by
    running this on the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This would return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: And with this, we’ve learned a very PHP-esque way to debug scripts. Fortunately,
    we are not going further down this road. Instead, let’s take a look into other
    more Ruby-esque ways to debug.
  prefs: []
  type: TYPE_NORMAL
- en: Gems for debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you probably guessed, the Ruby community came across the debugging problem
    just like any other programming community and thus has come up with libraries
    (or gems) to encapsulate different debug behaviors. We’ll talk specifically about
    three gems that make your debugging experience a whole different path than just
    dumping values in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: Debug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Byebug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these gems were designed for the same purpose, but each one has its own
    peculiarities and it will depend on your own preference which one you choose to
    use in your projects. Let’s start by looking at the first one.
  prefs: []
  type: TYPE_NORMAL
- en: The debug gem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This gem comes as a replacement (and improvement) to the traditional `lib/debug.rb`
    standard library. While there are various ways to use this gem, let’s start by
    installing our gem and creating a simple debuggable example. First, we will have
    to do some setup. Let’s use a Gemfile, which we learned about in previous chapters.
    In an empty folder, create a file called `Gemfile` and add the following code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to install the gems listed in this file by running the following
    command within our shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This should output something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And with this, we have installed the debug gem in our system. Now let’s test
    it out. To save time, you should download the example from the GitHub repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/blob/main/chapter06/debuggable_example.rb](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/blob/main/chapter06/debuggable_example.rb)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also type the whole code, though I wouldn’t recommend it as it contains
    a very long string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code may seem a bit complicated at first, but for now, let’s focus
    on running it and the output, and we will explain the outcome of the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run our code from the shell with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Our code is basically ciphering a password with an algorithm called SHA2 and
    compares it to an already ciphered string with the same algorithm. We use the
    `digest` module, which we import at the beginning of the file, to cipher the password
    with `Digest::SHA2`. If the passwords match, we should get the message `Your password
    is CORRECT`. However, we can infer from the output that the passwords do not match.
    To debug, instead of printing values here and there with the `print()` function,
    let’s use the debug gem. Since we already installed the gem, we can just import
    said gem into our script. Let’s do that. Let’s add the `require` statement to
    our third line of code so that the first four lines of code now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the gem has been imported, we can now create a breakpoint. A breakpoint
    is a line of code that is taken by a debugger program to pause the execution and
    let us analyze a program within that specific line of code. It’ll be more clear
    once we try it out. So, let’s add a breakpoint right after the hash value for
    `name` that has been set. Our code should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s run our script just like any other script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'But you’ll notice something new. Our script will now result in a pause in the
    middle of the execution. Instead of outputting the text, our shell will now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve truncated the ciphered value (`''32b3639…''`), but on your screen, it
    should show the full value. Notice how the execution has paused. What sorcery
    is this? Nothing other than the debug gem in action. And we can now even test
    things out. For example, let’s see what’s inside of the user hash. Within our
    debug shell, let’s type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Right after pressing *Enter*, the shell will return the value that has been
    assigned to `user`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how our `user` variable has both `name` and `password` indexes. But
    what would happen if we tried to get the value of the `user_sha2_input` variable?
    Let’s do it. On the debug shell, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns an empty value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the program has not yet reached the code where that variable
    is set. However, this special shell is already providing useful information by
    showing us all sorts of data related to the execution, such as what script we
    are running (`debuggable_example.rb`), and what line we are currently at (`=>
    9| binding.break`). We can also interact with this shell. Let’s type `next` and
    then press *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will move forward in the breakpoint one line at a time. The shell will
    re-render again so that it now displays the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we moved from line 9 to line 10\. Let’s move one more line of code
    so that we allow the program to assign the password. This time we will use the
    shortcut for `next`, which is just the first letter, `n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As it renders yet again, we now see that our breakpoint has moved to the `if`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can view the contents of the password. Again, let’s type the `user_sha2_input`
    variable in this debugging shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We confirm that the value is now there, as the output is now the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where our shell becomes extremely handy. We can test the `if` clause
    prior to executing it. Let’s copy the `if` clause, but without the `if` keyword,
    and paste it into the debug shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns what the `if` sentence is evaluating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Apparently, someone changed the password to our script but made a mistake.
    You see, the problem with the SHA2 algorithm is that it’s not an encryption algorithm
    that you can encrypt and decrypt so that you can get the original value. SHA2
    is a hashing algorithm, which means that you are only able to cipher a value.
    If you need to use it for a password, then what you do is save this ciphered value
    and compare it to the user’s ciphered input. That way, not even the program has
    the original password, thus protecting the user’s password even from the program
    itself. In this case, we can quickly confirm that the passwords don’t match. Let’s
    debug this issue. Let’s compare ciphered values. First, let’s output the `user_sha2_input`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we compare it to the `SECRET_SHA2_PASSWORD` value from our code, we
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Seeing them close to each other, we can easily see just from the first four
    digits that they have different values. But before we fix our code, let’s finish
    our script’s execution with the `continue` debug command by typing it into the
    debug shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This will continue our script’s execution until it either finds another breakpoint
    (of which there are no more in this case) or until it reaches the end of the program
    (as in this case). Additionally, it will output the same text as the first time
    we ran our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the shell is back to normal, we can get on to fixing the issue. Unfortunately,
    there is no way to get the original password (at least not until quantum computers
    are available to us). Fortunately, we already have the correct value from our
    previous debug session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can just copy this value into our `SECRET_SHA2_PASSWORD` variable and remove
    the breakpoint, so our code now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s run it once more to confirm that the fix is correct by typing this in
    our shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we have successfully debugged our script with the debug gem. As
    we previously saw, with the debug gem, we can run a script line by line, and add
    more than one break point, and that was just a simple example. I recommend you
    play around with this gem more and take a peek at other commands that the gem
    supports: [https://github.com/ruby/debug](https://github.com/ruby/debug).'
  prefs: []
  type: TYPE_NORMAL
- en: The pry gem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The debug gem is only one of the options that we have available to debug our
    code nowadays. The second gem we are going to take a look at for debugging is
    the pry gem. As its name clearly suggests, pry is a a gem that spawns an interactive
    console that is able to observe deep within a Ruby program. From its GitHub page,
    we get that pry is an attempt to replace the classic **Interactive Ruby** (or
    **IRB**). Though it has its similarities with the debug gem, it does have its
    own approach to the debug paradigm. Let’s take it out for a test drive so you
    can see what I’m talking about. We’ll start by simply installing the gem by running
    the following command on our command shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can either download the example from [https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/blob/main/chapter06/pryable_example.rb](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/blob/main/chapter06/pryable_example.rb)
    or simply type the code. The file we either download or create should be named
    `pryable_example.rb` and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s execute the script we just created from the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'It should output just a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we made a typo on purpose (failing to include a space between the
    name and last name), but now let’s see the pry magic. Let’s import `pry` and add
    a breakpoint. Our code should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s run our script again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'And, just like the debug gem, we will also enter an interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'What we must consider here is that the commands are going to be different.
    We will start with a simple command within this shell. Let’s type `ls` (that’s
    a lowercase L and a lowercase S), just like the Linux command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The prompt will return something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Pry lists the content (in memory) from our program, and pry lists it as if
    it were a filesystem. If we wanted to “pry” into the `person` object, we could
    navigate as if it were a folder. Let’s do that with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And right after that, let’s do an `ls` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the prompt will show the contents of `person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the version of Ruby that you may have installed, you may see the
    previous prompt or a similar one with slight variations, but one way or another
    they will all show the contents of the `person` object. If we closely take a look,
    we see the `first_name`, `last_name`, and `full_name` methods in addition to the
    `@first_name` and `@last_name` variables. That is one of the advantages of `pry`
    as it allows us to dig deep into an object. Another useful thing we can do is
    fix and reload our code, which simply means that we can change part of the code
    and then reload it into memory without having to stop the current execution. If
    we go to our source code, and we fix line seven by adding a space between `first_name`
    and `last_name`, our code should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, while still in our interactive shell, we run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This should make the prompt show us where our breakpoint is again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s get the full name again by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We then see the fixed full name in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now exit the debug shell with pry’s exit alias (`!!!`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This exits the debug shell. So, as you can see, we have a lot of advantages,
    such as the level of depth of our view of the object. However, we do have a major
    downside. With pry, we can only see the contents of that specific moment of execution.
    We cannot move to another line of code as with debug. What we can do is add multiple
    breakpoints as pry allows it. Either way, don’t let that downside deter you from
    trying it out.
  prefs: []
  type: TYPE_NORMAL
- en: The byebug gem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: And yet another tool that is available for us is the byebug gem. Byebug is another
    debugger that does not depend on internal core sources. It works in a similar
    manner to the two options that we’ve previously reviewed. Additionally, the gem
    has support for popular IDEs such as Sublime, Atom, and VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a quick dive into this tool. We are going to install the byebug
    gem. On a shell, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the following output on our shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the gem is available, let’s create a file called `byeable_example.rb`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s first run our program without any breakpoints. In our shell, let’s type
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Our program is showing the same message for every number, which is not what
    is intended. Since our gem is already installed and loaded, we only need to add
    a breakpoint. And we do that by adding the `byebug` text. Let’s add that to our
    code right before the output variable is printed. Our code should now look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'And again, let’s run our script in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the other debuggers, we see our shell change into an interactive debugging
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'From this shell, we can write commands and see the contents of variables, just
    like we did with debugger and pry. We see the file and the breakpoint that we
    defined on line 7\. At this point, we have access to the `index` variable. Let’s
    type this into the byebug shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We immediately see the value of this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are inside an `each` loop, the value for the `index` variable has been
    populated by the first value from the array (`[1,5,7,9]`), which in this case
    is `1`. We can also view what’s inside the `not_label` variable. Let’s type it
    on the byebug shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we see the contents of said variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the `not_label` variable is taking the `index` value and instead
    of comparing it to 6, we are just passing it to the ternary operator (the `?`
    symbol), ergo the `not_label` variable will always have the text `"NOT"` as its
    value. We can verify this by typing the keyword `continue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The `continue` command will carry on the execution of the program until it
    finds another breakpoint. As we are inside a loop, we will move on to the next
    element in the array, until we reach the breakpoint again. Let’s see what’s inside
    the index value again in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'That confirms that we’ve moved to the next element in the array. Let’s see
    what’s inside of the `not_label` variable again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the same value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'This will happen with every value assigned to the `index` variable. So let’s
    exit by typing the `exit` command on the byebug shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Our shell should go back to normal. Now let’s fix our code by adding a comparison
    inside our `not_label` variable and removing our breakpoint. Our code should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s do a final run of our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This should correctly output the text messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Congrats! Our code has been debugged and fixed. Again, this is a vastly simplified
    example, but I hope you get the idea of how useful byebug is. Byebug has additional
    commands, configuration options, and even a historical log of our commands. Please
    take a look at byebug’s GitHub page for more information: [https://github.com/deivid-rodriguez/byebug](https://github.com/deivid-rodriguez/byebug).'
  prefs: []
  type: TYPE_NORMAL
- en: As you probably noticed, all of these gems work in a very similar manner. As
    we’ll see in the next section, this is because they are all built based on IRB.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding IRB’s usefulness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B19230_03.xhtml#_idTextAnchor037), we briefly saw the **IRB**
    shell, and I hope you noticed some of the similarities between IRB and our debugging
    tools. Basically, what these gems do is enhance IRB so that we can view variables
    in memory, move around execution points, and work in a “frozen” state of our program.
    At the end of the day, you will be able to choose which one of these tools is
    more convenient for your everyday use. I could steer you toward one, or you could
    simply use the built-in IRB. One technique I saw a fellow developer use was that
    he wrote most of his code in IRB, and once the code ran without problems, he would
    just copy the code from IRB into an IDE to save his work. This saved him a lot
    of time that he would have otherwise used on testing. Another coworker used a
    very popular IDE called RubyMine. This tool allows us to add breaking points at
    the touch of a button (among many other features). Additionally, one downside
    of using debuggers is that you add debug code when setting up breakpoints. This
    could potentially break your code if you forget to remove the breakpoints when
    you commit your code into your code base. RubyMine removes that risk as breakpoints
    are not added to your code but rather managed by the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, most IDEs have integrated some sort of debugger mechanism for your
    convenience. As that might be outside of the scope of this book, you might want
    to check those IDEs and their own implementation of debugging on your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.sublimetext.com/](https://www.sublimetext.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://code.visualstudio.com/](https://code.visualstudio.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.jetbrains.com/ruby/](https://www.jetbrains.com/ruby/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whatever path you take is entirely up to you. I just wanted to give you an understanding
    of what IRB is, and how powerful it can be in Ruby development.
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP programmers who come from a Laravel background will be familiar with the
    tinker tool, which is basically an interactive shell for PHP with Laravel components
    loaded. I must admit that tinker ([https://github.com/laravel/tinker](https://github.com/laravel/tinker))
    looks a lot like a tool that Ruby on Rails has: the Rails console. The Rails console
    is basically IRB with Ruby on Rails components loaded for ease of use. But let’s
    not get ahead of ourselves. We first must learn about Ruby on Rails.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the different functions we can use to debug
    in PHP and the equivalent in Ruby, and how to debug our code by using three different
    tools that are easily configured and installed. While not wanting to impose my
    debugging gem of choice, I will say that for several years I used pry, until byebug
    came along. I suggest you not only try byebug but also be on the lookout for new
    debugging gems. We also learned how to add breakpoints to our debug code and how
    useful and powerful these breakpoints can be during development. Lastly, we learned
    that all of these gems are basically enhanced IRBs, so we can easily use any of
    them as they all behave in a very similar fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Having seen all this, we are now ready to board the Ruby on Rails wagon.
  prefs: []
  type: TYPE_NORMAL
- en: Part 2:Ruby and the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will get an introduction to how Ruby is used in web development
    through the most popular Ruby framework, Ruby on Rails. In addition to this, you
    will learn the basics of database handling and views, and finally, get an overview
    of the differences in hosting for Ruby on Rails applications in comparison to
    PHP applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19230_07.xhtml#_idTextAnchor103), *Understanding Convention
    over Configuration*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19230_08.xhtml#_idTextAnchor114), *Models, DBs, and Active Record*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19230_09.xhtml#_idTextAnchor127), *Bringing It All Together*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19230_10.xhtml#_idTextAnchor140), *Considerations for Hosting
    Rails Applications versus PHP Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
