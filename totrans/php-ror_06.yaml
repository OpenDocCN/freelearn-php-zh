- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Debugging Ruby
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby的调试
- en: Just like with any other significant programming language, Ruby has a number
    of tools to help us analyze, fix, and improve our code. According to a software
    architect I encountered many years ago, the disparity between a programmer who
    possesses debugging skills and one who lacks them equates to the distinction between
    a junior programmer and a senior programmer. By using the right tools to debug
    our code, we can both improve our code and improve our understanding of how the
    language is interpreted, which in the long run, is beneficial to our path as developers.
    Let’s take a look at the tools that come with Ruby out of the box, as well as
    the gems that the Ruby community has developed to debug our code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他重要的编程语言一样，Ruby有许多工具可以帮助我们分析、修复和改进我们的代码。根据多年前我遇到的一位软件架构师的说法，拥有调试技能的程序员与缺乏调试技能的程序员之间的差距，相当于初级程序员与高级程序员之间的区别。通过使用正确的工具来调试我们的代码，我们不仅可以改进我们的代码，还可以提高我们对语言如何被解释的理解，从长远来看，这对我们作为开发者的道路是有益的。让我们看看Ruby自带的一些工具，以及Ruby社区开发的用于调试代码的gem。
- en: 'With debugging in mind, in this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到调试，在本章中，我们将涵盖以下主题：
- en: Debugging functions in Ruby versus PHP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby与PHP中的调试函数
- en: Gems for debugging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试gem
- en: Understanding **Interactive Ruby** (IRB)’s usefulness
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解**交互式Ruby** (IRB)的有用性
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with this chapter, you will need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，你需要以下内容：
- en: Any IDE to view/edit code (e.g., Sublime Text, Visual Studio Code, Notepad++,
    Vim, Emacs, etc.)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何IDE来查看/编辑代码（例如，Sublime Text，Visual Studio Code，Notepad++，Vim，Emacs等）
- en: For macOS users, you will also need to have Xcode Command Line Tools installed
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于macOS用户，你还需要安装Xcode命令行工具
- en: Ruby version 2.6 or later installed and ready to use
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装并准备好使用的Ruby版本2.6或更高版本
- en: The code presented in this chapter is available at [https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的代码可在[https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/)找到。
- en: Debugging functions in Ruby versus PHP
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby与PHP中的调试函数
- en: 'So far, we’ve made scripts and code snippets making sure that our code works
    correctly every time. However, in the real world, we’ll come into contact with
    code that someone else has created and either wasn’t tested, or it wasn’t tested
    in a scenario that hadn’t come up until now. This happens more often than not,
    and we should be prepared to get our hands dirty to fix these types of issues.
    In PHP, we have a couple of functions that will help us debug in the simplest
    way. You are welcome to just read the following example and not follow along.
    For now, let’s take a look at PHP’s `var_dump()` function. We can open a command
    shell and create a file with the following content:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了确保代码每次都能正确运行的脚本和代码片段。然而，在现实世界中，我们会接触到别人编写的代码，这些代码可能没有经过测试，或者没有在之前未曾出现过的场景下进行过测试。这种情况很常见，我们应该准备好动手解决这些问题。在PHP中，我们有几个函数可以帮助我们以最简单的方式调试。你可以只阅读以下示例，不必跟着操作。现在，让我们看看PHP的`var_dump()`函数。我们可以打开命令行shell并创建一个包含以下内容的文件：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s say we ran the following PHP script on our shell:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在shell上运行了以下PHP脚本：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It should output something similar to this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 应该输出类似以下内容：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At first glance, we may or may not see the error within the code. If you saw
    the error at first glance, congratulations, you’re off to a good start. But for
    those who didn’t see the error at first glance, let’s use the `var_dump()` function.
    Let’s comment out the last line and add this to the ending line of our code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 初看时，我们可能看不到代码中的错误。如果你一眼就看到了错误，恭喜你，你有一个良好的开端。但对于那些一眼没看到错误的人来说，让我们使用`var_dump()`函数。让我们注释掉最后一行，并将其添加到代码的结尾行：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And let’s run this script again from our shell:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们再次从我们的shell中运行这个脚本：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This should output the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会输出以下内容：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In PHP, the `var_dump()` function is super useful as it outputs variables,
    its contents, and its content types. Notice that in this case, `var_dump($person)`
    is telling us that we have an array, and said array has two elements. These two
    elements in the array are strings. We also notice that the first associative element
    (`["firSt"]`) looks strange. It has a capital “S” in the middle. So, let’s make
    the correction and remove our debugging code. Our code should now look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，`var_dump()`函数非常有用，因为它输出变量、其内容及其内容类型。注意，在这种情况下，`var_dump($person)`告诉我们我们有一个数组，并且这个数组有两个元素。这两个元素都是字符串。我们还注意到数组中的第一个关联元素（`["firSt"]`）看起来很奇怪。它在中间有一个大写的“S”。所以，让我们进行更正并移除我们的调试代码。我们的代码现在应该看起来像这样：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We run it once more in our shell:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在shell上再次运行它：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It returns the following output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回以下输出：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'While this might not be the best debugging tool, it certainly is a very straightforward
    way to debug code in PHP. I personally am quite fond of this function as it was
    the very first function I used to debug in my life. Additionally, this is an oversimplified
    example, but in essence portrays real scenarios, especially when you debug during
    web development as sometimes you don’t know what is being sent to your script.
    If you are more interested in this function, you should take a look at the function’s
    documentation page: [https://www.php.net/manual/en/function.var-dump.php](https://www.php.net/manual/en/function.var-dump.php).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能不是最好的调试工具，但它确实是一种非常直接的方式来调试PHP中的代码。我个人非常喜欢这个函数，因为它是我用来调试人生中第一个函数。此外，这是一个过于简化的例子，但本质上描绘了真实场景，尤其是在进行网页开发调试时，有时你不知道什么被发送到你的脚本中。如果你对这个函数更感兴趣，你应该查看该函数的文档页面：[https://www.php.net/manual/en/function.var-dump.php](https://www.php.net/manual/en/function.var-dump.php)。
- en: You may also want to take a look at the `print_r()` and `var_export()` functions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想看看`print_r()`和`var_export()`函数。
- en: 'In Ruby, we don’t really have a `var_dump()` function, but instead, every object
    has a method already available called `inspect()`. The `inspect()` method converts
    the contents of an object to a string and returns it. Let’s redo the same example
    but in Ruby. Let’s create a file called `buggy_code.rb` and add the following
    code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby中，我们实际上没有`var_dump()`函数，而是每个对象都有一个名为`inspect()`的方法。`inspect()`方法将对象的内容转换为字符串并返回它。让我们用Ruby重做相同的例子。让我们创建一个名为`buggy_code.rb`的文件，并添加以下代码：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s say we were to run this script on our shell with the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将在shell上使用以下内容运行此脚本：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We would get the following output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We know ahead of time what the error is, but for educational purposes, let’s
    debug the `person` object by adding the following to our code so that it will
    now look like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们事先就知道错误是什么，但为了教育目的，让我们通过在我们的代码中添加以下内容来调试`person`对象，使其现在看起来像这样：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We run this script on the shell with the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下命令在shell上运行此脚本：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will return the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下结果：
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: While we could accomplish the same effect by just using `print()`, this is only
    true because we’re analyzing the contents of a hash in this example. If the previous
    example had a class object, the `print()` function would not show us all of the
    contents of an object. The `inspect()` method is more generic as it outputs the
    contents of any type of object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以通过仅使用`print()`函数来实现相同的效果，但这只适用于我们在这个例子中分析哈希的内容。如果前面的例子有一个类对象，`print()`函数将不会显示对象的所有内容。`inspect()`方法更通用，因为它输出任何类型对象的内容。
- en: 'Since we already know the fix, we can just go ahead and fix the example. Our
    code should now look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经知道解决方案，我们可以直接修复示例。我们的代码现在应该看起来像这样：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, we can run it again just to verify that our script runs correctly by
    running this on the shell:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以再次运行它，以验证我们的脚本是否正确运行，通过在shell上运行以下命令：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This would return the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下结果：
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And with this, we’ve learned a very PHP-esque way to debug scripts. Fortunately,
    we are not going further down this road. Instead, let’s take a look into other
    more Ruby-esque ways to debug.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经学习了一种非常PHP风格的调试脚本方法。幸运的是，我们不会继续这条路。相反，让我们看看其他更Ruby风格的调试方法。
- en: Gems for debugging
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试用的宝石
- en: 'As you probably guessed, the Ruby community came across the debugging problem
    just like any other programming community and thus has come up with libraries
    (or gems) to encapsulate different debug behaviors. We’ll talk specifically about
    three gems that make your debugging experience a whole different path than just
    dumping values in your code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，Ruby 社区遇到了调试问题，就像其他编程社区一样，因此想出了库（或gem）来封装不同的调试行为。我们将具体讨论三个gem，它们可以使你的调试体验与仅仅在代码中输出值完全不同：
- en: Debug
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Debug
- en: Pry
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pry
- en: Byebug
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Byebug
- en: All of these gems were designed for the same purpose, but each one has its own
    peculiarities and it will depend on your own preference which one you choose to
    use in your projects. Let’s start by looking at the first one.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些gem都是为了同一个目的而设计的，但每个gem都有自己的特性，你将根据自己的偏好选择在项目中使用哪一个。让我们先看看第一个。
- en: The debug gem
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: debug gem
- en: 'This gem comes as a replacement (and improvement) to the traditional `lib/debug.rb`
    standard library. While there are various ways to use this gem, let’s start by
    installing our gem and creating a simple debuggable example. First, we will have
    to do some setup. Let’s use a Gemfile, which we learned about in previous chapters.
    In an empty folder, create a file called `Gemfile` and add the following code
    to it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个gem作为传统`lib/debug.rb`标准库的替代品（和改进）。虽然有多种使用这个gem的方法，但让我们先安装我们的gem并创建一个简单的可调试示例。首先，我们必须做一些设置。让我们使用在前面章节中学到的Gemfile。在一个空文件夹中创建一个名为`Gemfile`的文件，并向其中添加以下代码：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we are going to install the gems listed in this file by running the following
    command within our shell:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过在shell中运行以下命令来安装此文件中列出的gem：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This should output something similar to this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出类似以下的内容：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And with this, we have installed the debug gem in our system. Now let’s test
    it out. To save time, you should download the example from the GitHub repo:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们在系统中安装了debug gem。现在让我们测试一下。为了节省时间，你应该从GitHub仓库下载示例：
- en: '[https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/blob/main/chapter06/debuggable_example.rb](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/blob/main/chapter06/debuggable_example.rb)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/blob/main/chapter06/debuggable_example.rb](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/blob/main/chapter06/debuggable_example.rb)'
- en: 'You can also type the whole code, though I wouldn’t recommend it as it contains
    a very long string:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以输入整个代码，尽管我不推荐这么做，因为它包含一个非常长的字符串：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code may seem a bit complicated at first, but for now, let’s focus
    on running it and the output, and we will explain the outcome of the script.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码一开始可能看起来有点复杂，但就目前而言，让我们专注于运行它和输出，我们将在后面解释脚本的输出结果。
- en: 'Let’s run our code from the shell with the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下命令从shell中运行我们的代码：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will output the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our code is basically ciphering a password with an algorithm called SHA2 and
    compares it to an already ciphered string with the same algorithm. We use the
    `digest` module, which we import at the beginning of the file, to cipher the password
    with `Digest::SHA2`. If the passwords match, we should get the message `Your password
    is CORRECT`. However, we can infer from the output that the passwords do not match.
    To debug, instead of printing values here and there with the `print()` function,
    let’s use the debug gem. Since we already installed the gem, we can just import
    said gem into our script. Let’s do that. Let’s add the `require` statement to
    our third line of code so that the first four lines of code now look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码基本上是用SHA2算法加密密码，并与使用相同算法加密的已加密字符串进行比较。我们使用`digest`模块，在文件开头导入，用`Digest::SHA2`加密密码。如果密码匹配，我们应该得到消息`您的密码是正确的`。然而，我们可以从输出中推断出密码不匹配。为了调试，而不是用`print()`函数在这里那里打印值，让我们使用调试gem。因为我们已经安装了gem，所以我们可以直接将这个gem导入到我们的脚本中。让我们这么做。让我们在第三行代码中添加`require`语句，这样前四行代码现在看起来是这样的：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that the gem has been imported, we can now create a breakpoint. A breakpoint
    is a line of code that is taken by a debugger program to pause the execution and
    let us analyze a program within that specific line of code. It’ll be more clear
    once we try it out. So, let’s add a breakpoint right after the hash value for
    `name` that has been set. Our code should now look like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在gem已经导入，我们可以创建一个断点了。断点是一行代码，调试程序会在这里暂停执行，让我们分析特定行内的程序。一旦我们尝试一下，就会更清楚。所以，让我们在为`name`设置的hash值之后添加一个断点。现在我们的代码应该看起来是这样的：
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let’s run our script just like any other script:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像其他脚本一样运行我们的脚本：
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'But you’ll notice something new. Our script will now result in a pause in the
    middle of the execution. Instead of outputting the text, our shell will now look
    like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但你会注意到一些新东西。我们的脚本现在会在执行过程中暂停。而不是输出文本，我们的shell现在看起来像这样：
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'I’ve truncated the ciphered value (`''32b3639…''`), but on your screen, it
    should show the full value. Notice how the execution has paused. What sorcery
    is this? Nothing other than the debug gem in action. And we can now even test
    things out. For example, let’s see what’s inside of the user hash. Within our
    debug shell, let’s type the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经截断了加密值（`'32b3639…'`），但在你的屏幕上，它应该显示完整的值。注意执行已经暂停。这是什么魔法？这不过是debug gem在起作用。现在我们甚至可以测试一些事情。例如，让我们看看用户哈希中有什么。在我们的调试shell中，让我们输入以下内容：
- en: '[PRE28]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Right after pressing *Enter*, the shell will return the value that has been
    assigned to `user`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在按下*Enter*后，shell将返回分配给`user`的值：
- en: '[PRE29]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Notice how our `user` variable has both `name` and `password` indexes. But
    what would happen if we tried to get the value of the `user_sha2_input` variable?
    Let’s do it. On the debug shell, type the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的`user`变量既有`name`也有`password`索引。但如果我们尝试获取`user_sha2_input`变量的值会发生什么？让我们试试。在调试shell中，输入以下内容：
- en: '[PRE30]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This returns an empty value:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个空值：
- en: '[PRE31]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is because the program has not yet reached the code where that variable
    is set. However, this special shell is already providing useful information by
    showing us all sorts of data related to the execution, such as what script we
    are running (`debuggable_example.rb`), and what line we are currently at (`=>
    9| binding.break`). We can also interact with this shell. Let’s type `next` and
    then press *Enter*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为程序还没有到达设置该变量的代码。然而，这个特殊的shell已经通过显示与执行相关的各种数据提供了有用的信息，例如我们正在运行的脚本（`debuggable_example.rb`）和当前所在的行（`=>
    9| binding.break`）。我们还可以与此shell交互。让我们输入`next`然后按*Enter*：
- en: '[PRE32]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will move forward in the breakpoint one line at a time. The shell will
    re-render again so that it now displays the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将逐行前进到断点。shell将再次渲染，因此现在显示以下内容：
- en: '[PRE33]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Notice that we moved from line 9 to line 10\. Let’s move one more line of code
    so that we allow the program to assign the password. This time we will use the
    shortcut for `next`, which is just the first letter, `n`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们已经从第9行移动到第10行。让我们再移动一行代码，以便允许程序分配密码。这次我们将使用`next`的快捷键，即第一个字母，`n`：
- en: '[PRE34]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As it renders yet again, we now see that our breakpoint has moved to the `if`
    statement:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当它再次渲染时，我们现在看到我们的断点已经移动到了`if`语句：
- en: '[PRE35]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we can view the contents of the password. Again, let’s type the `user_sha2_input`
    variable in this debugging shell:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以查看密码的内容。再次，在这个调试shell中，输入`user_sha2_input`变量：
- en: '[PRE36]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We confirm that the value is now there, as the output is now the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确认值现在已经在那里，因为输出现在是以下内容：
- en: '[PRE37]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is where our shell becomes extremely handy. We can test the `if` clause
    prior to executing it. Let’s copy the `if` clause, but without the `if` keyword,
    and paste it into the debug shell:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的shell变得极其方便的地方。我们可以在执行之前测试`if`子句。让我们复制`if`子句，但不包括`if`关键字，并将其粘贴到调试shell中：
- en: '[PRE38]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This returns what the `if` sentence is evaluating:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回`if`句子正在评估的内容：
- en: '[PRE39]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Apparently, someone changed the password to our script but made a mistake.
    You see, the problem with the SHA2 algorithm is that it’s not an encryption algorithm
    that you can encrypt and decrypt so that you can get the original value. SHA2
    is a hashing algorithm, which means that you are only able to cipher a value.
    If you need to use it for a password, then what you do is save this ciphered value
    and compare it to the user’s ciphered input. That way, not even the program has
    the original password, thus protecting the user’s password even from the program
    itself. In this case, we can quickly confirm that the passwords don’t match. Let’s
    debug this issue. Let’s compare ciphered values. First, let’s output the `user_sha2_input`
    value:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，有人更改了我们的脚本的密码，但犯了一个错误。你看，SHA2算法的问题在于它不是一个你可以加密和解密的加密算法，以便你可以得到原始值。SHA2是一个散列算法，这意味着你只能加密一个值。如果你需要用它作为密码，那么你所做的就是保存这个加密值，并将其与用户的加密输入进行比较。这样，甚至程序本身也无法获得原始密码，从而保护用户的密码免受程序本身的侵害。在这种情况下，我们可以快速确认密码不匹配。让我们调试这个问题。让我们比较加密值。首先，让我们输出`user_sha2_input`值：
- en: '[PRE40]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This returns the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回以下内容：
- en: '[PRE41]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And if we compare it to the `SECRET_SHA2_PASSWORD` value from our code, we
    see the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将它与我们的代码中的 `SECRET_SHA2_PASSWORD` 值进行比较，我们会看到以下内容：
- en: '[PRE42]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Seeing them close to each other, we can easily see just from the first four
    digits that they have different values. But before we fix our code, let’s finish
    our script’s execution with the `continue` debug command by typing it into the
    debug shell:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 看到它们靠近，我们可以很容易地只从前四个数字看出它们有不同的值。但在我们修复代码之前，让我们通过在 debug 控制台中输入 `continue` 调试命令来完成脚本执行：
- en: '[PRE43]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will continue our script’s execution until it either finds another breakpoint
    (of which there are no more in this case) or until it reaches the end of the program
    (as in this case). Additionally, it will output the same text as the first time
    we ran our script:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将继续执行我们的脚本，直到它找到另一个断点（在这种情况下没有更多断点）或者直到它到达程序的末尾（就像这个例子一样）。此外，它将输出与我们第一次运行脚本时相同的文本：
- en: '[PRE44]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now the shell is back to normal, we can get on to fixing the issue. Unfortunately,
    there is no way to get the original password (at least not until quantum computers
    are available to us). Fortunately, we already have the correct value from our
    previous debug session:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在shell恢复正常，我们可以开始修复问题。不幸的是，我们无法获取原始密码（至少在我们能够使用量子计算机之前是这样）。幸运的是，我们已经从之前的调试会话中获得了正确的值：
- en: '[PRE45]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can just copy this value into our `SECRET_SHA2_PASSWORD` variable and remove
    the breakpoint, so our code now looks like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个值直接复制到我们的 `SECRET_SHA2_PASSWORD` 变量中，并移除断点，因此我们的代码现在看起来像这样：
- en: '[PRE46]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let’s run it once more to confirm that the fix is correct by typing this in
    our shell:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行它，通过在 shell 中输入以下内容来确认修复是否正确：
- en: '[PRE47]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output should be the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是以下内容：
- en: '[PRE48]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With this, we have successfully debugged our script with the debug gem. As
    we previously saw, with the debug gem, we can run a script line by line, and add
    more than one break point, and that was just a simple example. I recommend you
    play around with this gem more and take a peek at other commands that the gem
    supports: [https://github.com/ruby/debug](https://github.com/ruby/debug).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经成功地使用 debug 钩子调试了我们的脚本。正如我们之前看到的，使用 debug 钩子，我们可以逐行运行脚本，并添加多个断点，这只是一个简单的例子。我建议你更多地尝试这个钩子，并查看它支持的其它命令：[https://github.com/ruby/debug](https://github.com/ruby/debug)。
- en: The pry gem
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pry 钩子
- en: 'The debug gem is only one of the options that we have available to debug our
    code nowadays. The second gem we are going to take a look at for debugging is
    the pry gem. As its name clearly suggests, pry is a a gem that spawns an interactive
    console that is able to observe deep within a Ruby program. From its GitHub page,
    we get that pry is an attempt to replace the classic **Interactive Ruby** (or
    **IRB**). Though it has its similarities with the debug gem, it does have its
    own approach to the debug paradigm. Let’s take it out for a test drive so you
    can see what I’m talking about. We’ll start by simply installing the gem by running
    the following command on our command shell:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: debug 钩子是我们现在可用的用于调试代码的选项之一。我们将要查看的第二个用于调试的钩子是 pry 钩子。正如其名称明显暗示的那样，pry 是一个能够深入观察
    Ruby 程序的交互式控制台钩子。从其 GitHub 页面，我们了解到 pry 是尝试替代经典的 **交互式 Ruby**（或 **IRB**）。尽管它与
    debug 钩子有相似之处，但它对调试范式的处理有自己的方法。让我们试驾一下，以便你能看到我在说什么。我们将从简单地通过在命令行中运行以下命令来安装钩子开始：
- en: '[PRE49]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We should see the following output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到以下输出：
- en: '[PRE50]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now you can either download the example from [https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/blob/main/chapter06/pryable_example.rb](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/blob/main/chapter06/pryable_example.rb)
    or simply type the code. The file we either download or create should be named
    `pryable_example.rb` and it looks like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以从 [https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/blob/main/chapter06/pryable_example.rb](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/blob/main/chapter06/pryable_example.rb)
    下载示例，或者简单地输入代码。我们下载或创建的文件应该命名为 `pryable_example.rb`，它看起来像这样：
- en: '[PRE51]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now let’s execute the script we just created from the shell:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从 shell 中执行我们刚刚创建的脚本：
- en: '[PRE52]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'It should output just a name:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该只输出一个名字：
- en: '[PRE53]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Of course, we made a typo on purpose (failing to include a space between the
    name and last name), but now let’s see the pry magic. Let’s import `pry` and add
    a breakpoint. Our code should now look like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们故意犯了一个拼写错误（在名字和姓氏之间没有包括空格），但现在让我们看看 pry 的魔法。让我们导入 `pry` 并添加一个断点。我们的代码现在应该看起来像这样：
- en: '[PRE54]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let’s run our script again:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行我们的脚本：
- en: '[PRE55]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'And, just like the debug gem, we will also enter an interactive shell:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就像debug gem一样，我们也将进入一个交互式shell：
- en: '[PRE56]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'What we must consider here is that the commands are going to be different.
    We will start with a simple command within this shell. Let’s type `ls` (that’s
    a lowercase L and a lowercase S), just like the Linux command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须考虑的是，命令将会不同。我们将在这个shell中开始一个简单的命令。让我们输入`ls`（这是一个小写的L和一个小写的S），就像Linux命令一样：
- en: '[PRE57]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The prompt will return something like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 提示符将返回类似以下内容：
- en: '[PRE58]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Pry lists the content (in memory) from our program, and pry lists it as if
    it were a filesystem. If we wanted to “pry” into the `person` object, we could
    navigate as if it were a folder. Let’s do that with the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Pry列出我们程序（在内存中）的内容，并且pry将其列出，就像它是一个文件系统。如果我们想“pry”到`person`对象中，我们可以像导航文件夹一样导航。让我们用以下命令来做这件事：
- en: '[PRE59]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And right after that, let’s do an `ls` again:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，紧接着，我们再次执行`ls`命令：
- en: '[PRE60]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now the prompt will show the contents of `person`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在提示符将显示`person`的内容：
- en: '[PRE61]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Depending on the version of Ruby that you may have installed, you may see the
    previous prompt or a similar one with slight variations, but one way or another
    they will all show the contents of the `person` object. If we closely take a look,
    we see the `first_name`, `last_name`, and `full_name` methods in addition to the
    `@first_name` and `@last_name` variables. That is one of the advantages of `pry`
    as it allows us to dig deep into an object. Another useful thing we can do is
    fix and reload our code, which simply means that we can change part of the code
    and then reload it into memory without having to stop the current execution. If
    we go to our source code, and we fix line seven by adding a space between `first_name`
    and `last_name`, our code should now look like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你可能安装的Ruby版本，你可能会看到之前的提示或略有不同的类似提示，但无论如何，它们都会显示`person`对象的全部内容。如果我们仔细观察，我们会看到`first_name`、`last_name`和`full_name`方法，以及`@first_name`和`@last_name`变量。这就是`pry`的一个优点，因为它允许我们深入挖掘对象。我们还可以做的另一件有用的事情是修复并重新加载我们的代码，这意味着我们可以更改代码的一部分，然后将其重新加载到内存中，而无需停止当前执行。如果我们回到我们的源代码，并在第七行中在`first_name`和`last_name`之间添加一个空格，我们的代码现在应该看起来像这样：
- en: '[PRE62]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Lastly, while still in our interactive shell, we run this command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们交互式shell中，我们运行以下命令：
- en: '[PRE63]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This should make the prompt show us where our breakpoint is again:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该使提示符再次显示我们的断点位置：
- en: '[PRE64]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now let’s get the full name again by typing the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次通过输入以下内容来获取全名：
- en: '[PRE65]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We then see the fixed full name in the output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后在输出中看到修正后的完整名称：
- en: '[PRE66]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We can now exit the debug shell with pry’s exit alias (`!!!`):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用pry的退出别名（`!!!`）退出调试shell：
- en: '[PRE67]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This exits the debug shell. So, as you can see, we have a lot of advantages,
    such as the level of depth of our view of the object. However, we do have a major
    downside. With pry, we can only see the contents of that specific moment of execution.
    We cannot move to another line of code as with debug. What we can do is add multiple
    breakpoints as pry allows it. Either way, don’t let that downside deter you from
    trying it out.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将退出调试shell。所以，正如你所看到的，我们有很多优点，比如我们观察对象深度的水平。然而，我们确实有一个主要的缺点。在使用pry时，我们只能看到特定执行时刻的内容。我们不能像使用debug那样移动到另一行代码。我们可以做的是添加多个断点，因为pry允许这样做。无论如何，不要让这个缺点阻止你尝试它。
- en: The byebug gem
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The byebug gem
- en: And yet another tool that is available for us is the byebug gem. Byebug is another
    debugger that does not depend on internal core sources. It works in a similar
    manner to the two options that we’ve previously reviewed. Additionally, the gem
    has support for popular IDEs such as Sublime, Atom, and VS Code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个对我们可用的工具是byebug gem。Byebug是另一个不依赖于内部核心资源的调试器。它的工作方式与我们之前审查的两个选项类似。此外，这个gem支持流行的IDE，如Sublime、Atom和VS
    Code。
- en: 'Let’s take a quick dive into this tool. We are going to install the byebug
    gem. On a shell, type the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解一下这个工具。我们将安装byebug gem。在shell中输入以下命令：
- en: '[PRE68]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We should see the following output on our shell:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在shell上看到以下输出：
- en: '[PRE69]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now that the gem is available, let’s create a file called `byeable_example.rb`
    with the following content:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 既然这个gem已经可用，让我们创建一个名为`byeable_example.rb`的文件，并包含以下内容：
- en: '[PRE70]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let’s first run our program without any breakpoints. In our shell, let’s type
    this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先在没有断点的情况下运行我们的程序。在我们的shell中，让我们输入以下内容：
- en: '[PRE71]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The output will be the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将会是以下内容：
- en: '[PRE72]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Our program is showing the same message for every number, which is not what
    is intended. Since our gem is already installed and loaded, we only need to add
    a breakpoint. And we do that by adding the `byebug` text. Let’s add that to our
    code right before the output variable is printed. Our code should now look like
    this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目为每个数字显示相同的消息，这并不是我们预期的。由于我们的gem已经安装并加载，我们只需要添加一个断点。我们通过添加`byebug`文本来实现这一点。让我们在我们的代码中输出变量之前添加这一行。我们的代码现在应该看起来像这样：
- en: '[PRE73]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'And again, let’s run our script in the shell:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们在shell中运行我们的脚本：
- en: '[PRE74]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'As with the other debuggers, we see our shell change into an interactive debugging
    shell:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他调试器一样，我们看到我们的shell变成了一个交互式调试shell：
- en: '[PRE75]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'From this shell, we can write commands and see the contents of variables, just
    like we did with debugger and pry. We see the file and the breakpoint that we
    defined on line 7\. At this point, we have access to the `index` variable. Let’s
    type this into the byebug shell:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个shell中，我们可以编写命令并查看变量的内容，就像我们使用debugger和pry时做的那样。我们看到文件和我们在第7行定义的断点。在这个时候，我们可以访问`index`变量。让我们在byebug
    shell中输入以下内容：
- en: '[PRE76]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We immediately see the value of this variable:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即看到这个变量的值：
- en: '[PRE77]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As we are inside an `each` loop, the value for the `index` variable has been
    populated by the first value from the array (`[1,5,7,9]`), which in this case
    is `1`. We can also view what’s inside the `not_label` variable. Let’s type it
    on the byebug shell:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处于`each`循环中，`index`变量的值已经被数组（`[1,5,7,9]`）的第一个值填充，在这个例子中是`1`。我们也可以查看`not_label`变量内部的内容。让我们在byebug
    shell中输入它：
- en: '[PRE78]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now we see the contents of said variable:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们看到该变量的内容：
- en: '[PRE79]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This is because the `not_label` variable is taking the `index` value and instead
    of comparing it to 6, we are just passing it to the ternary operator (the `?`
    symbol), ergo the `not_label` variable will always have the text `"NOT"` as its
    value. We can verify this by typing the keyword `continue`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`not_label`变量正在获取`index`值，而不是将其与6进行比较，我们只是将其传递给三元运算符（`?`符号），因此`not_label`变量将始终具有文本`"NOT"`作为其值。我们可以通过输入关键字`continue`来验证这一点：
- en: '[PRE80]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `continue` command will carry on the execution of the program until it
    finds another breakpoint. As we are inside a loop, we will move on to the next
    element in the array, until we reach the breakpoint again. Let’s see what’s inside
    the index value again in the shell:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`命令将继续执行程序，直到找到另一个断点。由于我们处于循环中，我们将移动到数组的下一个元素，直到再次达到断点。让我们再次在shell中查看`index`值：'
- en: '[PRE81]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This will output the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE82]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'That confirms that we’ve moved to the next element in the array. Let’s see
    what’s inside of the `not_label` variable again:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这确认我们已经移动到数组的下一个元素。让我们再次查看`not_label`变量内部的内容：
- en: '[PRE83]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We should see the same value:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到相同的值：
- en: '[PRE84]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This will happen with every value assigned to the `index` variable. So let’s
    exit by typing the `exit` command on the byebug shell:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发生在分配给`index`变量的每个值上。所以，让我们通过在byebug shell中输入`exit`命令来退出：
- en: '[PRE85]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Our shell should go back to normal. Now let’s fix our code by adding a comparison
    inside our `not_label` variable and removing our breakpoint. Our code should look
    like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的shell应该恢复正常。现在让我们通过在`not_label`变量内添加比较并移除我们的断点来修复我们的代码。我们的代码现在应该看起来像这样：
- en: '[PRE86]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now let’s do a final run of our script:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行我们的脚本的最终版本：
- en: '[PRE87]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This should correctly output the text messages:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该正确输出文本消息：
- en: '[PRE88]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Congrats! Our code has been debugged and fixed. Again, this is a vastly simplified
    example, but I hope you get the idea of how useful byebug is. Byebug has additional
    commands, configuration options, and even a historical log of our commands. Please
    take a look at byebug’s GitHub page for more information: [https://github.com/deivid-rodriguez/byebug](https://github.com/deivid-rodriguez/byebug).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们的代码已经被调试并修复。再次强调，这是一个大大简化的例子，但我希望你能理解byebug有多有用。byebug有额外的命令、配置选项，甚至还有我们命令的历史记录。请查看byebug的GitHub页面以获取更多信息：[https://github.com/deivid-rodriguez/byebug](https://github.com/deivid-rodriguez/byebug)。
- en: As you probably noticed, all of these gems work in a very similar manner. As
    we’ll see in the next section, this is because they are all built based on IRB.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能注意到的，所有这些gem都以非常相似的方式工作。正如我们将在下一节中看到的，这是因为它们都是基于IRB构建的。
- en: Understanding IRB’s usefulness
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解IRB的有用性
- en: In [*Chapter 3*](B19230_03.xhtml#_idTextAnchor037), we briefly saw the **IRB**
    shell, and I hope you noticed some of the similarities between IRB and our debugging
    tools. Basically, what these gems do is enhance IRB so that we can view variables
    in memory, move around execution points, and work in a “frozen” state of our program.
    At the end of the day, you will be able to choose which one of these tools is
    more convenient for your everyday use. I could steer you toward one, or you could
    simply use the built-in IRB. One technique I saw a fellow developer use was that
    he wrote most of his code in IRB, and once the code ran without problems, he would
    just copy the code from IRB into an IDE to save his work. This saved him a lot
    of time that he would have otherwise used on testing. Another coworker used a
    very popular IDE called RubyMine. This tool allows us to add breaking points at
    the touch of a button (among many other features). Additionally, one downside
    of using debuggers is that you add debug code when setting up breakpoints. This
    could potentially break your code if you forget to remove the breakpoints when
    you commit your code into your code base. RubyMine removes that risk as breakpoints
    are not added to your code but rather managed by the IDE.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第三章*](B19230_03.xhtml#_idTextAnchor037)中，我们简要地看到了**IRB** shell，我希望你注意到了IRB和我们的调试工具之间的一些相似之处。基本上，这些gem的作用是增强IRB，使我们能够查看内存中的变量，移动执行点，并在程序的“冻结”状态下工作。最终，你将能够选择这些工具中哪一个更适合你的日常使用。我可以引导你选择一个，或者你也可以简单地使用内置的IRB。我看到一位开发者使用的一个技巧是，他在IRB中编写了大部分代码，一旦代码运行无误，他就会将代码从IRB复制到IDE中保存工作。这节省了他很多本可以用于测试的时间。另一位同事使用了一个非常流行的IDE，叫做RubyMine。这个工具允许我们通过点击按钮添加断点（以及其他许多功能）。此外，使用调试器的缺点之一是在设置断点时添加调试代码。如果你忘记在将代码提交到代码库时移除断点，这可能会破坏你的代码。RubyMine消除了这种风险，因为断点不是添加到你的代码中，而是由IDE管理的。
- en: 'Nowadays, most IDEs have integrated some sort of debugger mechanism for your
    convenience. As that might be outside of the scope of this book, you might want
    to check those IDEs and their own implementation of debugging on your own:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数IDE都集成了某种调试机制，以便于你的使用。由于这可能超出了本书的范围，你可能需要自己检查这些IDE及其对调试的实现：
- en: '[https://www.sublimetext.com/](https://www.sublimetext.com/)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Sublime Text官网](https://www.sublimetext.com/)'
- en: '[https://code.visualstudio.com/](https://code.visualstudio.com/)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Visual Studio Code官网](https://code.visualstudio.com/)'
- en: '[https://www.jetbrains.com/ruby/](https://www.jetbrains.com/ruby/)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JetBrains Ruby官网](https://www.jetbrains.com/ruby/)'
- en: Whatever path you take is entirely up to you. I just wanted to give you an understanding
    of what IRB is, and how powerful it can be in Ruby development.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪条道路，完全取决于你自己。我只是想让你了解IRB是什么，以及它在Ruby开发中可以有多么强大。
- en: 'PHP programmers who come from a Laravel background will be familiar with the
    tinker tool, which is basically an interactive shell for PHP with Laravel components
    loaded. I must admit that tinker ([https://github.com/laravel/tinker](https://github.com/laravel/tinker))
    looks a lot like a tool that Ruby on Rails has: the Rails console. The Rails console
    is basically IRB with Ruby on Rails components loaded for ease of use. But let’s
    not get ahead of ourselves. We first must learn about Ruby on Rails.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Laravel背景的PHP程序员会对tinker工具很熟悉，这个工具基本上是一个加载了Laravel组件的PHP交互式shell。我必须承认，tinker（[https://github.com/laravel/tinker](https://github.com/laravel/tinker)）看起来很像Ruby
    on Rails的一个工具：Rails控制台。Rails控制台基本上是加载了Ruby on Rails组件的IRB，以便于使用。但让我们不要跑题。我们首先必须了解Ruby
    on Rails。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the different functions we can use to debug
    in PHP and the equivalent in Ruby, and how to debug our code by using three different
    tools that are easily configured and installed. While not wanting to impose my
    debugging gem of choice, I will say that for several years I used pry, until byebug
    came along. I suggest you not only try byebug but also be on the lookout for new
    debugging gems. We also learned how to add breakpoints to our debug code and how
    useful and powerful these breakpoints can be during development. Lastly, we learned
    that all of these gems are basically enhanced IRBs, so we can easily use any of
    them as they all behave in a very similar fashion.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了在PHP中可以使用的不同调试功能及其在Ruby中的等效功能，以及如何通过使用三种易于配置和安装的工具来调试我们的代码。虽然我不想强推我偏爱的调试宝石，但我可以说，在byebug出现之前，我使用了几年pry。我建议你不仅尝试byebug，还要留意新的调试宝石。我们还学习了如何将断点添加到我们的调试代码中，以及这些断点在开发过程中的有用性和强大功能。最后，我们了解到所有这些宝石基本上都是增强版的IRB，因此我们可以轻松地使用它们，因为它们的行为非常相似。
- en: Having seen all this, we are now ready to board the Ruby on Rails wagon.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到所有这些之后，我们现在已经准备好登上Ruby on Rails的列车。
- en: Part 2:Ruby and the Web
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：Ruby与Web
- en: In this part, you will get an introduction to how Ruby is used in web development
    through the most popular Ruby framework, Ruby on Rails. In addition to this, you
    will learn the basics of database handling and views, and finally, get an overview
    of the differences in hosting for Ruby on Rails applications in comparison to
    PHP applications.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，你将通过最流行的Ruby框架Ruby on Rails了解Ruby在Web开发中的应用。除此之外，你还将学习数据库处理和视图的基础知识，最后，将概述Ruby
    on Rails应用程序与PHP应用程序在托管方面的差异。
- en: 'This part has the following chapters:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 7*](B19230_07.xhtml#_idTextAnchor103), *Understanding Convention
    over Configuration*'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19230_07.xhtml#_idTextAnchor103), *理解约定优于配置*'
- en: '[*Chapter 8*](B19230_08.xhtml#_idTextAnchor114), *Models, DBs, and Active Record*'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19230_08.xhtml#_idTextAnchor114), *模型、数据库和活动记录*'
- en: '[*Chapter 9*](B19230_09.xhtml#_idTextAnchor127), *Bringing It All Together*'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19230_09.xhtml#_idTextAnchor127), *整合一切*'
- en: '[*Chapter 10*](B19230_10.xhtml#_idTextAnchor140), *Considerations for Hosting
    Rails Applications versus PHP Applications*'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19230_10.xhtml#_idTextAnchor140), *托管Rails应用程序与PHP应用程序的考虑因素*'
