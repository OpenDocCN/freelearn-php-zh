- en: Chapter 2. Tooling up for Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to have an overview of Yii 2, what has changed
    since the last version, with which you might have become comfortable its new directory
    structure and organization, as well as its new features and niceties.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot introduce Yii 2 without looking at **Composer**, a new way to organize
    and extend your projects in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have had a look at all the basic tools we''re going to use, let''s
    review our plan and consider what we will be working on in the rest of this book:
    user authentication REST interface and user login from a modal window.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to start working on our features, we need to step aside and review
    our plan from a project management and quality assurance point of view, that is,
    introduce the master test plan. In other words, we need to consider what we are
    going to test and how much before undertaking the actual implementation work.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be working through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and installing Yii 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding your way around Yii 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining our working strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing testing for our purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading and installing Yii 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've worked with Yii in the past, be prepared. The new version of Yii 2
    can be considered as a brand new framework, modern and robust.
  prefs: []
  type: TYPE_NORMAL
- en: Yii 2 takes a long-awaited step forward in the right direction. It is the result
    of several years of work, done collaboratively on the Internet, mostly on GitHub
    ([https://github.com/yiisoft/yii2](https://github.com/yiisoft/yii2)), by developers
    from different parts of the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a user of Yii, you can collaborate too, by simply filing bug reports, feature
    requests at [https://github.com/yiisoft/yii2/issues](https://github.com/yiisoft/yii2/issues),
    polishing off the documentation and translations, and creating new extensions
    and features for review and inclusion on the project. There are also many other
    non-officially supported subprojects that can benefit from your support: some
    already there for you to use, and some that you may have written yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: Environment and workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a developer, you will have your own environment with which you need to feel
    confident enough, and which can actually help you writing the code without many
    worries. If you do feel that there's a gap between writing the code and seeing
    the actual result, then there's something you need to fix.
  prefs: []
  type: TYPE_NORMAL
- en: It's quite important for the purpose of this book to outline my optimal environment
    that I will use throughout the upcoming chapters and code samples that you will
    find.
  prefs: []
  type: TYPE_NORMAL
- en: I will, of course, note when the environment might make a difference, but be
    wary that, if your environment is different, you may need to check the developer's
    documentation or reach out to anyone who might know the answer, in case something
    is not working.
  prefs: []
  type: TYPE_NORMAL
- en: 'My personal development environment is composed of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A robust **Integrated Development Environment** (**IDE**), such as IntelliJ
    PHPStorm, rather than a simple code editor (for example, VIM): You get some additional
    benefits from it, for example, an integrated debugger, a syntax checker, a code
    hinting system, and so forth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A modern version control system (for example, GIT): Commit always and often.
    It''s the only way for you to understand the history and control the changes in
    your project in a sensible way. Head over to [http://git-scm.com/doc](http://git-scm.com/doc)
    if you need more information and learn by visually experimenting with it at [http://pcottle.github.io/learnGitBranching/](http://pcottle.github.io/learnGitBranching/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux Apache MariaDB PHP** (**LAMP**) box packaged as a virtual machine:
    I''ve passed through the stage of having my own machine acting as my LAMP box,
    but this has proved to be too unreliable for many reasons. Mostly because after
    a while, you will end up confusing experimental plugins and tools that are not
    meant to be used on certain projects, potentially messing up your work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A development or testing environment is usually quite simple to set up as it
    won't require an extensive configuration, as it would do in a critical or production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the reasons in favor of having such an environment setup, in particular
    with reference to the LAMP box, is the ability to configure it as you wish based
    on the project you''re working on, and in particular being able to replicate the
    live/production environment as close as possible. This has a clear advantage when
    it comes to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Working within a team with more than one developer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replicating bugs occurring on any environment (for example, test, stage, or
    live)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vagrant is probably the tool you're looking for if you want to start easy (see
    [http://www.vagrantup.com/](http://www.vagrantup.com/)), and if it convinces you,
    it might be worth giving the book, *Creating Development Environments with Vagrant*,
    *Michael Peacock*, *Packt Publishing*, a shot ([http://www.packtpub.com/creating-development-environments-with-vagrant/book](http://www.packtpub.com/creating-development-environments-with-vagrant/book)).
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP does not need major adjustments, and I believe a default PHP installation
    will suffice to get you started as this is the only constraint for running Yii
    2\. Be sure to have a version equal to or above 5.4, and have a CLI PHP available
    on the command line, by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output is from a Vagrant machine running Ubuntu 12.04 with PHP
    5.5 installed.
  prefs: []
  type: TYPE_NORMAL
- en: The dollar sign (`$`) means the command can be run by a user and you won't need
    administrative permissions to run it.
  prefs: []
  type: TYPE_NORMAL
- en: If you get a `command not found` error, be sure to refer to your distribution/OS
    vendor for support on how to install it. Most of the distributions provide it
    by default, while others require additional configuration parameters or packages.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Composer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you might well know, Yii 1 was (initially) shipped as a standalone library
    that needed installation on the target environment, and from there you could use
    its CLI interface to create your web app. After that, the library would be sitting
    somewhere in your filesystem to be directly called by the web app upon loading
    it.
  prefs: []
  type: TYPE_NORMAL
- en: When Yii started, this was common practice; there wasn't a way to keep the code
    self-contained and you could easily get into several problems whenever you needed
    to ship the code to shared hosting environments (I'm looking at you Plesk/OpenBaseDir
    restriction).
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, system-wide packages and dependencies were often restricting the developers
    to embrace new features and work around existing bugs, without even counting that
    these were (too) often overlooked. If you've been working on the web with PHP
    for quite a while, I'm pretty sure you've experienced the sense of lagging behind
    other big frameworks on the development scene (and not just in PHP-land).
  prefs: []
  type: TYPE_NORMAL
- en: Composer ([http://getcomposer.org](http://getcomposer.org)) solves the problem
    under many aspects, and thanks to the efforts of Nils Adermann, Jordi Boggiano,
    and many community contributions, it was first released in 2012.
  prefs: []
  type: TYPE_NORMAL
- en: Composer takes inspiration from Node.js' **npm** and Ruby's **bundler**. It
    provides a way to define and install dependencies (that is, libraries), and install
    web applications that are available from Packagist ([https://packagist.org/](https://packagist.org/))
    on a per-project basis.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by following the installation guide proposed on the Composer website
    ([https://getcomposer.org/doc/00-intro.md#installation-nix](https://getcomposer.org/doc/00-intro.md#installation-nix)).
    Consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command we are using `curl` to download the installer and `php`
    to parse it and output an executable PHP file called `composer.phar`. Be mindful
    that the installation under a different OS (in case you don't have a Linux box
    to play with) varies, for example, under OS X, Composer is part of the `homebrew-php`
    project at [https://github.com/Homebrew/homebrew-php](https://github.com/Homebrew/homebrew-php).
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you can simply call Composer directly using a relative or absolute
    path, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Or move it into a more appropriate position for easier invocation, as you will
    see next.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can run sudo or log in as root, move it into a system wide `bin` folder,
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If the preceding option does not apply, you can install it in user-space, for
    example, `~/bin/`, and then add the path to your `PATH` environment variable,
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The last command is adding the path to your terminal environment, so it can
    be invoked from anywhere you are in the filesystem. This specific command would
    need to be issued every time you open a terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, you can add it permanently, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By adding the `export` statement to your `.bashrc` (`>> ~/.bashrc` appends the
    output of `echo` to the end of the `.bashrc` file), you are simply making the
    directory searchable automatically every time you log in, given you are using
    BASH as shell interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re unsure which shell you''re on, you can check using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, while this will work on most shells and it''s quite easy to remember,
    it won''t work if your shell is CSH, in which case, use the more complex but also
    more portable `ps` invocation, as shown in the following: command'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have installed Composer, you can simply invoke it using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The composer.json and composer.lock files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Composer works by reading the `composer.json` file found in the root of your
    project, which will contain all the requirements and dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet is quite clear: it''s defining a dependency of our project
    on Twig ([http://twig.sensiolabs.org/](http://twig.sensiolabs.org/)). This is
    a template engine with a clear and compact syntax. It''s also defining a specific
    dependency on any version of Twig starting with 1.16.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modifying the `composer.json` file by hand can be prone to human errors, and
    sometimes it might be necessary, as we will see later on, to add the packages
    to your `require` or `require-dev` section via the command line using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This way the `composer.json` file will be automatically created if it does
    not already exist, and the package with its dependencies will be installed for
    you. Alternatively, if you''ve created the file yourself or if you''ve received
    the file as part of a project, you can invoke the `install` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The normal behavior of the preceding command is to fetch the required packages
    as archives (called dist in composer jargon) for stable sources, or via repository
    if either the dist is not available or if the package is in some stage that is
    not stable (for example, beta or dev).
  prefs: []
  type: TYPE_NORMAL
- en: You can change this behavior by using the `--prefer-dist` option to force searching
    for the dist even for development packages, or `--prefer-source` to force the
    checkout from repository rather than dist for stable packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will see by listing the content of the directory, Composer will install
    all libraries into your project folder under the `/vendor` directory and create
    a `composer.lock` file in the root folder that will hold a snapshot of the current
    state of the installation, locking the installed libraries to the specific version
    defined in the lock file, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When sharing your code, you need to commit the `composer.lock` file, so everyone
    in your team and any other environment you will deploy to will run exactly the
    same version of the dependencies you have, mitigating the risk of bugs affecting
    only some environments. Composer will look for the lock file first before deciding
    to use the JSON file to download a more up-to-date version based on the definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, it is not recommended to commit the `/vendor` directory
    to your VCS as it can cause several problems, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Difficulty in handling revisions and updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased size of the repository without any benefit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Git, it could cause problems if you're adding packages checked out via Git,
    as it will show them as submodules, while they're not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This heavily depends on your deployment policy, but, in general, it will be
    better to have your environments and team mates run the `composer install` command
    on their own.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ever need to update the dependencies, you can simply issue the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Or to update a specific package, the command will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `[...]` means you can add as many packages to be updated with a single command.
  prefs: []
  type: TYPE_NORMAL
- en: Packages and Packagist
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By creating the `composer.json` file, you are also defining your project as
    a package. This is a package that depends on other packages. The only difference
    is that your project is without a name, yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Composer can help you here in defining your project/package in a more consistent
    and clear way. Consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start by asking you for some basic information regarding your project,
    including the requirements that you want for your project, and then create (or
    overwrite) the `composer.json` file, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Among these, the one worth noticing is the `Minimum Stability` option: it provides
    a way to control the stability of the packages. By omitting it, it defaults to
    stable. This option combined with `"prefer-stable": true` (or `false` if you want
    to have the dev versions of your dependencies) will give you enough power to decide
    the policy of stability of the dependencies where this is not explicitly defined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will then move into setting the dependencies interactively, as shown in
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The search can be anything, and it works the same way as you would by searching
    on the website ([https://packagist.org](https://packagist.org)). If you want to
    have a more clear idea of what you''re going to install, you probably want to
    have a look at the website: you need to be aware of the dependencies and browse
    the code to check it does what it says on the tin.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing how to use the version constraints can be quite important in any project
    with just a few dependencies. According to [https://getcomposer.org/doc/01-basic-usage.md#package-versions](https://getcomposer.org/doc/01-basic-usage.md#package-versions),
    the following are the possible keywords you need to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exact version**: For example, `1.0.23`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Range**: For example, `>=1.2` or `>=1.0,<2.0` or use the pipe as a logical
    OR as `>=1.0,<2.0 | >=3.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wildcard**: For example, `1.2.*`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tilde operator**: Here, `~1.2` is the same as `>=1.2,<2.0`; `~1.2.3` is the
    same as `>=1.2.3,<1.3` (semantically: `[[[[...]c.]b.]a.]x`, where `x` is the only
    variable)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composer provides further granularity when selecting specific packages, specifically
    you can filter by stability by adding `@dev` (or `alpha`, `beta`, `RC` or `stable`).
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you are forced to use an unstable version, either because of the
    lack of a stable version or because the stable version ships with a bug that has
    been fixed in the master (dev)!
  prefs: []
  type: TYPE_NORMAL
- en: 'Together with `require`, which defines the list of fundamental packages that
    are a direct dependency, `require-dev` defines instead the secondary packages
    used for development, such as libraries for running tests, performing debugging,
    and so on. However, these are not fundamental for the application to work, as
    shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also skip adding packages for `require`, and then add them later using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: While for `require-dev`, at least with the version I've got installed at the
    time of writing this book, you need to add them manually as seen at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point of the process, you''ll be able to review the JSON that will
    be written before confirming it, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once you've got your `composer.json` file created, you can edit it and tweak
    it to your liking. There are many other options that can be specified. Refer to
    [https://getcomposer.org/doc/04-schema.md](https://getcomposer.org/doc/04-schema.md).
  prefs: []
  type: TYPE_NORMAL
- en: By compiling your `composer.json` file, you are actually creating a package
    yourself that could be shared on Packagist with other developers.
  prefs: []
  type: TYPE_NORMAL
- en: The process itself is not particularly difficult, as you just need to add a
    few additional options, as defined in the JSON schema documentation ([https://getcomposer.org/doc/04-schema.md#the-composer-json-schema](https://getcomposer.org/doc/04-schema.md#the-composer-json-schema)),
    and publish your code using a Git, subversion or mercurial repository. You can
    also decide to publish just a dist package. Refer to the documentation at [https://getcomposer.org/doc/](https://getcomposer.org/doc/)
    for more information if you want to take a step in this direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve created your `composer.json` file, you can start installing all
    the dependencies as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Composer lets you decide how to fetch all the requirements and, in this particular
    case, we gave preference to dist files when available. The result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Creating your first web app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you should have gained enough confidence with Composer to be
    able to undertake the next step. But before doing this, forget what you've learned!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a `composer.json` file and requiring a bunch of packages can be done
    by anyone. With Composer, you can create a project from a given package. This
    means that the package will be extracted into a specified directory (not `/vendor`
    anymore). This new project will have all its dependencies checked out and saved
    within its scope, that is, within its own directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for the command we''re going to use to install Yii 2 and start working
    with it is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, `vendor/project` is the Packagist name of the project, in our case, the
    name will be `yiisoft/yii2-app-basic,` as we will see later, and `target-directory`
    is where you want to install it. This command won't create a `composer.json` file,
    so you can run it from anywhere in your environment, just be sure to specify the
    correct target path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yii 2 developers have shared two packages that contain an initial application
    you can start working with: a *basic* and an *advanced* one.'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the two is the type of dependencies and what's already
    been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both projects come with a `README.md` file in Markdown format, which you can
    read to understand the details. To keep it short:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic**: As the name says, it''s a basic implementation, very close to what
    you would get by installing Yii 1, ready to be used with a default Apache or Nginx
    installation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced**: This is a very basic configuration if you need to build a multitiered
    application. The one you will get with the advanced app consists of a frontend,
    a backend, and a console application, all as separate Yii applications with some
    common components. It would require a specific initialization, so refer to the
    `README.md` file for details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The advanced application features an additional script called `init,` which
    wraps Composer and enables or disables the installation of `require-dist`.
  prefs: []
  type: TYPE_NORMAL
- en: For a more detailed guide, check out the documentation at [http://www.yiiframework.com/doc-2.0/guide-tutorial-advanced-app.html](http://www.yiiframework.com/doc-2.0/guide-tutorial-advanced-app.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We are now installing into `/basic` the `yiisoft/yii2-app-basic` package. There
    are other ways to get you started, but this is definitely the most clean way I
    can think of, as you won't be tied to a repository nor anything else.
  prefs: []
  type: TYPE_NORMAL
- en: There is no interaction required after this command, as it would carry on installing
    the required packages including `require-dev`.
  prefs: []
  type: TYPE_NORMAL
- en: It might be that at this point, Composer will fail in installing some dependencies,
    or you can fall in some runtime errors later on, so it's probably better if you
    check your requirements are met by opening the requirement script in your browser,
    which will check that everything is all right. The file is found in the root of
    the project and it's called `requirements.php`.
  prefs: []
  type: TYPE_NORMAL
- en: In Ubuntu, there are some packages you might want to install, which are going
    to be needed, such as `php5-mcrypt`, `php5-xsl`, and `php5-xdebug`. Each Linux
    distribution ships these PHP extensions in different ways and their naming might
    be different; please consult your Linux distro documentation if you're having
    problems on how to find, install, or configure them.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the installation process, you will note some additional work
    being done, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you had memory of the previous version of Yii, this was something many were
    looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that these steps need to be replicated manually if you're running
    Composer on a freshly checked out application, or you would need to run the `init`
    tool if you've got the advanced application installed.
  prefs: []
  type: TYPE_NORMAL
- en: The CLI command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Yii 2, Composer is used both as a way to install the basic skeleton of your
    web app, something you would have done with Yii 1 using the CLI interface instead,
    as shown in the following sequence of commands, and as a way to manage the dependencies
    of your projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can imagine, the scope and functionality of the command line is now quite
    different and has been expanded.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, the CLI is now found in the root of the project and it''s called
    `yii`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'By just running the preceding command, you will get a list of possible commands,
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The ones you will recognize from Yii 1 are `migrate` and `message`, which accomplish
    the same operations you were used to, albeit some have been improved. The only
    real difference is the way you'll be calling its specific actions (for example,
    `migrate/create`).
  prefs: []
  type: TYPE_NORMAL
- en: The shell and web app commands have now been replaced with a cache management
    tool called `cache`, a fixtures creation tool called `fixture,` which we'll see
    later on, and a demo command called `hello`, which you can use as inspiration
    to code one yourself (for example, to create cronjob tasks).
  prefs: []
  type: TYPE_NORMAL
- en: Finding your way around Yii 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you should have everything you need installed on your box, so let's start
    looking around and see how Yii 2 is organized so that we will know where to put
    our hands when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, there''s always a `README.md` file you can consult: in the advanced
    application, it will show you the structure and use of the various directories.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By just listing the content of the root of the project, you will immediately
    spot a big difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: I've willingly excluded the files from the output of `tree` and displayed only
    the directories.
  prefs: []
  type: TYPE_NORMAL
- en: It seems like all the content of what once was in `/protected` have been dropped
    outside of the document root.
  prefs: []
  type: TYPE_NORMAL
- en: The project structure is now very similar to what could be a Django or a Ruby
    on Rails application; the project root contains all the code, which is organized
    the same way as it was in the `protected` folder (for example, controllers, modules,
    config, and so on), some additional directories, such as for widgets, and the
    document root for your web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The directory you will need to configure Apache to use is called `web`, and
    it''s used by Yii to ship only the static files, assets, and the entry scripts,
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: I tend to prefer this organization as it gives the user the immediate idea of
    the organization of the code by lowering down the nesting levels of the directories.
  prefs: []
  type: TYPE_NORMAL
- en: If you are keen on using Nginx, that's not a problem, and you will find the
    required answers in the official documentation, which can be found at [http://www.yiiframework.com/doc-2.0/guide-start-installation.html#configuring-web-servers](http://www.yiiframework.com/doc-2.0/guide-start-installation.html#configuring-web-servers).
  prefs: []
  type: TYPE_NORMAL
- en: The only two directories that require a bit of explanation are `mail`, which
    is used to store the HTML template(s) for the e-mails (see documentation at [http://www.yiiframework.com/doc-2.0/guide-tutorial-mailing.html](http://www.yiiframework.com/doc-2.0/guide-tutorial-mailing.html)),
    and, possibly, `tests`, which you will be learning soon.
  prefs: []
  type: TYPE_NORMAL
- en: Structure of the default web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic application is composed of a `SiteController` with a couple of modules
    and a login system.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration files should be quite straightforward to understand and can
    be found in the `/config` directory. We will be touching on them every now and
    then in order to configure certain aspects and extensions we're going to use.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of whether you are using the manually installed basic application
    or the Composer-driven method explained earlier, you will be required to set up
    the database on your environment and configure the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the configuration file `web.php`, be sure to have set up the `cookieValidationKey`,
    and while in `db.php`, set up the DSN of your database as described in the documentation
    at [http://www.yiiframework.com/doc-2.0/guide-start-databases.html#configuring-a-db-connection](http://www.yiiframework.com/doc-2.0/guide-start-databases.html#configuring-a-db-connection).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also note the following at the end of the `web.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: By default, Yii 2 will provide you with a `YII_DEBUG` global constant definition,
    and an environment `YII_ENV_<ENVIRONMENT>` definition, which could come handy
    in certain conditions. Be aware that its use should be limited to specific cases
    where an alternative and more portable solution cannot be found, either by revisiting
    the implementation or the initial requirements. In a production environment, `YII_DEBUG`
    should be set to `false` and `YII_ENV` to `prod`.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation and sample code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this version, Yii is now following more strict standards in the way that
    the code is written and distributed.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation and readability of the code is essential and is mainly dictated
    by the PSR-1 and PSR-2 coding style guide (note that PSR-2 is explicitly depending
    on PSR-1), published by PHP-FIG ([http://www.php-fig.org](http://www.php-fig.org)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHPStorm, it is quite easy to set up the code style. Alternatively, you
    can use PHP_Codesniffer ([https://github.com/squizlabs/PHP_CodeSniffer](https://github.com/squizlabs/PHP_CodeSniffer))
    to accomplish the same task and validate your code:'
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to browse the code and check what it does. It's not massively different
    to what Yii 1 sample application did, apart from the use of PHP 5.4 syntactic
    sugar.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our working strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we know most of our tools that we are going to use, but we still don't know
    what we're going to do with them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the features we want to implement into Yii Playground,
    and let's analyze the end-to-end structure of the final application and how we
    should meet our quality assurance requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Key features to be implemented
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given what we've seen in the previous sections, the base web app provided by
    Yii contains just a basic infrastructure with which you can start playing around.
    For the purpose of this book, we're going to add several features that in a real-world
    environment would normally be requested by the client or stakeholders on the project
    through a brief, discussed and analyzed by the internal teams and scheduled to
    be developed.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to follow these steps and outline the necessary work needed in
    order to meet the desired level of quality assurance for the resulting application.
  prefs: []
  type: TYPE_NORMAL
- en: As previously said, the aim of testing is first and foremost to ensure that
    the code we produce matches the desired requirements. Anything else outside our
    code is not normally tested, but here exceptions apply and it really boils down
    to what the third-party code is doing, its overall quality, and reliability.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to aim to change the basic app in order to be able to login from
    a modal window.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've got the business requirements in place, we would break this feature
    down into subfeatures, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the path we will take on how to implement the modal window and the
    underlying infrastructure is quite important.
  prefs: []
  type: TYPE_NORMAL
- en: The code controlling the window from the client-side perspective needs to communicate
    with the backend to validate and authenticate the user. On a very basic level,
    this can be achieved by just adjusting the already existing controller that deals
    with the login process.
  prefs: []
  type: TYPE_NORMAL
- en: But we can do better. We can decide to roll our new login system without changing
    the existing one, thus avoiding introducing a breaking change that can affect
    our users. If for some reason a bug will slip past our control, we can just disable
    the new feature, while still letting the users log into the system.
  prefs: []
  type: TYPE_NORMAL
- en: This specific feature is also bringing up a series of implicit requirements,
    such as security and portability of our code, and integration with the existing
    and upcoming functionality. We want the user login application that sits on the
    client side to be self-contained and reusable as much as possible. Same goes for
    the backend authentication system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The proposed approach is then the following, together with the high-level assurance
    criteria we need to satisfy, which will outline the scope of the work in much
    more detail when implementing it and, on the other side, will help us create the
    required tests:'
  prefs: []
  type: TYPE_NORMAL
- en: User REST interface to authenticate the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modal login window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User authentication REST interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The REST interface will define some entry points to our application that will
    be easy to use. The URLs will then have a syntax of `/resource/id/operation`.
  prefs: []
  type: TYPE_NORMAL
- en: A GET retrieves information, a POST will store information. For example, POST
    user/login to log in, POST user/logout to log out, POST user/update to update
    some fields once if the user is logged in, and GET user/details to display user
    information.
  prefs: []
  type: TYPE_NORMAL
- en: The communication will work using JSON where needed.
  prefs: []
  type: TYPE_NORMAL
- en: User login from a modal window
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let's piece together what we've done with the REST interface and code the
    JavaScript code that will open the modal window, validate the form, communicate
    the login credentials to the backend, and keep the user logged in until the browser
    window is closed.
  prefs: []
  type: TYPE_NORMAL
- en: As previously said, the code needs to be self-contained and portable, and for
    security reasons, it will not deal with any sensible information at any point,
    like the actual authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing testing for our purposes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have defined what to do, we need to discuss what kind of testing
    is needed and how much of it we want to test, based on the approaches we have
    outlined in [Chapter 1](ch01.html "Chapter 1. The Testing Mindset"), *The Testing
    Mindset*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to cover the following areas of testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests**: This is to achieve isolated components testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration tests**: This is to ensure the various components are working
    well together'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acceptance tests**: These are the most relevant types of tests from the user
    perspective, as they try to meet the right requirements defined at the beginning'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearly, without knowing how our application is structured, it is hard to understand
    what kind of work we're going to endure.
  prefs: []
  type: TYPE_NORMAL
- en: So, before getting into defining the actual tests, we need to start breaking
    down our application into several modules, and overseeing the structure from an
    architectural point of view.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to perform an architectural breakdown, some might be stricter
    and more detailed, using a textual list, while others might end up being a rough
    sketch using a diagram. This heavily depends on the size and complexity of your
    application, and, in our case, a diagram seems to fit our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: We need to remember that we always want to balance the effort and the time spent
    on these initial phases with the amount of detail required at any given point.
    For instance, we might not know exactly how the modal window login will interact
    with the rest of the application, whether we need to develop a user model that
    is more complex than the one we will start with or even split it into different
    components so as to provide a different functionality to the frontend, or whether
    this is out of scope with the work we want to do and we can do it in a self-contained
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the diagram can miss small bits, which we might forget to test or
    consider when evaluating our test plan. For example, the JavaScript side of our
    application might include several small sets of utility functions that should
    be considered as separate modules for manageability and reuse.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing testing for our purposes](img/B03646_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Partial view of the structure of our application
  prefs: []
  type: TYPE_NORMAL
- en: As a solution to these problems, it is always advisable to revisit the structure
    of the software module and its own breakdown when approaching the development
    of the specific feature. This is something we will see in detail in the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, we can see that our application comprises essentially
    three main areas, starting from the bottom: a data storage system (database),
    a model representing the data, and a functional part (the view/controller part
    of the application). On top of everything sits our main interaction bit given
    by the user browser. This is not representative of the whole application, rather
    just the specific areas where we''re going to work on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''ve already seen, the **unit tests** are aimed at testing an atomic bit
    of the application, such as a class or a small set of related functions: their
    purpose is to be *small* and *isolate*, meaning they should have no external dependencies.
    Keep in mind that totally isolated tests in web development are difficult to achieve,
    and we are in fact not allowed to touch parts of our infrastructure, for instance,
    the database interaction. These tests are actually called **small tests** in Google''s
    internal terminology , which immediately indicates their scope and the time they
    will take to run.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Google is currently one of the publicly known companies that have made testing
    one of their core values. Their approach makes constant use of adjectives to distinguish
    between types of tests.
  prefs: []
  type: TYPE_NORMAL
- en: To read more about Google's way of testing, you might be interested in *How
    Google Tests Software*, *Addison Wesley*, *James Whittaker*, *Jason Arbon,* and
    *Jeff Carollo*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application, the unit test can be represented in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing testing for our purposes](img/B03646_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Graphical representation of unit testing coverage
  prefs: []
  type: TYPE_NORMAL
- en: A practical example is the user model we're going to create, and, as stated
    before, we might have other unit tests that we might want to write, for instance,
    in our JavaScript layer in the frontend, in case we were dealing with a client-side
    application where part of the business logic lives in the user browser.
  prefs: []
  type: TYPE_NORMAL
- en: Just remember, the tests covering the user model shouldn't make any use of external
    dependencies (for example, external helpers, such as the security module) and,
    secondly, they can avoid touching parts of the framework over which we don't have
    any control, specifically those that have potentially already been covered by
    other tests.
  prefs: []
  type: TYPE_NORMAL
- en: When focusing a bit more on the global picture, we can now see how things stack
    up and interact with each other. With **integration tests**, we might be required
    to use mocks and fakes anyway, but this is not highly recommended as it would
    be used for unit tests. In Google's terminology, these tests are called **medium
    tests**, as they take a bit more when executed and are also trivial to develop
    in certain situations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing testing for our purposes](img/B03646_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Graphical representation of integration tests coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last pieces of the jigsaw are the acceptance tests, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing testing for our purposes](img/B03646_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Graphical overview of acceptance tests.
  prefs: []
  type: TYPE_NORMAL
- en: '**Acceptance tests** are similar to system tests (or end-to-end tests), but
    they target the user rather than the consistency of the overall system from an
    engineering point of view. Acceptance tests are close to what could be a real-world
    use: these tests are required to ensure that all components are working well together,
    and meet the acceptance criteria defined at the beginning, as specific actions
    that outline the user interaction with the application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Acceptance criteria are those we have defined previously when outlining our
    features: the user should be able to log in using a modal window.'
  prefs: []
  type: TYPE_NORMAL
- en: I've intentionally avoided to use a business domain language, as we want to
    keep it as wide as possible for this initial part, instead we're going to dive
    into that later on.
  prefs: []
  type: TYPE_NORMAL
- en: At Google, acceptance (and end-to-end) tests are also called **large** or **enormous
    tests** because they will take a lot more to implement and to execute. They also
    require an infrastructure that could mimic a real-world scenario, which may not
    be trivial to set up. Because of this, creating corner cases can be quite difficult
    as this means that we're going to test only the defined scenarios and any specific
    case we think to be meaningful to the area that we're testing.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, this might be something along the lines of "The user will receive
    an error when using wrong credentials."
  prefs: []
  type: TYPE_NORMAL
- en: Again, we will specifically dig into these details later on in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Using a top-down approach versus a bottom-up approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's important to reiterate that BDD has been created as an improvement over
    TDD and quite an important one at that. It provides a better and more flexible
    language to define acceptance criteria, which will also help define the scope
    of the testing needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two ways to define our testing strategy and our test plan: using either
    a bottom-up (or *outside-in*) or a top-down (or *inside-out*) approach, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a top-down approach versus a bottom-up approach](img/B03646_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Comparison of different size of tests and their benefit.
  prefs: []
  type: TYPE_NORMAL
- en: It's not new for agencies and startups when trying to build up and improve their
    QA to start from the bottom, implementing unit tests and trying to get a good
    amount of coverage.
  prefs: []
  type: TYPE_NORMAL
- en: The use of TDD is encouraged and it's actually the first step in getting into
    the *testing mentality*, by writing tests first and then going through the *red,
    green, and refactor* phases. But its sole focus relies on the code, and the responsibility
    to implement and ensure they're covering the right amount of code rests with the
    developer.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests will help you focus on small and atomic parts of your application,
    and the tests, by being rather quick to be executed, will help you discover bugs
    frequently and improve the quality of the code developed. Your architectural and
    design skills will also improve significantly.
  prefs: []
  type: TYPE_NORMAL
- en: At a certain point, you will find yourself knowing that there's still something
    that is not touched by tests. While the project grows, the amount of manual and
    exploratory testing grows with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Integration tests can help you alleviate this problem, but please refrain yourself
    from spawning an incredible amount of integration tests: these can quickly become
    brittle and unmaintainable, especially when the external dependencies can become
    out-of-sync.'
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance tests are going to keep everything together and eliminate the need
    for the repetitive tasks you can perform when doing manual tests. Again, acceptance
    tests are not a replacement for exploratory testing and should instead focus on
    the acceptance criteria defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can imagine, the top-down approach gives you the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: A complete solution with a good enough coverage
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A clear panoramic of the testing infrastructure
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A good balance between effort, development, and tests
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most of all, the *confidence* that your system is solid, if not rock-solid
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What to test and what not to test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The distribution of test coverage could end up being distributed as 100 percent–20
    percent–10 percent, for unit, integration, and acceptance tests, respectively.
    The percentage for integration and acceptance can grow quite a fair bit in user-facing
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: In this context, it is particularly important to understand what **code coverage**
    means.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't already, you will probably find some software engineer that will
    convince you that 100 percent coverage is essential and not reaching it is some
    sort of shame you have to wear for the rest of the project, looking down at the
    ground for you're not a respectable developer.
  prefs: []
  type: TYPE_NORMAL
- en: Reaching full coverage is a noble aim, and that's where we will try to get,
    but we need also to be realists and, as highlighted before, understand that there
    are many situations where this is not possible at all.
  prefs: []
  type: TYPE_NORMAL
- en: The "what to test" question, or in other words the scope of the testing, is
    defined by our acceptance criteria for each feature we are going to develop.
  prefs: []
  type: TYPE_NORMAL
- en: Using the top-down approach, we will also be able to highlight which bits are
    important to be integration tested, while trying to achieve 100 percent for units.
  prefs: []
  type: TYPE_NORMAL
- en: The master test plan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the end of this initial planning work, you will have everything needed to
    define your master test plan.
  prefs: []
  type: TYPE_NORMAL
- en: The master test plan is a unified way to document the scope and details of what
    needs to be tested and how.
  prefs: []
  type: TYPE_NORMAL
- en: You don't need to be formal, and there's no specific requirement or procedure
    to follow, unless you're working for a big company where it's considered a deliverable
    at the beginning of the project to be signed off by the stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, it will be roughly defined by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'User API implementation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test as much as possible (aim for 100 percent, but 60 percent to 70 percent
    is considered acceptable on a case-by-case basis)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional tests to cover all the entry points of the application
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Well defined corner-cases—bad parameters and/or requests (for example, GET instead
    of POST) as client-side errors, and server-side errors handling (50* errors and
    similar)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'User login from modal window:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional tests to ensure we are getting the right markup
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Well defined corner cases—for example, no e-mail specified, e-mail with no Gravatar
    setup
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Acceptance tests—user clicks on the login button, modal is displayed, user logs
    in, user sees him/her as logged in; user is logged in, click on the logout button,
    the user sees him/her as logged out
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can imagine, the test plan should be a document that lives together with
    the project, being expanded and amended upon necessity when introducing new features
    or changing others. This requirement determines some constraints that should be
    respected if you want to keep having a specification document that is simple enough
    to be updated in a short time (10 minutes top) and, at a glance, lets you know
    what the implied risk and importance of each component and feature is.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to understand more of the topic, I would strongly suggest you read
    more starting from **Attributes-Components-Capabilities** (**ACC**) at [https://code.google.com/p/test-analytics/wiki/AccExplained](https://code.google.com/p/test-analytics/wiki/AccExplained).
  prefs: []
  type: TYPE_NORMAL
- en: The ACC goes together with risk analysis and mitigation. By putting your components,
    their relative capabilities (or features), and the attributes they should provide,
    such as "secure", "stable", "elegant", and so on in a grid, you can immediately
    understand where you should focus your testing attentions. For each row, you can
    give a risk value, relative to the other features. We want to keep the value relative
    to avoid making it too difficult to compute and also because it is meaningful
    only in this context.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During this chapter, you saw many important things, which are the base of what
    we''re going to work on in the next chapters and the base of testing from a wider
    perspective: you learned the importance of our workflow and environment setup,
    you saw how to use Composer and use it to install Yii, and, finally, we''ve picked
    up the concepts detailed in [Chapter 1](ch01.html "Chapter 1. The Testing Mindset"),
    *The Testing Mindset*, and made them concrete, applying them to our specific application
    and the features that we''re going to implement.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, before we dive into the actual implementation of the application, we need
    to get first into the testing suite **Codeception**, the jargon it uses, and the
    various features that it will provide, which we're going to use in the upcoming
    chapters.
  prefs: []
  type: TYPE_NORMAL
