<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Automated Testing</h1>
                </header>
            
            <article>
                
<p>Automated testing is a process by which we rely on special software to continuously run pre-defined tests that verify the integrity of our application. To this end, automated tests are a collection of steps that cover the functionality of an application and compare triggered outcomes to expected ones.</p>
<p>Manual testing is a great way to ensure that a piece of written functionality works as expected. The main problem encountered by most adopters of this strategy, especially those who use it exclusively, is regression. Once a piece of functionality is tested, the only way they can guarantee regressions (or bugs) were not introduced by another piece of functionality is by retesting it. And as the application grows, this becomes impossible to handle. This is where automated tests come in.</p>
<p>Automated testing uses special software that has an API that allows us to automate the steps involved in testing the functionality. This means that we can rely on machines to run these tests as many times as we want, and the only thing stopping us from having a fully-working application is the lack of proper test coverage with well-defined tests.</p>
<p>There's a lot of different software available for performing such tests and it's usually geared toward specific types of automated testing. For example, Behat is a powerful PHP-based open source behavior testing framework that allows the scripting of tests that mirror quite closely what a manual tester would do—interact with the application through the browser and test its behavior. There are other testing frameworks that go much lower in the level of their testing target. For example, the PHP industry standard tool, PHPUnit, is widely used for performing unit tests. This type of testing focuses on the actual code at the lowest possible level; it tests that class methods work properly by verifying their output after providing them with different input. A strong argument in favor of this kind of testing is that it encourages better code architecture, which can be (partly) measured by the ease with which unit testing can be written for it.</p>
<p>We also have functional or integration tests which fall somewhere in between the two examples. These go higher than code level and enlist application subsystems in order to test more comprehensive sets of functionality, without necessarily considering browser behavior and user interaction.</p>
<p>It is not difficult to agree that a well-tested application features a combination of the different testing methodologies. For example, testing the individual architectural units of an application does not guarantee that the entire subsystem works, just as testing only the subsystem does not guarantee that its individual components will work properly under all circumstances. Also, the same is true for certain subsystems that depend on user interaction—these require test coverage as well.</p>
<p>In this chapter, we will see how automated testing works in Drupal 8. More specifically, we will go through and explain all testing methodologies available for us as module developers and exemplify them with two tests each. By the end of this chapter, you'll be ready to write your own tests and be familiar enough with the code to further explore the available testing capabilities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing methodologies in Drupal 8</h1>
                </header>
            
            <article>
                
<p>Like many other development aspects, automated testing has been greatly improved in Drupal 8. In the previous version, the testing framework was a custom one built specifically for testing Drupal applications—<em>Simpletest</em>. Its main testing capability focused on functional testing with a strong emphasis on user interaction with a pseudo-browser. However, it was quite strong and allowed a wide range of functionality to be tested.</p>
<p>Drupal 8 development started with <em>Simpletest</em> as well. However, with the adoption of PHPUnit, Drupal is moving away from it and is in the process of deprecating it. To replace it, there is a host of different types of tests—all run by PHPUnit—that can cover more testing methodologies. So let's see what these are.</p>
<p>Drupal 8 comes with the following types of testing:</p>
<ul>
<li>Simpletest: exists for legacy reasons but no longer used to create new tests. This will be removed in Drupal 9.</li>
<li>Unit: low-level class testing with minimal dependencies (usually mocked).</li>
<li>Kernel: functional testing with the kernel bootstrapped, access to the database and only a few loaded modules.</li>
</ul>
<ul>
<li>Functional: functional testing with a bootstrapped Drupal instance, a few installed modules and using a Mink-based browser emulator (Goutte driver).</li>
<li>Functional JavaScript: functional testing like the previous, using the Selenium driver for Mink that allows for testing JavaScript powered functionality.</li>
</ul>
<p>Apart from Simpletest, all of these test suites are built on top of PHPUnit and are, consequently, run by it. Based on the namespace the test classes reside in, as well as the directory placement, Drupal can discover these tests and know what type they are.</p>
<p>In this chapter, we will see examples of all of them (except Simpletest) as we go about testing some of the functionality we've been writing in this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PHPUnit</h1>
                </header>
            
            <article>
                
<p>Drupal 8 uses PHPUnit as the testing framework for all types of tests. In this section, we will see how we can work with it to run tests.</p>
<div class="packt_tip">On your development environment (or wherever you want to run the tests), make sure you have the composer dependencies installed with the <kbd>--dev</kbd> flag. This will include PHPUnit. Keep in mind not to ever do this on your production environment as you can compromise the security of your application.</div>
<p>Although Drupal has a UI for running tests, PHPUnit is not well integrated with this. So, it's recommended that we run them using the command line instead. Actually, it's very easy to do so. To run the entire test suite (of a certain type), we have to navigate to the Drupal core folder:</p>
<pre>cd core  </pre>
<p>And run the following command:</p>
<pre>../vendor/bin/phpunit —testsuite=unit  </pre>
<p>This command goes back a folder through the vendor directory and uses the installed <kbd>phpunit</kbd> executable. As an option, in the previous example, we specified that we only want to run unit tests. Omitting that would run all types of tests. However, for most of the others, there will be some configuration needed, as we will see in the respective sections.</p>
<p>If we want to run a specific test, we can pass it as an argument to the <kbd>phpunit</kbd> command (the path to the file):</p>
<pre>../vendor/bin/phpunit tests/Drupal/Tests/Core/Routing/UrlGeneratorTest.php  </pre>
<p>In this example, we run a Drupal core test that tests the <kbd>UrlGenerator</kbd> class.</p>
<p>Alternatively, we can run multiple tests that belong to the same <em>group</em> (we will see how tests are added to a group soon):</p>
<pre>../vendor/bin/phpunit —group=Routing </pre>
<p>This runs all the tests from the <kbd>Routing</kbd> group which actually contains the <kbd>UrlGeneratorTest</kbd> we saw earlier. We can run tests from multiple groups if we separate them by a comma.</p>
<p>Also, to check what the available groups are, we can run the following command:</p>
<pre>../vendor/bin/phpunit —list-groups </pre>
<p>This will list all the groups that have been registered with PHPUnit.</p>
<p>Finally, we can also run a specific method found inside a test by using the <kbd>—filter</kbd> argument:</p>
<pre>../vendor/bin/phpunit —filter=testAliasGenerationUsingInterfaceConstants  </pre>
<p>This is one of the test methods from the same <kbd>UrlGeneratorTest</kbd> we saw before and is the only one that would run.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Registering tests</h1>
                </header>
            
            <article>
                
<p>There are certain commonalities between the various test suite types regarding what we need to do in order for Drupal (and PHPUnit) to be able to discover and run them.</p>
<p>First, we have the directory placement where the test classes should go in. The pattern is this: <kbd>tests/src/[suite_type]</kbd>, where <kbd>[suite_type]</kbd> is a name of the test suite type this test should be. And it can be one of the following:</p>
<ul>
<li>Unit</li>
<li>Kernel</li>
<li>Functional</li>
<li>FunctionalJavascript</li>
</ul>
<p>So, for example, unit tests would go inside the <kbd>tests/src/Unit</kbd> folder of our module.</p>
<p>Second, the test classes need to respect a namespace structure as well:</p>
<pre>namespace Drupal\Tests\[module_name]\[suite_type]  </pre>
<p>This is also pretty straightforward to understand.</p>
<p>Third, there is a certain metadata that we need to have in the test class PHPDoc. Every class must have a summary line describing what the test class is for. Only classes that use the <kbd>@coversDefaultClass</kbd> attribute can omit the summary line. Moreover, all test classes must have the <kbd>@group</kbd> PHPDoc annotation indicating the group they are part of. This is how PHPUnit can run tests that belong to certain groups only.</p>
<p>So now that we know how to register and run tests, let's look at unit tests and see how we can write our own.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit tests</h1>
                </header>
            
            <article>
                
<p>As briefly mentioned at the beginning, unit tests are used for testing single <em>units</em> that make up the code architecture. In practice, this means testing individual classes, especially the methods they contain and what they should be doing. Since the testing happens at such a low level, they are by far the fastest tests that can be run.</p>
<p>The logic behind unit tests is quite simple: after providing input, the test asserts that the method output is correct. Typically, the more <em>input -&gt; output</em> scenarios it covers, the more stable the tested code is. For example, tests should also cover unexpected scenarios, as well as exercise all the code contained in the tested methods (such as forks created by <em>if/else</em> statements).</p>
<p>The programming pattern of dependency injection—objects should receive as dependencies other objects they might need—becomes critical when it comes to unit testing. The reason is that if class methods work with the global scope or instantiate other objects, we can no longer test them cleanly. Instead, if they require dependencies, we can <em>mock</em> them and pass these within the context of the executed tests. We will see some examples shortly. But before we do that, let's create a simple class that can be easily tested using a unit test.</p>
<p>A typical example is a simple calculator class. It will take two numbers as arguments to its constructor and have four methods for performing basic arithmetic on those numbers. We'll put this into our <em>Hello World</em> module:</p>
<pre>namespace Drupal\hello_world; 
 
/** 
 * Class used to demonstrate a simple Unit test. 
 */ 
class Calculator { 
 
  private $a; 
  private $b; 
 
  public function __construct($a, $b) { 
    $this-&gt;a = $a; 
    $this-&gt;b = $b; 
  } 
 
  public function add() { 
    return $this-&gt;a + $this-&gt;b; 
  } 
 
  public function subtract() { 
    return $this-&gt;a - $this-&gt;b; 
  } 
 
  public function multiply() { 
    return $this-&gt;a * $this-&gt;b; 
  } 
 
  public function divide() { 
    return $this-&gt;a / $this-&gt;b; 
  } 
} </pre>
<p>Nothing so complicated here. You could argue that a calculator class should not get any dependencies but instead pass the numbers to the actual arithmetic methods. However, this will work just as fine for our example and is a bit less repetitive.</p>
<p>Now, let's create the first unit test to make sure that this class behaves as we expect it. In the previous section, we saw which directory these need to go in. So, in our case, it will be <kbd>/tests/src/Unit</kbd>. And the test class looks like this:</p>
<pre>namespace Drupal\Tests\hello_world\Unit; 
 
use Drupal\hello_world\Calculator; 
use Drupal\Tests\UnitTestCase; 
 
/** 
 * Tests the Calculator class methods. 
 * 
 * @group hello_world 
 */ 
class CalculatorTest extends UnitTestCase { 
 
  /** 
   * Tests the Calculator::add() method. 
   */ 
  public function testAdd() { 
    $calculator = new Calculator(10, 5); 
    $this-&gt;assertEquals(15, $calculator-&gt;add()); 
  } 
 
  /** 
   * Tests the Calculator::subtract() method. 
   */ 
  public function testSubtract() { 
    $calculator = new Calculator(10, 5); 
    $this-&gt;assertEquals(5, $calculator-&gt;subtract()); 
  } 
 
  /** 
   * Tests the Calculator::multiply() method. 
   */ 
  public function testMultiply() { 
    $calculator = new Calculator(10, 5); 
    $this-&gt;assertEquals(50, $calculator-&gt;multiply()); 
  } 
 
  /** 
   * Tests the Calculator::divide() method. 
   */ 
  public function testDivide() { 
    $calculator = new Calculator(10, 5); 
    $this-&gt;assertEquals(2, $calculator-&gt;divide()); 
  } 
 
}  </pre>
<p>First of all, you notice the namespace corresponds to the pattern what we saw in the previous chapter. Second of all, the PHPDoc contains the required information: a summary and the <kbd>@group</kbd> tag. Third of all, the class name ends with the word <kbd>Test</kbd>. Finally, the class extends <kbd>UnitTestCase</kbd>, which is the base class we need to extend for all unit tests.</p>
<div class="packt_infobox">All types of test class names in Drupal 8 need to end with the word <em>Test</em> and extend the relevant base class that provides specific code for that type of test.</div>
<p>Then, we have the actual methods that test various aspects of the <kbd>Calculator</kbd> class and which always have to start with the word <kbd>test</kbd>. This is what tells PHPUnit that they need to be run. These methods are the actual standalone tests themselves, meaning that the <kbd>CalculatorTest</kbd> class has four tests. Moreover, each of these tests runs independently of the other.</p>
<p>Since the <kbd>Calculator</kbd> arithmetic is very simple, it's not difficult to understand what we are doing to test it. For each method, we are instantiating a new instance with some numbers, and then we <em>assert</em> that the result from the arithmetic operation equals to what we expect. The base class provides a multitude of different assertion methods that we can use in our tests. Since there are so many of them, we are not going to cover them all here. We will see more as we write more tests, but I strongly recommend you check the base classes of the various types of test suites for methods that start with the word <kbd>assert</kbd>. A great way is also to use an IDE that autocompletes as you type the method name. It can be very handy.</p>
<p>With this, we can already run the test and see whether it passes. Normally, it should because we can do math in our heads and we know it's correct:</p>
<pre>../vendor/bin/phpunit ../modules/custom/hello_world/tests/src/Unit/CalculatorTest.php  </pre>
<p>The result should be green:</p>
<pre>OK (4 tests, 4 assertions)  </pre>
<p>However, earlier I mentioned that a good test also accounts for unexpected situations and negative responses. However, we have not done so very well in our example. If we look at <kbd>testAdd()</kbd>, we can see that the assertion is correct with those two numbers. But what if we later go to the <kbd>Calculator::add()</kbd> method and change it to this by accident:</p>
<pre>return 15;  </pre>
<p>The test will still pass but will it actually be a true positive? Not really, because if we pass different numbers, the calculation won't match anymore. So we should test these methods with more than just one set of numbers to actually prove that the math behind the <kbd>Calculator</kbd> class is valid.</p>
<p>So instead, we can do something like this:</p>
<pre>$calculator = new Calculator(10, 5); 
$this-&gt;assertEquals(15, $calculator-&gt;add()); 
$calculator = new Calculator(10, 6); 
$this-&gt;assertEquals(16, $calculator-&gt;add());  </pre>
<p>This way, we are sure that the addition operation works correctly. One trade-off in this is that we have a bit of repetitive code, especially if we have to do this for all the other operations as well.</p>
<p>Generally, when writing tests, repetition is much more accepted than when writing the actual code. Many times, there is nothing you can do about it as the code will seem very repetitive. However, in our case, we can actually do something by using the <kbd>setUp()</kbd> method which is called by PHPUnit before each test method runs. Its purpose is to perform various preparation tasks that are common for all the tests in the class. However, don't take this to mean that it runs only once and then is used by all. In fact, it runs before each individual test method.</p>
<p>So, what we can do is something like this:</p>
<pre>/** 
 * @var \Drupal\hello_world\Calculator 
 */ 
protected $calculatorOne; 
 
/** 
 * @var \Drupal\hello_world\Calculator 
 */ 
protected $calculatorTwo; 
 
/** 
 * {@inheritdoc} 
 */ 
public function setUp() { 
  parent::setUp(); 
  $this-&gt;calculatorOne = new Calculator(10, 5); 
  $this-&gt;calculatorTwo = new Calculator(10, 2); 
}  </pre>
<p>We create two class properties and inside the <kbd>setUp()</kbd> method we assign them to our calculator objects. A very important thing to keep in mind is to always call the parent call of this method because it does very important things for the environment setup. Especially as we move to Kernel and Functional tests.</p>
<p>Now, the <kbd>testAdd()</kbd> method can look like this:</p>
<pre>public function testAdd() { 
  $this-&gt;assertEquals(15, $this-&gt;calculatorOne-&gt;add()); 
  $this-&gt;assertEquals(12, $this-&gt;calculatorTwo-&gt;add()); 
}  </pre>
<p>Much cleaner and less repetitive. Based on this, you can extrapolate and apply the same changes to the other methods yourself.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mocked dependencies</h1>
                </header>
            
            <article>
                
<p>Seldom are tested classes so simple as our calculator class. Most of the time, they will have dependencies that in turn also have dependencies. So unit testing becomes a bit more complicated. In fact, the ease with which unit tests are written has become a litmus test for the quality of the code being tested—the less complicated the unit test, the better the code.</p>
<p>As our second example of writing unit tests, let's go into the "real world" and test one of the classes we wrote in this book, namely, the <kbd>UserTypesAccess</kbd> class. If you remember from <a href="bb49e98d-7db0-4969-95fc-a2bad6d4f1db.xhtml">Chapter 10</a>, <em>Access <span><span>C</span></span>ontrol</em>, we created this service to be used on routes as an access checker. Although we can write functional tests that verify that it works well as part of the access system, we can also write a unit test to check the actual code in the <kbd>access()</kbd> method. So let's get started.</p>
<p>The first thing we need to do is to create the class (respecting the directory placement as well as the class namespace):</p>
<pre>namespace Drupal\Tests\user_types\Unit; 
 
use Drupal\Tests\UnitTestCase; 
 
/** 
 * Tests the UserTypesAccess class methods. 
 * 
 * @group user_types 
 */ 
class UserTypesAccessTest extends UnitTestCase {}  </pre>
<p>So far things look like our previous example—we have the PHPDoc information and we are extending the <kbd>UnitTestCase</kbd> class. So let's write a test for the <kbd>access()</kbd> method of the <kbd>UserTypesAccess</kbd> class. However, if you remember, this method takes two arguments (a user account and a route object) and also uses the entity type manager which is injected in the class. So that is where the bulk of our complication lies. What we need to test is the return value of the method depending on these arguments. Basically, whether it will allow or deny access if the user account has certain values found on the route.</p>
<p>In unit testing, dependencies are usually mocked. This means PHPUnit will create empty lookalike objects that behave as we describe them to and we can use these as the dependencies. The way to create a simple mock object is this:</p>
<pre>$user = $this-&gt;createMock('Drupal\user\Entity\User');  </pre>
<p>The <kbd>$user</kbd> object will now be a mock of the Drupal 8 <kbd>User</kbd> entity class. It, of course, won't do anything but it can be used as a dependency. But to actually make it useful, we need to prescribe some behavior to it based on what the tested code does with it. For example, if it calls its <kbd>id()</kbd> method, we need to prescribe this behavior. We can do this with <em>expectations</em>:</p>
<pre>$user-&gt;expects($this-&gt;any()) 
  -&gt;method('id') 
  -&gt;will($this-&gt;returnValue(1));  </pre>
<p>This tells the mock object that for every call to the <kbd>id()</kbd> method on it, it should return the value <kbd>1</kbd>. The <kbd>expects()</kbd> method takes in a matcher which can be even more restrictive. For example, instead of <kbd>$this-&gt;any()</kbd>, we can use <kbd>$this-&gt;once()</kbd>, which means that the mock object can have its <kbd>id()</kbd> method called only once. Check out the base class for the other available options, as well as what you can pass to the <kbd>will()</kbd> method—although <kbd>$this-&gt;returnValue()</kbd> is going to be the most common one. Finally, if the <kbd>id()</kbd> method takes an argument, we can also have the <kbd>with()</kbd> method to which we pass the value of the expected argument in the matcher.</p>
<p>A more complex way of creating a mock is by using the mock builder:</p>
<pre>$user = $this-&gt;getMockBuilder('Drupal\user\Entity\User') 
  -&gt;getMock(); </pre>
<p>This will get the same mock object but will allow for some more options in its construction. I recommend checking out the PHPUnit documentation for more information as this is as deep as we are going to go in this book on mocking objects.</p>
<p>Now that we know a bit about mocking, we can proceed with writing our test. To do this, we need to think about the end goal and work our way back to all the method calls we need to mock. Just as a reminder, this is the code that we need to test:</p>
<pre>public function access(AccountInterface $account, Route $route) { 
  $user_types = $route-&gt;getOption('_user_types'); 
  if (!$user_types) { 
    return AccessResult::forbidden(); 
  } 
  if ($account-&gt;isAnonymous()) { 
    return AccessResult::forbidden(); 
  } 
  $user = $this-&gt;entityTypeManager-&gt;getStorage('user')-&gt;load($account-&gt;id()); 
  $type = $user-&gt;get('field_user_type')-&gt;value; 
  return in_array($type, $user_types) ? AccessResult::allowed() : AccessResult::forbidden(); 
}  </pre>
<p>So, at the first glance, we need to mock <kbd>EntityTypeManager</kbd>. The method arguments we will instantiate manually with some dummy data inside. However, mocking <kbd>EntityTypeManager</kbd> is going to be quite complicated. A call to its <kbd>getStorage()</kbd> method needs to return a <kbd>UserStorage</kbd> object. This needs to also be mocked because a call on its <kbd>load()</kbd> method needs to return a <kbd>User</kbd> entity object. Finally, we also need to mock that because a call to its <kbd>get()</kbd> method is also expected to return a value object.</p>
<p>As I mentioned, we will proceed by going back from our end goal. So we can start with instantiating the types of <kbd>AccountInterface</kbd> objects we want to pass, as well as the route objects:</p>
<pre>/**<br/>  * Tests the UserTypesAccess::access() method.<br/>  */<br/> public function testAccess() {<br/>   // User accounts<br/>   $anonymous = new UserSession(['uid' =&gt; 0]);<br/>   $registered = new UserSession(['uid' =&gt; 2]);<br/><br/>   // Route definitions.<br/>   $manager_route = new Route('/test_manager', [], [], ['_user_types' =&gt; ['manager']]);<br/>   $board_route = new Route('/test_board', [], [], ['_user_types' =&gt; ['board']]);<br/>   $none_route = new Route('/test_board');<br/> }</pre>
<p>And the new <em>use</em> statements at the top:</p>
<pre>use Drupal\Core\Session\UserSession; 
use Symfony\Component\Routing\Route;  </pre>
<p>Basically, we want to test what happens for both types of users: anonymous and registered. When instantiating the <kbd>UserSession</kbd> objects (which implement <kbd>AccountInterface</kbd>), we pass in some data to be stored with it. In our case, we need the user <kbd>uid</kbd> because it will be requested by the tested code when checking whether the user is anonymous or not.</p>
<p>Then, we create three routes: one where managers should have access, one where board members should have access, and one where no one should have access (as indicated by the <kbd>_user_types</kbd> option on the route). Do check back to <a href="bb49e98d-7db0-4969-95fc-a2bad6d4f1db.xhtml">Chapter 10</a>, <em>Access Control,</em> if you don't remember what this functionality is about.</p>
<p>Once this is done, it follows to instantiate our <kbd>UserTypesAccess</kbd> class, in view of calling its <kbd>access()</kbd> method with various combinations of our account and route objects:</p>
<pre>$access = new UserTypesAccess($entity_type_manager);</pre>
<p>And the new <em>use</em> statement at the top:</p>
<pre> use Drupal\user_types\Access\UserTypesAccess;</pre>
<p>However, we don't yet have an entity type manager so we need to mock it. Here is all the code we need to mock the entity type manager to work for our tested code (this goes before the code we wrote so far in this test):</p>
<pre>// User entity mock. 
$type = new \stdClass(); 
$type-&gt;value = 'manager'; 
$user = $this-&gt;getMockBuilder('Drupal\user\Entity\User') 
  -&gt;disableOriginalConstructor() 
  -&gt;getMock(); 
$user-&gt;expects($this-&gt;any()) 
  -&gt;method('get') 
  -&gt;will($this-&gt;returnValue($type)); 
 
// User storage mock 
$user_storage = $this-&gt;getMockBuilder('Drupal\user\UserStorage') 
  -&gt;disableOriginalConstructor() 
  -&gt;getMock(); 
$user_storage-&gt;expects($this-&gt;any()) 
  -&gt;method('load') 
  -&gt;will($this-&gt;returnValue($user)); 
 
// Entity type manager mock. 
$entity_type_manager = $this-&gt;getMockBuilder('Drupal\Core\Entity\EntityTypeManager') 
  -&gt;disableOriginalConstructor() 
  -&gt;getMock(); 
$entity_type_manager-&gt;expects($this-&gt;any()) 
  -&gt;method('getStorage') 
  -&gt;will($this-&gt;returnValue($user_storage));  </pre>
<p>First of all, you will notice that the entity type manager is only mocked at the very end. We first need to start the call chain which ends with a User entity object field value. So the first block mocks the User entity object which expects any number of calls to its <kbd>get()</kbd> method to which it will always return a <kbd>stdClass()</kbd> object with the property <kbd>value</kbd> that equals to the <kbd>manager</kbd> string. This way we are mocking the entity field system accessor.</p>
<div class="packt_infobox">While using the mock builder for creating our mocks, we can use the <kbd>disableOriginalConstructor()</kbd> method to prevent PHPUnit from calling the constructor of the original class. This is important in order to prevent the need for all sorts of other dependencies that don't actually impact the tested code.</div>
<p>Now that we have the User entity mock, we can use it as the return value of the <kbd>UserStorage</kbd> mock's <kbd>load()</kbd> method. This, in turn, is the return value of the entity type manager mock's <kbd>getStorage()</kbd> method. So, all of the code we wrote means that we have mocked the following chain:</p>
<pre>$this-&gt;entityTypeManager-&gt;getStorage('user')-&gt;load($account-&gt;id());  </pre>
<p>It doesn't really matter what we pass to the <kbd>load()</kbd> method as we will always have that one user entity that has the <kbd>manager</kbd> user type.</p>
<p>Now that everything is mocked, we can use the <kbd>$access</kbd> object we created earlier and make assertions based on calls to its <kbd>access()</kbd> method:</p>
<pre>// Access denied due to lack of route option. 
$this-&gt;assertInstanceOf('Drupal\Core\Access\AccessResultForbidden', $access-&gt;access($registered, $none_route)); 
 
// Access denied due to user being anonymous on any of the routes 
$this-&gt;assertInstanceOf('Drupal\Core\Access\AccessResultForbidden', $access-&gt;access($anonymous, $manager_route)); 
$this-&gt;assertInstanceOf('Drupal\Core\Access\AccessResultForbidden', $access-&gt;access($anonymous, $board_route)); 
 
// Access denied due to user not having proper field value 
$this-&gt;assertInstanceOf('Drupal\Core\Access\AccessResultForbidden', $access-&gt;access($registered, $board_route)); 
 
// Access allowed due to user having the proper field value. 
$this-&gt;assertInstanceOf('Drupal\Core\Access\AccessResultAllowed', $access-&gt;access($registered, $manager_route));  </pre>
<p>The return value is always an object that implements an interface—either <kbd>AccessResultAllowed</kbd> or <kbd>AccessResultForbidden</kbd>, so that is what we need to assert. We are checking four different use cases:</p>
<ul>
<li>Access denied if there is no route option</li>
<li>Access denied for anonymous users on any of the routes</li>
<li>Access denied for registered users with the wrong user type</li>
<li>Access allowed for registered users with the proper user type</li>
</ul>
<p>So with this, we can run the test and should hopefully get a green result:</p>
<pre>../vendor/bin/phpunit ../modules/custom/user_types/tests/src/Unit/UserTypesAccessTest.php   </pre>
<p>This is the basics of writing unit tests. There are a lot more types of assertions and you'll end up mocking quite a lot of dependencies in Drupal 8. But don't be put off by the slow pace encountered at first as things will become faster as you get more experience.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Kernel tests</h1>
                </header>
            
            <article>
                
<p>Kernel tests are the immediate higher-level testing methodology we can have in Drupal 8 and are actually integration tests that focus on testing various components. They are faster than regular Functional tests as they don't do a full Drupal install, but use an in-memory pseudo installation that is much faster to bootstrap. For this reason, they also don't handle any browser interactions and don't install any modules automatically.</p>
<p>Apart from the code itself, Kernel tests also work with the database and allow us to load the modules that we need for running the test. However, unlike the Functional tests we will see next, Kernel tests also require us to manually trigger the installation of any database schemas we need. But we will see how we can do this in the two examples we cover in this section.</p>
<p>Before we can work with Kernel tests though, we need to make sure we have a connection to the database and PHPUnit is aware of this. Inside the <kbd>core</kbd> folder of our Drupal installation we find a <kbd>phpunit.xml.dist</kbd> file which we need to duplicate and rename to <kbd>phpunit.xml</kbd>. This is the PHPUnit configuration file. Normally this file should already be ignored by Git so no need to worry about committing it to the repository.</p>
<p>In this file, we find an environment variable called <kbd>SIMPLETEST_DB</kbd> where we can specify the connection to the database, using the format exemplified in the following commented code:</p>
<pre>mysql://username:password@localhost/databasename#table_prefix  </pre>
<p>Once that is in, PHPUnit will be able to connect to the database in order to install Drupal for Kernel tests as well as Functional and FunctionalJavascript tests.</p>
<div class="packt_tip">As a rule of thumb, you should always opt for Kernel tests over Functional tests whenever browser interactions are not involved and Kernel tests are enough to do the job. This is because a suite full of tests can end up taking a long time to run so you should make it as performant as possible.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">TeamCleaner test</h1>
                </header>
            
            <article>
                
<p>Now that we have that covered, it's time to write our first Kernel test. And a nice simple example can be to test the <kbd>TeamCleaner</kbd><kbd>QueueWorker</kbd> plugin we created in <a href="88a7281a-cb61-4079-8dde-3041babf698e.xhtml">Chapter 14</a>, <em>Batches, Queues, and Cron</em>. If you are wondering why this cannot be tested using the ultra-fast unit testing methodology, the answer is that its single method doesn't return anything. Instead, it alters database values that we need to access in order to check it happened correctly.</p>
<p>The test class goes naturally in the <kbd>tests/src/Kernel</kbd> folder of our module and can start off like this:</p>
<pre>namespace Drupal\Tests\sports\Kernel; 
 
use Drupal\KernelTests\KernelTestBase; 
 
/** 
 * Test the TeamCleaner QueueWorker plugin. 
 * 
 * @group sports 
 */ 
class TeamCleanerTest extends KernelTestBase {}  </pre>
<p>The namespace is consistent with the ones we've seen so far and we have the correct PHPDoc annotations to register the test. Moreover, this time, we are extending from <kbd>KernelTestBase</kbd>. Do pay attention to the actual version of this class because the one that comes from the old Simpletest framework is also called <kbd>KernelTestBase</kbd>. So make sure you extend the correct one as seen in the <em>use</em> statement.</p>
<p>The first thing we need to do is specify which modules we want loaded when running this test. For our case, this is the <kbd>sports</kbd> module so we can add a class property that contains this name:</p>
<pre>/** 
 * Modules to enable. 
 * 
 * @var array 
 */ 
protected static $modules = ['sports'];  </pre>
<p>Specifying a list of modules here does not actually install them but simply loads and adds them to the service container. So yes, we have access to the module and code as well as the container. But that also means that schemas defined by these modules are not actually created so we need to do that manually. The same is true for the configuration the module is shipped with. But we can handle these things in the <kbd>setUp()</kbd> method or in the actual test method itself. We'll opt for the latter because, in this case, we only have one test method in the class. And the whole thing can look like this:</p>
<pre>/** 
 * Tests the TeamCleaner::processItem() method. 
 */ 
public function testProcessItem() { 
  $this-&gt;installSchema('sports', 'teams'); 
  $database = $this-&gt;container-&gt;get('database'); 
  $fields = ['name' =&gt; 'Team name']; 
  $id = $database-&gt;insert('teams') 
    -&gt;fields($fields) 
    -&gt;execute(); 
 
  $records = $database-&gt;query("SELECT id FROM {teams} WHERE id = :id", [':id' =&gt; $id])-&gt;fetchAll(); 
  $this-&gt;assertNotEmpty($records); 
 
  $worker = new TeamCleaner([], NULL, NULL, $database); 
  $data = new \stdClass(); 
  $data-&gt;id = $id; 
  $worker-&gt;processItem($data); 
  $records = $database-&gt;query("SELECT id FROM {teams} WHERE id = :id", [':id' =&gt; $id])-&gt;fetchAll(); 
  $this-&gt;assertEmpty($records); 
}  </pre>
<p>And the <em>use</em> statement:</p>
<pre>use Drupal\sports\Plugin\QueueWorker\TeamCleaner;  </pre>
<p>Since the <kbd>TeamCleaner</kbd> plugin removes teams, it's enough to only install that table. We can do that using the parent <kbd>installSchema()</kbd> method to which we pass the module name and table we want installed. We don't actually deal with players so we should avoid doing unnecessary work like the creation of the <kbd>players</kbd> table.</p>
<p>Then, very similar to how we do it in real code, we get the <kbd>database</kbd> service from the container and add a record to the <kbd>teams</kbd> table. This will be the test record that we delete so we remember its <kbd>$id</kbd>. But before we test this, we want to make absolutely sure that our record got saved. So we query for it and assert that the result is not empty. The <kbd>assertNotEmpty()</kbd> method is another helpful assertion that we can use when dealing with arrays.</p>
<p>Now that we are certain the record is in the database, we can "process" it using our plugin. So we instantiate a <kbd>TeamCleaner</kbd> object, passing all its required dependencies—most importantly the database service. Then we create a simple object that mimics what the <kbd>processItem()</kbd> method expects and calls the latter while passing the former to it. At this point, if our plugin did its job correctly, the team record should have been deleted from the database. So we can query for it and this time assert the opposite of what we did before: that the query comes back empty.</p>
<p>And with this, our test is finished. As always, we should actually run it and make sure it passes:</p>
<pre>../vendor/bin/phpunit ../modules/custom/sports/tests/src/Kernel/TeamCleanerTest.php  </pre>
<p>And that is a very simple example of using Kernel tests for testing a component, particularly one that integrates with the database. We could have used a Functional test as well but that would have been overkill—it would run slower and make no use of the benefits that it offers over Kernel testing, such as browser integration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CsvImporter test</h1>
                </header>
            
            <article>
                
<p>After this simple example, let's write another test that illustrates a more complex scenario. And we will write one that tests the <kbd>CsvImporter</kbd> plugin we created in the previous chapter.</p>
<p>There is quite a lot of functionality that goes into this plugin and working with it—we have the actual importing, the plugin and configuration entity creation, the user interface for doing so, and so on. And it's a very good example of functionality that can benefit from a multi-methodology test coverage. And in this respect, we start with testing its underlying purpose, that of the product import, for which we don't need browser interactions. This means that we can use a Kernel test.</p>
<p>Similar to how we wrote the previous test, we can start with the class like so (this time in the <kbd>products</kbd> module):</p>
<pre>namespace Drupal\Tests\products\Kernel; 
 
use Drupal\KernelTests\KernelTestBase; 
 
/** 
 * Tests the CSV Product Importer 
 * 
 * @group products 
 */ 
class CsvImporterTest extends KernelTestBase {}  </pre>
<p>Nothing new so far.</p>
<p>Next, we need to specify the modules we need loaded. And here we have a bigger list:</p>
<pre>  /** 
   * Modules to enable. 
   * 
   * @var array 
   */ 
  protected static $modules = ['system', 'csv_importer_test', 'products', 'image', 'file', 'user'];  </pre>
<p>Only the <kbd>products</kbd> module may seem obvious to you at this point, but all the rest are also needed. The <kbd>system</kbd>, <kbd>image</kbd>, <kbd>file</kbd> and <kbd>user</kbd> modules are all somehow needed for dealing with the file upload and storage process that is needed for the <kbd>CsvImporter</kbd> plugin.</p>
<div class="packt_tip">It's not always so easy to figure out which modules are needed so it will involve a bit of a trial and error, at least in the beginning. A typical scenario is to run the test and notice failures due to missing functionality. Tracking this functionality to a module and specifying this module in the list is how you usually end up with a complete module list, especially when the test is complex and needs a wide range of subsystems with dependencies.</div>
<p>But you may be wondering what's with the <kbd>csv_importer_test</kbd> module there. Oftentimes, you may need to create modules used only for the tests—usually because they contain some configuration you want to use in your testing. In our case, we did so to demonstrate where these modules would go and to add a <kbd>products.csv</kbd> test file that we can use in our tests.</p>
<p>Tests modules go inside the <kbd>tests/modules</kbd> folder of the module that contains the tests that use them. So, in our case, we have <kbd>csv_importer_test</kbd> with its <kbd>info.yml</kbd> file:</p>
<pre>name: CSV Importer Test 
description: Used for testing the CSV Importer 
core: 8.x 
type: module 
package: Testing  </pre>
<p>And the mentioned CSV file we will use is right next to it:</p>
<pre>id,name,number 
1,Car,45345 
2,Motorbike,54534  </pre>
<p>Now that we covered that, we can write the test method:</p>
<pre>/** 
 * Tests the import of the CSV based plugin. 
 */ 
public function testImport() { 
  $this-&gt;installEntitySchema('product'); 
  $this-&gt;installEntitySchema('file'); 
  $this-&gt;installSchema('file', 'file_usage'); 
  $manager = $this-&gt;container-&gt;get('entity_type.manager'); 
  $products = $manager-&gt;getStorage('product')-&gt;loadMultiple(); 
  $this-&gt;assertEmpty($products); 
 
  $csv_path = drupal_get_path('module', 'csv_importer_test') . '/products.csv'; 
  $csv_contents = file_get_contents($csv_path); 
  $file = file_save_data($csv_contents, 'public://simpletest-products.csv', FileSystemInterface::EXISTS_REPLACE); 
  $config = $manager-&gt;getStorage('importer')-&gt;create([ 
    'id' =&gt; 'csv', 
    'label' =&gt; 'CSV', 
    'plugin' =&gt; 'csv', 
    'plugin_configuration' =&gt; [ 
      'file' =&gt; [$file-&gt;id()] 
    ], 
    'source' =&gt; 'Testing', 
    'bundle' =&gt; 'goods', 
    'update_existing' =&gt; true 
  ]); 
  $config-&gt;save(); 
 
  $plugin = $this-&gt;container-&gt;get('products.importer_manager')-&gt;createInstanceFromConfig('csv'); 
  $plugin-&gt;import(); 
  $products = $manager-&gt;getStorage('product')-&gt;loadMultiple(); 
  $this-&gt;assertCount(2, $products); 
 
  $products = $manager-&gt;getStorage('product')-&gt;loadByProperties(['number' =&gt; 45345]); 
  $this-&gt;assertNotEmpty($products); 
  $this-&gt;assertCount(1, $products); 
}  </pre>
<p>And the <em>use</em> statement at the top:</p>
<pre>use Drupal\Core\File\FileSystemInterface;  </pre>
<p>The initial setup here is a bit more complicated, partly because of Kernel tests not installing module schemas. Using the parent <kbd>installEntitySchema()</kbd>, method we can install all the necessary tables for the Product and File content entities. However, since we are working with managed files, we also need to install the <kbd>file_usage</kbd> table manually. It is not technically an entity table. Again, there is no shame in arriving at these steps using trial and error.</p>
<p>Now that we have the basics set up, we do a sanity check and ensure that we don't have any product entities in the database. There is no reason why we should have any, but it doesn't hurt to ensure it. This guarantees a valid test since our goal will be to later assert the existence of products.</p>
<p>Then we create a managed File entity by using the <kbd>products.csv</kbd> file from the <kbd>csv_importer_test</kbd> module. The <kbd>drupal_get_path()</kbd> function is a very common way of retrieving the relative path to a module or a theme, regardless of where it is actually located. And we save the contents of this file into the <kbd>public://</kbd> filesystem of the testing environment. Keep in mind, though, that after the test runs successfully, this file gets removed as Drupal cleans up after itself.</p>
<p>Next, we need to create an Importer configuration entity that uses the CSV-based plugin to run the import. And instead of doing it through the UI, we do it programmatically. Using the storage manager, we create the entity as we learned in <a href="77cab458-5612-468c-8010-12385708eb81.xhtml">Chapter 6</a>, <em>Data Modeling and Storage</em>. Once we have that, we use the Importer plugin manager to create an instance based on this configuration entity (to which we gave the ID <kbd>csv</kbd>). And finally, we run the import of the products.</p>
<p>Now, for the assertions, we do a double check. Since our test CSV contains two rows, we load all the product entities again and assert that we have a total of two. No more, no less. And here we see another useful assertion method for working with arrays: <kbd>assertCount()</kbd>. But then we get a bit more specific and try to load a product that has a field value (the <kbd>number</kbd>) equal to an expected number from the test CSV file. And assert that it is, in fact, found as well.</p>
<p>We could even do some more assertions. For example, we can check that all the Product field values have been set correctly. I'll let you explore ways in which you can do this—either by querying based on these values or asserting equality between field values and their expected ones. But it's important to not go overboard as it will impact speed and, in some cases, add insufficient value to the test coverage to compensate for it. The trick is to find the right balance.</p>
<p>Finally, with our test in place, we can actually run it:</p>
<pre>../vendor/bin/phpunit ../modules/custom/products/tests/src/Kernel/CsvImporterTest.php  </pre>
<p>And this test should pass as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functional tests</h1>
                </header>
            
            <article>
                
<p>In the previous section we looked at Kernel tests and said that they are basically integration tests that focus on components rather than interactions with the browser. In this section, we'll go one level up and talk about the fully-fledged Functional tests, otherwise called browser tests (from the name of the base class we need to extend).</p>
<p>Functional tests in Drupal 8 use a simulated browser (using the popular Mink emulator) that allows users to click links, navigate to pages, work with forms and make assertions regarding HTML elements on the page. What they don't allow us is to test JavaScript-based interactions (see the next section for those).</p>
<p>In Drupal 7, Functional tests were the most common type of tests used, most classes extending from Simpletest's <kbd>WebTestBase</kbd> class. But in Drupal 8 we have the <kbd>Drupal\Tests\BrowserTestBase</kbd> class which is integrated with PHPUnit like the ones we've seen before. And the base class contains loads of methods both for asserting things and shortcuts to performing Drupal (and web) related tasks: creating users, entities, navigating to pages, filling in and submitting forms, logging in, and so on. And just like before, each test (class method), runs in isolation so things like content and users cannot be shared across multiple tests but would have to be recreated (perhaps using the <kbd>setUp()</kbd> method as we've already seen).</p>
<p>Browser tests perform a full Drupal installation with a minimal number of modules (using the <em>Testing</em> installation profile). This means that we can specify to install other modules as well, and the schema for these also gets installed. Moreover, it's also important to understand that the resulting installation has got nothing in common with our current development site. Any configuration we need, we have to create. There are no users, no content and no files. So it is a brand new, parallel installation<span><span>,</span></span> that runs for the duration of one single test and gets cleaned up as it finishes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration for functional tests</h1>
                </header>
            
            <article>
                
<p>Before writing our functional tests, we need to turn back to our <kbd>phpunit.xml</kbd> file and change some environment variables. Apart from the <kbd>SIMPLETEST_DB</kbd> variable we adjusted earlier, we also have the <kbd>SIMPLETEST_BASE_URL</kbd> and <kbd>BROWSERTEST_OUTPUT_DIRECTORY</kbd>. The first is used to know where the application can be accessed in the browser. The latter is the directory where output data can be saved by PHPUnit and needs to be an absolute local path (for example, a folder in the local <kbd>files</kbd> folder):</p>
<pre>/var/www/sites/default/files/browser-output   </pre>
<p>Moreover, make sure the user running the test has permissions to write into the <kbd>sites/simpletest</kbd> folder as that is where the virtual filesystem is created for each test. The easiest way to do it is to change the folder ownership to the web server user that runs the process. In the case of Apache, this is usually <kbd>www-data</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hello World page test</h1>
                </header>
            
            <article>
                
<p>The first Functional test we will write is for the <em>Hello World</em> page we created and the functionality behind it. We will test whether the page shows the correct <em>Hello World</em> message, also depending on the value found in the configuration. So let's create the class for it, naturally in the <kbd>hello_world</kbd> module, inside the <kbd>tests/src/Functional</kbd> folder:</p>
<pre>namespace Drupal\Tests\hello_world\Functional; 
 
use Drupal\Tests\BrowserTestBase; 
 
/** 
 * Basic testing of the main Hello World page. 
 * 
 * @group hello_world 
 */ 
class HelloWorldPageTest extends BrowserTestBase {}  </pre>
<p>You can really see the consistency with the other types of tests. But in this case, as mentioned, we extend from <kbd>BrowserTestBase</kbd>.</p>
<p>Also, like before, we can configure a number of modules we want installed:</p>
<pre>/** 
 * Modules to enable. 
 * 
 * @var array 
 */ 
protected static $modules = ['hello_world', 'user']; </pre>
<p>We will need the User module for the second test we run, which will go in the same class as this one. But let's proceed with the first, easier test:</p>
<pre>/** 
 * Tests the main Hello World page. 
 */ 
public function testPage() { 
  $expected = $this-&gt;assertDefaultSalutation(); 
  $config = $this-&gt;config('hello_world.custom_salutation'); 
  $config-&gt;set('salutation', 'Testing salutation'); 
  $config-&gt;save(); 
 
  $this-&gt;drupalGet('/hello'); 
  $this-&gt;assertSession()-&gt;pageTextNotContains($expected); 
  $expected = 'Testing salutation'; 
  $this-&gt;assertSession()-&gt;pageTextContains($expected); 
}  </pre>
<p>If you remember, our <kbd>/hello</kbd> page shows a greeting depending on the time of day, unless an administrator has overridden that message through a configuration form. So we start this test by asserting that with a fresh install that has no override, we see the time-based greeting. And for that we create a separate assertion message since it's a bit wordy and we will reuse it:</p>
<pre>/** 
 * Helper function to assert that the default salutation is present on the page. 
 * 
 * Returns the message so we can reuse it in multiple places. 
 */ 
private function assertDefaultSalutation() { 
  $this-&gt;drupalGet('/hello'); 
  $this-&gt;assertSession()-&gt;pageTextContains('Our first route'); 
  $time = new \DateTime(); 
  $expected = ''; 
  if ((int) $time-&gt;format('G') &gt;= 00 &amp;&amp; (int) $time-&gt;format('G') &lt; 12) { 
    $expected = 'Good morning'; 
  } 
 
  if ((int) $time-&gt;format('G') &gt;= 12 &amp;&amp; (int) $time-&gt;format('G') &lt; 18) { 
    $expected = 'Good afternoon'; 
  } 
 
  if ((int) $time-&gt;format('G') &gt;= 18) { 
    $expected = 'Good evening'; 
  } 
  $expected .= ' world'; 
  $this-&gt;assertSession()-&gt;pageTextContains($expected); 
  return $expected; 
} </pre>
<p>The very first thing we do here is use the <kbd>drupalGet()</kbd> method to navigate to a path on the site. Do check out the method signature for all the options you can pass to it. And the first assertion we make is that the page contains the text <em>Our first route</em> (which is the page title). The parent <kbd>assertSession()</kbd> method returns an instance of <kbd>WebAssert</kbd> which contains all sorts of methods for asserting the presence of elements on the current page in the Mink session. One such method is the generic <kbd>pageTextContains()</kbd> with which we simply check that the given text can be found anywhere on the page.</p>
<p>Although in quite a lot of cases asserting the presence of a text string is enough, you may want to ensure that it is actually the right one (to avoid false positives). For example, in our case, we could check that it is really the page title that is rendered inside an <kbd>&lt;h1&gt;</kbd> tag. We can do it like so:</p>
<pre>$this-&gt;assertSession()-&gt;elementTextContains('css', 'h1', 'Our first route');  </pre>
<p>The <kbd>elementTextContains()</kbd> method can be used to find an element on the page based on a locator (CSS selector or xpath) and assert that it contains the specified text. In our example we use the CSS selector locator and we try to find the <kbd>&lt;h1&gt;</kbd> element.</p>
<p>If all of that is okay, we proceed with asserting that the actual salutation message is present on the page. Unfortunately, we have to duplicate quite some code because it is dependent on the time of day. A good homework for you would be to extract this logic to a service that determines the message and use this service both here and in the actual code. And since we need this message later, we also return it.</p>
<p>Going back to our actual test method, we can proceed knowing that the message is showing correctly on the page. And the next thing we want to test is the following: if there is a <kbd>hello_world.custom_salutation</kbd> configuration object with a <kbd>salutation</kbd> value, that is what should be shown. So we programmatically create it. Next, we again navigate to the same path (we essentially reload the page) and check that the old message is not shown anymore and that the new one is instead.</p>
<p>So if we actually run this test:</p>
<pre>../vendor/bin/phpunit ../modules/custom/hello_world/tests/src/Functional/HelloWorldPageTest.php  </pre>
<p>...darn. We get an error:</p>
<pre>Behat\Mink\Exception\ResponseTextException: The text "Good evening world" appears in the text of this page, but it should not. </pre>
<p>It's as if we didn't even override the salutation message. But we did.</p>
<p>The problem is caching. Keep in mind, we are navigating these pages as anonymous users and caching is enabled on the site like in normal scenarios. In <a href="13739cad-2542-40b4-ae42-9a7f9e159716.xhtml">Chapter 11</a>, <em>Caching</em>, I made a note about this particular problem—the <kbd>max-age</kbd> property only bubbles up to the page level for the dynamic page cache (logged-in users) and not for anonymous users.</p>
<div class="packt_infobox">This is a great example of automated testing shedding light on mistakes we introduce while developing and that we don't notice. We most likely wrote our functionality while having caching disabled and/or always visiting the page as a logged-in user. So it's an easy mistake to make. Luckily, automated testing comes to the rescue.</div>
<p>The solution to this problem can be found using an all-out cache kill switch. This means that we need to alter a bit our logic to tell Drupal to never cache the pages where our salutation component is shown. This is the price we have to pay for the highly dynamic nature of our functionality and it's always a good exercise to evaluate if it is worth it.</p>
<p>The kill switch is actually easy to use. It's a service that we need to inject into our <kbd>HelloWorldSalutation</kbd> service:</p>
<pre>/** 
 * @var \Drupal\Core\PageCache\ResponsePolicy\KillSwitch 
 */ 
protected $killSwitch; 
 
/** 
 * HelloWorldSalutation constructor. 
 * 
 * @param \Drupal\Core\Config\ConfigFactoryInterface $config_factory 
 * @param \Symfony\Component\EventDispatcher\EventDispatcherInterface $eventDispatcher 
 * @param \Drupal\Core\PageCache\ResponsePolicy\KillSwitch $killSwitch 
 */ 
public function __construct(ConfigFactoryInterface $config_factory, EventDispatcherInterface $eventDispatcher, KillSwitch $killSwitch) { 
  $this-&gt;configFactory = $config_factory; 
  $this-&gt;eventDispatcher = $eventDispatcher; 
  $this-&gt;killSwitch = $killSwitch; 
}  </pre>
<p>And the appropriate <em>use</em> statement at the top:</p>
<pre>use Drupal\Core\PageCache\ResponsePolicy\KillSwitch;  </pre>
<p>And at the beginning of both the <kbd>getSalutation()</kbd> and <kbd>getSalutationComponent()</kbd> methods, we simply have to add this line:</p>
<pre>$this-&gt;killSwitch-&gt;trigger();  </pre>
<p>This will tell Drupal's internal page cache to never cache this page. But before we go running the test again, we mustn't forget to add the <kbd>page_cache_kill_switch</kbd> service as a dependency to the <kbd>HelloWorldSalutation</kbd> service inside <kbd>hello_world.services.yml</kbd>. And now if we run this test, we should get a green result.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hello World form test</h1>
                </header>
            
            <article>
                
<p>The second Functional test we will write should test the salutation override form itself. In the previous one, we interacted with the configuration API directly to make changes to the configuration value. Now we will see whether the form to do so actually works. But since we can reuse quite a lot from the previous test, and they are very closely related, we can add it to the same class:</p>
<pre>/** 
 * Tests that the configuration form for overriding the message works. 
 */ 
public function testForm() { 
  $expected = $this-&gt;assertDefaultSalutation(); 
  $this-&gt;drupalGet('/admin/config/salutation-configuration'); 
  $this-&gt;assertSession()-&gt;statusCodeEquals(403); 
  $account = $this-&gt;drupalCreateUser(['administer site configuration']); 
  $this-&gt;drupalLogin($account); 
  $this-&gt;drupalGet('/admin/config/salutation-configuration'); 
  $this-&gt;assertSession()-&gt;statusCodeEquals(200); 
  $this-&gt;assertSession()-&gt;pageTextContains('Salutation configuration'); 
  $this-&gt;assertSession()-&gt;elementExists('css', '#edit-salutation'); 
 
  $edit = [ 
    'salutation' =&gt; 'My custom salutation', 
  ]; 
 
  $this-&gt;drupalPostForm(NULL, $edit, 'op'); 
  $this-&gt;assertSession()-&gt;pageTextContains('The configuration options have been saved'); 
  $this-&gt;drupalGet('/hello'); 
  $this-&gt;assertSession()-&gt;pageTextNotContains($expected); 
  $this-&gt;assertSession()-&gt;pageTextContains('My custom salutation'); 
}  </pre>
<p>We start this test in the same way, asserting that the hour dependent message is shown. This also proves that each test runs in its own independent environment and changes to the configuration in one test has no impact on the other. They all start with a blank slate.</p>
<p>Then we navigate to the configuration form page and assert that we do not have access. For this, we use the <kbd>statusCodeEquals()</kbd> assertion method to check the response code. This is good because we need to be logged in with a user that has a certain permission.</p>
<div class="packt_tip">The access restrictions on the configuration form allow any user that has a certain permission. For this reason, our test should focus on that permission rather than something else that may indirectly include this permission. For example, it should not assume that a user with the administrator role has that permission.</div>
<p>So we create a new user account using the handy <kbd>drupalCreateUser()</kbd> method whose first parameter is an array of permissions the user should have. We can then use the resulting User entity with the <kbd>drupalLogin()</kbd> method to log in. Under the hood, this navigates to the user login page, submits the form and then asserts that everything went well. Now we can go back to the configuration form page and should have access— something that we also assert. In addition, we assert that we have the page title and that we have the salutation text field HTML element on the page. We do so using the <kbd>elementExists()</kbd> method, using the CSS selector locator as we had done in the previous test. Again, check out <kbd>WebAssert</kbd> for all sorts of assertion methods that help you identify things on the page.</p>
<p>Now it's time to submit the form and override the salutation message. And we do this with <kbd>drupalPostForm()</kbd>, whose most important parameter is an array of values to fill in the form elements, keyed by the <kbd>name</kbd> parameter of the individual form HTML element. In our case, we only have one. Do check out the documentation of this method for more information on all the things you can do with it. Once the form is submitted, the page will reload and we can assert the presence of the confirmation message. And finally, we can go back to the <kbd>/hello</kbd> path and assert that the old message is no longer showing but the new overridden one does so instead.</p>
<p>Running the test class again should now include this new test as well and everything should be green. And noticeably much slower as two full Drupal installations are done. In the next section, we'll bring JavaScript into the picture so that we can also test the more dynamic browser integrations. But already you can notice that Kernel tests are much faster to run if you don't need to interact with a browser.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functional JavaScript tests</h1>
                </header>
            
            <article>
                
<p>The last type of tests we can write in Drupal 8 is the JavaScript-powered functional test. FunctionalJavascript tests are useful when we want to test more dynamic client-side functionality such as JavaScript behaviors or Ajax interactions.</p>
<p>They are an extension of the regular Functional tests, but which use WebDriver. The latter is an API that allows things like Selenium to control browsers such as Chrome or Firefox. Drupal uses Chrome for this so make sure you have Selenium installed and working with the Chrome driver. We won't cover this here because it depends on your local environment and the current latest versions.</p>
<p>Assuming you have Selenium running, we can write some tests. But only after we add another environment variable to the PHPUnit configuration file:</p>
<pre>&lt;env name="MINK_DRIVER_ARGS_WEBDRIVER" value='["chrome", null, "http://localhost:4444/wd/hub"]'/&gt; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Time test</h1>
                </header>
            
            <article>
                
<p>If you remember from <a href="ca6e92fc-24fa-41b4-bd57-c3884f9d16b1.xhtml">Chapter 12</a>, <em>JavaScript and Ajax API</em>, we added to our Hello World salutation component a little time widget that displays the current hour in real time if the salutation is not overridden. This component is powered by JavaScript, and more importantly, appended to the page using JavaScript.</p>
<p>Moreover, in the previous section, we wrote a Functional test for the Hello World page in which we asserted the presence of the salutation message. However, the actual time widget would never show up there because the Mink driver used in these types of tests do not support JavaScript. So if we want to test that, we need to write a FunctionalJavascript test.</p>
<p>As expected, these types of tests follow the same patterns for the directory placement and namespaces. So our first test class can start like this:</p>
<pre>namespace Drupal\Tests\hello_world\FunctionalJavascript; 
 
use Drupal\FunctionalJavascriptTests\WebDriverTestBase; 
 
/** 
 * Testing the simple Javascript timer on the Hello World page. 
 * 
 * @group hello_world 
 */ 
class TimeTest extends WebDriverTestBase {}  </pre>
<p>By now most of the above code should be clear. However, the base class we extend this time is the <kbd>WebDriverTestBase</kbd> class, which itself is a child of <kbd>BrowserTestBase</kbd>. Interestingly, it doesn't actually add much to the mix apart from configuring the test to use Selenium Web Driver and adding a few JavaScript specific helper methods. This is to demonstrate that most of the difference between Functional and FunctionalJavascript tests is given by the actual Mink driver.</p>
<div class="packt_infobox">Be aware that until Drupal 8.1, the default driver for JavaScript tests was Phantom.js so you may find deprecated references to this. We are staying ahead of the curve though and using the latest Web Driver API with Selenium and Chrome to run our tests.</div>
<p>One extremely handy addition, though, is the ability to take screenshots. Many times when testing frontend interactions, things don't go as we thought and we don't understand why. The parent <kbd>createScreenshot()</kbd> method allows us to save a full page screenshot at any given moment, that we can investigate for debugging purposes. All we have to do is pass in the name of the file we want to be saved. So do check that out.</p>
<p>Moving on with our test, let's add the modules we want to be enabled:</p>
<pre>/** 
 * Modules to enable. 
 * 
 * @var array 
 */ 
protected static $modules = ['hello_world']; </pre>
<p>As expected, the <kbd>Hello World</kbd> module is enough. And the very simple test method can look like this:</p>
<pre>/** 
 * Tests the time component. 
 */ 
public function testTime() { 
  $this-&gt;drupalGet('/hello'); 
  $this-&gt;assertSession()-&gt;pageTextContains('The time is'); 
 
  $config = $this-&gt;config('hello_world.custom_salutation'); 
  $config-&gt;set('salutation', 'Testing salutation'); 
  $config-&gt;save(); 
 
  $this-&gt;drupalGet('/hello'); 
  $this-&gt;assertSession()-&gt;pageTextNotContains('The time is'); 
}  </pre>
<p>We are using the exact same assertion techniques as before, but because JavaScript is enabled, the time widget text should show up now. And like before, we also test that if the salutation method is overridden, the time widget does not show up.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CsvImporter test</h1>
                </header>
            
            <article>
                
<p>When learning about Kernel tests, we wrote a test for the <kbd>CsvImporter</kbd> that focused on the importing functionality given an existing Importer configuration entity (which we created programmatically). However, another important angle of this functionality is the process of creating this configuration entity as we are relying on Ajax to dynamically inject form elements related to the selected Importer plugin. So let's write a test for that as well.</p>
<p>Just as before, the test class can start with something like this:</p>
<pre>namespace Drupal\Tests\products\FunctionalJavascript; 
 
use Drupal\FunctionalJavascriptTests\WebDriverTestBase; 
 
/** 
 * Testing the creation/edit of Importer configuration entities using the CSV importer 
 * 
 * @group products 
 */ 
class ImporterFormTest extends WebDriverTestBase {}  </pre>
<p>And like always, let's enable some modules:</p>
<pre>/** 
 * Modules to enable. 
 * 
 * @var array 
 */ 
protected static $modules = ['image', 'file', 'node']; </pre>
<p>You may be wondering why, for example, the <kbd>products</kbd> module is not in that list. At the time of writing, it did not work, as a dependency-related error was being thrown when enabling it (missing plugin defined by the <kbd>image</kbd> module). So instead, we can also enable modules directly in our test or <kbd>setUp()</kbd> methods. And that is exactly what we will do.</p>
<div class="packt_infobox">The node module is enabled because it defines the <kbd>access content</kbd> permission which is used by the core <kbd>machine_name</kbd> form element. And this element is used on the Importer entity form so we'll need it in order for the tests to actually work.</div>
<p>Even though we only write one test method, there is quite a bit of preparation for it that we might want to reuse elsewhere. Plus, it also looks cleaner to be separated from the actual test method. So we can add it to the <kbd>setUp()</kbd> method instead:</p>
<pre>/** 
 * {@inheritdoc} 
 */ 
public function setUp() { 
  parent::setUp(); 
  $this-&gt;container-&gt;get('module_installer')-&gt;install(['products', 'csv_importer_test']); 
  $csv_path = drupal_get_path('module', 'csv_importer_test') . '/products.csv'; 
  $csv_contents = file_get_contents($csv_path); 
  $this-&gt;file = file_save_data($csv_contents, 'public://simpletest-products.csv', FileSystemInterface::EXISTS_REPLACE); 
  $this-&gt;admin = $this-&gt;drupalCreateUser(['administer site configuration']); 
  $this-&gt;bundle = ProductType::create(['id' =&gt; 'goods', 'label' =&gt; 'Goods']); 
  $this-&gt;bundle-&gt;save(); 
}  </pre>
<p>And the new <em>use</em> statement:</p>
<pre>use Drupal\products\Entity\ProductType; 
use Drupal\Core\File\FileSystemInterface;  </pre>
<p>As expected, the first thing we do is install the <kbd>products</kbd> and <kbd>csv_importer_test</kbd> modules. We use the <kbd>ModuleInstaller</kbd> service for that. Then, we do the same thing as we did in the previous test—load the test CSV file from the <kbd>csv_importer_test</kbd> module and "upload" it to Drupal creating a new managed File entity.</p>
<p>Then, we create an administrator user account that has the permission needed for creating Importer configuration entities, as well as a bundle for the Product entity so that we can actually create products. We didn't need to worry about the bundle in the previous test because we created the Importer configuration programmatically. But now, through the UI, a bundle needs to exist in order to select it.</p>
<p>The resulting File entity, admin user account and ProductType configuration entity we store on class properties so we should also define those:</p>
<pre>/** 
 * @var \Drupal\file\FileInterface 
 */ 
protected $file; 
 
/** 
 * @var \Drupal\Core\Session\AccountInterface 
 */ 
protected $admin; 
 
/** 
 * @var \Drupal\products\Entity\ProductType 
 */ 
protected $bundle; </pre>
<p>And with this we are ready to write our empty test method and start filling it up step by step:</p>
<pre>/** 
 * Tests the importer form. 
 */ 
public function testForm() {} </pre>
<p>We can start with the basics:</p>
<pre>$this-&gt;drupalGet('/admin/structure/importer/add'); 
$assert = $this-&gt;assertSession(); 
$assert-&gt;pageTextContains('Access denied'); </pre>
<p>We navigate to the form for creating importer configuration entities and assert that the user does not have access. This is because by default we are browsing as anonymous users. Next, we need to log in and try this again:</p>
<pre>$this-&gt;drupalLogin($this-&gt;admin); 
$this-&gt;drupalGet('/admin/structure/importer/add'); 
$assert-&gt;pageTextContains('Add importer'); 
$assert-&gt;elementExists('css', '#edit-label'); 
$assert-&gt;elementExists('css', '#edit-plugin'); 
$assert-&gt;elementExists('css', '#edit-update-existing'); 
$assert-&gt;elementExists('css', '#edit-source'); 
$assert-&gt;elementExists('css', '#edit-bundle'); 
$assert-&gt;elementNotExists('css', 'input[name="files[plugin_configuration_plugin_file]"]'); </pre>
<p>We use the same <kbd>drupalLogin()</kbd> method and navigate back to the form. This time we assert that we have the title as well as various HTML elements—the form elements used for creating the entity. Moreover, we also assert that we do not have the element for uploading the CSV file because that should only show up if we select that we want to use the CSV Importer plugin.</p>
<p>It follows we do just that:</p>
<pre>$page = $this-&gt;getSession()-&gt;getPage(); 
$page-&gt;selectFieldOption('plugin', 'csv'); 
$this-&gt;assertSession()-&gt;assertWaitOnAjaxRequest(); 
$assert-&gt;elementExists('css', 'input[name="files[plugin_configuration_plugin_file]"]');  </pre>
<p>Using the <kbd>getSession()</kbd> method, we get the current Mink session, from which we can get the object representing the actual page we are looking at. This is a <kbd>DocumentElement</kbd> object which can be traversed, inspected and manipulated in all sorts of ways. I recommend you check out the <kbd>TraversableElement</kbd> class for all the available methods.</p>
<p>One such method is <kbd>selectFieldOption()</kbd> by which we can specify the locator of an HTML select element (ID, name or label) and a value, and it will trigger the selection. As you know, this is supposed to make an Ajax request bringing in our new form elements. And using <kbd>assertWaitOnAjaxRequest()</kbd> on the <kbd>JSWebAssert</kbd> object, we can wait until that is complete. Finally, we can assert that the file upload field is present on the page.</p>
<p>Next, we proceed with filling in the form:</p>
<pre>$page-&gt;fillField('label', 'Test CSV Importer'); 
$this-&gt;assertJsCondition('jQuery(".machine-name-value").html() == "test_csv_importer"'); 
$page-&gt;checkField('update_existing'); 
$page-&gt;fillField('source', 'testing'); 
$page-&gt;fillField('bundle', $this-&gt;bundle-&gt;id()); 
$wrapper = $this-&gt;container-&gt;get('stream_wrapper_manager')-&gt;getViaUri($this-&gt;file-&gt;getFileUri()); 
$page-&gt;attachFileToField('files[plugin_configuration_plugin_file]', $wrapper-&gt;realpath()); 
$this-&gt;assertSession()-&gt;assertWaitOnAjaxRequest(); 
$page-&gt;pressButton('Save'); 
$assert-&gt;pageTextContains('Created the Test CSV Importer Importer.'); </pre>
<p>The generic <kbd>fillField()</kbd> method is useful for things like text fields while the <kbd>checkField()</kbd> method is expectedly useful for checkboxes. The locator for both is again either the ID, the name or the label of the element.</p>
<p>We also use the <kbd>assertJsCondition</kbd> method to have the execution wait until a JavaScript change has happened on the page. And we do this to ensure that the entity machine name field has been currently filled in.</p>
<p>Next, with the help of the stream wrapper of the file that we uploaded, and more specifically its <kbd>realpath()</kbd> method, we attach the file to the field using the <kbd>attachFileToField()</kbd> method. This triggers an Ajax request, which again we wait for to complete. Lastly, we use the <kbd>pressButton()</kbd> method to click on the submit button and then assert that we have a confirmation message printed out (the form has been saved and the page refreshed).</p>
<p>Now to check that the operation actually went through properly:</p>
<pre>$config = Importer::load('test_csv_importer'); 
$this-&gt;assertInstanceOf('Drupal\products\Entity\ImporterInterface', $config); 
 
$fids = $config-&gt;getPluginConfiguration()['file']; 
$fid = reset($fids); 
$file = File::load($fid); 
$this-&gt;assertInstanceOf('Drupal\file\FileInterface', $file);  </pre>
<p>And the new <em>use</em> statements:</p>
<pre>use Drupal\file\Entity\File; 
use Drupal\products\Entity\Importer;  </pre>
<p>We load the configuration entity using the ID we gave it and then assert that the resulting object is an instance of the correct interface. This checks we actually did save the entity. Next, we load the File entity based on the ID found in the Importer configuration entity and assert that it itself also implements the correct interface. This proves that the file actually got saved and the configuration is correct.</p>
<p>Instead of checking the rest of the field values programmatically, in the same way, we opt for navigating to the edit form of the Importer entity and asserting that the values are pre-filled correctly:</p>
<pre>$this-&gt;drupalGet('admin/structure/importer/test_csv_importer/edit'); 
$assert-&gt;pageTextContains('Edit Test CSV Importer'); 
$assert-&gt;fieldValueEquals('label', 'Test CSV Importer'); 
$assert-&gt;fieldValueEquals('plugin', 'csv'); 
$assert-&gt;checkboxChecked('update_existing'); 
$assert-&gt;fieldValueEquals('source', 'testing'); 
$page-&gt;hasLink('products.csv'); 
$bundle_field = $this-&gt;bundle-&gt;label() . ' (' . $this-&gt;bundle-&gt;id() . ')'; 
$assert-&gt;fieldValueEquals('bundle', $bundle_field);  </pre>
<p>The <kbd>fieldValueEquals()</kbd> and <kbd>checkboxChecked()</kbd> methods are handy for checking field values. Moreover, we also use the <kbd>hasLink()</kbd> method to check whether there is a link with that name on the page. This is actually to prove the uploaded file is shown correctly:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/f24f8b1c-23ea-411e-bf80-c6db74f5fcbc.png" style="width:21.25em;height:7.42em;"/></div>
<p>And finally, since the bundle field is a reference field and not a simple text field, we need to construct the value the testing framework actually sees there and which is in this pattern: <kbd>Label (ID)</kbd>.</p>
<p>And with this, our test is complete and we can run it in its entirety:</p>
<pre>../vendor/bin/phpunit ../modules/custom/products/tests/src/Kernel/CsvImporterTest.php </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we talked a bit about automated testing in Drupal 8. We started with an introduction about why it's useful and actually important to write automated tests, and then briefly covered a few of the more popular types of software development testing methodologies.</p>
<p>Drupal 8 comes with advantages in this field over its predecessor by integrating with the PHPUnit framework for all the different types of testing it does. And there is a capability for quite a lot of methodologies as we've seen exemplified. We have unit tests—the lowest level form of testing that focuses on single architectural units and which are by far the fastest running tests of them all. Then we have Kernel tests which are integration tests focusing on lower level components and their interactions. Next, we have Functional tests which are higher level tests that focus on interactions with the browser. And finally, we have the FunctionalJavascript tests which extend on the latter and bring Selenium and Chrome into the picture to allow for the testing of functionalities that depend on JavaScript.</p>
<p>We've also seen that all these different types of tests are integrated with PHPUnit so we can run them all using this tool. This means that all the different types of tests follow the same "rules" for registering them with Drupal, namely, the directory placement, the namespacing, and the PHPDoc information.</p>
<p>The world of automated testing is huge and there can be no single chapter in a book that can cover all the different ways something can be tested. For this reason, especially for beginners, the journey towards good test coverage is full of trial and error when reading Drupal and PHPUnit code and documentation, and even has the occasional frustration. But out of this, we get stable code that works always and that is protected from regressions.</p>


            </article>

            
        </section>
    </body></html>