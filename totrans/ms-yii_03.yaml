- en: Chapter 3. Migrations, DAO, and Query Building
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。迁移、DAO 和查询构建
- en: One of the most fundamental aspects of writing modern web application is working
    with databases. Through PHP's PDO driver, Yii2, can work with many different kinds
    of relational databases. In this chapter, we'll cover how to connect to different
    databases, write database migrations to instantiate our databases, use **database
    access objects** (**DAO**), and use Yii2's built-in Query Builder. We'll also
    cover the basics of powerful tools such as data providers and data widgets as
    well as how to use Yii2 to replicate and load balance access to our databases.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写现代 Web 应用程序的最基本方面之一是与数据库一起工作。通过 PHP 的 PDO 驱动程序，Yii2 可以与许多不同类型的关联数据库一起工作。在本章中，我们将介绍如何连接到不同的数据库，编写数据库迁移以实例化我们的数据库，使用**数据库访问对象**（**DAO**），以及使用
    Yii2 内置的查询构建器。我们还将介绍数据提供者和数据小部件等强大工具的基础知识，以及如何使用 Yii2 复制和负载均衡对数据库的访问。
- en: Connecting to databases
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'The primary component required in order to work with databases is the `yii\db\Connection`
    class. Through this class, we can connect to a variety of different database types,
    ranging from local SQLite databases to clustered MySQL databases. The simplest
    way to establish a connection to a database is to create a SQLite database connection,
    as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与数据库一起工作，所需的主要组件是 `yii\db\Connection` 类。通过这个类，我们可以连接到各种不同的数据库类型，从本地的 SQLite
    数据库到集群化的 MySQL 数据库。建立数据库连接的最简单方法就是创建一个 SQLite 数据库连接，如下所示：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Normally, however, we''ll want to use a single database connection across our
    entire application. We can keep our application *DRY* by putting our database
    configuration into the `db` component of our web or console configuration file.
    Following the examples laid out in the previous chapters, this component will
    reference the `config/env/<ENV>/db.php` file. As an example, establishing a SQLite
    connection in this file will be done as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常我们希望在应用程序的整个范围内使用单个数据库连接。我们可以通过将数据库配置放入 Web 或控制台配置文件的 `db` 组件中来使我们的应用程序保持
    *DRY*。按照前几章中的示例，此组件将引用 `config/env/<ENV>/db.php` 文件。例如，在此文件中建立 SQLite 连接将如下所示：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By storing our database configuration in the `db` component of our application,
    it can easily be shared between both our web and console applications without
    any additional effort on our part. Furthermore, since Yii2 loads components only
    when required, it can keep our application lean and performant.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的数据库配置存储在我们的应用程序的 `db` 组件中，它可以很容易地在我们的 Web 和控制台应用程序之间共享，而无需我们做任何额外的工作。此外，由于
    Yii2 仅在需要时加载组件，它可以保持我们的应用程序精简且性能良好。
- en: Tip
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In Yii2, components are only loaded when required. This process is often called
    **lazy loading**. Unless a component is preloaded, Yii2 will not create an instance
    of that component until it is first used. After being initially instantiated,
    Yii will then reuse the same component across your application rather than creating
    multiple instances of that component. Lazy loading is one of the primary reasons
    Yii is so performant.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Yii2 中，组件仅在需要时才会被加载。这个过程通常被称为**延迟加载**。除非组件被预先加载，否则 Yii2 不会在首次使用之前创建该组件的实例。一旦被初始化，Yii
    将在整个应用程序中重用相同的组件，而不是创建该组件的多个实例。延迟加载是 Yii 性能出色的主要原因之一。
- en: 'With our database configuration stored within our configuration file, we can
    now access the database connection, as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的数据库配置存储在我们的配置文件中后，我们现在可以访问数据库连接，如下所示：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This connection will also be shared to any Active Record models used in our
    application, which we'll discuss in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此连接也将共享到我们应用程序中使用的任何 Active Record 模型，我们将在[第 4 章](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "第 4 章。Active Record，模型和表单")*Active Record，模型和表单*中讨论。
- en: 'As stated earlier, Yii2 can connect to several different database types. As
    Yii2 binds on top of PHP''s PDO library, it can connect to the same sources a
    native PDO driver can connect to. A few examples of the **data source names**
    (**DSNs**) that Yii2 supports are listed here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Yii2 可以连接到多种不同的数据库类型。因为 Yii2 是基于 PHP 的 PDO 库构建的，所以它可以连接到原生 PDO 驱动程序可以连接到的相同来源。以下是
    Yii2 支持的一些**数据源名称**（**DSN**）的示例：
- en: '| Database Type | DSN Scheme |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 数据库类型 | DSN 方案 |'
- en: '| --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| MySQL, Percona, MariaDB, and so on | `mysql:host=localhost;dbname=mydatabase`
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| MySQL、Percona、MariaDB 等等 | `mysql:host=localhost;dbname=mydatabase` |'
- en: '| SQLite | `sqlite:/path/to/database/file.sqlite` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| SQLite | `sqlite:/path/to/database/file.sqlite` |'
- en: '| PostgreSQL | `pgsql:host=localhost;port=5432;dbname=mydatabase` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| PostgreSQL | `pgsql:host=localhost;port=5432;dbname=mydatabase` |'
- en: '| CUBRID | `cubrid:dbname=demodb;host=localhost;port=33000` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| CUBRID | `cubrid:dbname=demodb;host=localhost;port=33000` |'
- en: '| MS SQL Server (via the sqlsrv driver) | `sqlsrv:Server=localhost;Database=mydatabase`
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| MS SQL Server (via the sqlsrv driver) | `sqlsrv:Server=localhost;Database=mydatabase`
    |'
- en: '| MS SQL Server (via the dblib driver) | `dblib:host=localhost;dbname=mydatabase`
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| MS SQL Server (via the dblib driver) | `dblib:host=localhost;dbname=mydatabase`
    |'
- en: '| MS SQL Server (via the mssql driver) | `mssql:host=localhost;dbname=mydatabase`
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| MS SQL Server (via the mssql driver) | `mssql:host=localhost;dbname=mydatabase`
    |'
- en: '| Oracle | `oci:dbname=//localhost:1521/mydatabase` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| Oracle | `oci:dbname=//localhost:1521/mydatabase` |'
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you're connecting to a MS SQL server, you'll need to have either the sqlsrv,
    dblib or mssql PHP drivers installed on your system. More information on these
    base drivers can be found within the PHP manual at [https://php.net/manual/en/pdo.drivers.php](https://php.net/manual/en/pdo.drivers.php).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在连接到 MS SQL 服务器，你需要在你的系统上安装 sqlsrv、dblib 或 mssql PHP 驱动程序。有关这些基础驱动程序的更多信息可以在
    PHP 手册中找到，链接为 [https://php.net/manual/en/pdo.drivers.php](https://php.net/manual/en/pdo.drivers.php)。
- en: Additionally, Oracle connections will require the installation of Oracle's OCI8
    driver. More information on this driver can be found in the PHP manual at [https://php.net/manual/en/book.oci8.php](https://php.net/manual/en/book.oci8.php).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Oracle 连接将需要安装 Oracle 的 OCI8 驱动程序。有关此驱动程序的更多信息可以在 PHP 手册中找到，链接为 [https://php.net/manual/en/book.oci8.php](https://php.net/manual/en/book.oci8.php)。
- en: Note that Yii2 will not be able to connect to any database unless the appropriate
    PHP drivers are properly installed and configured. If you aren't certain which
    drivers you have installed, the native `phpinfo()` function can output a list
    of all the currently installed PHP extensions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除非适当的 PHP 驱动程序已正确安装和配置，否则 Yii2 将无法连接到任何数据库。如果你不确定已安装了哪些驱动程序，原生的 `phpinfo()`
    函数可以输出所有当前已安装的 PHP 扩展列表。
- en: 'In addition to the base drivers listed earlier, Yii2 can also connect to databases
    over **Open Database Connectivity** (**ODBC**). When connecting to a database
    via ODBC, you''ll need to specify the `$driverName` property within your `db`
    connection component so that Yii2 can properly connect to your database:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面列出的基础驱动程序之外，Yii2 还可以连接到通过 **开放数据库连接**（**ODBC**）的数据库。当你通过 ODBC 连接到数据库时，你需要在你的
    `db` 连接组件中指定 `$driverName` 属性，以便 Yii2 能够正确连接到你的数据库：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As shown previously, some database configurations may require you to specify
    a username or password to connect to them. Within the `db` component, simply specify
    the `username` and `password` attributes that are appropriate for your database.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，某些数据库配置可能需要你指定用户名或密码才能连接到它们。在 `db` 组件中，只需指定适合你数据库的 `username` 和 `password`
    属性。
- en: Additional configuration options
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外的配置选项
- en: In addition to the basic `db` component options listed previously, Yii2 also
    provides several additional options that can be used to either enhance the performance
    of your application or deal with a known issue within the native PHP drivers.
    While many of these options can be found in the Yii guide and the API documentation,
    some of them will most likely be used more often than others. These properties
    are `$emulatePrepare`, `$enableQueryCache`, and `$enableSchemaCache`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面列出的基本 `db` 组件选项之外，Yii2 还提供了几个额外的选项，这些选项可以用来提高你应用程序的性能或解决原生 PHP 驱动程序中的已知问题。虽然许多这些选项可以在
    Yii 指南和 API 文档中找到，但其中一些可能会比其他选项更频繁地使用。这些属性是 `$emulatePrepare`、`$enableQueryCache`
    和 `$enableSchemaCache`。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A complete list of the available methods and properties for the `yii\db\Connection`
    class can be found at [http://www.yiiframework.com/doc-2.0/yii-db-connection.html](http://www.yiiframework.com/doc-2.0/yii-db-connection.html).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`yii\db\Connection` 类的所有可用方法和属性的完整列表可以在 [http://www.yiiframework.com/doc-2.0/yii-db-connection.html](http://www.yiiframework.com/doc-2.0/yii-db-connection.html)
    找到。'
- en: The first common attribute, `$emulatePrepare`, can be used to alleviate common
    issues identified by the Yii team when preparing database statements. By default,
    Yii2 will try to use the native prepare support built into the native PDO driver.
    To help alleviate issues with a few of the native PDO drivers (mainly, the MS
    SQL drivers), the `$emulatePrepare` attribute may need to be set to `true` in
    order to allow Yii2 to handle the prepare statements.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个常见的属性`$emulatePrepare`可以用来减轻Yii团队在准备数据库语句时发现的一些常见问题。默认情况下，Yii2将尝试使用内置在原生PDO驱动程序中的原生准备支持。为了帮助减轻与一些原生PDO驱动程序（主要是MS
    SQL驱动程序）的问题，可能需要将`$emulatePrepare`属性设置为`true`，以便允许Yii2处理准备语句。
- en: The next common property often enabled in our `db` component is `$enableQueryCache`.
    To improve the performance of our application, we can set this value to `true`
    and allow Yii to cache commonly executed queries. In an application that mostly
    performs read actions, enabling this attribute can greatly increase the performance
    of your application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`db`组件中通常启用的下一个常见属性是`$enableQueryCache`。为了提高应用程序的性能，我们可以将其设置为`true`，并允许Yii缓存常用查询。在一个主要执行读取操作的应用程序中，启用此属性可以显著提高应用程序的性能。
- en: 'To completely enable this component, however, the additional properties we''ll
    mention now must be set as well. The first property, `$queryCache`, specifies
    the named cache object that the query cache should use. If unset, this will simply
    default to the cache component in our application. The second property is `$queryCacheDuration`,
    and it determines how long any database query result will be cached for. By default,
    the query cache will be valid for 3,600 seconds, or 60 minutes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要完全启用此组件，我们现在将提到的附加属性也必须设置。第一个属性是`$queryCache`，它指定查询缓存应使用的命名缓存对象。如果未设置，则默认为应用程序中的缓存组件。第二个属性是`$queryCacheDuration`，它决定了任何数据库查询结果将被缓存多长时间。默认情况下，查询缓存将有效期为3,600秒，即60分钟：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The final common property that often will be added to our `db` component is
    `$enableSchemaCache`. Before Yii accesses the database, it will often need to
    determine the database schema. This schema information is used to assist Yii when
    running validators and working with relational models, such as related Active
    Record models. Rather than having Yii try to determine our database schema on
    every request, we can tell it that our schema isn't changing by setting `$enableSchemaCache`
    to `true`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个常见的属性，通常会被添加到我们的`db`组件中是`$enableSchemaCache`。在Yii访问数据库之前，它通常需要确定数据库模式。此模式信息用于帮助Yii在运行验证器和处理关系模型（如相关Active
    Record模型）时。我们不必让Yii在每次请求时都尝试确定我们的数据库模式，我们可以通过将`$enableSchemaCache`设置为`true`来告诉它我们的模式不会改变。
- en: 'Similar to the `$enableCache` parameter outlined previously, we''ll also need
    to define the `$schemaCache` parameter, which will tell Yii what cache component
    to use. We''ll also need to define the `$schemaCacheDuration` parameter so that
    Yii2 knows how long the schema cache is valid for in seconds:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前概述的`$enableCache`参数类似，我们还需要定义`$schemaCache`参数，这将告诉Yii使用哪个缓存组件。我们还需要定义`$schemaCacheDuration`参数，以便Yii2知道模式缓存在秒内有效的时间：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As the majority of our controller actions will most likely result in a database
    operation, enabling these properties can greatly improve the performance of our
    application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的大多数控制器操作很可能会导致数据库操作，启用这些属性可以大大提高应用程序的性能。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that because `$enableSchemaCache` and `$enableQueryCache` are enabled,
    Yii2 will not perform common checks against the database. Any change to the underlying
    data or schema in your database may cause your application to return bad data
    or crash entirely. If you change the data in your database directly rather than
    through Yii2, or if you change the database schema, ensure that you flush the
    relevant cache components defined by `$enableSchemaCache` or `$enableQueryCache`
    to ensure that your application functions correctly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，因为`$enableSchemaCache`和`$enableQueryCache`已被启用，Yii2将不会对数据库执行常见检查。您数据库中底层数据或模式的任何更改都可能使您的应用程序返回错误数据或完全崩溃。如果您直接更改数据库中的数据而不是通过Yii2，或者更改数据库模式，请确保刷新由`$enableSchemaCache`或`$enableQueryCache`定义的相关缓存组件，以确保您的应用程序正常运行。
- en: Writing database migrations
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写数据库迁移
- en: When building and maintaining modern web applications, the underlying structure
    of our database may need to change to account for changes in requirements or scopes.
    To ensure that our database schema can evolve in tandem with our source code,
    Yii2 provides built-in support to manage database migrations. Using database migrations,
    we can treat our database as an extension of the source code and easily change
    it when our source code changes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建和维护现代网络应用程序时，我们数据库的底层结构可能需要根据需求或范围的变化而改变。为了确保我们的数据库模式可以与源代码同步发展，Yii2 提供了内置支持来管理数据库迁移。使用数据库迁移，我们可以将数据库视为源代码的扩展，并在源代码更改时轻松地对其进行更改。
- en: An overview of schema
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述模式
- en: When working with database migrations, we'll often be working with the `yii\db\Schema`
    class. When paired properly, we can often write our migrations in a way that enables
    them to be run across a variety of database types. For example, when working locally,
    we might need to use a local SQLite database even if our application will ultimately
    run on a MySQL database.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当与数据库迁移一起工作时，我们通常会使用 `yii\db\Schema` 类。当正确配对时，我们通常可以编写迁移，以便它们能够在各种数据库类型上运行。例如，当本地工作时，我们可能需要使用本地
    SQLite 数据库，即使我们的应用程序最终将在 MySQL 数据库上运行。
- en: At the heart of this class is a variety of different schema types that Yii2
    will be able to properly map to the appropriate data type within our database.
    These include data types such as `INT`, `DATETIME`, and `TEXT`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的核心是多种不同的模式类型，Yii2 将能够正确地将它们映射到我们数据库中的适当数据类型。这些包括 `INT`、`DATETIME` 和 `TEXT`
    等数据类型。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For a complete list of the available constants made available by the Schema
    class, ensure that you refer to the Yii2 guide at [http://www.yiiframework.com/doc-2.0/yii-db-schema.html#constants](http://www.yiiframework.com/doc-2.0/yii-db-schema.html#constants).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 Schema 类提供的所有可用常量的完整列表，请确保您参考 Yii2 指南 [http://www.yiiframework.com/doc-2.0/yii-db-schema.html#constants](http://www.yiiframework.com/doc-2.0/yii-db-schema.html#constants)。
- en: 'Within our migrations, we can call any of these constants by running this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的迁移中，我们可以通过运行以下命令来调用这些常量：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the example of an integer, we can use this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在整数的示例中，我们可以使用以下内容：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using these constants in our migration, we can ensure that our migrations map
    to the appropriate data type within our database and work across a variety of
    database types.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的迁移中使用这些常量，我们可以确保我们的迁移映射到数据库中的适当数据类型，并在各种数据库类型上工作。
- en: Writing migrations
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写迁移
- en: 'As shown in the previous chapter, we can create a new migration by invoking
    the `migrate/create` command from the `yii` command-line tool. Using the source
    code from the previous chapter as a starting point, we''ll do this by running
    the following from the command line:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所示，我们可以通过从 `yii` 命令行工具调用 `migrate/create` 命令来创建一个新的迁移。以前一章的源代码作为起点，我们将在命令行中运行以下操作：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Writing migrations](img/00008.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![编写迁移](img/00008.jpeg)'
- en: Running this command will create a new migration in the `migrations` folder
    of our application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将在我们应用程序的 `migrations` 文件夹中创建一个新的迁移。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Depending upon the file permissions on your system, Yii2 may not be able to
    create the `migrations` folder if it does not exist. If the `migrations` folder
    doesn't exist yet, ensure that you create it before running the `migrate/create`
    command.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您系统的文件权限，如果 `migrations` 文件夹不存在，Yii2 可能无法创建它。如果 `migrations` 文件夹尚未存在，请在运行
    `migrate/create` 命令之前确保创建它。
- en: When running migrations, Yii2 will execute them in the order in which they were
    created. To determine this order, Yii2 will look at the filename or the migration
    that contains the name of the migration specified from the `migrate/create` command
    as well as the exact timestamp the migration was created at.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行迁移时，Yii2 将按照它们创建的顺序执行它们。为了确定这个顺序，Yii2 将查看文件名或包含从 `migrate/create` 命令指定的迁移名称以及迁移创建的确切时间的迁移。
- en: In our case, the filename is `m150523_194158_init.php`, which means that this
    migration was created on May 23, 2015 at 7:41:58 PM UTC.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，文件名是 `m150523_194158_init.php`，这意味着这个迁移是在 2015 年 5 月 23 日晚上 7:41:58
    UTC 创建的。
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Because of this naming convention, any migration that you create will have a
    distinct and unique filename. If you're following along, ensure that you're working
    in the file that was created from the `./yii` command.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种命名约定，你创建的任何迁移都将具有独特且唯一的文件名。如果你正在跟随教程，请确保你在由 `./yii` 命令创建的文件中工作。
- en: 'After running the `migrate/create` command, Yii2 provides us with a skeleton
    migration that will look similar to the following code block:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`migrate/create`命令后，Yii2为我们提供了一个类似以下代码块的骨架迁移：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Migrations in Yii2 can operate in one of these two ways: we can either bring
    a migration up, or we can bring it down. These two operations correspond to one
    of four functions: `up()`, `safeUp()`, `down()`, and `safeDown()`. The `up()`
    and `down()` methods are the base methods required to run migrations and will
    execute any database command issued inside them even if there is an error. Alternatively,
    we can use the `safeUp()` and `safeDown()` methods, which are functionally identical
    to the `up()` and `down()` methods, with the exception that the entire operation
    is wrapped within a transaction. If our database supports transactions, running
    our migrations from the safe methods can help us catch migration errors at runtime
    before an error can cause problems with our entire database.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yii2中，迁移可以以两种方式操作：我们可以将迁移提升，或者将其降级。这两个操作对应于四个函数之一：`up()`、`safeUp()`、`down()`和`safeDown()`。`up()`和`down()`方法是运行迁移所需的基本方法，即使有错误，也会执行它们内部发出的任何数据库命令。或者，我们可以使用`safeUp()`和`safeDown()`方法，这两个方法在功能上与`up()`和`down()`方法相同，唯一的区别是整个操作都被包裹在一个事务中。如果我们的数据库支持事务，使用安全方法运行迁移可以帮助我们在错误导致整个数据库出现问题之前在运行时捕获迁移错误。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Because of the additional safety they offer, `safeUp()` and `safeDown()` should
    be our go-to methods when writing migrations. Additionally, if `safeUp()` or `safeDown()`
    are used, the unsafe methods cannot be used.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们提供的额外安全性，`safeUp()`和`safeDown()`应该是我们编写迁移时的首选方法。此外，如果使用了`safeUp()`或`safeDown()`，则不能使用不安全的方法。
- en: 'Let''s start by adding a simple table to our database in order to store our
    users. We''ll start by simply storing an ID, an email address, a password, the
    username, and some timestamp metadata indicating when our user was created and
    last updated. Within our migration, we can write this as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向我们的数据库添加一个简单的表开始，以便存储我们的用户信息。我们将从简单地存储一个ID、电子邮件地址、密码、用户名以及一些时间戳元数据开始，这些元数据表示我们的用户何时被创建以及最后更新。在我们的迁移中，我们可以这样写：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As illustrated previously, Yii2 supports two different ways to declare schema
    types for columns. We can either directly use the constants defined by the `Schema`
    class, or we can use the native migration methods, such as `primaryKey()`, `integer()`,
    `string()`, and `text()`. Using the migration methods is preferred because it
    permits us to add additional attributes to our column, such as the column size
    and length. For a complete list of methods offered by the migration class, refer
    to the Yii2 guide at [http://www.yiiframework.com/doc-2.0/yii-db-migration.html](http://www.yiiframework.com/doc-2.0/yii-db-migration.html).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Yii2支持两种不同的方式来声明列的架构类型。我们可以直接使用由`Schema`类定义的常量，或者使用原生的迁移方法，如`primaryKey()`、`integer()`、`string()`和`text()`。使用迁移方法更受青睐，因为它允许我们向列添加额外的属性，例如列的大小和长度。有关迁移类提供的所有方法的完整列表，请参阅Yii2指南[http://www.yiiframework.com/doc-2.0/yii-db-migration.html](http://www.yiiframework.com/doc-2.0/yii-db-migration.html)。
- en: 'In the previous example, we outlined two methods: `createTable()`, which will
    create a new database table within our application, and `dropTable()`, which will
    drop the table from our database.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们概述了两种方法：`createTable()`，它将在我们的应用程序中创建一个新的数据库表，以及`dropTable()`，它将从我们的数据库中删除表。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A common convention when working with a database is to write field names with
    underscores and use singular names for table and column names. While Yii2 is smart
    enough to work with any field names you specify, following this convention will
    make your code more readable and working with your databases less complicated.
    While you don't have to explicitly follow this convention, following a convention
    can save you a lot of time in the future.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在与数据库一起工作时，一个常见的约定是使用下划线编写字段名，并为表和列名使用单数名称。虽然Yii2足够智能，可以处理你指定的任何字段名，但遵循此约定可以使你的代码更易于阅读，与数据库的交互也更简单。虽然你不必明确遵循此约定，但遵循约定可以在未来为你节省大量时间。
- en: Running migrations
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行迁移
- en: 'Running our migrations can be done through the `yii` command, as shown in the
    previous chapter:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`yii`命令运行我们的迁移，如前一章所示：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Running migrations](img/00009.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![运行迁移](img/00009.jpeg)'
- en: 'Since we''re using a SQLite database in our example, we can easily explore
    what just happened when we ran the `migrate/up` command. Using the `sqlite` command-line
    tool, we can explore our SQLite database:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在示例中使用的是 SQLite 数据库，我们可以轻松地探索运行 `migrate/up` 命令后发生了什么。使用 `sqlite` 命令行工具，我们可以探索我们的
    SQLite 数据库：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If your package manager does not provide sqlite3, you can download the binary
    executables from [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的包管理器不提供 sqlite3，您可以从 [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html)
    下载二进制可执行文件。
- en: 'By running the `.tables` command from our SQLite prompt, we can see that two
    tables were created when we ran the `migrate/up` command, `migration` and `user`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从我们的 SQLite 提示符运行 `.tables` 命令，我们可以看到在运行 `migrate/up` 命令时创建了两个表，`migration`
    和 `user`：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![Running migrations](img/00010.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![运行迁移](img/00010.jpeg)'
- en: The first table, `migration`, contains a list of all the applied migrations
    as well as the time at which they were applied.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表，`migration`，包含所有已应用迁移的列表以及它们被应用的时间。
- en: '![Running migrations](img/00011.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![运行迁移](img/00011.jpeg)'
- en: The second table, `user`, shows the resulting schema that was created by Yii
    from our migration class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个表，`user`，显示了 Yii 从我们的迁移类创建的结果模式。
- en: '![Running migrations](img/00012.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![运行迁移](img/00012.jpeg)'
- en: For instance, by specifying the `TYPE_PK` schema for our `ID` attribute, Yii2
    knew that it needed to add `AUTOINCRIMENT` and `NOT NULL` attributes to our SQLite
    schema.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过指定我们的 `ID` 属性的 `TYPE_PK` 模式，Yii2 知道它需要向我们的 SQLite 模式添加 `AUTOINCREMENT`
    和 `NOT NULL` 属性。
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: While database migrations are suited for most database changes, running them
    against large datasets may result in your database being unavailable to your application,
    resulting in downtime. Make sure that before you run a database migration through
    Yii2, your application should be able to handle temporary downtime. If even temporary
    downtime is not appropriate for your application, you may need to consider migrating
    your data to an updated schema in other ways.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数据库迁移适用于大多数数据库更改，但针对大型数据集运行它们可能会导致您的数据库对应用程序不可用，从而导致停机时间。确保在您通过 Yii2 运行数据库迁移之前，您的应用程序应该能够处理临时停机时间。如果即使是临时的停机时间也不适合您的应用程序，您可能需要考虑以其他方式将数据迁移到更新的模式。
- en: Altering a database schema
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改数据库模式
- en: When developing locally, we can simply use the `migrate/down` command to undo
    a specific migration (assuming we implemented a `down()` or `safeDown()` method).
    However, after committing and pushing our code to our DCVS system, such as Git
    or SVN, others may be using or working with our code. In this instance, we want
    to change our migrations without causing harm to their local instance; we can
    create new migrations that users of our code can apply in order to bring their
    applications up to date.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地开发时，我们可以简单地使用 `migrate/down` 命令来撤销特定的迁移（假设我们实现了 `down()` 或 `safeDown()` 方法）。然而，在我们提交并将代码推送到我们的分布式版本控制系统（DCVS）系统，如
    Git 或 SVN 之后，其他人可能会使用或与我们合作代码。在这种情况下，我们希望在不会损害他们本地实例的情况下更改我们的迁移；我们可以创建新的迁移，以便我们的代码用户可以应用这些迁移，以使他们的应用程序保持最新。
- en: 'Take, for instance, the user schema that was created for us:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们为我们创建的用户模式为例：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Rather than having a single field for our username, we may want to have two
    fields: one for their first name and one for their last name. We may also want
    to make a few changes to other fields, such as our `email` field, to prevent them
    from being `NULL`. We can do this by writing a new migration and altering the
    schema of the database itself.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是为我们的用户名设置一个单独的字段，我们可能希望有两个字段：一个用于他们的名字，另一个用于他们的姓氏。我们可能还希望对其他字段进行一些更改，例如我们的
    `email` 字段，以防止它们为 `NULL`。我们可以通过编写一个新的迁移并更改数据库本身的模式来实现这一点。
- en: 'We''ll start by creating a new migration:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个新的迁移：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember, the `--interactive=0` flag tells Yii to run our console command without
    prompts.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`--interactive=0` 标志告诉 Yii 在没有提示的情况下运行我们的控制台命令。
- en: 'Within our new `migrations/…name_change.php` migration, we can write a `safeUp()`
    method to alter these columns for us:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新 `migrations/…name_change.php` 迁移中，我们可以编写一个 `safeUp()` 方法来为我们更改这些列：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In Yii2, migration commands are self-explanatory in what they do. For instance,
    the first method, `renameColumn()`, will simply rename the `name` column to `first_name`.
    In the same vein, `addColumn()` will add a new column with the specified name
    and schema to our database, `alterColumn()` will alter the schema for the named
    column, and `createIndex()` will create a unique index on the email field in our
    database, which will ensure that no two users will share the same email address.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Yii2 中，迁移命令在执行时具有自解释性。例如，第一个方法 `renameColumn()` 将简单地将 `name` 列重命名为 `first_name`。同样，`addColumn()`
    将在数据库中添加一个具有指定名称和模式的新的列，`alterColumn()` 将修改指定列的模式，而 `createIndex()` 将在我们的数据库中的电子邮件字段上创建一个唯一索引，这将确保不会有两个用户共享相同的电子邮件地址。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A complete list of commands that can be run within the migration calls can be
    found in the Yii2 guide at [http://www.yiiframework.com/doc-2.0/yii-db-migration.html](http://www.yiiframework.com/doc-2.0/yii-db-migration.html).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 Yii2 指南 [http://www.yiiframework.com/doc-2.0/yii-db-migration.html](http://www.yiiframework.com/doc-2.0/yii-db-migration.html)
    中找到可以在迁移调用中运行的命令的完整列表。
- en: 'If we try to run these migrations against our SQLite database, however, we
    would be presented with an error similar to the following, indicating that SQLite
    doesn''t have support for these methods:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们尝试在 SQLite 数据库上运行这些迁移，我们会遇到类似于以下错误的错误，表明 SQLite 不支持这些方法：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s the output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'While the previously listed migration would work on MySQL or PostgreSQL, our
    SQLite driver doesn''t provide support for these commands. Since we''re using
    SQLite, however, we''d have to rewrite our initial migration command and notify
    users of our application about the change. For SQLite, we can rewrite our newly
    created `migrations/…name_change.php` migration as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然之前列出的迁移可以在 MySQL 或 PostgreSQL 上工作，但我们的 SQLite 驱动程序不提供对这些命令的支持。然而，由于我们使用 SQLite，因此我们必须重写我们的初始迁移命令，并通知应用程序用户关于更改的信息。对于
    SQLite，我们可以将新创建的 `migrations/…name_change.php` 迁移重写如下：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`yii\db\Migration` does not have a `query()` method that we can use to retrieve
    data. Consequently, if we need to query data within a migration, we will need
    to use Yii2''s Query Builder to do this, which we''ll cover later in this chapter.
    If our application has widespread adoption, it might be better to query for all
    of our users with Query Builder and store them temporarily in the memory (or a
    temporary store if we have a large number of records). Then, after creating our
    new table schema for our users table, we could then reinsert them into our database
    using the `insert()` method.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`yii\db\Migration` 没有我们可以用来检索数据的 `query()` 方法。因此，如果我们需要在迁移中查询数据，我们需要使用 Yii2
    的查询构建器来完成此操作，我们将在本章后面介绍。如果我们的应用程序被广泛采用，可能最好使用查询构建器查询所有用户并将它们临时存储在内存中（或者如果我们有大量记录，则存储在临时存储中）。然后，在为我们的用户表创建新的表模式之后，我们可以使用
    `insert()` 方法将它们重新插入到我们的数据库中。'
- en: 'After updating our new migration, we can rerun our migration command. Since
    our first migration was already applied, that migration will be skipped when the
    migrate/up command is executed, and only our `migrations/m150523_203944_change.php`
    migration will be run:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新了我们的新迁移之后，我们可以重新运行我们的迁移命令。由于我们的第一次迁移已经应用，当执行 `migrate/up` 命令时，该迁移将被跳过，并且只会运行我们的
    `migrations/m150523_203944_change.php` 迁移：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![Altering a database schema](img/00013.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![修改数据库模式](img/00013.jpeg)'
- en: 'After running our migration, we can query our database to see what our full
    schema looks like within SQLite:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的迁移后，我们可以查询我们的数据库以查看在 SQLite 中我们的完整模式看起来是什么样子：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![Altering a database schema](img/00014.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![修改数据库模式](img/00014.jpeg)'
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Migrations in Yii2 are extremely powerful. Take a look at the Yii2 documentation
    at [http://www.yiiframework.com/doc-2.0/yii-db-migration.html](http://www.yiiframework.com/doc-2.0/yii-db-migration.html)
    to see everything that you can do with `yii\db\Migration`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Yii2 中的迁移功能非常强大。请查看 Yii2 文档 [http://www.yiiframework.com/doc-2.0/yii-db-migration.html](http://www.yiiframework.com/doc-2.0/yii-db-migration.html)，了解您可以使用
    `yii\db\Migration` 做到的一切。
- en: Database access objects
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库访问对象
- en: Yii database access objects, commonly referred to as DAO, provide a powerful
    object-oriented API to work with a relational database. As the foundation for
    more complex database access, such as Query Builder and Active Record, DAO enables
    us to work directly with our database through SQL statements and PHP arrays. Consequently,
    it is significantly more performant to work with DAO statements than it is to
    work with either Active Record or Query Builder.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Yii 数据库访问对象，通常称为 DAO，提供了一个强大的面向对象 API，用于与关系数据库一起工作。作为更复杂数据库访问（如查询构建器和活动记录）的基础，DAO
    使我们能够通过 SQL 语句和 PHP 数组直接与数据库交互。因此，与使用活动记录或查询构建器相比，使用 DAO 语句的性能要高得多。
- en: 'At the core of DAO is our `yii\db\Connection` class, or more commonly, our
    `db` component `\Yii::$app->db`. Since our `db` component is already properly
    configured for SQLite, we''ll use it moving forward. With DAO, there are two general
    types of queries that we can run: queries that return data, such as `SELECT` queries,
    and queries that execute data, such as `DELETE` or `UPDATE`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: DAO 的核心是我们的 `yii\db\Connection` 类，或者更常见的是我们的 `db` 组件 `\Yii::$app->db`。由于我们的
    `db` 组件已经为 SQLite 正确配置，我们将继续使用它。使用 DAO，我们可以运行两种类型的查询：返回数据的查询，如 `SELECT` 查询，以及执行数据的查询，如
    `DELETE` 或 `UPDATE`。
- en: Tip
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you use the `yii\db\Connection` class directly, you'll need to explicitly
    call the `open()` method before you can run any queries against that connection.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接使用 `yii\db\Connection` 类，你需要在运行任何针对该连接的查询之前显式调用 `open()` 方法。
- en: Querying for data
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询数据
- en: 'The first way in which we can use DAO is to query for data. There are four
    main methods that are used to query for data: `queryAll()`, `queryOne()`, `queryScalar()`,
    and `queryColumn()`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 DAO 的第一种方式是查询数据。用于查询数据的主要方法有四个：`queryAll()`、`queryOne()`、`queryScalar()`
    和 `queryColumn()`。
- en: 'The first method, `queryAll()`, is used to query for all the data in a specific
    table based upon the SQL statement used within the `createCommand()` method. Using
    our user table as an example, we can query for all the users in our database by
    running the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法，`queryAll()`，用于根据 `createCommand()` 方法中使用的 SQL 语句查询特定表中的所有数据。以我们的用户表为例，我们可以通过运行以下命令来查询我们数据库中的所有用户：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After running this command, our `$users` variable will be populated with an
    array of users:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，我们的 `$users` 变量将填充一个用户数组：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The next method, `queryOne()`, is used to fetch a single record from the database.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下一种方法，`queryOne()`，用于从数据库中检索单个记录。
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `queryOne()` method returns an array of data for a single element. In the
    event that no data is found, this method will return `false`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`queryOne()` 方法返回单个元素的数据数组。如果没有找到数据，此方法将返回 `false`：'
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The third method, `queryScalar()`, is used to return the result of a `SELECT`
    query that returns a single value. For instance, if we want to count the number
    of users in our database, we can use `queryScalar()` to get the value:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法，`queryScalar()`，用于返回返回单个值的 `SELECT` 查询的结果。例如，如果我们想计算我们数据库中用户的数量，我们可以使用
    `queryScalar()` 来获取值：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After running this command, our `$count` variable will be populated with the
    number of users in our database.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，我们的 `$count` 变量将填充我们数据库中用户的数量。
- en: 'The final method, `queryColumn()`, is used to query a specific column in our
    database. For instance, if we want to know the email addresses of all the users
    in our database, we can use `queryAll()` to fetch all that data, or we can use
    `queryColumn()`, which would be significantly more efficient to use as it would
    query for less data:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种方法，`queryColumn()`，用于查询我们数据库中的特定列。例如，如果我们想了解我们数据库中所有用户的电子邮件地址，我们可以使用 `queryAll()`
    来获取所有这些数据，或者我们可以使用 `queryColumn()`，这将更高效，因为它将查询更少的数据：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Like `queryAll()`, `queryColumn()` will return an array of results:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `queryAll()` 类似，`queryColumn()` 将返回结果数组：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the event that no results are found, `queryColumn()` will return an empty
    array.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到结果，`queryColumn()` 将返回一个空数组。
- en: 'With our knowledge of these methods, as an exercise, let''s go back to our
    previous migrations and rewrite them to preserve our users across our schema change:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解这些方法之后，作为一个练习，让我们回到我们之前的迁移并将它们重写以保留我们的用户跨模式更改：
- en: 'First, let''s roll back our migrations to properly simulate the scenario:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们回滚我们的迁移以正确模拟场景：
- en: '[PRE29]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we''ll migrate our initial migration using the `migrate/to` command:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用 `migrate/to` 命令迁移我们的初始迁移：
- en: '[PRE30]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, let''s seed our database with some test data:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们用一些测试数据填充我们的数据库：
- en: '[PRE31]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If we take a look at our database, we'll see that the initial schema and data
    is now in place.![Querying for data](img/00015.jpeg)
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看我们的数据库，我们会看到初始模式和数据现在已经就绪。![查询数据](img/00015.jpeg)
- en: 'Then, let''s rewrite our `migrations/…name_change.php` migration to fetch our
    users from the database before running the initial migration that we created,
    and then reinsert our users back into our database. We''ll do this using the `queryAll()`
    DAO method to fetch the data and the `insert()` method of `yii\db\Migration` to
    put it back into the database. The new code blocks have been highlighted for easy
    viewing:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们重写我们的`migrations/…name_change.php`迁移，在运行我们创建的初始迁移之前从数据库中获取我们的用户，然后将我们的用户重新插入到数据库中。我们将使用`queryAll()`
    DAO方法来获取数据，并使用`yii\db\Migration`的`insert()`方法将其放回数据库。新的代码块已被突出显示以便于查看：
- en: '[PRE32]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now we can rerun our migration. If successful, we should see our original migration
    run and an insert call executed for each user in our database.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以重新运行我们的迁移。如果成功，我们应该看到我们的原始迁移运行，并且为数据库中的每个用户执行一个插入调用。
- en: '[PRE33]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![Querying for data](img/00016.jpeg)'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![查询数据](img/00016.jpeg)'
- en: 'Finally, we can query our SQLite database to preview the updated schema and
    see our updated users:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以查询我们的SQLite数据库以预览更新的模式并查看更新的用户：
- en: '[PRE34]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![Querying for data](img/00017.jpeg)'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![查询数据](img/00017.jpeg)'
- en: As you can see, DAO's query method provides us with the ability to quickly and
    efficiently fetch data from our database.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，DAO的查询方法为我们提供了快速有效地从数据库中获取数据的能力。
- en: Quoting table and column names
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用表和列名
- en: When writing database-agnostic SQL queries, properly quoting field names can
    be problematic. To avoid this problem, Yii2 provides the ability to automatically
    quote table and column names for you using the correct quoting rule for the specific
    database in use.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写数据库无关的SQL查询时，正确引用字段名可能会出现问题。为了避免这个问题，Yii2提供了自动为您使用特定数据库的正确引用规则来引用表和列名的功能。
- en: 'To automatically quote a column name, simply enclose the column name in square
    brackets:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要自动引用列名，只需将列名放在方括号中：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To automatically quote a table, simply enclose the table name in curly brackets:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要自动引用表，只需将表名放在花括号中：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'An example of both of these tools in action is shown as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了这两个工具在操作中的示例：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Executing queries
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行查询
- en: 'While the query methods provide the ability to select data from our database,
    we often need to execute `UPDATE` or `DELETE` commands, which do not return data.
    To execute these commands, we can use the `execute()` method in general:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然查询方法提供了从我们的数据库中选择数据的能力，但我们经常需要执行`UPDATE`或`DELETE`命令，这些命令不会返回数据。为了执行这些命令，我们通常可以使用`execute()`方法：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If successful, the `execute()` method will return with `true`, whereas if it
    fails, it will return `false`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，`execute()`方法将返回`true`，如果失败，则返回`false`。
- en: Yii2 also provides convenient wrappers for `insert()`, `update()`, and `delete()`,
    which enables us to write commands without having to write raw SQL. These methods
    properly escape and quote table and column names and bind parameters on your behalf.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Yii2还提供了`insert()`、`update()`和`delete()`的便捷包装器，这使得我们能够编写命令而无需编写原始SQL。这些方法代表您正确转义和引用表和列名以及绑定参数。
- en: 'For instance, we can insert a new user into a database as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以按照以下方式将新用户插入到数据库中：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can update all the users in our database using the `update()` method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`update()`方法更新我们数据库中的所有用户：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The last argument listed in our update command defines the `where` condition
    of our query command, which we'll cover in more detail later in the chapter. `1=1`
    is a common SQL idiom to update all records.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新命令中列出的最后一个参数定义了查询命令的`where`条件，我们将在本章后面更详细地介绍。`1=1`是一个常见的SQL成语，用于更新所有记录。
- en: 'We can also delete a user in our database using the `delete()` method:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`delete()`方法从我们的数据库中删除用户：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Additionally, if you need to insert several rows at the same time, you can
    use the `batchInsert()` method, which can be significantly more efficient than
    inserting a single row at a time:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您需要同时插入多行，可以使用`batchInsert()`方法，这比逐行插入要高效得多：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Tip
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Yii2 does not provide a `batchUpdate()` or `batchDelete()` method as bulk updates
    and deletes can be handled by the `update()` and `delete()` methods using a normal
    SQL.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Yii2没有提供`batchUpdate()`或`batchDelete()`方法，因为批量更新和删除可以通过`update()`和`delete()`方法使用常规SQL来处理。
- en: Parameter binding
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数绑定
- en: The number one rule when working with user-submitted data is to never trust
    user-submitted data. Any data that passes through our databases and has come from
    an end user needs to be validated, sanitized, and properly bound to our statements
    before they are executed against our database.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与用户提交的数据打交道时，最重要的规则是永远不要信任用户提交的数据。任何通过我们的数据库传递并来自最终用户的数据都需要在执行数据库操作之前进行验证、清理和正确绑定到我们的语句中。
- en: 'Take, for instance, the following query:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下查询为例：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Under normal circumstances, Yii would generate the following SQL, assuming
    `$_GET[''id'']` had a value of `1`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，Yii会生成以下SQL，假设`$_GET['id']`的值为`1`：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'While this is innocent enough, any user who can manipulate the `$_GET[''id'']`
    variable can rewrite our query to something much more dangerous. For instance,
    they could drop our entire user table simply by substituting `$_GET[''id'']` with
    `1; DROP TABLE user; --`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来是无害的，但任何可以操作`$_GET['id']`变量的用户都可以将我们的查询重写为更危险的内容。例如，他们可以通过将`$_GET['id']`替换为`1;
    DROP TABLE user; --`来删除我们整个用户表：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This kind of attack is called SQL injection. To help protect against SQL injection,
    Yii2 offers several different ways to bind parameters to our queries in a way
    that will filter our injected SQL. These three methods are `bindValue()`, `bindValues()`,
    and `bindParam()`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击被称为SQL注入。为了帮助防止SQL注入，Yii2提供了几种不同的方法来将参数绑定到我们的查询中，从而过滤注入的SQL。这三种方法是`bindValue()`、`bindValues()`和`bindParam()`。
- en: 'The first method, `bindValue()`, is used to bind a single parameter to a token
    within our SQL statement. For example, we can rewrite the previous query as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法，`bindValue()`，用于将单个参数绑定到我们的SQL语句中的标记上。例如，我们可以将之前的查询重写如下：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Alternatively, we can use the `bindValues()` method to bind several parameters
    into a single call:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`bindValues()`方法在单个调用中绑定多个参数：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For convenience, the previous query can be rewritten so that the parameters
    are in line with the `createCommand()` method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，可以将之前的查询重写，使参数与`createCommand()`方法一致：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The final method, `bindParam()`, is valued to bind parameters by reference
    rather than by value:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种方法，`bindParam()`，通过引用绑定参数而不是通过值绑定：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Because `bindParam()` binds parameters by reference, we can change the bounded
    values to execute multiple queries. Following the previous example, we can write
    the following to update multiple users without having to rewrite our query each
    time:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`bindParam()`通过引用绑定参数，我们可以更改绑定的值以执行多个查询。在先前的例子中，我们可以写出以下内容来更新多个用户，而无需每次都重写查询：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Tip
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember, the most important rule of working with user data is to never trust
    user-submitted data. Even in cases where you're 100% certain that SQL injection
    cannot happen, it's recommended that you use parameter binding rather than writing
    in line SQL. This will protect you against future changes to your code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，与用户数据打交道时最重要的规则是永远不要信任用户提交的数据。即使在您100%确信SQL注入不会发生的情况下，也建议您使用参数绑定而不是直接编写SQL语句。这将保护您免受未来代码更改的影响。
- en: Transactions
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务
- en: 'When running multiple queries in a sequence, we often want to ensure that our
    database state remains consistent across these queries. Most modern databases
    support the use of transactions to accomplish this. In a transaction, changes
    are written to the database in such a way that they can be committed if everything
    went well or rolled back without consequence if any given query within the transaction
    failed. In Yii2, this looks as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当连续运行多个查询时，我们通常希望确保数据库状态在这些查询之间保持一致。大多数现代数据库都支持使用事务来实现这一点。在事务中，更改以这种方式写入数据库，如果一切顺利则可以提交，如果事务中的任何给定查询失败则可以无后果地回滚。在Yii2中，这看起来如下所示：
- en: '[PRE51]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Query Builder
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询构建器
- en: Building on top of the foundations laid by DAO is Yii's Query Builder. Yii's
    Query Builder allows us to write database-agnostic queries in a programmatic way.
    Consequently, queries written through the Query Builder are significantly more
    readable than their DAO counterparts.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在DAO（数据访问对象）奠定基础之上，诞生了Yii的查询构建器。Yii的查询构建器允许我们以编程方式编写数据库无关的查询。因此，通过查询构建器编写的查询比其DAO对应物要易于阅读得多。
- en: 'The basics of Query Builder involve the creation an instance of `yii\db\Query`,
    the construction of a statement, and then the execution of that query statement.
    For example, we could simply query for all the users in our database in Query
    Builder using the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 查询构建器的基本原理包括创建 `yii\db\Query` 实例、构建语句，然后执行该查询语句。例如，我们可以在查询构建器中使用以下代码简单地查询我们数据库中的所有用户：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Tip
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When working with Query Builder, we're actually using the `yii\db\Query` class
    rather than `yii\db\QueryBuilder`. While `yii\db\QueryBuilder` can generate SQL
    statements similar to those generated by `yii\db\Query`, `yii\db\Query` enables
    these statements to be database-agnostic. In general, you'll want to work with
    `yii\db\Query` when using Query Builder.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用查询构建器时，我们实际上使用的是 `yii\db\Query` 类而不是 `yii\db\QueryBuilder`。虽然 `yii\db\QueryBuilder`
    可以生成与 `yii\db\Query` 类似的 SQL 语句，但 `yii\db\Query` 允许这些语句对数据库不可知。通常，当使用查询构建器时，你将想要使用
    `yii\db\Query`。
- en: Query construction methods
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询构建方法
- en: The basics of Query Builder involve the chaining of multiple query methods together.
    These method names directly correspond with the SQL segment that they are named
    after. When working with Query Builder, the most common methods that you'll use
    will be the `select()`, `from()`, and `where()` methods.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 查询构建器的基本原理涉及将多个查询方法链接在一起。这些方法名称直接对应于它们命名的 SQL 部分。当使用查询构建器时，你将最常使用的方法将是 `select()`、`from()`
    和 `where()` 方法。
- en: 'Moving forward, we''ll use the following variable to represent our query builder
    object:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 今后，我们将使用以下变量来表示我们的查询构建器对象：
- en: '[PRE53]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The select method
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择方法
- en: 'The `select()` method directly corresponds to the `SELECT` segment of our SQL
    query and accepts either a string of column names or an array of columns to specify
    the columns that we would want to select from our database. For instance, the
    following queries are identical:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`select()` 方法直接对应于我们的 SQL 查询的 `SELECT` 部分，接受列名字符串或列数组，以指定我们想要从数据库中选择的列。例如，以下查询是相同的：'
- en: '[PRE54]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Tip
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When using the `select()` method, the array format is generally easy to read
    and work with. If you choose to list the column names as a string, ensure that
    you do that consistently throughout your application. In the following examples,
    we'll use the array format.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `select()` 方法时，数组格式通常易于阅读和操作。如果你选择将列名作为字符串列出，确保你在整个应用程序中保持一致性。在以下示例中，我们将使用数组格式。
- en: 'The `select()` method also supports column aliases and table prefixes, as shown
    in the next example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`select()` 方法还支持列别名和表前缀，如下一个示例所示：'
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In addition to column names, the `select` method also provides support for
    expressions. For instance, if we want to retrieve the user''s complete name as
    a single field, we can execute the following query:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 除了列名外，`select` 方法还支持表达式。例如，如果我们想检索用户的完整姓名作为一个单独的字段，我们可以执行以下查询：
- en: '[PRE56]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `select` method can also be used to execute subqueries, such as `COUNT()`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`select` 方法还可以用来执行子查询，例如 `COUNT()`：'
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, the `select` statement can be chained with the `distinct()` method
    to retrieve unique records. For instance, if we want to list all the first names
    of our user''s database, we can execute the following query:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`select` 语句可以与 `distinct()` 方法链接，以检索唯一记录。例如，如果我们想列出我们用户数据库中的所有第一个名字，我们可以执行以下查询：
- en: '[PRE58]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Tip
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Omitting the `select()` method from your query will result in a `SELECT *` query
    being performed.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的查询中省略了 `select()` 方法，将执行 `SELECT *` 查询。
- en: The from method
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`from` 方法'
- en: 'Our previous examples have already illustrated the basic usage of the `from()`
    method. The `from()` method can also be used to specify a table alias, as shown
    in the following example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的示例已经展示了 `from()` 方法的基本用法。`from()` 方法也可以用来指定表别名，如下面的示例所示：
- en: '[PRE59]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Tip
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Like the `select()` method, the `from()` method can also accept strings as an
    input rather than an array. The preceding query can be rewritten as `$query->select('first_name')->from(['users
    u');`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `select()` 方法类似，`from()` 方法也可以接受字符串作为输入，而不是数组。前面的查询可以重写为 `$query->select('first_name')->from(['users
    u']);`。
- en: The where method
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`where` 方法'
- en: The `where`() method specifies the `where` segment of our SQL query and can
    be used either in a string format, hash format, or operator format.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`where()` 方法指定了我们的 SQL 查询的 `where` 部分，可以使用字符串格式、哈希格式或运算符格式。'
- en: The string format
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串格式
- en: 'The string format of the `where()` method should always be chained with the
    `addParams()` method in order to prevent SQL injection:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`where()`方法的字符串格式应始终与`addParams()`方法链式连接，以防止SQL注入：'
- en: '[PRE60]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Alternatively, the parameters can be rewritten as the second argument to the
    `where()` method:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以将参数重写为`where()`方法的第二个参数：
- en: '[PRE61]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Tip
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember to avoid adding PHP variables inline in your `where()` method in order
    to avoid SQL injection.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，为了避免SQL注入，不要在`where()`方法中直接添加PHP变量。
- en: The hash format
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 哈希格式
- en: The hash format provides an even better way to chain multiple `AND` conditions
    together in the `where` statement. Rather than passing a string as a parameter,
    we can instead pass an array of key values representing the column name and value.
    When using the hash format, the selected fields will be joined together with the
    SQL `AND`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希格式提供了一种更好的方法来在`where`语句中链式连接多个`AND`条件。而不是传递一个字符串作为参数，我们可以传递一个表示列名和值的键值对的数组。当使用哈希格式时，所选字段将通过SQL
    `AND`连接在一起。
- en: 'For example, we can find all the users in our database with the first name
    of John who were in their 20s and who didn''t have a listed pet name by running
    the following query:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过运行以下查询来找到所有名为John的用户，他们在20多岁，并且没有列出宠物名称：
- en: '[PRE62]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Tip
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Our database currently doesn't have an `age` or `pets_name` field. We will have
    to adjust our schema with a migration to add these fields to our database.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的数据库中没有`age`或`pets_name`字段。我们将不得不通过迁移调整我们的模式来向数据库中添加这些字段。
- en: 'This would result in the following query:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下查询：
- en: '[PRE63]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Tip
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As illustrated previously, the hash format allows you to generate more complex
    `WHERE` queries, such as those that use `IN` when specifying an array of values
    and `IS NULL` when passing null as the array value.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，哈希格式允许您生成更复杂的`WHERE`查询，例如在指定值数组时使用`IN`，以及在传递数组值为null时使用`IS NULL`。
- en: The operator format
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 操作符格式
- en: The last way to use the `where()` method is to use the operator format. The
    operator format allows us to build more complex SQL queries containing conditionals
    such as `LIKE`, `OR`, `BETWEEN`, and `EXISTS`, just to name a few examples.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`where()`方法的最后一种方式是使用操作符格式。操作符格式允许我们构建包含条件如`LIKE`、`OR`、`BETWEEN`和`EXISTS`等更复杂的SQL查询，仅举几个例子。
- en: 'In general, the `operator` format takes the following format:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`operator`格式采用以下格式：
- en: '[PRE64]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'For example, if we want to fetch all users from our database who had the first
    name of John or Jill, we can execute this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想从我们的数据库中获取所有名为John或Jill的用户，我们可以执行以下操作：
- en: '[PRE65]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Tip
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For a complete list of all the available operators that the operator format
    supports, check out the Yii2 API documentation at [http://www.yiiframework.com/doc-2.0/yii-db-query.html#where()-detail](http://www.yiiframework.com/doc-2.0/yii-db-query.html#where()-detail).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看操作符格式支持的完整操作符列表，请查看Yii2 API文档中的[http://www.yiiframework.com/doc-2.0/yii-db-query.html#where()-detail](http://www.yiiframework.com/doc-2.0/yii-db-query.html#where()-detail)。
- en: 'As you can imagine, the `where()` method can quickly become very bulky and
    complicated. Rather than using the operator, you may find your code more readable
    by using the `andWhere()` or `orWhere()` methods to chain multiple conditions
    together:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，`where()`方法可能会迅速变得非常庞大和复杂。与其使用操作符，您可能会发现使用`andWhere()`或`orWhere()`方法来链式连接多个条件会使代码更易读：
- en: '[PRE66]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Ordering results
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序结果
- en: 'Query builder can also sort results by a given field using the `orderBy()`
    method. For example, to sort all of our users in our database by age, we can construct
    the following query:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 查询构建器还可以使用`orderBy()`方法根据给定字段对结果进行排序。例如，为了按年龄对数据库中的所有用户进行排序，我们可以构建以下查询：
- en: '[PRE67]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Limiting and offsetting data
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制和偏移数据
- en: 'Commonly used with the `where()` method are the `limit()` and `offset()` methods,
    which are used to limit the number of results and offset our results by a given
    number of results. When properly used together, these two methods form the basics
    of paginating through results:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 通常与`where()`方法一起使用的是`limit()`和`offset()`方法，这些方法用于限制结果数量并偏移给定数量的结果。当这两个方法正确使用时，它们构成了通过结果分页的基本方法：
- en: '[PRE68]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Grouping and having
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分组和聚合
- en: Often when working with diverse datasets, we'll need to perform some analysis
    on our data. Aggregate functions such as `GROUP BY` and `HAVING` can greatly assist
    in extracting additional information from our data. Yii2 supports these methods
    via the `groupBy()` and `having()` methods.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理多样化的数据集时，我们通常需要对我们的数据进行一些分析。聚合函数如 `GROUP BY` 和 `HAVING` 可以极大地帮助我们从数据中提取更多信息。Yii2
    通过 `groupBy()` 和 `having()` 方法支持这些方法。
- en: 'For example, if we want to list the number of users in our database in each
    age group, we can execute the following query:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想列出我们数据库中每个年龄组的用户数量，我们可以执行以下查询：
- en: '[PRE69]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This will generate the following SQL statement:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下 SQL 语句：
- en: '[PRE70]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `groupBy()` method behaves similar to the `select()` method in that it accepts
    either an array or a string as an argument; however, when using database expressions,
    you'll need to use the array syntax.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupBy()` 方法的行为类似于 `select()` 方法，因为它接受一个数组或字符串作为参数；然而，当使用数据库表达式时，你需要使用数组语法。'
- en: 'After grouping our results with `groupBy()`, we can then filter our results
    with the `having()` method, which behaves the same as the `where()` method. The
    following example will only show the number of users in our dataset who are over
    a specified age:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `groupBy()` 对我们的结果进行分组后，我们可以使用 `having()` 方法来过滤我们的结果，该方法的行为与 `where()` 方法相同。以下示例将仅显示我们数据集中年龄超过指定年龄的用户数量：
- en: '[PRE71]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Joins and unions
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接和并集
- en: When working across multiple tables, you may often need to perform a join or
    union on your datasets. Joins and unions can be performed through query builder
    using the `join()` and `union()` methods.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当在多个表上工作时，你可能经常需要在你的数据集上执行连接或并集。可以通过查询构建器使用 `join()` 和 `union()` 方法来执行连接和并集。
- en: 'The join method has the following method syntax:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 连接方法具有以下方法语法：
- en: '[PRE72]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The first parameter, `$type`, specifies the join type you'd like to execute
    (for example, `INNER JOIN`, `LEFT JOIN`, or `OUTER JOIN`). The `$table` parameter
    specifies the table to be joined. The third parameter, `$on`, specifies the conditions
    on which the table should be joined and takes the syntax of the `where()` method,
    and the `$params` parameter specifies optional parameters to be bound to the join.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数 `$type` 指定了你想要执行的连接类型（例如，`INNER JOIN`、`LEFT JOIN` 或 `OUTER JOIN`）。`$table`
    参数指定要连接的表。第三个参数 `$on` 指定了表应该连接的条件，并采用 `where()` 方法的语法，而 `$params` 参数指定了要绑定到连接的可选参数。
- en: 'For example, suppose we had a posts and users table. We could join them as
    follows using the `join()` method:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个帖子表和用户表。我们可以使用 `join()` 方法将它们连接如下：
- en: '[PRE73]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Assuming our database had both a user and post table, this would return a return
    containing a join of all users and their posts. The result would include all users
    joined with all the posts that they owned.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的数据库中既有用户表又有帖子表，这将返回一个包含所有用户及其帖子的连接。结果将包括所有与所有他们拥有的帖子连接的用户。
- en: Joins can also be performed by type using the shortcut methods `rightJoin()`,
    `leftJoin()`, and `innerJoin()`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过类型使用快捷方法 `rightJoin()`、`leftJoin()` 和 `innerJoin()` 来执行连接。
- en: 'In the same vein, unions of two different queries can be constructed by first
    building two separate `yii\db\Query` objects and then using the `union()` method
    on them, as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，可以通过首先构建两个不同的 `yii\db\Query` 对象，然后使用它们上的 `union()` 方法来构造两个不同查询的并集，如下所示：
- en: '[PRE74]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Executing queries
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行查询
- en: After constructing our query with Query Builder, we'll need to specify the execution
    of our query. Yii2 provides the following query methods to execute queries built
    with Query Builder. The query methods are simply chained to the existing `$query`
    object, which will immediately result in their execution.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用查询构建器构建我们的查询后，我们需要指定查询的执行。Yii2 提供以下查询方法来执行使用查询构建器构建的查询。查询方法简单地链接到现有的 `$query`
    对象，这将立即导致它们的执行。
- en: 'Most of the times when working with Query Builder, we''ll want to fetch all
    the records in our database. This can be done by chaining the `all()` methods
    to our query object, which will retrieve all the records that fulfill the requirements
    of our `$query` object:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用查询构建器的大多数情况下，我们希望获取数据库中的所有记录。这可以通过将 `all()` 方法链接到我们的查询对象来完成，这将检索满足我们的 `$query`
    对象要求的所有记录：
- en: '[PRE75]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `$result` variable will then be populated with an array of rows, with each
    row containing an associated array of name-value key pairs for the resulting data.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`$result` 变量将填充一个包含行的数组，每个行包含一个与结果数据关联的名称-值键对数组。'
- en: Tip
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Carefully consider using the `all()` method if you have a large dataset, as
    the resulting query execution could take a long time to complete, and it could
    either hang or cause an error in your application.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有大量数据集，请仔细考虑使用`all()`方法，因为查询执行可能需要很长时间才能完成，并且可能会导致你的应用程序挂起或出错。
- en: 'In other instances, it may be more beneficial just to fetch the first row of
    a query. To fetch the first row, we can use the `one()` method:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，可能只需要获取查询的第一行。要获取第一行，我们可以使用`one()`方法：
- en: '[PRE76]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: At other times, we may just want to know whether a query would result in any
    data. To achieve this, we can use the `exists()` method, which will return either
    `true` or `false`, indicating that data would be returned from the resulting query.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他时候，我们可能只想知道查询是否会返回任何数据。为了实现这一点，我们可以使用`exists()`方法，它将返回`true`或`false`，指示结果查询将返回数据。
- en: 'For example, if we want to know whether we have any users in our database,
    we can use the `exists()` query to check whether we had users before we performed
    any more complex queries:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想知道我们的数据库中是否有任何用户，我们可以使用`exists()`查询来检查我们在执行任何更复杂的查询之前是否有用户：
- en: '[PRE77]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Alternatively, we can use the `count()` method to determine how many users
    exist in our database before running our query. The `count()` method will execute
    a `COUNT(*)` method within the `SELECT` fragment, and it will return a scalar
    value:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在运行查询之前使用`count()`方法来确定我们数据库中存在多少用户。`count()`方法将在`SELECT`片段中执行`COUNT(*)`方法，并将返回一个标量值：
- en: '[PRE78]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'When working with database expressions, such as `MIN()` and `MAX()`, or even
    more complex queries, you may find it useful to retrieve scalar values from query
    builder rather than an associative array. To fetch scalar values with query builder,
    we can use the `scalar()` method. For instance, if we want to know how old the
    oldest user is in our database using the `MAX()` SQL method, we can use the following
    code to return an integer representing their age:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理数据库表达式，如`MIN()`和`MAX()`，或更复杂的查询时，你可能发现从查询构建器中检索标量值而不是关联数组是有用的。要使用查询构建器检索标量值，我们可以使用`scalar()`方法。例如，如果我们想使用`MAX()`
    SQL方法知道我们数据库中最年长的用户有多老，我们可以使用以下代码返回代表他们年龄的整数：
- en: '[PRE79]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Finally, we may find it beneficial to retrieve the first column of our database
    results, such as in the instance of using the `groupBy()` or `having()` methods.
    To fetch the first row of our results, we can use the `column()` method:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可能发现检索数据库结果的第一个列是有益的，例如在使用`groupBy()`或`having()`方法的情况下。要获取结果的第一行，我们可以使用`column()`方法：
- en: '[PRE80]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In the previous example, the first column of our user table is the `ID` field.
    Consequently, an array of all IDs in our database will be returned.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们用户表的第一个列是`ID`字段。因此，将返回我们数据库中所有ID的数组。
- en: Tip
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Selecting all columns (`*`) will result in all records being loaded into the
    memory, which, depending upon the size of the table, could result in performance
    degradation. It's important to remember when querying for data that you only query
    for the data you need. If you need all data, you query for it in iterative way
    such as to limit the memory required for each query.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有列（`*`）将导致所有记录被加载到内存中，这取决于表的大小，可能会导致性能下降。在查询数据时，请记住你只查询你需要的数据。如果你需要所有数据，你可以以迭代方式查询，例如限制每个查询所需的内存。
- en: Examining queries
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询检查
- en: 'After building a query, you may want to examine the resulting query. To achieve
    this, the `createCommand()` method can be used to convert the Query Builder object
    into a DAO command:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建查询后，你可能想检查生成的查询。为此，可以使用`createCommand()`方法将查询构建器对象转换为DAO命令：
- en: '[PRE81]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Iterating over query results
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历查询结果
- en: 'Often when working with large datasets, the resulting datasets may be too large
    to load into the memory. To keep the memory consumption low and to prevent our
    application from hanging, we can use either the `batch()` or `each()` method.
    By default, both methods will fetch 100 rows from the database. To change the
    number of rows to be fetched, simply change the first parameter of each method:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在处理大量数据集时，结果数据集可能太大而无法加载到内存中。为了保持内存消耗低并防止我们的应用程序挂起，我们可以使用`batch()`或`each()`方法。默认情况下，这两种方法将从数据库中检索100行。要更改要检索的行数，只需更改每个方法的第一参数：
- en: '[PRE82]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: A `batch()` method supports fetching the data in batches, which can keep the
    memory down. Think of this method as a query appended with a limit and an offset
    parameter, which will restrict the number of returned rows. Each iteration of
    the `batch()` query will contain multiple results. Like the `batch()` method,
    the `each()` method can be used to reduce memory consumption as well, but it will
    iterate over the query row-by-row instead, which means that each iteration of
    the method will result in a single instance of our data.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`batch()` 方法支持分批获取数据，这可以降低内存消耗。将此方法视为附加了限制和偏移参数的查询，这将限制返回的行数。`batch()` 查询的每次迭代将包含多个结果。与`batch()`
    方法类似，`each()` 方法也可以用来减少内存消耗，但它将逐行迭代查询，这意味着该方法的每次迭代将只产生我们数据的一个实例。'
- en: Data providers and data widgets
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据提供者和数据小部件
- en: In Yii2, data providers are helper classes that are used to extract data via
    Query Builder to be passed to a data widget. The benefit of using data providers
    and data widgets over queries built via Query Builder is that they provide an
    interface to automatically deal with sorting and pagination.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yii2中，数据提供者是辅助类，用于通过查询构建器提取数据，并将其传递给数据小部件。使用数据提供者和数据小部件而不是通过查询构建器构建查询的好处是，它们提供了一个接口来自动处理排序和分页。
- en: 'The most common way to work with data providers is to use the `yii\data\ActiveDataProvider`
    class. Typically, `yii\data\ActiveDataProvider` will be used with Active Record
    models:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据提供者一起工作的最常见方式是使用`yii\data\ActiveDataProvider`类。通常，`yii\data\ActiveDataProvider`将与Active
    Record模型一起使用：
- en: '[PRE83]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Tip
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We'll cover how to create and use Active Record and models in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7 "第4章。活动记录、模型和表单")中介绍如何创建和使用Active
    Record和模型，*活动记录、模型和表单*。
- en: 'Active data providers can also be populated through Query Builder, as shown
    in the following example:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 活动数据提供者也可以通过查询构建器填充，如下例所示：
- en: '[PRE84]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Note
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Yii2 provides two additional data provider types: `yii\data\ActiveDataProvider`
    and `yii\data\SqlDataProvider`. For more information on these data providers,
    check out the Yii2 guide at [http://www.yiiframework.com/doc-2.0/guide-output-data-providers.html](http://www.yiiframework.com/doc-2.0/guide-output-data-providers.html).'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Yii2提供了两种额外的数据提供者类型：`yii\data\ActiveDataProvider` 和 `yii\data\SqlDataProvider`。有关这些数据提供者的更多信息，请参阅Yii2指南中的[http://www.yiiframework.com/doc-2.0/guide-output-data-providers.html](http://www.yiiframework.com/doc-2.0/guide-output-data-providers.html)。
- en: Once we have fetched our data with a data provider, we can pass the resulting
    data to a data widget. Data widgets in Yii2 are reusable building blocks used
    within views to create complex interfaces to interact with data. The most common
    data widgets are `DetailView`, `ListView`, and `GridView`, which behave similar
    to their Yii1 counterparts.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用数据提供者获取了数据，我们可以将结果数据传递给数据小部件。Yii2中的数据小部件是可重用的构建块，用于在视图中创建与数据交互的复杂界面。最常见的数据小部件是`DetailView`、`ListView`和`GridView`，它们的行为类似于它们的Yii1对应物。
- en: 'For instance, we can take our previous data provider and output it in `GridView`,
    as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将之前的数据提供者输出到`GridView`中，如下所示：
- en: '[PRE85]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'By itself, our resulting `GridView` widget will display all the fields in our
    database table. In some instances, there may be sensitive data that we don''t
    want to display on this page. Alternatively, there could simply be too much data
    to display in `GridView`. To restrict the number of fields to display in our `GridView`
    widget, we can use the `columns` attribute:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 仅就其本身而言，我们的结果`GridView`小部件将显示我们数据库表中的所有字段。在某些情况下，可能存在我们不希望在页面上显示的敏感数据。或者，可能数据太多，无法在`GridView`中显示。为了限制在`GridView`小部件中显示的字段数，我们可以使用`columns`属性：
- en: '[PRE86]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '![Data providers and data widgets](img/00018.jpeg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![数据提供者和数据小部件](img/00018.jpeg)'
- en: 'We can further enhance our data providers using the `yii\data\Sort` class,
    which provides sorting capabilities to our data providers. To add sorting to our
    data provider, we''ll need to specify the sort parameter within `yii\data\ActiveDataProvider`
    with an instance of `yii\data\Sort`, which specifies the attributes that can be
    sorted against:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`yii\data\Sort`类进一步增强我们的数据提供者，该类为我们提供数据提供者的排序功能。要向我们的数据提供者添加排序，我们需要在`yii\data\ActiveDataProvider`中指定`yii\data\Sort`实例，该实例指定了可以排序的属性：
- en: '[PRE87]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '![Data providers and data widgets](img/00019.jpeg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![数据提供者和数据小部件](img/00019.jpeg)'
- en: As illustrated, the listed attributes within the `sort` attribute are now clickable
    and sortable through our data provider.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，`sort` 属性中列出的属性现在可以通过我们的数据提供者进行点击和排序。
- en: Tip
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More information on output data widgets can be found in the Yii2 guide at [http://www.yiiframework.com/doc-2.0/guide-output-data-widgets.html](http://www.yiiframework.com/doc-2.0/guide-output-data-widgets.html).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 更多有关输出数据小部件的信息可以在 Yii2 指南中找到，请参阅[http://www.yiiframework.com/doc-2.0/guide-output-data-widgets.html](http://www.yiiframework.com/doc-2.0/guide-output-data-widgets.html)。
- en: 'While some widgets, such as `GridView`, allow us to work with and display multiple
    rows, we can also use data providers and data widgets to display information for
    a single row. With the `DetailView` widget, we can dynamically configure a simple
    interface to display the information for a particular user in our database. The
    `getModels()` method of our data provider splits our data provider into individual
    models that our `DetailView` widget can understand:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些小部件，如 `GridView`，允许我们处理和显示多行，但我们也可以使用数据提供者和数据小部件来显示单行的信息。使用 `DetailView`
    小部件，我们可以动态配置一个简单的界面来显示数据库中特定用户的信息。我们数据提供者的 `getModels()` 方法将数据提供者拆分为 `DetailView`
    小部件可以理解的单独模型：
- en: '[PRE88]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Tip
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Typically when working with the `DetailView` widget, we'll supply it with an
    Active Record instance rather than a generated model from our data provider, which
    we'll cover in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在处理 `DetailView` 小部件时，我们会向其提供一个 Active Record 实例，而不是从数据提供者生成的模型，这将在[第4章](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "第4章。Active Record，模型和表单")中介绍，*Active Record，模型和表单*。
- en: 'This will be displayed on our screen:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的屏幕上显示：
- en: '![Data providers and data widgets](img/00020.jpeg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![数据提供者和数据小部件](img/00020.jpeg)'
- en: 'In addition to simply displaying results from a database, the `DetailView`
    widget also supports the custom formatting of certain rows. In our previous example,
    we were able to format our Unix timestamp stored in the `updated_at` field as
    human-readable date and time fields by specifying the `:datetime` formatter in
    our updated field:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单地显示数据库中的结果外，`DetailView` 小部件还支持某些行的自定义格式化。在我们的上一个示例中，我们能够通过在更新字段中指定 `:datetime`
    格式化器，将存储在 `updated_at` 字段中的 Unix 时间戳格式化为可读的日期和时间字段：
- en: '[PRE89]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Tip
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The formatter listed here is a powerful tool that allows us to quickly convert
    raw data into useful human-readable information. More information on the formatter
    can be found at [http://www.yiiframework.com/doc-2.0/yii-i18n-formatter.html](http://www.yiiframework.com/doc-2.0/yii-i18n-formatter.html).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的格式化器是一个强大的工具，它允许我们快速将原始数据转换为有用的可读信息。有关格式化器的更多信息，请参阅[http://www.yiiframework.com/doc-2.0/yii-i18n-formatter.html](http://www.yiiframework.com/doc-2.0/yii-i18n-formatter.html)。
- en: Data replication and load balancing
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据复制和负载均衡
- en: As we start working with larger and larger systems, we often find the need to
    build an additional redundancy into our system in order to enable high availability
    and protection against unexpected downtime. When working with large systems, we
    will split our database into a read-and-write master and a read-only slave of
    a set of slaves. Typically, our applications are unaware of our database architecture,
    which can introduce problems when required to migrate from a new master. With
    Yii2, we can configure our database connection to not only be aware of our master-slave
    database configuration, but also intelligently handle slave unavailability.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始处理更大和更复杂的系统时，我们经常发现需要在系统中构建额外的冗余，以便实现高可用性和防止意外停机。当处理大型系统时，我们将数据库拆分为一个读写主数据库和一组从数据库的只读从数据库。通常，我们的应用程序对我们的数据库架构一无所知，这可能会在需要从新主数据库迁移时引入问题。使用
    Yii2，我们可以配置我们的数据库连接，使其不仅了解我们的主从数据库配置，而且可以智能地处理从数据库不可用的情况。
- en: 'In Yii2, we can configure a single master and multiple slaves using the following
    database configuration. This will result in all writes going to our declared master
    and all reads going to one of our declared slaves:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Yii2 中，我们可以使用以下数据库配置来配置单个主数据库和多个从数据库。这将导致所有写入操作都发送到我们声明的主数据库，所有读取操作都发送到我们声明的从数据库之一：
- en: '[PRE90]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Tip
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In general, queries executed with the `execute()` method will run against the
    master, whereas all other queries will run against one of the slaves.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用 `execute()` 方法执行的查询将针对主数据库运行，而所有其他查询将针对从数据库之一运行。
- en: In this configuration, Yii will execute write queries (such as `UPDATE`, `INSERT`,
    and `DELETE`) against the master and run a read query (such as `SELECT`) against
    one of the available slaves. When working with slaves, Yii will attempt to connect
    to slaves in the list until a slave responds and load balance queries against
    each of the available slaves. By setting `PDO::ATTR_TIMEOUT` equal to 10 seconds,
    Yii will abort trying to retrieve data from a slave if it receives no response
    within 10 seconds, and it will remember the state of the slave for the duration
    that the configuration is in effect.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中，Yii 将会对主节点执行写查询（如 `UPDATE`、`INSERT` 和 `DELETE`），并对可用的从节点之一执行读查询（如 `SELECT`）。当与从节点协同工作时，Yii
    将会尝试连接列表中的从节点，直到从节点响应，并对每个可用的从节点进行查询的负载均衡。通过将 `PDO::ATTR_TIMEOUT` 设置为 10 秒，如果
    Yii 在 10 秒内没有收到从节点的响应，它将终止尝试从从节点检索数据，并且会记住从节点的状态，直到配置生效期间。
- en: 'Alternatively, using the following configuration, we can configure our application
    to work with both multiple masters and multiple slaves. When using multiple masters,
    Yii will execute writes against any available master and will load balance writes
    between the available masters:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用以下配置，我们可以配置我们的应用程序同时与多个主节点和多个从节点协同工作。当使用多个主节点时，Yii 将会对任何可用的主节点执行写操作，并在可用的主节点之间进行写操作的负载均衡：
- en: '[PRE91]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Tip
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If Yii2 is unable to connect to any of the available masters, an exception will
    be thrown.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Yii2 无法连接到任何可用的主节点，将会抛出异常。
- en: 'When working with a master-slave topology, we may want to issue a read query
    against one of our masters. To do that, we would need to explicitly tell Yii2
    to run our query against our master rather than our slaves:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当与主从拓扑结构协同工作时，我们可能希望对某个主节点发起一个读查询。为此，我们需要明确告诉 Yii2 将我们的查询运行在主节点上而不是从节点上：
- en: '[PRE92]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'When working with transactions, Yii2 will try to run transactions against our
    master by default. If we need to issue a transaction against a slave, we will
    need to explicitly begin the transaction on a slave, as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 当与事务协同工作时，Yii2 默认会尝试在我们的主节点上运行事务。如果我们需要在从节点上发起一个事务，我们需要在从节点上显式地开始事务，如下所示：
- en: '[PRE93]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Summary
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the foundations of working with databases in Yii2\.
    By working with database access objects, we showed how we can execute raw SQL
    statements to run against our database and how we can use transactions to protect
    our database integrity. We also illustrated the use of Query Builder, which can
    enable us to write database-agnostic queries in a programmatic way. We then discovered
    how we can use Query Builder to construct intelligent data providers, which are
    used to supply data to reusable data widgets. Finally, we learned how to configure
    Yii2 to be aware of master-slave and multi-master database cluster configurations
    and how to load balance between these connections.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用 Yii2 处理数据库的基础。通过使用数据库访问对象，我们展示了如何执行针对数据库的原始 SQL 语句，以及如何使用事务来保护数据库的完整性。我们还展示了如何使用查询构建器，它能够以编程方式使我们能够编写数据库无关的查询。然后我们发现如何使用查询构建器构建智能数据提供者，这些提供者用于向可重用的数据小部件提供数据。最后，我们学习了如何配置
    Yii2 以识别主从和多主数据库集群配置，以及如何在这些连接之间进行负载均衡。
- en: In the next chapter, we discover the capstone of working with databases in Yii2—Active
    Record—which is a powerful tool used to work with our data and model our database
    structure. We'll also dive into Active Records relatives, basic models, and forms,
    and we'll learn how we can use a powerful tool called Gii to automate the construction
    of much of the code our modern applications will work with.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将发现使用 Yii2 处理数据库的基石——Active Record，这是一个强大的工具，用于处理我们的数据和建模数据库结构。我们还将深入了解
    Active Record 的相关内容，基本模型和表单，并学习如何使用一个名为 Gii 的强大工具来自动化构建现代应用程序将使用的大部分代码。
