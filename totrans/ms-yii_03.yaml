- en: Chapter 3. Migrations, DAO, and Query Building
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most fundamental aspects of writing modern web application is working
    with databases. Through PHP's PDO driver, Yii2, can work with many different kinds
    of relational databases. In this chapter, we'll cover how to connect to different
    databases, write database migrations to instantiate our databases, use **database
    access objects** (**DAO**), and use Yii2's built-in Query Builder. We'll also
    cover the basics of powerful tools such as data providers and data widgets as
    well as how to use Yii2 to replicate and load balance access to our databases.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The primary component required in order to work with databases is the `yii\db\Connection`
    class. Through this class, we can connect to a variety of different database types,
    ranging from local SQLite databases to clustered MySQL databases. The simplest
    way to establish a connection to a database is to create a SQLite database connection,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, however, we''ll want to use a single database connection across our
    entire application. We can keep our application *DRY* by putting our database
    configuration into the `db` component of our web or console configuration file.
    Following the examples laid out in the previous chapters, this component will
    reference the `config/env/<ENV>/db.php` file. As an example, establishing a SQLite
    connection in this file will be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By storing our database configuration in the `db` component of our application,
    it can easily be shared between both our web and console applications without
    any additional effort on our part. Furthermore, since Yii2 loads components only
    when required, it can keep our application lean and performant.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Yii2, components are only loaded when required. This process is often called
    **lazy loading**. Unless a component is preloaded, Yii2 will not create an instance
    of that component until it is first used. After being initially instantiated,
    Yii will then reuse the same component across your application rather than creating
    multiple instances of that component. Lazy loading is one of the primary reasons
    Yii is so performant.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our database configuration stored within our configuration file, we can
    now access the database connection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This connection will also be shared to any Active Record models used in our
    application, which we'll discuss in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated earlier, Yii2 can connect to several different database types. As
    Yii2 binds on top of PHP''s PDO library, it can connect to the same sources a
    native PDO driver can connect to. A few examples of the **data source names**
    (**DSNs**) that Yii2 supports are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Database Type | DSN Scheme |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| MySQL, Percona, MariaDB, and so on | `mysql:host=localhost;dbname=mydatabase`
    |'
  prefs: []
  type: TYPE_TB
- en: '| SQLite | `sqlite:/path/to/database/file.sqlite` |'
  prefs: []
  type: TYPE_TB
- en: '| PostgreSQL | `pgsql:host=localhost;port=5432;dbname=mydatabase` |'
  prefs: []
  type: TYPE_TB
- en: '| CUBRID | `cubrid:dbname=demodb;host=localhost;port=33000` |'
  prefs: []
  type: TYPE_TB
- en: '| MS SQL Server (via the sqlsrv driver) | `sqlsrv:Server=localhost;Database=mydatabase`
    |'
  prefs: []
  type: TYPE_TB
- en: '| MS SQL Server (via the dblib driver) | `dblib:host=localhost;dbname=mydatabase`
    |'
  prefs: []
  type: TYPE_TB
- en: '| MS SQL Server (via the mssql driver) | `mssql:host=localhost;dbname=mydatabase`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Oracle | `oci:dbname=//localhost:1521/mydatabase` |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're connecting to a MS SQL server, you'll need to have either the sqlsrv,
    dblib or mssql PHP drivers installed on your system. More information on these
    base drivers can be found within the PHP manual at [https://php.net/manual/en/pdo.drivers.php](https://php.net/manual/en/pdo.drivers.php).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Oracle connections will require the installation of Oracle's OCI8
    driver. More information on this driver can be found in the PHP manual at [https://php.net/manual/en/book.oci8.php](https://php.net/manual/en/book.oci8.php).
  prefs: []
  type: TYPE_NORMAL
- en: Note that Yii2 will not be able to connect to any database unless the appropriate
    PHP drivers are properly installed and configured. If you aren't certain which
    drivers you have installed, the native `phpinfo()` function can output a list
    of all the currently installed PHP extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the base drivers listed earlier, Yii2 can also connect to databases
    over **Open Database Connectivity** (**ODBC**). When connecting to a database
    via ODBC, you''ll need to specify the `$driverName` property within your `db`
    connection component so that Yii2 can properly connect to your database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As shown previously, some database configurations may require you to specify
    a username or password to connect to them. Within the `db` component, simply specify
    the `username` and `password` attributes that are appropriate for your database.
  prefs: []
  type: TYPE_NORMAL
- en: Additional configuration options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the basic `db` component options listed previously, Yii2 also
    provides several additional options that can be used to either enhance the performance
    of your application or deal with a known issue within the native PHP drivers.
    While many of these options can be found in the Yii guide and the API documentation,
    some of them will most likely be used more often than others. These properties
    are `$emulatePrepare`, `$enableQueryCache`, and `$enableSchemaCache`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A complete list of the available methods and properties for the `yii\db\Connection`
    class can be found at [http://www.yiiframework.com/doc-2.0/yii-db-connection.html](http://www.yiiframework.com/doc-2.0/yii-db-connection.html).
  prefs: []
  type: TYPE_NORMAL
- en: The first common attribute, `$emulatePrepare`, can be used to alleviate common
    issues identified by the Yii team when preparing database statements. By default,
    Yii2 will try to use the native prepare support built into the native PDO driver.
    To help alleviate issues with a few of the native PDO drivers (mainly, the MS
    SQL drivers), the `$emulatePrepare` attribute may need to be set to `true` in
    order to allow Yii2 to handle the prepare statements.
  prefs: []
  type: TYPE_NORMAL
- en: The next common property often enabled in our `db` component is `$enableQueryCache`.
    To improve the performance of our application, we can set this value to `true`
    and allow Yii to cache commonly executed queries. In an application that mostly
    performs read actions, enabling this attribute can greatly increase the performance
    of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To completely enable this component, however, the additional properties we''ll
    mention now must be set as well. The first property, `$queryCache`, specifies
    the named cache object that the query cache should use. If unset, this will simply
    default to the cache component in our application. The second property is `$queryCacheDuration`,
    and it determines how long any database query result will be cached for. By default,
    the query cache will be valid for 3,600 seconds, or 60 minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The final common property that often will be added to our `db` component is
    `$enableSchemaCache`. Before Yii accesses the database, it will often need to
    determine the database schema. This schema information is used to assist Yii when
    running validators and working with relational models, such as related Active
    Record models. Rather than having Yii try to determine our database schema on
    every request, we can tell it that our schema isn't changing by setting `$enableSchemaCache`
    to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the `$enableCache` parameter outlined previously, we''ll also need
    to define the `$schemaCache` parameter, which will tell Yii what cache component
    to use. We''ll also need to define the `$schemaCacheDuration` parameter so that
    Yii2 knows how long the schema cache is valid for in seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As the majority of our controller actions will most likely result in a database
    operation, enabling these properties can greatly improve the performance of our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that because `$enableSchemaCache` and `$enableQueryCache` are enabled,
    Yii2 will not perform common checks against the database. Any change to the underlying
    data or schema in your database may cause your application to return bad data
    or crash entirely. If you change the data in your database directly rather than
    through Yii2, or if you change the database schema, ensure that you flush the
    relevant cache components defined by `$enableSchemaCache` or `$enableQueryCache`
    to ensure that your application functions correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Writing database migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building and maintaining modern web applications, the underlying structure
    of our database may need to change to account for changes in requirements or scopes.
    To ensure that our database schema can evolve in tandem with our source code,
    Yii2 provides built-in support to manage database migrations. Using database migrations,
    we can treat our database as an extension of the source code and easily change
    it when our source code changes.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with database migrations, we'll often be working with the `yii\db\Schema`
    class. When paired properly, we can often write our migrations in a way that enables
    them to be run across a variety of database types. For example, when working locally,
    we might need to use a local SQLite database even if our application will ultimately
    run on a MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: At the heart of this class is a variety of different schema types that Yii2
    will be able to properly map to the appropriate data type within our database.
    These include data types such as `INT`, `DATETIME`, and `TEXT`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a complete list of the available constants made available by the Schema
    class, ensure that you refer to the Yii2 guide at [http://www.yiiframework.com/doc-2.0/yii-db-schema.html#constants](http://www.yiiframework.com/doc-2.0/yii-db-schema.html#constants).
  prefs: []
  type: TYPE_NORMAL
- en: 'Within our migrations, we can call any of these constants by running this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example of an integer, we can use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using these constants in our migration, we can ensure that our migrations map
    to the appropriate data type within our database and work across a variety of
    database types.
  prefs: []
  type: TYPE_NORMAL
- en: Writing migrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As shown in the previous chapter, we can create a new migration by invoking
    the `migrate/create` command from the `yii` command-line tool. Using the source
    code from the previous chapter as a starting point, we''ll do this by running
    the following from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Writing migrations](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Running this command will create a new migration in the `migrations` folder
    of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending upon the file permissions on your system, Yii2 may not be able to
    create the `migrations` folder if it does not exist. If the `migrations` folder
    doesn't exist yet, ensure that you create it before running the `migrate/create`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: When running migrations, Yii2 will execute them in the order in which they were
    created. To determine this order, Yii2 will look at the filename or the migration
    that contains the name of the migration specified from the `migrate/create` command
    as well as the exact timestamp the migration was created at.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the filename is `m150523_194158_init.php`, which means that this
    migration was created on May 23, 2015 at 7:41:58 PM UTC.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because of this naming convention, any migration that you create will have a
    distinct and unique filename. If you're following along, ensure that you're working
    in the file that was created from the `./yii` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the `migrate/create` command, Yii2 provides us with a skeleton
    migration that will look similar to the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Migrations in Yii2 can operate in one of these two ways: we can either bring
    a migration up, or we can bring it down. These two operations correspond to one
    of four functions: `up()`, `safeUp()`, `down()`, and `safeDown()`. The `up()`
    and `down()` methods are the base methods required to run migrations and will
    execute any database command issued inside them even if there is an error. Alternatively,
    we can use the `safeUp()` and `safeDown()` methods, which are functionally identical
    to the `up()` and `down()` methods, with the exception that the entire operation
    is wrapped within a transaction. If our database supports transactions, running
    our migrations from the safe methods can help us catch migration errors at runtime
    before an error can cause problems with our entire database.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because of the additional safety they offer, `safeUp()` and `safeDown()` should
    be our go-to methods when writing migrations. Additionally, if `safeUp()` or `safeDown()`
    are used, the unsafe methods cannot be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding a simple table to our database in order to store our
    users. We''ll start by simply storing an ID, an email address, a password, the
    username, and some timestamp metadata indicating when our user was created and
    last updated. Within our migration, we can write this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As illustrated previously, Yii2 supports two different ways to declare schema
    types for columns. We can either directly use the constants defined by the `Schema`
    class, or we can use the native migration methods, such as `primaryKey()`, `integer()`,
    `string()`, and `text()`. Using the migration methods is preferred because it
    permits us to add additional attributes to our column, such as the column size
    and length. For a complete list of methods offered by the migration class, refer
    to the Yii2 guide at [http://www.yiiframework.com/doc-2.0/yii-db-migration.html](http://www.yiiframework.com/doc-2.0/yii-db-migration.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we outlined two methods: `createTable()`, which will
    create a new database table within our application, and `dropTable()`, which will
    drop the table from our database.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common convention when working with a database is to write field names with
    underscores and use singular names for table and column names. While Yii2 is smart
    enough to work with any field names you specify, following this convention will
    make your code more readable and working with your databases less complicated.
    While you don't have to explicitly follow this convention, following a convention
    can save you a lot of time in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Running migrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Running our migrations can be done through the `yii` command, as shown in the
    previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Running migrations](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we''re using a SQLite database in our example, we can easily explore
    what just happened when we ran the `migrate/up` command. Using the `sqlite` command-line
    tool, we can explore our SQLite database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your package manager does not provide sqlite3, you can download the binary
    executables from [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'By running the `.tables` command from our SQLite prompt, we can see that two
    tables were created when we ran the `migrate/up` command, `migration` and `user`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![Running migrations](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The first table, `migration`, contains a list of all the applied migrations
    as well as the time at which they were applied.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running migrations](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The second table, `user`, shows the resulting schema that was created by Yii
    from our migration class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running migrations](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For instance, by specifying the `TYPE_PK` schema for our `ID` attribute, Yii2
    knew that it needed to add `AUTOINCRIMENT` and `NOT NULL` attributes to our SQLite
    schema.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While database migrations are suited for most database changes, running them
    against large datasets may result in your database being unavailable to your application,
    resulting in downtime. Make sure that before you run a database migration through
    Yii2, your application should be able to handle temporary downtime. If even temporary
    downtime is not appropriate for your application, you may need to consider migrating
    your data to an updated schema in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: Altering a database schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When developing locally, we can simply use the `migrate/down` command to undo
    a specific migration (assuming we implemented a `down()` or `safeDown()` method).
    However, after committing and pushing our code to our DCVS system, such as Git
    or SVN, others may be using or working with our code. In this instance, we want
    to change our migrations without causing harm to their local instance; we can
    create new migrations that users of our code can apply in order to bring their
    applications up to date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for instance, the user schema that was created for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than having a single field for our username, we may want to have two
    fields: one for their first name and one for their last name. We may also want
    to make a few changes to other fields, such as our `email` field, to prevent them
    from being `NULL`. We can do this by writing a new migration and altering the
    schema of the database itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by creating a new migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, the `--interactive=0` flag tells Yii to run our console command without
    prompts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within our new `migrations/…name_change.php` migration, we can write a `safeUp()`
    method to alter these columns for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In Yii2, migration commands are self-explanatory in what they do. For instance,
    the first method, `renameColumn()`, will simply rename the `name` column to `first_name`.
    In the same vein, `addColumn()` will add a new column with the specified name
    and schema to our database, `alterColumn()` will alter the schema for the named
    column, and `createIndex()` will create a unique index on the email field in our
    database, which will ensure that no two users will share the same email address.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A complete list of commands that can be run within the migration calls can be
    found in the Yii2 guide at [http://www.yiiframework.com/doc-2.0/yii-db-migration.html](http://www.yiiframework.com/doc-2.0/yii-db-migration.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to run these migrations against our SQLite database, however, we
    would be presented with an error similar to the following, indicating that SQLite
    doesn''t have support for these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'While the previously listed migration would work on MySQL or PostgreSQL, our
    SQLite driver doesn''t provide support for these commands. Since we''re using
    SQLite, however, we''d have to rewrite our initial migration command and notify
    users of our application about the change. For SQLite, we can rewrite our newly
    created `migrations/…name_change.php` migration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`yii\db\Migration` does not have a `query()` method that we can use to retrieve
    data. Consequently, if we need to query data within a migration, we will need
    to use Yii2''s Query Builder to do this, which we''ll cover later in this chapter.
    If our application has widespread adoption, it might be better to query for all
    of our users with Query Builder and store them temporarily in the memory (or a
    temporary store if we have a large number of records). Then, after creating our
    new table schema for our users table, we could then reinsert them into our database
    using the `insert()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After updating our new migration, we can rerun our migration command. Since
    our first migration was already applied, that migration will be skipped when the
    migrate/up command is executed, and only our `migrations/m150523_203944_change.php`
    migration will be run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![Altering a database schema](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After running our migration, we can query our database to see what our full
    schema looks like within SQLite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![Altering a database schema](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Migrations in Yii2 are extremely powerful. Take a look at the Yii2 documentation
    at [http://www.yiiframework.com/doc-2.0/yii-db-migration.html](http://www.yiiframework.com/doc-2.0/yii-db-migration.html)
    to see everything that you can do with `yii\db\Migration`.
  prefs: []
  type: TYPE_NORMAL
- en: Database access objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yii database access objects, commonly referred to as DAO, provide a powerful
    object-oriented API to work with a relational database. As the foundation for
    more complex database access, such as Query Builder and Active Record, DAO enables
    us to work directly with our database through SQL statements and PHP arrays. Consequently,
    it is significantly more performant to work with DAO statements than it is to
    work with either Active Record or Query Builder.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the core of DAO is our `yii\db\Connection` class, or more commonly, our
    `db` component `\Yii::$app->db`. Since our `db` component is already properly
    configured for SQLite, we''ll use it moving forward. With DAO, there are two general
    types of queries that we can run: queries that return data, such as `SELECT` queries,
    and queries that execute data, such as `DELETE` or `UPDATE`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you use the `yii\db\Connection` class directly, you'll need to explicitly
    call the `open()` method before you can run any queries against that connection.
  prefs: []
  type: TYPE_NORMAL
- en: Querying for data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first way in which we can use DAO is to query for data. There are four
    main methods that are used to query for data: `queryAll()`, `queryOne()`, `queryScalar()`,
    and `queryColumn()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method, `queryAll()`, is used to query for all the data in a specific
    table based upon the SQL statement used within the `createCommand()` method. Using
    our user table as an example, we can query for all the users in our database by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After running this command, our `$users` variable will be populated with an
    array of users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The next method, `queryOne()`, is used to fetch a single record from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `queryOne()` method returns an array of data for a single element. In the
    event that no data is found, this method will return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The third method, `queryScalar()`, is used to return the result of a `SELECT`
    query that returns a single value. For instance, if we want to count the number
    of users in our database, we can use `queryScalar()` to get the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: After running this command, our `$count` variable will be populated with the
    number of users in our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final method, `queryColumn()`, is used to query a specific column in our
    database. For instance, if we want to know the email addresses of all the users
    in our database, we can use `queryAll()` to fetch all that data, or we can use
    `queryColumn()`, which would be significantly more efficient to use as it would
    query for less data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `queryAll()`, `queryColumn()` will return an array of results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the event that no results are found, `queryColumn()` will return an empty
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our knowledge of these methods, as an exercise, let''s go back to our
    previous migrations and rewrite them to preserve our users across our schema change:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s roll back our migrations to properly simulate the scenario:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll migrate our initial migration using the `migrate/to` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s seed our database with some test data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we take a look at our database, we'll see that the initial schema and data
    is now in place.![Querying for data](img/00015.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, let''s rewrite our `migrations/…name_change.php` migration to fetch our
    users from the database before running the initial migration that we created,
    and then reinsert our users back into our database. We''ll do this using the `queryAll()`
    DAO method to fetch the data and the `insert()` method of `yii\db\Migration` to
    put it back into the database. The new code blocks have been highlighted for easy
    viewing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we can rerun our migration. If successful, we should see our original migration
    run and an insert call executed for each user in our database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Querying for data](img/00016.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Finally, we can query our SQLite database to preview the updated schema and
    see our updated users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Querying for data](img/00017.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: As you can see, DAO's query method provides us with the ability to quickly and
    efficiently fetch data from our database.
  prefs: []
  type: TYPE_NORMAL
- en: Quoting table and column names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When writing database-agnostic SQL queries, properly quoting field names can
    be problematic. To avoid this problem, Yii2 provides the ability to automatically
    quote table and column names for you using the correct quoting rule for the specific
    database in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'To automatically quote a column name, simply enclose the column name in square
    brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To automatically quote a table, simply enclose the table name in curly brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of both of these tools in action is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Executing queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the query methods provide the ability to select data from our database,
    we often need to execute `UPDATE` or `DELETE` commands, which do not return data.
    To execute these commands, we can use the `execute()` method in general:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If successful, the `execute()` method will return with `true`, whereas if it
    fails, it will return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Yii2 also provides convenient wrappers for `insert()`, `update()`, and `delete()`,
    which enables us to write commands without having to write raw SQL. These methods
    properly escape and quote table and column names and bind parameters on your behalf.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can insert a new user into a database as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can update all the users in our database using the `update()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last argument listed in our update command defines the `where` condition
    of our query command, which we'll cover in more detail later in the chapter. `1=1`
    is a common SQL idiom to update all records.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also delete a user in our database using the `delete()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, if you need to insert several rows at the same time, you can
    use the `batchInsert()` method, which can be significantly more efficient than
    inserting a single row at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yii2 does not provide a `batchUpdate()` or `batchDelete()` method as bulk updates
    and deletes can be handled by the `update()` and `delete()` methods using a normal
    SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The number one rule when working with user-submitted data is to never trust
    user-submitted data. Any data that passes through our databases and has come from
    an end user needs to be validated, sanitized, and properly bound to our statements
    before they are executed against our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for instance, the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Under normal circumstances, Yii would generate the following SQL, assuming
    `$_GET[''id'']` had a value of `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'While this is innocent enough, any user who can manipulate the `$_GET[''id'']`
    variable can rewrite our query to something much more dangerous. For instance,
    they could drop our entire user table simply by substituting `$_GET[''id'']` with
    `1; DROP TABLE user; --`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This kind of attack is called SQL injection. To help protect against SQL injection,
    Yii2 offers several different ways to bind parameters to our queries in a way
    that will filter our injected SQL. These three methods are `bindValue()`, `bindValues()`,
    and `bindParam()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method, `bindValue()`, is used to bind a single parameter to a token
    within our SQL statement. For example, we can rewrite the previous query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the `bindValues()` method to bind several parameters
    into a single call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, the previous query can be rewritten so that the parameters
    are in line with the `createCommand()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The final method, `bindParam()`, is valued to bind parameters by reference
    rather than by value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `bindParam()` binds parameters by reference, we can change the bounded
    values to execute multiple queries. Following the previous example, we can write
    the following to update multiple users without having to rewrite our query each
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, the most important rule of working with user data is to never trust
    user-submitted data. Even in cases where you're 100% certain that SQL injection
    cannot happen, it's recommended that you use parameter binding rather than writing
    in line SQL. This will protect you against future changes to your code.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When running multiple queries in a sequence, we often want to ensure that our
    database state remains consistent across these queries. Most modern databases
    support the use of transactions to accomplish this. In a transaction, changes
    are written to the database in such a way that they can be committed if everything
    went well or rolled back without consequence if any given query within the transaction
    failed. In Yii2, this looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Query Builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building on top of the foundations laid by DAO is Yii's Query Builder. Yii's
    Query Builder allows us to write database-agnostic queries in a programmatic way.
    Consequently, queries written through the Query Builder are significantly more
    readable than their DAO counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basics of Query Builder involve the creation an instance of `yii\db\Query`,
    the construction of a statement, and then the execution of that query statement.
    For example, we could simply query for all the users in our database in Query
    Builder using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with Query Builder, we're actually using the `yii\db\Query` class
    rather than `yii\db\QueryBuilder`. While `yii\db\QueryBuilder` can generate SQL
    statements similar to those generated by `yii\db\Query`, `yii\db\Query` enables
    these statements to be database-agnostic. In general, you'll want to work with
    `yii\db\Query` when using Query Builder.
  prefs: []
  type: TYPE_NORMAL
- en: Query construction methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basics of Query Builder involve the chaining of multiple query methods together.
    These method names directly correspond with the SQL segment that they are named
    after. When working with Query Builder, the most common methods that you'll use
    will be the `select()`, `from()`, and `where()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward, we''ll use the following variable to represent our query builder
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The select method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `select()` method directly corresponds to the `SELECT` segment of our SQL
    query and accepts either a string of column names or an array of columns to specify
    the columns that we would want to select from our database. For instance, the
    following queries are identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using the `select()` method, the array format is generally easy to read
    and work with. If you choose to list the column names as a string, ensure that
    you do that consistently throughout your application. In the following examples,
    we'll use the array format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `select()` method also supports column aliases and table prefixes, as shown
    in the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to column names, the `select` method also provides support for
    expressions. For instance, if we want to retrieve the user''s complete name as
    a single field, we can execute the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `select` method can also be used to execute subqueries, such as `COUNT()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `select` statement can be chained with the `distinct()` method
    to retrieve unique records. For instance, if we want to list all the first names
    of our user''s database, we can execute the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Omitting the `select()` method from your query will result in a `SELECT *` query
    being performed.
  prefs: []
  type: TYPE_NORMAL
- en: The from method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our previous examples have already illustrated the basic usage of the `from()`
    method. The `from()` method can also be used to specify a table alias, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like the `select()` method, the `from()` method can also accept strings as an
    input rather than an array. The preceding query can be rewritten as `$query->select('first_name')->from(['users
    u');`.
  prefs: []
  type: TYPE_NORMAL
- en: The where method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `where`() method specifies the `where` segment of our SQL query and can
    be used either in a string format, hash format, or operator format.
  prefs: []
  type: TYPE_NORMAL
- en: The string format
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The string format of the `where()` method should always be chained with the
    `addParams()` method in order to prevent SQL injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the parameters can be rewritten as the second argument to the
    `where()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to avoid adding PHP variables inline in your `where()` method in order
    to avoid SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: The hash format
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The hash format provides an even better way to chain multiple `AND` conditions
    together in the `where` statement. Rather than passing a string as a parameter,
    we can instead pass an array of key values representing the column name and value.
    When using the hash format, the selected fields will be joined together with the
    SQL `AND`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can find all the users in our database with the first name
    of John who were in their 20s and who didn''t have a listed pet name by running
    the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our database currently doesn't have an `age` or `pets_name` field. We will have
    to adjust our schema with a migration to add these fields to our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'This would result in the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As illustrated previously, the hash format allows you to generate more complex
    `WHERE` queries, such as those that use `IN` when specifying an array of values
    and `IS NULL` when passing null as the array value.
  prefs: []
  type: TYPE_NORMAL
- en: The operator format
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last way to use the `where()` method is to use the operator format. The
    operator format allows us to build more complex SQL queries containing conditionals
    such as `LIKE`, `OR`, `BETWEEN`, and `EXISTS`, just to name a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the `operator` format takes the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we want to fetch all users from our database who had the first
    name of John or Jill, we can execute this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a complete list of all the available operators that the operator format
    supports, check out the Yii2 API documentation at [http://www.yiiframework.com/doc-2.0/yii-db-query.html#where()-detail](http://www.yiiframework.com/doc-2.0/yii-db-query.html#where()-detail).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can imagine, the `where()` method can quickly become very bulky and
    complicated. Rather than using the operator, you may find your code more readable
    by using the `andWhere()` or `orWhere()` methods to chain multiple conditions
    together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Ordering results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Query builder can also sort results by a given field using the `orderBy()`
    method. For example, to sort all of our users in our database by age, we can construct
    the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Limiting and offsetting data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Commonly used with the `where()` method are the `limit()` and `offset()` methods,
    which are used to limit the number of results and offset our results by a given
    number of results. When properly used together, these two methods form the basics
    of paginating through results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Grouping and having
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often when working with diverse datasets, we'll need to perform some analysis
    on our data. Aggregate functions such as `GROUP BY` and `HAVING` can greatly assist
    in extracting additional information from our data. Yii2 supports these methods
    via the `groupBy()` and `having()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to list the number of users in our database in each
    age group, we can execute the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate the following SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `groupBy()` method behaves similar to the `select()` method in that it accepts
    either an array or a string as an argument; however, when using database expressions,
    you'll need to use the array syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'After grouping our results with `groupBy()`, we can then filter our results
    with the `having()` method, which behaves the same as the `where()` method. The
    following example will only show the number of users in our dataset who are over
    a specified age:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Joins and unions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working across multiple tables, you may often need to perform a join or
    union on your datasets. Joins and unions can be performed through query builder
    using the `join()` and `union()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The join method has the following method syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter, `$type`, specifies the join type you'd like to execute
    (for example, `INNER JOIN`, `LEFT JOIN`, or `OUTER JOIN`). The `$table` parameter
    specifies the table to be joined. The third parameter, `$on`, specifies the conditions
    on which the table should be joined and takes the syntax of the `where()` method,
    and the `$params` parameter specifies optional parameters to be bound to the join.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we had a posts and users table. We could join them as
    follows using the `join()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Assuming our database had both a user and post table, this would return a return
    containing a join of all users and their posts. The result would include all users
    joined with all the posts that they owned.
  prefs: []
  type: TYPE_NORMAL
- en: Joins can also be performed by type using the shortcut methods `rightJoin()`,
    `leftJoin()`, and `innerJoin()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same vein, unions of two different queries can be constructed by first
    building two separate `yii\db\Query` objects and then using the `union()` method
    on them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Executing queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After constructing our query with Query Builder, we'll need to specify the execution
    of our query. Yii2 provides the following query methods to execute queries built
    with Query Builder. The query methods are simply chained to the existing `$query`
    object, which will immediately result in their execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the times when working with Query Builder, we''ll want to fetch all
    the records in our database. This can be done by chaining the `all()` methods
    to our query object, which will retrieve all the records that fulfill the requirements
    of our `$query` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `$result` variable will then be populated with an array of rows, with each
    row containing an associated array of name-value key pairs for the resulting data.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Carefully consider using the `all()` method if you have a large dataset, as
    the resulting query execution could take a long time to complete, and it could
    either hang or cause an error in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other instances, it may be more beneficial just to fetch the first row of
    a query. To fetch the first row, we can use the `one()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: At other times, we may just want to know whether a query would result in any
    data. To achieve this, we can use the `exists()` method, which will return either
    `true` or `false`, indicating that data would be returned from the resulting query.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to know whether we have any users in our database,
    we can use the `exists()` query to check whether we had users before we performed
    any more complex queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the `count()` method to determine how many users
    exist in our database before running our query. The `count()` method will execute
    a `COUNT(*)` method within the `SELECT` fragment, and it will return a scalar
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with database expressions, such as `MIN()` and `MAX()`, or even
    more complex queries, you may find it useful to retrieve scalar values from query
    builder rather than an associative array. To fetch scalar values with query builder,
    we can use the `scalar()` method. For instance, if we want to know how old the
    oldest user is in our database using the `MAX()` SQL method, we can use the following
    code to return an integer representing their age:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we may find it beneficial to retrieve the first column of our database
    results, such as in the instance of using the `groupBy()` or `having()` methods.
    To fetch the first row of our results, we can use the `column()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, the first column of our user table is the `ID` field.
    Consequently, an array of all IDs in our database will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Selecting all columns (`*`) will result in all records being loaded into the
    memory, which, depending upon the size of the table, could result in performance
    degradation. It's important to remember when querying for data that you only query
    for the data you need. If you need all data, you query for it in iterative way
    such as to limit the memory required for each query.
  prefs: []
  type: TYPE_NORMAL
- en: Examining queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After building a query, you may want to examine the resulting query. To achieve
    this, the `createCommand()` method can be used to convert the Query Builder object
    into a DAO command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Iterating over query results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Often when working with large datasets, the resulting datasets may be too large
    to load into the memory. To keep the memory consumption low and to prevent our
    application from hanging, we can use either the `batch()` or `each()` method.
    By default, both methods will fetch 100 rows from the database. To change the
    number of rows to be fetched, simply change the first parameter of each method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: A `batch()` method supports fetching the data in batches, which can keep the
    memory down. Think of this method as a query appended with a limit and an offset
    parameter, which will restrict the number of returned rows. Each iteration of
    the `batch()` query will contain multiple results. Like the `batch()` method,
    the `each()` method can be used to reduce memory consumption as well, but it will
    iterate over the query row-by-row instead, which means that each iteration of
    the method will result in a single instance of our data.
  prefs: []
  type: TYPE_NORMAL
- en: Data providers and data widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Yii2, data providers are helper classes that are used to extract data via
    Query Builder to be passed to a data widget. The benefit of using data providers
    and data widgets over queries built via Query Builder is that they provide an
    interface to automatically deal with sorting and pagination.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common way to work with data providers is to use the `yii\data\ActiveDataProvider`
    class. Typically, `yii\data\ActiveDataProvider` will be used with Active Record
    models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll cover how to create and use Active Record and models in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Active data providers can also be populated through Query Builder, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Yii2 provides two additional data provider types: `yii\data\ActiveDataProvider`
    and `yii\data\SqlDataProvider`. For more information on these data providers,
    check out the Yii2 guide at [http://www.yiiframework.com/doc-2.0/guide-output-data-providers.html](http://www.yiiframework.com/doc-2.0/guide-output-data-providers.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have fetched our data with a data provider, we can pass the resulting
    data to a data widget. Data widgets in Yii2 are reusable building blocks used
    within views to create complex interfaces to interact with data. The most common
    data widgets are `DetailView`, `ListView`, and `GridView`, which behave similar
    to their Yii1 counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can take our previous data provider and output it in `GridView`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'By itself, our resulting `GridView` widget will display all the fields in our
    database table. In some instances, there may be sensitive data that we don''t
    want to display on this page. Alternatively, there could simply be too much data
    to display in `GridView`. To restrict the number of fields to display in our `GridView`
    widget, we can use the `columns` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '![Data providers and data widgets](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can further enhance our data providers using the `yii\data\Sort` class,
    which provides sorting capabilities to our data providers. To add sorting to our
    data provider, we''ll need to specify the sort parameter within `yii\data\ActiveDataProvider`
    with an instance of `yii\data\Sort`, which specifies the attributes that can be
    sorted against:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '![Data providers and data widgets](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As illustrated, the listed attributes within the `sort` attribute are now clickable
    and sortable through our data provider.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on output data widgets can be found in the Yii2 guide at [http://www.yiiframework.com/doc-2.0/guide-output-data-widgets.html](http://www.yiiframework.com/doc-2.0/guide-output-data-widgets.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'While some widgets, such as `GridView`, allow us to work with and display multiple
    rows, we can also use data providers and data widgets to display information for
    a single row. With the `DetailView` widget, we can dynamically configure a simple
    interface to display the information for a particular user in our database. The
    `getModels()` method of our data provider splits our data provider into individual
    models that our `DetailView` widget can understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typically when working with the `DetailView` widget, we'll supply it with an
    Active Record instance rather than a generated model from our data provider, which
    we'll cover in [Chapter 4](part0030_split_000.html#SJGS2-ad3e09b384df46aea690d9c8897d5fe7
    "Chapter 4. Active Record, Models, and Forms"), *Active Record, Models, and Forms*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be displayed on our screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data providers and data widgets](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to simply displaying results from a database, the `DetailView`
    widget also supports the custom formatting of certain rows. In our previous example,
    we were able to format our Unix timestamp stored in the `updated_at` field as
    human-readable date and time fields by specifying the `:datetime` formatter in
    our updated field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The formatter listed here is a powerful tool that allows us to quickly convert
    raw data into useful human-readable information. More information on the formatter
    can be found at [http://www.yiiframework.com/doc-2.0/yii-i18n-formatter.html](http://www.yiiframework.com/doc-2.0/yii-i18n-formatter.html).
  prefs: []
  type: TYPE_NORMAL
- en: Data replication and load balancing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we start working with larger and larger systems, we often find the need to
    build an additional redundancy into our system in order to enable high availability
    and protection against unexpected downtime. When working with large systems, we
    will split our database into a read-and-write master and a read-only slave of
    a set of slaves. Typically, our applications are unaware of our database architecture,
    which can introduce problems when required to migrate from a new master. With
    Yii2, we can configure our database connection to not only be aware of our master-slave
    database configuration, but also intelligently handle slave unavailability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Yii2, we can configure a single master and multiple slaves using the following
    database configuration. This will result in all writes going to our declared master
    and all reads going to one of our declared slaves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, queries executed with the `execute()` method will run against the
    master, whereas all other queries will run against one of the slaves.
  prefs: []
  type: TYPE_NORMAL
- en: In this configuration, Yii will execute write queries (such as `UPDATE`, `INSERT`,
    and `DELETE`) against the master and run a read query (such as `SELECT`) against
    one of the available slaves. When working with slaves, Yii will attempt to connect
    to slaves in the list until a slave responds and load balance queries against
    each of the available slaves. By setting `PDO::ATTR_TIMEOUT` equal to 10 seconds,
    Yii will abort trying to retrieve data from a slave if it receives no response
    within 10 seconds, and it will remember the state of the slave for the duration
    that the configuration is in effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, using the following configuration, we can configure our application
    to work with both multiple masters and multiple slaves. When using multiple masters,
    Yii will execute writes against any available master and will load balance writes
    between the available masters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If Yii2 is unable to connect to any of the available masters, an exception will
    be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with a master-slave topology, we may want to issue a read query
    against one of our masters. To do that, we would need to explicitly tell Yii2
    to run our query against our master rather than our slaves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with transactions, Yii2 will try to run transactions against our
    master by default. If we need to issue a transaction against a slave, we will
    need to explicitly begin the transaction on a slave, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the foundations of working with databases in Yii2\.
    By working with database access objects, we showed how we can execute raw SQL
    statements to run against our database and how we can use transactions to protect
    our database integrity. We also illustrated the use of Query Builder, which can
    enable us to write database-agnostic queries in a programmatic way. We then discovered
    how we can use Query Builder to construct intelligent data providers, which are
    used to supply data to reusable data widgets. Finally, we learned how to configure
    Yii2 to be aware of master-slave and multi-master database cluster configurations
    and how to load balance between these connections.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we discover the capstone of working with databases in Yii2—Active
    Record—which is a powerful tool used to work with our data and model our database
    structure. We'll also dive into Active Records relatives, basic models, and forms,
    and we'll learn how we can use a powerful tool called Gii to automate the construction
    of much of the code our modern applications will work with.
  prefs: []
  type: TYPE_NORMAL
