- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up Our Local Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a developer, you probably already know that one of the key skillsets that
    you need to start programming is to install the programming language itself onto
    your computer. We need a way to start testing code besides our head, as our brains
    are not the best language compilers. But what does installing the language really
    mean?
  prefs: []
  type: TYPE_NORMAL
- en: Coming from PHP, this could mean installing the binary interpreter of PHP on
    our computer so that we can run PHP, open a browser, and then away we go. Or it
    could mean downloading the PHP source code, compiling it, and generating our own
    binary with the compilation options we choose. In Ruby, we not only have very
    similar options to these, but also many more ways to install the Ruby interpreter
    on our local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore different ways of setting up our development
    environments. We will analyze the pros and cons of each to give you different
    options to choose from so that any errors will be consistent between developers,
    in order to avoid the wretched phrase all developers have heard and unfortunately
    used: *“It works on* *my machine.”*'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ruby locally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a virtual machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using rbenv
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with this chapter, we will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Any IDE to view/edit code (e.g. SublimeText, Visual Studio Code, Notepad++ Vim,
    Emacs, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For macOS users, you will also need to have the Xcode Command Line Tools installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code presented in this chapter is available at [https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ruby locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are ready to set up our Ruby environment. Probably the most convenient way
    to install Ruby on our machines is with a package manager or an installer, depending
    on your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: macOS users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For macOS users, the brew package manager is the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install brew, using the Finder window, navigate to the **Applications**
    folder, then to the **Utilities** folder, and then scroll until you find **Terminal**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: The Application Utilities](img/B19230_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: The Application Utilities'
  prefs: []
  type: TYPE_NORMAL
- en: 'Double click on the **Terminal** icon and you should see a Terminal with a
    shell prompt waiting for commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: The Terminal](img/B19230_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: The Terminal'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then copy the command from the brew homepage ([https://brew.sh/](https://brew.sh/))
    that you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: Homebrew installing instructions](img/B19230_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Homebrew installing instructions'
  prefs: []
  type: TYPE_NORMAL
- en: Now paste the command into the Terminal to install brew.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once brew is installed, installing Ruby (or its variations) is easy. If brew
    was already installed, you might just want to update it by running the `brew update`
    command. You may have to open up a new Terminal window, but once you’ve done that,
    you can install Ruby by simply running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code shown here has been redacted for brevity and may vary from version
    to version of macOS, but in essence, you should see the same (or very similar)
    output after brew has been installed. As long as there are no errors, you should
    be good to go. As a side note, I’d like to emphasize that brew is a package manager
    used by many developers working on macOS and some Linux environments, but it’s
    not the only path to install Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: As a last step we should open up a new Terminal window. This will load the `$PATH`
    variable again and make Ruby available for us to use. This a very pragmatic way
    of installing Ruby because we can start using the Ruby interpreter right away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s confirm that Ruby is in fact installed. In the Terminal, type the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return the Ruby version that was installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have successfully installed Ruby. Nowadays, most Macs already come with Ruby
    installed out of the box. However, it is an outdated version of Ruby, therefore
    it’s still a good practice exercise to install it on our own.
  prefs: []
  type: TYPE_NORMAL
- en: Windows users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Windows users, the simplest way to install Ruby is with an installer from
    [https://rubyinstaller.org/](https://rubyinstaller.org/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: Ruby Windows installer](img/B19230_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Ruby Windows installer'
  prefs: []
  type: TYPE_NORMAL
- en: 'I chose the latest version as it is best practice to install this one, or at
    least the latest stable version. Be sure to select the correct version (either
    32-bit or 64-bit) depending on your machine architecture. Once it’s downloaded,
    double-click on the installer and you will see this screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5: Windows Installer License Agreement](img/B19230_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Windows Installer License Agreement'
  prefs: []
  type: TYPE_NORMAL
- en: Accept the license and click **Next**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then choose the default options for the location and the addition of the binary
    to our PATH:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6: Windows Installer installation location](img/B19230_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Windows Installer installation location'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, select **Install**. Once this process is finished, we are prompted
    with a **Run ‘ridk** **install’** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7: Windows Installer finishing the setup](img/B19230_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Windows Installer finishing the setup'
  prefs: []
  type: TYPE_NORMAL
- en: 'While `sh`, `make`, and `gcc` available. These tools need to be compiled for
    some libraries (or gems) that we may use in the future. By setting this option,
    we will have another prompt pop up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8: MSYS2 installation prompt](img/B19230_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: MSYS2 installation prompt'
  prefs: []
  type: TYPE_NORMAL
- en: Press *Enter* for all options until the installation is done. These options
    install and update MSYS2, which provides a Unix-like environment for compatibility
    with software built on Windows systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once done, make sure that Ruby was installed correctly. To do this, open Windows
    PowerShell. Then use the `ruby -v` command, and you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9: Windows Ruby version confirmation](img/B19230_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Windows Ruby version confirmation'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have confirmed that Ruby is installed correctly on our Windows
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Linux users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For Linux users, we have different distributions and while some of them share
    package managers, for the most part, each family uses its own package manager.
    As an example, the Red Hat family distros (Red Hat and CentOS) use `yum`, Ubuntu
    uses `apt`, and Debian uses `dpk` but also supports `apt`. We are going to focus
    on the most popular distribution used as a desktop operating system, which is
    Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Ubuntu, navigate to the `sudo apt install ruby`. Ubuntu will then confirm
    that you are in fact trying to install Ruby. When this confirmation comes up,
    just type *Y*, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10: Ruby installation prompt](img/B19230_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Ruby installation prompt'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `sudo` command because we require root privileges to install applications
    on our system. It might take a while to install depending on our internet speed
    and machine’s specifications but once the process is finished, let’s again verify
    the installation with `ruby -v`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11: Ubuntu Ruby version confirmation](img/B19230_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: Ubuntu Ruby version confirmation'
  prefs: []
  type: TYPE_NORMAL
- en: So, there we have it, you now know how to install Ruby on whichever operating
    system you use. Let’s now take a look at using a virtual environment to work with
    Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: Using a virtual machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to install Ruby on our own local machine, that is,
    the machine we use daily for work. This is the best way to install Ruby when starting
    out, but once you start working on more complex applications and with other developers,
    you will want to have consistency in the behavior of everyone’s local environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why, you may ask? The simple answer is that we want to avoid the dreaded phrase
    that all developers have either heard or even used at some point in our careers:
    *“It works on my machine.”* What is important to remember is that every local
    environment is different, from the processor to the OS version and Ruby version,
    and this can get in the way of more important work.'
  prefs: []
  type: TYPE_NORMAL
- en: As an example that I personally experienced, we once wasted almost a week when
    we deployed a PHP application to a Linux server that was developed on Windows
    local machines. The problem was that one of the developers forgot that Windows
    (at the time) did not distinguish between uppercase and lowercase letters in folder
    names. While this might seem a silly example, we should try to avoid these issues
    as much as we can, as time can quickly be wasted while dealing with issues of
    this nature.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization can play an important role in the creation of equivalent environments
    between the developers in your team, and fortunately, we have several options
    that we can explore in the virtual realm to help us with this.
  prefs: []
  type: TYPE_NORMAL
- en: VMware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first option is VMware ([https://vmware.com](https://vmware.com)). VMware
    lets you emulate a complete operating system within your machine. This setup,
    of course, takes longer than the others as you have to first install VMware, create
    a virtual machine, then install the operating system within this virtual machine,
    and then install Ruby. It would be certainly complex and time consuming, but once
    you have it up and running, you can share the environment with other members of
    your team. This would mean that everyone in the team would have the exact same
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: VirtualBox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: VirtualBox ([https://www.virtualbox.org](https://www.virtualbox.org)) is an
    Oracle product that behaves and has a similar workflow to VMware. Some people
    prefer VirtualBox and others prefer VMware. In my personal experience, VirtualBox
    is the better choice for beginners as it is open source, free to use, has a better
    UI, and works great for small to mid-sized projects.
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Vagrant ([https://www.vagrantup.com/](https://www.vagrantup.com/)) is a tool
    that helps us automate and manage our environments. Both VMware and VirtualBox
    have mechanisms in place to be able to share files and other resources with our
    host machine; however, they’re not that easy to use, and sometimes it take up
    a lot of time to configure them. Vagrant comes in to solve that: it lets us specify
    shared folders between our local machine and the virtual one, allows us to replicate
    configurations through a configuration file, and also makes it much easier to
    connect to the virtual machine. The coolest part is that Vagrant can work seamlessly
    with both VMware and VirtualBox.'
  prefs: []
  type: TYPE_NORMAL
- en: Laravel developers might be familiar with Vagrant as Homestead can be set up
    with VirtualBox. Even if you are not going to use this option as it may not be
    very practical, I would recommend at least trying it once to play around with
    Ruby on an operating system other than the one you have installed on your machine.
    This type of virtualization consumes a lot of resources, including memory, processor,
    and even disk space. It’s a high price to pay for convenience, but worthwhile
    in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'As this goes beyond the scope of the book and is not necessary for initial
    Ruby developers; we will not be looking at how to carry out such installations.
    But it does make sense for a newbie Ruby developer to at least be familiar with
    these tools, only if by name. Should you be more curious about these implementations,
    particularly Vagrant and VirtualBox, you might want to head to the following site:
    [https://www.taniarascia.com/what-are-vagrant-and-virtualbox-and-how-do-i-use-them/](https://www.taniarascia.com/what-are-vagrant-and-virtualbox-and-how-do-i-use-them/).'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, there is a different type of virtualization provided by Docker, which
    is lighter than both VMware and VirtualBox, and this is what we will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker ([https://www.docker.com/](https://www.docker.com/)) is yet another
    virtualization technology that has become the go-to option for a lot of medium
    and large enterprises. While it’s still a virtualized environment and comes with
    its own set of disadvantages, the advantages overshadow them. Let’s take a look
    at a few advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker is not fully virtual – it creates a container that shares resources with
    the host in which it is running. Because of this, it runs significantly faster
    than a virtualized environment. I’m oversimplifying the Docker technology, but
    in essence it’s an improved (in my opinion) virtualized environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can package your Docker environment into a Docker image (similar to a virtual
    machine), which can be deployed and used by others with ease.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the advent of cloud computing, Docker has become more and more popular.
    Amazon (AWS), Microsoft (Azure), and Google (GCP) all support Docker and little
    by little have made it much easier to implement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Docker, you can replicate practically any error that occurred on another
    developer’s machine, as well as in production environments (given the correct
    circumstances). Imagine a hypothetical developer world where you can take a production
    server and test things there, making sure that any error that was seen in the
    past is corrected before showing it to the public. Well, this is almost possible
    with Docker. Certainly, I’m simplifying the process, but essentially, the Docker
    image you use locally has the potential to be the same image used in production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main disadvantage with Docker is that it’s more complicated to understand
    how to use images and containers and build microservices. If you’ve never heard
    of microservices, the concept might take you aback as they are different than
    traditional applications and deployments. Microservices are an architectural style
    used to build applications by separating the application into a collection of
    services. Docker Compose might make it easier to implement microservices locally,
    but it’s still a complex topic.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Should you be more interested in the topic of microservices, you should take
    look at [https://microservices.io/](https://microservices.io/).
  prefs: []
  type: TYPE_NORMAL
- en: I honestly think it’s worth exploring Docker more than other virtualization
    options simply because it’s gained so much popularity among the developer and
    infrastructure communities.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we won’t take a deep dive into Docker, we can take some baby steps to
    learn how to use it on our local environment. The first step is to install Docker
    through an installer or package manager. Depending on your OS and distribution,
    use one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Mac: [https://docs.docker.com/desktop/install/mac-install/](https://docs.docker.com/desktop/install/mac-install/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Windows: [https://docs.docker.com/desktop/install/windows-install/](https://docs.docker.com/desktop/install/windows-install/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Linux: [https://docs.docker.com/desktop/install/linux-install/](https://docs.docker.com/desktop/install/linux-install/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After that, we can run the following command to verify that Docker has been
    installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return the current Docker version found on your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Docker is available, we can download a Ruby image and run a Ruby command
    with this one liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are telling the Docker agent to get the latest Ruby Docker image and
    then run `ruby -v`. The command should output something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first time you run this command, it might take a while because it will have
    to download the Ruby Docker image. Once the Docker image is downloaded, it starts
    a container with said image and runs the command. Once the command has been run,
    the container is halted.
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we have successfully run a Ruby command with Docker. While actually
    using Docker for development in a more practical way is more complicated, this
    is a great starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen a couple of options to set up our local environment, we’ll
    move to the next essential tool for Ruby development, that is, rbenv.
  prefs: []
  type: TYPE_NORMAL
- en: Using rbenv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While it is highly recommended to use some sort of homogeneous environment
    for all members of the team (such as the virtual ones previously mentioned), a
    simpler and quicker way to create equivalent environments is to use some sort
    of Ruby version management tool. These types of tools allow us to install different
    versions of Ruby and for the most part will behave similarly, even if they are
    installed on different operating systems. We have a couple of options, but for
    simplicity, we will use rbenv: [https://github.com/rbenv/rbenv](https://github.com/rbenv/rbenv).'
  prefs: []
  type: TYPE_NORMAL
- en: 'rbenv allows us to install multiple versions of Ruby and manage these versions.
    By *managing them*, I mean we can define what version of Ruby the whole system
    uses (global), or we can define a specific version to be used on each project
    (local). For macOS and Linux users, you should follow the instructions on the
    previously mentioned GitHub repository, which also serves as the official website.
    If you run into any issues while trying to install the tool, you could also follow
    these two tutorials for installing rbenv:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.digitalocean.com/community/tutorials/how-to-install-ruby-on-rails-with-rbenv-on-macos](https://www.digitalocean.com/community/tutorials/how-to-install-ruby-on-rails-with-rbenv-on-macos)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://collectionbuilder.github.io/cb-docs/docs/software/ruby_mac/](https://collectionbuilder.github.io/cb-docs/docs/software/ruby_mac/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lastly, for Windows users, we have rbenv-for-windows: [https://github.com/ccmywish/rbenv-for-windows](https://github.com/ccmywish/rbenv-for-windows).'
  prefs: []
  type: TYPE_NORMAL
- en: Beware that the version for Windows might be a little limited and you may encounter
    issues with certain versions of Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we’ve installed rbenv, we should list the Ruby versions we have installed
    on the machine. Let’s open a shell and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This should show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output means that we only have one version of Ruby installed.
    Let’s add Ruby 2.6.10 to use throughout the examples of this book. We’ll do so
    by typing the following command on the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This should throw the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have Ruby 2.6.10 available for use, we can start using said version
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the preceding command has been run, make sure to test it with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This should show the current version of Ruby to be 2.6.10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The output may vary from system to system, but the version should be the same.
    I won’t dwell too much on how rbenv works, but I will say that by running this
    command on a folder, any work you do while in said folder (or subfolders within
    this folder) will have Ruby 2.6.10 for use. If we move to a different folder,
    the Ruby version available will be different. It’s an important best practice
    to set the Ruby version for each project and not just rely on the one installed
    on the computer. Switching Ruby versions is now as easy as installing the required
    version and applying said version with the aforementioned command. For the exercises
    in this book, I highly recommend relying on rbenv.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative to rbenv, we have rvm: https://rvm.io/.'
  prefs: []
  type: TYPE_NORMAL
- en: However, I highly recommend choosing rbenv over rvm as most developers use rbenv.
    You can give rvm a try, if you’re up to the challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve learned how to install Ruby on macOS, Windows, and Linux systems.
    While some operating systems may already come with Ruby installed, it is almost
    always outdated. We should always install the latest version of Ruby, as installing
    Ruby is part of our own development process as Ruby developers.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about virtualization with VMware, VirtualBox, and Docker. I
    want to point out that the theory regarding virtualization technologies might
    be a little overwhelming for a beginner developer – I personally did not work
    with any of these virtual technologies when I started with Ruby, mainly because
    it was not a practical option, but also because they had not become so popular
    at that time – but I can now confidently say that I wish I had had those resources
    when I started, as it would have saved me some major headaches. Having said that,
    I can guarantee you that they will come in handy (at least Docker), but to start
    programming in Ruby they are not compulsory. Lastly, we learned about rbenv, its
    basic commands, and why it has become the go-to Ruby version manager in the Ruby
    community.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on to our next chapter, we are now ready to start writing some Ruby ourselves.
    We will also take a look at the Ruby syntax compared to PHP and analyze how we
    can take advantage of what we already know from PHP and port it to Ruby. Lastly,
    we will learn about the Ruby language enhancements that PHP does not have but
    which make perfect sense in the Ruby world.
  prefs: []
  type: TYPE_NORMAL
