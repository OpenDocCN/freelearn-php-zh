- en: Chapter 12. Building a Module from Scratch
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章. 从零开始构建模块
- en: 'Based on the knowledge acquired from previous chapters, we will now build a
    miniature `Helpdesk` module. Though miniature, the module will showcase the usage
    of several important Magento platform features as we go through the following
    sections:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前几章获得的知识，我们现在将构建一个微型`Helpdesk`模块。虽然这个模块是微型的，但我们将通过以下部分展示几个重要的Magento平台功能的用法：
- en: Registering a module (`registration.php` and `module.xml`)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册模块（`registration.php`和`module.xml`）
- en: Creating a configuration file (`config.xml`)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建配置文件（`config.xml`）
- en: Creating e-mail templates (`email_templates.xml`)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建电子邮件模板（`email_templates.xml`）
- en: Creating a system configuration file (`system.xml`)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建系统配置文件（`system.xml`）
- en: Creating access control lists (`acl.xml`)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建访问控制列表（`acl.xml`）
- en: Creating an installation script (`InstallSchema.php`)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建安装脚本（`InstallSchema.php`）
- en: Managing entity persistence (model, resource, collection)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理实体持久性（模型、资源、集合）
- en: Building a frontend interface
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建前端界面
- en: Building a backend interface
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建后端界面
- en: Creating unit tests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建单元测试
- en: Module requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块要求
- en: 'Module requirements are defined as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 模块要求定义如下：
- en: Name used, `Foggyline/Helpdesk`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的名称，`Foggyline/Helpdesk`
- en: Data to be stored in table is called `foggyline_helpdesk_ticket`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要存储在表中的数据称为`foggyline_helpdesk_ticket`
- en: Tickets entity will contain `ticket_id`, `customer_id`, `title`, `severity`,
    `created_at`, and `status` properties
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工单实体将包含`ticket_id`、`customer_id`、`title`、`severity`、`created_at`和`status`属性
- en: The `customer_id` property is to be foreign key on the `customer_entity` table
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer_id`属性将在`customer_entity`表上作为外键'
- en: 'There will be three available ticket severity values: `low`, `medium`, and
    `high`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将有三个可用的工单严重性值：`低`、`中`和`高`
- en: If not specified, the default severity value for new tickets is `low`
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未指定，新工单的默认严重性值为`低`
- en: 'There will be two available ticket statuses: `opened` and `closed`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将有两个可用的工单状态：`已打开`和`已关闭`
- en: If not specified, the default status value for new tickets is `opened`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未指定，新工单的默认状态值为`已打开`
- en: 'Two e-mails templates: `store_owner_to_customer_email_template` and `customer_to_store_owner_email_template`
    are to be defined for pushing e-mail updates upon ticket creation and status change'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要定义两个电子邮件模板：`store_owner_to_customer_email_template`和`customer_to_store_owner_email_template`，以便在创建工单和状态更改时推送电子邮件更新
- en: Customers will be able to submit a ticket through their **My Account** section
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户将能够通过他们的**我的账户**部分提交工单
- en: Customers will be able to see all of their previously submitted tickets under
    their **My Account** section
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户将能够在他们的**我的账户**部分查看他们之前提交的所有工单
- en: Customers will not be able to edit any existing tickets
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户将无法编辑任何现有的工单
- en: Once a customer submits a new ticket, transactional e-mail (let's call it **Foggyline**
    – **Helpdesk** – **Customer** | **Store Owner**) is sent to the store owner
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦客户提交了新的工单，就会发送事务性电子邮件（我们可以称之为**Foggyline** – **帮助台** – **客户** | **店主**）给店主
- en: Configurable option is required for possibly overriding **Foggyline** – **Helpdesk**
    – **Customer** | **Store Owner** e-mail
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个可配置的选项，以可能覆盖**Foggyline** – **帮助台** – **客户** | **店主**电子邮件
- en: Admin users will be able to access a list of all tickets under **Customers**
    | **Helpdesk Tickets**
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员用户将能够访问**客户** | **帮助台工单**下的所有工单列表
- en: Admin users will be able to change ticket status from **Opened** to **Closed**
    and other way round
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员用户将能够将工单状态从**已打开**更改为**已关闭**，反之亦然
- en: Once an admin user changes the ticket status, transactional e-mail (let's call
    it **Foggyline** – **Helpdesk** – **Store Owner** | **Customer**) is sent to the
    customer
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦管理员用户更改了工单状态，就会发送事务性电子邮件（我们可以称之为**Foggyline** – **帮助台** – **店主** | **客户**）给客户
- en: Configurable option is required for possibly overriding **Foggyline** – **Helpdesk**
    – **Store Owner** | **Customer** e-mail
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个可配置的选项，以可能覆盖**Foggyline** – **帮助台** – **店主** | **客户**电子邮件
- en: With the requirements outlined, we are ready to begin our module development.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据概述的要求，我们已准备好开始我们的模块开发。
- en: Registering a module
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册模块
- en: 'We first start by defining the `app/code/Foggyline/Helpdesk/registration.php`
    file with the following content:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先开始定义`app/code/Foggyline/Helpdesk/registration.php`文件，内容如下：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We then define the `app/code/Foggyline/Helpdesk/etc/module.xml` file with the
    following content:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后定义了`app/code/Foggyline/Helpdesk/etc/module.xml`文件，内容如下：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Looking at the preceding file, if we strip away the boilerplate that repeats
    itself across all modules, we are left with three important things here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面的文件，如果我们移除所有模块中重复的样板内容，我们在这里剩下三个重要的事情：
- en: The module name attribute, defined as `Foggyline_Helpdesk`. We need to be sure
    to follow a certain pattern when naming our modules, like `Vendor` + `_` + `Module`
    name. The module name attribute can contain only letters and numbers [A-Z, a-z,
    0-9, _].
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块名称属性，定义为`Foggyline_Helpdesk`。我们需要确保在命名我们的模块时遵循一定的模式，例如`Vendor` + `_` + `Module`名称。模块名称属性只能包含字母和数字
    [A-Z, a-z, 0-9, _]。
- en: The schema `setup_version` attribute that defines our module version. Its value
    can contain only numbers [0-9]. Our example sets the value of `1.0.0` for the
    `setup_version` attribute.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义我们的模块版本的`setup_version`属性。其值只能包含数字 [0-9]。我们的示例将`setup_version`属性的值设置为`1.0.0`。
- en: The sequence module name attribute, which defines module dependencies. Our module
    basically says it requires `Magento_Store` and `Magento_Customer` modules to be
    enabled.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义模块依赖关系的模块名称属性。我们的模块基本上表示它需要启用`Magento_Store`和`Magento_Customer`模块。
- en: 'Once this file is in place, we need to go to the command line, change the directory
    to that of Magento installation, and simply execute the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个文件就绪，我们需要转到命令行，将目录更改为Magento安装目录，然后简单地执行以下命令：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, if we now open either the admin of the frontend area in our browser,
    we might get an error page, which generates the following error under the `var/reports/`
    folder:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们现在在浏览器中打开前端区域的任何管理页面，我们可能会得到一个错误页面，该页面在`var/reports/`文件夹下生成以下错误：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Luckily, the error is pretty self-descriptive so we simply move back to the
    console, change the directory to the Magento root folder, and execute the following
    command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，错误信息相当自描述，所以我们只需简单地回到控制台，将目录更改为Magento根目录，并执行以下命令：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Executed commands will activate our module.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的命令将激活我们的模块。
- en: 'We can confirm that by looking under the `app/etc/config.php` file, as shown
    in the following screenshot (on line 33):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看以下截图中的`app/etc/config.php`文件来确认这一点（在第33行）：
- en: '![Registering a module](img/00095.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![注册模块](img/00095.jpeg)'
- en: 'Further if we log in to the admin area, and go to **Stores** | **Configuration**
    | **Advanced** | **Advanced**, we should see our module listed there, as shown
    in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步地，如果我们登录到管理区域，并转到**商店** | **配置** | **高级** | **高级**，我们应该在那里看到我们的模块列表，如下面的截图所示：
- en: '![Registering a module](img/00096.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![注册模块](img/00096.jpeg)'
- en: Creating a configuration file (config.xml)
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建配置文件（config.xml）
- en: 'Now we will create an `app/code/Foggyline/Helpdesk/etc/config.xml` file with
    the content, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个包含以下内容的`app/code/Foggyline/Helpdesk/etc/config.xml`文件：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This might look confusing at first as to where the `default` | `foggyline_helpdesk`
    | `email_template` structure comes from. The structure itself denotes the position
    of our configuration values that we will map to the administrative interface visible
    in our browser under the **Stores** | **Configuration** section. Given that all
    things visual regarding the **Stores** | **Configuration** section originate from
    `system.xml` files, this structure we have now in `config.xml` will then map to
    another `system.xml` file we will define soon.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能一开始看起来很困惑，不知道`default` | `foggyline_helpdesk` | `email_template`结构从何而来。这个结构本身表示我们将映射到浏览器中**商店**
    | **配置**部分可见的配置值的位臵。鉴于与**商店** | **配置**部分相关的所有视觉元素都源自`system.xml`文件，我们现在在`config.xml`中的这个结构将映射到我们即将定义的另一个`system.xml`文件。
- en: Right now, just remember the structure and the values contained within the `customer`
    and `store_owner` attributes. These values will further map to another `email_templates.xml`
    file, which we will soon create.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只需记住`customer`和`store_owner`属性中的结构和值。这些值将进一步映射到我们即将创建的另一个`email_templates.xml`文件。
- en: There is one more important thing regarding the `config.xml` file. We need to
    be very careful of the `xsi:noNamespaceSchemaLocation` attribute value. This value
    needs to be set to `urn:magento:module:Magento_Store:etc/config.xsd`. It's an
    alias that actually points to the `vendor/magento/module-store/etc/config.xsd`
    file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`config.xml`文件，还有一件更重要的事情。我们需要非常小心地处理`xsi:noNamespaceSchemaLocation`属性值。此值需要设置为`urn:magento:module:Magento_Store:etc/config.xsd`。这是一个别名，实际上指向`vendor/magento/module-store/etc/config.xsd`文件。
- en: Creating e-mail templates (email_templates.xml)
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建电子邮件模板（email_templates.xml）
- en: 'Our module requirements specify that two e-mail templates need to be defined.
    Hints to this have already been given in the `app/code/Foggyline/Helpdesk/etc/config.xml`
    file previously defined. The actual definition of e-mail templates available to
    our modules is done through the `app/code/Foggyline/Helpdesk/etc/email_templates.xml
    file`, with the content as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模块的要求指定需要定义两个电子邮件模板。关于这一点，在之前定义的 `app/code/Foggyline/Helpdesk/etc/config.xml`
    文件中已经给出了提示。我们模块可用的电子邮件模板的实际定义是通过 `app/code/Foggyline/Helpdesk/etc/email_templates.xml`
    文件完成的，内容如下：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Looking into `email_templates.xsd`, we can conclude that the values for `id`,
    `label`, `file`, `type`, and `module` are all required. `id` should be defined
    unique to our module, giving some sensible and reasonable code name to our e-mail
    templates, as this code name is going to be used further in other XML files or
    in code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `email_templates.xsd`，我们可以得出结论，`id`、`label`、`file`、`type` 和 `module` 的值都是必需的。`id`
    应该定义为我们模块的唯一值，给我们的电子邮件模板起一个合理且合理的代码名称，因为这个代码名称将在其他 XML 文件或代码中进一步使用。
- en: What we defined as ID values here, can be found under `app/code/Foggyline/Helpdesk/etc/config.xml`,
    as the value of `default` | `foggyline_helpdesk` | `email_template` | `customer`
    and `default` | `foggyline_helpdesk` | `email_template` | `store_owner` elements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义的 ID 值可以在 `app/code/Foggyline/Helpdesk/etc/config.xml` 中找到，作为 `default`
    | `foggyline_helpdesk` | `email_template` | `customer` 和 `default` | `foggyline_helpdesk`
    | `email_template` | `store_owner` 元素的值。
- en: If it is not yet fully clear what the connection between the two is; we will
    get to it when we start building our `system.xml` file soon.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个之间的联系还不完全清楚；当我们开始构建我们的 `system.xml` 文件时，我们将很快了解到这一点。
- en: The value of the `label` attribute is something that is visible later on, within
    the Magento admin area under **Marketing** | **Communications** | **Email Templates**,
    so be sure to put something user friendly and easily recognizable here.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`label` 属性的值是稍后在 Magento 管理区域 **营销** | **通讯** | **电子邮件模板** 中可见的内容，所以请确保在这里放置一些用户友好且易于识别的内容。'
- en: 'Further, the values of the `file` attribute point to the location of the following
    files:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`file` 属性的值指向以下文件的位置：
- en: '`app/code/Foggyline/Helpdesk/view/frontend/email/customer_to_store_owner.html`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app/code/Foggyline/Helpdesk/view/frontend/email/customer_to_store_owner.html`'
- en: '`app/code/Foggyline/Helpdesk/view/frontend/email/store_owner_to_customer.html`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app/code/Foggyline/Helpdesk/view/frontend/email/store_owner_to_customer.html`'
- en: The content of the files will be set such that later on, in the code, we will
    need to pass it on certain variables in order to fill in the variable placeholders.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的内容将被设置为，稍后，在代码中，我们需要传递某些变量以填充变量占位符。
- en: 'The `customer_to_store_owner.html` e-mail template, with content as follows,
    will be triggered later on in the code when a customer creates a new ticket:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`customer_to_store_owner.html` 电子邮件模板，内容如下，将在代码中稍后触发，当客户创建新的票据时：'
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Later on, we will see how to pass the `ticket` object as a variable into the
    template, in order to enable calls like `{{var ticket.title}}` within the HTML
    template.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将看到如何将 `ticket` 对象作为变量传递到模板中，以便在 HTML 模板中启用 `{{var ticket.title}}` 这样的调用。
- en: 'The `store_owner_to_customer.html` e-mail template, with content as follows,
    will be triggered later on in the code when the store owner changes the status
    of a ticket:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`store_owner_to_customer.html` 电子邮件模板，内容如下，将在代码中稍后触发，当店主更改票据状态时：'
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we now log in to the Magento admin area, go under **Marketing** | **Communications**
    | **Email Templates**, click on the **Add New Template** button, and we should
    be able to see our two e-mail templates under the **Template** drop-down, as shown
    in the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在登录到 Magento 管理区域，进入 **营销** | **通讯** | **电子邮件模板**，点击 **添加新模板** 按钮，我们应该能够在
    **模板** 下拉菜单中看到我们的两个电子邮件模板，如图所示：
- en: '![Creating e-mail templates (email_templates.xml)](img/00097.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![创建电子邮件模板（email_templates.xml）](img/00097.jpeg)'
- en: 'If we look back at our `config.xml` and `email_templates.xml`, there is still
    no clear connection as to what `default` | `foggyline_helpdesk` | `email_template`
    | `customer` and `default` | `foggyline_helpdesk` | `email_template` | `store_owner`
    under `config.xml` actually do. That is because we still lack two more ingredients
    that will link them together: the `app/code/Foggyline/Helpdesk/etc/adminhtml/system.xml`
    and `app/code/Foggyline/Helpdesk/etc/acl.xml files`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下我们的 `config.xml` 和 `email_templates.xml`，仍然没有明确的联系，不清楚 `default` | `foggyline_helpdesk`
    | `email_template` | `customer` 和 `default` | `foggyline_helpdesk` | `email_template`
    | `store_owner` 在 `config.xml` 中实际上代表什么。这是因为我们仍然缺少两个将它们联系起来的关键成分：`app/code/Foggyline/Helpdesk/etc/adminhtml/system.xml`
    和 `app/code/Foggyline/Helpdesk/etc/acl.xml` 文件。
- en: Creating a system configuration file (system.xml)
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建系统配置文件（system.xml）
- en: The `system.xml` file is essentially the **Stores** | **Configuration** interface
    builder. Entries we define in our module's `system.xml` file will render certain
    parts of the **Stores** | **Configuration** interface under the Magento admin
    area.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`system.xml` 文件本质上是一个 **商店** | **配置** 接口构建器。我们在模块的 `system.xml` 文件中定义的条目将在
    Magento 管理区域下的 **商店** | **配置** 接口中渲染某些部分。'
- en: 'Unlike the previous two XML files, this configuration file is located under
    an additional subfolder, so its full path goes like `app/code/Foggyline/Helpdesk/etc/adminhtml/system.xml`,
    with content as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与前两个 XML 文件不同，此配置文件位于一个额外的子文件夹中，因此其完整路径为 `app/code/Foggyline/Helpdesk/etc/adminhtml/system.xml`，内容如下：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Even though we have a lot going on in this file, it can all be summed up in
    a few important bits.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个文件中有很多事情，但都可以总结为几个重要点。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Determining where we want to show our module configuration options is a matter
    of choice. Either we define and use our own tab or we use an existing tab from
    one of the core modules. It really comes down to where we decide to put our configuration
    options.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 确定我们想要显示我们的模块配置选项的位置是一个选择问题。要么我们定义并使用自己的标签，要么我们使用核心模块中的一个现有标签。这实际上取决于我们决定将配置选项放在哪里。
- en: '`system.xml` defines one tab, as noted by the tab element assigned `id` attribute
    value of `foggyline`. We can have multiple tabs defined under a single `system.xml`
    file. The tab element attribute `id` needs to be unique under all tabs, not just
    those defined within our module. Within the `tab` element, we have a `label` element
    with the value of `Foggyline`. This value is what shows up under the Magento admin
    **Stores** | **Configuration** area.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`system.xml` 定义了一个标签，正如分配了 `id` 属性值为 `foggyline` 的标签元素所示。我们可以在单个 `system.xml`
    文件下定义多个标签。标签元素属性 `id` 需要在所有标签中都是唯一的，而不仅仅是我们在模块中定义的标签。在 `tab` 元素内，我们有一个 `label`
    元素，其值为 `Foggyline`。这个值是显示在 Magento 管理界面 **商店** | **配置** 区域的内容。'
- en: 'The final results should be as shown in the following image:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果应如图所示：
- en: '![Creating a system configuration file (system.xml)](img/00098.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![创建系统配置文件（system.xml）](img/00098.jpeg)'
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Magento has six pre-existing tabs defined (**General**, **Service**, **Advanced**,
    **Catalog**, **Customer**, **Sales**) across its core modules. We can easily get
    a list of all defined tabs in Magento just by doing a search for the `tab` string,
    filtering only on files named `system.xml`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Magento 在其核心模块中定义了六个预存在的标签（**通用**、**服务**、**高级**、**目录**、**客户**、**销售**）。我们只需通过搜索
    `tab` 字符串，仅过滤名为 `system.xml` 的文件，就可以轻松地获取 Magento 中所有定义的标签列表。
- en: Next to the `tab` element, we have the `config` | `system` | `section` element.
    This is the element within which we further define what are to become HTML input
    fields for accepting configuration options, as visible on the previous image.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `tab` 元素旁边，我们有 `config` | `system` | `section` 元素。这个元素是我们进一步定义将成为接受配置选项的 HTML
    输入字段的元素，如前一张图所示。
- en: We can have multiple sections defined within a single `system.xml` file. The
    actual `section` element attributes require us to specify the `id` attribute value,
    which in our example is set to `foggyline_helpdesk`. Other important `section`
    element attributes are `showInWebsite` and `showInStore`. These can have either
    `0` or `1` as a value. Depending on our module business logic, we might find a
    good reason for choosing one value over the other.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在单个 `system.xml` 文件中定义多个部分。实际的 `section` 元素属性要求我们指定 `id` 属性值，在我们的例子中设置为
    `foggyline_helpdesk`。其他重要的 `section` 元素属性是 `showInWebsite` 和 `showInStore`。这些可以取
    `0` 或 `1` 作为值。根据我们的模块业务逻辑，我们可能会找到一个很好的理由来选择其中一个值而不是另一个。
- en: 'Looking further, the elements contained within our `section` element are:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步观察，我们 `section` 元素中包含的元素有：
- en: '`label`: This specifies the label we will see under the Magento admin **Store**
    | **Configuration** area.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`: 这指定了我们在 Magento 管理员 **Store** | **Configuration** 区域下将看到的标签。'
- en: '`tab`: This specifies the ID value of a tab under which we want this section
    to appear, which in our case equals to `foggyline`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tab`: 这指定了我们希望此部分出现的标签页的ID值，在我们的例子中等于 `foggyline`。'
- en: '`resource`: This specifies the ACL resource ID value.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource`: 这指定了 ACL 资源 ID 值。'
- en: '`group`: This specifies the group of fields. Similar to the `section` element,
    it also has `id`, `sortOrder`, `showInWebsite`, and `showInStore` attributes.
    Further, the group element has child field elements, which translate to HTML input
    fields under the Magento admin **Store** | **Configuration** area.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group`: 这指定了字段的组。类似于 `section` 元素，它也有 `id`、`sortOrder`、`showInWebsite` 和 `showInStore`
    属性。此外，组元素有子字段元素，这对应于在 Magento 管理员 **Store** | **Configuration** 区域下的 HTML 输入字段。'
- en: We defined two fields, `customer` and `store_owner`. Similar to `section` and
    `group`, `field` elements also have `id`, `sortOrder`, `showInWebsite`, and `showInStore`
    attributes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个字段，`customer` 和 `store_owner`。类似于 `section` 和 `group`，`field` 元素也有 `id`、`sortOrder`、`showInWebsite`
    和 `showInStore` 属性。
- en: Notice how `field` further contains child elements that define its options.
    Given that our `field` element type attribute was set to `select` with both fields,
    we needed to define the `source_model` element within each `field`. Both fields
    have the same `source_model` value which points to the Magento core class, `Magento\Config\Model\Config\Source\Email\Template`.
    Looking into that class, we can see it implements `\Magento\Framework\Option\ArrayInterface`
    and defines the `toOptionArray` method. During rendering the admin **Stores**
    | **Configuration** area, Magento will call this method to fill in the values
    for the select HTML element.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `field` 元素如何进一步包含定义其选项的子元素。鉴于我们的 `field` 元素类型属性被设置为 `select`，并且两个字段都如此，我们需要在每个
    `field` 中定义 `source_model` 元素。两个字段都有相同的 `source_model` 值，它指向 Magento 核心类，`Magento\Config\Model\Config\Source\Email\Template`。查看该类，我们可以看到它实现了
    `\Magento\Framework\Option\ArrayInterface` 并定义了 `toOptionArray` 方法。在渲染管理员 ** Stores**
    | **Configuration** 区域时，Magento 将调用此方法以填充选择HTML元素的值。
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Understanding what we can do with `system.xml` comes down to understanding what
    is defined under `vendor/magento/module-config/etc/system_file.xsd` and studying
    existing Magento core module `system.xml` files to get some examples.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 理解我们可以使用 `system.xml` 做什么，归结于理解在 `vendor/magento/module-config/etc/system_file.xsd`
    下定义了什么，并研究现有的 Magento 核心模块 `system.xml` 文件以获取一些示例。
- en: As noted previously, our `system.xml` has a resource element that points to
    the `app/code/Foggyline/Helpdesk/etc/acl.xml` file, which we will now look into.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的 `system.xml` 有一个指向 `app/code/Foggyline/Helpdesk/etc/acl.xml` 文件的资源元素，我们现在将查看它。
- en: Creating access control lists (acl.xml)
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建访问控制列表（acl.xml）
- en: 'The `app/code/Foggyline/Helpdesk/etc/acl.xml` file is where we define our module
    access control list resources. Access control list resources are visible under
    the Magento admin **System** | **Permissions** | **User Roles** area, when we
    click on the **Add New Role** button, as shown in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`app/code/Foggyline/Helpdesk/etc/acl.xml` 文件是我们定义模块访问控制列表资源的地方。当点击 **Add New
    Role** 按钮时，访问控制列表资源在 Magento 管理员 **System** | **Permissions** | **User Roles**
    区域可见，如以下截图所示：'
- en: '![Creating access control lists (acl.xml)](img/00099.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![创建访问控制列表（acl.xml）](img/00099.jpeg)'
- en: 'Looking at the preceding screenshot, we can see our **Helpdesk Section** under
    **Stores** | **Settings** | **Configuration**. How did we put it there? We have
    defined it in our `app/code/Foggyline/Helpdesk/etc/acl.xml` file with content
    as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 查看前面的截图，我们可以看到在 **Stores** | **Settings** | **Configuration** 下的 **Helpdesk
    Section**。我们是如何将其放置在那里的？我们已经在 `app/code/Foggyline/Helpdesk/etc/acl.xml` 文件中定义了它，内容如下：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Looking at the provided code, the immediate conclusion is that resources can
    be nested into each other. It is unclear how we should know where to nest our
    custom-defined resource with an ID value of `Foggyline_Helpdesk::helpdesk`. The
    simple answer is we followed the Magento structure. By looking into a few of the
    Magento core modules `system.xml` files and their `acl.xml` files, a pattern emerged
    where modules nest their resource under `Magento_Backend::admin` | `Magento_Backend::stores`
    | `Magento_Backend::stores_settings` | `Magento_Config::config`. These are all
    existing resources defined in core Magento, so we are merely referencing them,
    not defining them. The only resource we are defining in our `acl.xml` file is
    our own, which we are then referencing from our `system.xml` file. We can define
    other resources within `acl.xml` and not all would be nested into the same structure
    as `Foggyline_Helpdesk::helpdesk`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看提供的代码，可以立即得出结论，资源可以嵌套在彼此之中。不清楚我们应该如何知道如何将具有`Foggyline_Helpdesk::helpdesk`
    ID值的自定义定义资源嵌套在哪里。简单的答案是，我们遵循了Magento的结构。通过查看几个Magento核心模块的`system.xml`文件及其`acl.xml`文件，出现了一种模式，其中模块将资源嵌套在`Magento_Backend::admin`
    | `Magento_Backend::stores` | `Magento_Backend::stores_settings` | `Magento_Config::config`之下。这些都是核心Magento中定义的现有资源，所以我们只是引用它们，而不是定义它们。我们在`acl.xml`文件中定义的唯一资源是我们自己的，然后我们从`system.xml`文件中引用它。我们可以在`acl.xml`中定义其他资源，并不一定所有资源都会嵌套在`Foggyline_Helpdesk::helpdesk`相同的结构中。
- en: The value of the `title` attribute we assign to a resource element is shown
    in the admin area, as in the previous screenshot.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分配给资源元素的`title`属性值在管理区域中显示，如前一个截图所示。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be sure to use a descriptive label so that our module resource is easily recognizable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要使用描述性的标签，以便我们的模块资源易于识别。
- en: Creating an installation script (InstallSchema.php)
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建安装脚本（InstallSchema.php）
- en: '`InstallSchema`, or install script, is a way for us to set up tables in the
    database that will be used to persist our models later on.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`InstallSchema`，或安装脚本，是我们设置数据库中用于后续持久化我们模型所需表的一种方式。'
- en: 'If we look back at the module requirements, the following fields need to be
    created in the `foggyline_helpdesk_ticket` table:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾模块需求，以下字段需要在`foggyline_helpdesk_ticket`表中创建：
- en: '`ticket_id`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ticket_id`'
- en: '`customer_id`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer_id`'
- en: '`title`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`'
- en: '`severity`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`severity`'
- en: '`created_at`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created_at`'
- en: '`status`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`'
- en: 'Our `InstallSchema` is defined under the `app/code/Foggyline/Helpdesk/Setup/InstallSchema.php`
    file with (partial) content as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`InstallSchema`定义在`app/code/Foggyline/Helpdesk/Setup/InstallSchema.php`文件中，其（部分）内容如下：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `InstallSchema` class conforms to `InstallSchemaInterface` by implementing
    a single `install` method. Within this method, we start the installer, create
    new tables, create new fields, add indexes and foreign keys to the table, and
    finally end the installer, as shown in the following (partial) code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`InstallSchema`类通过实现单个`install`方法符合`InstallSchemaInterface`。在这个方法中，我们启动安装程序，创建新表，创建新字段，向表中添加索引和外键，最后结束安装程序，如下面的（部分）代码所示：'
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The provided code shows each of the fields from the module requirement being
    added to the database using the `addColumn` method call and passing it certain
    parameters such as the `field type` and `nullable` state. It is worth getting
    familiar with the `addColumn`, `addIndex`, and `addForeignKey` methods as these
    are most commonly used when specifying new tables for our modules.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的代码显示了如何使用`addColumn`方法调用将模块需求中的每个字段添加到数据库中，并传递某些参数，例如`字段类型`和`可空`状态。熟悉`addColumn`、`addIndex`和`addForeignKey`方法是有价值的，因为这些方法在指定我们模块的新表时最常用。
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We could further deepen our understanding of the installation script by studying
    how other core modules handle the `InstallSchema.php` file. Following a good database
    design practice, we should always create indexes and foreign keys on our table
    when referencing data from other tables.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过研究其他核心模块如何处理`InstallSchema.php`文件来进一步深化对安装脚本的理解。遵循良好的数据库设计实践，我们应该始终在我们的表上创建索引和外键，当我们从其他表引用数据时。
- en: Managing entity persistence (model, resource, collection)
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理实体持久性（模型、资源、集合）
- en: With `InstallSchema` in place, we now have conditions for entity persistence.
    Our next step is to define model, resource, and collection classes for the `Ticket`
    entity.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`InstallSchema`到位后，我们现在有实体持久性的条件。我们的下一步是定义`Ticket`实体的模型、资源和集合类。
- en: 'The `Ticket` entity model class is defined under the `app/code/Foggyline/Helpdesk/Model/Ticket.php`
    file with content as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ticket`实体模型类定义在`app/code/Foggyline/Helpdesk/Model/Ticket.php`文件中，其内容如下：'
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Reading the preceding code, we see it extends the `\Magento\Framework\Model\AbstractModel`
    class, which further extends the `\Magento\Framework\Object` class. This brings
    a lot of extra methods into our `Ticket` model class, such as `load`, `delete`,
    `save`, `toArray`, `toJson`, `toString`, `toXml`, and so on.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读前面的代码，我们看到它扩展了`\Magento\Framework\Model\AbstractModel`类，该类进一步扩展了`\Magento\Framework\Object`类。这为我们`Ticket`模型类带来了许多额外的方法，例如`load`、`delete`、`save`、`toArray`、`toJson`、`toString`、`toXml`等等。
- en: The only actual requirement for us is to define the `_construct` method that,
    through the `_init` function call, specifies the resource class the model will
    be using when persisting data. We have set this value to `Foggyline\Helpdesk\Model\ResourceModel\Ticket`,
    which will be the next class we will define, the so-called resource class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，唯一实际的要求是定义`_construct`方法，通过调用`_init`函数，指定模型在持久化数据时将使用的资源类。我们已将该值设置为`Foggyline\Helpdesk\Model\ResourceModel\Ticket`，这将是我们将要定义的下一个类，所谓的资源类。
- en: We have further defined several constants, `STATUS_*` and `SEVERITY_*`, as a
    sign of good programming practice and not to hardcode values that we will use
    across the code, which we can centralize into a class constant. These constants,
    in a way, map to our module requirements.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还进一步定义了几个常量，`STATUS_*`和`SEVERITY_*`，作为良好的编程实践标志，并且不是将我们将在代码中使用的值硬编码，我们可以将这些值集中到类常量中。这些常量在某种程度上映射到我们的模块需求。
- en: Additionally, we have three additional methods (`getSeveritiesOptionArray`,
    `getStatusAsLabel`, and `getSeverityAsLabel`) that we will use later on in our
    block class and template file.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有三个额外的方法（`getSeveritiesOptionArray`、`getStatusAsLabel`和`getSeverityAsLabel`），我们将在后续的块类和模板文件中使用。
- en: 'The `Ticket` entity resource class is defined under `app/code/Foggyline/Helpdesk/Model/ResourceModel/Ticket.php`
    with content as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ticket`实体资源类在`app/code/Foggyline/Helpdesk/Model/ResourceModel/Ticket.php`下定义，内容如下：'
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can see the code extends the `\Magento\Framework\Model\ResourceModel\Db\AbstractDb`
    class, which further extends the \`Magento\Framework\Model\ResourceModel\AbstractResource`
    class. This brings a lot of extra methods into our `Ticket` resource class, such
    as `load`, `delete`, `save`, `commit`, `rollback`, and so on.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到代码扩展了`\Magento\Framework\Model\ResourceModel\Db\AbstractDb`类，该类进一步扩展了`\Magento\Framework\Model\ResourceModel\AbstractResource`类。这为我们`Ticket`资源类带来了许多额外的方法，例如`load`、`delete`、`save`、`commit`、`rollback`等等。
- en: The only actual requirement for us is to define the _construct method, through
    which we call the `_init` function that accepts two parameters. The first parameter
    of the `_init` function specifies the table name `foggyline_helpdesk_ticket` and
    the second parameter specifies identifying the `ticket_id` column within that
    table where we will be persisting data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，唯一实际的要求是定义`_construct`方法，通过这个方法我们调用接受两个参数的`_init`函数。`_init`函数的第一个参数指定表名`foggyline_helpdesk_ticket`，第二个参数指定在该表中识别`ticket_id`列，我们将在此列中持久化数据。
- en: 'Finally, we define the `Ticket` entity collection class under `app/code/Foggyline/Helpdesk/Model/ResourceModel/Ticket/Collection.php`
    with content as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`app/code/Foggyline/Helpdesk/Model/ResourceModel/Ticket/Collection.php`下定义了`Ticket`实体集合类，内容如下：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The collection class code extends the `\Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection`
    class, which further extends the `\Magento\Framework\Data\Collection\AbstractDb`
    class, which further extends `\Magento\Framework\Data\Collection`. The final parent
    collection class then implements the following interfaces: `\IteratorAggregate`,
    `\Countable`, `Magento\Framework\Option\ArrayInterface`, and `Magento\Framework\Data\CollectionDataSourceInterface`.
    Through this deep inheritance, a large number of methods become available to our
    collection class, such as `count`, `getAllIds`, `getColumnValues`, `getFirstItem`,
    `getLastItem`, and so on.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 集合类代码扩展了`\Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection`类，该类进一步扩展了`\Magento\Framework\Data\Collection\AbstractDb`类，该类进一步扩展了`\Magento\Framework\Data\Collection`。最终的父集合类实现了以下接口：`\IteratorAggregate`、`\Countable`、`Magento\Framework\Option\ArrayInterface`和`Magento\Framework\Data\CollectionDataSourceInterface`。通过这种深层次的继承，大量方法变得可用给我们的集合类，例如`count`、`getAllIds`、`getColumnValues`、`getFirstItem`、`getLastItem`等等。
- en: With regard to our newly defined collection class, the only actual requirement
    for us is to define the `_construct` method. Within the `_construct` method, we
    call the `_init` function to which we pass two parameters. The first parameter
    specifies the `Ticket` model class `Foggyline\Helpdesk\Model\Ticket` and the second
    parameter specifies the `Ticket` resource class `Foggyline\Helpdesk\Model\ResourceModel\Ticket`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们新定义的集合类，我们唯一实际的要求是定义`_construct`方法。在`_construct`方法中，我们调用`_init`函数，并向其传递两个参数。第一个参数指定`Ticket`模型类`Foggyline\Helpdesk\Model\Ticket`，第二个参数指定`Ticket`资源类`Foggyline\Helpdesk\Model\ResourceModel\Ticket`。
- en: The three classes we just defined (`model`, `resource`, `collection`) act as
    an overall single entity persistence mechanism. With the currently defined code,
    we are able to save, delete, update, lookup with filtering, and list our `Ticket`
    entities, which we demonstrate in the upcoming sections.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义的三个类（`model`、`resource`、`collection`）作为一个整体的单一实体持久机制。根据当前定义的代码，我们能够保存、删除、更新、带有过滤的查找以及列出我们的`Ticket`实体，我们将在接下来的部分中演示。
- en: Building a frontend interface
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建前端界面
- en: Now that we have defined the necessary minimum for data persistence functionality,
    we can move forward to building a frontend interface. The module requirement says
    that customers should be able to submit a ticket through their **My Account**
    section. We will therefore add a link called **Helpdesk Tickets** under the customer's
    **My Account** section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了数据持久性功能所需的最小必要条件，我们可以继续构建前端界面。模块要求表明，客户应该能够通过他们的**我的账户**部分提交工单。因此，我们将在客户的**我的账户**部分下添加一个名为**帮助台工单**的链接。
- en: 'The following are needed for a fully functional frontend:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个完全功能的前端，以下内容是必需的：
- en: A route that will map to our controller
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将映射到我们控制器的路由
- en: A controller that will catch requests from a mapped route
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将捕获来自映射路由的请求的控制器
- en: A controller action that will load the layout
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个控制器动作，将加载布局
- en: Layout XMLs that will update the view making it look as if we are on the **My
    Account** section while providing content of our own
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将更新视图以使其看起来像我们处于**我的账户**部分，同时提供我们自己的内容
- en: A block class to power our template file
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于驱动我们的模板文件的块类
- en: A template file that we will render into the content area of a page
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个我们将渲染到页面内容区域的模板文件
- en: A controller action that will save the **New Ticket** form once it is posted
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个控制器动作，当表单提交时将保存**新工单**表单
- en: Creating routes, controllers, and layout handles
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建路由、控制器和布局处理程序
- en: 'We start by defining a route within the `app/code/Foggyline/Helpdesk/etc/frontend/routes.xml`
    file with content as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在`app/code/Foggyline/Helpdesk/etc/frontend/routes.xml`文件中定义一条路由，其内容如下：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the route element `id` and `frontName` attributes have the same value,
    but they do not serve the same purpose, as we will see soon.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，路由元素`id`和`frontName`属性具有相同的值，但它们并不服务于相同的目的，正如我们很快将看到的。
- en: 'Now we define our controller `app/code/Foggyline/Helpdesk/Controller/Ticket.php`
    file with content as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义我们的控制器`app/code/Foggyline/Helpdesk/Controller/Ticket.php`文件，其内容如下：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our controller loads the customer session object through its constructor. The
    customer session object is then used within the dispatch method to check if the
    customer is authenticated or not. If the customer is not authenticated, all frontend
    actions in the Internet browser that lead to this controller will result in the
    customer being redirected to the login screen.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的控制器通过其构造函数加载客户会话对象。然后，在dispatch方法中使用客户会话对象来检查客户是否已认证。如果客户未认证，所有导致此控制器的Internet浏览器中的前端操作都将导致客户被重定向到登录屏幕。
- en: 'Once the controller is in place, we can then define the actions that extend
    from it. Each action is a class file on its own, extending from the parent class.
    We will now define our index action, the one that will render the view under **My
    Account** | **Helpdesk Tickets**, within the `app/code/Foggyline/Helpdesk/Controller/Ticket/Index.php`
    file with content as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦控制器就位，我们就可以定义从它扩展的动作。每个动作都是一个独立的类文件，从父类扩展而来。现在，我们将在`app/code/Foggyline/Helpdesk/Controller/Ticket/Index.php`文件中定义我们的index动作，即渲染**我的账户**
    | **帮助台工单**下的视图的动作，其内容如下：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Controller action code lives within the `execute` method of its class. We simply
    extend from the `\Foggyline\Helpdesk\Controller\Ticket` controller class and define
    the necessary logic within the execute method. Simply calling `loadLayout` and
    `renderLayout` is enough to render the page on the frontend.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器操作代码位于其类中的 `execute` 方法内。我们简单地扩展了 `\Foggyline\Helpdesk\Controller\Ticket`
    控制器类，并在 `execute` 方法中定义必要的逻辑。简单地调用 `loadLayout` 和 `renderLayout` 就足以在前端渲染页面。
- en: 'The frontend XML layout handles reside under the `app/code/Foggyline/Helpdesk/view/frontend/layout`
    folder. Having the route ID, controller, and controller action is enough for us
    to determine the handle name, which goes by formula *{route id}_{controller name}_{controller
    action name}.xml*. Thus, we define an index action layout within the `app/code/Foggyline/Helpdesk/view/frontend/layout/foggyline_helpdesk_ticket_index.xml`
    file with content as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前端 XML 布局位于 `app/code/Foggyline/Helpdesk/view/frontend/layout` 文件夹下。拥有路由 ID、控制器和控制器操作就足以让我们确定处理名称，该名称遵循公式
    *{route id}_{controller name}_{controller action name}.xml*。因此，我们在 `app/code/Foggyline/Helpdesk/view/frontend/layout/foggyline_helpdesk_ticket_index.xml`
    文件中定义了一个索引操作布局，内容如下：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice how we immediately call the update directive, passing it the `customer_account`
    handle attribute value. This is like saying, "Include everything from the `customer_account`
    handle into our handle here." We are further referencing the content block, within
    which we define our own custom block type `Foggyline\Helpdesk\Block\Ticket\Index`.
    Though a block class can specify its own template, we are using a template attribute
    with a module-specific path, `Foggyline_Helpdesk::ticket/index.phtml`, to assign
    a template to a block.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何立即调用更新指令，并传递 `customer_account` 处理程序属性值。这就像说，“将 `customer_account` 处理程序中的所有内容包含到我们的处理程序中。”我们进一步引用内容块，在其中我们定义了自己的自定义块类型
    `Foggyline\Helpdesk\Block\Ticket\Index`。尽管块类可以指定自己的模板，但我们使用模板属性和模块特定的路径 `Foggyline_Helpdesk::ticket/index.phtml`
    来分配一个模板给块。
- en: 'Simply including the `customer_acount` handle is not enough; we need something
    extra to define our link under the **My Account** section. We define this extra
    something under the `app/code/Foggyline/Helpdesk/view/frontend/layout/customer_account.xml`
    file with content as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 仅包含 `customer_acount` 处理程序是不够的；我们需要一些额外的东西来定义在 **我的账户** 部分下的链接。我们在 `app/code/Foggyline/Helpdesk/view/frontend/layout/customer_account.xml`
    文件中定义了这个额外的东西，内容如下：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What is happening here is that we are referencing an existing block called
    `customer_account_navigation` and defining a new block within it of class `Magento\Framework\View\Element\Html\Link\Current`.
    This block accepts two parameters: the path that is set to our controller action
    and the label that is set to **Helpdesk Tickets**.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是我们正在引用一个名为 `customer_account_navigation` 的现有块，并在其中定义了一个新的块，其类为 `Magento\Framework\View\Element\Html\Link\Current`。这个块接受两个参数：设置为我们的控制器操作的路径和设置为
    **帮助台票据** 的标签。
- en: Creating blocks and templates
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建块和模板
- en: 'The `Foggyline\Helpdesk\Block\Ticket\Index` block class we pointed to from
    `foggyline_helpdesk_ticket_index.xml` is defined under the `app/code/Foggyline/Helpdesk/Block/Ticket/Index.php`
    file with content as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `foggyline_helpdesk_ticket_index.xml` 中引用的 `Foggyline\Helpdesk\Block\Ticket\Index`
    块类定义在 `app/code/Foggyline/Helpdesk/Block/Ticket/Index.php` 文件中，内容如下：
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The reason why we defined the `Foggyline\Helpdesk\Block\Ticket` block class
    instead of using just `\Magento\Framework\View\Element\Template` is because we
    wanted to define some helper methods we could then use in our `index.phtml` template.
    These methods are `getTickets` (which we will use for listing all customer tickets)
    and `getSeverities` (which we will use for creating a dropdown of possible severities
    to choose from when creating a new ticket).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义 `Foggyline\Helpdesk\Block\Ticket` 块类而不是仅仅使用 `\Magento\Framework\View\Element\Template`
    的原因是我们想定义一些可以在我们的 `index.phtml` 模板中使用的辅助方法。这些方法是 `getTickets`（我们将用于列出所有客户票据）和
    `getSeverities`（我们将用于在创建新票据时创建一个可供选择的严重性下拉列表）。
- en: 'The template is further defined under the `app/code/Foggyline/Helpdesk/view/frontend/templates/ticket/index.phtml`
    file with content as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 模板进一步在 `app/code/Foggyline/Helpdesk/view/frontend/templates/ticket/index.phtml`
    文件中定义，内容如下：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Though this is a big chunk of code, it is easily readable as it is divided into
    a few very different role-playing chunks.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一大块代码，但由于它被分成了几个非常不同的角色扮演块，因此很容易阅读。
- en: The `$block` variable is actually the same as if we wrote `$this`, which is
    a reference to the instance of the `Foggyline\Helpdesk\Block\Ticket` class where
    we defined the actual `getTickets` method. Thus, the `$tickets` variable is first
    defined as a collection of tickets that belong to the currently logged-in customer.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`$block`变量实际上等同于我们写的`$this`，它是对`Foggyline\Helpdesk\Block\Ticket`类实例的引用，我们在其中定义了实际的`getTickets`方法。因此，`$tickets`变量首先被定义为属于当前登录客户的工单集合。'
- en: We then specified a form with a `POST` method type and an action URL that points
    to our `Save` controller action. Within the form, we have a `$block->getBlockHtml('formkey')`
    call, which basically returns a hidden input field named `form_key` whose value
    is a random string. Form keys in Magento are a means of preventing against **Cross-Site
    Request Forgery** (**CSRF**), so we need to be sure to use them on any form we
    define. As part of the form, we have also defined a title input field, severity
    select field, and submit button. Notice the CSS classes tossed around, which guarantee
    that our form's look will match those of other Magento forms.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了一个具有`POST`方法类型和指向我们的`Save`控制器动作的action URL的表单。在表单中，我们有一个`$block->getBlockHtml('formkey')`调用，它基本上返回一个名为`form_key`的隐藏输入字段，其值是一个随机字符串。在Magento中，表单密钥是一种防止**跨站请求伪造**（**CSRF**）的手段，因此我们确保在定义的任何表单上使用它们。作为表单的一部分，我们还定义了一个标题输入字段、严重性选择字段和提交按钮。注意那些被抛来抛去的CSS类，它们保证了我们的表单外观将与其他Magento表单相匹配。
- en: Right after the closing form tag, we have a RequireJS type of JavaScript inclusion
    for validation. Given that our form ID value is set to **form-validate**, the
    JavaScript `dataForm` variable binds to it and triggers a validation check when
    we press the **Submit** button.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单标签关闭后，我们有一个RequireJS类型的JavaScript包含，用于验证。鉴于我们的表单ID值设置为**form-validate**，JavaScript
    `dataForm`变量绑定到它，并在我们按下**提交**按钮时触发验证检查。
- en: We then have a count check and a `foreach` loop that renders all possibly existing
    customer tickets.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个计数检查和一个`foreach`循环，用于渲染所有可能存在的客户工单。
- en: 'The final result of the template code can be seen in the following image:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 模板代码的最终结果可以在以下图像中看到：
- en: '![Creating blocks and templates](img/00100.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![创建块和模板](img/00100.jpeg)'
- en: Handling form submissions
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理表单提交
- en: 'There is one more piece we are missing in order to complete our frontend functionality
    – a controller action that will save the **New Ticket** form once it is posted.
    We define this action within the `app/code/Foggyline/Helpdesk/Controller/Ticket/Save.php`
    file with content as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的前端功能，我们还缺少一个组件——一个控制器动作，用于在表单提交后保存**新工单**。我们在这个`app/code/Foggyline/Helpdesk/Controller/Ticket/Save.php`文件中定义了这个动作，内容如下：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, we look at `__construct` to see what parameters are passed to it. Given
    that the code we run in the `execute` method needs to check if the form key is
    valid, create a ticket in the database, pass on the ticket and some customer info
    to the e-mail that is being sent to the store owner; then, we get an idea of what
    kind of objects are being passed around.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们查看`__construct`方法，看看传递给它了哪些参数。鉴于我们在`execute`方法中运行的代码需要检查表单密钥是否有效，在数据库中创建一个工单，将工单和一些客户信息传递给发送给商店所有者的电子邮件；然后，我们可以了解正在传递的哪些类型的对象。
- en: The `execute` method starts by checking the validity of the form key. If the
    form key is invalid, we return with a redirection to the referring URL.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute`方法首先检查表单密钥的有效性。如果表单密钥无效，我们将通过重定向到引用URL返回。'
- en: Passing the form key check, we grab the title and severity variables as passed
    by the form. We then instantiate the ticket entity by the ticket factory create
    method and simply set the `ticket` entity values one by one. Note that the `Ticket`
    entity model `Foggyline\Helpdesk\Model\Ticket` does not really have methods like
    `setSeverity` on its own. This is the inherited property of its `\Magento\Framework\Object`
    parent class.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过表单密钥检查后，我们获取表单传递的标题和严重性变量。然后，我们通过工单工厂的创建方法实例化工单实体，并逐个设置`ticket`实体的值。请注意，`Ticket`实体模型`Foggyline\Helpdesk\Model\Ticket`本身并没有像`setSeverity`这样的方法。这是其`\Magento\Framework\Object`父类继承的属性。
- en: Once the ticket entity is saved, we initiate the `transport builder` object,
    passing along all of the required parameters for successful e-mail sending. Notice
    how `setTemplateIdentifier` uses our `system.xml` configuration option `foggyline_helpdesk/email_template/store_owner`.
    This, if not specifically set under the admin **Store** | **Configuration** |
    **Foggyline** | **Helpdesk** area, has a default value defined under `config.xml`
    that points to the e-mail template ID in the `email_templates.xml` file.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦保存了票务实体，我们就初始化`运输构建器`对象，传递所有成功发送电子邮件所需的参数。注意`setTemplateIdentifier`是如何使用我们的`system.xml`配置选项`foggyline_helpdesk/email_template/store_owner`的。如果没有在管理员**商店**
    | **配置** | **Foggyline** | **帮助台**区域中特别设置，它将在`config.xml`中定义一个默认值，该值指向`email_templates.xml`文件中的电子邮件模板ID。
- en: '`setTemplateVars` expects the array or instance of `\Magento\Framework\Object`
    to be passed to it. We pass the entire `$ticket` object to it, just nesting it
    under the ticket key, thus making the properties of a `Ticket` entity, like a
    title, become available in the e-mail HTML template as `{{var ticket.title}}`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTemplateVars`期望传递给它的是一个数组或`\Magento\Framework\Object`的实例。我们传递整个`$ticket`对象给它，只是将其嵌套在票务键下，这样`Ticket`实体的属性，如标题，就可以在电子邮件HTML模板中作为`{{var
    ticket.title}}`可用。'
- en: When a customer now submits the **New Ticket** form from **My Account** | **Helpdesk
    Tickets**, the `HTTP POST` request will hit the save controller action class.
    If the preceding code is successfully executed, the ticket is saved to the database
    and redirection back to **My Account** | **Helpdesk Tickets** will occur showing
    a **Ticket successfully created** message in the browser.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户现在从**我的账户** | **帮助台票务**提交**新票务**表单时，`HTTP POST`请求将击中保存控制器动作类。如果前面的代码成功执行，票务将被保存到数据库，并且将重定向回**我的账户**
    | **帮助台票务**，在浏览器中显示**票务成功创建**的消息。
- en: Building a backend interface
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建后端界面
- en: Until now, we have been dealing with setting up general module configuration,
    e-mail templates, frontend route, frontend layout, block, and template. What remains
    to complete the module requirements is the admin interface, where the store owner
    can see submitted tickets and change statuses from open to closed.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理设置通用模块配置、电子邮件模板、前端路由、前端布局、块和模板。要完成模块要求，剩下的就是管理员界面，店主可以在那里查看提交的票务并将状态从开放更改为关闭。
- en: 'The following are needed for a fully functional admin interface as per the
    requirements:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要满足完全功能的管理员界面要求：
- en: ACL resource used to allow or disallow access to the ticket listing
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于允许或拒绝访问票务列表的ACL资源
- en: Menu item linking to tickets listing the controller action
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接到列出票务的控制器动作的菜单项
- en: Route that maps to our admin controller
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射到我们的管理员控制器的路由
- en: Layout XMLs that map to the ticket listing the controller action
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射到票务列表控制器动作的布局XML
- en: Controller action for listing tickets
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出票务的控制器动作
- en: Full XML layout grid definition within layout XMLs defining grid, custom column
    renderers, and custom dropdown filter values
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在布局XML中定义的完整XML布局网格定义，包括网格、自定义列渲染器和自定义下拉筛选值
- en: Controller action for closing tickets and sending e-mails to customers
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭票务并发送电子邮件给客户的控制器动作
- en: Linking the access control list and menu
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接访问控制列表和菜单
- en: 'We start by adding a new ACL resource entry to the previously defined `app/code/Foggyline/Helpdesk/etc/acl.xml`
    file, as a child of the `Magento_Backend::admin` resource as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先向先前定义的`app/code/Foggyline/Helpdesk/etc/acl.xml`文件添加一个新的ACL资源条目，作为`Magento_Backend::admin`资源的子项，如下所示：
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: On its own, the defined resource entry does not do anything. This resource will
    later be used within the menu and controller.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，定义的资源条目不会做任何事情。这个资源将稍后用于菜单和控制器中。
- en: 'The menu item linking to the tickets listing the controller action is defined
    under the `app/code/Foggyline/Helpdesk/etc/adminhtml/menu.xml` file as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 链接到列出票务的控制器动作的菜单项在`app/code/Foggyline/Helpdesk/etc/adminhtml/menu.xml`文件中定义，如下所示：
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We are using the `menu` | `add` element to add a new menu item under the Magento
    admin area. The position of an item within the admin area is defined by the attribute
    parent, which in our case means under the existing **Customer** menu. If the parent
    is omitted, our item would appear as a new item on a menu. The `title` attribute
    value is the label we will see in the menu. The `id` attribute has to uniquely
    differentiate our menu item from others. The `resource` attribute references the
    ACL resource defined in the `app/code/Foggyline/Helpdesk/etc/acl.xml` file. If
    a role of a logged-in user does not allow him to use the `Foggyline_Helpdesk::ticket_manage`
    resource, the user would not be able to see the menu item.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Creating routes, controllers, and layout handles
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we add a route that maps to our admin controller, by defining the `app/code/Foggyline/Helpdesk/etc/adminhtml/routes.xml`
    file as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The admin route definition is almost identical to the frontend router definition,
    where the difference primarily lies in the router ID value, which equals to the
    admin here.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'With the router definition in place, we can now define our three layout XMLs,
    under the `app/code/Foggyline/Helpdesk/view/adminhtml/layout` directory, which
    map to the ticket listing the controller action:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '`foggyline_helpdesk_ticket_grid.xml`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foggyline_helpdesk_ticket_grid_block.xml`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foggyline_helpdesk_ticket_index.xml`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason we define three layout files for a single action controller and not
    one is because of the way we use the listing in control in the Magento admin area.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of the `foggyline_helpdesk_ticket_index.xml` file is defined as
    follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Two update handles are specified, one pulling in `formkey` and the other pulling
    in `foggyline_helpdesk_ticket_grid_block`. We then reference the content container
    and define a new block of the `Foggyline\Helpdesk\Block\Adminhtml\Ticket` class
    with it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the grid widget
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We could have used `Magento\Backend\Block\Widget\Grid\Container` as a block
    class name. However, given that we needed some extra logic, like removing the
    **Add New** button, we opted for a custom class that then extends `\Magento\Backend\Block\Widget\Grid\Container`
    and adds the required logic.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Foggyline\Helpdesk\Block\Adminhtml\Ticket` class is defined under the
    `app/code/Foggyline/Helpdesk/Block/Adminhtml/Ticket.php` file as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Not much is happening in the `Ticket` block class here. Most importantly, we
    extend from `\Magento\Backend\Block\Widget\Grid\Container` and define `_controller`
    and `_blockGroup,` as these serve as a sort of glue for telling our grid where
    to find other possible block classes. Since we won't have an **Add New** ticket
    feature in admin, we are calling the `removeButton` method to remove the default
    **Add New** button from the grid container.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our second XML layout file, the `foggyline_helpdesk_ticket_grid.xml`
    file, which we define as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice how the content of `foggyline_helpdesk_ticket_grid.xml` is nearly identical
    to that of `foggyline_helpdesk_ticket_index.xml`. The only difference between
    the two is the value of the `block` class and the template attribute. The `block`
    class is defined as `Magento\Backend\Block\Widget\Grid\Container`, where we previously
    defined it as `Foggyline\Helpdesk\Block\Adminhtml\Ticket`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`foggyline_helpdesk_ticket_grid.xml`的内容几乎与`foggyline_helpdesk_ticket_index.xml`相同。两者之间的唯一区别是`block`类和模板属性的值。`block`类定义为`Magento\Backend\Block\Widget\Grid\Container`，而我们之前将其定义为`Foggyline\Helpdesk\Block\Adminhtml\Ticket`。
- en: 'If we look at the content of the `\Magento\Backend\Block\Widget\Grid\Container`
    class, we can see the following property defined:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`\Magento\Backend\Block\Widget\Grid\Container`类的代码，我们可以看到以下属性被定义：
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If we look at the content of the `vendor/magento/module-backend/view/adminhtml/templates/widget/grid/container.phtml`
    and `vendor/magento/module-backend/view/adminhtml/templates/widget/grid/container/empty.phtml`
    files, the difference can be easily spotted. `container/empty.phtml` only returns
    grid HTML, whereas `container.phtml` returns buttons and grid HTML.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`vendor/magento/module-backend/view/adminhtml/templates/widget/grid/container.phtml`和`vendor/magento/module-backend/view/adminhtml/templates/widget/grid/container/empty.phtml`文件的内容，差异可以很容易地被发现。`container/empty.phtml`只返回网格HTML，而`container.phtml`返回按钮和网格HTML。
- en: Given that `foggyline_helpdesk_ticket_grid.xml` will be a handle for the AJAX
    loading grid listing during sorting and filtering, we need it to return only grid
    HTML upon reload.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`foggyline_helpdesk_ticket_grid.xml`将是排序和过滤期间AJAX加载网格列表的句柄，我们需要它在重新加载时只返回网格HTML。
- en: We now move on to the third and largest of XML's layout files, the `app/code/Foggyline/Helpdesk/view/adminhtml/layout/foggyline_helpdesk_ticket_grid_block.xml`
    file. Given the size of it, we will split it into two code chunks as we explain
    them one by one.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在继续到XML布局文件中的第三个也是最大的文件，即`app/code/Foggyline/Helpdesk/view/adminhtml/layout/foggyline_helpdesk_ticket_grid_block.xml`文件。鉴于其大小，我们将将其分成两个代码块，在解释它们时逐一说明。
- en: 'The first part, or initial content of the `foggyline_helpdesk_ticket_grid_block.xml`
    file, is defined as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`foggyline_helpdesk_ticket_grid_block.xml`文件的第一部分，或初始内容，定义如下：'
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice `<!-- Column definitions here -->`; we will come back to that soon. For
    now, let's analyze what is happening here. Right after a body element, we have
    a reference to `admin.block.helpdesk.ticket.grid.container`, which is a content
    block child defined under the `foggyline_helpdesk_ticket_grid.xml` and `foggyline_helpdesk_ticket_index.xml`
    files. Within this reference, we are defining another block of class `Magento\Backend\Block\Widget\Grid`,
    passing it a name of our choosing and an alias. Further, this block has an arguments
    list and another block of class `Magento\Backend\Block\Widget\Grid\ColumnSet`
    as child elements.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`<!-- Column definitions here -->`；我们很快就会回到那里。现在，让我们分析这里发生的事情。在主体元素之后，我们有一个对`admin.block.helpdesk.ticket.grid.container`的引用，这是一个在`foggyline_helpdesk_ticket_grid.xml`和`foggyline_helpdesk_ticket_index.xml`文件下定义的内容块子元素。在这个引用中，我们定义了另一个类为`Magento\Backend\Block\Widget\Grid`的块，传递了我们选择的名称和一个别名。此外，这个块有一个参数列表，并且有一个类为`Magento\Backend\Block\Widget\Grid\ColumnSet`的块作为子元素。
- en: 'Through the arguments list we specify the:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过参数列表，我们指定了：
- en: '`id`: Set to the value of `ticketGrid`, we can set any value we want here,
    ideally sticking to formula *{entity name}*.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`: 设置为`ticketGrid`的值，我们可以在这里设置任何我们想要的值，理想情况下坚持使用公式*{实体名称}*。'
- en: '`dataSource`: Set to the value of `Foggyline\Helpdesk\Model\ResourceModel\Ticket\Collection`,
    which is the name of our `Ticket` entity resource class.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dataSource`: 设置为`Foggyline\Helpdesk\Model\ResourceModel\Ticket\Collection`的值，这是我们的`Ticket`实体资源类的名称。'
- en: '`default_sort`: Set to the value of `ticket_id`, which is the property of the
    `Ticket` entity by which we want to sort.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_sort`: 设置为`ticket_id`的值，这是我们想要按其排序的`Ticket`实体属性。'
- en: '`default_dir`: Set to the value of `desc`, to denote a descending order of
    sorting. This value functions together with `default_sort` as a single unit.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_dir`: 设置为`desc`的值，表示排序的降序。此值与`default_sort`一起作为一个单一单元使用。'
- en: '`save_parameters_in_session`: Set to `true`, this is easiest to explain using
    the following example: if we do some sorting and filtering on the `Ticket` grid
    and then move on to another part of the admin area, then come back to `Ticket`
    grid, if this value is set to **yes**, the grid we see will have those filters
    and sorting set.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`save_parameters_in_session`: 设置为`true`，这可以通过以下示例最容易解释：如果我们对`Ticket`网格进行一些排序和过滤，然后转到管理区域的另一个部分，然后回到`Ticket`网格，如果此值设置为**是**，我们看到的网格将具有那些过滤和排序设置。'
- en: '`use_ajax`: Set to `true`, when grid filtering and sorting is triggered, an
    AJAX loader kicks in and reloads only the grid area and not the whole page.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_ajax`: 设置为`true`时，当网格过滤和排序被触发时，一个AJAX加载器会启动并仅重新加载网格区域而不是整个页面。'
- en: 'Right after the grid blocks argument list, we have the grid column set. This
    brings us to the second part of `foggyline_helpdesk_ticket_grid_block.xml` content.
    We simply replace the `<!-- Columns here -->` comment with the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在网格块参数列表之后，我们有网格列设置。这使我们到达了`foggyline_helpdesk_ticket_grid_block.xml`内容的第二部分。我们只需将`<!--
    Columns here -->`注释替换为以下内容：
- en: '[PRE32]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Similar to grid, column definitions also have arguments that define its look
    and behavior:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与网格类似，列定义也有定义其外观和行为的参数：
- en: '`header`: Mandatory, the value we want to see as a label on top of the column.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`header`: 必需的，我们希望在列顶部看到的标签值。'
- en: '`type`: Mandatory, can be anything from: `date`, `datetime`, `text`, `longtext`,
    `options`, `store`, `number`, `currency`, `skip-list`, `wrapline`, and `country`.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`: 必需的，可以是以下任何一种：`date`、`datetime`、`text`、`longtext`、`options`、`store`、`number`、`currency`、`skip-list`、`wrapline`和`country`。'
- en: '`id`: Mandatory, a unique value that identifies our column, preferably matching
    the name of the entity property.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`: 必需的，一个唯一值，用于标识我们的列，最好与实体属性名称匹配。'
- en: '`index`: Mandatory, the database column name.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`: 必需的，数据库列名。'
- en: '`options`: Optional, if we are using a type like options, then for the options
    argument we need to specify the class like `Foggyline\Helpdesk\Model\Ticket\Grid\Severity`
    that implements `\Magento\Framework\Option\ArrayInterface`, meaning it provides
    the `toOptionArray` method that then fills the values of options during grid rendering.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options`: 可选的，如果我们使用像`options`这样的类型，那么对于`options`参数，我们需要指定一个类，例如`Foggyline\Helpdesk\Model\Ticket\Grid\Severity`，该类实现了`\Magento\Framework\Option\ArrayInterface`，这意味着它提供了`toOptionArray`方法，然后在网格渲染期间填充选项值。'
- en: '`renderer`: Optional, as our `Ticket` entities store severity and status as
    integer values in the database, columns would render those integer values into
    columns, which is not really useful. We want to turn those integer values into
    labels. In order to do so, we need to rewrite the rendering bit of a single table
    cell, which we do with the help of the renderer argument. The value we pass to
    it, `Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Severity`, needs
    to be a class that extends `\Magento\Backend\Block\Widget\Grid\Column\Renderer\AbstractRenderer`
    and does its own implementation of the render method.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`renderer`: 可选的，因为我们的`Ticket`实体将严重性和状态作为整数值存储在数据库中，列会渲染这些整数值，这实际上并不太有用。我们希望将这些整数值转换为标签。为了做到这一点，我们需要重写单个表格单元的渲染部分，我们通过`renderer`参数来完成。传递给它的值，`Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Severity`，需要是一个扩展`\Magento\Backend\Block\Widget\Grid\Column\Renderer\AbstractRenderer`并对其`render`方法进行自己实现的类。'
- en: '`header_css_class`: Optional, if we prefer to specify a custom header class.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`header_css_class`: 可选的，如果我们希望指定一个自定义标题类。'
- en: '`column_css_class`: Optional, if we prefer to specify a custom column class.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`column_css_class`: 可选的，如果我们希望指定一个自定义列类。'
- en: Creating a grid column renderer
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建网格列渲染器
- en: 'The `Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Severity` class,
    defined in the `app/code/Foggyline/Helpdesk/Block/Adminhtml/Ticket/Grid/Renderer/Severity.php`
    file, is as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 定义在`app/code/Foggyline/Helpdesk/Block/Adminhtml/Ticket/Grid/Renderer/Severity.php`文件中的`Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Severity`类如下：
- en: '[PRE33]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we are passing the instance of the ticket factory to the constructor and
    then using that instance within the render method to load a ticket based on the
    ID value fetched from the current row. Given that `$row->getId()` returns the
    ID of the ticket, this is a nice way to reload the entire ticket entity and then
    fetch the full label from the ticket model by using `$ticket->getSeverityAsLabel()`.
    Whatever string we return from this method is what will be shown under the grid
    row.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将票据工厂的实例传递给构造函数，然后在`render`方法中使用该实例根据从当前行获取的ID值加载票据。鉴于`$row->getId()`返回票据的ID，这是一种很好的方式来重新加载整个票据实体，然后通过使用`$ticket->getSeverityAsLabel()`从票据模型中获取完整的标签。从这个方法返回的任何字符串都将在网格行下方显示。
- en: 'Another renderer class that is referenced within the `foggyline_helpdesk_ticket_grid_block.xml`
    file is `Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Status`, and
    we define its content under the `app/code/Foggyline/Helpdesk/Block/Adminhtml/Ticket/Grid/Renderer/Status.php`
    file as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在`foggyline_helpdesk_ticket_grid_block.xml`文件中引用的另一个渲染器类是`Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Status`，我们将其内容定义在`app/code/Foggyline/Helpdesk/Block/Adminhtml/Ticket/Grid/Renderer/Status.php`文件中如下：
- en: '[PRE34]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Given that it too is used for a renderer, the content of the `Status` class
    is nearly identical to the content of the `Severity` class. We pass on the ticket
    factory object via the constructor, so we have it internally for usage within
    the `render` method. Then we load the `Ticket` entity using the ticket factory
    and ID value fetched from a `$row` object. As a result, the column will contain
    the label value of a status and not its integer value.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它也用于渲染器，`Status`类的内文几乎与`Severity`类的内文相同。我们通过构造函数传递票务工厂对象，以便在`render`方法内部使用。然后我们使用票务工厂和从`$row`对象获取的ID值加载`Ticket`实体。因此，该列将包含状态标签值而不是其整数值。
- en: Creating grid column options
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建网格列选项
- en: Besides referencing renderer classes, our `foggyline_helpdesk_ticket_grid_block.xml`
    file also references the `options` class for the `Severity` field.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 除了引用渲染器类之外，我们的`foggyline_helpdesk_ticket_grid_block.xml`文件还引用了`Severity`字段的`options`类。
- en: 'We define the `Foggyline\Helpdesk\Model\Ticket\Grid\Severity` options class
    under the `app/code/Foggyline/Helpdesk/Model/Ticket/Grid/Severity.php` file as
    follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`app/code/Foggyline/Helpdesk/Model/Ticket/Grid/Severity.php`文件下定义了`Foggyline\Helpdesk\Model\Ticket\Grid\Severity`选项类如下：
- en: '[PRE35]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `options` value from XML layouts refers to a class that has to implement
    the `toOptionArray` method, which returns an array of arrays, such as the following
    example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 来自XML布局的`options`值指的是一个必须实现`toOptionArray`方法的类，它返回一个数组，例如以下示例：
- en: '[PRE36]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Our `Severity` class simply calls the static method we have defined on the `Ticket`
    class, the `getSeveritiesOptionArray`, and passes along those values.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Severity`类简单地调用我们在`Ticket`类上定义的静态方法`getSeveritiesOptionArray`，并传递这些值。
- en: Creating controller actions
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建控制器动作
- en: Up to this point, we have defined the menu item, ACL resource, XML layouts,
    block, `options` class, and `renderer` classes. What remains to connect it all
    are controllers. We will need three controller actions (`Index`, `Grid`, and `Close`),
    all extending from the same admin `Ticket` controller.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了菜单项、ACL资源、XML布局、块、`options`类和`renderer`类。要连接所有这些，我们需要控制器。我们需要三个控制器动作（`Index`、`Grid`和`Close`），它们都扩展自同一个管理`Ticket`控制器。
- en: 'We define the admin `Ticket` controller under the `app/code/Foggyline/Helpdesk/Controller/Adminhtml/Ticket.php`
    file as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`app/code/Foggyline/Helpdesk/Controller/Adminhtml/Ticket.php`文件下定义了管理`Ticket`控制器如下：
- en: '[PRE37]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There are a few things to note here. `$this->resultPageFactory`, `$this->resultForwardFactory`
    and `$this->resultRedirectFactory` are objects to be used on the child (`Index`,
    `Grid`, and `Close`), so we do not have to initiate them in each child class separately.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的事项。`$this->resultPageFactory`、`$this->resultForwardFactory`和`$this->resultRedirectFactory`是用于子类（`Index`、`Grid`和`Close`）的对象，因此我们不需要在每个子类中单独初始化它们。
- en: The `_isAllowed()` method is extremely important every time we have a custom-defined
    controller or controller action that we want to check against our custom ACL resource.
    Here, we are the `isAllowed` method call on the `\Magento\Framework\AuthorizationInterface`
    type of object (`$this->_authorization`). The parameter passed to the `isAllowed`
    method call should be the ID value of our custom ACL resource.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`_isAllowed()`方法在每次我们有一个自定义定义的控制器或控制器动作，并希望对其进行自定义ACL资源检查时非常重要。在这里，我们是在`\Magento\Framework\AuthorizationInterface`类型的对象`($this->_authorization)`上调用`isAllowed`方法。传递给`isAllowed`方法调用的参数应该是我们自定义ACL资源的ID值。'
- en: We then have the `_initAction` method, which is used for setting up logic shared
    across child classes, usually things like loading the entire layout, setting up
    the active menu flag, and adding breadcrumbs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有`_initAction`方法，这个方法用于设置子类之间共享的逻辑，通常包括加载整个布局、设置活动菜单标志和添加面包屑。
- en: 'Moving forward, we define the `Index` controller action within the `app/code/Foggyline/Helpdesk/Controller/Adminhtml/Ticket/Index.php`
    file as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在前进的过程中，我们在`app/code/Foggyline/Helpdesk/Controller/Adminhtml/Ticket/Index.php`文件中定义了`Index`控制器动作如下：
- en: '[PRE38]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Controller actions execute within their own class, within the `execute` method.
    Our `execute` method first checks if the coming request is the AJAX parameter
    within it. If there is an AJAX parameter, the request is forwarded to the `Grid`
    action of the same controller.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: If there is no AJAX controller, we simply create the instance of the `\Magento\Framework\View\Result\PageFactory`
    object, and set title, active menu item, and breadcrumbs in it.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: A logical question at this point would be how does all of this work and where
    can we see it. If we log in to the Magento admin area, under the **Customers**
    menu we should be able to see the **Helpdesk Tickets** menu item. This item, defined
    previously within `app/code/Foggyline/Helpdesk/etc/adminhtml/menu.xml`, says the
    menu `action` attribute equals to `foggyline_helpdesk/ticket/index`, which basically
    translates to the `Index` action of our `Ticket` controller.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Once we click on the **Helpdesk Tickets** link, Magento will hit the `Index`
    action within its `Ticket` controller and try to find the XML file that has the
    matching route *{id}+{controller name }+{controller action name }+{xml file extension
    }*, which in our case translates to *{foggyline_helpdesk}+{ticket}+{index}+{.xml}*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we should be able to see the screen, as shown in the following
    screenshot:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating controller actions](img/00101.jpeg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
- en: However, if we now try to use sorting or filtering, we would get a broken layout.
    This is because based on arguments defined under the `foggyline_helpdesk_ticket_grid_block.xml`
    file, we are missing the controller `Grid` action. When we use sorting or filtering,
    the AJAX request hits the `Index` controller and asks to be forwarded to the `Grid`
    action, which we haven't defined yet.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'We now define the `Grid` action within the `app/code/Foggyline/Helpdesk/Controller/Adminhtml/Ticket/Grid.php`
    file as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There is only one `execute` method with the `Grid` controller action class,
    which is expected. The code within the `execute` method simply calls the `loadLayout(false)`
    method to prevent the entire layout loading, making it load only the bits defined
    under the `foggyline_helpdesk_ticket_grid.xml` file. This effectively returns
    the grid HTML to the AJAX, which refreshes the grid on the page.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to handle the `Close` action link we see on the grid. This
    link was defined as part of the column definition within the `foggyline_helpdesk_ticket_grid_block.xml`
    file and points to `*/*/close`, which translates to "router as relative from current
    URL / controller as relative from current URL / close action", which further equals
    to our `Ticket` controller `Close` action.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the `Close` controller action under the `app/code/Foggyline/Helpdesk/Controller/Adminhtml/Ticket/Close.php`
    file as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `Close` action controller has two separate roles to fulfill. One is to change
    the ticket status; the other is to send an e-mail to the customer using the proper
    e-mail template. The class constructor is being passed a lot of parameters that
    all instantiate the objects we will be juggling around.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Within the execute action, we first check for the existence of the `id` parameter
    and then try to load a `Ticket` entity through the ticket factory, based on the
    provided ID value. If the ticket exists, we set its status label to `\Foggyline\Helpdesk\Model\Ticket::STATUS_CLOSED`
    and save it.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Following the ticket save is the e-mail-sending code, which is very similar
    to the one that we already saw in the customer **New Ticket** save action. The
    difference is that the e-mail goes out from the admin user to the customer this
    time. We are setting the template ID to the configuration value at path `foggyline_helpdesk/email_template/customer`.
    The `setTemplateVars` method is passed to the member array this time, both `ticket`
    and `customer_name`, as they are both used in the e-mail template. The `setFrom`
    method is passed the general store username and e-mail, and the `sendMessage`
    method is called on the `transport` object.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Finally, using the `resultRedirectFactory` object, the user is redirected back
    to the tickets grid.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: With this, we finalize our module functional requirement.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Though we are done with the functional requirement of a module, what remains
    for us as developers is to write tests. There are several types of tests, such
    as unit, functional, integration, and so on. To keep things simple, within this
    chapter we will cover only unit tests across a single model class.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Creating unit tests
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that we have PHPUnit configured and available on the command
    line. If this is not the case, PHPUnit can be installed using instructions from
    the [https://phpunit.de/](https://phpunit.de/) website.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'To build and run tests using the PHPUnit testing framework, we need to define
    test locations and other configuration options via an XML file. Magento defines
    this XML configuration file under `dev/tests/unit/phpunit.xml.dist`. Let''s make
    a copy of that file under `dev/tests/unit/phpunit-foggyline-helpdesk.xml`, with
    adjustments as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Tip
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are making a special XML configuration file for our module alone because
    we want to quickly run a few of the tests contained within our module alone and
    not the entire Magento `app/code` folder.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Given that the actual art of writing unit tests is beyond the scope of this
    book and writing the full unit test with 100 percent code coverage for this simple
    module would require at least a dozen more pages, we will only write a single
    test, one that covers the `Ticket` entity model class.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'We define our `Ticket` entity model class test under the `app/code/Foggyline/Helpdesk/Test/Unit/Model/TicketTest.php`
    file as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The location of test files should map those of the files being tested. The naming
    of the test file should also follow the naming of the file being tested with the
    suffix `Test` attached to it. This means that if our `Ticket` model is located
    under the modules `Model/Ticket.php` file, then our test should be located under
    `Test/Unit/TicketTest.php`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Our `Foggyline\Helpdesk\Test\Unit\Model\TicketTest` extends the `\PHPUnit_Framework_TestCase`
    class. There is a `setUp` method we need to define, which acts like a constructor,
    where we set up the variables and everything that requires initializing.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Using Magento `ObjectManager`, we instantiate the `Ticket` model, which is then
    used within the test methods. The actual test methods follow a simple naming pattern,
    where the name of the method from the `Ticket` model matches the {*test}+{method
    name}* from the `TicketTest` class.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined four test methods: `testGetSeveritiesOptionArray`, `testGetStatusesOptionArray`,
    `testGetStatusAsLabel`, and `testGetSeverityAsLabel`. Within the test methods,
    we are using only `assertEquals` and `assertNotEmpty` methods from the PHPUnit
    testing framework library to do basic checks.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now open a console, change the directory to our Magento installation
    directory, and execute the following command:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After the command executes, the console should show an output as shown:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Looking back at our `dev/tests/unit/phpunit-foggyline-helpdesk.xml` file, under
    the `target` attribute of the `phpunit` > `logging` > `log` element, we can see
    that the test report is dumped into the `coverage_dir/Foggyline_Helpdesk/test-reports/coverage`
    folder relative to the XML file.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open the `dev/tests/unit/coverage_dir/Foggyline_Helpdesk/test-reports/coverage/`
    folder, we should see a whole lot of files generated there, as shown in the following
    screenshot:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating unit tests](img/00102.jpeg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
- en: 'Opening the `index.html` file in the browser should give us a page as shown
    in the following screenshot:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating unit tests](img/00103.jpeg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: We can see the code coverage report showing 60% on lines and methods for our
    `Model` folder and 0% for the rest. This is because we only wrote the test for
    the `Ticket` entity model class, whereas the rest remain untested.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter gave a full step-by-step guide to writing a simple yet functional
    Magento module. Seemingly simple in terms of functionality, we can see that the
    module code is significantly scattered across multiple PHP, XML, and PHMTL files.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: With this simple module, we covered quite a lot of various Magento platform
    parts, from routes, ACLs, controllers, blocks, XML layouts, grids, controller
    actions, models, resources, collections, install scripts, interactions with session,
    e-mail templates, e-mail transport, and layout objects.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: At the end, we wrote a few simple unit tests for our models. Although the practice
    is to write unit tests for all of our PHP code, we opted for a shorter version
    or else we would need more pages to cover everything.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为我们的模型编写了一些简单的单元测试。尽管通常的做法是为所有 PHP 代码编写单元测试，但我们选择了简短版本，否则我们需要更多页面来涵盖所有内容。
- en: 'The full module code is available here: [https://github.com/ajzele/B05032-Foggyline_Helpdesk](https://github.com/ajzele/B05032-Foggyline_Helpdesk).'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的模块代码可在以下链接获取：[https://github.com/ajzele/B05032-Foggyline_Helpdesk](https://github.com/ajzele/B05032-Foggyline_Helpdesk).
- en: With this being the last chapter, let us look at a short overview of the things
    we learned throughout the whole book. Our journey started by grasping the Magento
    platform architecture, where we gained significant insight into the technology
    stack behind it. We then progressed to environment management. Although it might
    seem like a wrong order of things, we opted for this next step in order to quickly
    get us set for development. We then looked into programming concepts and conventions,
    which served as a precursor to actual hands-on development bits. Details of entity
    persistence were shown through model, resource, collection classes, and indexers.
    We further covered the importance and practical details of dependency injection
    and interception. Backend and frontend-related development was covered in their
    own two chapters, outlining the most common bits and pieces for making customizations
    to our Magento platform. We then dug into details of the web API, showing how
    to make authenticated API calls and even define our own APIs. Along the way, we
    covered a few major functional areas as well, such as customers, reports, import
    export, cart, and so on. The testing and QA took up a significant chunk as we
    briefly covered all forms of available tests. Finally, we used what we learned
    to build a fully functional module.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一章，让我们简要回顾一下全书所学的内容。我们的旅程从掌握 Magento 平台架构开始，我们对它背后的技术栈有了深刻的洞察。然后我们转向环境管理。尽管这可能看起来像是事物的错误顺序，但我们选择这一步是为了快速为我们开发做好准备。然后我们探讨了编程概念和约定，这为实际动手开发奠定了基础。通过模型、资源、集合类和索引器展示了实体持久化的细节。我们还进一步介绍了依赖注入和拦截的重要性及其实际细节。后端和前端相关开发各自在两章中进行了介绍，概述了为我们的
    Magento 平台进行定制时最常见的一些内容。然后我们深入研究了 Web API 的细节，展示了如何进行认证的 API 调用甚至定义我们自己的 API。在这个过程中，我们还覆盖了一些主要的功能区域，如客户、报告、导入导出、购物车等。测试和
    QA 占据了相当大的篇幅，因为我们简要地介绍了所有可用的测试形式。最后，我们利用所学知识构建了一个功能齐全的模块。
- en: Although we have covered a significant path on our journey, this is merely a
    first step. Given its massive code base, diverse technology stacks, and feature
    list, Magento is not an easy platform to master. Hopefully, this book will give
    enough incentive to take further steps into profiling ourselves as true Magento
    experts.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在旅途中已经走过了相当长的路，但这仅仅是一个第一步。鉴于其庞大的代码库、多样的技术栈和功能列表，Magento 并不是一个容易掌握的平台。希望这本书能提供足够的动力，让我们进一步深入，成为真正的
    Magento 专家。
