- en: Chapter 12. Building a Module from Scratch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on the knowledge acquired from previous chapters, we will now build a
    miniature `Helpdesk` module. Though miniature, the module will showcase the usage
    of several important Magento platform features as we go through the following
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Registering a module (`registration.php` and `module.xml`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a configuration file (`config.xml`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating e-mail templates (`email_templates.xml`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a system configuration file (`system.xml`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating access control lists (`acl.xml`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an installation script (`InstallSchema.php`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing entity persistence (model, resource, collection)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a frontend interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a backend interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Module requirements are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Name used, `Foggyline/Helpdesk`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data to be stored in table is called `foggyline_helpdesk_ticket`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tickets entity will contain `ticket_id`, `customer_id`, `title`, `severity`,
    `created_at`, and `status` properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `customer_id` property is to be foreign key on the `customer_entity` table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There will be three available ticket severity values: `low`, `medium`, and
    `high`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If not specified, the default severity value for new tickets is `low`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There will be two available ticket statuses: `opened` and `closed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If not specified, the default status value for new tickets is `opened`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two e-mails templates: `store_owner_to_customer_email_template` and `customer_to_store_owner_email_template`
    are to be defined for pushing e-mail updates upon ticket creation and status change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customers will be able to submit a ticket through their **My Account** section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customers will be able to see all of their previously submitted tickets under
    their **My Account** section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customers will not be able to edit any existing tickets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a customer submits a new ticket, transactional e-mail (let's call it **Foggyline**
    – **Helpdesk** – **Customer** | **Store Owner**) is sent to the store owner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurable option is required for possibly overriding **Foggyline** – **Helpdesk**
    – **Customer** | **Store Owner** e-mail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Admin users will be able to access a list of all tickets under **Customers**
    | **Helpdesk Tickets**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Admin users will be able to change ticket status from **Opened** to **Closed**
    and other way round
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once an admin user changes the ticket status, transactional e-mail (let's call
    it **Foggyline** – **Helpdesk** – **Store Owner** | **Customer**) is sent to the
    customer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurable option is required for possibly overriding **Foggyline** – **Helpdesk**
    – **Store Owner** | **Customer** e-mail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the requirements outlined, we are ready to begin our module development.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We first start by defining the `app/code/Foggyline/Helpdesk/registration.php`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define the `app/code/Foggyline/Helpdesk/etc/module.xml` file with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the preceding file, if we strip away the boilerplate that repeats
    itself across all modules, we are left with three important things here:'
  prefs: []
  type: TYPE_NORMAL
- en: The module name attribute, defined as `Foggyline_Helpdesk`. We need to be sure
    to follow a certain pattern when naming our modules, like `Vendor` + `_` + `Module`
    name. The module name attribute can contain only letters and numbers [A-Z, a-z,
    0-9, _].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The schema `setup_version` attribute that defines our module version. Its value
    can contain only numbers [0-9]. Our example sets the value of `1.0.0` for the
    `setup_version` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sequence module name attribute, which defines module dependencies. Our module
    basically says it requires `Magento_Store` and `Magento_Customer` modules to be
    enabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once this file is in place, we need to go to the command line, change the directory
    to that of Magento installation, and simply execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we now open either the admin of the frontend area in our browser,
    we might get an error page, which generates the following error under the `var/reports/`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily, the error is pretty self-descriptive so we simply move back to the
    console, change the directory to the Magento root folder, and execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Executed commands will activate our module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can confirm that by looking under the `app/etc/config.php` file, as shown
    in the following screenshot (on line 33):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering a module](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Further if we log in to the admin area, and go to **Stores** | **Configuration**
    | **Advanced** | **Advanced**, we should see our module listed there, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering a module](img/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a configuration file (config.xml)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will create an `app/code/Foggyline/Helpdesk/etc/config.xml` file with
    the content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This might look confusing at first as to where the `default` | `foggyline_helpdesk`
    | `email_template` structure comes from. The structure itself denotes the position
    of our configuration values that we will map to the administrative interface visible
    in our browser under the **Stores** | **Configuration** section. Given that all
    things visual regarding the **Stores** | **Configuration** section originate from
    `system.xml` files, this structure we have now in `config.xml` will then map to
    another `system.xml` file we will define soon.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, just remember the structure and the values contained within the `customer`
    and `store_owner` attributes. These values will further map to another `email_templates.xml`
    file, which we will soon create.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more important thing regarding the `config.xml` file. We need to
    be very careful of the `xsi:noNamespaceSchemaLocation` attribute value. This value
    needs to be set to `urn:magento:module:Magento_Store:etc/config.xsd`. It's an
    alias that actually points to the `vendor/magento/module-store/etc/config.xsd`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating e-mail templates (email_templates.xml)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our module requirements specify that two e-mail templates need to be defined.
    Hints to this have already been given in the `app/code/Foggyline/Helpdesk/etc/config.xml`
    file previously defined. The actual definition of e-mail templates available to
    our modules is done through the `app/code/Foggyline/Helpdesk/etc/email_templates.xml
    file`, with the content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Looking into `email_templates.xsd`, we can conclude that the values for `id`,
    `label`, `file`, `type`, and `module` are all required. `id` should be defined
    unique to our module, giving some sensible and reasonable code name to our e-mail
    templates, as this code name is going to be used further in other XML files or
    in code.
  prefs: []
  type: TYPE_NORMAL
- en: What we defined as ID values here, can be found under `app/code/Foggyline/Helpdesk/etc/config.xml`,
    as the value of `default` | `foggyline_helpdesk` | `email_template` | `customer`
    and `default` | `foggyline_helpdesk` | `email_template` | `store_owner` elements.
  prefs: []
  type: TYPE_NORMAL
- en: If it is not yet fully clear what the connection between the two is; we will
    get to it when we start building our `system.xml` file soon.
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `label` attribute is something that is visible later on, within
    the Magento admin area under **Marketing** | **Communications** | **Email Templates**,
    so be sure to put something user friendly and easily recognizable here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, the values of the `file` attribute point to the location of the following
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app/code/Foggyline/Helpdesk/view/frontend/email/customer_to_store_owner.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app/code/Foggyline/Helpdesk/view/frontend/email/store_owner_to_customer.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The content of the files will be set such that later on, in the code, we will
    need to pass it on certain variables in order to fill in the variable placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `customer_to_store_owner.html` e-mail template, with content as follows,
    will be triggered later on in the code when a customer creates a new ticket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Later on, we will see how to pass the `ticket` object as a variable into the
    template, in order to enable calls like `{{var ticket.title}}` within the HTML
    template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `store_owner_to_customer.html` e-mail template, with content as follows,
    will be triggered later on in the code when the store owner changes the status
    of a ticket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now log in to the Magento admin area, go under **Marketing** | **Communications**
    | **Email Templates**, click on the **Add New Template** button, and we should
    be able to see our two e-mail templates under the **Template** drop-down, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating e-mail templates (email_templates.xml)](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we look back at our `config.xml` and `email_templates.xml`, there is still
    no clear connection as to what `default` | `foggyline_helpdesk` | `email_template`
    | `customer` and `default` | `foggyline_helpdesk` | `email_template` | `store_owner`
    under `config.xml` actually do. That is because we still lack two more ingredients
    that will link them together: the `app/code/Foggyline/Helpdesk/etc/adminhtml/system.xml`
    and `app/code/Foggyline/Helpdesk/etc/acl.xml files`.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a system configuration file (system.xml)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `system.xml` file is essentially the **Stores** | **Configuration** interface
    builder. Entries we define in our module's `system.xml` file will render certain
    parts of the **Stores** | **Configuration** interface under the Magento admin
    area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the previous two XML files, this configuration file is located under
    an additional subfolder, so its full path goes like `app/code/Foggyline/Helpdesk/etc/adminhtml/system.xml`,
    with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Even though we have a lot going on in this file, it can all be summed up in
    a few important bits.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Determining where we want to show our module configuration options is a matter
    of choice. Either we define and use our own tab or we use an existing tab from
    one of the core modules. It really comes down to where we decide to put our configuration
    options.
  prefs: []
  type: TYPE_NORMAL
- en: '`system.xml` defines one tab, as noted by the tab element assigned `id` attribute
    value of `foggyline`. We can have multiple tabs defined under a single `system.xml`
    file. The tab element attribute `id` needs to be unique under all tabs, not just
    those defined within our module. Within the `tab` element, we have a `label` element
    with the value of `Foggyline`. This value is what shows up under the Magento admin
    **Stores** | **Configuration** area.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final results should be as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a system configuration file (system.xml)](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Magento has six pre-existing tabs defined (**General**, **Service**, **Advanced**,
    **Catalog**, **Customer**, **Sales**) across its core modules. We can easily get
    a list of all defined tabs in Magento just by doing a search for the `tab` string,
    filtering only on files named `system.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Next to the `tab` element, we have the `config` | `system` | `section` element.
    This is the element within which we further define what are to become HTML input
    fields for accepting configuration options, as visible on the previous image.
  prefs: []
  type: TYPE_NORMAL
- en: We can have multiple sections defined within a single `system.xml` file. The
    actual `section` element attributes require us to specify the `id` attribute value,
    which in our example is set to `foggyline_helpdesk`. Other important `section`
    element attributes are `showInWebsite` and `showInStore`. These can have either
    `0` or `1` as a value. Depending on our module business logic, we might find a
    good reason for choosing one value over the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking further, the elements contained within our `section` element are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`label`: This specifies the label we will see under the Magento admin **Store**
    | **Configuration** area.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tab`: This specifies the ID value of a tab under which we want this section
    to appear, which in our case equals to `foggyline`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource`: This specifies the ACL resource ID value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`group`: This specifies the group of fields. Similar to the `section` element,
    it also has `id`, `sortOrder`, `showInWebsite`, and `showInStore` attributes.
    Further, the group element has child field elements, which translate to HTML input
    fields under the Magento admin **Store** | **Configuration** area.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defined two fields, `customer` and `store_owner`. Similar to `section` and
    `group`, `field` elements also have `id`, `sortOrder`, `showInWebsite`, and `showInStore`
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how `field` further contains child elements that define its options.
    Given that our `field` element type attribute was set to `select` with both fields,
    we needed to define the `source_model` element within each `field`. Both fields
    have the same `source_model` value which points to the Magento core class, `Magento\Config\Model\Config\Source\Email\Template`.
    Looking into that class, we can see it implements `\Magento\Framework\Option\ArrayInterface`
    and defines the `toOptionArray` method. During rendering the admin **Stores**
    | **Configuration** area, Magento will call this method to fill in the values
    for the select HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Understanding what we can do with `system.xml` comes down to understanding what
    is defined under `vendor/magento/module-config/etc/system_file.xsd` and studying
    existing Magento core module `system.xml` files to get some examples.
  prefs: []
  type: TYPE_NORMAL
- en: As noted previously, our `system.xml` has a resource element that points to
    the `app/code/Foggyline/Helpdesk/etc/acl.xml` file, which we will now look into.
  prefs: []
  type: TYPE_NORMAL
- en: Creating access control lists (acl.xml)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `app/code/Foggyline/Helpdesk/etc/acl.xml` file is where we define our module
    access control list resources. Access control list resources are visible under
    the Magento admin **System** | **Permissions** | **User Roles** area, when we
    click on the **Add New Role** button, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating access control lists (acl.xml)](img/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking at the preceding screenshot, we can see our **Helpdesk Section** under
    **Stores** | **Settings** | **Configuration**. How did we put it there? We have
    defined it in our `app/code/Foggyline/Helpdesk/etc/acl.xml` file with content
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the provided code, the immediate conclusion is that resources can
    be nested into each other. It is unclear how we should know where to nest our
    custom-defined resource with an ID value of `Foggyline_Helpdesk::helpdesk`. The
    simple answer is we followed the Magento structure. By looking into a few of the
    Magento core modules `system.xml` files and their `acl.xml` files, a pattern emerged
    where modules nest their resource under `Magento_Backend::admin` | `Magento_Backend::stores`
    | `Magento_Backend::stores_settings` | `Magento_Config::config`. These are all
    existing resources defined in core Magento, so we are merely referencing them,
    not defining them. The only resource we are defining in our `acl.xml` file is
    our own, which we are then referencing from our `system.xml` file. We can define
    other resources within `acl.xml` and not all would be nested into the same structure
    as `Foggyline_Helpdesk::helpdesk`.
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `title` attribute we assign to a resource element is shown
    in the admin area, as in the previous screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure to use a descriptive label so that our module resource is easily recognizable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an installation script (InstallSchema.php)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`InstallSchema`, or install script, is a way for us to set up tables in the
    database that will be used to persist our models later on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look back at the module requirements, the following fields need to be
    created in the `foggyline_helpdesk_ticket` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ticket_id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`customer_id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`severity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created_at`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `InstallSchema` is defined under the `app/code/Foggyline/Helpdesk/Setup/InstallSchema.php`
    file with (partial) content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `InstallSchema` class conforms to `InstallSchemaInterface` by implementing
    a single `install` method. Within this method, we start the installer, create
    new tables, create new fields, add indexes and foreign keys to the table, and
    finally end the installer, as shown in the following (partial) code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The provided code shows each of the fields from the module requirement being
    added to the database using the `addColumn` method call and passing it certain
    parameters such as the `field type` and `nullable` state. It is worth getting
    familiar with the `addColumn`, `addIndex`, and `addForeignKey` methods as these
    are most commonly used when specifying new tables for our modules.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could further deepen our understanding of the installation script by studying
    how other core modules handle the `InstallSchema.php` file. Following a good database
    design practice, we should always create indexes and foreign keys on our table
    when referencing data from other tables.
  prefs: []
  type: TYPE_NORMAL
- en: Managing entity persistence (model, resource, collection)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With `InstallSchema` in place, we now have conditions for entity persistence.
    Our next step is to define model, resource, and collection classes for the `Ticket`
    entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Ticket` entity model class is defined under the `app/code/Foggyline/Helpdesk/Model/Ticket.php`
    file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Reading the preceding code, we see it extends the `\Magento\Framework\Model\AbstractModel`
    class, which further extends the `\Magento\Framework\Object` class. This brings
    a lot of extra methods into our `Ticket` model class, such as `load`, `delete`,
    `save`, `toArray`, `toJson`, `toString`, `toXml`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The only actual requirement for us is to define the `_construct` method that,
    through the `_init` function call, specifies the resource class the model will
    be using when persisting data. We have set this value to `Foggyline\Helpdesk\Model\ResourceModel\Ticket`,
    which will be the next class we will define, the so-called resource class.
  prefs: []
  type: TYPE_NORMAL
- en: We have further defined several constants, `STATUS_*` and `SEVERITY_*`, as a
    sign of good programming practice and not to hardcode values that we will use
    across the code, which we can centralize into a class constant. These constants,
    in a way, map to our module requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we have three additional methods (`getSeveritiesOptionArray`,
    `getStatusAsLabel`, and `getSeverityAsLabel`) that we will use later on in our
    block class and template file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Ticket` entity resource class is defined under `app/code/Foggyline/Helpdesk/Model/ResourceModel/Ticket.php`
    with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can see the code extends the `\Magento\Framework\Model\ResourceModel\Db\AbstractDb`
    class, which further extends the \`Magento\Framework\Model\ResourceModel\AbstractResource`
    class. This brings a lot of extra methods into our `Ticket` resource class, such
    as `load`, `delete`, `save`, `commit`, `rollback`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The only actual requirement for us is to define the _construct method, through
    which we call the `_init` function that accepts two parameters. The first parameter
    of the `_init` function specifies the table name `foggyline_helpdesk_ticket` and
    the second parameter specifies identifying the `ticket_id` column within that
    table where we will be persisting data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we define the `Ticket` entity collection class under `app/code/Foggyline/Helpdesk/Model/ResourceModel/Ticket/Collection.php`
    with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The collection class code extends the `\Magento\Framework\Model\ResourceModel\Db\Collection\AbstractCollection`
    class, which further extends the `\Magento\Framework\Data\Collection\AbstractDb`
    class, which further extends `\Magento\Framework\Data\Collection`. The final parent
    collection class then implements the following interfaces: `\IteratorAggregate`,
    `\Countable`, `Magento\Framework\Option\ArrayInterface`, and `Magento\Framework\Data\CollectionDataSourceInterface`.
    Through this deep inheritance, a large number of methods become available to our
    collection class, such as `count`, `getAllIds`, `getColumnValues`, `getFirstItem`,
    `getLastItem`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: With regard to our newly defined collection class, the only actual requirement
    for us is to define the `_construct` method. Within the `_construct` method, we
    call the `_init` function to which we pass two parameters. The first parameter
    specifies the `Ticket` model class `Foggyline\Helpdesk\Model\Ticket` and the second
    parameter specifies the `Ticket` resource class `Foggyline\Helpdesk\Model\ResourceModel\Ticket`.
  prefs: []
  type: TYPE_NORMAL
- en: The three classes we just defined (`model`, `resource`, `collection`) act as
    an overall single entity persistence mechanism. With the currently defined code,
    we are able to save, delete, update, lookup with filtering, and list our `Ticket`
    entities, which we demonstrate in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Building a frontend interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have defined the necessary minimum for data persistence functionality,
    we can move forward to building a frontend interface. The module requirement says
    that customers should be able to submit a ticket through their **My Account**
    section. We will therefore add a link called **Helpdesk Tickets** under the customer's
    **My Account** section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are needed for a fully functional frontend:'
  prefs: []
  type: TYPE_NORMAL
- en: A route that will map to our controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A controller that will catch requests from a mapped route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A controller action that will load the layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout XMLs that will update the view making it look as if we are on the **My
    Account** section while providing content of our own
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A block class to power our template file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A template file that we will render into the content area of a page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A controller action that will save the **New Ticket** form once it is posted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating routes, controllers, and layout handles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by defining a route within the `app/code/Foggyline/Helpdesk/etc/frontend/routes.xml`
    file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that the route element `id` and `frontName` attributes have the same value,
    but they do not serve the same purpose, as we will see soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we define our controller `app/code/Foggyline/Helpdesk/Controller/Ticket.php`
    file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Our controller loads the customer session object through its constructor. The
    customer session object is then used within the dispatch method to check if the
    customer is authenticated or not. If the customer is not authenticated, all frontend
    actions in the Internet browser that lead to this controller will result in the
    customer being redirected to the login screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the controller is in place, we can then define the actions that extend
    from it. Each action is a class file on its own, extending from the parent class.
    We will now define our index action, the one that will render the view under **My
    Account** | **Helpdesk Tickets**, within the `app/code/Foggyline/Helpdesk/Controller/Ticket/Index.php`
    file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Controller action code lives within the `execute` method of its class. We simply
    extend from the `\Foggyline\Helpdesk\Controller\Ticket` controller class and define
    the necessary logic within the execute method. Simply calling `loadLayout` and
    `renderLayout` is enough to render the page on the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The frontend XML layout handles reside under the `app/code/Foggyline/Helpdesk/view/frontend/layout`
    folder. Having the route ID, controller, and controller action is enough for us
    to determine the handle name, which goes by formula *{route id}_{controller name}_{controller
    action name}.xml*. Thus, we define an index action layout within the `app/code/Foggyline/Helpdesk/view/frontend/layout/foggyline_helpdesk_ticket_index.xml`
    file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we immediately call the update directive, passing it the `customer_account`
    handle attribute value. This is like saying, "Include everything from the `customer_account`
    handle into our handle here." We are further referencing the content block, within
    which we define our own custom block type `Foggyline\Helpdesk\Block\Ticket\Index`.
    Though a block class can specify its own template, we are using a template attribute
    with a module-specific path, `Foggyline_Helpdesk::ticket/index.phtml`, to assign
    a template to a block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply including the `customer_acount` handle is not enough; we need something
    extra to define our link under the **My Account** section. We define this extra
    something under the `app/code/Foggyline/Helpdesk/view/frontend/layout/customer_account.xml`
    file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'What is happening here is that we are referencing an existing block called
    `customer_account_navigation` and defining a new block within it of class `Magento\Framework\View\Element\Html\Link\Current`.
    This block accepts two parameters: the path that is set to our controller action
    and the label that is set to **Helpdesk Tickets**.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating blocks and templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Foggyline\Helpdesk\Block\Ticket\Index` block class we pointed to from
    `foggyline_helpdesk_ticket_index.xml` is defined under the `app/code/Foggyline/Helpdesk/Block/Ticket/Index.php`
    file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The reason why we defined the `Foggyline\Helpdesk\Block\Ticket` block class
    instead of using just `\Magento\Framework\View\Element\Template` is because we
    wanted to define some helper methods we could then use in our `index.phtml` template.
    These methods are `getTickets` (which we will use for listing all customer tickets)
    and `getSeverities` (which we will use for creating a dropdown of possible severities
    to choose from when creating a new ticket).
  prefs: []
  type: TYPE_NORMAL
- en: 'The template is further defined under the `app/code/Foggyline/Helpdesk/view/frontend/templates/ticket/index.phtml`
    file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Though this is a big chunk of code, it is easily readable as it is divided into
    a few very different role-playing chunks.
  prefs: []
  type: TYPE_NORMAL
- en: The `$block` variable is actually the same as if we wrote `$this`, which is
    a reference to the instance of the `Foggyline\Helpdesk\Block\Ticket` class where
    we defined the actual `getTickets` method. Thus, the `$tickets` variable is first
    defined as a collection of tickets that belong to the currently logged-in customer.
  prefs: []
  type: TYPE_NORMAL
- en: We then specified a form with a `POST` method type and an action URL that points
    to our `Save` controller action. Within the form, we have a `$block->getBlockHtml('formkey')`
    call, which basically returns a hidden input field named `form_key` whose value
    is a random string. Form keys in Magento are a means of preventing against **Cross-Site
    Request Forgery** (**CSRF**), so we need to be sure to use them on any form we
    define. As part of the form, we have also defined a title input field, severity
    select field, and submit button. Notice the CSS classes tossed around, which guarantee
    that our form's look will match those of other Magento forms.
  prefs: []
  type: TYPE_NORMAL
- en: Right after the closing form tag, we have a RequireJS type of JavaScript inclusion
    for validation. Given that our form ID value is set to **form-validate**, the
    JavaScript `dataForm` variable binds to it and triggers a validation check when
    we press the **Submit** button.
  prefs: []
  type: TYPE_NORMAL
- en: We then have a count check and a `foreach` loop that renders all possibly existing
    customer tickets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final result of the template code can be seen in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating blocks and templates](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Handling form submissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one more piece we are missing in order to complete our frontend functionality
    – a controller action that will save the **New Ticket** form once it is posted.
    We define this action within the `app/code/Foggyline/Helpdesk/Controller/Ticket/Save.php`
    file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: First, we look at `__construct` to see what parameters are passed to it. Given
    that the code we run in the `execute` method needs to check if the form key is
    valid, create a ticket in the database, pass on the ticket and some customer info
    to the e-mail that is being sent to the store owner; then, we get an idea of what
    kind of objects are being passed around.
  prefs: []
  type: TYPE_NORMAL
- en: The `execute` method starts by checking the validity of the form key. If the
    form key is invalid, we return with a redirection to the referring URL.
  prefs: []
  type: TYPE_NORMAL
- en: Passing the form key check, we grab the title and severity variables as passed
    by the form. We then instantiate the ticket entity by the ticket factory create
    method and simply set the `ticket` entity values one by one. Note that the `Ticket`
    entity model `Foggyline\Helpdesk\Model\Ticket` does not really have methods like
    `setSeverity` on its own. This is the inherited property of its `\Magento\Framework\Object`
    parent class.
  prefs: []
  type: TYPE_NORMAL
- en: Once the ticket entity is saved, we initiate the `transport builder` object,
    passing along all of the required parameters for successful e-mail sending. Notice
    how `setTemplateIdentifier` uses our `system.xml` configuration option `foggyline_helpdesk/email_template/store_owner`.
    This, if not specifically set under the admin **Store** | **Configuration** |
    **Foggyline** | **Helpdesk** area, has a default value defined under `config.xml`
    that points to the e-mail template ID in the `email_templates.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: '`setTemplateVars` expects the array or instance of `\Magento\Framework\Object`
    to be passed to it. We pass the entire `$ticket` object to it, just nesting it
    under the ticket key, thus making the properties of a `Ticket` entity, like a
    title, become available in the e-mail HTML template as `{{var ticket.title}}`.'
  prefs: []
  type: TYPE_NORMAL
- en: When a customer now submits the **New Ticket** form from **My Account** | **Helpdesk
    Tickets**, the `HTTP POST` request will hit the save controller action class.
    If the preceding code is successfully executed, the ticket is saved to the database
    and redirection back to **My Account** | **Helpdesk Tickets** will occur showing
    a **Ticket successfully created** message in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Building a backend interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have been dealing with setting up general module configuration,
    e-mail templates, frontend route, frontend layout, block, and template. What remains
    to complete the module requirements is the admin interface, where the store owner
    can see submitted tickets and change statuses from open to closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are needed for a fully functional admin interface as per the
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: ACL resource used to allow or disallow access to the ticket listing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menu item linking to tickets listing the controller action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Route that maps to our admin controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout XMLs that map to the ticket listing the controller action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controller action for listing tickets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Full XML layout grid definition within layout XMLs defining grid, custom column
    renderers, and custom dropdown filter values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controller action for closing tickets and sending e-mails to customers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking the access control list and menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by adding a new ACL resource entry to the previously defined `app/code/Foggyline/Helpdesk/etc/acl.xml`
    file, as a child of the `Magento_Backend::admin` resource as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: On its own, the defined resource entry does not do anything. This resource will
    later be used within the menu and controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The menu item linking to the tickets listing the controller action is defined
    under the `app/code/Foggyline/Helpdesk/etc/adminhtml/menu.xml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `menu` | `add` element to add a new menu item under the Magento
    admin area. The position of an item within the admin area is defined by the attribute
    parent, which in our case means under the existing **Customer** menu. If the parent
    is omitted, our item would appear as a new item on a menu. The `title` attribute
    value is the label we will see in the menu. The `id` attribute has to uniquely
    differentiate our menu item from others. The `resource` attribute references the
    ACL resource defined in the `app/code/Foggyline/Helpdesk/etc/acl.xml` file. If
    a role of a logged-in user does not allow him to use the `Foggyline_Helpdesk::ticket_manage`
    resource, the user would not be able to see the menu item.
  prefs: []
  type: TYPE_NORMAL
- en: Creating routes, controllers, and layout handles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we add a route that maps to our admin controller, by defining the `app/code/Foggyline/Helpdesk/etc/adminhtml/routes.xml`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The admin route definition is almost identical to the frontend router definition,
    where the difference primarily lies in the router ID value, which equals to the
    admin here.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the router definition in place, we can now define our three layout XMLs,
    under the `app/code/Foggyline/Helpdesk/view/adminhtml/layout` directory, which
    map to the ticket listing the controller action:'
  prefs: []
  type: TYPE_NORMAL
- en: '`foggyline_helpdesk_ticket_grid.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foggyline_helpdesk_ticket_grid_block.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foggyline_helpdesk_ticket_index.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason we define three layout files for a single action controller and not
    one is because of the way we use the listing in control in the Magento admin area.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of the `foggyline_helpdesk_ticket_index.xml` file is defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Two update handles are specified, one pulling in `formkey` and the other pulling
    in `foggyline_helpdesk_ticket_grid_block`. We then reference the content container
    and define a new block of the `Foggyline\Helpdesk\Block\Adminhtml\Ticket` class
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the grid widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We could have used `Magento\Backend\Block\Widget\Grid\Container` as a block
    class name. However, given that we needed some extra logic, like removing the
    **Add New** button, we opted for a custom class that then extends `\Magento\Backend\Block\Widget\Grid\Container`
    and adds the required logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Foggyline\Helpdesk\Block\Adminhtml\Ticket` class is defined under the
    `app/code/Foggyline/Helpdesk/Block/Adminhtml/Ticket.php` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Not much is happening in the `Ticket` block class here. Most importantly, we
    extend from `\Magento\Backend\Block\Widget\Grid\Container` and define `_controller`
    and `_blockGroup,` as these serve as a sort of glue for telling our grid where
    to find other possible block classes. Since we won't have an **Add New** ticket
    feature in admin, we are calling the `removeButton` method to remove the default
    **Add New** button from the grid container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our second XML layout file, the `foggyline_helpdesk_ticket_grid.xml`
    file, which we define as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the content of `foggyline_helpdesk_ticket_grid.xml` is nearly identical
    to that of `foggyline_helpdesk_ticket_index.xml`. The only difference between
    the two is the value of the `block` class and the template attribute. The `block`
    class is defined as `Magento\Backend\Block\Widget\Grid\Container`, where we previously
    defined it as `Foggyline\Helpdesk\Block\Adminhtml\Ticket`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the content of the `\Magento\Backend\Block\Widget\Grid\Container`
    class, we can see the following property defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the content of the `vendor/magento/module-backend/view/adminhtml/templates/widget/grid/container.phtml`
    and `vendor/magento/module-backend/view/adminhtml/templates/widget/grid/container/empty.phtml`
    files, the difference can be easily spotted. `container/empty.phtml` only returns
    grid HTML, whereas `container.phtml` returns buttons and grid HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Given that `foggyline_helpdesk_ticket_grid.xml` will be a handle for the AJAX
    loading grid listing during sorting and filtering, we need it to return only grid
    HTML upon reload.
  prefs: []
  type: TYPE_NORMAL
- en: We now move on to the third and largest of XML's layout files, the `app/code/Foggyline/Helpdesk/view/adminhtml/layout/foggyline_helpdesk_ticket_grid_block.xml`
    file. Given the size of it, we will split it into two code chunks as we explain
    them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part, or initial content of the `foggyline_helpdesk_ticket_grid_block.xml`
    file, is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice `<!-- Column definitions here -->`; we will come back to that soon. For
    now, let's analyze what is happening here. Right after a body element, we have
    a reference to `admin.block.helpdesk.ticket.grid.container`, which is a content
    block child defined under the `foggyline_helpdesk_ticket_grid.xml` and `foggyline_helpdesk_ticket_index.xml`
    files. Within this reference, we are defining another block of class `Magento\Backend\Block\Widget\Grid`,
    passing it a name of our choosing and an alias. Further, this block has an arguments
    list and another block of class `Magento\Backend\Block\Widget\Grid\ColumnSet`
    as child elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Through the arguments list we specify the:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: Set to the value of `ticketGrid`, we can set any value we want here,
    ideally sticking to formula *{entity name}*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dataSource`: Set to the value of `Foggyline\Helpdesk\Model\ResourceModel\Ticket\Collection`,
    which is the name of our `Ticket` entity resource class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default_sort`: Set to the value of `ticket_id`, which is the property of the
    `Ticket` entity by which we want to sort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default_dir`: Set to the value of `desc`, to denote a descending order of
    sorting. This value functions together with `default_sort` as a single unit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`save_parameters_in_session`: Set to `true`, this is easiest to explain using
    the following example: if we do some sorting and filtering on the `Ticket` grid
    and then move on to another part of the admin area, then come back to `Ticket`
    grid, if this value is set to **yes**, the grid we see will have those filters
    and sorting set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use_ajax`: Set to `true`, when grid filtering and sorting is triggered, an
    AJAX loader kicks in and reloads only the grid area and not the whole page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Right after the grid blocks argument list, we have the grid column set. This
    brings us to the second part of `foggyline_helpdesk_ticket_grid_block.xml` content.
    We simply replace the `<!-- Columns here -->` comment with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to grid, column definitions also have arguments that define its look
    and behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '`header`: Mandatory, the value we want to see as a label on top of the column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: Mandatory, can be anything from: `date`, `datetime`, `text`, `longtext`,
    `options`, `store`, `number`, `currency`, `skip-list`, `wrapline`, and `country`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id`: Mandatory, a unique value that identifies our column, preferably matching
    the name of the entity property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index`: Mandatory, the database column name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options`: Optional, if we are using a type like options, then for the options
    argument we need to specify the class like `Foggyline\Helpdesk\Model\Ticket\Grid\Severity`
    that implements `\Magento\Framework\Option\ArrayInterface`, meaning it provides
    the `toOptionArray` method that then fills the values of options during grid rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`renderer`: Optional, as our `Ticket` entities store severity and status as
    integer values in the database, columns would render those integer values into
    columns, which is not really useful. We want to turn those integer values into
    labels. In order to do so, we need to rewrite the rendering bit of a single table
    cell, which we do with the help of the renderer argument. The value we pass to
    it, `Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Severity`, needs
    to be a class that extends `\Magento\Backend\Block\Widget\Grid\Column\Renderer\AbstractRenderer`
    and does its own implementation of the render method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`header_css_class`: Optional, if we prefer to specify a custom header class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`column_css_class`: Optional, if we prefer to specify a custom column class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a grid column renderer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Severity` class,
    defined in the `app/code/Foggyline/Helpdesk/Block/Adminhtml/Ticket/Grid/Renderer/Severity.php`
    file, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are passing the instance of the ticket factory to the constructor and
    then using that instance within the render method to load a ticket based on the
    ID value fetched from the current row. Given that `$row->getId()` returns the
    ID of the ticket, this is a nice way to reload the entire ticket entity and then
    fetch the full label from the ticket model by using `$ticket->getSeverityAsLabel()`.
    Whatever string we return from this method is what will be shown under the grid
    row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another renderer class that is referenced within the `foggyline_helpdesk_ticket_grid_block.xml`
    file is `Foggyline\Helpdesk\Block\Adminhtml\Ticket\Grid\Renderer\Status`, and
    we define its content under the `app/code/Foggyline/Helpdesk/Block/Adminhtml/Ticket/Grid/Renderer/Status.php`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Given that it too is used for a renderer, the content of the `Status` class
    is nearly identical to the content of the `Severity` class. We pass on the ticket
    factory object via the constructor, so we have it internally for usage within
    the `render` method. Then we load the `Ticket` entity using the ticket factory
    and ID value fetched from a `$row` object. As a result, the column will contain
    the label value of a status and not its integer value.
  prefs: []
  type: TYPE_NORMAL
- en: Creating grid column options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides referencing renderer classes, our `foggyline_helpdesk_ticket_grid_block.xml`
    file also references the `options` class for the `Severity` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the `Foggyline\Helpdesk\Model\Ticket\Grid\Severity` options class
    under the `app/code/Foggyline/Helpdesk/Model/Ticket/Grid/Severity.php` file as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `options` value from XML layouts refers to a class that has to implement
    the `toOptionArray` method, which returns an array of arrays, such as the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Our `Severity` class simply calls the static method we have defined on the `Ticket`
    class, the `getSeveritiesOptionArray`, and passes along those values.
  prefs: []
  type: TYPE_NORMAL
- en: Creating controller actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, we have defined the menu item, ACL resource, XML layouts,
    block, `options` class, and `renderer` classes. What remains to connect it all
    are controllers. We will need three controller actions (`Index`, `Grid`, and `Close`),
    all extending from the same admin `Ticket` controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the admin `Ticket` controller under the `app/code/Foggyline/Helpdesk/Controller/Adminhtml/Ticket.php`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things to note here. `$this->resultPageFactory`, `$this->resultForwardFactory`
    and `$this->resultRedirectFactory` are objects to be used on the child (`Index`,
    `Grid`, and `Close`), so we do not have to initiate them in each child class separately.
  prefs: []
  type: TYPE_NORMAL
- en: The `_isAllowed()` method is extremely important every time we have a custom-defined
    controller or controller action that we want to check against our custom ACL resource.
    Here, we are the `isAllowed` method call on the `\Magento\Framework\AuthorizationInterface`
    type of object (`$this->_authorization`). The parameter passed to the `isAllowed`
    method call should be the ID value of our custom ACL resource.
  prefs: []
  type: TYPE_NORMAL
- en: We then have the `_initAction` method, which is used for setting up logic shared
    across child classes, usually things like loading the entire layout, setting up
    the active menu flag, and adding breadcrumbs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward, we define the `Index` controller action within the `app/code/Foggyline/Helpdesk/Controller/Adminhtml/Ticket/Index.php`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Controller actions execute within their own class, within the `execute` method.
    Our `execute` method first checks if the coming request is the AJAX parameter
    within it. If there is an AJAX parameter, the request is forwarded to the `Grid`
    action of the same controller.
  prefs: []
  type: TYPE_NORMAL
- en: If there is no AJAX controller, we simply create the instance of the `\Magento\Framework\View\Result\PageFactory`
    object, and set title, active menu item, and breadcrumbs in it.
  prefs: []
  type: TYPE_NORMAL
- en: A logical question at this point would be how does all of this work and where
    can we see it. If we log in to the Magento admin area, under the **Customers**
    menu we should be able to see the **Helpdesk Tickets** menu item. This item, defined
    previously within `app/code/Foggyline/Helpdesk/etc/adminhtml/menu.xml`, says the
    menu `action` attribute equals to `foggyline_helpdesk/ticket/index`, which basically
    translates to the `Index` action of our `Ticket` controller.
  prefs: []
  type: TYPE_NORMAL
- en: Once we click on the **Helpdesk Tickets** link, Magento will hit the `Index`
    action within its `Ticket` controller and try to find the XML file that has the
    matching route *{id}+{controller name }+{controller action name }+{xml file extension
    }*, which in our case translates to *{foggyline_helpdesk}+{ticket}+{index}+{.xml}*.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we should be able to see the screen, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating controller actions](img/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: However, if we now try to use sorting or filtering, we would get a broken layout.
    This is because based on arguments defined under the `foggyline_helpdesk_ticket_grid_block.xml`
    file, we are missing the controller `Grid` action. When we use sorting or filtering,
    the AJAX request hits the `Index` controller and asks to be forwarded to the `Grid`
    action, which we haven't defined yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now define the `Grid` action within the `app/code/Foggyline/Helpdesk/Controller/Adminhtml/Ticket/Grid.php`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There is only one `execute` method with the `Grid` controller action class,
    which is expected. The code within the `execute` method simply calls the `loadLayout(false)`
    method to prevent the entire layout loading, making it load only the bits defined
    under the `foggyline_helpdesk_ticket_grid.xml` file. This effectively returns
    the grid HTML to the AJAX, which refreshes the grid on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to handle the `Close` action link we see on the grid. This
    link was defined as part of the column definition within the `foggyline_helpdesk_ticket_grid_block.xml`
    file and points to `*/*/close`, which translates to "router as relative from current
    URL / controller as relative from current URL / close action", which further equals
    to our `Ticket` controller `Close` action.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the `Close` controller action under the `app/code/Foggyline/Helpdesk/Controller/Adminhtml/Ticket/Close.php`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `Close` action controller has two separate roles to fulfill. One is to change
    the ticket status; the other is to send an e-mail to the customer using the proper
    e-mail template. The class constructor is being passed a lot of parameters that
    all instantiate the objects we will be juggling around.
  prefs: []
  type: TYPE_NORMAL
- en: Within the execute action, we first check for the existence of the `id` parameter
    and then try to load a `Ticket` entity through the ticket factory, based on the
    provided ID value. If the ticket exists, we set its status label to `\Foggyline\Helpdesk\Model\Ticket::STATUS_CLOSED`
    and save it.
  prefs: []
  type: TYPE_NORMAL
- en: Following the ticket save is the e-mail-sending code, which is very similar
    to the one that we already saw in the customer **New Ticket** save action. The
    difference is that the e-mail goes out from the admin user to the customer this
    time. We are setting the template ID to the configuration value at path `foggyline_helpdesk/email_template/customer`.
    The `setTemplateVars` method is passed to the member array this time, both `ticket`
    and `customer_name`, as they are both used in the e-mail template. The `setFrom`
    method is passed the general store username and e-mail, and the `sendMessage`
    method is called on the `transport` object.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, using the `resultRedirectFactory` object, the user is redirected back
    to the tickets grid.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we finalize our module functional requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Though we are done with the functional requirement of a module, what remains
    for us as developers is to write tests. There are several types of tests, such
    as unit, functional, integration, and so on. To keep things simple, within this
    chapter we will cover only unit tests across a single model class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that we have PHPUnit configured and available on the command
    line. If this is not the case, PHPUnit can be installed using instructions from
    the [https://phpunit.de/](https://phpunit.de/) website.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build and run tests using the PHPUnit testing framework, we need to define
    test locations and other configuration options via an XML file. Magento defines
    this XML configuration file under `dev/tests/unit/phpunit.xml.dist`. Let''s make
    a copy of that file under `dev/tests/unit/phpunit-foggyline-helpdesk.xml`, with
    adjustments as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are making a special XML configuration file for our module alone because
    we want to quickly run a few of the tests contained within our module alone and
    not the entire Magento `app/code` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Given that the actual art of writing unit tests is beyond the scope of this
    book and writing the full unit test with 100 percent code coverage for this simple
    module would require at least a dozen more pages, we will only write a single
    test, one that covers the `Ticket` entity model class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define our `Ticket` entity model class test under the `app/code/Foggyline/Helpdesk/Test/Unit/Model/TicketTest.php`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The location of test files should map those of the files being tested. The naming
    of the test file should also follow the naming of the file being tested with the
    suffix `Test` attached to it. This means that if our `Ticket` model is located
    under the modules `Model/Ticket.php` file, then our test should be located under
    `Test/Unit/TicketTest.php`.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Foggyline\Helpdesk\Test\Unit\Model\TicketTest` extends the `\PHPUnit_Framework_TestCase`
    class. There is a `setUp` method we need to define, which acts like a constructor,
    where we set up the variables and everything that requires initializing.
  prefs: []
  type: TYPE_NORMAL
- en: Using Magento `ObjectManager`, we instantiate the `Ticket` model, which is then
    used within the test methods. The actual test methods follow a simple naming pattern,
    where the name of the method from the `Ticket` model matches the {*test}+{method
    name}* from the `TicketTest` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined four test methods: `testGetSeveritiesOptionArray`, `testGetStatusesOptionArray`,
    `testGetStatusAsLabel`, and `testGetSeverityAsLabel`. Within the test methods,
    we are using only `assertEquals` and `assertNotEmpty` methods from the PHPUnit
    testing framework library to do basic checks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now open a console, change the directory to our Magento installation
    directory, and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After the command executes, the console should show an output as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Looking back at our `dev/tests/unit/phpunit-foggyline-helpdesk.xml` file, under
    the `target` attribute of the `phpunit` > `logging` > `log` element, we can see
    that the test report is dumped into the `coverage_dir/Foggyline_Helpdesk/test-reports/coverage`
    folder relative to the XML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open the `dev/tests/unit/coverage_dir/Foggyline_Helpdesk/test-reports/coverage/`
    folder, we should see a whole lot of files generated there, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating unit tests](img/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Opening the `index.html` file in the browser should give us a page as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating unit tests](img/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can see the code coverage report showing 60% on lines and methods for our
    `Model` folder and 0% for the rest. This is because we only wrote the test for
    the `Ticket` entity model class, whereas the rest remain untested.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter gave a full step-by-step guide to writing a simple yet functional
    Magento module. Seemingly simple in terms of functionality, we can see that the
    module code is significantly scattered across multiple PHP, XML, and PHMTL files.
  prefs: []
  type: TYPE_NORMAL
- en: With this simple module, we covered quite a lot of various Magento platform
    parts, from routes, ACLs, controllers, blocks, XML layouts, grids, controller
    actions, models, resources, collections, install scripts, interactions with session,
    e-mail templates, e-mail transport, and layout objects.
  prefs: []
  type: TYPE_NORMAL
- en: At the end, we wrote a few simple unit tests for our models. Although the practice
    is to write unit tests for all of our PHP code, we opted for a shorter version
    or else we would need more pages to cover everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full module code is available here: [https://github.com/ajzele/B05032-Foggyline_Helpdesk](https://github.com/ajzele/B05032-Foggyline_Helpdesk).'
  prefs: []
  type: TYPE_NORMAL
- en: With this being the last chapter, let us look at a short overview of the things
    we learned throughout the whole book. Our journey started by grasping the Magento
    platform architecture, where we gained significant insight into the technology
    stack behind it. We then progressed to environment management. Although it might
    seem like a wrong order of things, we opted for this next step in order to quickly
    get us set for development. We then looked into programming concepts and conventions,
    which served as a precursor to actual hands-on development bits. Details of entity
    persistence were shown through model, resource, collection classes, and indexers.
    We further covered the importance and practical details of dependency injection
    and interception. Backend and frontend-related development was covered in their
    own two chapters, outlining the most common bits and pieces for making customizations
    to our Magento platform. We then dug into details of the web API, showing how
    to make authenticated API calls and even define our own APIs. Along the way, we
    covered a few major functional areas as well, such as customers, reports, import
    export, cart, and so on. The testing and QA took up a significant chunk as we
    briefly covered all forms of available tests. Finally, we used what we learned
    to build a fully functional module.
  prefs: []
  type: TYPE_NORMAL
- en: Although we have covered a significant path on our journey, this is merely a
    first step. Given its massive code base, diverse technology stacks, and feature
    list, Magento is not an easy platform to master. Hopefully, this book will give
    enough incentive to take further steps into profiling ourselves as true Magento
    experts.
  prefs: []
  type: TYPE_NORMAL
