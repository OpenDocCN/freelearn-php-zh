- en: Chapter 6. Adapting to MVC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。适应MVC
- en: Web applications are more complex than what we have built so far. The more functionality
    you add, the more difficult the code is to maintain and understand. It is for
    this reason that structuring your code in an organized way is crucial. You could
    design your own structure, but as with OOP, there already exist some design patterns
    that try to solve this problem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序比我们迄今为止构建的更复杂。您添加的功能越多，代码的维护和理解就越困难。这就是为什么以有组织的方式组织代码至关重要。您可以设计自己的结构，但就像面向对象编程一样，已经存在一些设计模式试图解决这个问题。
- en: '**MVC** (**model-view-controller**) has been the favorite pattern for web developers.
    It helps us separate the different parts of a web application, leaving the code
    easy to understand even for beginners. We will try to refactor our bookstore example
    to use the MVC pattern, and you will realize how quickly you can add new functionality
    after that.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**MVC**（**模型-视图-控制器**）一直是Web开发者的最爱模式。它帮助我们分离Web应用程序的不同部分，即使对于初学者来说，代码也易于理解。我们将尝试重构我们的书店示例以使用MVC模式，您将意识到在那之后您可以多么快速地添加新功能。'
- en: 'In this chapter, you will learn the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: Using Composer to manage dependencies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Composer管理依赖关系
- en: Designing a router for your application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的应用程序设计路由器
- en: Organizing your code into models, views, and controllers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的代码组织成模型、视图和控制器
- en: Twig as the template engine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Twig作为模板引擎
- en: Dependency injection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: The MVC pattern
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC模式
- en: 'So far, each time we have had to add a feature, we added a new PHP file with
    a mixture of PHP and HTML for that specific page. For chunks of code with a single
    purpose, and which we have to reuse, we created functions and added them to the
    functions file. Even for very small web applications like ours, the code starts
    becoming very confusing, and the ability to reuse code is not as helpful as it
    could be. Now imagine an application with a large number of features: that would
    be pretty much chaos itself.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，每次我们添加新功能时，我们都会为该特定页面添加一个包含PHP和HTML混合的新PHP文件。对于具有单一目的的代码块，并且我们必须重复使用，我们创建了函数并将它们添加到函数文件中。即使是像我们这样非常小的Web应用程序，代码也开始变得非常混乱，代码的重用能力并不像它本可以那样有帮助。现在想象一个具有大量功能的程序：那几乎就是混乱本身。
- en: The problems do not stop here. In our code, we have mixed HTML and PHP code
    in a single file. That will give us a lot of trouble when trying to change the
    design of the web application, or even if we want to perform a very small change
    across all pages, such as changing the menu or footer of the page. The more complex
    the application, the more problems we will encounter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 问题并没有在这里停止。在我们的代码中，我们在一个文件中混合了HTML和PHP代码。当我们试图更改Web应用程序的设计，或者即使我们想要在所有页面上进行非常小的更改，例如更改页面的菜单或页脚时，这会给我们带来很多麻烦。应用程序越复杂，我们遇到的问题就越多。
- en: MVC came up as a pattern to help us divide the different parts of the application.
    These parts are known as models, views, and controllers. **Models** manage the
    data and/or the business logic, **views** contain the templates for our responses
    (for example, HTML pages), and **controllers** orchestrate requests, deciding
    what data to use and how to render the appropriate template. We will go through
    them in later sections of this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: MVC作为一个模式出现，帮助我们划分应用程序的不同部分。这些部分被称为模型、视图和控制器。**模型**管理数据和/或业务逻辑，**视图**包含我们的响应模板（例如，HTML页面），而**控制器**协调请求，决定使用哪些数据以及如何渲染适当的模板。我们将在本章的后续部分中详细介绍它们。
- en: Using Composer
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Composer
- en: Even though this is not a necessary component when implementing the MVC pattern,
    Composer has been an indispensable tool for any PHP web application over the last
    few years. The main goal of this tool is to help you manage the dependencies of
    your application, that is, the third-party libraries (of code) that we need to
    use in our application. We can achieve that by just creating a configuration file
    that lists them, and by running a command in your command line.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在实现MVC模式时这不是一个必要的组件，但Composer在过去几年中一直是任何PHP Web应用程序不可或缺的工具。这个工具的主要目标是帮助您管理应用程序的依赖关系，即我们应用中需要使用的第三方库（代码）。我们可以通过创建一个列出它们的配置文件，并在您的命令行中运行一个命令来实现这一点。
- en: 'You need to install Composer on your development machine (see [Chapter 1](part0014_split_000.html#DB7S1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 1. Setting Up the Environment"), *Setting Up the Environment*). Make
    sure that you have it by executing the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的开发机器上安装Composer（见[第1章](part0014_split_000.html#DB7S1-edcc22b134104d5db0bf3aa086c86851
    "第1章。设置环境")，*设置环境*)。请确保您已执行以下命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This should return the version of your Composer installation. If it does not,
    return to the installation section to fix the problem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会返回您Composer安装的版本。如果它没有这样做，请返回安装部分以解决问题。
- en: Managing dependencies
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理依赖项
- en: As we stated earlier, the main goal of Composer is to manage dependencies. For
    example, we've already implemented our configuration reader, the `Config` class,
    but if we knew of someone that implemented a better version of it, we could just
    use theirs instead of reinventing the wheel; just make sure that they allow you
    to do so!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所述，Composer的主要目标是管理依赖项。例如，我们已经实现了我们的配置读取器，即`Config`类，但如果我们知道有人实现了更好的版本，我们就可以直接使用他们的版本而不是重新发明轮子；只需确保他们允许这样做即可！
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Open source**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**开源**'
- en: Open source refers to the code that developers write and share with the community
    in order to be used by others without restrictions. There are actually different
    types of licenses, and some give you more flexibility than others, but the basic
    idea is that we can reuse the libraries that other developers have written in
    our applications. That helps the community to grow in knowledge, as we can learn
    what others have done, improve it, and share it afterwards.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 开源指的是开发者编写的并与社区共享的代码，以便其他人可以无限制地使用。实际上存在不同类型的许可证，有些比其他提供更大的灵活性，但基本思想是我们可以在我们的应用程序中重用其他开发者编写的库。这有助于社区在知识上的增长，因为我们可以从他人的工作中学习，改进它，并在之后分享它。
- en: 'We''ve already implemented a decent configuration reader, but there are other
    elements of our application that need to be done. Let''s take advantage of Composer
    to reuse someone else''s libraries. There are a couple of ways of adding a dependency
    to our project: executing a command in our command line, or editing the configuration
    file manually. As we still do not have Composer''s configuration file, let''s
    use the first option. Execute the following command in the root directory of your
    application:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了一个不错的配置读取器，但我们的应用程序中还有其他元素需要完成。让我们利用Composer来重用他人的库。向我们的项目添加依赖项有几种方法：在我们的命令行中执行命令，或手动编辑配置文件。由于我们还没有Composer的配置文件，让我们使用第一种方法。在您的应用程序根目录中执行以下命令：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This command will show the following result:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将显示以下结果：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With this command, we asked Composer to add the library `monolog/monolog` as
    a dependency of our application. Having executed that, we can now see some changes
    in our directory:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，我们要求Composer将库`monolog/monolog`添加为我们的应用程序的依赖项。执行后，我们现在可以看到目录中的一些变化：
- en: We have a new file named `composer.json`. This is the configuration file where
    we can add our dependencies.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个名为`composer.json`的新文件。这是配置文件，我们可以在此添加我们的依赖项。
- en: We have a new file named `composer.lock`. This is a file that Composer uses
    in order to track the dependencies that have already been installed and their
    versions.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个名为`composer.lock`的新文件。这是一个Composer用来跟踪已安装的依赖项及其版本的文件。
- en: We have a new directory named `vendor`. This directory contains the code of
    the dependencies that Composer downloaded.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个名为`vendor`的新目录。这个目录包含Composer下载的依赖项代码。
- en: The output of the command also shows us some extra information. In this case,
    it says that it downloaded two libraries or packages, even though we asked for
    only one. The reason is that the package that we needed also contained other dependencies
    that were resolved by Composer. Also note the version that Composer downloaded;
    as we did not specify any version, Composer took the most recent one available,
    but you can always try to write the specific version that you need.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出还显示了一些额外信息。在这种情况下，它说它下载了两个库或包，尽管我们只请求了一个。原因是所需的包也包含其他依赖项，这些依赖项由Composer解决。请注意Composer下载的版本；由于我们没有指定任何版本，Composer选择了可用的最新版本，但您始终可以尝试写入您需要的特定版本。
- en: 'We will need another library, in this case `twig/twig`. Let''s add it to our
    dependencies list with the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要另一个库，在这种情况下是`twig/twig`。让我们使用以下命令将其添加到我们的依赖项列表中：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command will show the following result:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将显示以下结果：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we check the `composer.json` file, we will see the following content:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查`composer.json`文件，我们将看到以下内容：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The file is just a JSON map that contains the configuration of our application;
    in this case, the list of the two dependencies that we installed. As you can see,
    the dependencies'' name follows a pattern: two words separated by a slash. The
    first of the words refers to the vendor that developed the library. The second
    of them is the name of the library itself. The dependency has a version, which
    could be the exact version number—as in this case—or it could contain wildcard
    characters or tag names. You can read more about this at [https://getcomposer.org/doc/articles/aliases.md](https://getcomposer.org/doc/articles/aliases.md).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件只是一个包含我们应用程序配置的JSON映射；在这种情况下，是我们安装的两个依赖项的列表。如您所见，依赖项的名称遵循一个模式：由斜杠分隔的两个单词。第一个单词指的是开发库的供应商。第二个单词是库本身的名称。依赖项有一个版本，可以是确切的版本号，如本例所示，或者可以包含通配符字符或标签名称。您可以在[https://getcomposer.org/doc/articles/aliases.md](https://getcomposer.org/doc/articles/aliases.md)上了解更多信息。
- en: Finally, if you would like to add another dependency, or edit the `composer.json`
    file in any other way, you should run `composer update` in your command line,
    or wherever the `composer.json` file is, in order to update the dependencies.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您想添加另一个依赖项或以任何方式编辑`composer.json`文件，您应该在命令行中运行`composer update`，或者在`composer.json`文件所在的任何位置，以便更新依赖项。
- en: Autoloader with PSR-4
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PSR-4的自动加载器
- en: In the previous chapters, we also added an autoloader to our application. As
    we are now using someone else's code, we need to know how to load their classes
    too. Soon, developers realized that this scenario without a standard would be
    virtually impossible to manage, and they came out with some standards that most
    developers follow. You can find a lot of information on this topic at [http://www.php-fig.org](http://www.php-fig.org).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们也为我们应用程序添加了一个自动加载器。由于我们现在使用的是他人的代码，我们需要知道如何加载他们的类。很快，开发者意识到如果没有标准，这种场景几乎无法管理，因此他们提出了一些大多数开发者都遵循的标准。您可以在[http://www.php-fig.org](http://www.php-fig.org)找到关于这个主题的大量信息。
- en: 'Nowadays, PHP has two main standards for autoloading: **PSR-0** and **PSR-4**.
    They are very similar, but we will be implementing the latter, as it is the most
    recent standard published. This standard basically follows what we''ve already
    introduced when talking about namespaces: the namespace of a class must be the
    same as the directory where it is, and the name of the class should be the name
    of the file, followed by the extension `.php`. For example, the file in `src/Domain/Book.php`
    contains the class `Book` inside the namespace `Bookstore\Domain`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，PHP有两个主要的自动加载标准：**PSR-0**和**PSR-4**。它们非常相似，但我们将实现后者，因为它是最新的发布标准。这个标准基本上遵循我们在讨论命名空间时已经介绍的内容：类的命名空间必须与它所在的目录相同，类的名称应该是文件名，后跟扩展名`.php`。例如，`src/Domain/Book.php`文件包含在`Bookstore\Domain`命名空间内的`Book`类。
- en: 'Applications using Composer should follow one of those standards, and they
    should note in their respective `composer.json` file which one they are using.
    This means that Composer knows how to autoload its own application files, so we
    will not need to take care of it when we download external libraries. To specify
    that, we edit our `composer.json` file, and add the following content:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Composer的应用程序应遵循这些标准之一，并在它们各自的`composer.json`文件中注明它们使用的是哪一个。这意味着Composer知道如何自动加载它自己的应用程序文件，因此当我们下载外部库时，我们不需要关心它。为了指定这一点，我们编辑我们的`composer.json`文件，并添加以下内容：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code means that we will use PSR-4 in our application, and that
    all the namespaces that start with `Bookstore` should be found inside the `src/`
    directory. This is exactly what our autoloader was doing already, but reduced
    to a couple of lines in a configuration file. We can safely remove our autoloader
    and any reference to it now.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码表示我们将使用PSR-4在我们的应用程序中，并且所有以`Bookstore`开头的命名空间都应该在`src/`目录内找到。这正是我们的自动加载器已经做到的，但现在简化为配置文件中的几行。我们现在可以安全地删除我们的自动加载器及其任何引用。
- en: 'Composer generates some mappings that help to speed up the loading of classes.
    In order to update those maps with the new information added to the configuration
    file, we need to run the `composer update` command that we ran earlier. This time,
    the output will tell us that there is no package to update, but the autoload files
    will be generated again:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Composer 生成一些映射来帮助加快类的加载速度。为了将配置文件中添加的新信息更新到这些映射中，我们需要运行之前运行的 `composer update`
    命令。这次，输出将告诉我们没有需要更新的包，但将再次生成自动加载文件：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Adding metadata
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加元数据
- en: In order to know where to find the libraries that you define as dependencies,
    Composer keeps a repository of packages and versions, known as **Packagist**.
    This repository keeps a lot of useful information for developers, such as all
    the versions available for a given package, the authors, some description of what
    the package does (or a website pointing to that information), and the dependencies
    that this package will download. You can also browse the packages, searching by
    name or categories.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了知道你定义的依赖项库在哪里，Composer 维护着一个包和版本的仓库，称为 **Packagist**。这个仓库为开发者提供了大量有用的信息，例如给定包的所有版本、作者、一些关于包功能的描述（或指向该信息的网站），以及该包将下载的依赖项。你还可以通过名称或类别浏览包。
- en: 'But how does Packagist know about this? It is all thanks to the `composer.json`
    file itself. In there, you can define all the metadata of your application in
    a format that Composer understands. Let''s see an example. Add the following content
    to your `composer.json` file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Packagist 是如何知道这个文件的？这都要归功于 `composer.json` 文件本身。在那里，你可以以 Composer 理解的格式定义你应用程序的所有元数据。让我们看看一个例子。将以下内容添加到你的
    `composer.json` 文件中：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The configuration file now contains the name of the package following the Composer
    convention: vendor name, slash, and the package name—in this case, `picahielos/bookstore`.
    We also add a description, license, authors, and other metadata. If you have your
    code in a pubic repository such as GitHub, adding this `composer.json` file will
    allow you to go to Packagist and insert the URL of your repository. Packagist
    will add your code as a new package, extracting the info from your `composer.json`
    file. It will show the available versions based on your tags or branches. In order
    to learn more about it, we encourage you to visit the official documentation at
    [https://getcomposer.org/doc/04-schema.md](https://getcomposer.org/doc/04-schema.md).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件现在包含了遵循 Composer 约定的包名称：供应商名称，斜杠，包名称——在这个例子中，`picahielos/bookstore`。我们还添加了描述、许可证、作者和其他元数据。如果你在公共仓库（如
    GitHub）中有代码，添加这个 `composer.json` 文件将允许你访问 Packagist 并插入你仓库的 URL。Packagist 将你的代码作为一个新的包添加，从你的
    `composer.json` 文件中提取信息。它将根据你的标签或分支显示可用的版本。为了了解更多信息，我们鼓励你访问官方文档[https://getcomposer.org/doc/04-schema.md](https://getcomposer.org/doc/04-schema.md)。
- en: The index.php file
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: index.php 文件
- en: 'In MVC applications, we usually have one file that gets all the requests, and
    routes them to the specific controller depending on the URL. This logic can generally
    be found in the `index.php` file in our root directory. We already have one, but
    as we are adapting our features to the MVC pattern, we will not need the current
    `index.php` anymore. Hence, you can safely replace it with the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MVC 应用程序中，我们通常有一个文件来获取所有请求，并根据 URL 将它们路由到特定的控制器。这种逻辑通常可以在我们根目录中的 `index.php`
    文件中找到。我们已经有了一个，但随着我们适应 MVC 模式，我们不再需要当前的 `index.php`。因此，你可以安全地将其替换为以下内容：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The only thing that this file will do now is include the file that handles all
    the autoloading from the Composer code. Later, we will initialize everything here,
    such as database connections, configuration readers, and so on, but right now,
    let's leave it empty.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个文件唯一要做的就是包含处理所有自动加载的 Composer 代码的文件。稍后，我们将在这里初始化一切，例如数据库连接、配置读取器等等，但现在让我们先留空。
- en: Working with requests
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理请求
- en: As you might recall from previous chapters, the main purpose of a web application
    is to process HTTP requests coming from the client and return a response. If that
    is the main goal of your application, managing requests and responses should be
    an important part of your code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如同你可能在之前的章节中回忆的那样，Web 应用程序的主要目的是处理来自客户端的 HTTP 请求并返回响应。如果你的应用程序的主要目标是这个，那么管理请求和响应应该是你代码中的一个重要部分。
- en: PHP is a language that can be used for scripts, but its main usage is in web
    applications. Due to this, the language comes ready with a lot of helpers for
    managing requests and responses. Still, the native way is not ideal, and as good
    OOP developers, we should come up with a set of classes that help with that. The
    main elements for this small project—still inside your application—are the request
    and the router. Let's start!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: PHP是一种可以用于脚本的编程语言，但它的主要用途是Web应用程序。由于这个原因，语言自带了很多用于管理请求和响应的辅助工具。尽管如此，原生的方式并不理想，并且作为好的面向对象开发者，我们应该提出一套有助于此的类。这个小项目的主要元素——仍然在你的应用内部——是请求和路由器。让我们开始吧！
- en: The request object
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求对象
- en: As we start our mini framework, we need to change our directory structure a
    bit. We will create the `src/Core` directory for all the classes related to the
    framework. As the configuration reader from the previous chapters is also part
    of the framework (rather than functionality for the user), we should move the
    `Config.php` file to this directory too.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开始我们的迷你框架，我们需要稍微改变一下我们的目录结构。我们将为所有与框架相关的类创建一个`src/Core`目录。由于上一章中的配置读取器也是框架的一部分（而不是用户的功能），我们应该也将`Config.php`文件移动到这个目录。
- en: 'The first thing to consider is what a request looks like. If you remember [Chapter
    2](part0019_split_000.html#I3QM2-edcc22b134104d5db0bf3aa086c86851 "Chapter 2. Web
    Applications with PHP"), *Web Applications with PHP*, a request is basically a
    message that goes to a URL, and has a method—GET or POST for now. The URL is at
    the same time composed of two parts: the domain of the web application, that is,
    the name of your server, and the path of the request inside the server. For example,
    if you try to access `http://bookstore.com/my-books`, the first part, `http://bookstore.com`,
    would be the domain and `/my-books` would be the path. In fact, `http` would not
    be part of the domain, but we do not need that level of granularity for our application.
    You can get this information from the global array `$_SERVER` that PHP populates
    for each request.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要考虑的是请求看起来是什么样子。如果你还记得[第2章](part0019_split_000.html#I3QM2-edcc22b134104d5db0bf3aa086c86851
    "第2章。使用PHP的Web应用程序")，*使用PHP的Web应用程序*，一个请求基本上是一个发送到URL的消息，并且有一个方法——目前是GET或POST。URL同时由两部分组成：Web应用的域名，即你的服务器名称，以及服务器内请求的路径。例如，如果你尝试访问`http://bookstore.com/my-books`，第一部分`http://bookstore.com`将是域名，而`/my-books`将是路径。实际上，`http`不会是域名的一部分，但对我们应用来说，我们不需要那么细粒度的信息。你可以从PHP为每个请求填充的全局数组`$_SERVER`中获取这些信息。
- en: 'Our `Request` class should have a property for each of those three elements,
    followed by a set of getters and some other helpers that will be useful for the
    user. Also, we should initialize all the properties from `$_SERVER` in the constructor.
    Let''s see what it would look like:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Request`类应该为这三个元素中的每一个都有一个属性，然后是一系列获取器和一些对用户有用的其他辅助方法。此外，我们应该在构造函数中从`$_SERVER`初始化所有属性。让我们看看它会是怎样的：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can see in the preceding code that other than the getters for each property,
    we added the methods `getUrl`, `isPost`, and `isGet`. The user could find the
    same information using the already existing getters, but as they will be needed
    a lot, it is always good to make it easier for the user. Also note that the properties
    are coming from the values of the `$_SERVER` array: `HTTP_HOST`, `REQUEST_URI`,
    and `REQUEST_METHOD`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的代码中看到，除了每个属性的获取器之外，我们还添加了`getUrl`、`isPost`和`isGet`方法。用户可以使用现有的获取器找到相同的信息，但鉴于它们将非常需要，总是好的让它们更容易使用。另外请注意，属性来自`$_SERVER`数组的值：`HTTP_HOST`、`REQUEST_URI`和`REQUEST_METHOD`。
- en: Filtering parameters from requests
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从请求中过滤参数
- en: Another important part of a request is the information that comes from the user,
    that is, the GET and POST parameters, and the cookies. As with the `$_SERVER`
    global array, this information comes from `$_POST`, `$_GET`, and `$_COOKIE`, but
    it is always good to avoid using them directly, without filtering, as the user
    could send malicious code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的另一个重要部分是来自用户的信息，即GET和POST参数，以及cookies。与`$_SERVER`全局数组一样，这些信息来自`$_POST`、`$_GET`和`$_COOKIE`，但总是好的避免直接使用它们，没有过滤，因为用户可能会发送恶意代码。
- en: 'We will now implement a class that will represent a map—key-value pairs—that
    can be filtered. We will call it `FilteredMap`, and will include it in our namespace,
    `Bookstore\Core`. We will use it to contain the parameters GET and POST and the
    cookies as two new properties in our `Request` class. The map will contain only
    one property, the array of data, and will have some methods to fetch information
    from it. To construct the object, we need to send the array of data as an argument
    to the constructor:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现一个表示可以过滤的映射（键值对）的类。我们将称之为 `FilteredMap`，并将其包含在我们的命名空间 `Bookstore\Core`
    中。我们将使用它来包含 GET 和 POST 参数以及作为我们 `Request` 类中的两个新属性。这个映射将只包含一个属性，即数据数组，并且将有一些方法来从它中获取信息。为了构造对象，我们需要将数据数组作为参数发送给构造函数：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This class does not do much so far. We could have the same functionality with
    a normal array. The utility of this class comes when we add filters while fetching
    data. We will implement three filters, but you can add as many as you need:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类到目前为止并没有做什么。我们可以用普通的数组实现相同的功能。这个类的实用性在于我们在获取数据时添加过滤器。我们将实现三个过滤器，但你可以根据需要添加更多：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These three methods in the preceding code allow the user to get parameters of
    a specific type. Let's say that the developer needs to get the ID of the book
    from the request. The best option is to use the `getInt` method to make sure that
    the returned value is a valid integer, and not some malicious code that can mess
    up our database. Also note the function `getString`, where we use the `addSlashed`
    method. This method adds slashes to some of the suspicious characters, such as
    slashes or quotes, trying to prevent malicious code with it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的这三个方法允许用户获取特定类型的参数。假设开发者需要从请求中获取书籍的 ID。最佳选项是使用 `getInt` 方法来确保返回的值是一个有效的整数，而不是可能破坏我们数据库的恶意代码。还要注意
    `getString` 函数，我们使用了 `addSlashed` 方法。这个方法向一些可疑字符添加斜杠，例如斜杠或引号，试图用它来防止恶意代码。
- en: 'Now we are ready to get the GET and POST parameters as well as the cookies
    from our `Request` class using our `FilteredMap`. The new code would look like
    the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用我们的 `FilteredMap` 从我们的 `Request` 类中获取 GET 和 POST 参数以及 cookies。新的代码将如下所示：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With this new addition, a developer could get the POST parameter `price` with
    the following line of code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新功能，开发者可以通过以下代码行获取 POST 参数 `price`：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is way safer than the usual call to the global array:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这比通常调用全局数组要安全得多：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Mapping routes to controllers
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将路由映射到控制器
- en: If you can recall from any URL that you use daily, you will probably not see
    any PHP file as part of the path, like we have with `http://localhost:8000/init.php`.
    Websites try to format their URLs to make them easier to remember instead of depending
    on the file that should handle that request. Also, as we've already mentioned,
    all our requests go through the same file, `index.php`, regardless of their path.
    Because of this, we need to keep a map of the URL paths, and who should handle
    them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够回忆起你每天使用的任何 URL，你可能会看不到任何 PHP 文件作为路径的一部分，就像我们在 `http://localhost:8000/init.php`
    中看到的那样。网站试图格式化它们的 URL，使它们更容易记住，而不是依赖于应该处理该请求的文件。同样，正如我们已经提到的，所有我们的请求都通过同一个文件 `index.php`，无论它们的路径如何。正因为如此，我们需要保留一个
    URL 路径的映射，以及谁应该处理它们。
- en: Sometimes, we have URLs that contain parameters as part of their path, which
    is different from when they contain the GET or POST parameters. For example, to
    get the page that shows a specific book, we might include the ID of the book as
    part of the URL, such as `/book/12` or `/book/3`. The ID will change for each
    different book, but the same controller should handle all of these requests. To
    achieve this, we say that the URL contains an argument, and we could represent
    it by `/book/:id`, where `id` is the argument that identifies the ID of the book.
    Optionally, we could specify the kind of value this argument can take, for example,
    number, string, and so on.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们的 URL 会包含作为路径一部分的参数，这与它们包含 GET 或 POST 参数的情况不同。例如，要获取显示特定书籍的页面，我们可能会在 URL
    中包含书籍的 ID，例如 `/book/12` 或 `/book/3`。每个不同的书籍的 ID 都会改变，但同一个控制器应该处理所有这些请求。为了实现这一点，我们说
    URL 包含一个参数，我们可以用 `/book/:id` 来表示它，其中 `id` 是标识书籍 ID 的参数。可选地，我们可以指定这个参数可以接受的价值类型，例如数字、字符串等等。
- en: Controllers, the ones in charge of processing requests, are defined by a method's
    class. This method takes as arguments all the arguments that the URL's path defines,
    such as the ID of the book. We group controllers by their functionality, that
    is, a `BookController` class will contain the methods related to requests about
    books.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 负责处理请求的控制器由一个方法的类定义。该方法接受所有由 URL 的路径定义的参数，例如书的 ID。我们根据功能分组控制器，也就是说，一个 `BookController`
    类将包含与书籍请求相关的所有方法。
- en: 'Having defined all the elements of a route—a URL-controller relationship—we
    are ready to create our `routes.json` file, a configuration file that will keep
    this map. Each entry of this file should contain a route, the key being the URL,
    and the value, a map of information about the controller. Let''s see an example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了路由的所有元素——URL-控制器关系后，我们就可以创建我们的 `routes.json` 文件了，这是一个配置文件，将保存这个映射。该文件的每个条目应包含一个路由，键是
    URL，值是关于控制器的信息映射。让我们看看一个例子：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The route in the preceding example refers to all the URLs that follow the pattern
    `/books/:page`, with `page` being any number. Thus, this route will match URLs
    such as `/books/23` or `/books/2`, but it should not match `/books/one` or `/books`.
    The controller that will handle this request should be the `getAllWithPage` method
    from `BookController`; we will append `Controller` to all the class names. Given
    the parameters that we defined, the definition of the method should be something
    like the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，该路由指的是所有符合模式 `/books/:page` 的 URL，其中 `page` 可以是任何数字。因此，这个路由将匹配像 `/books/23`
    或 `/books/2` 这样的 URL，但不应该匹配 `/books/one` 或 `/books`。将处理此请求的控制器设置为 `BookController`
    中的 `getAllWithPage` 方法；我们将把 `Controller` 添加到所有类名中。根据我们定义的参数，方法的定义可能如下所示：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is one last thing we should consider when defining a route. For some
    endpoints, we should enforce the user to be authenticated, such as when the user
    is trying to access their own sales. We could define this rule in several ways,
    but we chose to do it as part of the route, adding the entry `"login": true` as
    part of the controller''s information. With that in mind, let''s add the rest
    of the routes that define all the views that we expect to have:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '在定义路由时，我们应考虑最后一件事。对于某些端点，我们应该强制用户进行身份验证，例如当用户试图访问他们自己的销售时。我们可以以多种方式定义此规则，但我们选择将其作为路由的一部分，在控制器的信息中添加
    `"login": true` 条目。考虑到这一点，让我们添加定义我们期望拥有的所有视图的其余路由：'
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'These routes define all the pages we need; we can get all the books in a paginated
    way or specific books by their ID, we can search books, list the sales of the
    user, show a specific sale by its ID, and list all the books that a certain user
    has borrowed. However, we are still lacking some of the endpoints that our application
    should be able to handle. For all those actions that are trying to modify data
    rather than requesting it, that is, borrowing a book or buying it, we need to
    add endpoints too. Add the following to your `routes.json` file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路由定义了我们需要的所有页面；我们可以以分页的方式获取所有书籍，或者通过它们的 ID 获取特定书籍，我们可以搜索书籍，列出用户的销售情况，显示特定
    ID 的销售，以及列出某个用户借阅的所有书籍。然而，我们仍然缺少一些应用程序应该能够处理的端点。对于所有试图修改数据而不是请求数据的操作，即借阅一本书或购买它，我们也需要添加端点。将以下内容添加到您的
    `routes.json` 文件中：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The router
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器
- en: 'The router will be by far the most complicated piece of code in our application.
    The main goal is to receive a `Request` object, decide which controller should
    handle it, invoke it with the necessary parameters, and return the response from
    that controller. The main goal of this section is to understand the importance
    of the router rather than its detailed implementation, but we will try to describe
    each of its parts. Copy the following content as your `src/Core/Router.php` file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器将是我们的应用程序中最复杂的代码部分。主要目标是接收一个 `Request` 对象，决定哪个控制器应该处理它，用必要的参数调用它，并返回该控制器的响应。本节的主要目标是理解路由的重要性，而不是其详细实现，但我们将尝试描述其各个部分。将以下内容复制到您的
    `src/Core/Router.php` 文件中：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The constructor of this class reads from the `routes.json` file, and stores
    the content as an array. Its main method, `route`, takes a `Request` object and
    returns a string, which is what we will send as output to the client. This method
    iterates all the routes from the array, trying to match each with the path of
    the given request. Once it finds one, it tries to execute the controller related
    to that route. If none of the routes are a good match to the request, the router
    will execute the `notFound` method of the `ErrorController`, which will then return
    an error page.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的构造函数从 `routes.json` 文件中读取，并将内容存储为数组。其主要方法 `route` 接收一个 `Request` 对象并返回一个字符串，这是我们发送给客户端的输出。该方法迭代数组中的所有路由，尝试将每个路由与给定请求的路径进行匹配。一旦找到匹配项，它将尝试执行与该路由相关的控制器。如果没有任何路由与请求匹配，则路由器将执行
    `ErrorController` 的 `notFound` 方法，然后返回一个错误页面。
- en: URLs matching with regular expressions
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与正则表达式匹配的URL
- en: 'While matching a URL with the route, we need to take care of the arguments
    for dynamic URLs, as they do not let us perform a simple string comparison. PHP—and
    other languages—has a very strong tool for performing string comparisons with
    dynamic content: regular expressions. Being an expert in regular expressions takes
    time, and it is outside the scope of this book, but we will give you a brief introduction
    to them.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在匹配路由中的URL时，我们需要注意动态URL的参数，因为它们不允许我们进行简单的字符串比较。PHP以及其他语言有一个非常强大的工具用于执行带有动态内容的字符串比较：正则表达式。成为正则表达式专家需要时间，而且这超出了本书的范围，但我们将为您简要介绍它们。
- en: 'A regular expression is a string that contains some wildcard characters that
    will match the dynamic content. Some of the most important ones are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一个包含一些通配符的字符串，这些通配符将匹配动态内容。其中一些最重要的如下：
- en: '`^`: This is used to specify that the matching part should be the start of
    the whole string'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^`: 这用于指定匹配的部分应该是整个字符串的开始'
- en: '`$`: This is used to specify that the matching part should be the end of the
    whole string'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`: 这用于指定匹配的部分应该是整个字符串的末尾'
- en: '`\d`: This is used to match a digit'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\d`: 这用于匹配一个数字'
- en: '`\w`: This is used to match a word'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\w`: 这用于匹配一个单词'
- en: '`+`: This is used for following a character or expression, to let that character
    or expression to appear at least once or many times'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`: 这用于跟随一个字符或表达式，让该字符或表达式至少出现一次或多次'
- en: '`*`: This is used for following a character or expression, to let that character
    or expression to appear zero or many times'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`: 这用于跟随一个字符或表达式，让该字符或表达式出现零次或多次'
- en: '`.`: This is used to match any single character'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.`: 这用于匹配任何单个字符'
- en: 'Let''s see some examples:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子：
- en: The pattern `.*` will match anything, even an empty string
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式 `.*` 将匹配任何内容，甚至是一个空字符串
- en: The pattern `.+` will match anything that contains at least one character
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式 `.+` 将匹配任何包含至少一个字符的内容
- en: The pattern `^\d+$` will match any number that has at least one digit
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式 `^\d+$` 将匹配任何至少包含一个数字的数字
- en: 'In PHP, we have different functions to work with regular expressions. The easiest
    of them, and the one that we will use, is `pregmatch`. This function takes a pattern
    as its first argument (delimited by two characters, usually `@` or `/`), the string
    that we are trying to match as the second argument, and optionally, an array where
    PHP stores the occurrences found. The function returns a Boolean value, being
    `true` if there was a match, `false` otherwise. We use it as follows in our `Route`
    class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，我们有不同的函数用于处理正则表达式。其中最简单的一个，也是我们将要使用的，是 `pregmatch`。该函数将其第一个参数（由两个字符分隔，通常是
    `@` 或 `/`）作为模式，我们将尝试匹配的字符串作为第二个参数，可选地，一个数组，其中PHP存储找到的匹配项。该函数返回一个布尔值，如果找到匹配项则为
    `true`，否则为 `false`。我们在 `Route` 类中如下使用它：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `$path` variable contains the path of the request, for example, `/books/2`.
    We match using a pattern that is delimited by `@`, has the `^` and `$` wildcards
    to force the pattern to match the whole string, and contains the concatenation
    of `/` and the variable `$regexRoute`. The content of this variable is given by
    the following method; add this as well to your `Router` class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`$path` 变量包含请求的路径，例如，`/books/2`。我们使用一个由 `@` 分隔的模式进行匹配，该模式包含 `^` 和 `$` 通配符，以强制模式匹配整个字符串，并包含
    `/` 和变量 `$regexRoute` 的连接。此变量的内容由以下方法提供；同时将其添加到您的 `Router` 类中：'
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding method iterates the parameters list coming from the information
    of the route. For each parameter, the function replaces the name of the parameter
    inside the route by the wildcard character corresponding to the type of parameter—check
    the static array, `$regexPatterns`. To illustrate the usage of this function,
    let''s see some examples:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法遍历来自路由信息的参数列表。对于每个参数，函数将路由中参数的名称替换为对应参数类型的通配符字符——检查静态数组`$regexPatterns`。为了说明这个函数的用法，让我们看一些例子：
- en: The route `/books` will be returned without a change, as it does not contain
    any argument
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由`/books`将保持不变，因为它不包含任何参数
- en: The route `books/:id/borrow` will be changed to `books/\d+/borrow`, as the URL
    argument, `id`, is a number
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由`books/:id/borrow`将更改为`books/\d+/borrow`，因为URL参数`id`是一个数字
- en: Extracting the arguments of the URL
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取URL的参数
- en: 'In order to execute the controller, we need three pieces of data: the name
    of the class to instantiate, the name of the method to execute, and the arguments
    that the method needs to receive. We already have the first two as part of the
    route `$info` array, so let''s focus our efforts on finding the third one. Add
    the following method to the `Router` class:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行控制器，我们需要三份数据：要实例化的类的名称、要执行的方法的名称以及方法需要接收的参数。我们已经有了前两个作为路由`$info`数组的一部分，所以让我们集中精力寻找第三个。向`Router`类添加以下方法：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This last method expects that both the path of the request and the URL of the
    route follow the same pattern. With the `explode` method, we get two arrays that
    should match each of their entries. We iterate them, and for each entry in the
    route array that looks like a parameter, we fetch its value in the URL. For example,
    if we had the route `/books/:id/borrow` and the path `/books/12/borrow`, the result
    of this method would be the array *['id' => 12]*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的方法期望请求的路径和路由的URL遵循相同的模式。使用`explode`方法，我们得到两个应该匹配它们各自条目的数组。我们遍历它们，并且对于路由数组中的每个看起来像参数的条目，我们在URL中获取它的值。例如，如果我们有路由`/books/:id/borrow`和路径`/books/12/borrow`，这个方法的结果将是数组*['id'
    => 12]*。
- en: Executing the controller
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行控制器
- en: We end this section by implementing the method that executes the controller
    in charge of a given route. We already have the name of the class, the method,
    and the arguments that the method needs, so we could make use of the `call_user_func_array`
    native function that, given an object, a method name, and the arguments for the
    method, invokes the method of the object passing the arguments. We have to make
    use of it as the number of arguments is not fixed, and we cannot perform a normal
    invocation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实现负责给定路由的控制器执行方法来结束本节。我们已经有类的名称、方法的名称以及方法需要的参数，因此我们可以使用`call_user_func_array`这个原生函数，它给定一个对象、一个方法名称和方法的参数，调用对象的方法。我们必须使用它，因为参数的数量是不固定的，我们不能执行正常的调用。
- en: 'But we are still missing a behavior introduced when creating our `routes.json`
    file. There are some routes that force the user to be logged in, which, in our
    case, means that the user has a cookie with the user ID. Given a route that enforces
    authorization, we will check whether our request contains the cookie, in which
    case we will set it to the controller class through `setCustomerId`. If the user
    does not have a cookie, instead of executing the controller for the current route,
    we will execute the `showLogin` method of the `CustomerController` class, which
    will render the template for the login form. Let''s see how everything would look
    on adding the last method of our `Router` class:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们在创建`routes.json`文件时遗漏了一个行为。有一些路由强制用户登录，在我们的情况下，这意味着用户有一个包含用户ID的cookie。给定一个强制授权的路由，我们将检查我们的请求是否包含cookie，如果是的话，我们将通过`setCustomerId`将其设置到控制器类中。如果用户没有cookie，我们将不会执行当前路由的控制器，而是执行`CustomerController`类的`showLogin`方法，这将渲染登录表单的模板。让我们看看在添加我们的`Router`类的最后一个方法后，一切将如何看起来：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have already warned you about the lack of security in our application, as
    this is just a project with didactic purposes. So, avoid copying the authorization
    system implemented here.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经警告过你我们应用程序的安全性不足，因为这个项目只是具有教学目的。所以，避免复制这里实现的授权系统。
- en: M for model
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: M代表模型
- en: Imagine for a moment that our bookstore website is quite successful, so we think
    of building a mobile app to increase our market. Of course, we would want to use
    the same database that we use for our website, as we need to sync the books that
    people borrow or buy from both apps. We do not want to be in a position where
    two people buy the same last copy of a book!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时想象一下，我们的书店网站非常成功，所以我们考虑建立一个移动应用来扩大我们的市场。当然，我们希望使用与我们的网站相同的数据库，因为我们需要同步两个应用中人们借阅或购买的书籍。我们不希望处于两个人购买同一本书最后一本的情况！
- en: Not only the database, but the queries used to get books, update them, and so
    on, have to be the same too, otherwise we would end up with unexpected behavior.
    Of course, one apparently easy option would be to replicate the queries in both
    codebases, but that has a huge maintainability problem. What if we change one
    single field of our database? We need to apply the same change to at least two
    different codebases. That does not seem to be useful at all.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅数据库，用于获取书籍、更新它们等的查询也必须相同，否则我们最终会遇到意外的行为。当然，一个显然简单的选择是在两个代码库中复制查询，但这有一个巨大的可维护性问题。如果我们更改数据库中的一个字段怎么办？我们需要至少在两个不同的代码库中应用相同的更改。这似乎根本没有什么用。
- en: Business logic plays an important role here too. Think of it as decisions you
    need to take that affect your business. In our case, that a premium customer is
    able to borrow 10 books and a normal one only 3, is business logic. This logic
    should be put in a common place too, because, if we want to change it, we will
    have the same problems as with our database queries.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 商业逻辑在这里也扮演着重要的角色。把它想象成你需要做出的决策，这些决策会影响你的业务。在我们的案例中，那就是高级客户可以借阅10本书，而普通客户只能借阅3本，这是商业逻辑。这种逻辑也应该放在一个公共的地方，因为如果我们想改变它，我们会遇到与我们的数据库查询相同的问题。
- en: We hope that by now we've convinced you that data and business logic should
    be separated from the rest of the code in order to make it reusable. Do not worry
    if it is hard for you to define what should go as part of the model or as part
    of the controller; a lot of people struggle with this distinction. As our application
    is very simple, and it does not have a lot of business logic, we will just focus
    on adding all the code related to MySQL queries.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望到现在我们已经说服你，数据和商业逻辑应该从其他代码中分离出来，以便使其可重用。如果你觉得难以定义什么应该作为模型的一部分或作为控制器的一部分，不要担心；很多人都在这个区别上挣扎。由于我们的应用程序非常简单，并且没有很多商业逻辑，我们只需关注添加所有与MySQL查询相关的代码。
- en: 'As you can imagine, for an application integrated with MySQL, or any other
    database system, the database connection is an important element of a model. We
    chose to use PDO in order to interact with MySQL, and as you might remember, instantiating
    that class was a bit of a pain. Let''s create a singleton class that returns an
    instance of `PDO` to make things easier. Add this code to `src/Core/Db.php`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，对于一个与MySQL或任何其他数据库系统集成的应用程序，数据库连接是模型的一个重要元素。我们选择使用PDO来与MySQL交互，你可能还记得，实例化这个类有点痛苦。让我们创建一个单例类，它返回一个`PDO`实例，使事情变得更容易。将此代码添加到`src/Core/Db.php`中：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Although it might not be true for all models, in our application, they will
    always have to access the database. We could create an abstract class where all
    models extend. This class could contain a `$db` protected property that will be
    set on the constructor. With this, we avoid duplicating the same constructor and
    property definition across all our models. Copy the following class into `src/Models/AbstractModel.php`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能对所有模型都不成立，但在我们的应用程序中，它们将始终需要访问数据库。我们可以创建一个抽象类，所有模型都从这个类扩展。这个类可以包含一个`$db`受保护的属性，它将在构造函数中设置。有了这个，我们就避免了在所有模型中重复相同的构造函数和属性定义。将以下类复制到`src/Models/AbstractModel.php`中：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, to finish the setup of the models, we could create a new exception
    (as we did with the `NotFoundException` class) that represents an error from the
    database. It will not contain any code, but we will be able to differentiate where
    an exception is coming from. We will save it in `src/Exceptions/DbException.php`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了完成模型的设置，我们可以创建一个新的异常（就像我们为`NotFoundException`类所做的那样），它代表数据库中的错误。它将不包含任何代码，但我们能够区分异常是从哪里来的。我们将它保存在`src/Exceptions/DbException.php`中：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that we''ve set the ground, we can start writing our models. It is up to
    you to organize your models, but it is a good idea to mimic the domain objects
    structure. In this case, we would have three models: `CustomerModel`, `BookModel`,
    and `SalesModel`. In the following sections, we will explain the contents of each
    of them.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经奠定了基础，我们可以开始编写我们的模型了。组织模型由你决定，但模仿领域对象结构是一个好主意。在这种情况下，我们将有三个模型：`CustomerModel`、`BookModel`
    和 `SalesModel`。在接下来的章节中，我们将解释每个模型的内容。
- en: The customer model
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户模型
- en: 'Let''s start with the easiest one. As our application is still very primitive,
    we will not allow the creation of new costumers, and work with the ones we inserted
    manually into the database instead. That means that the only thing we need to
    do with customers is to query them. Let''s create a `CustomerModel` class in `src/Models/CustomerModel.php`
    with the following content:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的一个开始。由于我们的应用程序仍然非常原始，我们不会允许创建新的客户，而是使用我们手动插入数据库的客户。这意味着我们只需要对客户进行查询。让我们在
    `src/Models/CustomerModel.php` 中创建一个 `CustomerModel` 类，其内容如下：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `CustomerModel` class, which extends from the `AbstractModel` class, contains
    two methods; both of them return a `Customer` instance, one of them when providing
    the ID of the customer, and the other one when providing the e-mail. As we already
    have the database connection as the `$db` property, we just need to prepare the
    statement with the given query, execute the statement with the arguments, and
    fetch the result. As we expect to get a customer, if the user provided an ID or
    an e-mail that does not belong to any customer, we will need to throw an exception—in
    this case, a `NotFoundException` is just fine. If we find a customer, we use our
    factory to create the object and return it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerModel` 类继承自 `AbstractModel` 类，包含两个方法；这两个方法都返回一个 `Customer` 实例，一个在提供客户
    ID 时调用，另一个在提供电子邮件时调用。因为我们已经通过 `$db` 属性拥有了数据库连接，所以我们只需要准备一个给定的查询语句，用参数执行该语句，并获取结果。如果我们期望获取一个客户，如果用户提供的
    ID 或电子邮件不属于任何客户，我们需要抛出一个异常——在这种情况下，`NotFoundException` 就足够了。如果我们找到了一个客户，我们使用我们的工厂创建对象并返回它。'
- en: The book model
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 书籍模型
- en: 'Our `BookModel` class gives us a bit more of work. Customers had a factory,
    but it is not worth having one for books. What we use for creating them from MySQL
    rows is not the constructor, but a fetch mode that PDO has, and that allows us
    to map a row into an object. To do so, we need to adapt the `Book` domain object
    a bit:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `BookModel` 类给我们带来了一些额外的工作。客户有一个工厂，但对于书籍来说，拥有一个工厂并不值得。我们用于从 MySQL 行创建它们的不是构造函数，而是
    PDO 具有的一种获取模式，它允许我们将一行映射到对象。为了做到这一点，我们需要对 `Book` 领域对象进行一些调整：
- en: The names of the properties have to be the same as the names of the fields in
    the database
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性的名称必须与数据库中的字段名称相同
- en: There is no need for a constructor or setters, unless we need them for other
    purposes
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有必要提供构造函数或设置器，除非我们需要它们用于其他目的
- en: To go with encapsulation, properties should be private, so we will need getters
    for all of them
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了与封装性相匹配，属性应该是私有的，因此我们需要为它们提供获取器
- en: 'The new `Book` class should look like the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `Book` 类应该如下所示：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We retained the `getCopy` and `addCopy` methods even though they are not getters,
    as we will need them later. Now, when fetching a group of rows from MySQL with
    the `fetchAll` method, we can send two parameters: the constant `PDO::FETCH_CLASS`
    that tells PDO to map rows to a class, and the name of the class that we want
    to map to. Let''s create the `BookModel` class with a simple `get` method that
    fetches a book from the database with a given ID. This method will return either
    a `Book` object or throw an exception in case the ID does not exist. Save it as
    `src/Models/BookModel.php`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留了 `getCopy` 和 `addCopy` 方法，即使它们不是获取器，因为我们在以后还需要它们。现在，当我们使用 `fetchAll` 方法从
    MySQL 获取一组行时，我们可以发送两个参数：常量 `PDO::FETCH_CLASS`，它告诉 PDO 将行映射到类，以及我们想要映射到的类的名称。让我们创建一个
    `BookModel` 类，它有一个简单的 `get` 方法，该方法使用给定的 ID 从数据库中获取一本书。此方法将返回一个 `Book` 对象，或者在 ID
    不存在的情况下抛出一个异常。将其保存为 `src/Models/BookModel.php`：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There are advantages and disadvantages of using this fetch mode. On one hand,
    we avoid a lot of dull code when creating objects from rows. Usually, we either
    just send all the elements of the row array to the constructor of the class, or
    use setters for all its properties. If we add more fields to the MySQL table,
    we just need to add the properties to our domain class, instead of changing everywhere
    where we were instantiating the objects. On the other hand, you are forced to
    use the same names for the fields in both the table's as well as the class' properties,
    which means high coupling (always a bad idea). This also causes some conflicts
    when following conventions, because in MySQL, it is common to use `book_id`, but
    in PHP, the property is `$bookId`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种获取模式有优点和缺点。一方面，在从行创建对象时，我们避免了大量的枯燥代码。通常，我们要么将行数组的所有元素发送到类的构造函数，要么使用所有属性的setter。如果我们向MySQL表添加更多字段，我们只需将属性添加到我们的领域类中，而无需更改我们实例化对象的所有地方。另一方面，你被迫在表和类的属性中使用相同的字段名，这意味着高度耦合（这始终是一个坏主意）。这也导致了一些遵循约定时的冲突，因为在MySQL中，通常使用`book_id`，但在PHP中，属性是`$bookId`。
- en: 'Now that we know how this fetch mode works, let''s add three other methods
    that fetch data from MySQL. Add the following code to your model:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了这种获取模式是如何工作的，让我们添加三个其他方法，这些方法从MySQL获取数据。将以下代码添加到您的模型中：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The methods added are as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的方法如下：
- en: '`getAll` returns an array of all the books for a given page. Remember that
    `LIMIT` allows you to return a specific number of rows with an offset, which can
    work as a paginator.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAll`返回给定页面的所有书籍数组。记住，`LIMIT`允许你通过偏移量返回特定数量的行，这可以作为分页器使用。'
- en: '`getByUser` returns all the books that a given customer has borrowed—we will
    need to use a join query for this. Note that we return `b.*`, that is, only the
    fields of the `book` table, skipping the rest of the fields.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getByUser`返回给定客户借阅的所有书籍——我们需要为此使用连接查询。注意，我们返回`b.*`，即只返回`book`表的字段，跳过其他字段。'
- en: Finally, there is a method to search by either title or author, or both. We
    can do that using the operator `LIKE` and enclosing the patterns with `%`. If
    we do not specify one of the parameters, we will try to match the field with `%%`,
    which matches everything.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，有一个方法可以通过标题或作者进行搜索，或者两者都搜索。我们可以使用`LIKE`运算符和用`%`包围的模式来实现这一点。如果我们没有指定其中一个参数，我们将尝试用`%%`匹配字段，它匹配一切。
- en: 'So far, we have been adding methods to fetch data. Let''s add methods that
    will allow us to modify the data in our database. For the book model, we will
    need to be able to borrow books and return them. Here is the code for those two
    actions:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在添加获取数据的方法。现在让我们添加允许我们修改数据库中数据的方法。对于书籍模型，我们需要能够借阅书籍并归还它们。以下是这两个操作的代码：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The sales model
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 销售模型
- en: 'Now we need to add the last model to our application: the `SalesModel`. Using
    the same fetch mode that we used with books, we need to adapt the domain class
    as well. We need to think a bit more in this case, as we will be doing more than
    just fetching. Our application has to be able to create new sales on demand, containing
    the ID of the customer and the books. We can already add books with the current
    implementation, but we need to add a setter for the customer ID. The ID of the
    sale will be given by the autoincrement ID in MySQL, so there is no need to add
    a setter for it. The final implementation would look as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要向我们的应用程序添加最后一个模型：`SalesModel`。使用与书籍相同的获取模式，我们还需要调整领域类。在这种情况下，我们需要思考更多，因为我们不仅要获取数据。我们的应用程序必须能够根据需求创建新的销售，包含客户和书籍的ID。我们当前的实施方案已经可以添加书籍，但我们需要添加一个客户ID的setter。销售的ID将由MySQL中的自增ID提供，因此不需要为它添加setter。最终的实现将如下所示：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `SalesModel` will be the most difficult one to write. The problem with
    this model is that it includes manipulating different tables: `sale` and `sale_book`.
    For example, when getting the information of a sale, we need to get the information
    from the `sale` table, and then the information of all the books in the `sale_book`
    table. You could argue about whether to have one unique method that fetches all
    the necessary information related to a sale, or to have two different methods,
    one to fetch the sale and the other to fetch the books, and let the controller
    to decide which one to use.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`SalesModel`将是编写起来最困难的一个。这个模型的问题在于它包括操作不同的表：`sale`和`sale_book`。例如，当获取销售信息时，我们需要从`sale`表获取信息，然后从`sale_book`表获取所有书籍的信息。你可以争论是否应该有一个唯一的方法来获取与销售相关的所有必要信息，或者有两个不同的方法，一个用于获取销售信息，另一个用于获取书籍信息，让控制器决定使用哪一个。'
- en: This actually starts a very interesting discussion. On one hand, we want to
    make things easier for the controller—having one unique method to fetch the entire
    `Sale` object. This makes sense as the controller does not need to know about
    the internal implementation of the `Sale` object, which lowers coupling. On the
    other hand, forcing the model to always fetch the whole object, even if we only
    need the information in the `sale` table, is a bad idea. Imagine if the sale contains
    a lot of books; fetching them from MySQL will decrease performance unnecessarily.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上引发了一场非常有趣的讨论。一方面，我们希望让控制器更容易操作——有一个唯一的方法来获取整个`Sale`对象。这是有意义的，因为控制器不需要了解`Sale`对象的内部实现，这降低了耦合。另一方面，强迫模型总是获取整个对象，即使我们只需要`sale`表中的信息，也是一个坏主意。想象一下，如果销售包含大量的书籍，从MySQL中获取它们将无必要地降低性能。
- en: You should think how your controllers need to manage sales. If you will always
    need the entire object, you can have one method without being concerned about
    performance. If you only need to fetch the entire object sometimes, maybe you
    could add both methods. For our application, we will have one method to rule them
    all, since that is what we will always need.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该思考你的控制器如何管理销售。如果你总是需要整个对象，你可以有一个方法而不必担心性能。如果你有时需要获取整个对象，也许你可以添加两个方法。对于我们的应用程序，我们将有一个方法来处理所有这些，因为我们总是需要它。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Lazy loading**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**延迟加载**'
- en: As with any other design challenge, other developers have already given a lot
    of thought to this problem. They came up with a design pattern named **lazy load**.
    This pattern basically lets the controller think that there is only one method
    to fetch the whole domain object, but we will actually be fetching only what we
    need from database.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他设计挑战一样，其他开发者已经对这个问题进行了很多思考。他们提出了一种名为**延迟加载**的设计模式。这个模式基本上让控制器认为只有一个方法可以获取整个域对象，但实际上我们只会从数据库中获取所需的数据。
- en: 'The model fetches the most used information for the object and leaves the rest
    of the properties that need extra database queries empty. Once the controller
    uses a getter of a property that is empty, the model automatically fetches that
    data from the database. We get the best of both worlds: there is simplicity for
    the controller, but we do not spend more time than necessary querying unused data.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 模型获取对象最常用的信息，并将需要额外数据库查询的其他属性留空。一旦控制器使用一个空属性的getter，模型会自动从数据库中获取那些数据。我们得到了两全其美的效果：控制器有简单的操作，但我们不会在查询未使用的数据上浪费更多时间。
- en: 'Add the following as your `src/Models/SaleModel.php` file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到你的`src/Models/SaleModel.php`文件中：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Another tricky method in this model is the one that takes care of creating a
    sale in the database. This method has to create a sale in the `sale` table, and
    then add all the books for that sale to the `sale_book` table. What would happen
    if we have a problem when adding one of the books? We would leave a corrupted
    sale in the database. To avoid that, we need to use transactions, starting with
    one at the beginning of the model's or the controller's method, and either rolling
    back in case of error, or committing it at the end of the method.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型中，另一个棘手的方法是处理在数据库中创建销售的方法。这个方法必须在`sale`表中创建一个销售记录，然后将该销售的所有书籍添加到`sale_book`表中。如果我们添加书籍时出现问题，会发生什么？我们会在数据库中留下一个损坏的销售记录。为了避免这种情况，我们需要使用事务，从模型或控制器方法的开始处开始，在出现错误时回滚，或者在方法结束时提交。
- en: 'In the same method, we also need to take care of the ID of the sale. We do
    not set the ID of the sale when creating the `sale` object, because we rely on
    the autoincremental field in the database. But when inserting the books into `sale_book`,
    we do need the ID of the sale. For that, we need to request the PDO for the last
    inserted ID with the `lastInsertId` method. Let''s add then the `create` method
    into your `SaleModel`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的方法中，我们还需要注意销售项的ID。在创建`sale`对象时，我们没有设置销售项的ID，因为我们依赖于数据库中的自增字段。但是，当将书籍插入到`sale_book`中时，我们需要销售项的ID。为此，我们需要使用`lastInsertId`方法请求PDO的最后一个插入ID。让我们将`create`方法添加到您的`SaleModel`中：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: One last thing to note from this method is that we prepare a statement, bind
    a value to it (the sale ID), and then bind and execute the same statement as many
    times as the books in the array. Once you have a statement, you can bind the values
    as many times as you want. Also, you can execute the same statement as many times
    as you want, and the values stay the same.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个方法中需要注意的最后一点是，我们准备一个语句，将其绑定到一个值（销售ID），然后绑定并执行与数组中书籍数量相同的相同语句。一旦你有一个语句，你可以绑定你想要的任何次数的值。同样，你可以执行你想要的任何次数的相同语句，而值保持不变。
- en: V for view
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: V代表视图
- en: The view is the layer that takes care of the… view. In this layer, you find
    all the templates that render the HTML that the user gets. Although the separation
    between views and the rest of the application is easy to see, that does not make
    views an easy part. In fact, you will have to learn a new technology in order
    to write views properly. Let's get into the details.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 视图层负责处理视图。在这个层中，你可以找到所有渲染用户获取的HTML的模板。尽管视图与应用程序其他部分的分离很容易看出，但这并不意味着视图是一个容易的部分。实际上，你将不得不学习一项新技术才能正确编写视图。让我们深入了解细节。
- en: Introduction to Twig
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Twig简介
- en: In our first attempt at writing views, we mixed up PHP and HTML code. We already
    know that the logic should not be mixed in the same place as HTML, but that is
    not the end of the story. When rendering HTML, we need some logic there too. For
    example, if we want to print a list of books, we need to repeat a certain block
    of HTML for each book. And since a priori we do not know the number of books to
    print, the best option would be a `foreach` loop.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一次尝试编写视图时，我们将PHP和HTML代码混合在一起。我们已经知道逻辑不应该与HTML混合在同一地方，但这并不是故事的结尾。在渲染HTML时，我们同样需要一些逻辑。例如，如果我们想打印一本书的列表，我们需要为每本书重复一定的HTML块。由于我们事先不知道要打印多少本书，最佳选择是使用`foreach`循环。
- en: One option that a lot of people take is minimizing the amount of logic that
    you can include in a view. You could set some rules, such as *we should only include
    conditionals and loops*, which is a reasonable amount of logic needed to render
    basic views. The problem is that there is not a way of enforcing this kind of
    rule, and other developers can easily start adding heavy logic in there. While
    some people are OK with that, assuming that no one will do it, others prefer to
    implement more restrictive systems. That was the beginning of template engines.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人选择的一个选项是尽量减少在视图中包含的逻辑量。你可以设定一些规则，例如*我们只应包含条件和循环*，这是渲染基本视图所需的合理逻辑量。问题是无法强制执行这类规则，其他开发者可以轻易地开始在其中添加复杂的逻辑。虽然有些人对此表示可以接受，假设没有人会这样做，但其他人更喜欢实施更严格的系统。这就是模板引擎的起源。
- en: You could think of a template engine as another language that you need to learn.
    Why would you do that? Because this new "language" is more limited than PHP. These
    languages usually allow you to perform conditionals and simple loops, and that
    is it. The developer is not able to add PHP to that file, since the template engine
    will not treat it as PHP code. Instead, it will just print the code to the output—the
    response' body—as if it was plain text. Also, as it is specially oriented to write
    templates, the syntax is usually easier to read when mixed with HTML. Almost everything
    is an advantage.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将模板引擎视为另一种需要学习的新语言。你为什么要这样做呢？因为这种新的“语言”比PHP更有限。这些语言通常允许你执行条件和简单的循环，仅此而已。开发者无法将PHP添加到该文件中，因为模板引擎不会将其视为PHP代码。相反，它只会将代码打印到输出——响应体——就像它是纯文本一样。此外，由于它专门面向编写模板，当与HTML混合时，语法通常更容易阅读。几乎一切都是优点。
- en: 'The inconvenience of using a template engine is that it takes some time to
    translate the new language to PHP, and then to HTML. This can be quite time consuming,
    so it is very important that you choose a good template engine. Most of them also
    allow you to cache templates, improving the performance. Our choice is a quite
    light and widely used one: **Twig**. As we''ve already added the dependency in
    our Composer file, we can use it straight away.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板引擎的不便之处在于，它需要一些时间将新语言翻译成PHP，然后再翻译成HTML。这可能会非常耗时，因此选择一个好的模板引擎非常重要。大多数模板引擎还允许你缓存模板，从而提高性能。我们的选择是一个相当轻量级且广泛使用的：**Twig**。因为我们已经在Composer文件中添加了依赖项，所以我们可以直接使用它。
- en: 'Setting up Twig is quite easy. On the PHP side, you just need to specify the
    location of the templates. A common convention is to use the `views` directory
    for that. Create the directory, and add the following two lines into your `index.php`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Twig相当简单。在PHP方面，你只需要指定模板的位置。一个常见的约定是使用`views`目录。创建该目录，并在你的`index.php`中添加以下两行：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The book view
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 书籍视图
- en: 'In these sections, as we work with templates, it would be nice to see the result
    of your work. We have not yet implemented any controllers, so we will force our
    `index.php` to render a specific template, regardless of the request. We can start
    rendering the view of a single book. For that, let''s add the following code at
    the end of your `index.php`, after creating your `twig` object:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些部分，当我们处理模板时，看到你工作的结果会很好。我们还没有实现任何控制器，所以我们将强制`index.php`渲染一个特定的模板，无论请求如何。我们可以开始渲染单个书籍的视图。为此，让我们在创建你的`twig`对象之后，在`index.php`的末尾添加以下代码：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding code, we request the book with ID 1 to the `BookModel`, get
    the `book` object, and create an array where the `book` key has the value of the
    `book` object. After that, we tell Twig to load the template `book.twig` and to
    render it by sending the array. This takes the template and injects the `$book`
    object, so that you are able to use it inside the template.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们向`BookModel`请求ID为1的书籍，获取`book`对象，并创建一个数组，其中`book`键的值为`book`对象。之后，我们告诉Twig加载模板`book.twig`，并通过发送数组来渲染它。这会将模板和`$book`对象注入其中，这样你就可以在模板内部使用它了。
- en: 'Let''s now create our first template. Write the following code into `view/book.twig`.
    By convention, all Twig templates should have the `.twig` extension:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来创建我们的第一个模板。将以下代码写入`view/book.twig`。按照惯例，所有Twig模板都应该有`.twig`扩展名：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Since this is your first Twig template, let''s go step by step. You can see
    that most of the content is HTML: some headers, a couple of paragraphs, and two
    forms with two buttons. You can recognize the Twig part, since it is enclosed
    by `{{ }}`. In Twig, everything that is between those curly brackets will be printed
    out. The first one that we find contains `book.title`. Do you remember that we
    injected the `book` object when rendering the template? We can access it here,
    just not with the usual PHP syntax. To access an object''s property, use `.` instead
    of `->`. So, this `book.title` will return the value of the `title` property of
    the `book` object, and the `{{ }}` will make Twig print it out. The same applies
    to the rest of the template.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是你的第一个Twig模板，让我们一步一步来。你可以看到大部分内容是HTML：一些标题，几个段落，以及两个带有两个按钮的表单。你可以识别出Twig部分，因为它被`{{
    }}`包围。在Twig中，所有那些在花括号之间的内容都将被打印出来。我们找到的第一个包含`book.title`。你还记得我们在渲染模板时注入了`book`对象吗？我们在这里可以访问它，只是不是用常规的PHP语法。要访问一个对象的属性，使用`.`而不是`->`。所以，这个`book.title`将返回`book`对象的`title`属性的值，而`{{
    }}`将使Twig打印它出来。模板的其余部分也是如此。
- en: There is one that does a bit more than just access an object's property. The
    `book.price|number_format(2)` gets the price of the book and sends it as an argument
    (using the pipe symbol) to the function `number_format`, which has already got
    `2` as another argument. This bit of code basically formats the price to two digital
    figures. In Twig, you also have some functions, but they are mostly reduced to
    formatting the output, which is an acceptable amount of logic.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个功能不仅限于访问对象的属性。`book.price|number_format(2)`获取书籍的价格，并将其作为参数（使用管道符号）发送到已经获得`2`作为另一个参数的`number_format`函数。这段代码基本上将价格格式化为两位数字。在Twig中，你也有一些函数，但它们主要被简化为格式化输出，这是可接受的逻辑量。
- en: 'Are you convinced now about how clean it is to use a template engine for your
    views? You can try it in your browser: accessing any path, your web server should
    execute the `index.php` file, forcing the template `book.twig` to be rendered.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在相信使用模板引擎为你的视图提供多么清晰的解决方案了吗？你可以在浏览器中尝试它：访问任何路径，你的Web服务器应该执行`index.php`文件，强制渲染模板`book.twig`。
- en: Layouts and blocks
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局和区块
- en: When you design your web application, usually you would want to share a common
    layout across most of your views. In our case, we want to always have a menu at
    the top of the view that allows us to go to the different sections of the website,
    or even to search books from wherever the user is. As with models, we want to
    avoid code duplication, since if we were to copy and paste the layout everywhere,
    updating it would be a nightmare. Instead, Twig comes with the ability to define
    layouts.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设计你的Web应用程序时，通常你会在大多数视图中共享一个共同的布局。在我们的例子中，我们希望视图的顶部始终有一个菜单，允许我们访问网站的各个部分，甚至可以从用户所在的位置搜索书籍。与模型一样，我们想要避免代码重复，因为如果我们把布局复制粘贴到每个地方，更新它将是一场噩梦。相反，Twig提供了定义布局的能力。
- en: 'A **layout** in Twig is just another template file. Its content is just the
    common HTML code that we want to display across all views (in our case, the menu
    and search bar), and contains some tagged gaps (blocks in Twig''s world), where
    you will be able to inject the specific HTML of each view. You can define one
    of those blocks with the tag `{% block %}`. Let''s see what our `views/layout.twig`
    file would look like:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在Twig中，**布局**只是一个模板文件。其内容是我们想要在所有视图中显示的公共HTML代码（在我们的案例中，是菜单和搜索栏），并包含一些带标签的空隙（Twig世界中的区块），你将能够注入每个视图的特定HTML。你可以使用`{%
    block %}`标签定义其中一个区块。让我们看看我们的`views/layout.twig`文件会是什么样子：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see in the preceding code, blocks have a name so that templates
    using the layout can refer to them. In our layout, we defined two blocks: one
    for the title of the view and the other for the content itself. When a template
    uses the layout, we just need to write the HTML code for each of the blocks defined
    in the layout, and Twig will do the rest. Also, to let Twig know that our template
    wants to use the layout, we use the tag `{% extends %}` with the layout filename.
    Let''s update `views/book.twig` to use our new layout:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，区块有一个名称，这样使用布局的模板就可以引用它们。在我们的布局中，我们定义了两个区块：一个用于视图的标题，另一个用于内容本身。当模板使用布局时，我们只需要为布局中定义的每个区块编写HTML代码，Twig就会完成剩余的工作。此外，为了让Twig知道我们的模板想要使用布局，我们使用带有布局文件名的`{%
    extends %}`标签。让我们更新`views/book.twig`以使用我们新的布局：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: At the top of the file, we add the layout that we need to use. Then, we open
    a block tag with the reference name, and we write inside it the HTML that we want
    to use. You can use anything valid inside a block, either Twig code or plain HTML.
    In our template, we used the title of the book as the `title` block, which refers
    to the title of the view, and we put all the previous HTML inside the `content`
    block. Note that everything in the file is inside a block now. Try it in your
    browser now to see the changes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部，我们添加我们需要使用的布局。然后，我们用一个带有参考名称的区块标签打开，并在其中写入我们想要使用的HTML。你可以在区块中使用任何有效的HTML，无论是Twig代码还是纯HTML。在我们的模板中，我们使用书的标题作为`title`区块，它引用了视图的标题，并将所有之前的HTML放入`content`区块。请注意，现在文件中的所有内容都在一个区块内。现在在你的浏览器中尝试一下，看看变化。
- en: Paginated book list
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分页书籍列表
- en: 'Let''s add another view, this time for a paginated list of books. In order
    to see the result of your work, update the content of `index.php`, replacing the
    code of the previous section with the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加另一个视图，这次是为书籍分页列表。为了看到你工作的结果，更新`index.php`的内容，用以下代码替换上一节的代码：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can also use conditionals in a Twig template, which work the same as the
    conditionals in PHP. The syntax is `{% if <boolean expression> %}`. Let''s use
    it to decide if we should show the previous and/or following links on our page.
    Add the following code at the end of the content block:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在Twig模板中使用条件语句，它们的工作方式与PHP中的条件语句相同。语法是`{% if <boolean expression> %}`。让我们使用它来决定是否在我们的页面上显示上一页和/或下一页链接。在内容区块的末尾添加以下代码：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The last thing to note from this template is that we are not restricted to using
    only variables when printing out content with `{{ }}`. We can add any valid Twig
    expression that returns a value, as we did with `{{ currentPage + 1 }}`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个模板中需要注意的最后一件事是，我们在使用`{{ }}`打印内容时，不仅限于使用变量。我们可以添加任何有效的Twig表达式，它返回一个值，就像我们使用`{{
    currentPage + 1 }}`一样。
- en: The sales view
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 销售视图
- en: 'We have already shown you everything that you will need for using templates,
    and now we just have to finish adding all of them. The next one in the list is
    the template that shows the list of sales for a given user. Update your `index.php`
    file with the following hack:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向你展示了使用模板所需的一切，现在我们只需完成添加所有模板。列表中的下一个模板是显示特定用户销售列表的模板。使用以下技巧更新你的 `index.php`
    文件：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The template for this view will be very similar to the one listing the books:
    a table populated with the content of an array. The following is the content of
    `views/sales.twig`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图的模板将与列出书籍的模板非常相似：一个填充了数组内容的表格。以下是 `views/sales.twig` 的内容：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The other view related to sales is where we want to display all the content
    of a specific one. This sale, again, will be similar to the books list, as we
    will be listing the books related to that sale. The hack to force the rendering
    of this template is as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 与销售相关的另一种观点是我们希望展示特定内容的全部。这次销售，同样，将与书籍列表相似，因为我们将会列出与这次销售相关的书籍。强制渲染此模板的技巧如下：
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And the Twig template should be placed in `views/sale.twig`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，Twig 模板应该放置在 `views/sale.twig`：
- en: '[PRE50]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The error template
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误模板
- en: 'We should add a very simple template that will be shown to the user when there
    is an error in our application, rather than showing a PHP error message. This
    template will just expect the `errorMessage` variable, and it could look like
    the following. Save it as `views/error.twig`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该添加一个非常简单的模板，当我们的应用中出现错误时，将显示给用户，而不是显示 PHP 错误消息。这个模板只期望 `errorMessage` 变量，它可能看起来像以下这样。将其保存为
    `views/error.twig`：
- en: '[PRE51]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that even the error page extends from the layout, as we want the user to
    be able to do something else when this happens.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使是错误页面也扩展自布局，因为我们希望用户在发生这种情况时能够做些其他事情。
- en: The login template
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录模板
- en: 'Our last template will be the one that allows the user to log in. This template
    is a bit different from the others, as it will be used in two different scenarios.
    In the first one, the user accesses the login view for the first time, so we need
    to show the form. In the second one, the user has already tried to log in, and
    there was an error when doing so, that is, the e-mail address was not found. In
    this case, we will add an extra variable to the template, `errorMessage`, and
    we will add a conditional to show its contents only when this variable is defined.
    You can use the operator `is defined` to check that. Add the following template
    as `views/login.twig`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的模板将允许用户登录。这个模板与其他模板略有不同，因为它将在两种不同的场景中使用。在第一种情况下，用户首次访问登录视图，因此我们需要显示表单。在第二种情况下，用户已经尝试登录，但在登录过程中出现了错误，即找不到电子邮件地址。在这种情况下，我们将向模板添加一个额外的变量
    `errorMessage`，并且我们将添加一个条件来显示其内容，仅当这个变量被定义时。你可以使用 `is defined` 操作符来检查。将以下模板作为
    `views/login.twig` 添加：
- en: '[PRE52]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: C for controller
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C 代表控制器
- en: 'It is finally time for the director of the orchestra. Controllers represent
    the layer in our application that, given a request, talks to the models and builds
    the views. They act like the manager of a team: they decide what resources to
    use depending on the situation.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，轮到乐团指挥了。控制器代表我们的应用中这样一个层次：给定一个请求，与模型通信并构建视图。它们就像一个团队的经理：根据情况决定使用哪些资源。
- en: 'As we stated when explaining models, it is sometimes difficult to decide if
    some piece of logic should go into the controller or the model. At the end of
    the day, MVC is a pattern, like a recipe that guides you, rather than an exact
    algorithm that you need to follow step by step. There will be scenarios where
    the answer is not straightforward, so it will be up to you; in these cases, just
    try to be consistent. The following are some common scenarios that might be difficult
    to localize:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在解释模型时所说的，有时很难决定某些逻辑是否应该放入控制器或模型中。最终，MVC 只是一个模式，就像一个指导你的食谱，而不是一个需要你一步一步遵循的精确算法。有些情况下答案并不直接，所以这取决于你；在这些情况下，只需尽量保持一致性。以下是一些可能难以本地化的常见场景：
- en: The request points to a path that we do not support. This scenario is already
    covered in our application, and it is the router that should take care of it,
    not the controller.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求指向我们不支持的路径。这种情况在我们的应用中已经得到处理，并且应该由路由器来处理，而不是控制器。
- en: The request tries to access an element that does not exist, for example, a book
    ID that is not in the database. In this case, the controller should ask the model
    if the book exists, and depending on the response, render a template with the
    book's contents, or another with a "Not found" message.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求尝试访问一个不存在的元素，例如，数据库中不存在的书籍ID。在这种情况下，控制器应该询问模型书籍是否存在，并根据响应渲染包含书籍内容的模板，或者渲染另一个包含“未找到”信息的模板。
- en: The user tries to perform an action, such as buying a book, but the parameters
    coming from the request are not valid. This is a tricky one. One option is to
    get all the parameters from the request without checking them, sending them straight
    to the model, and leaving the task of sanitizing the information to the model.
    Another option is that the controller checks that the parameters provided make
    sense, and then gives them to the model. There are other solutions, like building
    a class that checks if the parameters are valid, which can be reused in different
    controllers. In this case, it will depend on the amount of parameters and logic
    involved in the sanitization. For requests receiving a lot of data, the third
    option looks like the best of them, as we will be able to reuse the code in different
    endpoints, and we are not writing controllers that are too long. But in requests
    where the user sends one or two parameters, sanitizing them in the controller
    might be good enough.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户尝试执行一个动作，例如购买一本书，但请求中来的参数无效。这是一个棘手的问题。一个选项是获取请求中的所有参数而不进行检查，直接将它们发送到模型，并将清理信息的工作留给模型。另一个选项是控制器检查提供的参数是否合理，然后将它们交给模型。还有其他解决方案，例如构建一个检查参数是否有效的类，这个类可以在不同的控制器中重用。在这种情况下，它将取决于参数的数量和清理中涉及的逻辑。对于接收大量数据的请求，第三个选项看起来是其中最好的，因为我们将在不同的端点重用代码，并且我们没有编写过长的控制器。但在用户发送一个或两个参数的请求中，在控制器中清理它们可能就足够了。
- en: 'Now that we''ve set the ground, let''s prepare our application to use controllers.
    The first thing to do is to update our `index.php`, which has been forcing the
    application to always render the same template. Instead, we should be giving this
    task to the router, which will return the response as a string that we can just
    print with `echo`. Update your `index.php` file with the following content:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经奠定了基础，让我们准备我们的应用程序使用控制器。首先要做的是更新我们的`index.php`文件，它一直迫使应用程序始终渲染相同的模板。相反，我们应该将这个任务交给路由器，它将返回一个字符串作为响应，我们可以直接使用`echo`打印。使用以下内容更新您的`index.php`文件：
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As you might remember, the router instantiates a controller class, sending
    the request object to the constructor. But controllers have other dependencies
    as well, such as the template engine, the database connection, or the configuration
    reader. Even though this is not the best solution (you will improve it once we
    cover dependency injection in the next section), we could create an `AbstractController`
    that would be the parent of all controllers, and will set those dependencies.
    Copy the following as `src/Controllers/AbstractController.php`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能记得，路由器实例化一个控制器类，将请求对象发送到构造函数。但是控制器还有其他依赖项，例如模板引擎、数据库连接或配置读取器。尽管这不是最佳解决方案（我们将在下一节介绍依赖注入时对其进行改进），我们可以创建一个`AbstractController`，它将是所有控制器的父类，并将设置这些依赖项。将以下内容复制为`src/Controllers/AbstractController.php`：
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When instantiating a controller, we will set some properties that will be useful
    when handling requests. We already know how to instantiate the database connection,
    the configuration reader, and the template engine. The fourth property, `$log`,
    will allow the developer to write logs to a given file when necessary. We will
    use the Monolog library for that, but there are many other options. Notice that
    in order to instantiate the logger, we get the value of log from the configuration,
    which should be the path to the log file. The convention is to use the `/var/log/`
    directory, so create the `/var/log/bookstore.log` file, and add `"log": "/var/log/bookstore.log"`
    to your configuration file.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '在实例化控制器时，我们将设置一些在处理请求时有用的属性。我们已经知道如何实例化数据库连接、配置读取器和模板引擎。第四个属性`$log`将允许开发者在必要时将日志写入指定的文件。我们将使用Monolog库来完成这项工作，但还有许多其他选项。请注意，为了实例化记录器，我们从配置中获取日志的值，这应该是日志文件的路径。惯例是使用`/var/log/`目录，因此创建`/var/log/bookstore.log`文件，并将`"log":
    "/var/log/bookstore.log"`添加到您的配置文件中。'
- en: Another thing that is useful to some controllers—but not all of them—is the
    information about the user performing the action. As this is only going to be
    available for certain routes, we should not set it when constructing the controller.
    Instead, we have a setter for the router to set the customer ID when available;
    in fact, the router does that already.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件对某些控制器有用的信息（但不是所有控制器）是关于执行动作的用户的信息。由于这仅适用于某些路由，我们不应该在构建控制器时设置它。相反，我们有一个setter用于路由器，当可用时设置客户ID；实际上，路由器已经这样做了。
- en: 'Finally, a handy helper method that we could use is one that renders a given
    template with parameters, as all the controllers will end up rendering one template
    or the other. Let''s add the following protected method to the `AbstractController`
    class:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个方便的辅助方法是我们可以使用的一个，它使用参数渲染给定的模板，因为所有控制器最终都会渲染一个模板或另一个。让我们向`AbstractController`类添加以下受保护的方法：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The error controller
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误控制器
- en: 'Let''s start by creating the easiest of the controllers: the `ErrorController`.
    This controller does not do much; it just renders the `error.twig` template sending
    the "Page not found!" message. As you might remember, the router uses this controller
    when it cannot match the request to any of the other defined routes. Save the
    following class in `src/Controllers/ErrorController.php`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建最简单的控制器：`ErrorController`。这个控制器并没有做很多事情；它只是渲染`error.twig`模板，发送“页面未找到！”的消息。你可能还记得，当路由器无法匹配到其他定义的路由时，它会使用这个控制器。将以下类保存到`src/Controllers/ErrorController.php`中：
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The login controller
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录控制器
- en: 'The second controller that we have to add is the one that manages the login
    of the customers. If we think about the flow when a user wants to authenticate,
    we have the following scenarios:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须添加的第二个控制器是管理客户登录的控制器。如果我们考虑用户想要进行身份验证时的流程，我们会遇到以下场景：
- en: The user wants to get the login form in order to submit the necessary information
    and log in.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户想要获取登录表单，以便提交必要的信息并登录。
- en: The user tries to submit the form, but we could not get the e-mail address.
    We should render the form again, letting them know about the problem.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户试图提交表单，但我们无法获取电子邮件地址。我们应该再次渲染表单，并让他们知道问题所在。
- en: The user submits the form with an e-mail, but it is not a valid one. In this
    case, we should show the login form again with an error message explaining the
    situation.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户提交了带有电子邮件的表单，但不是一个有效的电子邮件。在这种情况下，我们应该再次显示登录表单，并带有解释情况的错误信息。
- en: The user submits a valid e-mail, we set the cookie, and we show the list of
    books so the user can start searching. This is absolutely arbitrary; you could
    choose to send them to their borrowed books page, their sales, and so on. The
    important thing here is to notice that we will be redirecting the request to another
    controller.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户提交了一个有效的电子邮件，我们设置了cookie，并显示了书籍列表，以便用户可以开始搜索。这完全是任意的；你也可以选择将他们发送到他们借阅的书籍页面、他们的销售页面等。这里重要的是要注意，我们将请求重定向到另一个控制器。
- en: 'There are up to four possible paths. We will use the `request` object to decide
    which of them to use in each case, returning the corresponding response. Let''s
    create, then, the `CustomerController` class in `src/Controllers/CustomerController.php`
    with the `login` method, as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有多达四种可能的路径。我们将使用`request`对象来决定在每种情况下使用哪一条路径，并返回相应的响应。因此，让我们在`src/Controllers/CustomerController.php`中创建`CustomerController`类，并添加`login`方法，如下所示：
- en: '[PRE57]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see, there are four different returns for the four different cases.
    The controller itself does not do anything, but orchestrates the rest of the components,
    and makes decisions. First, we check if the request is a POST, and if it is not,
    we will assume that the user wants to get the form. If it is, we will check for
    the e-mail in the parameters, returning an error if the e-mail is not there. If
    it is, we will try to find the customer with that e-mail, using our model. If
    we get an exception saying that there is no such customer, we will render the
    form with a "Not found" error message. If the login is successful, we will set
    the cookie with the ID of the customer, and will execute the `getAll` method of
    `BookController` (still to be written), returning the list of books.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有四种不同的返回值对应于四种不同的情况。控制器本身并没有做什么，而是协调其他组件，并做出决策。首先，我们检查请求是否为POST，如果不是，我们将假设用户想要获取表单。如果是，我们将检查参数中的电子邮件，如果电子邮件不存在，则返回错误。如果存在，我们将尝试使用我们的模型找到具有该电子邮件的客户。如果得到一个异常，表示没有这样的客户，我们将渲染带有“未找到”错误信息的表单。如果登录成功，我们将设置包含客户ID的cookie，并执行`BookController`的`getAll`方法（尚未编写），返回书籍列表。
- en: At this point, you should be able to test the login feature of your application
    end to end with the browser. Try to access `http://localhost:8000/login` to see
    the form, adding random e-mails to get the error message, and adding a valid e-mail
    (check your `customer` table in MySQL) to log in successfully. After this, you
    should see the cookie with the customer ID.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该能够使用浏览器端到端测试你应用程序的登录功能。尝试访问 `http://localhost:8000/login` 来查看表单，添加随机的电子邮件以获取错误信息，并添加一个有效的电子邮件（检查MySQL中的`customer`表）以成功登录。之后，你应该能看到包含客户ID的cookie。
- en: The book controller
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 书籍控制器
- en: 'The `BookController` class will be the largest of our controllers, as most
    of the application relies on it. Let''s start by adding the easiest methods, the
    ones that just retrieve information from the database. Save this as `src/Controllers/BookController.php`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookController`类将是我们的控制器中最大的一个，因为大多数应用程序都依赖于它。让我们先添加最简单的函数，即只从数据库检索信息的函数。将其保存为`src/Controllers/BookController.php`：'
- en: '[PRE58]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There's nothing too special in this preceding code so far. The `getAllWithPage`
    and `getAll` methods do the same thing, one with the page number given by the
    user as a URL argument, and the other setting the page number as 1—the default
    case. They ask the model for the list of books to be displayed and passed to the
    view. The information of the current page—and whether or not we are on the last
    page—is also sent to the template in order to add the "previous" and "next" page
    links.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这段前置代码并没有什么特别之处。`getAllWithPage` 和 `getAll` 方法执行相同的功能，一个通过用户提供的页面编号作为URL参数，另一个将页面编号设置为1——默认情况。它们请求模型以获取要显示并传递给视图的书籍列表。当前页面的信息——以及我们是否在最后一页——也会发送到模板中，以便添加“上一页”和“下一页”的链接。
- en: The `get` method will get the ID of the book that the customer is interested
    in. It will try to fetch it using the model. If the model throws an exception,
    we will render the error template with a "Book not found" message. Instead, if
    the book ID is valid, we will render the book template as expected.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 方法将获取客户感兴趣的书籍的ID。它将尝试使用模型获取它。如果模型抛出异常，我们将渲染带有“书籍未找到”信息的错误模板。相反，如果书籍ID有效，我们将按预期渲染书籍模板。'
- en: The `getByUser` method will return all the books that the authenticated customer
    has borrowed. We will make use of the `customerId` property that we set from the
    router. There is no sanity check here, since we are not trying to get a specific
    book, but rather a list, which could be empty if the user has not borrowed any
    books yet—but that is not an issue.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`getByUser`方法将返回认证客户借阅的所有书籍。我们将使用从路由器设置的`customerId`属性。这里没有进行合理性检查，因为我们不是试图获取特定的书籍，而是一个列表，如果用户尚未借阅任何书籍，这个列表可能为空——但这不是问题。'
- en: 'Another getter controller is the one that searches for a book by its title
    and/or author. This method will be triggered when the user submits the form in
    the layout template. The form sends both the `title` and the `author` fields,
    so the controller will ask for both. The model is ready to use the arguments that
    are empty, so we will not perform any extra checking here. Add the method to the
    `BookController` class:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个获取器控制器是搜索书籍标题和/或作者的方法。当用户在布局模板中提交表单时，将触发此方法。表单发送 `title` 和 `author` 字段，因此控制器将请求这两个字段。模型已经准备好使用空参数，因此我们在这里不会进行任何额外的检查。将方法添加到
    `BookController` 类中：
- en: '[PRE59]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Your application cannot perform any actions, but at least you can finally browse
    the list of books, and click on any of them to view the details. We are finally
    getting something here!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序无法执行任何操作，但至少您最终可以浏览书籍列表，并点击其中任何一本书查看详细信息。我们终于有所收获了！
- en: Borrowing books
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 借阅书籍
- en: 'Borrowing and returning books are probably the actions that involve the most
    logic, together with buying a book, which will be covered by a different controller.
    This is a good place to start logging the user''s actions, since it will be useful
    later for debugging purposes. Let''s see the code first, and then discuss it briefly.
    Add the following two methods to your `BookController` class:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 借阅和归还书籍可能是涉及最多逻辑的操作，与购买书籍一起，将由不同的控制器处理。这是一个开始记录用户操作的好地方，因为这对于以后的调试非常有用。让我们先看看代码，然后再简要讨论一下。向您的
    `BookController` 类添加以下两个方法：
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As we mentioned earlier, one of the new things here is that we are logging
    user actions, like when trying to borrow or return a book that is not valid. Monolog
    allows you to write logs with different priority levels: error, warning, and notices.
    You can invoke methods such as `error`, `warn`, or `notice` to refer to each of
    them. We use warnings when something unexpected, yet not critical, happens, for
    example, trying to borrow a book that is not there. Errors are used when there
    is an unknown problem from which we cannot recover, like an error from the database.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这里的新功能之一是我们正在记录用户操作，例如尝试借阅或归还无效的书籍。Monolog 允许您使用不同的优先级级别写入日志：错误、警告和通知。您可以使用
    `error`、`warn` 或 `notice` 等方法来引用它们。当发生意外但非关键的情况时，我们会使用警告，例如尝试借阅不存在的书籍。当出现我们无法恢复的未知问题时，我们会使用错误，例如数据库错误。
- en: 'The modus operandi of these two methods is as follows: we get the `book` object
    from the 3database with the given book ID. As usual, if there is no such book,
    we return an error page. Once we have the `book` domain object, we make use of
    the helpers `addCopy` and `getCopy` in order to update the stock of the book,
    and send it to the model, together with the customer ID, to store the information
    in the database. There is also a sanity check when borrowing a book, just in case
    there are no more books available. In both cases, we return the list of books
    that the user has borrowed as the response of the controller.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法的操作模式如下：我们从数据库中根据给定的书籍 ID 获取 `book` 对象。通常情况下，如果没有这样的书籍，我们会返回一个错误页面。一旦我们有了
    `book` 领域对象，我们就使用 `addCopy` 和 `getCopy` 等辅助器来更新书籍库存，并将其连同客户 ID 一起发送到模型，以便在数据库中存储信息。在借阅书籍时，我们也会进行一个合理性检查，以防没有更多的书籍可用。在这两种情况下，我们都将用户已借阅的书籍列表作为控制器的响应返回。
- en: The sales controller
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 销售控制器
- en: 'We arrive at the last of our controllers: the `SalesController`. With a different
    model, it will end up doing pretty much the same as the methods related to borrowed
    books. But we need to create the `sale` domain object in the controller instead
    of getting it from the model. Let''s add the following code, which contains a
    method for buying a book, `add`, and two getters: one that gets all the sales
    of a given user and one that gets the info of a specific sale, that is, `getByUser`
    and `get` respectively. Following the convention, the file will be `src/Controllers/SalesController.php`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来到了最后一个控制器：`SalesController`。由于使用了不同的模型，它最终将执行与借阅书籍相关的方法几乎相同的功能。但我们需要在控制器中创建
    `sale` 领域对象，而不是从模型中获取它。让我们添加以下代码，其中包含一个购买书籍的方法 `add` 和两个获取器：一个获取特定用户的全部销售记录，另一个获取特定销售的信息，即
    `getByUser` 和 `get`。按照惯例，文件将是 `src/Controllers/SalesController.php`：
- en: '[PRE61]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Dependency injection
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'At the end of the chapter, we will cover one of the most interesting and controversial
    of the topics that come with, not only the MVC pattern, but OOP in general: **dependency
    injection**. We will show you why it is so important, and how to implement a solution
    that suits our specific application, even though there are quite a few different
    implementations that can cover different necessities.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将介绍与MVC模式以及一般OOP相关的最有趣和最具争议的话题之一：**依赖注入**。我们将向你展示为什么它如此重要，以及如何实施一个适合我们特定应用的解决方案，尽管有相当多的不同实现可以满足不同的需求。
- en: Why is dependency injection necessary?
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要依赖注入？
- en: 'We still need to cover the way to unit test your code, hence you have not experienced
    it by yourself yet. But one of the signs of a potential source of problems is
    when you use the `new` statement in your code to create an instance of a class
    that does not belong to your code base—also known as a dependency. Using `new`
    to create a domain object like `Book` or `Sale` is fine. Using it to instantiate
    models is also acceptable. But manually instantiating, which something else, such
    as the template engine, the database connection, or the logger, is something that
    you should avoid. There are different reasons that support this idea:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要介绍如何对代码进行单元测试，因此你还没有亲自体验过。但潜在问题来源的一个迹象是在你的代码中使用`new`语句创建不属于你的代码库的类的实例——也称为依赖项。使用`new`创建域对象，如`Book`或`Sale`是可以的。用它来实例化模型也是可以接受的。但手动实例化其他东西，比如模板引擎、数据库连接或记录器，是你应该避免的。有不同理由支持这个观点：
- en: If you want to use a controller from two different places, and each of these
    places needs a different database connection or log file, instantiating those
    dependencies inside the controller will not allow us to do that. The same controller
    will always use the same dependency.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想在两个不同的地方使用控制器，并且每个地方都需要不同的数据库连接或日志文件，那么在控制器内部实例化这些依赖项将不允许我们这样做。同一个控制器将始终使用相同的依赖项。
- en: Instantiating the dependencies inside the controller means that the controller
    is fully aware of the concrete implementation of each of its dependencies, that
    is, the controller knows that we are using PDO with the MySQL driver and the location
    of the credentials for the connection. This means a high level of coupling in
    your application—so, bad news.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制器内部实例化依赖项意味着控制器完全了解每个依赖项的具体实现，也就是说，控制器知道我们正在使用PDO和MySQL驱动程序，以及连接凭证的位置。这意味着你的应用程序耦合度很高——所以，坏消息。
- en: Replacing one dependency with another that implements the same interface is
    not easy if you are instantiating the dependency explicitly everywhere, as you
    will have to search all these places, and change the instantiation manually.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在每个地方都显式实例化依赖项，那么用实现相同接口的另一个依赖项替换一个依赖项并不容易，因为你将不得不搜索所有这些地方，并手动更改实例化。
- en: 'For all these reasons, and more, it is always good to provide the dependencies
    that a class such as a controller needs instead of letting it create its own.
    This is something that everybody agrees with. The problem comes when implementing
    a solution. There are different options:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些原因，以及更多原因，总是提供控制器等类需要的依赖项，而不是让它自己创建，这是一个大家都能接受的观点。问题在于实施解决方案。有几种不同的选择：
- en: We have a constructor that expects (through arguments) all the dependencies
    that the controller, or any other class, needs. The constructor will assign each
    of the arguments to the properties of the class.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个期望（通过参数）所有控制器或任何其他类需要的依赖项的构造函数。构造函数将每个参数分配给类的属性。
- en: We have an empty constructor, and instead, we add as many setter methods as
    the dependencies of the class.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个空构造函数，而不是添加与类的依赖项一样多的setter方法。
- en: A hybrid of both, where we set the main dependencies through a constructor,
    and set the rest of the dependencies via setters.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种混合方式，我们通过构造函数设置主要依赖项，其余依赖项则通过setter设置。
- en: Sending an object that contains all the dependencies as a unique argument for
    the constructor, and the controller gets the dependencies that it needs from that
    container.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将包含所有依赖项的对象作为唯一参数传递给构造函数，控制器从该容器中获取它需要的依赖项。
- en: Each solution has its pros and cons. If we have a class with a lot of dependencies,
    injecting all of them via the constructor would make it counterintuitive, so it
    would be better if we inject them using setters, even though a class with a lot
    of dependencies looks like bad design. If we have just one or two dependencies,
    using the constructor could be acceptable, and we will write less code. For classes
    with several dependencies, but not all of them mandatory, using the hybrid version
    could be a good solution. The fourth option makes it easier when injecting the
    dependencies as we do not need to know what each object expects. The problem is
    that each class should know how to fetch its dependency, that is, the dependency
    name, which is not ideal.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our own dependency injector
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open source solutions for dependency injectors are already available, but we
    think that it would be a good experience to implement a simple one by yourself.
    The idea of our dependency injector is a class that contains instances of the
    dependencies that your code needs. This class, which is basically a map of dependency
    names to dependency instances, will have two methods: a getter and a setter of
    dependencies. We do not want to use a static property for the dependencies array,
    as one of the goals is to be able to have more than one dependency injector with
    a different set of dependencies. Add the following class to `src/Utils/DependencyInjector.php`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Having a dependency injector means that we will always use the same instance
    of a given class every time we ask for it, instead of creating one each time.
    That means that singleton implementations are not needed anymore; in fact, as
    mentioned in [Chapter 4](part0033_split_000.html#VF2I2-edcc22b134104d5db0bf3aa086c86851
    "Chapter 4. Creating Clean Code with OOP"), *Creating Clean Code with OOP*, it
    is preferable to avoid them. Let''s get rid of them, then. One of the places where
    we were using it was in our configuration reader. Replace the existing code with
    the following in the `src/Core/Config.php` file:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The other place where we were making use of the singleton pattern was in the
    `DB` class. In fact, the purpose of the class was only to have a singleton for
    our database connection, but if we are not making use of it, we can remove the
    entire class. So, delete your `src/Core/DB.php` file.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to define all these dependencies and add them to our dependency
    injector. The `index.php` file is a good place to have the dependency injector
    before we route the request. Add the following code just before instantiating
    the `Router` class:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'There are a few changes that we need to make now. The most important of them
    refers to the `AbstractController`, the class that will make heavy use of the
    dependency injector. Add a property named `$di` to that class, and replace the
    constructor with the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The other changes refer to the `Router` class, as we are sending it now as
    part of the constructor, and we need to inject it to the controllers that we create.
    Add a `$di` property to that class as well, and change the constructor to the
    following one:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 其他更改涉及`Router`类，因为我们现在将其作为构造函数的一部分发送，我们需要将其注入到我们创建的控制器中。给这个类添加一个`$di`属性，并将构造函数更改为以下形式：
- en: '[PRE66]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Also change the content of the `executeController` and `route` methods:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要更改`executeController`和`route`方法的内容：
- en: '[PRE67]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'There is one last place that you need to change. The `login` method of `CustomerController`
    was instantiating a controller too, so we need to inject the dependency injector
    there as well:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要更改一个地方。`CustomerController`的`login`方法也在实例化控制器，所以我们也需要在那里注入依赖注入器：
- en: '[PRE68]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned what MVC is, and how to write an application that
    follows that pattern. You also know how to use a router to route requests to controllers,
    Twig to write templates, and Composer to manage your dependencies and autoloader.
    You were introduced to dependency injection, and you even built your own implementation,
    even though it is a very controversial topic with many different points of view.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了什么是MVC，以及如何编写遵循该模式的程序。你还知道了如何使用路由器将请求路由到控制器，使用Twig编写模板，以及使用Composer管理你的依赖和自动加载器。你被介绍了依赖注入，甚至自己构建了一个实现，尽管这是一个非常有争议的话题，有很多人不同的观点。
- en: 'In the next chapter, we will go through one of the most important parts needed
    when writing good code and good applications: unit testing your code to get quick
    feedback from it.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨编写良好代码和应用程序时最需要的部分之一：对你的代码进行单元测试以获得快速的反馈。
