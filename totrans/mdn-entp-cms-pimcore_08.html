<html><head></head><body>
		<div id="_idContainer131">
			<h1 id="_idParaDest-138"><em class="italic"><a id="_idTextAnchor139"/>Chapter 8</em>: Creating Custom CMS Pages</h1>
			<p>In the previous chapters, we learned how to create documents and objects and implement very simple websites using such features. </p>
			<p>In this chapter, we will have a deep dive into the creation of custom CMS pages. In fact, if you are templating a document or creating a standalone page, you have many tools that make the development experience in Pimcore great for you. This chapter will cover many aspects that are fundamental for a full overview of Pimcore's CMS capabilities; such features are basic tools for creating custom web pages, which we have combined to discuss user inputs and templates for creating content. </p>
			<p>The chapter is structured as follows:</p>
			<ul>
				<li>Using the MVC Model</li>
				<li>Using Editables</li>
				<li>Using Blocks</li>
			</ul>
			<p>Let's see Pimcore in action! </p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor140"/>Technical requirements</h1>
			<p>As with the previous chapters, there is a demo that you can find in our GitHub repository, which you can find here: <a href="https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore">https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore</a>. </p>
			<p>All you need to do to run the demo connected with this chapter is to clone it and navigate to the <strong class="source-inline">8. Creating Custom CMS Pages</strong> folder and start the Docker environment.</p>
			<p>To do so, just follow these instructions:</p>
			<ol>
				<li>Run Docker with the following command:<p class="source-code"><strong class="bold">docker-compose up</strong></p></li>
				<li>Then, to restore all the settings from on your local machine, type the following:<p class="source-code"><strong class="bold">docker-compose exec php bash restore.sh</strong></p></li>
				<li>Navigate to <a href="http://localhost/admin">http://localhost/admin</a> and log in with your admin/pimcore credentials.</li>
			</ol>
			<p>What you will get with this setup is the following:</p>
			<ul>
				<li>A class definition called <strong class="source-inline">MyObject</strong></li>
				<li>Two instances of the class, <strong class="source-inline">My Item 1</strong> and <strong class="source-inline">My Item 2</strong> </li>
				<li>The <strong class="bold">Editables</strong> page, a page with a demo of editables (see <em class="italic">Using Editables</em>)</li>
				<li>The <strong class="bold">Template</strong> page, a page with a demo of the templating helpers (see <em class="italic">Using the MVC model</em>)</li>
				<li>A thumbnail preset called <strong class="source-inline">MyThumbnails</strong></li>
			</ul>
			<p>Now you are ready to play with the demo related to this chapter! </p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor141"/>Using the MVC Model</h1>
			<p>In <a id="_idIndexMarker421"/>this section, we will learn how the <strong class="bold">MVC</strong> (<strong class="bold">Model View Controller</strong>) model works and how to use it for creating a standalone web page that works outside the document scope. This is very important for covering all possible needs that you may encounter on your path with Pimcore as a Content Management System. </p>
			<p>The MVC principle is very easy. When a URL matches a set of rules (<strong class="bold">Routing</strong>), a controller class is activated and this will compute data (<strong class="bold">Model</strong>) using certain business logic (<strong class="bold">Controller</strong>). The data is then sent to the <strong class="bold">View</strong> that implements the presentation logic and shows content to the user.</p>
			<p>In this section, we will cover the most important concepts relating to building embedded web pages using the MVC pattern:</p>
			<ul>
				<li>Controllers</li>
				<li>Views (template helpers)</li>
				<li>Routing</li>
			</ul>
			<p>Let's see them in detail.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor142"/>Controllers</h2>
			<p>Pimcore <strong class="bold">Controllers</strong> implement the "C" part of the MVC pattern. Controllers are responsible for business<a id="_idIndexMarker422"/> logic or, in simpler words, are the part of your source code that reads, manipulates, and prepares data to be passed to the presentation layers (views). It is good practice to keep all the reusable logic in service classes, but the point that connects presentation with the business layer is, in fact, the controller element. </p>
			<p>Pimcore offers an abstract class (<strong class="source-inline">FrontendController</strong>) that can be used as a base for your controller implementation. This simply means that all your controllers will usually inherit from the frontend controller. The naming convention of your files will follow the generic Symfony rules. In a simple scenario where you use Symfony's standards for your website, you will have the following rules:</p>
			<ul>
				<li><strong class="bold">Controller class name</strong>: <strong class="source-inline">/src/Controller/[Controller].php</strong></li>
				<li><strong class="bold">View filename</strong>: <strong class="source-inline">/templates/[Controller]/[action].html.twig</strong></li>
			</ul>
			<p>Inside controllers, you can create any action you want. Each action is responsible for a single functionality and is linked to a URL. We usually create a controller for each topic or homogeneous group or function (that is, <strong class="source-inline">CustomerController</strong>, which manages all the customer's features). If you invoke a controller omitting the action name, <strong class="source-inline">default</strong> will be used.</p>
			<p>As we explained in <a href="B17073_04_ePub_RK.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating Documents in Pimcore</em>, we can choose a controller for each document and Pimcore comes out with a ready-to-go controller called <strong class="source-inline">DefaultController</strong>. We can create controllers that are unrelated to documents and simply implement custom web pages. </p>
			<p>Inside controllers, you can access some special variables that can help you to define how to build the desired output:</p>
			<ul>
				<li><strong class="source-inline">$this-&gt;document</strong>: If you are working on a document, this is the document that you are manipulating.</li>
				<li><strong class="source-inline">$this-&gt;editmode</strong>: Indicates whether you are in edit mode or not, and can be used for diversifying the output based on the case. This applies when you are working with documents.</li>
			</ul>
			<p>In the next sections, you will find some examples of controller actions that cover all the most common use cases. </p>
			<h3>Passing data to a view</h3>
			<p>The following <a id="_idIndexMarker423"/>example is an action that adds a variable into the view with a value. In this case, the value is just text, but imagine that you could use the input from <strong class="source-inline">$request</strong> for computing data and add a more complex data object:</p>
			<p class="source-code">    public function dataAction(Request $request)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        $input=$request-&gt;get('data');</p>
			<p class="source-code">      return array(</p>
			<p class="source-code">                'content' =&gt;$input</p>
			<p class="source-code">            );     </p>
			<p class="source-code">    }</p>
			<h3>Setting HTTP headers</h3>
			<p>Another<a id="_idIndexMarker424"/> requirement that we may have is to set some HTTP headers. If these values are fixed, you can add them using an annotation, or you can access and programmatically alter the response object using the <strong class="source-inline">addResponseHeader</strong> helper:</p>
			<p class="source-code">    /**</p>
			<p class="source-code">     * @ResponseHeader("X-Foo", values={"123456", "98765"})</p>
			<p class="source-code">     */</p>
			<p class="source-code">    public function headerAction(Request $request)</p>
			<p class="source-code">    {   </p>
			<p class="source-code">        $response = new Response();</p>
			<p class="source-code">        // using code: </p>
			<p class="source-code">        $response-&gt;headers-&gt;set('X-Foo', 'bar'); </p>
			<p class="source-code">        return $response;</p>
			<p class="source-code">    }</p>
			<p>The previous <a id="_idIndexMarker425"/>code adds three values for the same header: the first two from the annotation, and the other from the piece of code inside the method.</p>
			<h3>Specifying the template path</h3>
			<p>If you are scared <a id="_idIndexMarker426"/>about the fixed conventions of templating, we will reassure you with the next example. In the following snippet, we will override the normal template path by setting it manually: </p>
			<p class="source-code">    public function differentPathAction()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return $this-&gt;render("<strong class="bold">Default/default.html.twig</strong>", ["foo" =&gt; "bar"]); </p>
			<p class="source-code">    }</p>
			<p>Alternatively, you can manually specify the template path to the <strong class="source-inline">@Template()</strong> annotation and just return the data, as in the following snippet:</p>
			<p class="source-code">/**</p>
			<p class="source-code">* @Template(<strong class="bold">Default/default.html.twig</strong>)</p>
			<p class="source-code">*/</p>
			<p class="source-code">public function differentPathAction()</p>
			<p class="source-code">{</p>
			<p class="source-code">   return return ["foo" =&gt; "bar"]; </p>
			<p class="source-code">}</p>
			<h3>Generating JSON output</h3>
			<p>Even though Pimcore<a id="_idIndexMarker427"/> comes with a powerful API engine and <strong class="bold">Datahub Change this throughout the chapter</strong> lets you make anything using <strong class="bold">GraphQL</strong>, you may need to produce APIs manually. This scenario is easy to manage with controllers and the <strong class="source-inline">json</strong> function. In the next example, you will see how to create a <strong class="source-inline">json</strong> response starting from plain data:</p>
			<p class="source-code">    public function jsonAction(Request $request)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return $this-&gt;json(array('key' =&gt; 'value'));</p>
			<p class="source-code">    } </p>
			<p>This outputs the <strong class="source-inline">json</strong> serialization of data as the body of the response and sets the content type to <strong class="source-inline">application/json</strong>.</p>
			<h3>For all other cases</h3>
			<p>As a final fallback, if none of the <a id="_idIndexMarker428"/>standard solutions offered by Pimcore will satisfy your needs, there is the bare option to create a Symfony response object manually and return it to the MVC engine. Using this option, you will be free to set all response parameters, for <strong class="source-inline">mime</strong> type to the raw content without any limitation. In the next example, we will return fixed text:</p>
			<p class="source-code">    public function customAction(Request $request)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return new Response("Just some text");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The previous block of code returns a response with text content as an example. Given the <strong class="source-inline">Request</strong> object, you can implement all the code you want and then produce a custom <strong class="source-inline">Response</strong>.</p>
			<p>All the preceding <a id="_idIndexMarker429"/>actions are intended to be contained in a <strong class="source-inline">controller</strong> class like this:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">namespace App\Controller;</p>
			<p class="source-code">use Pimcore\Controller\FrontendController;</p>
			<p class="source-code">use Symfony\Component\HttpFoundation\Request;</p>
			<p class="source-code">use Symfony\Component\HttpFoundation\Response;</p>
			<p class="source-code">use Pimcore\Controller\Configuration\ResponseHeader;</p>
			<p class="source-code">class MyController extends FrontendController</p>
			<p class="source-code">{</p>
			<p class="source-code">   // Add your actions here</p>
			<p class="source-code">} </p>
			<p>This set of samples is not exhaustive but contains the most important features and is a great starting point. You can find more details in the official documentation: <a href="https://pimcore.com/docs/pimcore/current/Development_Documentation/MVC/index.html">https://pimcore.com/docs/pimcore/current/Development_Documentation/MVC/index.html</a>.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor143"/>Views</h2>
			<p>This section <a id="_idIndexMarker430"/>covers the "V" component of the MVC pattern. <strong class="bold">Views</strong> are the components that receive data and render it by implementing presentation logic. A views file can be written using Twig or a PHP template but, as we told you in <a href="B17073_04_ePub_RK.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating Documents in Pimcore</em>, we will focus only on the Twig solution, which allows a more strict separation between business and presentation logic and makes Pimcore a real detached CMS. The downside of this solution is that the logic that you can implement in a Twig file is limited as it forces you to implement all the business logic in the controller. This strict separation may seem limiting at the beginning, but when you are confident with <a id="_idIndexMarker431"/>the pattern, you will agree that it's more clean, reusable, and maintainable. Other than all the platform-specific features, called <strong class="bold">helpers</strong>, Pimcore's Twig files <a id="_idIndexMarker432"/>support all the standard features of Twig.</p>
			<p>Here is a list of the most important Pimcore helpers.</p>
			<h3>pimcore_object</h3>
			<p>In the<a id="_idIndexMarker433"/> following code, we loaded <a id="_idIndexMarker434"/>an object by its <strong class="source-inline">id</strong> (in our case, <strong class="source-inline">2</strong>) and we displayed the <strong class="source-inline">Title</strong> property:</p>
			<p class="source-code">{% set myObject = pimcore_object(2) %}</p>
			<p class="source-code">{{ myObject.getTitle() }}</p>
			<p>Our object has a <strong class="source-inline">Title</strong> property accessed by the standard <strong class="source-inline">getTitle</strong> <strong class="source-inline">method</strong>, so the value will be printed.</p>
			<h3>pimcore_document</h3>
			<p>In the next <a id="_idIndexMarker435"/>snippet, we<a id="_idIndexMarker436"/> have loaded a document and printed the title:</p>
			<p class="source-code">{% set myDoc = pimcore_document(3) %}</p>
			<p class="source-code">title: {{ myDoc.getTitle}} &lt;/br&gt;</p>
			<p class="source-code">url: {{ myDoc}}</p>
			<p>The <strong class="source-inline">myDoc</strong> element is Pimcore's document and all its properties can be accessed. </p>
			<h3>pimcore_asset</h3>
			<p>This <a id="_idIndexMarker437"/>helper loads an <a id="_idIndexMarker438"/>asset that can be used in the template. In the next example, we loaded one asset and we displayed the <strong class="source-inline">filename</strong> and <strong class="source-inline">url</strong>:</p>
			<p class="source-code">{% set myDoc = pimcore_asset(2) %}</p>
			<p class="source-code">url: {{ myDoc}} &lt;br&gt;</p>
			<p class="source-code">filename: {{ myDoc.getFilename}}</p>
			<p>Alternatively, you can find an asset by its path, using the following shortcut:</p>
			<p class="source-code">{% set asset = asset('/path/to/image.jpg') %}</p>
			<p>As usual, the assigned variable can be used in the template file for implementing any presentation logic.</p>
			<h3>Render controller output</h3>
			<p>This function calls an <a id="_idIndexMarker439"/>arbitrary action and prints the result. In the next <a id="_idIndexMarker440"/>example, we used the <strong class="source-inline">/custom/json</strong> example and we rendered the output, passing <strong class="source-inline">items=11</strong> as the parameter:</p>
			<p class="source-code">{{ render(controller('App\\Controller\\CustomController::jsonAction', { items: 11 })) </p>
			<p class="source-code">}}</p>
			<p>The parameter order is action, controller, bundle, and parameters.</p>
			<h3>pimcore_cache</h3>
			<p>Pimcore's cache<a id="_idIndexMarker441"/> simply implements an in-template caching functionality. You<a id="_idIndexMarker442"/> can use this to cache some parts of the HTML page directly in the template, independent of the other global definable caching functionality. This can be useful for templates that need a lot of calculation or require a huge amount of objects (such as navigations, and so on). In the next block of code, we will see caching in action:</p>
			<p class="source-code">{% set cache = pimcore_cache("cache_key", 60, true) %}</p>
			<p class="source-code">{% if not cache.start() %}</p>
			<p class="source-code">    &lt;h1&gt;If you refresh the page this date will remain the     same&lt;/h1&gt;</p>
			<p class="source-code">    {{ 'now'|date('y-m-d') }} v{{ 'now'|date('U') }}</p>
			<p class="source-code">    {% do cache.end() %}</p>
			<p class="source-code">{% endif %} </p>
			<p>The <a id="_idIndexMarker443"/>parameter order is the name of the key, the timeout in seconds, and an optional flag<a id="_idIndexMarker444"/> for forcing the cache in admin mode. </p>
			<h3>pimcore_device</h3>
			<p>The <strong class="source-inline">pimcore_device</strong> function<a id="_idIndexMarker445"/> helps when implementing adaptive<a id="_idIndexMarker446"/> designs. The next piece of code displays the usage of this helper in a template snippet:</p>
			<p class="source-code">{% if pimcore_device().isPhone() %}</p>
			<p class="source-code">    I'm a phone</p>
			<p class="source-code">{% elseif pimcore_device().isTablet() %}</p>
			<p class="source-code">    I'm a table</p>
			<p class="source-code">{% elseif pimcore_device().isDesktop() %}</p>
			<p class="source-code">    I'm a desktop device</p>
			<p class="source-code">{% endif %}</p>
			<p>If you are running this script on your PC, the output will be <strong class="bold">I'm a desktop device</strong>.</p>
			<h3>Request</h3>
			<p>From the <a id="_idIndexMarker447"/>default Symfony objects, you can access the request<a id="_idIndexMarker448"/> data. This can be done using the <strong class="source-inline">app.request</strong> item that contains all the information that we need. In the next example, we used this method to get the <strong class="source-inline">"_dc"</strong> URL parameter that you usually have in a page preview:</p>
			<p class="source-code">{{ app.request.get("_dc") }}</p>
			<p>This is just a<a id="_idIndexMarker449"/> sample, and you can access all the request parameters. You can look at the<a id="_idIndexMarker450"/> official documentation for more information, here: <a href="https://symfony.com/doc/current/templates.html#the-app-global-variable">https://symfony.com/doc/current/templates.html#the-app-global-variable</a>.</p>
			<h3>Glossary</h3>
			<p>This helper<a id="_idIndexMarker451"/> replaces glossary terms with links. The glossary module<a id="_idIndexMarker452"/> is a powerful tool, making internal and external linking easy and smart, and which Pimcore has out of the box. As an example, you can connect the word "Pimcore" with the official website, so that each time you use it in HTML, it will be replaced with a link to the website. The<strong class="source-inline"> pimcore_glossary</strong> helper will be used by this helper to render links. To test this feature, follow these steps:</p>
			<ol>
				<li value="1">Go to <strong class="bold">Tools </strong>| <strong class="bold">Glossary</strong>. </li>
				<li>Click <strong class="bold">Add</strong>. </li>
				<li>Enter the term <strong class="source-inline">PIMcore</strong> in the <strong class="bold">Text</strong> column and then the link to the page in the <strong class="bold">Link</strong> column. In this example, we added PIMcore and CMS words with the related links. In the next screenshot, you will find the result:<div id="_idContainer099" class="IMG---Figure"><img src="image/Figure_8.01_B17073.jpg" alt="Figure 8.1: Glossary terms&#13;&#10;"/></div><p class="figure-caption">Figure 8.1: Glossary terms</p></li>
				<li>Now the glossary is set and we can use it on any web page using the <strong class="source-inline">pimcoreglossary</strong> helper. We can do this by placing the following snippet in a web page template:<p class="source-code">{% pimcoreglossary %}</p><p class="source-code">My content PIMCore loves CMS</p><p class="source-code">{% endpimcoreglossary %}</p><p>In the<a id="_idIndexMarker453"/> previous snippet, we surround the text with the <strong class="source-inline">glossary</strong> function.  Because we defined <a id="_idIndexMarker454"/>the words <strong class="bold">PIMcore</strong> and <strong class="bold">CMS</strong> inside the glossary, they will be transformed into a link on the web page. This is the final result:</p></li>
			</ol>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/Figure_8.02_B17073.jpg" alt="Figure 8.2: The glossary helper in action&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2: The glossary helper in action</p>
			<p>This was a simple example to explain the concept, but it shows how powerful this feature is. </p>
			<h3>pimcore_placeholder</h3>
			<p>This <a id="_idIndexMarker455"/>helper adds custom placeholders into the template. The next<a id="_idIndexMarker456"/> snippet defines a placeholder called <strong class="source-inline">myplaceholder</strong>, which is configured for building an H3 tag surrounding the <strong class="source-inline">"My content</strong>" value:</p>
			<p class="source-code">{% do  pimcore_placeholder('myplaceholder')</p>
			<p class="source-code">.setPrefix("&lt;h3&gt;")</p>
			<p class="source-code">.setPostfix("&lt;/h3&gt;")</p>
			<p class="source-code">.set("My content") %}</p>
			<p class="source-code">{# Print placeholder #}</p>
			<p class="source-code">{{ pimcore_placeholder('myplaceholder') }}</p>
			<p>The output of this is <strong class="source-inline">&lt;h3&gt;My content&lt;/h3&gt;</strong>.</p>
			<h3>pimcore_head_link</h3>
			<p>This<a id="_idIndexMarker457"/> helper collects a <a id="_idIndexMarker458"/>list of head links (stylesheet or any other <strong class="source-inline">head link</strong> tag) and prints them on the head section of the web page. Based on the presentation logic, the links are collected (you may or may not include a file based on some special conditions) and then printed once. </p>
			<p>In the following example, the snippets append a favicon (favorite icon – the logos you see in browser tabs when you surf websites) to the link list:</p>
			<p class="source-code">{% do  pimcore_head_link({'rel' : 'icon', 'href' : '/img/favicon.ico'},"APPEND")  %}</p>
			<p class="source-code">{# Print head links#}</p>
			<p class="source-code">{{ pimcore_head_link()}}</p>
			<p>In the example, we appended a favicon to the list. Using the correct configuration of <strong class="source-inline">pimcore_head_link</strong>, we can also define the order using relative inclusion (for example, add x file after y file).</p>
			<h3>pimcore_head_meta</h3>
			<p>This helper <a id="_idIndexMarker459"/>prints <a id="_idIndexMarker460"/>HTTP meta tags. It can collect a set of items that will be printed once in the header section. In the next block of code, like in the <strong class="source-inline">HeadLink</strong> helper, the data is collected and printed to the function by the final call:</p>
			<p class="source-code">{% do pimcore_head_meta().appendName('description', 'My SEO description for my awesome page') %} </p>
			<p class="source-code">{# adding addictional properties #}</p>
			<p class="source-code">{% do pimcore_head_meta().setProperty('og:title', 'my article title') %}</p>
			<p class="source-code">{# Print tags #}</p>
			<p class="source-code">{{ pimcore_head_meta() }}</p>
			<h3>pimcore_head_script</h3>
			<p>This is the <a id="_idIndexMarker461"/>same as <strong class="source-inline">HeadLink</strong> and <strong class="source-inline">Style</strong>, but for a JavaScript file. The next block of code<a id="_idIndexMarker462"/> adds a script to the list and then prints it on the page:</p>
			<p class="source-code">{% do pimcore_head_script().appendFile("/myscript.js") %}</p>
			<p class="source-code">{# Print tags #}</p>
			<p class="source-code">{{ pimcore_head_script()}}</p>
			<h3>pimcore_head_style</h3>
			<p>This helper manages<a id="_idIndexMarker463"/> inline styles. It is like <strong class="source-inline">HeadLink</strong>, but with<a id="_idIndexMarker464"/> inline scripts. In the next piece of code, we add a file called <strong class="source-inline">ie.css</strong> with conditional wrapping that, in this case, limits the CSS action to Internet Explorer before version 11:</p>
			<p class="source-code">{% do pimcore_head_style().appendStyle("ie.css", {'conditional': 'lt IE 11'}) %}</p>
			<p class="source-code">{# Print tags #}</p>
			<p class="source-code">{{ pimcore_head_style() }}</p>
			<h3>pimcore_head_title</h3>
			<p>Creates and save the HTML<a id="_idIndexMarker465"/> document's <strong class="source-inline">&lt;title&gt;</strong> for later retrieval and output. The<a id="_idIndexMarker466"/> following script adds the special <strong class="source-inline">title</strong> tag into the page:</p>
			<p class="source-code">{% do pimcore_head_title('My first part') %}</p>
			<p class="source-code">{# Print tags #}</p>
			<p class="source-code">{{ pimcore_head_title() }} </p>
			<h3>pimcore_inc</h3>
			<p>This helper <a id="_idIndexMarker467"/>includes a Pimcore document in the page. In the next snippet, we<a id="_idIndexMarker468"/> see how the <strong class="source-inline">MySnippet</strong> document is rendered and added to the page:</p>
			<p class="source-code">{{ pimcore_inc('/MySnippet') }}</p>
			<h3>pimcore_inline_script</h3>
			<p>This helper adds<a id="_idIndexMarker469"/> inline scripts to a page. The usage is very similar to <strong class="source-inline">HeadScript</strong>, but<a id="_idIndexMarker470"/> intended for inline usage. The next piece of code adds <strong class="source-inline">myscript.js</strong> to the list and then prints it on the page:</p>
			<p class="source-code">{% do pimcore_inline_script().appendFile("/myscript.js") %}</p>
			<p class="source-code">{# Print tags #}</p>
			<p class="source-code">{{ pimcore_inline_script() | raw }}</p>
			<h3>Navigation</h3>
			<p>This helper is responsible for <a id="_idIndexMarker471"/>generating and adding a navigation<a id="_idIndexMarker472"/> menu. In the next piece of code, you will find an example that prints a menu based on the document hierarchy:</p>
			<p class="source-code">{% set mainNavStartNode = document.getProperty('mainNavStartNode') %}</p>
			<p class="source-code">{% set navigation = pimcore_build_nav({</p>
			<p class="source-code">    active: document,</p>
			<p class="source-code">    root: mainNavStartNode</p>
			<p class="source-code">}) %}</p>
			<p class="source-code">{# Print tags #}</p>
			<p class="source-code">{{ pimcore_render_nav(navigation) }}</p>
			<p>In the snippet, it rendered a menu that starts from <strong class="source-inline">mainNavStartNode</strong>, which is the root document, and uses the current document as the active one. </p>
			<p>You can refer to the official documentation for more information on <strong class="source-inline">navigation</strong>: <a href="https://pimcore.com/docs/pimcore/current/Development_Documentation/Documents/Navigation.html">https://pimcore.com/docs/pimcore/current/Development_Documentation/Documents/Navigation.html. </a></p>
			<h3>include</h3>
			<p>This helper directly <a id="_idIndexMarker473"/>includes a template inside the page. Look at the following <a id="_idIndexMarker474"/>script:</p>
			<p class="source-code">{{ include("Default/include.html.twig", {'par':'value'}) }}</p>
			<p>This script includes the <strong class="source-inline">Default/include.html.twig</strong> <strong class="source-inline">template</strong>, where you can use the set of parameters passed as the input. </p>
			<h3>Translations</h3>
			<p>This is a Symfony feature<a id="_idIndexMarker475"/> integrated within Pimcore's engine. With the pipe <a id="_idIndexMarker476"/>filter, you can transform text using the translations database and replace the original text with the translated version. To do this, do the following:</p>
			<ol>
				<li value="1">Create a document and assign a template to it.</li>
				<li>Add the following snippet to the template:<p class="source-code">{% set message ="my-test-key" %} </p><p class="source-code">{{ message|trans }}</p><p>This script sets a variable with a string value (<strong class="source-inline">my-test-key</strong>) and then prints it using the <strong class="source-inline">trans</strong> filter.</p></li>
				<li>After the first usage of the label, an entry will be created in your backend, and you will be able to set a value for each language. Go to <strong class="bold">Tools</strong> | <strong class="bold">Shared Translations</strong>. Set the value of the label for each language by entering data into the table:<div id="_idContainer101" class="IMG---Figure"><img src="image/Figure_8.03_B17073.jpg" alt="Figure 8.3: The Shared Translations panel&#13;&#10;"/></div><p class="figure-caption">Figure 8.3: The Shared Translations panel</p></li>
				<li>Open the <a id="_idIndexMarker477"/>web page and <a id="_idIndexMarker478"/>see the translated text. </li>
			</ol>
			<p>The translation functionality is very useful and easy to manage with its visual interface. </p>
			<h3>Website config</h3>
			<p>Pimcore has a<a id="_idIndexMarker479"/> bucket of configuration keys that are easily editable via the web interface. You<a id="_idIndexMarker480"/> can add them from <strong class="bold">Settings</strong> | <strong class="bold">Website Settings</strong> and then you can insert the value into the template or controller. To do this, do the following:</p>
			<ol>
				<li value="1">Create a document and assign a template.</li>
				<li>Open the website settings administration from <strong class="bold">Settings</strong> | <strong class="bold">Website Settings</strong>.</li>
				<li>Enter a key for your settings in the top editing bar and choose the <strong class="bold">Text</strong> option.</li>
				<li>Click the <strong class="bold">+</strong> button and the value will be displayed in the table. You will be able to edit it just by entering text into the grid. In the next screenshot, you will see the final result. In this example, we added a key called <strong class="bold">mykey</strong> with the value <strong class="bold">My Value</strong>:<div id="_idContainer102" class="IMG---Figure"><img src="image/Figure_8.04_B17073.jpg" alt="Figure 8.4: The Website Settings panel&#13;&#10;"/></div><p class="figure-caption">Figure 8.4: The Website Settings panel</p></li>
				<li>Now <a id="_idIndexMarker481"/>add the following<a id="_idIndexMarker482"/> snippet to the template:<p class="source-code">{{ pimcore_website_config('mykey') }}</p><p>Using the preceding code, you will get <strong class="source-inline">MyValue</strong> as the result of the helper.</p></li>
			</ol>
			<p>The visual editing of settings is very useful because it lets us create configurable templates and websites that can be easily managed centrally.</p>
			<h3>instanceof</h3>
			<p>The <strong class="source-inline">instanceof</strong> construct <a id="_idIndexMarker483"/>is useful for checking whether an object is of a given type. In the <a id="_idIndexMarker484"/>next piece of code, we will check whether an asset instance is of type <strong class="source-inline">Image</strong> or not:</p>
			<p class="source-code">{% if item is instanceof('\\Pimcore\\Model\\Asset\\Image') %}</p>
			<p class="source-code">    {# print the image #}</p>
			<p class="source-code">{% elseif is instanceof('\\Pimcore\\Model\\Asset\\Video) %}</p>
			<p class="source-code">    {# print the video #}</p>
			<p class="source-code">{% endif %} </p>
			<p>This feature is important because you can alter the code flow so it either completes or doesn't complete a task based on the object type. In the previous example, we get an object that could be a video or an image, and we can display it properly based on the type. </p>
			<h3>Thumbnails</h3>
			<p>When you are working with <a id="_idIndexMarker485"/>images, printing them at the right size is fundamental. The Pimcore thumbnail feature<a id="_idIndexMarker486"/> helps a lot with templating. What we can do is to define the asset thumbnails from the administration; you should have already discovered this topic in <a href="B17073_05_ePub_RK.xhtml#_idTextAnchor093"><em class="italic">Chapter 5</em></a><em class="italic">, Exploring Objects and Classes</em>. Let's see this feature in action in a few simple steps:</p>
			<ol>
				<li value="1">Create a web page and assign a template to it.</li>
				<li>Go to <strong class="bold">Settings | Thumbnails | Image Thumbnails</strong>.</li>
				<li>Add a thumbnail configuration with the settings shown in the following screenshot: <div id="_idContainer103" class="IMG---Figure"><img src="image/Figure_8.05_B17073.jpg" alt="Figure 8.5: The thumbnail settings &#13;&#10;"/></div><p class="figure-caption">Figure 8.5: The thumbnail settings </p><p>We used<a id="_idIndexMarker487"/> the <strong class="bold">PNG</strong> format, and we set <strong class="bold">Scale by Height</strong> to <strong class="bold">200</strong>. Now the<a id="_idIndexMarker488"/> images that we will upload will have a proper thumbnail.</p></li>
				<li>Upload an image into the <strong class="bold">DAM</strong> section. Right-click in the <strong class="bold">Assets</strong> section of the menu and choose the <strong class="bold">Upload Files</strong> option:<div id="_idContainer104" class="IMG---Figure"><img src="image/Figure_8.06_B17073.jpg" alt="Figure 8.6: Uploading an image&#13;&#10;"/></div><p class="figure-caption">Figure 8.6: Uploading an image</p></li>
				<li>The<a id="_idIndexMarker489"/> demo example already ships a Pimcore logo image with ID 2. To get a thumbnail, you <a id="_idIndexMarker490"/>just have to get the asset by path or ID, then render it. The next snippet does that. Copy the snippet to the template:<p class="source-code">{% set asset = pimcore_asset(2) %}</p><p class="source-code">{{ asset.getThumbnail('MyThubnails').getHtml() | raw }}</p><p>The scripts get the thumbnail (the files generated at the first usage) for the image and print the image tag to the document.</p></li>
				<li>The next example gets an on-the-fly thumbnail without having a configuration defined. Copy this code to the template and see the result:<p class="source-code">{{ asset.getThumbnail({</p><p class="source-code">    width: 50,</p><p class="source-code">    format: 'png'</p><p class="source-code">}).getHtml() | raw }}</p><p>This example is quite similar to the previous one but uses settings that are not predefined by a thumbnail configuration. </p></li>
			</ol>
			<p>That <a id="_idIndexMarker491"/>whole list of functions covers the set of features that Pimcore offers to us out of the box. In addition, you<a id="_idIndexMarker492"/> will have all the default Symfony functions, which you can discover using the official documentation: https://symfony.com/doc/current/reference/twig_reference.html. </p>
			<p>But what should you do if neither Pimcore nor Symfony implements what you need? The easier solution, if we are talking about business logic, is to manipulate data inside the controller, and produce a clean output for the view. In some cases, we may need to implement some complex presentation logic that is hard to manage with Twig syntax. Moreover, we do not want to move this logic to the controller (where it will be easy to implement) because it will create coupling between the template and controller, and this is not what we want (do you remember when we talked about the benefits of a detached solution in <a href="B17073_01_ePub_RK.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a><em class="italic">, Introducing Pimcore</em>?). The solution to the problem of implementing complex presentation logic inside templates is provided in the next section where we will see how to add methods to the template engine and implement reusable helpers for our project. </p>
			<h3>Implementing your own template helper</h3>
			<p>In the previous section, we<a id="_idIndexMarker493"/> learned how to use template helpers to generate dynamic content. Now it is time to learn how to extend the template helper system and add your own function inside the set. In the next example, we will create a template helper that will display the current date and time in a given format. You may object that the Twig templating already offers a feature more or less like this, but remember that this is an example to explain the template helper extension, so it is better to keep our case study as simple as possible. Now, follow the next steps:</p>
			<ol>
				<li value="1">Create a file in <strong class="source-inline">/src/Templating/Helper/Timestamp.php</strong>.</li>
				<li>Then copy the following snippet inside the <strong class="source-inline">Timestamp.php</strong> file:<p class="source-code">&lt;?php</p><p class="source-code">  …</p><p class="source-code">class Timestamp  extends AbstractExtension</p><p class="source-code">{    </p><p class="source-code">    public function getFunctions()</p><p class="source-code">    {</p><p class="source-code">        return [</p><p class="source-code">            new TwigFunction('timestamp', [$this,             'timestamp']), </p><p class="source-code">        ]; </p><p class="source-code">    }    </p><p class="source-code">    public function timestamp(String $format)</p><p class="source-code">    {     </p><p class="source-code">       echo date($format);</p><p class="source-code">    }</p><p class="source-code">}</p><p><strong class="source-inline">getFunctions</strong> is a <a id="_idIndexMarker494"/>special function that lists all the helper extensions exposed from this extension. In our case, we have one function, called <strong class="source-inline">timestamp</strong>. This function computes a textual date representation based on the format that's received from the user. This function is mapped to a command called <strong class="source-inline">timestamp</strong> and can be used inside the template engine. For simplicity, I used for the helper name the function that computes the result, but you can choose your own. </p></li>
				<li>Register the snippet using the YAML configuration. Open the <strong class="source-inline">/</strong> <strong class="source-inline">config/services.yml</strong> file and add the following:<p class="source-code">Services: </p><p class="source-code">     …</p><p class="source-code">    App\Templating\Helper\Timestamp:</p><p class="source-code">        public: true</p><p class="source-code">        tags:</p><p class="source-code">            - { name: templating.helper, alias:             timestamp}</p></li>
				<li>Now the<a id="_idIndexMarker495"/> timestamp helper is registered inside the templating engine, so we can call it inside our Twig files. Copy the following piece of code:<p class="source-code">{{ timestamp("Y-m-d") }}</p><p>You will get something similar to <strong class="source-inline">2020-11-03</strong>.</p></li>
			</ol>
			<p>In this section, we learned how to add functionality to the template engine. This is good for reusing code and overcomes the Twig syntax limitations. In the next section, we will learn how to master routing rules to connect URLs with controllers. </p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor144"/>Mastering Routing and URLs</h2>
			<p>The last step of mastering custom pages is<a id="_idIndexMarker496"/> routing. We learned in <a href="B17073_04_ePub_RK.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating Documents in Pimcore</em>, that each document has a path that can be changed by the document editing interface. What if we are not working with documents, but with custom pages? In this section, we will learn about the options that Pimcore offers, which are the following:</p>
			<ul>
				<li><strong class="bold">Hardcoded Routes</strong>, as per Symfony standard.</li>
				<li><strong class="bold">Static Routes</strong>, configurable routes that can be changed by the admin interface.</li>
				<li><strong class="bold">Redirects</strong>, which can set HTTP redirection using a nice admin interface. For those who are not familiar with redirection, imagine it as a way to redirect the browser from one URL to another. This is very common when a page changes its URL <a id="_idIndexMarker497"/>or we have to move a website from one domain to another.</li>
			</ul>
			<p>Let's look at them in detail.</p>
			<h3>Hardcoded routes</h3>
			<p>To add a route, there isn't<a id="_idIndexMarker498"/> anything more complex than adding it to the configuration. These settings are contained inside the <strong class="source-inline">routing.yml</strong> file, and these rules follow the Symfony standard that you can find here: https://symfony.com/doc/current/routing.html.</p>
			<p>In the next code fragment, we can see an example of a rule:</p>
			<p class="source-code"><strong class="bold">custom_rule</strong>:</p>
			<p class="source-code">    <strong class="bold">path</strong>:      /custom/actionname/{parameter}</p>
			<p class="source-code">    <strong class="bold">controller</strong>: App\Controller\CustomController:myaction</p>
			<p class="source-code">    defaults:</p>
			<p class="source-code">     <strong class="bold">parameter</strong>: "my default value"</p>
			<p>The most relevant settings for our purpose are the following:</p>
			<ul>
				<li><strong class="source-inline">name</strong>: The rule has a name that must be unique; in our example, it is <strong class="source-inline">custom_rule</strong>.</li>
				<li><strong class="source-inline">path</strong>: This is the path that the rule is listening on; this can contain regular expressions and fetch parameters (in our case, <strong class="source-inline">parameter</strong>). </li>
			</ul>
			<p><strong class="source-inline">controller</strong>: This is the controller, including the action name; it supports the Symfony syntax. In the case that you write <strong class="source-inline">App\Controller\CustomController:myaction</strong>, you will activate <strong class="source-inline">myaction</strong> inside the <strong class="source-inline">CustomController</strong> controller of the application<strong class="source-inline">.</strong></p>
			<ul>
				<li>For each parameter, you can give a default value in the case the parameter was optional.</li>
			</ul>
			<p>Note that even if we used names with an understandable naming convention, you could define any rule as you want. The parameter inside the URL (or query path) is parsed and delivered to the action.</p>
			<p>If you prefer, the<a id="_idIndexMarker499"/> second option is to use routing as an annotation of the controller's actions. The equivalent of the previous rule is the following:</p>
			<p class="source-code">   /**</p>
			<p class="source-code">     * @Route("/custom/actionname/{parameter}", name="custom_     rule")</p>
			<p class="source-code">     */</p>
			<p class="source-code">    public function myaction(string $parameter)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // ...</p>
			<p class="source-code">    }</p>
			<p>The routing rule is bidirectional, so it can both produce a URL from the parameter values and give the parameters values from a URL. For example, consider that you have the <strong class="source-inline">/product/{id}</strong> rule for the product URL. If the user enters <strong class="source-inline">/product/5</strong> in the browser, the routing engine is able to tell you that the ID parameter is 5. On the other hand, you can ask the engine to generate a URL for the product with ID 5 and you will get back <strong class="source-inline">/product/5</strong>. In simple words, you can build the URL automatically from the rule name and parameter. This is easy to do with the path helper:</p>
			<p class="source-code">{{% pimcore_path('custom_rule', {'parameter': 67}); }}</p>
			<p>This will generate the full URL, <strong class="source-inline">/custom/actionname/67</strong>. </p>
			<h3>Configurable routes</h3>
			<p>The hardcoded rules used in the<a id="_idIndexMarker500"/> previous section are a good solution but are static, and you need access to the source code to understand or change them. The other solution offered by Pimcore is to define them visually, using the admin UI. Under <strong class="bold">Settings</strong> | <strong class="bold">Static Routes</strong>, you can find a table where you can enter all values of a routing rule (including the name, pattern, parameter names, and building rules). This makes rule management very easy and you can monitor how many rules you have and their configuration without accessing the source code. </p>
			<p>You can follow these steps to see this method in action:</p>
			<ol>
				<li value="1">Create a controller caller, <strong class="source-inline">CustomController</strong>.</li>
				<li>Add an action<a id="_idIndexMarker501"/> called <strong class="source-inline">data</strong> into the controller, similar to this:<p class="source-code">/**</p><p class="source-code">     * @Template() </p><p class="source-code">     */    </p><p class="source-code">    public function dataAction(Request $request)</p><p class="source-code">    {</p><p class="source-code">      $input=$request-&gt;get('data');</p><p class="source-code">      $content = "data to show $input";       </p><p class="source-code">      return array(</p><p class="source-code">           'content' =&gt; $content,</p><p class="source-code">      );    </p><p class="source-code">    }</p><p>This code will take the <strong class="source-inline">data</strong> parameter from the URL and will pass it to the view using the <strong class="source-inline">content</strong> variable.</p></li>
				<li>Create a view in the controller folder called <strong class="source-inline">data.html.</strong> <strong class="source-inline">Twig</strong> and add the following code inside:<p class="source-code">{{ content }}</p><p>This script will print the <strong class="source-inline">content</strong> variable.</p></li>
				<li>Open the <strong class="bold">Static Routes</strong> section, where we can see the <strong class="bold">Static Routes</strong> table:<div id="_idContainer105" class="IMG---Figure"><img src="image/Figure_8.07_B17073.jpg" alt="Figure 8.7: The Static Routes admin &#13;&#10;"/></div><p class="figure-caption">Figure 8.7: The Static Routes admin </p><p>In this editor, we can add rules. Each column lets you set the parameter, so enter the values in the previous figure using the following instructions:</p><ul><li><strong class="bold">Name</strong>: The name of the rule. Hardcoded case is needed for computing reverse URLs. Enter <strong class="source-inline">custom</strong>.</li><li><strong class="bold">Pattern</strong>: The <a id="_idIndexMarker502"/>regular expression that matches the URL managed by this rule. It can contain many placeholders, and each one is parsed and saved to a variable. Enter <strong class="source-inline">/\/custom_data\/(.*)\//</strong>. Note that <strong class="source-inline">\/</strong> is for escaping the <strong class="source-inline">/</strong> char in the regular expression, so a URL such as <strong class="source-inline">/custom_data/anything/</strong> will be matched. The parameter matched by the selector <strong class="source-inline">(.*)</strong> is the <strong class="source-inline">anything</strong> part.</li><li><strong class="bold">Controller</strong>: The controller that is used by the URL. Click on the cell and choose <strong class="source-inline">CustomController</strong>.</li><li><strong class="bold">Action</strong>: The action that is used by the URL. Click on it and choose <strong class="source-inline">data</strong>.</li><li><strong class="bold">Reverse</strong>: The rule that generates a URL from the rule name and parameter. Enter <strong class="source-inline">/custom_data/%data/</strong>. With this value, the routing engine will be able to generate the URL, <strong class="source-inline">/custom_data/value/</strong>, if you use use the editable, <strong class="source-inline">{{% pimcore_path('custom', {'data': 'value'}); }}</strong>.</li><li><strong class="bold">Variables</strong>: A comma-separated list that is used when fetching parameters. It is positional, so the first regex placeholder value takes the first value in the list, and so on. Enter <strong class="source-inline">data</strong>. This will mean that the value of <strong class="source-inline">(.*)</strong> will be named <strong class="source-inline">data</strong>.</li><li><strong class="bold">Defaults</strong>: A list with default data for optional parameters. Enter <strong class="source-inline">empty</strong>. In this case, if the parameter will be omitted, the parameter data will have the text <strong class="source-inline">empty</strong> as its value.</li></ul></li>
				<li>Open your browser and navigate to <a href="http://localhost/custom_data/myvalue">http://localhost/custom_data/myvalue</a>. You will see the <strong class="source-inline">myvalue</strong> parameter printed on the page.</li>
			</ol>
			<p>Similar to the previous<a id="_idIndexMarker503"/> example, we can generate a URL using a rule name and parameters with the template helper.</p>
			<p>The settings that you edited through the admin UI are saved in a PHP configuration file (<strong class="source-inline">var/config/staticroutes.php</strong>), so it's also possible to edit the code directly or save them by committing it to a Git repository. The next piece of code shows what we obtained by adding the previous rules:</p>
			<p class="source-code">&lt;?php </p>
			<p class="source-code">return [</p>
			<p class="source-code">    1 =&gt; [</p>
			<p class="source-code">        "id" =&gt; 1,</p>
			<p class="source-code">        "name" =&gt; "custom",</p>
			<p class="source-code">        "pattern" =&gt; "/\\/custom_data\\/(.*)?\\//",</p>
			<p class="source-code">        "reverse" =&gt; "/custom_data/%data/",</p>
			<p class="source-code">        "module" =&gt; NULL,</p>
			<p class="source-code">        "controller" =&gt; "@App\\Controller\\        CustomController:dataAction",</p>
			<p class="source-code">        "variables" =&gt; "data,",</p>
			<p class="source-code">        "defaults" =&gt; "empty",</p>
			<p class="source-code">    ]</p>
			<p class="source-code">];</p>
			<p>Configurable routes are very useful when you want to keep URL routing flexible, letting the user choose the paths at runtime. This is essential for matching specification changes from the <a id="_idIndexMarker504"/>customer about URLs (maybe due to the SEO requirement changes) without touching a single line of code.</p>
			<h3>Redirects</h3>
			<p>Redirects are a <a id="_idIndexMarker505"/>useful feature of Pimcore for directing the user to the correct pages – whether it be for marketing URLs, for redirects after a website's relaunch, or redirects for moved documents.</p>
			<p>The process for <a id="_idIndexMarker506"/>creating a redirect is very simple. Just follow these steps:</p>
			<ol>
				<li value="1">Navigate to <strong class="bold">System | Redirects</strong>. This menu opens a table similar to this one:<div id="_idContainer106" class="IMG---Figure"><img src="image/Figure_8.08_B17073.jpg" alt="Figure 8.8: The Redirects table &#13;&#10;"/></div><p class="figure-caption">Figure 8.8: The Redirects table </p></li>
				<li>Click the <strong class="bold">Add</strong> button. You will be prompted with the following popup:<div id="_idContainer107" class="IMG---Figure"><img src="image/Figure_8.09_B17073.jpg" alt="Figure 8.9: Adding a redirect&#13;&#10;"/></div><p class="figure-caption">Figure 8.9: Adding a redirect</p><p>The <strong class="bold">Type</strong> dropdown lets you choose the type of redirection, while <strong class="bold">Source</strong> and <strong class="bold">Target</strong> allow you to choose the mapping rule that redirects the source to the target URL.</p></li>
				<li>Enter <strong class="source-inline">/\/redirect\/(.*)/</strong> in the <strong class="bold">Source</strong> box and <strong class="source-inline">/custom_data/$1</strong> in the <strong class="bold">Target</strong> box, like in <em class="italic">Figure 8.9</em>.</li>
				<li>Open a<a id="_idIndexMarker507"/> browser and navigate to <a href="http://localhost/redirect/xxx/">http://localhost/redirect/xxx/</a>. You will be redirected to http://localhost/custom_data/xxx/ instead.</li>
			</ol>
			<p>In this section, we learned how to create custom web pages using the MVC model. In particular, we covered all the most important topics:</p>
			<ul>
				<li><strong class="bold">Controllers</strong>: We understood how controllers interact with request parameters and pass data to the view. Inside a controller, we can implement our business logic without any limitations.</li>
				<li><strong class="bold">Views</strong>: We learned how the template engine works and how we can use the helpers to implement presentation logic. </li>
				<li><strong class="bold">Routing and URLs</strong>: We learned how to manage the page's URL properly. We didn't limit ourselves to Symfony's standard routing but also covered static routes and redirect options. With all these options, we can choose the right solution based on our use case. The most important thing to know is that this wide set of options give us the power to solve any URL problems that we may face. </li>
			</ul>
			<p>In the next section, we will have a deep dive into Pimcore editables and we will learn how to combine them to get results without writing tons of lines of code. </p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor145"/>Using editables</h1>
			<p>As we <a id="_idIndexMarker508"/>introduced in <a href="B17073_04_ePub_RK.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating Documents in Pimcore</em>, Pimcore's editables are a set of visual components that can be used to enter information in the CMS page and are able to render the output to get the web page ready. You should remember the <strong class="source-inline">pimcore_input</strong> and <strong class="source-inline">pimcore_wysiwyg</strong> components; well, the good news is that Pimcore has a lot of components like that and covers most of your user needs. In this section, we will take a look at these.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">In the <strong class="bold">Editables</strong> list, we should have <strong class="bold">Area</strong> and <strong class="bold">Areablock</strong> components, but we won't discuss these in this chapter. These elements, in conjunction with <strong class="bold">Bricks</strong>, are the pillars of code reuse in Pimcore and will be covered in <a href="B17073_10_ePub_RK.xhtml#_idTextAnchor188"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating Pimcore Bricks</em>. The motivation is that without discovering what bricks are, the Area, Areablock, and Block components would be hard to understand.</p>
			<p>In the next sections, we will discover a list of the editables available. For each one, we will add a snippet of code to show you how to add it to your code and, for the more complex items, we also have some screenshots to explain the interaction. </p>
			<p>The process for testing an <a id="_idIndexMarker509"/>editable in your live Pimcore environment is the following:</p>
			<ol>
				<li value="1">Add a document into your CMS and link the document to a template. This process is well described in <a href="B17073_04_ePub_RK.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a><em class="italic">, Creating Documents in Pimcore</em>.</li>
				<li>Copy the snippets that you find in the following subsections. </li>
				<li>Enter the page editor and see how the component looks.</li>
				<li>Open page preview and see the data that is saved inside the editable. Remember that by using <strong class="source-inline">{{ pimcore_xxx('name') }}</strong>, you will print the data, but you can also set it to a variable using <strong class="source-inline">{% set var = pimcore_xxx('name') %}</strong> and then implement your own presentation logic.</li>
			</ol>
			<p>All these examples are contained in the <strong class="source-inline">editable.htm.twig</strong> template, used in <strong class="bold">The Editable Pages</strong> that you will find in the demo related to this chapter.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor146"/>Checkbox</h2>
			<p>The following editable<a id="_idIndexMarker510"/> adds a checkbox<a id="_idIndexMarker511"/> that can be checked by the page editor: </p>
			<p class="source-code">{{ pimcore_checkbox('myCheckbox') }} </p>
			<p>The value can be used to implement some rendering logic (that is, showing or not showing something basing on the <strong class="source-inline">myCheckbox</strong> value).</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor147"/>Date</h2>
			<p>This<a id="_idIndexMarker512"/> snippet <a id="_idIndexMarker513"/>adds a <strong class="source-inline">DateTime</strong> picker to the web page:</p>
			<p class="source-code">{{ pimcore_date('myDate', {</p>
			<p class="source-code">    'format': 'd.m.Y',</p>
			<p class="source-code">    'outputFormat': '%d.%m.%Y'</p>
			<p class="source-code">    })</p>
			<p class="source-code">}}</p>
			<p>When editing the page, you will see an editable <strong class="source-inline">DateTime</strong> picker like the one shown here: </p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/Figure_8.10_B17073.jpg" alt="Figure 8.10: The date picker in action&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10: The date picker in action</p>
			<p>During the <a id="_idIndexMarker514"/>page rendering, when you are not in edit mode, the function outputs the value that the <a id="_idIndexMarker515"/>user selected in the editor. This value can be displayed or be used for implementing presentation logic. </p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor148"/>Relation (Many-To-One)</h2>
			<p>This<a id="_idIndexMarker516"/> editable provides the<a id="_idIndexMarker517"/> opportunity to add a <strong class="source-inline">relation</strong> to an object. You can select which types of elements you want to add (for example, <strong class="source-inline">asset</strong> or <strong class="source-inline">object</strong>) and which subtypes. In the following example, we allowed only classes of type <strong class="source-inline">MyObject</strong>:</p>
			<p class="source-code">{{ pimcore_relation("myRelation",{</p>
			<p class="source-code">    "types": ["asset","object"],</p>
			<p class="source-code">    "subtypes": {</p>
			<p class="source-code">        "asset": ["video", "image"],</p>
			<p class="source-code">        "object": ["object"],</p>
			<p class="source-code">    },</p>
			<p class="source-code">    "classes": ["MyObject"]</p>
			<p class="source-code">}) }}</p>
			<p>This component, once added to the page, is displayed as a simple edit box where you can drag the items that you want to show, as in the following screenshot: </p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/Figure_8.11_B17073.jpg" alt="Figure 8.11: Relation configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11: Relation configuration</p>
			<p>Then the<a id="_idIndexMarker518"/> relation named <strong class="source-inline">myRelation</strong> will contain your selection value, and <a id="_idIndexMarker519"/>you can use it in the template for rendering data.</p>
			<p> In the following example, we will add a <strong class="bold">Link</strong> button that navigates to the selected item:</p>
			<p class="source-code">&lt;a href="{{ pimcore_relation("myRelation").getFullPath() }}"&gt;{{ "Go to" }}&lt;/a&gt;</p>
			<p>The previous snippet will display a link in the text. </p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor149"/>Relations (many-to-many relation)</h2>
			<p>This editable is like the <a id="_idIndexMarker520"/>many-to-one relation but allows you to select<a id="_idIndexMarker521"/> references to multiple other elements (such as documents, assets, and objects). The following snippet is the same as the previous use case, but because this editable has multiple references, we used a <strong class="source-inline">for</strong> loop to list all the selected options:</p>
			<p class="source-code">{% if editmode %}</p>
			<p class="source-code">    {{ pimcore_relations("objectPaths") }}</p>
			<p class="source-code">{% else %}</p>
			<p class="source-code">&lt;ul&gt;</p>
			<p class="source-code">    {% for element in pimcore_relations("objectPaths") %}</p>
			<p class="source-code">        &lt;li&gt;&lt;a href="{{ element.getFullPath }}"&gt;{{  element.getTitle  }}&lt;/a&gt;&lt;/li&gt;</p>
			<p class="source-code">    {% endfor %}</p>
			<p class="source-code">&lt;/ul&gt;</p>
			<p class="source-code">{% endif %}</p>
			<p>Now we can<a id="_idIndexMarker522"/> drag and drop multiple items:</p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/Figure_8.12_B17073.jpg" alt="Figure 8.12: Relation configuration &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.12: Relation configuration </p>
			<p>The result of the <a id="_idIndexMarker523"/>selection is shown in the following table:</p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/Figure_8.13_B17073.jpg" alt="Figure 8.13: Relations in edit mode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.13: Relations in edit mode</p>
			<p>With the data in our sandbox, we will have something like this:</p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/Figure_8.14_B17073.jpg" alt="Figure 8.14: The output of relations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.14: The output of relations</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor150"/>Image</h2>
			<p>This editable<a id="_idIndexMarker524"/> gives you a widget where you can upload an image. If you drag a file from <a id="_idIndexMarker525"/>the asset folder and drop it on the component, the image will be displayed. The advantages compared with the <strong class="source-inline">Relation</strong> component are that the image is easier to use and integrated with the thumbnail system.</p>
			<p>The next piece of code allows you to upload an image:</p>
			<p class="source-code">{{ pimcore_image("myImage", {</p>
			<p class="source-code">    "title": "Drag your image here",</p>
			<p class="source-code">    "thumbnail": "myThumbnails"</p>
			<p class="source-code">}) }}</p>
			<p>You can upload images or drag and drop them to the widget as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/Figure_8.15_B17073.jpg" alt="Figure 8.15: Image configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.15: Image configuration</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor151"/>Input</h2>
			<p><strong class="source-inline">Input</strong> allows the<a id="_idIndexMarker526"/> user to input<a id="_idIndexMarker527"/> a single line of text, and we can use the input for rendering HTML: </p>
			<p class="source-code">{{ pimcore_input("myHeadline") }}</p>
			<p>We used it in <a href="B17073_04_ePub_RK.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a><em class="italic">, Creating Documents in Pimcore</em>; there isn't anything more to add about this editable.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor152"/>Link</h2>
			<p>This is a<a id="_idIndexMarker528"/> component for<a id="_idIndexMarker529"/> rendering a link:</p>
			<p class="source-code">{{ pimcore_link('blogLink') }}</p>
			<p>The following screenshot shows the link in edit mode:</p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/Figure_8.16_B17073.jpg" alt="Figure 8.16 – The link component in edit mode &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 8.16 – The link component in edit mode </p>
			<p>The component comes out with two buttons: the folder that opens the selected link, and the edit button (pencil icon) that opens the settings form. The next screenshot shows the popup<a id="_idIndexMarker530"/> and the <a id="_idIndexMarker531"/>parameters available for a link:</p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/Figure_8.17_B17073.jpg" alt="Figure 8.17: Link configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.17: Link configuration</p>
			<p>Once completed, the result is an HTML link with the text and the destination provided.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor153"/>Select</h2>
			<p>This snippet <a id="_idIndexMarker532"/>adds a <strong class="source-inline">select</strong> component<a id="_idIndexMarker533"/> that lets the user choose between a set of items. The following snippet shows how it works:</p>
			<p class="source-code">{% if editmode %}</p>
			<p class="source-code">    {{ pimcore_select("myItem", {</p>
			<p class="source-code">            "store": [</p>
			<p class="source-code">                ["option1", "Option One"],</p>
			<p class="source-code">                ["option2", "Option 2"],</p>
			<p class="source-code">                ["option3", "Option 3"]</p>
			<p class="source-code">            ],</p>
			<p class="source-code">            "defaultValue" : "option1"</p>
			<p class="source-code">        }) }}</p>
			<p class="source-code">{% else %}    </p>
			<p class="source-code">    Your choice:{{ pimcore_select("myItem").getData() }}    </p>
			<p class="source-code">{% endif %}</p>
			<p>The <strong class="source-inline">store</strong> parameter contains a list of arrays. Each item is composed of an array of two elements: the first is the key, the second is the value. The <strong class="source-inline">defaultValue</strong> setting configures the default value for the selected list item.</p>
			<p>This is what is<a id="_idIndexMarker534"/> shown in<a id="_idIndexMarker535"/> edit mode:</p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/Figure_8.18_B17073.jpg" alt="Figure 8.18: Select configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.18: Select configuration</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor154"/>Multiselect</h2>
			<p>The <strong class="source-inline">Multiselect</strong> component<a id="_idIndexMarker536"/> is very similar to the <strong class="source-inline">Select</strong> one, but it allows <a id="_idIndexMarker537"/>multiple choices:</p>
			<p class="source-code">{{% pimcore_multiselect("categories", [</p>
			<p class="source-code">        "width" =&gt; 200,</p>
			<p class="source-code">        "height" =&gt; 100,</p>
			<p class="source-code">        "store" =&gt; [</p>
			<p class="source-code">            ["cars", "Cars"], </p>
			<p class="source-code">            ["motorcycles", "Motorcycles"],</p>
			<p class="source-code">            ["accessories", "Accessories"] </p>
			<p class="source-code">        ]</p>
			<p class="source-code">    ]) %}} </p>
			<p>This is what is shown in edit mode:</p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/Figure_8.19_B17073.jpg" alt="Figure 8.19: Multiselect configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.19: Multiselect configuration</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor155"/>Numeric</h2>
			<p>This <a id="_idIndexMarker538"/>editable is <a id="_idIndexMarker539"/>like the <strong class="source-inline">Input</strong> one, but specifically for numbers:</p>
			<p class="source-code">{{ pimcore_numeric('myNumber') }}</p>
			<p>This is what is shown in edit mode:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/Figure_8.20_B17073.jpg" alt="Figure 8.20: Numeric editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.20: Numeric editor</p>
			<p>And in edit mode, it returns the number chosen.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor156"/>Renderlet</h2>
			<p>The <strong class="source-inline">Renderlet</strong> is a<a id="_idIndexMarker540"/> special container that is able to render an object. It uses a <a id="_idIndexMarker541"/>controller and an action to process the selected items, and the resulting HTML is provided to the user:</p>
			<p class="source-code">{{</p>
			<p class="source-code">     pimcore_renderlet('myGallery', {</p>
			<p class="source-code">          "controller" : "App\\Controller\\          CustomController::galleryAction",</p>
			<p class="source-code">          "title" : "Drag an asset folder here to get a           gallery",</p>
			<p class="source-code">          "height" : 400</p>
			<p class="source-code">     })</p>
			<p class="source-code">}}</p>
			<p>In this case, we need some extra steps to test it. Follow the next steps:</p>
			<ol>
				<li value="1">Add a template file inside the <strong class="source-inline">/app/Resources/views/Default</strong> folder called <strong class="source-inline">gallery.php</strong>, and add the following code to render your data:<p class="source-code">{% if assets %}</p><p class="source-code">          {% for asset in assets %}</p><p class="source-code">               {% if asset is instanceof(</p><p class="source-code">               '\\Pimcore\\Model\\Asset\\Image') %}</p><p class="source-code">                &lt;div style="border: 1px solid red; </p><p class="source-code">                width:200px; padding 10px; </p><p class="source-code">                margin:10px;"&gt;</p><p class="source-code">                    {{ asset.getThumbnail(</p><p class="source-code">                      'MiniIcons').getHTML()|raw}}</p><p class="source-code">                &lt;/div&gt;</p><p class="source-code">               {% endif %}</p><p class="source-code">          {% endfor %}</p><p class="source-code">{% endif %}</p></li>
				<li>Add an<a id="_idIndexMarker542"/> action to the <a id="_idIndexMarker543"/>default controller with the following code:<p class="source-code">   /**</p><p class="source-code">     * @Template() </p><p class="source-code">     */    </p><p class="source-code">    public function galleryAction(Request $request)</p><p class="source-code">    {</p><p class="source-code">        $result=array();</p><p class="source-code">        if ('asset' === $request-&gt;get('type')) {</p><p class="source-code">            $asset = Asset::getById($request-&gt;get('id'));</p><p class="source-code">            if ('folder' === $asset-&gt;getType()) {</p><p class="source-code">                $result["assets"] = $asset-                &gt;getChildren();</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">        return $result;</p><p class="source-code">    }</p></li>
				<li>Then add a <strong class="source-inline">Renderlet</strong> editable into the page with the following configuration:<p class="source-code">{{</p><p class="source-code">     pimcore_renderlet('myGallery', {</p><p class="source-code">          "controller" : "App\\Controller\\          CustomController::galleryAction",</p><p class="source-code">          "title" : "Drag an asset folder here to get a           gallery",</p><p class="source-code">          "height" : 400</p><p class="source-code">     })</p><p class="source-code">}}</p><p>This configuration <a id="_idIndexMarker544"/>tells Pimcore to use the action <strong class="source-inline">galleryAction</strong> from<a id="_idIndexMarker545"/> the <strong class="source-inline">Default</strong> controller to render the data.</p></li>
				<li>Drag and drop a folder into <strong class="source-inline">Renderlet</strong>; this is what is shown in edit mode:</li>
			</ol>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/Figure_8.21_B17073.jpg" alt="Figure 8.21:Dragging a folder to Renderlet &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.21:Dragging a folder to Renderlet </p>
			<p>View the<a id="_idIndexMarker546"/> page as a <a id="_idIndexMarker547"/>normal user and see the result of your template:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/Figure_8.22_B17073.jpg" alt="Figure 8.22: Output with the sample template&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.22: Output with the sample template</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor157"/>Snippet</h2>
			<p>This <a id="_idIndexMarker548"/>component is <a id="_idIndexMarker549"/>used to include a document or snippet (a special document type) inside the document; this is useful for reusing scripts or pieces of the website on your page:</p>
			<p class="source-code">{{ pimcore_snippet("mySnippet", {"width": 250, "height": 100}) }} </p>
			<p>Once you have entered the code, this is how to add a snippet to the web page:</p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/Figure_8.23_B17073.jpg" alt="Figure 8.23:Configuration of the snippet control&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.23:Configuration of the snippet control</p>
			<p>And this is what you will see as a website user:</p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/Figure_8.24_B17073.jpg" alt="Figure 8.24: The output of the snippet control&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.24: The output of the snippet control</p>
			<p>In the previous screenshot, the text <strong class="bold">I'm the default template</strong> comes from the snippet.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor158"/>Table</h2>
			<p>This editable <a id="_idIndexMarker550"/>creates a table<a id="_idIndexMarker551"/> and lets the editor define the data inside of it. You can specify the default number of columns (<strong class="source-inline">cols</strong>) or rows (<strong class="source-inline">rows</strong>). You can also add a matrix of data (array of array) into the <strong class="source-inline">data</strong> parameter. The user will be able to add rows and columns by itself. Here is an example of the editable:</p>
			<p class="source-code">{{ pimcore_table("productProperties", {</p>
			<p class="source-code">    "width": 700,</p>
			<p class="source-code">    "height": 400,</p>
			<p class="source-code">    "defaults": {</p>
			<p class="source-code">        "cols": 3,</p>
			<p class="source-code">        "rows": 3,</p>
			<p class="source-code">        }</p>
			<p class="source-code">    })</p>
			<p class="source-code">}}</p>
			<p>This is the resulting editor interface:</p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/Figure_8.25_B17073.jpg" alt="Figure 8.25: Configuration of the table control&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.25: Configuration of the table control</p>
			<p>And this is the default rendering result:</p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/Figure_8.26_B17073.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.26: Table output</p>
			<p>The<a id="_idIndexMarker552"/> previous figure doesn't look nice because the component outputs a simple HTML table without <a id="_idIndexMarker553"/>any styles. Of course, based on your CSS theme, you can apply all the styles you want to make it coherent for your website design.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor159"/>Textarea</h2>
			<p>This is very similar to<a id="_idIndexMarker554"/> the <strong class="source-inline">Input</strong> editable but uses a <strong class="source-inline">Textarea</strong> component <a id="_idIndexMarker555"/>instead:</p>
			<p class="source-code">{{ pimcore_textarea("myTextarea",</p>
			<p class="source-code">   {"placeholder": "My Description" }) </p>
			<p class="source-code">}} </p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor160"/>Video</h2>
			<p>This editable<a id="_idIndexMarker556"/> allows you<a id="_idIndexMarker557"/> to insert movie assets into your page content. It is very similar to the image component but works with video. You will need to add the following snippet to activate it:</p>
			<p class="source-code">  {{ pimcore_video('campaignVideo', {</p>
			<p class="source-code">        width: 700,</p>
			<p class="source-code">        height: 400</p>
			<p class="source-code">    }) }}</p>
			<p>Then you will be able to define the <a id="_idIndexMarker558"/>source (local assets or an external link) and fine-tune some options:</p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/Figure_8.27_B17073.jpg" alt="Figure 8.27: Video control&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.27: Video control</p>
			<p>On the <a id="_idIndexMarker559"/>web page, you will see it inside a video player as in the following screenshot:</p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/Figure_8.28_B17073.jpg" alt="Figure 8.28: Video control output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.28: Video control output</p>
			<p>The <a id="_idIndexMarker560"/>video editable is a very powerful solution for letting the user be autonomous in terms of uploading and <a id="_idIndexMarker561"/>managing videos without asking for help from a developer. </p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor161"/>WYSIWYG</h2>
			<p>This WYSIWYG editor<a id="_idIndexMarker562"/> is <a id="_idIndexMarker563"/>used for entering HTML content. In the next piece of code, there is a sample of editable usage:</p>
			<p class="source-code">{{  pimcore_wysiwyg("specialContent")     }}</p>
			<p>We used it in <a href="B17073_04_ePub_RK.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a><em class="italic">, Creating documents in Pimcore</em>; there isn't anything more to add.</p>
			<p>In this section, we saw an overview of the most important editables. Using them as base components for the web pages that we create gives us absolute power to customize any aspect of our HTML. Moreover, with this large set of options, cases when you need something more than adding input for the user and then templating the data that you collect are very few. Generally speaking, you do not have to code to satisfy the customer's needs but just template the pages.</p>
			<p>For more information about editables, you can consult the official documentation at the following URL: <a href="https://pimcore.com/docs/pimcore/current/Development_Documentation/Documents/Editables/">https://pimcore.com/docs/pimcore/current/Development_Documentation/Documents/Editables/</a>.</p>
			<p>In the next section, we will discover the usage of blocks, which are simple tools that help to create dynamic pages.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor162"/>Using blocks</h1>
			<p>Pimcore blocks are a very <a id="_idIndexMarker564"/>clever system for iterating parts of a page. For example, if you have a standard page composed of horizontal bands or titled paragraphs, you can define a piece of HTML that explains how each item should look and let the user add as many items as they want. As another example, you can define a block composed of an H2 title and text, and this will create many titled paragraphs on your web page. Alternatively, you could use a block with an image and create a gallery iterating the blocks. Moreover, you can also manage the visibility of blocks by scheduling their publication.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor163"/>Regular Blocks</h2>
			<p><strong class="source-inline">pimcore_iterate_block</strong> can return the list of blocks. All the code that is wrapped inside the <strong class="source-inline">for</strong> loop can be replicated as many times as the user wants.</p>
			<p>The difference between a <a id="_idIndexMarker565"/>block iteration and a regular <strong class="source-inline">for</strong> loop is that in the case of a<a id="_idIndexMarker566"/> block, the user defines how many items they want, and all the data input inside the editables is persisted. </p>
			<p>The syntax for defining a block is very easy and we can see in the next snippet the usage of the previously mentioned functions:</p>
			<p class="source-code">{% for i in <strong class="bold">pimcore_iterate_block</strong>(<strong class="bold">pimcore_block</strong>('block name')) %}</p>
			<p class="source-code">    My content</p>
			<p class="source-code">{% endfor %}</p>
			<p>In the next example, we will see a block in action that iterates over a small template with a header and text that builds a web page with titled paragraphs:</p>
			<ol>
				<li value="1">Create a page and link the page with a template, as we have done many times before. If you have any doubts, just refer to <a href="B17073_04_ePub_RK.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a><em class="italic">, Creating Documents in Pimcore</em>.</li>
				<li>Copy the following snippet into the template:<p class="source-code">{% for i in pimcore_iterate_block(pimcore_block('contentblock')) %}</p><p class="source-code">    &lt;h2&gt;{{ pimcore_input('title') }}&lt;/h2&gt;</p><p class="source-code">    &lt;p&gt;{ pimcore_wysiwyg('content') }}&lt;/p&gt;</p><p class="source-code">{% endfor %}</p></li>
				<li>The template part is composed of a <strong class="source-inline">title</strong>, surrounded by a <strong class="source-inline">H2</strong> tag and a <strong class="source-inline">paragraph</strong>. In the next screenshot, you will see the result of our code in edit mode before adding the blocks:<div id="_idContainer127" class="IMG---Figure"><img src="image/Figure_8.29_B17073.jpg" alt="Figure 8.29: Adding a block to the list&#13;&#10;"/></div><p class="figure-caption">Figure 8.29: Adding a block to the list</p></li>
				<li>Go to the page editor and click the green <strong class="bold">+</strong> icon to add one block to the block list. Now the block is visible in the editor and you will be able to enter data. You can add as many blocks as you want; you will be able to edit them one by one in the backend. </li>
				<li>Now enter data<a id="_idIndexMarker567"/> into the editables. In this example, I put <strong class="bold">My first item</strong> as<a id="_idIndexMarker568"/> the title and <strong class="bold">value</strong> inside the long text. The output will be something like the following screenshot:<div id="_idContainer128" class="IMG---Figure"><img src="image/Figure_8.30_B17073.jpg" alt="Figure 8.30: Editing the element in the block list&#13;&#10;"/></div><p class="figure-caption">Figure 8.30: Editing the element in the block list</p></li>
				<li>Iterate this for as many blocks as you like. <p>The final result will look like this on the web page:</p></li>
			</ol>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/Figure_8.31_B17073.jpg" alt="Figure 8.31: The result after adding more elements&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.31: The result after adding more elements</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor164"/>Scheduled Blocks</h2>
			<p>The scheduled block<a id="_idIndexMarker569"/> component is very similar to the block, but it has the option to<a id="_idIndexMarker570"/> define an expiration date for the contents. The syntax is the same, as you can see in the next snippet:</p>
			<p class="source-code">{% for i in pimcore_iterate_block(pimcore_scheduledblock('block')) %}</p>
			<p class="source-code">    &lt;h2&gt;{{ pimcore_input('blockinput') }}&lt;/h2&gt;</p>
			<p class="source-code">    &lt;p&gt;{{ pimcore_image('myimage') }}&lt;/p&gt;</p>
			<p class="source-code">{% endfor %}</p>
			<p>The process for testing this snippet is exactly the same as the standard block that we saw in the previous section. </p>
			<p>In the next screenshot, we will see the edit mode for the scheduled block, where we have a <strong class="source-inline">DateTime</strong> picker near the green <strong class="bold">+</strong> icon that allows the user to define when the content will expire:</p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/Figure_8.32_B17073.jpg" alt="Figure 8.32 – Editing a scheduled block&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.32 – Editing a scheduled block</p>
			<p>The block engine is a <a id="_idIndexMarker571"/>very powerful system that allows a lot of opportunities for making <a id="_idIndexMarker572"/>dynamic pages easily editable by the user. We will appreciate this feature more in <a href="B17073_10_ePub_RK.xhtml#_idTextAnchor188"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating Pimcore Bricks</em>, when we will use blocks in conjunction with bricks to create fully dynamic templates. Anyway, what we have learned so far is very interesting: we can give the user the opportunity to manage a repetitive template with a well-structured approach.</p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor165"/>Summary</h1>
			<p>In this chapter, we learned all the information needed for creating a custom CMS page. We gained an understanding of the MVC model, and we had a deep dive into the templating engine of Pimcore, discovering all the helpers and how to create our own. We also learned how to write backend code in the controller and make it work by defining routing rules. We saw that there are many ways to manage URLs in Pimcore (Hardcoded, Static Route, and Redirect) and they cover all the use cases for a website. Then we had a complete overview of editables, which left us able to master any custom web page just by templating it. Finally, we discovered the block system that allows the iteration of pieces of a template by giving the user the opportunity to manage repetitive patterns in web pages.</p>
			<p>This was an intense chapter that provided us with full knowledge of custom CMS pages. What we learned here will be very useful in the next chapter, <a href="B17073_09_ePub_RK.xhtml#_idTextAnchor166"><em class="italic">Chapter 9</em></a>, Configuring Entities and <em class="italic">Rendering Data</em>, where we will use it to render web pages for implementing a simple blog engine.</p>
		</div>
	</body></html>