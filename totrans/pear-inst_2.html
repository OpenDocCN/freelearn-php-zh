<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Mastering PHP Software Management with the PEAR Installer"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Mastering PHP Software Management with the PEAR Installer</h1></div></div></div><p>In this chapter, we learn how to turn PHP software into distributable PEAR packages. In September 2005, version 1.4.0 of the PEAR installer was released. This release was a milestone, marking the transformation of PEAR from a niche-market tool for installing small libraries distributed by<code class="literal"> pear.php.net</code> to a full-fledged application installation tool. For the first time, it is possible to distribute large-scale applications, and even complete web-based database-intensive applications can be installed and configured in one step.</p><p>The PEAR installer now can be used to install traditional web-based applications like phpMyAdmin and non-PEAR libraries like the popular Smarty template engine (both happen to be installable through the <a class="ulink" href="http://pearified.com"> http://pearified.com</a> PEAR channel). Two of the primary design goals of the PEAR installer are to:<a id="id30" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Make it possible to distribute application development across multiple development teams (i.e. stop re-inventing the wheel)</li><li class="listitem" style="list-style-type: disc">Prevent conflicting packages from overwriting each other</li></ul></div><p>All of this magic is made possible by the<code class="literal"> package.xml</code> file format.<code class="literal"> package.xml</code> is the heart and soul of the PEAR installer, and in order to take full advantage of PEAR's power, you need to understand its structure. Contained in<code class="literal"> package.xml</code> is a list of files to be installed, information used by the PEAR installer to distinguish between different packages and releases, and information that is useful to humans, such as a description of what the package is and a changelog. This file is in fact all the PEAR installer needs to properly install software. The PEAR installer also uses the information in<code class="literal"> package.xml</code> to create an installable archive in either<code class="literal"> .tar</code> format or compressed<code class="literal"> .tar</code> (<code class="literal">.tgz</code>) using the<code class="literal"> pear package</code> command.<a id="id31" class="indexterm"/>
</p><p>The PEAR installer is not limited to installation of local files, and in fact is designed to communicate over the Internet with<span class="strong"><strong> PEAR channel servers</strong></span>. What is a channel server? A channel server provides downloadable releases for each package, and web service interfaces to meta-information about those packages and releases through XML-RPC, REST, or SOAP. Channels are discussed in depth in <a class="link" href="ch05.html" title="Chapter 5. Releasing to the World: PEAR Channels">Chapter 5</a>. Now that PEAR 1.4.0+ and packages like Chiara_PEAR_Server ( <a class="ulink" href="http://pear.chiaraquartet.net/index.php?package=Chiara_PEAR_Server">http://pear.chiaraquartet.net/index.php?package=Chiara_PEAR_Server</a>) are available, it is simple to set up your own PEAR channel server and distribute libraries and applications with all of the sophistication you've come to expect from the<code class="literal"> pear</code> command.<a id="id32" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip09"/>Tip</h3><p><span class="strong"><strong>CLI versus Web/Gtk2 Installer</strong></span></p><p>Some of you reading this have probably installed the Web front end (PEAR_Frontend_Web package from<code class="literal"> pear.php.net</code>) or the Gtk2 front end (PEAR_Frontend_Gtk2 package from<code class="literal"> pear.php.net</code>). If so, then you have probably noticed that installing packages from other channels is even simpler, as the end user simply needs to choose the channel to install from, and all packages are listed with the most recent version and available upgrades.</p><p>We will be working with the command-line (CLI) front end to the PEAR installer in the next few chapters, as a much greater level of sophistication is available than what is possible through the Web front end, which is designed more for end users of PEAR packages than it is for developers of PEAR packages. At the time of writing this chapter, the Gtk2 front end is far more sophisticated than the Web installer, and is worth using if you are running PHP 5.1.0 or newer.</p></div><p>For example, if your server is <code class="literal"> pear.example.com</code>, and you release a package named <code class="literal">Foo</code>, the only thing your users need to type in order to install your package is:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear channel-discover pear.example.com
$ pear install pear.example.com/Foo
</strong></span>
</pre></div><p>However, the most dynamic and important feature of the PEAR installer is the sophisticated way in which it handles dependencies on other packages, on PHP version, on PHP extensions, and on the system architecture. Through very simple syntax in<code class="literal"> package.xml</code>, incredibly complex dependency scenarios can be easily and securely managed.<a id="id33" class="indexterm"/>
</p><p>Before we can get started with the actual work of creating our own packages, it is important to understand the core concepts behind the design of the PEAR installer and how you will need to shape your software design to best utilize its strengths.</p><div class="section" title="Distributing Libraries and Applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec01"/>Distributing Libraries and Applications</h1></div></div></div><p>The most important thing to understand is how the PEAR installer actually installs files. Most PHP developers distribute their applications as unzip-and-go archives. As such, we tend to assume that files will be in the exact same relative locations on the end user's machine that they are on our development machine. PEAR, however, is designed to be far more flexible than this.<a id="id34" class="indexterm"/>
</p><p>For instance, it is common for shared web hosts to install a global copy of PEAR, but users can also install local copies and use the<code class="literal"> include_path</code> from<code class="literal"> php.ini</code> to choose local packages when available and global ones when they are not. In order to make this flexibility possible, PEAR groups and installs files by their type or file<span class="emphasis"><em> role</em></span>.<a id="id35" class="indexterm"/>
</p><p>Each file role has a corresponding configuration entry that defines the location at which all files of that file role will be installed. For instance, the php file role has a configuration variable named<code class="literal"> php_dir</code> that defines the directory into which all PHP files are installed, the data file role has a configuration variable named<code class="literal"> data_dir</code>, and so on.<a id="id36" class="indexterm"/>
</p><p>This is a radical break from the traditional unzip-and-go philosophy, as it allows users to configure the installation locations in any way they desire on their own machine. This also means that the use of clever constructs to locate installed files such as<code class="literal"> dirname(__FILE__)</code> are dangerous ways to code in a PEAR package. Fortunately, there are other clever ways around this that are even more flexible and secure.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip10"/>Tip</h3><p><span class="strong"><strong>PEAR Configuration</strong></span></p><p>To retrieve all configuration variables and their values, use the<code class="literal"> config-show</code> command. Configuration variables that correspond to file roles generally have<code class="literal"> _dir</code> in their name, such as<code class="literal"> doc_dir</code>, and<code class="literal"> php_dir</code>.</p></div><p>This also changes the development process slightly: instead of testing by running code right out of the development directory, the code should first be installed via its<code class="literal"> package.xml</code> file and tested as the PEAR equivalent of unzip-and-go. For this reason, the most common<code class="literal"> pear</code> command to be used is:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear up -f package.xml
</strong></span>
</pre></div><p>or</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear upgrade --force package.xml
</strong></span>
</pre></div><p>This command allows the "upgrade" from (for instance) PEAR version 1.5.0a1 to PEAR version 1.5.0a1 when a bug has been fixed or a new feature has been added. This command in actuality facilitates rapid development by allowing one to quickly replace the existing files within a version after having made changes without requiring a bump in version number. In other words, if we had to change the version every time a minor change was made on a development machine, this would be onerous. The<code class="literal"> --force</code> option circumvents this problem.<a id="id37" class="indexterm"/>
</p><p>Although managing installations using PEAR may seem to be more complicated on the surface, a quick investigation of<span class="emphasis"><em> useful</em></span> unzip-and-go packages show that many unzip-and-go packages actually require a large amount of manual configuration that could easily be supplanted by the automated features of the PEAR installer. In short, once you get used to it, you'll wonder how you ever developed in PHP without using the PEAR installer to manage your packages.</p><div class="section" title="Differences between Libraries and Applications from the Installer's Point of View"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec01"/>Differences between Libraries and Applications from the Installer's Point of View</h2></div></div></div><p>The acronym<span class="strong"><strong> PEAR</strong></span>means <span class="strong"><strong>P</strong></span><span class="emphasis"><em>HP</em></span><span class="strong"><strong>E</strong></span><span class="emphasis"><em>xtension</em></span>and <span class="strong"><strong>A</strong></span><span class="emphasis"><em>pplication</em></span> <span class="strong"><strong>R</strong></span><span class="emphasis"><em>epository</em></span>, but until PEAR version 1.4.0, support for applications was minimal. Most PEAR packages are libraries designed to be integrated into other external applications. The initial design of the PEAR installer supported this model very effectively, but did not provide all of the customization that applications need in order to be installed and configured effectively. One of the primary motivations for the new features introduced in PEAR version 1.4.0 was better support for application installation.<a id="id38" class="indexterm"/>
</p><p>In spite of the obvious differences in functionality between libraries and complete applications, from the installer's point of view, libraries and applications don't need to be handled very differently. Both are distributed using<code class="literal"> package.xml</code>, both are stored in the registry in the same way, and the same rules of versioning and dependencies are applied. In fact, this is one of PEAR installer's greatest strengths, in that it both follows the<span class="strong"><strong> KISS</strong></span> (<span class="strong"><strong>Keep It Simple, Stupid</strong></span>) principle and leaves application design to the way<code class="literal"> package.xml</code> is used. Consequently, a thorough understanding of the design of<code class="literal"> package.xml</code> is necessary to use its capabilities to the fullest for any application or library package.</p><p>New features designed to simplify application development include:<a id="id39" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Customizable file roles</li><li class="listitem" style="list-style-type: disc">Customizable file tasks</li><li class="listitem" style="list-style-type: disc">More advanced dependency possibilities and pre-download dependency resolution</li><li class="listitem" style="list-style-type: disc">The ability to bundle several packages into a single tarball</li><li class="listitem" style="list-style-type: disc">Static dependencies based on a single release rather than an abstract package</li></ul></div><p>After reading this list, if your head is spinning or you're seeing spots resembling question marks, fear not — all of these features will be simply and extensively explored in the next few sections.</p><p>Before we launch into the new features, lets take a closer look at some basic principles that provide the foundation for best use of the new features.</p></div></div></div>
<div class="section" title="Using Versioning and Dependencies to Help Track and Eliminate Bugs"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec02"/>Using Versioning and Dependencies to Help Track and Eliminate Bugs</h1></div></div></div><p>Versioning and dependencies are two features that every enterprise-level distribution system must support at a very high level. With both simple dependencies and advanced versioning features, the PEAR installer makes depending on external packages safer and easier than ever before.<a id="id40" class="indexterm"/>
</p><div class="section" title="Versioning"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec02"/>Versioning</h2></div></div></div><p>The most basic foundation of the PEAR installer is the concept of versioning. Versioning should be familiar to all of us in the form of "Software package version X.Y.Z" such as "PHP version 5.1.4". The basic idea is that older versions of software have a lower number. In other words, PHP version 4.0.6 is older than PHP version 4.1.1beta1, which is older than PHP version 4.1.1.<a id="id41" class="indexterm"/>
</p><p>How does versioning help track and eliminate bugs? Imagine this scenario:</p><p>You are working on a Wiki, and allowing users to grab the source from your FTP site at any time and use it themselves. One of them finds a bug and reports, "It is doing this weird thing where it tries to delete all of my files." The user can't remember when he or she downloaded the source, as he or she had to restore from a backup and the file modification time has been reset. At this point, the only way to figure out the problem and whether it still exists in the current source is to grab the user project and compare it to the current source line by line. At best, this is tedious and at worst completely impossible.</p><p>Taking a fluid, ever-changing software project and making releases at specific times and assigning them a version number makes it much simpler for an end user to report a bug. The end user can simply say "Version 1.2.3 of your software package does this weird thing where it tries to delete all of my files" and you as the developer can ask the user to try the latest version, or the current development copy, making bug fixing much simpler.</p><p>In addition, it is possible to maintain two branches of the same code, a stable version, and an unstable version with innovative new features. There are many subtle ways of using versioning to provide more information about a software release. For instance, the Linux kernel versioning system is described in detail at <a class="ulink" href="http://en.wikipedia.org/wiki/Linux_kernel#Version_Numbering"> http://en.wikipedia.org/wiki/Linux_kernel#Version_Numbering</a>. In this case, one of the decimal places is used to denote the stability of the kernel, such that it is possible to have version 1.2.9 released after 1.3.0.<a id="id42" class="indexterm"/>
</p><p>The PEAR installer takes a more explicit approach to versioning. Rather than providing stability information inside the version number, a separate field in<code class="literal"> package.xml, &lt;stability&gt;</code>, is used to designate the stability of the code. This does not preclude the use of Linux-style versioning, or any other versioning scheme, as long as the basic premise (1.3.0 is always newer than 1.2.9) still holds.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip11"/>Tip</h3><p><span class="strong"><strong>Versioning Time versus Absolute Time</strong></span></p><p>PEAR's simple versioning rules can actually be kind of confusing in the real world. The PEAR installer doesn't particularly care when a version was released in real-world time but about its stability and version number.</p><p>This can mean that, for instance, PEAR 1.3.6 (stable) released on August 18, 2005 is older than PEAR 1.4.0a1 (alpha) released on February 26, 2005 because 1.3.6 is less than 1.4.0. Absolute time has nothing to do with versioning time.</p><p>The end user can tell the PEAR installer through a configuration variable called<code class="literal"> preferred_state</code> how stable packages must be in order to be installed. In our hypothetical example, if this variable is set to<code class="literal"> stable</code> or to<code class="literal"> beta</code>, then PEAR 1.3.6 would be installed instead of 1.4.0a1; otherwise for values less stable than beta (<code class="literal">alpha, devel</code>, and<code class="literal"> snapshot</code>) version 1.4.0a1 would be installed, even though version 1.3.6 was released months later, because 1.4.0 is always<span class="emphasis"><em> newer</em></span> than 1.3.6 in<span class="emphasis"><em> versioning time</em></span>.</p></div></div><div class="section" title="PEAR Packaging and Strict Version Validation"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec03"/>PEAR Packaging and Strict Version Validation</h2></div></div></div><p>The PEAR package repository at <a class="ulink" href="http://pear.php.net"> pear.php.net</a> uses a strict versioning protocol. All package versions are of format X.Y.Z, as in "1.3.0". The first digit (X) is used to describe the <span class="strong"><strong> Applications Program Interface</strong></span> (<span class="strong"><strong>API</strong></span>) version, the second digit (Y) is used to describe the feature set version, and the third digit (Z) is used to describe the bugfix revision level. As examples, here are some version numbers and their meaning:<a id="id43" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Sample PEAR version numbers and their meanings</p>
</th><td class="auto-generated"> </td></tr><tr><th style="text-align: left" valign="bottom">
<p>Version Number</p>
</th><th style="text-align: left" valign="bottom">
<p>Meaning</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>1.0.0</p>
</td><td style="text-align: left" valign="top">
<p>Stable API version 1.0, initial stable release of package</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>0.4.5</p>
</td><td style="text-align: left" valign="top">
<p>Unstable (developing) API, 4th feature set design, 5th bugfix release of this feature set</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>2.4.0</p>
</td><td style="text-align: left" valign="top">
<p>Stable API version 2.0, 4th feature set design, initial release of this new feature set</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1.3.4</p>
</td><td style="text-align: left" valign="top">
<p>Stable API version 1.0, 3rd set of new features since the initial stable release, 4th bugfix release of this feature set</p>
</td></tr></tbody></table></div><p>At installation time, this information is irrelevant: The PEAR installer will install anything it is given, including version numbering schemes like 24.25094.39.430 or 23.4.0-r1 and so on. However, the validation used when packaging up a package via:<a id="id44" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear package
</strong></span>
</pre></div><p>is much stricter than that used when downloading a PEAR package. In order to assist developers trying to meet the PEAR package repository's strict coding standards, there are a set of validation routines within the PEAR package located in<code class="literal"> PEAR/Validate.php</code> that check a number of important aspects of the PEAR coding standards, and emit warnings for anything that does not comply. For instance, version 1.0.0 must be stable (and not<code class="literal"> devel, alpha</code>, or<code class="literal"> beta</code> stability), and so the following snippet from a<code class="literal"> package.xml</code> will cause a warning:</p><div class="informalexample"><pre class="programlisting">&lt;version&gt;
&lt;release&gt;1.0.0&lt;/release&gt;
&lt;api&gt;1.0.0&lt;/api&gt;
&lt;/version&gt;
&lt;stability&gt;
&lt;release&gt;beta&lt;/release&gt;
&lt;api&gt;beta&lt;/api&gt;
&lt;/stability&gt;
</pre></div><p>Specifically, it would look something like this:</p><p><span class="strong"><strong>$ pear package</strong></span></p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>Warning: Channel validator warning: field "version" - version 1.0.0 probably should not be alpha or beta
</strong></span>
</pre></div><p>Although this is extremely helpful for anyone who wishes to adhere to PEAR's strict coding standards, in some cases this warning is not helpful, but is instead annoying or distracting. For instance, a private project may wish to use the Linux versioning scheme. Fortunately, there is a way to control the way custom validation routines are handled at the packaging, download, or installation phases of the PEAR installer. By extending the<code class="literal"> PEAR_Validate</code> class located in<code class="literal"> PEAR/Validate.php</code>, a special validator can be created using object-oriented inheritance. To activate it, the validator must be associated with a channel. Although this process will be discussed in detail in <a class="link" href="ch05.html" title="Chapter 5. Releasing to the World: PEAR Channels">Chapter 5</a>, here is a simple example.<a id="id45" class="indexterm"/>
</p><p>The developers of PHP extensions at<code class="literal"> pecl.php.net</code> have a much looser version validation system, and there is a wide variation of versioning accepted, from a two-digit 1.0 to the 7.5.00.26 used by the maxdb package ( <a class="ulink" href="http://pecl.php.net/maxdb">http://pecl.php.net/maxdb</a>) to mirror versioning used by MySQL's MaxDB database. As such, <a class="ulink" href="http://pecl.php.net"> pecl.php.net</a> is a separate channel from <a class="ulink" href="http://pear.php.net"> pear.php.net</a>, and in its channel definition file<code class="literal"> channel.xml</code> (also discussed in depth in <a class="link" href="ch05.html" title="Chapter 5. Releasing to the World: PEAR Channels">Chapter 5</a>) defines a channel validator:<a id="id46" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;validatepackage version="1.0"&gt;PEAR_Validator_PECL&lt;/validatepackage&gt;
</pre></div><p>This particular channel validator is distributed with the PEAR installer in the file<code class="literal"> PEAR/Validator/PECL.php</code>. This file is both the perfect example of a customized channel validator and the simplest, so here it is, in all of its glory:</p><div class="informalexample"><pre class="programlisting">&lt;?php
/**
* Channel Validator for the pecl.php.net channel
*
* PHP 4 and PHP 5
*
* @category pear
* @package PEAR
* @author Greg Beaver &lt;cellog@php.net&gt;
* @copyright 1997-2005 The PHP Group
* @license http://www.php.net/license/3_0.txt PHP License 3.0
* @version CVS: $Id: PECL.php,v 1.3 2005/08/21 03:31:48 cellog
Exp $
* @link http://pear.php.net/package/PEAR
* @since File available since Release 1.4.0a5
*/
/**
* This is the parent class for all validators
*/
require_once 'PEAR/Validate.php';
/**
* Channel Validator for the pecl.php.net channel
* @category pear
* @package PEAR
* @author Greg Beaver &lt;cellog@php.net&gt;
* @copyright 1997-2005 The PHP Group
* @license http://www.php.net/license/3_0.txt PHP License 3.0
* @version Release: @package_version@
* @link http://pear.php.net/package/PEAR
* @since Class available since Release 1.4.0a5
*/
class PEAR_Validator_PECL extends PEAR_Validate
{
function validateVersion()
{
if ($this-&gt;_state == PEAR_VALIDATE_PACKAGING) {
$version = $this-&gt;_packagexml-&gt;getVersion();
$versioncomponents = explode('.', $version);
$last = array_pop($versioncomponents);
if (substr($last, 1, 2) == 'rc') {
$this-&gt;_addFailure('version', 'Release Candidate versions must have ' .
'upper-case RC, not lower-case rc');
return false;
}
}
return true;
}
function validatePackageName()
{
$ret = parent::validatePackageName();
if ($this-&gt;_packagexml-&gt;getPackageType() == 'extsrc') {
if (strtolower($this-&gt;_packagexml-&gt;getPackage()) !=
strtolower($this-&gt;_packagexml-&gt;getProvidesExtension())) {
$this-&gt;_addWarning('providesextension', 'package name "' .
$this-&gt;_packagexml-&gt;getPackage() . '" is different from extension name "' .
$this-&gt;_packagexml-&gt;getProvidesExtension());
}
}
return $ret;
}
}
?&gt;
</pre></div><p>This class simply overrides the strict version validation of its parent, and then adds in a PECL-specific check to see if an extension package is claiming to distribute a differently-named extension from the package name. In addition, it checks for a release candidate with (lower-case)<code class="literal"> rc</code> in the version, as PHP's<code class="literal"> version_compare()</code> function ( <a class="ulink" href="http://www.php.net/version_compare">http://www.php.net/version_compare</a>) treats this very differently from versions containing (upper-case)<code class="literal"> RC</code>.<a id="id47" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip12"/>Tip</h3><p><span class="strong"><strong>Why are pear.php.net and pecl.php.net Separate Channels?</strong></span></p><p>In earlier PEAR versions, the<code class="literal"> pear</code> command was used to install both PEAR packages and <span class="strong"><strong> PHP Extension Community Library</strong></span> (<span class="strong"><strong>PECL</strong></span>) packages. This was changed in version 1.4.0 for a number of reasons. First of all, the developers at <a class="ulink" href="http://pear.php.net"> pear.php.net</a> are developing packages written in PHP. Developers at <a class="ulink" href="http://pecl.php.net"> pecl.php.net</a> are developing packages written in C that are compiled to shared<code class="literal"> .dll</code> or<code class="literal"> .so</code> files as internal components (extensions) of PHP itself. There are intrinsic differences in the way PEAR-style packages are installed and maintained compared to the PECL-style packages.</p><p>One of these differences is the importance given to proper versioning. PECL and PHP extensions can't co-exist with conflicting extensions; only one can run at a time. PEAR packages do not have this restriction, as several different versions of a PEAR package can co-exist and be loaded interchangeably through the<code class="literal"> include_path</code>, so versioning becomes much more important.</p><p>In addition, because of file locking, an extension that is loaded into memory cannot be uninstalled, making upgrading PHP extensions impossible unless<code class="literal"> php.ini</code> is not used.</p><p>There are a number of other small reasons that all added up to the need for a split, such as confusion over the function of packages (is this a PHP extension or a script written in PHP?) and so now we have both the<code class="literal"> pear</code> and the new<code class="literal"> pecl</code> command for managing PECL-packages.</p></div></div><div class="section" title="Enterprise-Level Dependency Management"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec04"/>Enterprise-Level Dependency Management</h2></div></div></div><p>Dependencies are a natural evolution in software design. If your forum package attempts to separate business logic from display by using a template engine, it is far better to focus your energies on developing the forum functionality than it is to design a new template engine. Not only have the authors of existing template engines spent more time working on and thinking about template engines, their template engine has been used by thousands of other developers just like you. All of the common and most of the unusual problems have been encountered and solved. In the event that you do find a new problem, you can report it to the maintainers, or even exercise the full strength of open source and fix the problem yourself and give the solution back to the maintainers.<a id="id48" class="indexterm"/>
</p><p>On the other hand, this requires putting trust in the maintainers of the template engine. By using the template engine, you implicitly trust the maintainers to effectively manage it, to fix all bugs discovered, and to prevent introducing new bugs into future releases. You also trust the maintainers to continue maintaining the package and to respond to issues you encounter.</p><p>PEAR developers have been around long enough to know that at its worst, this trust can be naïve or stupid, as software is still maintained by humans who have the capacity to screw up. Fortunately, because of this knowledge,<code class="literal"> package.xml</code> provides complete control over the "trust" of a dependency.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip13"/>Tip</h3><p><span class="strong"><strong>Dependencies in package.xml</strong></span></p><p>For more details on how dependencies work in<code class="literal"> package.xml</code>, see the section<span class="emphasis"><em> External Dependencies</em></span>
</p></div><p>The simplest dependency tells the installer that a package must be used but that we don't need to check for versioning issues: it is enough that it is installed. In<code class="literal"> package.xml 2.0</code>, this dependency looks something like:<a id="id49" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;package&gt;
&lt;name&gt;Dependency&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;/package&gt;
</pre></div><p>A slightly more restrictive dependency might tell the installer to only install versions newer than a minimum of version 1.2.0:<a id="id50" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;package&gt;
&lt;name&gt;Dependency&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;min&gt;1.2.0&lt;/min&gt;
&lt;/package&gt;
</pre></div><p>Going further, it may be the case that there were a few bungled releases. We can tell the installer to ignore specific releases 1.2.0 and 1.4.2, but that every other version newer than 1.2.0 is OK to install:</p><div class="informalexample"><pre class="programlisting">&lt;package&gt;
&lt;name&gt;Dependency&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;min&gt;1.2.0&lt;/min&gt;
&lt;exclude&gt;1.2.0&lt;/exclude&gt;
&lt;exclude&gt;1.4.2&lt;/exclude&gt;
&lt;/package&gt;
</pre></div><p>Finally, we can also tell the installer that we want to strongly recommend version 1.4.5, and to never upgrade unless we say it is OK:</p><div class="informalexample"><pre class="programlisting">&lt;package&gt;
&lt;name&gt;Dependency&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;min&gt;1.2.0&lt;/min&gt;
&lt;recommended&gt;1.4.5&lt;/recommended&gt;
&lt;exclude&gt;1.2.0&lt;/exclude&gt;
&lt;exclude&gt;1.4.2&lt;/exclude&gt;
&lt;/package&gt;
</pre></div><p>In this last case, we are given a tremendous amount of control over the dependency. The end user cannot accidentally break our package by upgrading to a newer release of a dependency unless the maintainers of the dependency have worked with you on your package and certified its compatibility with another tag,<code class="literal">&lt;compatible&gt;</code>, or you do another release of your package that recommends the newer version.</p><p>The differing levels of trust afforded by dependencies in<code class="literal"> package.xml</code> mean you can securely depend on other packages, but this is only the beginning of PEAR's dependency features. The other common problem solved by the use of dependencies is basic incompatibilities with the end user's computer, operating system, PHP version, or enabled extensions in<code class="literal"> php.ini</code>. PEAR provides dependency tags for each one of these situations. In addition, optional features or plug-ins can be implemented through optional dependencies or dependency groups. The list of possibilities is staggering, and yet the syntax in<code class="literal"> package.xml</code> is simple and very easy to learn.</p></div></div>
<div class="section" title="Distribution and Upgrades for the End User"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec03"/>Distribution and Upgrades for the End User</h1></div></div></div><p>From the end user's perspective, one of the most complex tasks faced when using an unzip-and-go package is upgrading. In the closed-source world, newer versions of a package break something that used to work with the old package as a means of forcing their users to upgrade, which sometimes requires significant work.<a id="id51" class="indexterm"/>
</p><p>In the open-source world, many developers continue to follow this model by introducing exciting new features that mean you can no longer use the old version. The actual upgrade process usually means overwriting the current version with the new files, possibly with new configuration needed. In addition, it opens up the scary prospect of completely breaking a live site, prompting the need for some kind of backup system.</p><p>By using the PEAR installer, all of these fears and dangers are a thing of the past. It is simple to upgrade to a new version by using:<a id="id52" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear upgrade Package
</strong></span>
</pre></div><p>It is just as simple to downgrade to a previous version of the package:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear upgrade --force Package-1.2.3
</strong></span>
</pre></div><p>This makes the task of maintaining a live site both easy and secure — a rare and wonderful combination. Note that this example assumes the old version of the package is<code class="literal"> 1.2.3</code>.</p><p>In addition, upgrading or installing dependencies is just as easy. Required dependencies are always downloaded and installed for packages that make use of<code class="literal"> package.xml 2.0</code>, and for packages that use<code class="literal"> package.xml 1.0</code>, dependencies can be automatically downloaded and installed with the<code class="literal"> --onlyreqdeps</code> (only required dependencies) option like this:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear upgrade --onlyreqdeps Package</strong></span>
</pre></div><p>Optional dependencies can also be automatically installed using the<code class="literal"> --alldeps</code> (all dependencies) option:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear upgrade --alldeps Package
</strong></span>
</pre></div><p>In addition, creating feature groups, or grouping several related packages into a single dependency, is easily accomplished with dependency groups, meaning users can install feature groups like PEAR's web installer feature like so:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear install PEAR#webinstaller
</strong></span>
</pre></div><p>When configuring a package, there is often a large amount of work that needs to be performed to configure file locations, set up databases, and so on. PEAR provides some simple ways to automate configuration, and also provides ways to standardize any level of complex setup through post-installation scripts.</p><p>If you're anything like me, thinking of all the possibilities built into the PEAR installer makes your heart race faster with anticipation. Even if you're not quite that geeky, I'm sure you will find that the power of the PEAR installer will make your programming life easier.</p></div>
<div class="section" title="An Overview of package.xml Structure"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec04"/>An Overview of package.xml Structure</h1></div></div></div><p>
<code class="literal">package.xml</code> contains all of the information the PEAR installer needs to install and configure PEAR packages. By leveraging standards such as XML and XSchema to document package structure ( <a class="ulink" href="http://pear.php.net/dtd/package1.xsd">http://pear.php.net/dtd/package1.xsd</a> and <a class="ulink" href="http://pear.php.net/dtd/package2.xsd"> http://pear.php.net/dtd/package2.xsd</a> have full definitions of<code class="literal"> package.xml 1.0</code> and<code class="literal"> package.xml 2.0</code> respectively), PEAR opens up future programming possibilities that would not be available otherwise. For instance, using XSchema allows future extensibility of<code class="literal"> package.xml</code> using XML namespaces to provide custom functionality.<a id="id53" class="indexterm"/>
</p><p>When discussing<code class="literal"> package.xml</code>, it is important to understand both the commonality and the differences between<code class="literal"> package.xml 1.0</code> and<code class="literal"> package.xml 2.0</code>. The<code class="literal"> package.xml 2.0</code> is a superset of<code class="literal"> package.xml 1.0</code>. In other words, it is possible to represent every single possible<code class="literal"> package.xml</code> version 1.0 as a<code class="literal"> package.xml 2.0</code>, but there is a large set of<code class="literal"> package.xml 2.0</code> that cannot be reduced to unique<code class="literal"> package.xml 1.0</code>.</p><p>The best way to get acquainted with the structure of<code class="literal"> package.xml 1.0</code> is to peruse the CVS of the PEAR repository at <a class="ulink" href="http://cvs.php.net"> cvs.php.net</a>. Each subdirectory contains a<code class="literal"> package.xml</code> file. If that<code class="literal"> package.xml</code> file begins with<code class="literal">&lt;package version="1.0"...</code> then it is a<code class="literal"> package.xml 1.0</code>. Many packages are already taking advantage of<code class="literal"> package.xml 2.0</code>, using a file named<code class="literal"> package2.xml</code>. Also useful is to investigate the PECL repository at <a class="ulink" href="http://cvs.php.net/pecl/"> http://cvs.php.net/pecl/</a> and see how PHP extension developers are using<code class="literal"> package.xml</code>.</p><p>To explore the equivalent<code class="literal"> package.xml 2.0</code>, there is a convenient PEAR command that can be used to convert a<code class="literal"> package.xml 1.0</code> into a<code class="literal"> package.xml 2.0</code>. This command is invoked as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear convert
</strong></span>
</pre></div><p>This will parse a file in the current directory named<code class="literal"> package.xml</code> and spit out a file named<code class="literal"> package2.xml</code> in the new format.</p><p>In addition, full up-to-date documentation on<code class="literal"> package.xml</code> is always available in the PEAR manual at <a class="ulink" href="http://pear.php.net/manual/"> http://pear.php.net/manual/</a>.</p><p>For the purposes of this book, we will be primarily discussing<code class="literal"> package.xml 2.0</code>, and only mentioning 1.0 to remark on important conceptual changes for those who are familiar with the old format.<a id="id54" class="indexterm"/>
</p><p>Here is a sample<code class="literal"> package.xml</code> file. This one is taken from the PEAR package itself, and demonstrates a number of<code class="literal"> package.xml's</code> features that will be explored in the sections to come. Feel free to skim this example and then refer back to it later on. For now, just absorb the basic structure and the specifics will make sense when you read about them later on in this text.</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;package version="2.0" 


xsi:schemaLocation="http://pear.php.net/dtd/tasks-1.0
http://pear.php.net/dtd/tasks-1.0.xsd
http://pear.php.net/dtd/package-2.0
http://pear.php.net/dtd/package-2.0.xsd"&gt;
&lt;name&gt;PEAR&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;summary&gt;PEAR Base System&lt;/summary&gt;
&lt;description&gt;The PEAR package contains:
* the PEAR installer, for creating, distributing
and installing packages
* the beta-quality PEAR_Exception PHP5 error handling mechanism
* the beta-quality PEAR_ErrorStack advanced error handling class
* the PEAR_Error error handling mechanism
* the OS_Guess class for retrieving info about the OS
where PHP is running on
* the System class for quick handling of common operations
with files and directories
* the PEAR base class
&lt;/description&gt;
&lt;lead&gt;
&lt;name&gt;Greg Beaver&lt;/name&gt;
&lt;user&gt;cellog&lt;/user&gt;
&lt;email&gt;cellog@php.net&lt;/email&gt;
&lt;active&gt;yes&lt;/active&gt;
&lt;/lead&gt;
&lt;lead&gt;
&lt;name&gt;Stig Bakken&lt;/name&gt;
&lt;user&gt;ssb&lt;/user&gt;
&lt;email&gt;stig@php.net&lt;/email&gt;
&lt;active&gt;yes&lt;/active&gt;
&lt;/lead&gt;
&lt;lead&gt;
&lt;name&gt;Tomas V.V.Cox&lt;/name&gt;
&lt;user&gt;cox&lt;/user&gt;
&lt;email&gt;cox@idecnet.com&lt;/email&gt;
&lt;active&gt;yes&lt;/active&gt;
&lt;/lead&gt;
&lt;lead&gt;
&lt;name&gt;Pierre-Alain Joye&lt;/name&gt;
&lt;user&gt;pajoye&lt;/user&gt;
&lt;email&gt;pajoye@pearfr.org&lt;/email&gt;
&lt;active&gt;yes&lt;/active&gt;
&lt;/lead&gt;
&lt;helper&gt;
&lt;name&gt;Martin Jansen&lt;/name&gt;
&lt;user&gt;mj&lt;/user&gt;
&lt;email&gt;mj@php.net&lt;/email&gt;
&lt;active&gt;no&lt;/active&gt;
&lt;/helper&gt;
&lt;date&gt;2005-10-09&lt;/date&gt;
&lt;version&gt;
&lt;release&gt;1.4.2&lt;/release&gt;
&lt;api&gt;1.4.0&lt;/api&gt;
&lt;/version&gt;
&lt;stability&gt;
&lt;release&gt;stable&lt;/release&gt;
&lt;api&gt;stable&lt;/api&gt;
&lt;/stability&gt;
&lt;license uri="http://www.php.net/license"&gt;PHP License&lt;/license&gt;
&lt;notes&gt;
This is a major milestone release for PEAR. In addition to several killer features, every single element of PEAR has a regression test, and so stability is much higher than any previous PEAR release, even with the beta label.
New features in a nutshell:
* full support for channels
* pre-download dependency validation
* new package.xml 2.0 format allows tremendous flexibility * while maintaining BC support for optional dependency groups * and limited support for sub-packaging robust dependency support
* full dependency validation on uninstall
* remote install for hosts with only ftp access - * no more problems with restricted host installation
* full support for mirroring
* support for bundling several packages into a single tarball
* support for static dependencies on a uri-based package
* support for custom file roles and installation tasks
&lt;/notes&gt;
&lt;contents&gt;
&lt;dir name="/"&gt;
&lt;dir name="OS"&gt;
&lt;file name="Guess.php" role="php"&gt;
&lt;tasks:replace from="@package_version@" to="version"
type="package-info" /&gt;
&lt;/file&gt;
&lt;/dir&gt; &lt;!-- /OS --&gt;
&lt;dir name="PEAR"&gt;
&lt;dir name="ChannelFile"&gt;
&lt;file name="Parser.php" role="php"&gt;
&lt;tasks:replace from="@package_version@" to="version"
type="package-info" /&gt;
&lt;/file&gt;
&lt;/dir&gt; &lt;!-- /PEAR/ChannelFile --&gt;
&lt;dir name="Command"&gt;
&lt;file name="Auth-init.php" role="php"/&gt;
&lt;file name="Auth.php" role="php"&gt;
&lt;tasks:replace from="@package_version@" to="version"
type="package-info" /&gt;
&lt;/file&gt;
&lt;file name="Build-init.php" role="php"/&gt;
&lt;file name="Build.php" role="php"&gt;
&lt;tasks:replace from="@package_version@" to="version"
type="package-info" /&gt;
&lt;/file&gt;
<span class="strong"><strong>[snip...]
</strong></span>
&lt;/dir&gt; &lt;!-- /PEAR --&gt;
&lt;dir name="scripts" baseinstalldir="/"&gt;
&lt;file name="pear.bat" role="script"&gt;
&lt;tasks:replace from="@bin_dir@" to="bin_dir" type="pear-config"
/&gt;
&lt;tasks:replace from="@php_bin@" to="php_bin" type="pear-config"
/&gt;
&lt;tasks:replace from="@include_path@" to="php_dir" type="pear-
config" /&gt;
&lt;tasks:windowseol/&gt;
&lt;/file&gt;
&lt;file name="peardev.bat" role="script"&gt;
&lt;tasks:replace from="@bin_dir@" to="bin_dir" type="pear-config"
/&gt;
&lt;tasks:replace from="@php_bin@" to="php_bin" type="pear-config"
/&gt;
&lt;tasks:replace from="@include_path@" to="php_dir" type="pear-config" /&gt;
&lt;tasks:windowseol/&gt;
&lt;/file&gt;
&lt;file name="pecl.bat" role="script"&gt;
&lt;tasks:replace from="@bin_dir@" to="bin_dir" type="pear-config"
/&gt;
&lt;tasks:replace from="@php_bin@" to="php_bin" type="pear-config"
/&gt;
&lt;tasks:replace from="@include_path@" to="php_dir" type="pear-config" /&gt;
&lt;tasks:windowseol/&gt;
&lt;/file&gt;
&lt;file name="pear.sh" role="script"&gt;
&lt;tasks:replace from="@php_bin@" to="php_bin" type="pear-config"
/&gt;
&lt;tasks:replace from="@php_dir@" to="php_dir" type="pear-config"
/&gt;
&lt;tasks:replace from="@pear_version@" to="version" type="package-info" /&gt;
&lt;tasks:replace from="@include_path@" to="php_dir" type="pear-config" /&gt;
&lt;tasks:unixeol/&gt;
&lt;/file&gt;
<span class="strong"><strong>[snip...]</strong></span>
&lt;/dir&gt; &lt;!-- /scripts --&gt;
&lt;file name="package.dtd" role="data" /&gt;
&lt;file name="PEAR.php" role="php"&gt;
&lt;tasks:replace from="@package_version@" to="version"
type="package-info" /&gt;
&lt;/file&gt;
&lt;file name="System.php" role="php"&gt;
&lt;tasks:replace from="@package_version@" to="version"
type="package-info" /&gt;
&lt;/file&gt;
&lt;file name="template.spec" role="data" /&gt;
&lt;/dir&gt; &lt;!-- / --&gt;
&lt;/contents&gt;
&lt;dependencies&gt;
&lt;required&gt;
&lt;php&gt;
&lt;min&gt;4.2&lt;/min&gt;
&lt;/php&gt;
&lt;pearinstaller&gt;
&lt;min&gt;1.4.0a12&lt;/min&gt;
&lt;/pearinstaller&gt;
&lt;package&gt;
&lt;name&gt;Archive_Tar&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;min&gt;1.1&lt;/min&gt;
&lt;recommended&gt;1.3.1&lt;/recommended&gt;
&lt;exclude&gt;1.3.0&lt;/exclude&gt;
&lt;/package&gt;
&lt;package&gt;
&lt;name&gt;Console_Getopt&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;min&gt;1.2&lt;/min&gt;
&lt;recommended&gt;1.2&lt;/recommended&gt;
&lt;/package&gt;
&lt;package&gt;
&lt;name&gt;XML_RPC&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;min&gt;1.4.0&lt;/min&gt;
&lt;recommended&gt;1.4.1&lt;/recommended&gt;
&lt;/package&gt;
&lt;package&gt;
&lt;name&gt;PEAR_Frontend_Web&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;max&gt;0.5.0&lt;/max&gt;
&lt;exclude&gt;0.5.0&lt;/exclude&gt;
&lt;conflicts/&gt;
&lt;/package&gt;
&lt;package&gt;
&lt;name&gt;PEAR_Frontend_Gtk&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;max&gt;0.4.0&lt;/max&gt;
&lt;exclude&gt;0.4.0&lt;/exclude&gt;
&lt;conflicts/&gt;
&lt;/package&gt;
&lt;extension&gt;
&lt;name&gt;xml&lt;/name&gt;
&lt;/extension&gt;
&lt;extension&gt;
&lt;name&gt;pcre&lt;/name&gt;
&lt;/extension&gt;
&lt;/required&gt;
&lt;group name="remoteinstall" hint="adds the ability to install
packages to a remote ftp server"&gt;
&lt;subpackage&gt;
&lt;name&gt;PEAR_RemoteInstaller&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;min&gt;0.1.0&lt;/min&gt;
&lt;recommended&gt;0.1.0&lt;/recommended&gt;
&lt;/subpackage&gt;
&lt;/group&gt;
&lt;group name="webinstaller" hint="PEAR's web-based installer"&gt;
&lt;package&gt;
&lt;name&gt;PEAR_Frontend_Web&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;min&gt;0.5.0&lt;/min&gt;
&lt;/package&gt;
&lt;/group&gt;
&lt;group name="gtkinstaller" hint="PEAR's PHP-GTK-based installer"&gt;
&lt;package&gt;
&lt;name&gt;PEAR_Frontend_Gtk&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;min&gt;0.4.0&lt;/min&gt;
&lt;/package&gt;
&lt;/group&gt;
&lt;/dependencies&gt;
&lt;phprelease&gt;
&lt;installconditions&gt;
&lt;os&gt;
&lt;name&gt;windows&lt;/name&gt;
&lt;/os&gt;
&lt;/installconditions&gt;
&lt;filelist&gt;
&lt;install as="pear.bat" name="scripts/pear.bat" /&gt;
&lt;install as="peardev.bat" name="scripts/peardev.bat" /&gt;
&lt;install as="pecl.bat" name="scripts/pecl.bat" /&gt;
&lt;install as="pearcmd.php" name="scripts/pearcmd.php" /&gt;
&lt;install as="peclcmd.php" name="scripts/peclcmd.php" /&gt;
&lt;ignore name="scripts/peardev.sh" /&gt;
&lt;ignore name="scripts/pear.sh" /&gt;
&lt;ignore name="scripts/pecl.sh" /&gt;
&lt;/filelist&gt;
&lt;/phprelease&gt;
&lt;phprelease&gt;
&lt;filelist&gt;
&lt;install as="pear" name="scripts/pear.sh" /&gt;
&lt;install as="peardev" name="scripts/peardev.sh" /&gt;
&lt;install as="pecl" name="scripts/pecl.sh" /&gt;
&lt;install as="pearcmd.php" name="scripts/pearcmd.php" /&gt;
&lt;install as="peclcmd.php" name="scripts/peclcmd.php" /&gt;
&lt;ignore name="scripts/pear.bat" /&gt;
&lt;ignore name="scripts/peardev.bat" /&gt;
&lt;ignore name="scripts/pecl.bat" /&gt;
&lt;/filelist&gt;
&lt;/phprelease&gt;
&lt;changelog&gt;
&lt;release&gt;
&lt;version&gt;
&lt;release&gt;1.3.6&lt;/release&gt;
&lt;api&gt;1.3.0&lt;/api&gt;
&lt;/version&gt;
&lt;stability&gt;
&lt;release&gt;stable&lt;/release&gt;
&lt;api&gt;stable&lt;/api&gt;
&lt;/stability&gt;
&lt;date&gt;2005-08-18&lt;/date&gt;
&lt;license&gt;PHP License&lt;/license&gt;
&lt;notes&gt;
* Bump XML_RPC dependency to 1.4.0
* return by reference from PEAR::raiseError()
&lt;/notes&gt;
&lt;/release&gt;
&lt;release&gt;
&lt;version&gt;
&lt;release&gt;1.4.0a1&lt;/release&gt;
&lt;api&gt;1.4.0&lt;/api&gt;
&lt;/version&gt;
&lt;stability&gt;
&lt;release&gt;alpha&lt;/release&gt;
&lt;api&gt;alpha&lt;/api&gt;
&lt;/stability&gt;
&lt;date&gt;2005-02-26&lt;/date&gt;
&lt;license uri="http://www.php.net/license/3_0.txt"&gt;PHP
License&lt;/license&gt;
&lt;notes&gt;
This is a major milestone release for PEAR. In addition to several
killer features,
every single element of PEAR has a regression test, and so
stability is much higher
than any previous PEAR release, even with the alpha label.
New features in a nutshell:
* full support for channels
* pre-download dependency validation
* new package.xml 2.0 format allows tremendous flexibility while
maintaining BC
* support for optional dependency groups and limited support for
sub-packaging
* robust dependency support
* full dependency validation on uninstall
* support for binary PECL packages
* remote install for hosts with only ftp access - * no more problems
with
restricted host installation
* full support for mirroring
* support for bundling several packages into a single tarball
* support for static dependencies on a url-based package
Specific changes from 1.3.5:
* Implement request #1789: SSL support for xml-rpc and download
* Everything above here that you just read
&lt;/notes&gt;
&lt;/release&gt;
<span class="strong"><strong>[snip...]
</strong></span>
&lt;/changelog&gt;
&lt;/package&gt;
<a id="id58" class="indexterm"/>
</pre></div></div>
<div class="section" title="Tags Shared between package.xml 1.0 and 2.0"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec05"/>Tags Shared between package.xml 1.0 and 2.0</h1></div></div></div><p>If you have a basic understanding of<code class="literal"> package.xml 1.0</code> and just want to see what has changed in<code class="literal"> package.xml 2.0</code>, it is best to skim the next few sections. Differences are always presented at the beginning of each section, followed by an in-depth exploration of the reasoning behind the changes.<a id="id59" class="indexterm"/>
</p><p>Before launching into the advanced new features of<code class="literal"> package.xml 2.0</code>, it is important to explore the tags and attributes that have been carried over from<code class="literal"> package.xml 1.0</code> that both formats have in common. Most tags are unchanged. A few have either added information or changed their name slightly, and others have been completely redesigned. Let's get started.<a id="id60" class="indexterm"/>
</p><div class="section" title="Package Metadata"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec05"/>Package Metadata</h2></div></div></div><p>Both<code class="literal"> package.xml</code> versions provide similar package metadata. Some basic information that must be present in any package includes:<a id="id61" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Package name/channel</li><li class="listitem" style="list-style-type: disc">Maintainers (authors)</li><li class="listitem" style="list-style-type: disc">Package description</li><li class="listitem" style="list-style-type: disc">Package summary (one-line description)</li></ul></div><p>Most of this information remains unchanged from release to release. For instance, the package name and channel are constant. The package description and summary will change rarely. The maintainers may change more frequently, depending on the community, so even though this is grouped under package metadata, it is probably reasonable to think of this as release-based information.</p><div class="section" title="Package Name/Channel"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Package Name/Channel</h3></div></div></div><p>These two fields are at the beginning of a<code class="literal"> package.xml</code>, and form the heart of the PEAR installer's package differentiation. These are like the primary key in a database table: a unique combination of package/channel = a unique package. Note that the<code class="literal">&lt;channel&gt;</code> and<code class="literal">&lt;uri&gt;</code> tags are only present in<code class="literal"> package.xml 2.0</code>.<a id="id62" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;name&gt;Packagename&lt;/name&gt;
&lt;channel&gt;channel.example.com&lt;/channel&gt; <span class="strong"><strong>-or-</strong></span> &lt;uri&gt;http://www.example.com/Packagename-1.2.3&lt;/uri&gt;
</pre></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip14"/>Tip</h3><p><span class="strong"><strong>Channels and package.xml 1.0</strong></span></p><p>As you learned earlier, the concept of channels is introduced in<code class="literal"> package.xml 2.0</code>. How does<code class="literal"> package.xml 1.0</code> define the channel when it is not a part of its specification?</p><p>PEAR handles this problem in a simple way: all packages packaged using<code class="literal"> package.xml 1.0</code> are installed as if they had a<code class="literal">&lt;channel&gt;pear.php.net&lt;/channel&gt;</code> tag inserted right after the package name declaration. Note that <a class="ulink" href="http://pecl.php.net"> pecl.php.net</a> packages that used<code class="literal"> package.xml 1.0</code> are allowed to migrate to the <a class="ulink" href="http://pecl.php.net"> pecl.php.net</a> channel when they upgrade to using a<code class="literal"> package.xml 2.0</code>, but all other packages must start over with a new channel.</p></div><p>The package name is declared using the<code class="literal">&lt;name&gt;</code> tag, and must begin with a letter, and otherwise contain only letters, numbers and the underscore character, unless the channel-specific validator allows another format for the package name. Channel-specific validators are covered in depth in <a class="link" href="ch05.html" title="Chapter 5. Releasing to the World: PEAR Channels">Chapter 5</a>. If you are simply creating a package, you need not know anything about channel-specific validators. If your package satisfies the requirements for a package, when you run:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ pear package
</strong></span>
</pre></div><p>Your package will be created without errors. Otherwise, packaging will fail, and one or more error messages will be presented describing the reasons for failure.<a id="id63" class="indexterm"/>
</p><p>The<code class="literal">&lt;channel&gt;</code> tag cannot co-exist with the<code class="literal">&lt;uri&gt;</code> tag. A package that uses the<code class="literal">&lt;uri&gt;</code> tag is in fact automatically part of the pseudo-channel<code class="literal"> __uri</code>, a channel that does not have a server or protocols associated with it. The<code class="literal"> __uri</code> channel is in fact a true magic channel that only serves to act as a namespace preventing URI-based packages from conflicting with packages from other channels.</p><p>For instance, consider a package whose<code class="literal"> package.xml</code> begins with:</p><div class="informalexample"><pre class="programlisting">&lt;name&gt;Packagename&lt;/name&gt;
&lt;uri&gt;http://pear.php.net/Packagename-1.2.3&lt;/uri&gt;
</pre></div><p>This package is<span class="emphasis"><em> not</em></span> the same as a package whose<code class="literal"> package.xml</code> begins with the following code even if the version number of the package is<code class="literal"> 1.2.3</code>.</p><div class="informalexample"><pre class="programlisting">&lt;name&gt;Packagename&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
</pre></div><p>URI-based packages are strictly release-based. The<code class="literal">&lt;uri&gt;</code> tag must be an absolute, real-world URI that can be used to access the package. However, the URI should not include a<code class="literal"> .tgz</code> or<code class="literal"> .tar</code> file extension, but both should be present. In our example above, both  <a class="ulink" href="http://pear.php.net/Packagename-1.2.3.tgz">http://pear.php.net/Packagename-1.2.3.tgz</a> and  <a class="ulink" href="http://pear.php.net/Packagename-1.2.3.tar"> http://pear.php.net/Packagename-1.2.3.tar</a> should exist and be identical except for the use of zlib compression on the<code class="literal"> .tgz</code>.</p></div><div class="section" title="Maintainers (Authors)"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Maintainers (Authors)</h3></div></div></div><p>The list of maintainers in<code class="literal"> package.xml</code> should serve the same function that a traditional<code class="literal"> AUTHORS</code> file serves. However, this list of authors is more than just useful information. The<code class="literal">&lt;user&gt;</code> tag is used by a channel server to match up package maintainers with the release of a package, allowing non-channel administrators to upload releases of software packages that they maintain. If you are maintaining a package that is released through <a class="ulink" href="http://pear.php.net"> pear.php.net</a>, for instance, the<code class="literal">&lt;user&gt;</code> tag must contain your PEAR username. For non-channel releases, the contents of these tags are informational only, and let end users of your package know how to contact you.<a id="id64" class="indexterm"/>
</p><p>The<code class="literal">&lt;role&gt;</code> tag in<code class="literal"> package.xml 1.0</code> may only contain the values<code class="literal"> lead, developer, contributor</code>, or<code class="literal"> helper</code>. This proves to be impossible to validate using XSchema, and so to make things easier,<code class="literal"> package.xml 2.0</code> has taken the contents of the<code class="literal">&lt;role&gt;</code> tag and extracted them out to new tags<code class="literal">&lt;lead&gt;, &lt;developer&gt;, &lt;contributor&gt;</code>, and<code class="literal">&lt;helper&gt;</code>. In addition, the<code class="literal">&lt;maintainers&gt;</code> and<code class="literal">&lt;maintainer&gt;</code> tag have been removed to simplify parsing.<a id="id65" class="indexterm"/>
</p><p>For<code class="literal"> package.xml 1.0:</code>
</p><div class="informalexample"><pre class="programlisting">&lt;maintainers&gt;
&lt;maintainer&gt;
&lt;user&gt;pearserverhandle&lt;/user&gt;
&lt;role&gt;lead&lt;/role&gt;
&lt;name&gt;Dorkus McForkus&lt;/name&gt;
&lt;email&gt;dorkus@example.com&lt;/email&gt;
&lt;/maintainer&gt;
&lt;maintainer&gt;
&lt;user&gt;pearserverhelper&lt;/user&gt;
&lt;role&gt;helper&lt;/role&gt;
&lt;name&gt;Horgie Borgie&lt;/name&gt;
&lt;email&gt;borgie@example.com&lt;/email&gt;
&lt;/maintainer&gt;
&lt;/maintainers&gt;
</pre></div><p>For<code class="literal"> package.xml 2.0:</code>
</p><div class="informalexample"><pre class="programlisting">&lt;lead&gt;
&lt;name&gt;Dorkus McForkus&lt;/name&gt;
&lt;user&gt;pearserverhandle&lt;/user&gt;
&lt;email&gt;dorkus@example.com&lt;/email&gt;
&lt;active&gt;yes&lt;/active&gt;
&lt;/lead&gt;
&lt;helper&gt;
&lt;name&gt;Horgie Borgie&lt;/name&gt;
&lt;user&gt;pearserverhelper&lt;/user&gt;
&lt;email&gt;borgie@example.com&lt;/email&gt;
&lt;active&gt;no&lt;/active&gt;
&lt;/helper&gt;
</pre></div></div><div class="section" title="Package Description and Summary"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Package Description and Summary</h3></div></div></div><p>The example summary/description pair below shows how the<code class="literal">&lt;summary&gt;</code> and<code class="literal">&lt;description&gt;</code> tags should be used in both<code class="literal"> package.xml 1.0</code> and<code class="literal"> package.xml 2.0</code>. These tags are strictly informational, and are not used by the installation portions of the PEAR installer. If a package is served through a channel, commands like<code class="literal"> list-all</code> will display the summary. The description is displayed when a user types commands like<code class="literal"> info</code> or<code class="literal"> remote-info</code> to display information about a particular package or release.<a id="id66" class="indexterm"/>
</p><p>Be sure that these tags are clear, concise, and understandable. Too often, I have seen summaries like<code class="literal"> GBRL</code> for a package named<code class="literal"> File_GBRL</code>  — define your acronyms if they are not commonly known!<a id="id67" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;summary&gt;Provides an interface to the BORG collective&lt;/summary&gt;
&lt;description&gt;
The Net_BORG package uses PHP to interface with the neural
Implants found in the face of all BORG. Both an object-oriented
and a functional interface is available. Both will be used.
Resistance is futile.
&lt;/description&gt;
</pre></div></div></div><div class="section" title="Basic Release Metadata"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec06"/>Basic Release Metadata</h2></div></div></div><p>The rest of<code class="literal"> package.xml</code> is generally release-specific data, with a few exceptions. Release-specific data is more apt to change than things like the name of a package. Specifically, the areas of release-specific information documented in<code class="literal"> package.xml</code> are:<a id="id68" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Package version</li><li class="listitem" style="list-style-type: disc">Package stability</li><li class="listitem" style="list-style-type: disc">External dependencies</li><li class="listitem" style="list-style-type: disc">Release notes</li><li class="listitem" style="list-style-type: disc">Release license</li><li class="listitem" style="list-style-type: disc">Changelog</li><li class="listitem" style="list-style-type: disc">File list, or contents of the package</li></ul></div><p>In<code class="literal"> package.xml 1.0</code>, this data was enclosed in a redundant<code class="literal">&lt;release&gt;</code> tag. This tag has been removed in version 2.0.</p><div class="section" title="Package Version"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Package Version</h3></div></div></div><p>The package version is very important, as this is the primary mechanism used by the installer to determine the relative age of different releases. Versions are sequential, meaning version 1.3.6 is older than version 1.4.0b1, even if version 1.3.6 was released a month after 1.4.0b1.<a id="id69" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;version&gt;1.2.3&lt;/version&gt;
</pre></div><p>For<code class="literal"> package.xml 2.0:</code>
</p><div class="informalexample"><pre class="programlisting">&lt;version&gt;
&lt;release&gt;1.2.3&lt;/release&gt;
&lt;api&gt;1.0.0&lt;/api&gt;
&lt;/version&gt;
</pre></div><p>The API version of a release is strictly for informational purposes. This can, however, be used in a<code class="literal"> replace</code> task as follows:</p><div class="informalexample"><pre class="programlisting">&lt;file name="Foo.php" role="php"&gt;
&lt;tasks:replace from="apiversion" to="@API-VER@" type="package-info"/&gt;
&lt;/file&gt;
</pre></div><p>This reduces redundancy in maintaining versioning inside files. In fact, providing API version through an API method is a very good idea. In my packages, I usually provide this code:</p><div class="informalexample"><pre class="programlisting">/**
* Get the current API version
* @return string
*/
function APIVersion()
{
Return '@API-VER@';
}
</pre></div><p>Upon packaging, the<code class="literal"> Foo.php</code> file containing the above code would look like this:<a id="id70" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">/**
* Get the current API version
* @return string
*/
function APIVersion()
{
Return '1.0.0';
}
</pre></div><p>In other words, all instances of the<code class="literal"> @API-VER@</code> token will be replaced with the contents of the<code class="literal">&lt;api&gt;</code> version tag. Replacement file tasks are used to perform this magic.</p></div><div class="section" title="Package Stability"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Package Stability</h3></div></div></div><p>In<code class="literal"> package.xml 1.0</code>, the<code class="literal">&lt;state&gt;</code> tag was used to describe the stability of code. In<code class="literal"> package.xml 2.0</code>, the<code class="literal">&lt;release&gt;</code> tag inside<code class="literal">&lt;stability&gt;</code> is used to describe the stability of code.<a id="id71" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;state&gt;beta&lt;/state&gt;
</pre></div><p>For<code class="literal"> package.xml 2.0:</code>
</p><div class="informalexample"><pre class="programlisting">&lt;stability&gt;
&lt;release&gt;beta&lt;/release&gt;
&lt;api&gt;stable&lt;/api&gt;
&lt;/stability&gt;
</pre></div><p>The PEAR installer uses the release stability in conjunction with an end user's<code class="literal"> preferred_state</code> configuration variable to determine whether a release is stable enough to install. If the user wishes to install the<code class="literal"> Foo</code> package, and these releases are available:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Version</p>
</th><th style="text-align: left" valign="bottom">
<p>Stability</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>1.0.1</p>
</td><td style="text-align: left" valign="top">
<p>stable</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1.1.0a1</p>
</td><td style="text-align: left" valign="top">
<p>alpha</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1.0.0</p>
</td><td style="text-align: left" valign="top">
<p>stable</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>0.9.0</p>
</td><td style="text-align: left" valign="top">
<p>beta</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>0.8.0</p>
</td><td style="text-align: left" valign="top">
<p>alpha</p>
</td></tr></tbody></table></div><p>The installer will choose versions to install based on the user's<code class="literal"> preferred_state</code> setting.<a id="id72" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>preferred_state value</p>
</th><th style="text-align: left" valign="bottom">
<p>Foo version that would be installed</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>stable</p>
</td><td style="text-align: left" valign="top">
<p>1.0.1</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>beta</p>
</td><td style="text-align: left" valign="top">
<p>1.0.1</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>alpha</p>
</td><td style="text-align: left" valign="top">
<p>1.1.0a1</p>
</td></tr></tbody></table></div><p>Note that for a<code class="literal"> preferred_state</code> of<code class="literal"> beta</code>, when there is a choice of a newer version 1.0.1 <code class="literal">(stable)</code> and older version 0.9.0 <code class="literal">(beta)</code>, the installer will choose the latest, most stable version — version 1.0.1. For a<code class="literal"> preferred_state</code> of<code class="literal"> alpha</code>, the installer will choose the newer and less stable version 1.1.0a1 <code class="literal">(alpha)</code> over the older version 1.0.1 <code class="literal">(stable)</code>, even though version 1.0.1 was released<span class="emphasis"><em> after</em></span> version 1.1.0a1.</p><p>The list of legal stabilities for release stability in order of diminishing stability is:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">stable:</code> code should be working in all situations.</li><li class="listitem" style="list-style-type: disc"><code class="literal">beta:</code> code should be working in all situations, and is feature-complete, but needs real-world testing.</li><li class="listitem" style="list-style-type: disc"><code class="literal">alpha:</code> code is in a state of flux, features may change at any time, stability is uncertain.</li><li class="listitem" style="list-style-type: disc"><code class="literal">devel:</code> code is not yet feature-complete, and may not work in most situations.</li><li class="listitem" style="list-style-type: disc"><code class="literal">snapshot:</code> this is a current copy of development code from source during live development in between normal releases.</li></ul></div><p>API stability serves the same informational purpose as API version. It is not used by the installer, but can be used to track the rate of change of an API. An API marked stable should in fact never change except for adding new features — users need to be able to depend upon a stable API in order for package dependencies to work. This is a key feature of enterprise-level dependencies.</p><p>The list of legal stabilities for API differs slightly in that an API snapshot is not allowed. API stability should be thought of as:<a id="id73" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">stable:</code> API is set, and will not break backward compatibility.</li><li class="listitem" style="list-style-type: disc"><code class="literal">beta:</code> API is probably set, and will only change to fix serious bugs in design that are encountered during testing.</li><li class="listitem" style="list-style-type: disc"><code class="literal">alpha:</code> API is fluid, and may change, breaking any existing features, as well as adding new ones.</li><li class="listitem" style="list-style-type: disc"><code class="literal">devel:</code> API is extremely unstable, and may change dramatically at any time.</li></ul></div></div><div class="section" title="External Dependencies"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec06"/>External Dependencies</h3></div></div></div><p>There are two kinds of dependencies that the PEAR installer recognizes:<span class="emphasis"><em> required</em></span> and<span class="emphasis"><em> optional</em></span> dependencies. In addition, there are two classes of dependencies, those that restrict installation, and those that describe other resources (packages/extensions) used by the primary package. Restrictive dependencies are defined by the<code class="literal">&lt;php&gt;, &lt;pearinstaller&gt;, &lt;arch&gt;, &lt;extension&gt;</code>, and<code class="literal">&lt;os&gt;</code> dependencies. Resource-based dependencies are defined by the<code class="literal">&lt;package&gt;, &lt;subpackage&gt;</code>, and<code class="literal">&lt;extension&gt;</code> dependencies.<a id="id74" class="indexterm"/>
</p><p>Although the<code class="literal"> package.xml 1.0</code> DTD defined several dependency types, only three were ever implemented:<a id="id75" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">pkg:</code> dependencies on packages</li><li class="listitem" style="list-style-type: disc"><code class="literal">ext:</code> dependencies on extensions</li><li class="listitem" style="list-style-type: disc"><code class="literal">php:</code> dependencies on PHP versions</li></ul></div><p>The structure of dependencies in<code class="literal"> package.xml 1.0</code> was quite simple:<a id="id76" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;deps&gt;
&lt;dep type="php" rel="ge" version="4.2.0"/&gt;
&lt;dep type="pkg" rel="has"&gt;PackageName&lt;/dep&gt;
&lt;dep type="pkg" rel="ge" version="1.0"&gt;PackageName2&lt;/dep&gt;
&lt;dep type="pkg" rel="ge" version="1.0"
optional="yes"&gt;PackageName3&lt;/dep&gt;
&lt;dep type="ext" rel="not"&gt;ExtensionName&lt;/dep&gt;
&lt;/deps&gt;
</pre></div><p>The legal values of the<code class="literal"> rel</code> attribute are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">has:</code> the dependency must exist</li><li class="listitem" style="list-style-type: disc"><code class="literal">not:</code> the dependency must not be present</li><li class="listitem" style="list-style-type: disc"><code class="literal">gt:</code> in conjunction with<code class="literal"> version</code> attribute, the dependency must have version &gt; the required version.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ge:</code> in conjunction with<code class="literal"> version</code> attribute, the dependency must have version &gt;= the required version</li><li class="listitem" style="list-style-type: disc"><code class="literal">eq:</code> in conjunction with<code class="literal"> version</code> attribute, the dependency must have version == the required version.</li><li class="listitem" style="list-style-type: disc"><code class="literal">lt:</code> in conjunction with<code class="literal"> version</code> attribute, the dependency must have version &lt; the required version.</li><li class="listitem" style="list-style-type: disc"><code class="literal">le:</code> in conjunction with<code class="literal"> version</code> attribute, the dependency must have version &lt;= the required version.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ne:</code> in conjunction with<code class="literal"> version</code> attribute, the dependency must have version != the required version. (PEAR version 1.3.6 only.)</li></ul></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip15"/>Tip</h3><p><span class="strong"><strong>How is Version Comparison Done?</strong></span></p><p>The PHP function<code class="literal"> version_compare()</code> is used to determine whether a version-based dependency validates. Documentation for<code class="literal"> version_compare()</code> is at <a class="ulink" href="http://www.php.net/version_compare"> http://www.php.net/version_compare</a>.</p></div><p>Only after a great deal of experience did the serious design flaws of this approach reveal themselves:<a id="id77" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>XML validation with tools like xmllint cannot reveal invalid dependencies</em></span>. Consider the following dependency<code class="literal">&lt;dep type="php" rel="has" version="4.3.0"/&gt;</code>. This dependency is not valid because<code class="literal"> rel="has"</code> ignores the version attribute, and so the dependency validation will not be performed — every PEAR installation has PHP installed by definition.</li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Trust level of dependency upgrades cannot be controlled</em></span>. The PEAR package depends upon the Console_Getopt package. At one point, the maintainer of Console_Getopt<span class="emphasis"><em> fixed</em></span> a bug that suddenly caused PEAR to stop working upon upgrade. A good deal of scrambling resulted in a fix, but the event highlighted the fatal flaw in the design of the PEAR installer pre-version 1.4.0: dependencies upon packages are inherently unsafe. There is no way to restrict trust of dependencies. The<code class="literal"> rel="eq"</code> attribute does not have the desired effect because this prevents upgrading safely for any reason, effectively freezing development. In addition, flaws in the validation of dependencies meant that even upgrading to a newer package version is forbidden.<p>If the current version has a dependency tag of <code class="literal">&lt;dep type="pkg" rel="eq" version="1.0"&gt;Deppackage&lt;/dep&gt;</code>, the PEAR installer would look at the dependencies for the new version with <code class="literal">&lt;dep type="pkg" rel="eq" version="1.1"&gt;Deppackage&lt;/dep&gt;</code> then look on disk to see that Deppackage version 1.0 was installed, and fail to upgrade. Even if both the main package and Deppackage were passed in, upgrade of Deppackage would fail because the installed version of the main package requires version 1.0 of Deppackage.
<a id="id78" class="indexterm"/>
</p><p>If the current version has a dependency tag of <code class="literal">&lt;dep type="pkg" rel="eq" version="1.0"&gt;Deppackage&lt;/dep&gt;</code>, the PEAR installer would look at the dependencies for the new version with <code class="literal">&lt;dep type="pkg" rel="eq" version="1.1"&gt;Deppackage&lt;/dep&gt;</code> then look on disk to see that Deppackage version 1.0 was installed, and fail to upgrade. Even if both the main package and Deppackage were passed in, upgrade of Deppackage would fail because the installed version of the main package requires version 1.0 of Deppackage.
</p></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Dependencies on PECL extension-based packages cannot work</em></span>. A<code class="literal">&lt;dep type="ext" rel="has"&gt;peclextension&lt;/dep&gt;</code> will only check for an extension in memory. Most PECL extensions can either be built directly into PHP (non-shared), distributed with PHP as a shared module, or downloaded and installed. If a PECL extension is built into PHP, distributed as a shared module, or installed via PECL, the<code class="literal"> type="ext"</code> dependency will work just fine. Unfortunately, in order to upgrade the extension using the PEAR installer,<code class="literal"> php.ini</code> must be disabled otherwise file locking will prevent overwriting the extension when it is in use by the current PHP process. Newer extensions such as PDO have drivers that depend on the PDO extension being present for installation. If<code class="literal"> php.ini</code> is disabled, there is no way to detect extensions to validate dependencies!</li></ul></div><div class="section" title="Simplifying XML Validation of package.xml"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec01"/>Simplifying XML Validation of package.xml</h4></div></div></div><p>In order to make it possible to validate dependencies with external tools, the structure needed to be redesigned. Generally, using tags in preference to attributes and particularly in preference to attribute values is the approach used in<code class="literal"> package.xml 2.0</code>. The dependency examples from<code class="literal"> package.xml 1.0</code> can be represented in<code class="literal"> package.xml 2.0</code> with:<a id="id79" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;dependencies&gt;
&lt;required&gt;
&lt;php&gt;
&lt;min&gt;4.2.0&lt;/min&gt;
&lt;/php&gt;
&lt;pearinstaller&gt;
&lt;min&gt;1.4.1&lt;/min&gt;
&lt;/pearinstaller&gt;
&lt;package&gt;
&lt;name&gt;Packagename&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;/package&gt;
&lt;package&gt;
&lt;name&gt;PackageName2&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;min&gt;1.0&lt;/min&gt;
&lt;/package&gt;
&lt;package&gt;
&lt;name&gt;ExtensionName&lt;/name&gt;
&lt;channel&gt;pecl.php.net&lt;/channel&gt;
&lt;providesextension&gt;ExtensionName&lt;/providesextension&gt;
&lt;conflicts/&gt;
&lt;/package&gt;
&lt;/required&gt;
&lt;optional&gt;
&lt;package&gt;
&lt;name&gt;PackageName3&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;min&gt;1.0&lt;/min&gt;
&lt;exclude&gt;1.0&lt;/exclude&gt;
&lt;/package&gt;
&lt;/optional&gt;
&lt;/dependencies&gt;
</pre></div><p>Note that attributes<code class="literal"> optional="yes"</code> and the implied<code class="literal"> optional="no"</code> have both been extracted out of the<code class="literal">&lt;dep&gt;</code> tag into the tags<code class="literal">&lt;required&gt;</code> and<code class="literal">&lt;optional&gt;</code>. In addition, the<code class="literal"> type</code> attribute has been extracted out into the tags<code class="literal">&lt;package&gt;, &lt;php&gt;</code>, and the previously undefined<code class="literal">&lt;pearinstaller&gt;</code> tag. Finally, both the<code class="literal"> rel</code> and the<code class="literal"> version</code> attributes have been completely replaced with a new set of tags.<a id="id80" class="indexterm"/>
</p><p>In<code class="literal"> package.xml 1.0</code>, in order to define a version set for a single dependency, multiple<code class="literal">&lt;dep&gt;</code> tags were needed:</p><div class="informalexample"><pre class="programlisting">&lt;dep type="pkg" rel="ge" version="1.2.3"&gt;PackageName&lt;/dep&gt;
&lt;dep type="pkg" rel="ne" version="1.3.0"&gt;PackageName&lt;/dep&gt;
&lt;dep type="pkg" rel="lt" version="2.0.0"&gt;PackageName&lt;/dep&gt;
</pre></div><p>This can be compared to the<code class="literal"> package.xml 2.0</code> equivalent:</p><div class="informalexample"><pre class="programlisting">&lt;package&gt;
&lt;name&gt;PackageName&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;min&gt;1.2.3&lt;/min&gt;
&lt;max&gt;2.0.0&lt;/max&gt;
&lt;exclude&gt;1.3.0&lt;/exclude&gt;
&lt;exclude&gt;2.0.0&lt;/exclude&gt;
&lt;/package&gt;
</pre></div><p>In fact, this change promotes much simpler debugging of dependency problems in complex<code class="literal"> package.xml</code> file. The above dependency easily translates into English as "Package PackageName from channel <a class="ulink" href="http://pear.php.net"> pear.php.net</a>, minimum version 1.2.3, maximum version 2.0.0, excluding versions 1.3.0 and 2.0.0." Not only is it easier to detect errors using tools like<code class="literal"> xmllint</code>, it is much easier to comprehend complex versioning of dependencies.<a id="id81" class="indexterm"/>
</p><p>The<code class="literal"> rel/version</code> duo has been effectively made obsolete by the combination of<code class="literal">&lt;min&gt;/&lt;max&gt;/&lt;exclude&gt;</code> tags. These three tags can be thought of as newer implementations of<code class="literal"> rel's ge, le</code>, and<code class="literal"> ne:</code>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;min&gt;1.2.0&lt;/min&gt;</code> =<code class="literal">&lt;dep rel="ge" version="1.2.0"&gt;</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;max&gt;1.2.0&lt;/max&gt;</code> =<code class="literal">&lt;dep rel="le" version="1.2.0"&gt;</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">&lt;exclude&gt;1.2.0&lt;/exclude&gt;</code> =<code class="literal">&lt;dep rel="ne" version="1.2.0"&gt;</code></li></ul></div><p>With these three tags, we can effectively and simply define any version set in a single dependency, without needing to think in terms of mathematical comparison operators.</p></div><div class="section" title="Managing Trust of Dependencies"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec02"/>Managing Trust of Dependencies</h4></div></div></div><p>The PEAR installer is extremely lithe, making upgrading to newer versions of packages so simple; until PEAR version 1.4.0 its greatest strength was also its greatest weakness. The ability to easily upgrade packages, as well as the ability to perform batch-automated upgrades with commands like<code class="literal"> upgrade-all</code> and<code class="literal"> download-all</code> followed by<code class="literal"> upgrade</code> is one of the key selling points of the installer. However, this ease is built upon an implicit trust in the quality of newer versions. By depending on packages with a simple<code class="literal">&lt;dep type="pkg" rel="ge" version="X.Y.Z"&gt;</code>, this gives a carte blanche to the developers of the dependent package. If a dependent package's developer introduces a break with previous releases, whether through carelessness or lack of sympathy for your code, your end users are in trouble. For this reason, bundling dependencies directly in the code has become a favored means of distributing applications. This, however, negates the primary benefit of the PEAR installer — the ability to quickly and easily upgrade in case of the discovery of serious bugs like functionality failures, or worse, subtle security vulnerabilities that open up a site to external attack. This also puts the burden of maintaining the bundled dependencies directly upon the application maintainer, reducing the efficiency of distributed development and all of its contingent benefits.<a id="id82" class="indexterm"/>
</p><p>
<code class="literal">package.xml 2.0</code> solves this dilemma simply and elegantly through the introduction of a new dependency concept: recommended version. This dependency can be taken from PEAR's<code class="literal"> package.xml:</code>
</p><div class="informalexample"><pre class="programlisting">&lt;package&gt;
&lt;name&gt;Console_Getopt&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;min&gt;1.2&lt;/min&gt;
&lt;/package&gt;
</pre></div><p>This instructs the installer to upgrade<code class="literal"> Console_Getopt</code> at will to any release of<code class="literal"> Console_Getopt</code>, version<code class="literal"> 1.2</code> or newer. By changing the dependency to:</p><div class="informalexample"><pre class="programlisting">&lt;package&gt;
&lt;name&gt;Console_Getopt&lt;/name&gt;
&lt;channel&gt;pear.php.net&lt;/channel&gt;
&lt;min&gt;1.2&lt;/min&gt;
&lt;recommended&gt;1.2&lt;/recommended&gt;
&lt;/package&gt;
</pre></div><p>This changes everything. Now, the installer will not automatically upgrade to version 1.3.0 upon release, unless the<code class="literal"> --force</code> or<code class="literal"> --loose</code> option is passed, or a<code class="literal">&lt;compatible&gt;</code> tag is present in the release of<code class="literal"> Console_Getopt</code>.</p><p>The syntax of<code class="literal">&lt;compatible&gt;</code> is simple:</p><div class="informalexample"><pre class="programlisting">&lt;compatible&gt;
&lt;name&gt;ParentPackage&lt;/name&gt;
&lt;channel&gt;pear.example.com&lt;/channel&gt;
&lt;min&gt;1.0.0&lt;/min&gt;
&lt;max&gt;1.3.0&lt;/max&gt;
&lt;exclude&gt;1.1.2&lt;/exclude&gt; [optional]
&lt;/compatible&gt;
</pre></div><p>As in dependencies,<code class="literal">&lt;min&gt;/&lt;max&gt;/&lt;exclude&gt;</code> is used to define a set of versions that the package is guaranteed to be compatible with. Unlike dependencies, the<code class="literal">&lt;max&gt;</code> tag is required to limit the set of versions. In addition, the set of versions must be limited to actual existing releases that have been tested.<a id="id83" class="indexterm"/>
</p><p>In theory, it is still possible for lazy developers to implement a<code class="literal">&lt;compatible&gt;</code> tag that is every bit as dangerous as the old<code class="literal"> rel="ge"-based</code> technique of dependency management, but this is both unlikely due to the principle of developer inertia and easy to catch and correct for the developer whose application depends on the dependency.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip16"/>Tip</h3><p><span class="strong"><strong>The Principle of Developer Inertia</strong></span></p><p>Developers, like electrons, will choose the path of least resistance to achieve their goals. Make it difficult to write bad code and easy to write good code, and developers will write good code.</p></div></div><div class="section" title="Reliably Depending on PECL Packages"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec03"/>Reliably Depending on PECL Packages</h4></div></div></div><p>Reliably depending on PECL packages has become possible due to two innovations:<a id="id84" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The split of the<code class="literal"> pear</code> script into two scripts:<code class="literal"> pear</code> and<code class="literal"> pecl</code></li><li class="listitem">The introduction of the<code class="literal">&lt;providesextension&gt;</code> tag</li></ol></div><p>The primary difference between the<code class="literal"> pear</code> and<code class="literal"> pecl</code> commands can be summarized as: "Use<code class="literal"> pear</code> to manage packages written in PHP like those at <a class="ulink" href="http://pear.php.net"> pear.php.net</a>, and use<code class="literal"> pecl</code> to manage packages extending PHP like those at <a class="ulink" href="http://pecl.php.net"> pecl.php.net</a>." Technically, the<code class="literal"> pecl</code> command disables<code class="literal"> php.ini</code>, and defaults to the <a class="ulink" href="http://pecl.php.net"> pecl.php.net</a> channel, but otherwise it is identical to the<code class="literal"> pear</code> command. Disabling<code class="literal"> php.ini</code> makes it possible to upgrade extensions that are inside<code class="literal"> php.ini</code> without unloading them.</p><p>The<code class="literal">&lt;providesextension&gt;</code> tag is used in dependencies as follows:</p><div class="informalexample"><pre class="programlisting">&lt;package&gt;
&lt;name&gt;PDO&lt;/name&gt;
&lt;channel&gt;pecl.php.net&lt;/channel&gt;
&lt;min&gt;1.0&lt;/min&gt;
&lt;providesextension&gt;PDO&lt;/providesextension&gt;
&lt;/package&gt;
</pre></div><p>This simple addition instructs the installer to treat the package dependency on<code class="literal"> PDO</code> as if it were a combination of these two dependencies:</p><div class="informalexample"><pre class="programlisting">&lt;extension&gt;
&lt;name&gt;PDO&lt;/name&gt;
&lt;min&gt;1.0&lt;/min&gt;
&lt;/extension&gt;
&lt;package&gt;
&lt;name&gt;PDO&lt;/name&gt;
&lt;channel&gt;pecl.php.net&lt;/channel&gt;
&lt;min&gt;1.0&lt;/min&gt;
&lt;/package&gt;
</pre></div><p>The installer will first check to see if the<code class="literal"> PDO</code> extension is present in memory, version 1.0 or newer, and if it is not, it will check the package registry to see if <a class="ulink" href="http://pecl.php.net/PDO"> pecl.php.net/PDO</a> version 1.0 or newer is installed. This allows, for instance, installation of production extensions for an Apache-based PEAR installation using a CLI-based PEAR installer without requiring the CLI-based installer to load each extension into its<code class="literal"> php.ini</code>. In addition, it allows extensions like<code class="literal"> PDO_mysql</code> to depend on<code class="literal"> PDO</code> without requiring the<code class="literal"> PDO</code> extension to be loaded in memory, greatly simplifying the end user experience.<a id="id85" class="indexterm"/>
</p></div></div><div class="section" title="Release Notes"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec07"/>Release Notes</h3></div></div></div><p>In both<code class="literal"> package.xml 1.0</code> and<code class="literal"> package.xml 2.0</code>, release notes are defined by the<code class="literal">&lt;notes&gt;</code> tag. The format of this tag is any text.<a id="id86" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;notes&gt;
Minor bugfix release
These bugs are fixed:
* Bug #1234: stupid politicians elected to office
* Bug #2345: I guess we voted for them didn't we
&lt;/notes&gt;
</pre></div></div><div class="section" title="Release License"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec08"/>Release License</h3></div></div></div><p>The text of the<code class="literal">&lt;license&gt;</code> tag is not validated — anything may be entered there.<a id="id87" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;license&gt;BSD license&lt;/license&gt;
</pre></div><p>In<code class="literal"> package.xml 2.0</code> there are optional attributes<code class="literal"> uri</code> and<code class="literal"> filesource</code> for linking a license to an online version and also to a specific license file within the package itself.</p><div class="informalexample"><pre class="programlisting">&lt;license uri="http://www.opensource.org/licenses/bsd-license.php"&gt;BSD
license&lt;/license&gt;
</pre></div></div><div class="section" title="Changelog"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec09"/>Changelog</h3></div></div></div><p>The format of changelog in<code class="literal"> package.xml 1.0</code> matches the format of a<code class="literal">&lt;release&gt;</code> tag with the exception that<code class="literal">&lt;filelist&gt;</code> is not allowed. The changelog is purely information for human purposes, and is not processed at all by the installer. The format for a changelog in<code class="literal"> package.xml 2.0</code> is very similar to that of<code class="literal"> package.xml 1.0</code>, and is best illustrated by an example:<a id="id88" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;release&gt;
&lt;version&gt;
&lt;release&gt;1.3.6&lt;/release&gt;
&lt;api&gt;1.3.0&lt;/api&gt;
&lt;/version&gt;
&lt;stability&gt;
&lt;release&gt;stable&lt;/release&gt;
&lt;api&gt;stable&lt;/api&gt;
&lt;/stability&gt;
&lt;date&gt;2005-08-18&lt;/date&gt;
&lt;license uri="http://www.php.net/license"&gt;PHP License&lt;/license&gt;
&lt;notes&gt;
* Bump XML_RPC dependency to 1.4.0
* return by reference from PEAR::raiseError()
&lt;/notes&gt;
&lt;/release&gt;
</pre></div><p>Like the release section of<code class="literal"> package.xml</code>, the tags<code class="literal">&lt;version&gt;, &lt;stability&gt;, &lt;date&gt;, &lt;license&gt;</code>, and<code class="literal">&lt;notes&gt;</code> are all present. This is identical to<code class="literal"> package.xml 1.0</code>. The only difference is the format of the<code class="literal">&lt;version&gt;, &lt;stability&gt;</code>, and<code class="literal">&lt;license&gt;</code> tags, which match the changes made in<code class="literal"> package.xml 2.0</code>.<a id="id89" class="indexterm"/>
</p></div><div class="section" title="File List, or Contents of the Package"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec10"/>File List, or Contents of the Package</h3></div></div></div><p>The primary purpose of PEAR, and by consequence,<code class="literal"> package.xml</code> is to distribute files containing programming code. This is ultimately controlled by the list of files that are in a package, as defined by<code class="literal">&lt;filelist&gt;</code> or<code class="literal">&lt;contents&gt;.</code>
<a id="id90" class="indexterm"/>
</p><p>For<code class="literal"> package.xml 1.0:</code>
</p><div class="informalexample"><pre class="programlisting">&lt;filelist&gt;
&lt;dir name="OS"&gt;
&lt;file role="php" name="Guess.php"&gt;
&lt;replace from="@package_version@" to="version" type="package-
info" /&gt;
&lt;/file&gt;
&lt;/dir&gt;
&lt;dir name="PEAR"&gt;
&lt;dir name="ChannelFile" baseinstalldir="Foo"&gt;
&lt;file name="Parser.php" role="php"&gt;
&lt;replace from="@package_version@" to="version" type="package-
info" /&gt;
&lt;/file&gt;
&lt;/dir&gt;
&lt;file role="data" name="Foo.dat"/&gt;
&lt;/dir&gt;
&lt;file role="doc" name="linux-Howto.doc" install-as="README"
platform="!windows"/&gt;
&lt;file role="doc" name="windows-Howto.doc" install-as="README"
platform="windows"/&gt;
&lt;/filelist&gt;
</pre></div><p>For<code class="literal"> package.xml 2.0:</code>
</p><div class="informalexample"><pre class="programlisting">&lt;contents&gt;
&lt;dir name="/"&gt;
&lt;dir name="OS"&gt;
&lt;file name="Guess.php" role="php"&gt;
&lt;tasks:replace from="@package_version@" to="version"
type="package-info"/&gt;
&lt;/file&gt;
&lt;/dir&gt;
&lt;dir name="PEAR"&gt;
&lt;dir name="ChannelFile" baseinstalldir="Foo"&gt;
&lt;file name="Parser.php" role="php"&gt;
&lt;tasks:replace from="@package_version@" to="version"
type="package-info"/&gt;
&lt;/file&gt;
&lt;/dir&gt;
&lt;file role="data" name="Foo.dat"/&gt;
&lt;/dir&gt;
&lt;file role="doc" name="linux-Howto.doc"/&gt;
&lt;file role="doc" name="windows-Howto.doc"/&gt;
&lt;/dir&gt;
&lt;/contents&gt;
</pre></div><p>This tag is the heart of<code class="literal"> package.xml</code> file. Once our trusty package has weathered dependency tests, this is the section of<code class="literal"> package.xml</code> that is actually used during installation.<a id="id91" class="indexterm"/>
</p><p>The file listing inside a<code class="literal"> package.xml</code> is used to define the directory structure inside a release. It must reflect exactly the relative locations of files as they were on the computer of the developer. In other words, if the<code class="literal"> package.xml</code> is in directory<code class="literal"> /home/frank/mypackage/</code>, and a file in<code class="literal"> package.xml</code> is located at<code class="literal"> /home/frank /mypackage/foo/test.php</code>, it must be listed as:<a id="id92" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;file role="php" name="foo/test.php"/&gt;
</pre></div><p>Or, alternately as:</p><div class="informalexample"><pre class="programlisting">&lt;dir name="foo"&gt;
&lt;file role="php" name="test.php"/&gt;
&lt;/dir&gt;
</pre></div><p>Either alternative will yield the same result. At installation time, PEAR will automatically convert all recursive directory trees like the second example into a single flat branch like the first example.</p></div></div></div>
<div class="section" title="New Tags in package.xml"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec06"/>New Tags in package.xml</h1></div></div></div><p>
<code class="literal">package.xml 2.0</code> introduced the new tags<code class="literal">&lt;phprelease&gt;, &lt;extsrcrelease&gt;</code>, and<code class="literal">&lt;extbinrelease&gt;</code> to differentiate between the different kinds of packages the PEAR installer handles.<code class="literal"> package.xml 2.1</code> introduces<code class="literal">&lt;zendextsrcrelease&gt;</code> and <code class="literal">&lt;zendextbinrelease&gt;</code> in order to differentiate between regular PHP extensions and Zend extensions like<code class="literal"> xdebug</code> ( <a class="ulink" href="http://pecl.php.net/xdebug">http://pecl.php.net/xdebug</a>).<a id="id93" class="indexterm"/>
</p><p>You may have noticed that the primary tag in<code class="literal"> package.xml 1.0</code> is named<code class="literal">&lt;filelist&gt;</code>, whereas the primary tag in<code class="literal"> package.xml 2.0</code> is named<code class="literal">&lt;contents&gt;</code>. This change came about as a result of a simple feature request. When PEAR 1.3.3 was popular, the need to customize installations grew; more and more attributes and information were crammed into the<code class="literal">&lt;file&gt;</code> tag. The<code class="literal"> platform</code> attribute tells the installer that a file should only be installed on a particular platform, such as UNIX or Windows. This is used in the PEAR package in order to install the<code class="literal"> pear</code> command using a<code class="literal"> schell</code> script on UNIX, and using a<code class="literal"> .bat</code> batch file on Windows. The feature request that came in was to implement an additional<code class="literal"> platform="!windows"</code> hack that would tell the installer to install the file on every platform except Windows. This introduces a number of problems. As package complexity grows, and more systems are supported, it may be necessary to specify a limited list of systems a file can be installed on, or different names to install the file as required on different systems. Implementation of this would require a sophisticated mapping between the<code class="literal"> install-as</code> and the<code class="literal"> platform</code> attributes, something that was not anticipated by the designers of<code class="literal"> package.xml 1.0</code>, and something that would introduce a miserable mess into a single file tag. Imagine encountering this nightmare and trying to debug it:<a id="id94" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;file name="Foo.scr" role="script" install-
as="windows=Foo.bat;Darwim=Fooscr;unix=Foo;"
platform="windows;!Solaris;unix"/&gt;
</pre></div><p>Do you see the typo buried deep in the install-as attribute?</p><p>One day while working on the problem caused by the spectre of such horribly complex features, it struck me that attributes like the<code class="literal"> platform</code> attribute were actually kludgy ways of implementing dependencies for a specific file. Suddenly, the answer was clear. Far better than extending the attribute's meaning would be abstracting the information into separate release tags. Each release tag would have a file list and installation conditions that would define which one should be used on an end user's computer. For instance, instead of:</p><div class="informalexample"><pre class="programlisting">&lt;file role="doc" name="linux-Howto.doc" install-as="README"
platform="!windows"/&gt;
&lt;file role="doc" name="windows-Howto.doc" install-as="README"
platform="windows"/&gt;
</pre></div><p>We would have:</p><div class="informalexample"><pre class="programlisting">&lt;file role="doc" name="linux-Howto.doc"/&gt;
&lt;file role="doc" name="windows-Howto.doc"/&gt;
...
&lt;phprelease&gt;
&lt;installconditions&gt;
&lt;os&gt;windows&lt;/os&gt;
&lt;/installconditions&gt;
&lt;filelist&gt;
&lt;install name="windows-Howto.doc" as="README"/&gt;
&lt;ignore name="linux-Howto.doc"/&gt;
&lt;/filelist&gt;
&lt;/phprelease&gt;
&lt;phprelease&gt;
&lt;filelist&gt;
&lt;install name="linux-Howto.doc" as="README"/&gt;
&lt;ignore name="windows-Howto.doc"/&gt;
&lt;/filelist&gt;
&lt;/phprelease&gt;
</pre></div><p>However, the most obvious benefit comes from the horrible "Darwin" example. This would translate from:</p><div class="informalexample"><pre class="programlisting">&lt;file name="Foo.scr" role="script" install-
as="windows=Foo.bat;Darwim=Fooscr;unix=Foo;"
platform="windows;!Solaris;unix"/&gt;
</pre></div><p>to:</p><div class="informalexample"><pre class="programlisting">&lt;file name="Foo.scr" role="script"/&gt;
...
&lt;phprelease&gt;
&lt;installconditions&gt;
&lt;os&gt;windows&lt;/os&gt;
&lt;/installconditions&gt;
&lt;filelist&gt;
&lt;install name="Foo.scr" as="Foo.bat"/&gt;
&lt;/filelist&gt;
&lt;/phprelease&gt;
&lt;phprelease&gt;
&lt;installconditions&gt;
&lt;os&gt;Darwim&lt;/os&gt;
&lt;/installconditions&gt;
&lt;filelist&gt;
&lt;install name="Foo.scr" as="Fooscr"/&gt;
&lt;/filelist&gt;
&lt;/phprelease&gt;
&lt;phprelease&gt;
&lt;installconditions&gt;
&lt;arch&gt;Solaris&lt;/arch&gt;
&lt;/installconditions&gt;
&lt;filelist&gt;
&lt;ignore name="Foo.scr"/&gt;
&lt;/filelist&gt;
&lt;/phprelease&gt;
&lt;phprelease&gt;
&lt;installconditions&gt;
&lt;os&gt;unix&lt;/os&gt;
&lt;/installconditions&gt;
&lt;filelist&gt;
&lt;install name="Foo.scr" as="Foo"/&gt;
&lt;/filelist&gt;
&lt;/phprelease&gt;
</pre></div><p>Here, the potential for simple validation is obvious: the<code class="literal">&lt;os&gt;</code> install condition is limited to a few known possibilities such as<code class="literal"> windows, unix, linux, Darwin</code>, and so on. The OS "Darwim" would simply refuse to validate. In addition, the complexity of how<code class="literal"> Foo.scr</code> is handled is grouped by OS rather than stuffed into a couple of attributes with error-prone non-XML syntax.<a id="id95" class="indexterm"/>
</p></div>
<div class="section" title="File/Directory Attributes: name, role, and baseinstalldir"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec07"/>File/Directory Attributes: name, role, and baseinstalldir</h1></div></div></div><p>The<code class="literal">&lt;file&gt;</code> and<code class="literal">&lt;dir&gt;</code> tags have a number of options available to them. Both tags require a<code class="literal"> name</code> attribute, defining the name of the element as located on disk. Unlike an operating system,<code class="literal"> package.xml</code> does not allow empty directories. All<code class="literal">&lt;dir&gt;</code> tags must contain at least one<code class="literal">&lt;file&gt;</code> tag. As described in the previous section, there are two ways to describe the location of a file in<code class="literal"> package.xml</code>, either with a complete relative path separated by the UNIX path separator<code class="literal"> /:</code>
<a id="id96" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;file role="php" name="foo/test.php"/&gt;
</pre></div><p>Or, alternately as:</p><div class="informalexample"><pre class="programlisting">&lt;dir name="foo"&gt;
&lt;file role="php" name="test.php"/&gt;
&lt;/dir&gt;
</pre></div><p>All files must have a<span class="strong"><strong> role</strong></span> attribute. This attribute tells the installer how to handle a file. The default list of allowed file roles is:<a id="id97" class="indexterm"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Default File Roles</p>
</th><td class="auto-generated"> </td></tr><tr><th style="text-align: left" valign="bottom">
<p>Role</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>php</p>
</td><td style="text-align: left" valign="top">
<p>PHP script files, like "PEAR.php"</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>data</p>
</td><td style="text-align: left" valign="top">
<p>Data files used by the script (read-only)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>doc</p>
</td><td style="text-align: left" valign="top">
<p>Documentation files</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>test</p>
</td><td style="text-align: left" valign="top">
<p>Test scripts, unit test files</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>script</p>
</td><td style="text-align: left" valign="top">
 <p>Executable script files <code class="literal">(pear.bat, pear.sh)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>ext</p>
</td><td style="text-align: left" valign="top">
<p>PHP Extension binaries <code class="literal">(php_mysql.dll)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>src</p>
</td><td style="text-align: left" valign="top">
<p>PHP Extension source files <code class="literal">(mysql.c)</code></p>
</td></tr></tbody></table></div><p>Each file role has a configuration value associated with it. For instance, on my Windows XP system, here is what I see when I list configuration values:<a id="id98" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>C:\&gt;pear config-show
CONFIGURATION (CHANNEL PEAR.PHP.NET):
=====================================
Auto-discover new Channels auto_discover &lt;not set&gt;
Default Channel default_channel pear.php.net
HTTP Proxy Server Address http_proxy &lt;not set&gt;
PEAR server [DEPRECATED] master_server pear.php.net
Default Channel Mirror preferred_mirror pear.php.net
Remote Configuration File remote_config &lt;not set&gt;
PEAR executables directory bin_dir C:\php4
PEAR documentation directory doc_dir C:\php4\PEAR\docs
PHP extension directory ext_dir C:\php4\extensions
PEAR directory php_dir C:\php4\PEAR
PEAR Installer cache directory cache_dir C:\DOCUME~1\GREGBE~1\LOCALS~1\
Temp\pear\cache
PEAR data directory data_dir C:\php4\PEAR\data
PHP CLI/CGI binary php_bin C:\php-4.3.8\cli\php.exe
PEAR test directory test_dir C:\php4\PEAR\tests
Cache TimeToLive cache_ttl 3600
Preferred Package State preferred_state stable
Unix file mask umask 0
Debug Log Level verbose 1
PEAR password (for password &lt;not set&gt; maintainers)
Signature Handling Program sig_bin c:\gnupg\gpg.exe
Signature Key Directory sig_keydir C:\php4\pearkeys
Signature Key Id sig_keyid &lt;not set&gt; Package
Signature Type sig_type gpg
PEAR username (for username &lt;not set&gt; maintainers)
User Configuration File Filename C:\php4\pear.ini
System Configuration File Filename C:\php4\pearsys.ini</strong></span>
</pre></div><p>In some cases, especially for subpackages like<code class="literal"> HTML_QuickForm_Controller</code> ( <a class="ulink" href="http://pear.php.net/package/HTML_QuickForm_Controller">http://pear.php.net/package/HTML_QuickForm_Controller</a>), all files should be installed into a subdirectory (HTML/QuickForm/Controller in our example). In order to reflect this installation path in our file, we would need to prepend all files with the full path, like so:<a id="id99" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;file role="php" name="HTML/QuickForm/Controller.php"/&gt;
&lt;file role="php" name="HTML/QuickForm/Controller/Action.php"/&gt;
</pre></div><p>Or, alternately use<code class="literal">&lt;dir&gt;</code> tags as follows:</p><div class="informalexample"><pre class="programlisting">&lt;dir name="HTML"&gt;
&lt;dir name="QuickForm"&gt;
&lt;dir name="Controller"&gt;
&lt;file role="php" name="Action.php"/&gt;
&lt;/dir&gt;
&lt;file role="php" name="Controller.php"/&gt;
&lt;/dir&gt;
&lt;/dir&gt;
</pre></div><p>In addition, our actual development path would need to reflect this. This does not fit the "make everything easy for lazy developers" development paradigm very well, and so PEAR provides the<code class="literal"> baseinstalldir</code> attribute to simplify things. Now, all we need is:</p><div class="informalexample"><pre class="programlisting">&lt;file role="php" baseinstalldir="HTML/QuickForm" name=" Controller.php"/&gt;
&lt;file role="php" baseinstalldir="HTML/QuickForm" name=" Controller/Action.php"/&gt;
</pre></div><p>Or, the far more common:<a id="id100" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;dir name="/" baseinstalldir="HTML/QuickForm"&gt;
&lt;dir name="Controller"&gt;
&lt;file role="php" name="Action.php"/&gt;
&lt;/dir&gt;
&lt;file role="php" name="Controller.php"/&gt;
&lt;/dir&gt;
</pre></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip17"/>Tip</h3><p><span class="strong"><strong>Path Locations on the Development Machine</strong></span></p><p>Note that as a developer, in order for this to work, the actual paths on disk must match the<code class="literal">&lt;dir&gt;/&lt;file&gt;</code> tags. In our example above, the files should be in:</p><p>
<code class="literal">Controller/Action.php Controller.php package.xml</code>
</p><p>Rather than:</p><p>
<code class="literal">HTML/QuickForm/Controller/Action.php HTML/QuickForm/Controller.php package.xml</code>
</p><p>Otherwise the PEAR installer will be unable to find the files.</p></div><p>Generally speaking, if a file is listed in<code class="literal"> package.xml</code> as:</p><div class="informalexample"><pre class="programlisting">&lt;file role="php" name="Path/To/Foo.php"/&gt;
</pre></div><p>And<code class="literal"> php_dir</code> is<code class="literal"> C:\php4\PEAR</code>, the file will be installed into<code class="literal"> C:\php4\PEAR\Path\To\Foo.php</code>. This is not always advantageous, especially for things like scripts. PEAR, for instance, places all of its scripts in the<code class="literal"> scripts/</code> subdirectory for easier organization. However, this would mean that if<code class="literal"> bin_dir</code> is<code class="literal"> C:\php4</code>,</p><div class="informalexample"><pre class="programlisting">&lt;file role="script" name="scripts/pear.bat"/&gt;
</pre></div><p>will be installed into<code class="literal"> C:\php4\scripts\pear.bat</code>, which may not necessarily be in the path. To change the base installation directory in PEAR 1.4.x, you need to use an<code class="literal">&lt;install&gt;</code> tag inside a release tag, In addition, it is possible to perform text transformations on the contents of files.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec08"/>Summary</h1></div></div></div><p>In this chapter, we discovered the basics of how the PEAR installer's internals work through the lens of<code class="literal"> package.xml's</code> structure. First, we explored the basic design philosophies of the PEAR installer, and how PEAR packages differ from the old-fashioned unzip-and-go approach. We learned about PEAR's configuration options, and the versatile ways in which PEAR deals with libraries versus applications.</p><p>Next, we explored the importance of versioning in controlling the quality of packages installed, and the importance of dependencies, and how the PEAR installer manages this important link between libraries and applications. Then, we explored how easy it is to upgrade when using the PEAR installer, as compared to upgrading traditional unzip-and-go applications.</p><p>After this, we dove headfirst into the structure of<code class="literal"> package.xml</code>, learning how package metadata such as the package name, authors, release notes, and changelog are organized. This was coupled with a look at how critical installation data such as files, dependencies, and versioning is organized.</p><p>The next chapter will examine advanced topics, specifically how<code class="literal"> package.xml 2.0</code> introduces better application support, and how to leverage these new features in your own packages.</p></div></body></html>