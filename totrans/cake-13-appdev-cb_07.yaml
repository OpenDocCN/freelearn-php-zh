- en: Chapter 7. Creating and Consuming Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。创建和消费网络服务
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating an RSS feed
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 RSS 源
- en: Consuming a JSON service
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费 JSON 服务
- en: Building REST services with JSON
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSON 构建 REST 服务
- en: Adding authentication to REST services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 REST 服务添加身份验证
- en: Implementing token-based authorization for API access
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 API 访问实现基于令牌的授权
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Web services are essential when looking forward to expose application functionality
    to third-party applications, or when looking forward to integrate foreign services
    into our own applications. They offer a broad set of technologies and definitions
    so that systems written in different programming languages can communicate.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望向第三方应用程序公开应用程序功能或希望将外部服务集成到我们自己的应用程序中时，网络服务是必不可少的。它们提供了一套广泛的技术和定义，以便使用不同编程语言编写的系统可以相互通信。
- en: This chapter introduces a set of recipes to consume web services, and to expose
    parts of our application as web services.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一系列菜谱，用于消费网络服务以及将我们应用程序的某些部分公开为网络服务。
- en: Creating an RSS feed
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 RSS 源
- en: RSS feeds are a form of web services, as they provide a service, over the web,
    using a known format to expose data. Due to their simplicity, they are a great
    way to introduce us to the world of web services, particularly as CakePHP offers
    a built in method to create them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: RSS 源是一种网络服务形式，因为它们通过互联网提供一种服务，使用已知格式来公开数据。由于它们的简单性，它们是介绍我们进入网络服务世界的好方法，尤其是
    CakePHP 提供了内置方法来创建它们。
- en: 'In the recipe *Consuming RSS feeds with a datasource* from [Chapter 5](ch05.html
    "Chapter 5. Datasources"), *Datasources*, we learned how to fetch content from
    a foreign RSS feed. In this recipe, will do exactly the opposite: produce a feed
    for our site that can be used by other applications.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 章](ch05.html "第 5 章。数据源") 的 *使用数据源消费 RSS 源* 菜谱中，我们学习了如何从外部 RSS 源获取内容。在这个菜谱中，我们将做完全相反的事情：为我们自己的网站生成一个可以被其他应用程序使用的源。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To go through this recipe we need a sample table to work with. Create a table
    named `posts`, using the following SQL statement:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个菜谱，我们需要一个示例表来操作。使用以下 SQL 语句创建一个名为 `posts` 的表：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add some sample data, using the following SQL statements:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下 SQL 语句添加一些示例数据：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We proceed now to create the required controller. Create the class `PostsController`
    in a file named `posts_controller.php` and place it in your `app/controllers`
    folder, with the following contents:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在继续创建所需的控制器。在 `app/controllers` 文件夹中创建一个名为 `posts_controller.php` 的类 `PostsController`，内容如下：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a folder named `posts` in your `app/views` folder, and then create the
    `index` view in a file named `index.ctp` and place it in your `app/views/posts`
    folder, with the following contents:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `app/views` 文件夹中创建一个名为 `posts` 的文件夹，然后在 `app/views/posts` 文件夹中创建一个名为 `index.ctp`
    的视图文件，并放置以下内容：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Edit your `app/config/routes.php` file and add the following statement at the
    end:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑你的 `app/config/routes.php` 文件，并在末尾添加以下语句：
- en: '[PRE4]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Edit your `app/controllers/posts_controller.php` file and add the following
    property to the `PostsController` class:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑你的 `app/controllers/posts_controller.php` 文件，并在 `PostsController` 类中添加以下属性：
- en: '[PRE5]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While still editing `PostsController`, make the following changes to the `index()`
    method:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑 `PostsController` 的同时，对 `index()` 方法进行以下更改：
- en: '[PRE6]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a folder named `rss` in your `app/views/posts` folder, and inside the
    `rss` folder create a file named `index.ctp`, with the following contents:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `app/views/posts` 文件夹中创建一个名为 `rss` 的文件夹，并在 `rss` 文件夹中创建一个名为 `index.ctp`
    的文件，内容如下：
- en: '[PRE7]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Edit your `app/views/posts/index.ctp` file and add the following at the end
    of the view:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑你的 `app/views/posts/index.ctp` 文件，并在视图末尾添加以下内容：
- en: '[PRE8]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you now browse to `http://localhost/posts`, you should see a listing of
    posts with a link entitled **Feed**. Clicking on this link should produce a valid
    RSS feed, as shown in the following screenshot:'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在浏览到 `http://localhost/posts`，你应该会看到一个包含名为 **Feed** 的链接的帖子列表。点击此链接应该会生成一个有效的
    RSS 源，如下面的截图所示：
- en: '![How to do it...](img/1926_07_01.jpg)'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1926_07_01.jpg)'
- en: 'If you view the source of the generated response, you can see that the source
    for the first item within the RSS document is:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看生成的响应的源代码，你可以看到 RSS 文档中第一个项目的源代码如下：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We started by telling CakePHP that our application accepts the `rss` extension
    with a call to `Router::parseExtensions()`, a method that accepts any number of
    extensions. Using extensions, we can create different versions of the same view.
    For example, if we wanted to accept both `rss` and `xml` as extensions, we would
    do:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`Router::parseExtensions()`方法来告诉CakePHP我们的应用程序接受`rss`扩展，这是一个接受任意数量扩展的方法。使用扩展，我们可以创建同一视图的不同版本。例如，如果我们想接受`rss`和`xml`作为扩展，我们会这样做：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In our recipe, we added `rss` to the list of valid extensions. That way, if
    an action is accessed using that extension, for example, by using the URL `http://localhost/posts.rss`,
    then CakePHP will identify `rss` as a valid extension, and will execute the `ArticlesController::index()`
    action as it normally would, but using the `app/views/posts/rss/index.ctp` file
    to render the view. The process also uses the file `app/views/layouts/rss/default.ctp`
    as its layout, or CakePHP's default RSS layout if that file is not present.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配置中，我们将`rss`添加到了有效扩展列表中。这样，如果通过该扩展访问操作，例如使用URL `http://localhost/posts.rss`，那么CakePHP会识别`rss`为有效扩展，并像平常一样执行`ArticlesController::index()`操作，但使用`app/views/posts/rss/index.ctp`文件来渲染视图。此过程还会使用文件`app/views/layouts/rss/default.ctp`作为布局，或者如果没有该文件，则使用CakePHP的默认RSS布局。
- en: We then modify how `ArticlesController::index()` builds the list of posts, and
    use the `RequestHandler` component to see if the current request uses the `rss`
    extension. If so, we use that knowledge to change the number and order of posts.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后修改了`ArticlesController::index()`方法构建帖子列表的方式，并使用`RequestHandler`组件来检查当前请求是否使用了`rss`扩展。如果是的话，我们就利用这一信息来改变帖子的数量和顺序。
- en: In the `app/views/posts/rss/index.ctp` view, we start by setting some view variables.
    Because a controller view is always rendered before the layout, we can add or
    change view variables from the view file, and have them available in the layout.
    CakePHP's default RSS layout uses a `$channel` view variable to describe the RSS
    feed. Using that variable, we set our feed's `title, link`, and `description`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app/views/posts/rss/index.ctp`视图文件中，我们首先设置一些视图变量。由于控制器视图总是在布局之前渲染，因此我们可以从视图文件中添加或更改视图变量，并在布局中使用它们。CakePHP的默认RSS布局使用`$channel`视图变量来描述RSS源。通过使用该变量，我们设置了我们的源标题`title`、链接`link`和描述`description`。
- en: We proceed to output the actual item files. There are different ways to do so,
    the first one is making a call to the `RssHelper::item()` method for each item,
    and the other one requires only a call to `RssHelper::items()`, passing it an
    array of items. We chose the latter method due to its simplicity.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续输出实际的条目文件。有几种不同的方法可以做到这一点，第一种是为每个条目调用`RssHelper::item()`方法，另一种方法只需要调用`RssHelper::items()`，并传递一个包含条目的数组。我们选择了后者，因为它更简单。
- en: While we build the array of items to be included in the feed, we only specify
    `title, link, description`, and `pubDate`. Looking at the generated XML source
    for the item, we can infer that the `RssHelper` used our value for the `link`
    element as the value for the `guid` (globally unique identifier) element.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建要包含在源中的条目数组时，我们只指定`title`、`link`、`description`和`pubDate`。查看生成的XML源代码，我们可以推断出`RssHelper`使用了我们为`link`元素指定的值作为`guid`（全局唯一标识符）元素的值。
- en: Note that the `description` field is specified slightly differently than the
    values for the other fields in our item array. This is because our description
    may contain HTML code, so we want to make sure that the generated document is
    still a valid XML document.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`description`字段与其他字段在数组中的值指定略有不同。这是因为我们的描述可能包含HTML代码，因此我们想要确保生成的文档仍然是一个有效的XML文档。
- en: By using the array notation for the `description` field, a notation that uses
    the `value` index to specify the actual value on the field, and by setting `cdata`
    to `true`, we are telling the `RssHelper` (actually the `XmlHelper` from which
    `RssHelper` descends) that the field should be wrapped in a section that should
    not be parsed as part of the XML document, denoted between a `<![CDATA[` prefix
    and a`]]>` postfix.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`description`字段的数组表示法，使用`value`索引指定字段的实际值，并通过将`cdata`设置为`true`，我们告诉`RssHelper`（实际上是`XmlHelper`，`RssHelper`是从它派生出来的）该字段应该被包裹在一个不应作为XML文档一部分的区域内，该区域由`<![CDATA[`前缀和`]]>`后缀表示。
- en: The final task in this recipe is adding a link to our feed that is shown in
    the `index.ctp` view file. While creating this link, we set the special `ext`
    URL setting to `rss`. This sets the extension for the generated link, which ends
    up being `http://localhost/posts.rss`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的最后一项任务是向我们的 `index.ctp` 视图文件中添加一个链接。在创建此链接时，我们将特殊的 `ext` URL 设置为 `rss`。这设置了生成链接的扩展名，最终结果是
    `http://localhost/posts.rss`。
- en: Adding view caching to an RSS feed
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向 RSS 源添加视图缓存
- en: Our feeds may be consumed by feed search crawlers. If we are lucky, we may get
    tons and tons of requests looking for updates to our blog. It is unlikely that
    we will update our blog so often that we would have new posts every second, so
    our server load may force us to add some caching.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的内容源可能被内容搜索爬虫消费。如果我们很幸运，我们可能会收到大量的请求，寻找我们博客的更新。我们不太可能频繁更新我们的博客，以至于每秒都有新的帖子，因此我们的服务器负载可能迫使我们添加一些缓存。
- en: When looking to improve performance, some developers are content to only cache
    their database queries. In our recipe, this would mean caching the results obtained
    from our `$this->Post->find('all')` call. Unless we have our database engine on
    a separate server that suffers from some considerable network latency, chances
    are this sort of caching will offer little or no benefit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当试图提高性能时，一些开发者只满足于缓存他们的数据库查询。在我们的食谱中，这意味着缓存从我们的 `$this->Post->find('all')` 调用中获得的结果。除非我们的数据库引擎在单独的服务器上运行，并且遭受一些相当大的网络延迟，否则这种类型的缓存可能只会带来很少或没有好处。
- en: A much better solution is to use view caching. That is, caching the generated
    RSS feed, and using that cached document whenever a request is made to our feed,
    provided we are within the cache time. Fortunately, CakePHP offers us a view-caching
    implementation right from the dispatcher, speeding up the request considerably.
    If a cached view file is found, that file is rendered directly to the client,
    without any intervention by the controller, or the need to load models, components,
    or helpers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是使用视图缓存。也就是说，缓存生成的 RSS 源，并在请求我们的源时使用该缓存文档，前提是我们处于缓存时间内。幸运的是，CakePHP
    从调度器直接为我们提供了视图缓存实现，大大加快了请求速度。如果找到缓存的视图文件，则该文件将直接渲染到客户端，无需控制器干预，也不需要加载模型、组件或辅助器。
- en: We want to add caching only when our `PostsController::index()` action is accessed
    with the `rss` extension. That is, we don't want to cache the listing of posts,
    but its feed. So we will make sure to only specify caching information when a
    feed is requested. In fact, we are going to cache all actions in our `PostsController`
    whenever the `rss` extension is used.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想在通过 `rss` 扩展访问 `PostsController::index()` 动作时添加缓存。也就是说，我们不想缓存帖子列表，而是其源。因此，我们将确保只在请求源时指定缓存信息。实际上，我们将使用
    `rss` 扩展时缓存 `PostsController` 中的所有操作。
- en: 'The first thing we need to do is tell CakePHP to take view caching into account.
    Edit your `app/config/core.php` file and uncomment the following line:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是告诉 CakePHP 考虑视图缓存。编辑你的 `app/config/core.php` 文件，并取消注释以下行：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, edit your `app/controllers/posts_controller.php` file and add the `Cache`
    helper to the `PostsController` class. Without it, view caching will simply not
    work:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑你的 `app/controllers/posts_controller.php` 文件，并将 `Cache` 辅助器添加到 `PostsController`
    类中。没有它，视图缓存将无法正常工作：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'While still editing the `PostsController` class, add the following method:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续编辑 `PostsController` 类的同时，添加以下方法：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this `beforeFilter()` implementation, we are checking to see if the current
    request was made using the `rss` extension. If so, we add the current action (whatever
    that may be) to the list of cached actions, and set the cache time to be `1 hour`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `beforeFilter()` 实现中，我们正在检查当前请求是否使用了 `rss` 扩展。如果是这样，我们将当前操作（无论是什么）添加到缓存操作列表中，并将缓存时间设置为
    `1 小时`。
- en: If we access the feed multiple times within the hour, we should see the same
    feed we have been getting so far, but coming from the cache instead of being built
    in real time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在一小时内多次访问该源，我们应该看到我们迄今为止一直获得的相同源，但来自缓存而不是实时构建。
- en: See also
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Consuming RSS feeds with a datasource* in [Chapter 5](ch05.html "Chapter 5. Datasources"),
    *Datasources*.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用数据源消费 RSS 源* 在 [第 5 章](ch05.html "第 5 章。数据源")，*数据源*。'
- en: '*Building REST services with JSON*'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 JSON 构建 REST 服务*'
- en: Consuming a JSON service
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费 JSON 服务
- en: '**JSON** (**JavaScript Object Notation**) is probably one of the best formats
    available for exposing data, due to its easy-to-read syntax, which greatly simplifies
    the parsing. In fact, PHP (as of its 5.2.0 release) provides built-in methods
    to convert data from a JSON-formatted string to a PHP native data type and from
    PHP types to JSON.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**（**JavaScript对象表示法**）可能是目前公开数据格式中最好的之一，因为它易于阅读的语法大大简化了解析。实际上，PHP（自5.2.0版本起）提供了内置方法，可以将数据从JSON格式的字符串转换为PHP原生数据类型，以及从PHP类型转换为JSON。'
- en: In this recipe, we will learn how to use the `HttpSocket` class to consume a
    JSON service from a foreign site. This time, we are going to use the YouTube JSON
    API to allow our users to search for YouTube videos that match a given search
    query.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用`HttpSocket`类从外部网站消费JSON服务。这次，我们将使用YouTube JSON API，允许我们的用户搜索与给定搜索查询匹配的YouTube视频。
- en: The JSON service we will be consuming from YouTube uses a variant of JSON, called
    JSON-C. JSON-C is nothing more than JSON, but Google is making a distinction between
    what YouTube used to provide as JSON, and the new version it is now producing.
    YouTube's JSON-C-based responses are far simpler than their JSON service. Consequently,
    Google has decided to deprecate JSON in favor of JSON-C in the near future.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从YouTube消费的JSON服务使用一种名为JSON-C的JSON变体。JSON-C实际上就是JSON，但谷歌正在区分YouTube过去提供的JSON和现在生产的新版本。YouTube基于JSON-C的响应比其JSON服务简单得多。因此，谷歌决定在不久的将来弃用JSON，转而使用JSON-C。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Start by creating the main controller in a file named `videos_controller.php`
    and place it in your `app/controllers` folder, with the following contents:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在名为`videos_controller.php`的文件中创建主要控制器，并将其放置在`app/controllers`文件夹中，内容如下：
- en: '[PRE14]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create the required model in a file named `video.php` and place it in your
    `app/models` folder, with the following contents:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`video.php`的文件中创建所需的模型，并将其放置在`app/models`文件夹中，内容如下：
- en: '[PRE15]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a view folder named videos in your `app/views` folder. Then, create
    a file named `index.ctp` and place it in your `app/views/videos` folder, with
    the following contents:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/views`文件夹中创建一个名为`videos`的视图文件夹。然后，创建一个名为`index.ctp`的文件，并将其放置在`app/views/videos`文件夹中，内容如下：
- en: '[PRE16]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you now browse to `http://localhost/videos`, you will see a search form.
    Entering **CakePHP** and clicking the button **Search** should give you a set
    of results similar to those shown in the following screenshot:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在浏览到`http://localhost/videos`，你会看到一个搜索表单。输入**CakePHP**并点击**搜索**按钮应该会给你一组类似于以下截图所示的结果：
- en: '![How to do it...](img/1926_07_02.jpg)'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何实现...](img/1926_07_02.jpg)'
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The controller class (`ArticlesController`) and the view file (`index.ctp`)
    have no connection with the underlying web service we are consuming. In fact,
    if you look closely at their code, they look like a regular controller and a standard
    view file. This is because we decided to encapsulate the service logic in a model.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器类（`ArticlesController`）和视图文件（`index.ctp`）与我们消费的底层Web服务没有关联。实际上，如果你仔细查看它们的代码，它们看起来就像一个常规控制器和一个标准视图文件。这是因为我们决定在模型中封装服务逻辑。
- en: Doing so allows us to change how we communicate with the service provider without
    having to modify neither the controller nor the view. That is one of the many
    advantages of the MVC (Model View Controller) architecture that is the foundation
    of CakePHP.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做允许我们更改与服务提供商的通信方式，而无需修改控制器或视图。这是MVC（模型-视图-控制器）架构的许多优点之一，它是CakePHP的基础。
- en: We could have taken a more complex approach, and decided to build a datasource
    to interact with the server. Instead, we chose a simpler route, by creating a
    model method that would perform the actual search and return the results in a
    data format typical of any CakePHP application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以采取更复杂的方法，决定构建一个数据源来与服务器交互。相反，我们选择了一条更简单的路线，通过创建一个模型方法来执行实际的搜索，并以任何CakePHP应用程序典型的数据格式返回结果。
- en: This is what the `Video` model is there for. As there's no underlying table
    for our videos, we set the model `$useTable` property to `false`. We also import
    the `HttpSocket` class, part of CakePHP's core, because it will be the mechanism
    we will use to communicate with the server.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是`Video`模型存在的原因。由于我们的视频没有底层表，我们将模型`$useTable`属性设置为`false`。我们还导入了`HttpSocket`类，它是CakePHP核心的一部分，因为我们将使用它来与服务器通信。
- en: The `search()` method is where the magic happens. The first thing we do is extract
    the search terms out of the submitted data. We then create an instance of `HttpSocket`,
    and use its get method to perform the request.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`search()` 方法是魔法发生的地方。我们首先从提交的数据中提取搜索词。然后我们创建一个 `HttpSocket` 实例，并使用其 get 方法执行请求。'
- en: '`HttpSocket::get()` takes three parameters:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpSocket::get()` 接受三个参数：'
- en: '`$uri`: The URL to which we are making the request. This can be either a string,
    or an array that contains the different elements of the URL, such as `scheme,
    host, port`, and `path`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$uri`: 我们要请求的URL。这可以是一个字符串，也可以是一个包含URL不同元素的数组，例如 `scheme, host, port` 和 `path`。'
- en: '`$query`: An array of parameters to append to the URL. The indexes in this
    array are the parameter names and the values their respective values.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$query`: 要附加到URL的参数数组。该数组的索引是参数名称及其相应值。'
- en: '`$request`: An array with any additional request information to send to the
    URL, such as `method, header`, and `body`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$request`: 一个包含要发送到URL的任何附加请求信息的数组，例如 `method, header` 和 `body`。'
- en: 'In our case we specify the URL to the YouTube video API, and we set the following
    query parameters:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们指定了 YouTube 视频API的URL，并设置了以下查询参数：
- en: '`v`: The API version to use.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v`: 要使用的API版本。'
- en: '`alt`: The format to get results in.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alt`: 获取结果时要使用的格式。'
- en: '`q`: The query to use for searching.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`q`: 用于搜索的查询。'
- en: '`orderby`: The order in which to get the results.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orderby`: 获取结果时的排序方式。'
- en: 'Once we get the response, we decode it using PHP''s `json_decode()` function,
    which converts a JSON string into a PHP object or to `null` if it is not a valid
    JSON string. For example, the following JSON:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到响应，我们使用 PHP 的 `json_decode()` 函数对其进行解码，该函数将 JSON 字符串转换为 PHP 对象或 `null`（如果它不是一个有效的
    JSON 字符串）。例如，以下 JSON：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Would be evaluated to a PHP class with two public attributes: `name`, and `profile`.
    The `profile` attribute will itself be a class, with one public attribute: `url`.
    If we had the above JSON string in a variable called `$json`, the following code
    would output **Mariano Iglesias has a website in http://marianoiglesias.com.ar**:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将被评估为具有两个公共属性：`name` 和 `profile` 的 PHP 类。`profile` 属性本身也是一个类，具有一个公共属性：`url`。如果我们有一个名为
    `$json` 的变量包含上述 JSON 字符串，以下代码将输出 **Mariano Iglesias 在 http://marianoiglesias.com.ar
    有一个网站**：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Back to the `Video::search()` method. Once we have decoded the JSON response,
    we check to make sure there are resulting videos available in the `$response->data->items`
    property. If so, we iterate through them, and we add elements to our response
    array, specifying only a subset of the data we obtained.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `Video::search()` 方法。一旦我们解码了 JSON 响应，我们检查 `$response->data->items` 属性中是否有可用的结果视频。如果有，我们就遍历它们，并将元素添加到我们的响应数组中，只指定我们获得的数据的子集。
- en: Once we have the data prepared, we return it back to the controller, which sends
    it to the view to render the results.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好了数据，我们就将其返回给控制器，控制器将其发送到视图以渲染结果。
- en: See also
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 5](ch05.html "Chapter 5. Datasources"), *Datasources*'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html "第5章。数据源"), *数据源*'
- en: '*Building REST services with JSON*'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 JSON 构建 REST 服务*'
- en: Building REST services with JSON
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JSON 构建 REST 服务
- en: In the recipe *Consuming a JSON service*, we learnt how lightweight and convenient
    the JSON format can be for exchanging data. What happens if we not only want to
    expose data using JSON, but also allow the possibility to modify it? This is one
    of the reasons why the REST architecture exists. **REST** stands for **Representational
    State Transfer**, and is no more than a set of principles that guide the concepts
    that describe its proper implementation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *消费 JSON 服务* 的食谱中，我们了解到 JSON 格式在交换数据时是多么轻量级和方便。如果我们不仅想使用 JSON 公开数据，还允许修改它的可能性，会发生什么？这是
    REST 架构存在的原因之一。**REST** 代表 **表征状态转移**，它不过是一组原则，指导描述其正确实现的各个概念。
- en: One of these main principles is that the client-server communication that is
    part of a REST request should be stateless. This means that no context exists
    in the server between requests from a specific client. All the information required
    to perform an operation is part of the request.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个主要原则是，REST请求中作为其一部分的客户端-服务器通信应该是无状态的。这意味着在服务器中不存在特定客户端请求之间的任何上下文。执行操作所需的所有信息都是请求的一部分。
- en: In this recipe, we will learn how to add REST services to an application, using
    JSON as their exchange format. These services will allow any foreign application
    to get data from a post, create new posts, or delete existing posts.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何使用 JSON 作为交换格式将 REST 服务添加到应用程序中。这些服务将允许任何外部应用程序从帖子中获取数据，创建新的帖子或删除现有的帖子。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To go through this recipe we need sample data to work with. Follow the *Getting
    ready* section of the *Creating an RSS feed* recipe.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个食谱，我们需要一些样本数据来工作。遵循“创建 RSS 源”食谱中的“准备工作”部分。
- en: 'Create the `Post` model in a file named `post.php` and place it in your `app/models`
    folder, with the following contents. With the validation option, `required`, we
    are telling CakePHP that these fields should always be present when creating or
    modifying records:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为`post.php`的文件中创建`Post`模型，并将其放置在你的`app/models`文件夹中，内容如下。通过验证选项`required`，我们告诉
    CakePHP 这些字段在创建或修改记录时始终存在：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let us add actions for creating, editing, and deleting posts. Edit your `app/controllers/posts_controller.php`
    file and add the following methods to the `PostsController` class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加创建、编辑和删除帖子的操作。编辑你的`app/controllers/posts_controller.php`文件，并在`PostsController`类中添加以下方法：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We now need to add their respective views. Create a file named `edit.ctp` and
    place it in your `app/views/posts` folder, with the following contents:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要添加它们相应的视图。创建一个名为`edit.ctp`的文件，并将其放置在你的`app/views/posts`文件夹中，内容如下：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a file named `delete.ctp` and place it in your `app/views/posts` folder,
    with the following contents:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`delete.ctp`的文件，并将其放置在你的`app/views/posts`文件夹中，内容如下：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Modify the `app/views/posts/index.ctp` to add links to these actions by changing
    the whole view to the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`app/views/posts/index.ctp`，通过更改整个视图来添加这些操作的链接：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Edit your `app/config/routes.php` file and add the following statement at the
    end:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑你的`app/config/routes.php`文件，并在文件末尾添加以下语句：
- en: '[PRE24]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Edit your `app/controllers/posts_controller.php` file and add the following
    property to the `PostsController` class:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑你的`app/controllers/posts_controller.php`文件，并在`PostsController`类中添加以下属性：
- en: '[PRE25]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a folder named `json` in your `app/views/layouts` folder, and inside
    the `json` folder, create a file named `default.ctp`, with the following contents:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`app/views/layouts`文件夹中创建一个名为`json`的文件夹，然后在`json`文件夹内创建一个名为`default.ctp`的文件，内容如下：
- en: '[PRE26]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a folder named `json` in your `app/views/posts` folder, and inside the
    `json` folder, create a file named `index.ctp`, with the following contents:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`app/views/posts`文件夹中创建一个名为`json`的文件夹，然后在`json`文件夹内创建一个名为`index.ctp`的文件，内容如下：
- en: '[PRE27]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Edit your `app/controllers/posts_controller.php` file and add the following
    method to the end of the `PostsController` class:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑你的`app/controllers/posts_controller.php`文件，并在`PostsController`类的末尾添加以下方法：
- en: '[PRE28]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Edit the `PostsController::index()` method and make the following changes:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`PostsController::index()`方法，并做出以下更改：
- en: '[PRE29]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following methods to the beginning of the `PostsController` class below
    the declaration of the `components` property:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PostsController`类的`components`属性声明下方添加以下方法：
- en: '[PRE30]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Edit the `PostsController::edit()` method and make the following changes:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`PostsController::edit()`方法，并做出以下更改：
- en: '[PRE31]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Edit the `PostsController::delete()` method and make the following changes:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`PostsController::delete()`方法，并做出以下更改：
- en: '[PRE32]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To test these services, we are going to create a small CakePHP shell that will
    create a new post, edit the created post, delete it, and show the list of posts
    throughout the process. Create a file named `consume.php` and place it in your
    `app/vendors/shells` folder, with the following contents:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这些服务，我们将创建一个小的 CakePHP shell，它将创建一个新的帖子，编辑已创建的帖子，删除它，并在整个过程中显示帖子列表。创建一个名为`consume.php`的文件，并将其放置在你的`app/vendors/shells`文件夹中，内容如下：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To run this shell script, invoke it with one argument: the base URL of your
    application. So change `http://localhost` below to suit your application''s URL:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此 shell 脚本，使用一个参数调用它：你应用程序的基本 URL。所以将下面的`http://localhost`更改为适合你应用程序的 URL：
- en: 'If you are on a GNU Linux / Mac / Unix system:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是 GNU Linux / Mac / Unix 系统：
- en: '[PRE34]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you are on Microsoft Windows:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是 Microsoft Windows：
- en: '[PRE35]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output should be similar to that shown in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应类似于以下截图所示：
- en: '![How to do it...](img/1926_07_03.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/1926_07_03.jpg)'
- en: We can see that the first list of posts shows our newly created post entitled
    **New Post**. The second list shows how we successfully changed its title to **New
    Post Title**, and the third list shows how we deleted the post.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，第一列帖子显示了我们的新创建的帖子，标题为**新帖子**。第二列显示了如何成功将其标题更改为**新帖子标题**，第三列显示了如何删除该帖子。
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Similarly to what was described in the *Creating an RSS feed* recipe, we started
    by specifying `json` as a valid extension and added the `RequestHandler` component
    to our list of components.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与在*创建一个RSS源*菜谱中描述的类似，我们首先指定`json`作为有效扩展，并将`RequestHandler`组件添加到我们的组件列表中。
- en: Unlike the `rss` and `xml` extensions, CakePHP does not provide a default layout
    for `json`, so we need to create one. Through the `beforeRender` callback, we
    turn debugging off, and we disable caching when a JSON request is made, to avoid
    any information that would break the JSON syntax and prevent client browsers from
    caching JSON requests.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与`rss`和`xml`扩展不同，CakePHP没有为`json`提供默认布局，因此我们需要创建一个。通过`beforeRender`回调，我们关闭调试，并在发送JSON请求时禁用缓存，以避免任何会破坏JSON语法并阻止客户端浏览器缓存JSON请求的信息。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When a JSON request is made to a controller that uses the `RequestHandler` component,
    the component will automatically set the content type of the response to `application/json`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当向使用`RequestHandler`组件的控制器发送JSON请求时，该组件将自动将响应的内容类型设置为`application/json`。
- en: Once we have our layout, we are ready to start implementing our JSON views.
    In this recipe, we only implement `index()` as a JSON action that returns JSON
    data through a view. All the other actions—`add(), edit()`, and `delete()`—will
    simply use HTTP status codes to communicate with the client. The JSON `index.ctp`
    view will simply add the full URL for each post, and echo the whole data structure
    as a JSON-formatted string using `json_encode()`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了布局，我们就可以开始实现我们的JSON视图了。在这个菜谱中，我们只实现了`index()`作为一个返回JSON数据的JSON动作。所有其他动作——`add()`、`edit()`和`delete()`——将简单地使用HTTP状态码与客户端通信。JSON
    `index.ctp`视图将简单地为每个帖子添加完整的URL，并使用`json_encode()`将整个数据结构作为JSON格式的字符串回显。
- en: As we will be changing some of the controller logic depending on the type of
    access (JSON versus normal access), we add a method named `_isJSON()` to our controller.
    This method uses the `ext` property of the `RequestHandler` component, which is
    set to the extension with which our action is requested. If no extension is used,
    and then it defaults to `html`. Using this property, we can check when a request
    is made using the `json` extension.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将根据访问类型（JSON与正常访问）更改一些控制器逻辑，我们在控制器中添加了一个名为`_isJSON()`的方法。此方法使用`RequestHandler`组件的`ext`属性，该属性设置为请求动作的扩展名。如果没有使用扩展名，则默认为`html`。使用此属性，我们可以检查是否使用`json`扩展名发送了请求。
- en: With `_isJSON(),` we can also add some extra checks to our methods, to make
    sure they are requested the proper way. For our `index` action, we make sure that
    if the request is made with JSON, we only allow GET requests to go through. If
    the request was made with any other method, for example, with POST, then we return
    an HTTP status of `400` (Bad Request), and we exit the application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`_isJSON()`，我们还可以在我们的方法中添加一些额外的检查，以确保它们以正确的方式请求。对于我们的`index`动作，我们确保如果请求是使用JSON发送的，我们只允许GET请求通过。如果请求是使用任何其他方法发送的，例如POST，则我们返回HTTP状态`400`（错误请求），并退出应用程序。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When no data needs to be sent back to the client, HTTP status codes are a great
    way to inform if a REST request has succeeded or failed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当不需要向客户端发送数据时，HTTP状态码是通知REST请求是否成功或失败的好方法。
- en: To help users of our REST requests, we should allow them to POST data without
    having to know how the data needs to be formatted for CakePHP to process it automatically.
    Therefore, we override the `beforeFilter` callback, so if a request is made with
    JSON that is not a GET request, and if CakePHP did not find any data properly
    formatted (when data was indeed posted), then we set what was posted as the controller
    data. This way, when creating or modifying posts, client code can simply use `title`
    to refer to the post `title` field, rather than having to use `data[Post][title]`
    as the name for the field.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们的REST请求的用户，我们应该允许他们在不了解数据需要如何格式化以便CakePHP自动处理的情况下发送数据。因此，我们覆盖了`beforeFilter`回调，如果发送了JSON请求（不是GET请求），并且CakePHP没有找到任何正确格式化的数据（当确实发送了数据时），则我们将发送的内容设置为控制器数据。这样，在创建或修改帖子时，客户端代码可以简单地使用`title`来引用帖子`title`字段，而无需使用`data[Post][title]`作为字段的名称。
- en: 'We then proceed to make the necessary modifications to the `edit()` method.
    We start by making sure that we were accessing with the proper method (POST),
    and we change how we report success or failure: with an HTTP status of `200` (OK)
    when the post is saved, `403` (Forbidden) if the post cannot be saved, or `404`
    (Not Found) if trying to edit a post that does not exist.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续对`edit()`方法进行必要的修改。我们首先确保我们使用的是正确的方法（POST），并更改我们报告成功或失败的方式：当帖子保存时，使用HTTP状态`200`（OK），如果帖子无法保存，则使用`403`（禁止），如果尝试编辑一个不存在的帖子，则使用`404`（未找到）。
- en: The modifications to the `delete()` method are almost identical to the ones
    made to the `edit()` method. The two main differences are that the expected method
    is DELETED, and that we don't enforce data to be posted when being accessed through
    JSON.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对`delete()`方法的修改几乎与对`edit()`方法的修改相同。两个主要区别是期望的方法是DELETED，并且当通过JSON访问时，我们不强制提交数据。
- en: To test the code in this recipe, we built a shell script to consume our REST
    services. This script uses the `HttpSocket` class to fetch the content. In this
    shell script, we built a generic `request()` function that takes a URL, a method
    (we use GET, POST, and DELETE), and an optional array of data to post.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个配方中的代码，我们构建了一个shell脚本来消费我们的REST服务。这个脚本使用`HttpSocket`类来获取内容。在这个shell脚本中，我们构建了一个通用的`request()`函数，该函数接受一个URL、一个方法（我们使用GET、POST和DELETE），以及一个可选的数据数组来提交。
- en: We use the `request()` method to create a new post (notice how we specify the
    values for the `title` and `body` fields), get the list of posts that should include
    our newly created post, modify the created post, and finally delete it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`request()`方法创建一个新的帖子（注意我们如何指定`title`和`body`字段的值），获取应包括我们新创建的帖子的帖子列表，修改创建的帖子，最后删除它。
- en: See also
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating an RSS feed*'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个RSS源*'
- en: '*Adding authentication to REST services*'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将身份验证添加到REST服务*'
- en: Adding authentication to REST services
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将身份验证添加到REST服务
- en: In the previous recipe, *Building REST services with JSON*, we learnt how to
    enable JSON access to our actions, including the ability to create, modify, or
    delete posts with a simple JSON request.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方*使用JSON构建REST服务*中，我们学习了如何启用对我们的动作的JSON访问，包括使用简单的JSON请求创建、修改或删除帖子的能力。
- en: Modification of data through REST requests can lead to sensitive data loss if
    we don't add some sort of authentication. This recipe shows us how to enforce
    that our data-changing REST services are only utilized by valid users using HTTP
    Basic Authentication.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不添加某种形式的身份验证，通过REST请求修改数据可能会导致敏感数据丢失。这个配方展示了如何通过HTTP基本身份验证强制我们的数据更改REST服务只被有效用户使用。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To go through this recipe, we need some JSON-based REST services implemented.
    Follow the entire recipe *Building REST services with JSON*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个配方，我们需要一些基于JSON的REST服务实现。请按照*使用JSON构建REST服务*的整个配方进行操作。
- en: We also need a working authentication for our application. Follow the entire
    recipe *Setting up a basic authentication system* in the *Authentication* chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为我们的应用程序提供一个有效的身份验证。请按照*身份验证*章节中的整个配方*设置基本身份验证系统*进行操作。
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Edit your `app/controller/posts_controller.php` file and make the following
    changes to the `beforeFilter` callback:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑你的`app/controller/posts_controller.php`文件，并对`beforeFilter`回调进行以下更改：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'While still editing the `PostsController` class, add the following method below
    the `beforeFilter()` method:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们仍在编辑`PostsController`类时，在`beforeFilter()`方法下方添加以下方法：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If we now browse to `http://localhost/posts`, we will be presented with a login
    screen. As there are no users in the system, we need to create one by browsing
    to `http://localhost/users/add`, and specifying the desired user name and password.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在浏览到`http://localhost/posts`，我们将看到一个登录界面。由于系统中没有用户，我们需要通过浏览到`http://localhost/users/add`并指定所需的用户名和密码来创建一个用户。
- en: Let us run the test shell script (remember to change `http://localhost` to suit
    your application's base URL).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行测试shell脚本（记得将`http://localhost`更改为适合你应用程序的基本URL）。
- en: 'If you are on a GNU Linux / Mac / Unix system:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是GNU Linux / Mac / Unix系统：
- en: '[PRE38]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you are on Microsoft Windows:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是Microsoft Windows：
- en: '[PRE39]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Its output would inform us that the creation of the post fails with a `401`
    (Unauthorized) status code, as shown in the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 其输出将告诉我们帖子创建失败，状态码为`401`（未授权），如下面的截图所示：
- en: '![How to do it...](img/1926_07_04.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/1926_07_04.jpg)'
- en: If you haven't done so already while following the recipe *Setting up a basic
    authentication system*, create a user account by browsing to `http://localhost/users/add`
    and specifying the desired username and password.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在遵循*设置基本认证系统*食谱的过程中还没有这样做，请通过浏览到 `http://localhost/users/add` 并指定所需的用户名和密码来创建用户帐户。
- en: We need to modify the script to specify the user and password we created.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改脚本以指定我们创建的用户和密码。
- en: 'Edit your `app/vendors/shells/consume.php` shell script and add the following
    two properties to the `ConsumeShell` class:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `app/vendors/shells/consume.php` 脚本，并将以下两个属性添加到 `ConsumeShell` 类中：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'While still editing the script, make the following changes to the `main()`
    method:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续编辑脚本的同时，对 `main()` 方法进行以下更改：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Make the following changes to the `request()` method:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `request()` 方法进行以下更改：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can now run the script specifying the username and password we created.
    Change `http://localhost` to match your application''s URL, `user` to match the
    username, and `password` to match the created password:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行脚本，指定我们创建的用户名和密码。将 `http://localhost` 更改为匹配您的应用程序的 URL，将 `user` 更改为匹配用户名，将
    `password` 更改为匹配创建的密码：
- en: 'If you are on a GNU Linux / Mac / Unix system:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用的是 GNU Linux / Mac / Unix 系统：
- en: '[PRE43]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you are on Microsoft Windows:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用的是 Microsoft Windows：
- en: '[PRE44]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Running the script should give the same successful output as shown in the recipe
    *Building REST services with JSON*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本应该给出与食谱*使用 JSON 构建 REST 服务*中所示相同的成功输出。
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We started by adding some special logic to the `beforeFilter` callback when
    being requested through JSON. In it, we start by telling the `Auth` component
    that the action being requested is public. If we didn't, the `Auth` component
    would render the login form to the client, which is obviously not a valid JSON
    response.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在通过 JSON 请求时添加了一些特殊的逻辑到 `beforeFilter` 回调中。在其中，我们首先告诉 `Auth` 组件所请求的操作是公开的。如果我们不这样做，`Auth`
    组件会向客户端渲染登录表单，这显然不是一个有效的 JSON 响应。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This recipe uses a database-based authentication method. A simplier approach
    could have been taken by implementing basic HTTP authentication, a concept covered
    at [http://book.cakephp.org/view/1309/Basic-HTTP-Authentication](http://book.cakephp.org/view/1309/Basic-HTTP-Authentication).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱使用基于数据库的认证方法。可以通过实现基本的 HTTP 认证来采取更简单的方法，这是一个在 [http://book.cakephp.org/view/1309/Basic-HTTP-Authentication](http://book.cakephp.org/view/1309/Basic-HTTP-Authentication)
    中介绍的概念。
- en: 'Once we have established that the `Auth` component will not handle authorization
    for any actions requested through JSON, we need to add support for HTTP Basic
    Authentication. We do so by first configuring the `loginOptions` property of the
    `Security` component with the following settings:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定 `Auth` 组件不会处理通过 JSON 请求的任何授权操作，我们需要添加对 HTTP Basic 认证的支撑。我们通过首先配置 `Security`
    组件的 `loginOptions` 属性并使用以下设置来实现这一点：
- en: '`type`: Type of HTTP Authentication to use, which can be either `basic` or
    `digest`. We chose `basic`.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`: 要使用的 HTTP 认证类型，可以是 `basic` 或 `digest`。我们选择了 `basic`。'
- en: '`realm`: A descriptive name of the system being accessed.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`realm`: 访问系统的描述性名称。'
- en: '`login`: An optional function that is called when a client is trying to login
    through HTTP authentication. As we will use the `Auth` component to validate a
    login, we specify our own custom function, named `_restLogin`, to validate a user.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login`: 当客户端尝试通过 HTTP 认证登录时调用的可选函数。由于我们将使用 `Auth` 组件来验证登录，我们指定自己的自定义函数，命名为
    `_restLogin`，以验证用户。'
- en: Once we configured `Security`, we use its `requireLogin()` method to mark the
    current action as one that requires HTTP authentication.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们配置了 `Security`，我们就使用它的 `requireLogin()` 方法将当前操作标记为需要 HTTP 认证的。
- en: We also need to take into account a special check the `Security` component performs
    on certain requests. When data is posted, the component will look for a special
    token that should be saved in the session, and also posted as part of the request.
    This is a great feature that prevents the manipulation of hidden fields, because
    the token contains a hash of all known form values.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要考虑 `Security` 组件对某些请求执行的特殊检查。当数据被提交时，组件将寻找一个特殊令牌，该令牌应该保存在会话中，并作为请求的一部分提交。这是一个很棒的功能，因为它可以防止对隐藏字段的操纵，因为令牌包含所有已知表单值的哈希。
- en: Naturally, this is something that should not be applicable for REST requests
    because as we learnt while describing the REST architecture in the introduction
    to the recipe *Building REST services with JSON*, REST requests are stateless.
    Therefore, we disable this feature by setting the `validatePost` property of the
    `Security` component to `false`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这不应该适用于REST请求，因为我们在《使用JSON构建REST服务》的引言中描述REST架构时了解到，REST请求是无状态的。因此，我们通过将`Security`组件的`validatePost`属性设置为`false`来禁用此功能。
- en: 'The final step is implementing the method that is called by the `Security`
    component whenever an HTTP authentication login is attempted. We named this method
    `_restLogin(),` prefixing it with an underscore to prevent direct access to it.
    This method takes only one parameter, an indexed array with two mandatory keys:
    `username`, and `password`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是实现当`Security`组件尝试进行HTTP身份验证登录时被调用的方法。我们将其命名为`_restLogin()`，通过在前面加下划线来防止直接访问它。此方法只接受一个参数，一个包含两个必填键的索引数组：`username`和`password`。
- en: As the `Auth` component can be configured to use any field names for the `username`
    and `password` fields, we need to make sure we use the configured field names
    prior to attempting the login. The `fields` property of the `Auth` component contains
    this configuration in an array, indexed by `username`, and `password`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Auth`组件可以配置为使用任何字段名作为`username`和`password`字段，我们需要确保在尝试登录之前使用配置的字段名。`Auth`组件的`fields`属性包含此配置，以数组形式索引，索引为`username`和`password`。
- en: When we receive a call to `_restLogin()`, the value for the `password` field
    is plain text, as this is the standard way HTTP Basic Authentication works. However,
    the `Auth` component only takes hashes as passwords, so we need to hash the given
    password by utilizing the `password()` method of the `Auth` component.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到对`_restLogin()`的调用时，`password`字段的值是纯文本，因为这是HTTP基本身份验证的标准方式。然而，`Auth`组件只接受散列密码，因此我们需要通过使用`Auth`组件的`password()`方法来散列给定的密码。
- en: Once the correct field names are utilized, and the password is hashed, we are
    ready to attempt the login. We call the `login()` method of the `Auth` component,
    which returns `true` if the login is successful, or `false` otherwise. If the
    login fails, we use the `blackHole()` method of the `Security` component, specifying
    the reason for failure (login, which translates to a 401 HTTP status code), which
    stops the client request.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用了正确的字段名，并且密码被散列，我们就准备好尝试登录。我们调用`Auth`组件的`login()`方法，如果登录成功则返回`true`，否则返回`false`。如果登录失败，我们使用`Security`组件的`blackHole()`方法，指定失败原因（登录，这对应于401
    HTTP状态码），这将阻止客户端请求。
- en: Implementing token-based authorization for API access
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基于令牌的API访问授权
- en: In the previous recipe, *Adding authentication to REST services*, we built a
    REST API using JSON for our `PostsController` actions. With it, clients that utilize
    our REST services use a user account to validate their requests.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的食谱《向REST服务添加认证》中，我们为`PostsController`操作构建了一个使用JSON的REST API。有了它，利用我们的REST服务的客户端使用用户账户来验证他们的请求。
- en: 'Without neglecting the need to authorize all requests, several companies take
    a different approach when publishing their APIs: the use of API tokens. The advantage
    of using API tokens is that our user accounts are not exposed in client scripts,
    so the authorization information can''t be used to log in to the site.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在不忽视授权所有请求需求的同时，一些公司在发布他们的API时采取不同的方法：使用API令牌。使用API令牌的优势在于我们的用户账户不会在客户端脚本中暴露，因此授权信息不能用来登录网站。
- en: In this recipe we will take our authenticated REST service system and enable
    the use of tokens to use the exposed API. We will also add a usage limit, so client
    API usage is only allowed within a certain time and number of uses threshold.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用我们的认证REST服务系统并启用使用令牌来使用公开的API。我们还将添加使用限制，以便客户端API的使用仅限于一定的时间和次数阈值内。
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To go through this recipe, we need some JSON-based REST services implemented
    with authentication in place, so follow the previous recipe.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个食谱，我们需要一些实现了认证的基于JSON的REST服务，所以请遵循之前的食谱。
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We start by adding some fields to our `users` table. Issue the following SQL
    statements:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先向我们的`users`表添加一些字段。执行以下SQL语句：
- en: '[PRE45]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Edit your `app/controllers/users_controller.php` file and add the following
    method to the `UsersController` class:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑你的`app/controllers/users_controller.php`文件，并将以下方法添加到`UsersController`类中：
- en: '[PRE46]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create its view in a file named `token.ctp` and place it in your `app/views/users`
    folder, with the following contents:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `token.ctp` 的文件中创建其视图，并将其放置在 `app/views/users` 文件夹中，内容如下：
- en: '[PRE47]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let us add the parameters that will define the API access limits. Edit your
    `app/config/bootstrap.php` file and add the following at the end:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加定义 API 访问限制的参数。编辑你的 `app/config/bootstrap.php` 文件，并在末尾添加以下内容：
- en: '[PRE48]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Edit your `app/controllers/posts_controller.php` file and change the `_restLogin()`
    method, replacing it with the following contents:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑你的 `app/controllers/posts_controller.php` 文件，并更改 `_restLogin()` 方法，用以下内容替换：
- en: '[PRE49]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create the `User` model in a file named `user.php` and place it in your `app/models`
    folder, with the following contents:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `user.php` 的文件中创建 `User` 模型，并将其放置在 `app/models` 文件夹中，内容如下：
- en: '[PRE50]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Edit your `app/vendors/shells/consume.php` test script, remove the `$user`
    and `$password` properties, and then add the following property:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑你的 `app/vendors/shells/consume.php` 测试脚本，删除 `$user` 和 `$password` 属性，然后添加以下属性：
- en: '[PRE51]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'While still editing the shell script, make the following changes to its `main()`
    method:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑 shell 脚本的同时，对其 `main()` 方法进行以下修改：
- en: '[PRE52]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, make the following changes to the `request()` method:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对 `request()` 方法进行以下修改：
- en: '[PRE53]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If you now browse to `http://localhost/users/token`, you will be asked to Log
    in. Log in with the user account you created during the *Getting Started* section
    and you will then obtain an API token.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在浏览到 `http://localhost/users/token`，你将被要求登录。使用你在 *入门* 部分创建的用户账户登录，然后你将获得一个
    API 令牌。
- en: 'Let us now run the testing script with the following command. Change `http://localhost`
    to match your application''s URL, and token to match the API token you just generated:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用以下命令运行测试脚本。将 `http://localhost` 更改为匹配你的应用程序的 URL，并将令牌更改为你刚刚生成的 API 令牌：
- en: 'If you are on a GNU Linux / Mac / Unix system:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是 GNU Linux / Mac / Unix 系统：
- en: '[PRE54]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you are on Microsoft Windows:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是 Microsoft Windows：
- en: '[PRE55]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If we specified the right token, we will get the same successful output as shown
    in the recipe *Building REST services with JSON*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们指定了正确的令牌，我们将得到与 *构建 JSON REST 服务* 脚本中显示的相同成功输出。
- en: If you run the script again within 2 minutes since the last run, you will get
    a `503` (Service Unavailable) HTTP status error, indicating that we are overusing
    our API token. We will have to wait two minutes to be able to successfully run
    the script again, because each run makes six requests to the API, and six is the
    maximum allowed requests within two minutes, as configured in `app/config/bootstrap.php`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次在距离上次运行 2 分钟内运行脚本，你将得到一个 `503`（服务不可用）HTTP 状态错误，这表明我们过度使用了我们的 API 令牌。我们将不得不等待两分钟才能再次成功运行脚本，因为每次运行都会向
    API 发送六次请求，而六次是两分钟内允许的最大请求次数，如 `app/config/bootstrap.php` 中配置的那样。
- en: How it works...
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We start by adding three fields to the `users` table:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先向 `users` 表添加三个字段：
- en: '`token`: The API access token, unique to each user. This is what a user will
    use to use our API services.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`token`：API 访问令牌，每个用户都是唯一的。这是用户将用来使用我们的 API 服务的东西。'
- en: '`token_used`: The last time the API usage counter (`token_uses`) was reset.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`token_used`：API 使用计数器 (`token_uses`) 上次重置的时间。'
- en: '`token_uses`: The number of API uses since the date and time specified in `token_used`.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`token_uses`：自 `token_used` 中指定的日期和时间以来的 API 使用次数。'
- en: We then create an action called `token` in the `UsersController` class to allow
    users to get new API access tokens. This action will simply create a new token
    by hashing a **UUID** (**Universally Unique Identifier**), and saving it to the
    `users` table record.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后在 `UsersController` 类中创建一个名为 `token` 的操作，允许用户获取新的 API 访问令牌。此操作将简单地通过散列一个
    **UUID**（**全球唯一标识符**）来创建一个新的令牌，并将其保存到 `users` 表记录中。
- en: 'We proceed to set our application configuration in `bootstrap.php` by defining
    the API access limits with two settings:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续在 `bootstrap.php` 中设置应用程序配置，通过定义两个设置来定义 API 访问限制：
- en: '`maximum`: The maximum number of API requests allowed within a given time frame.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maximum`：在给定时帧内允许的最大 API 请求次数。'
- en: '`time`: The time frame that is used to check for API overuse. Any string that
    can be used by the PHP function `strtotime()` is allowed.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time`：用于检查 API 过度使用的时帧。允许使用 PHP 函数 `strtotime()` 的任何字符串。'
- en: We set `time` to `2` minutes, and `maximum` to `6` requests, which means that
    we will allow up to six API requests per user, every two minutes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `time` 设置为 `2` 分钟，将 `maximum` 设置为 `6` 次请求，这意味着我们将允许每个用户每两分钟最多进行六次 API 请求。
- en: As we are no longer using real accounts to authenticate our API users, we changed
    the `_restLogin()` method in `ProfilesController` to only use the given `username`
    field value. This value is in fact a user's API token. The `password` field is
    therefore ignored, which allows our test client script to simply pass an empty
    value as the password.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再使用真实账户来验证我们的API用户，我们将`ProfilesController`中的`_restLogin()`方法更改为仅使用提供的`username`字段值。实际上，这个值是一个用户的API令牌。因此，`password`字段被忽略，这使得我们的测试客户端脚本可以简单地传递一个空值作为密码。
- en: We use the method `useToken()` of the `User` model to check the validity of
    the token. If the method throws an `Exception`, then the given token does not
    exist, so we end the request with a `401` status (Unauthorized) by calling the
    `blackhole()` method of the `Security` component. If the `useToken()` method returns
    `false`, then the token is being overused, so we send back a `503` (Service Unavailable)
    status. If we are given back a valid user ID, we convert this value to a string,
    and pass it to the `login()` method of the `Auth` component, which will log in
    a user with a given ID if the specified parameter is a string.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`User`模型的`useToken()`方法来检查令牌的有效性。如果该方法抛出`Exception`异常，则表示给定的令牌不存在，因此我们通过调用`Security`组件的`blackhole()`方法，以`401`状态（未授权）结束请求。如果`useToken()`方法返回`false`，则表示令牌被过度使用，因此我们发送回`503`（服务不可用）状态。如果我们得到一个有效的用户ID，我们将此值转换为字符串，并将其传递给`Auth`组件的`login()`方法，如果指定的参数是字符串，则该方法将使用给定的ID登录用户。
- en: As we can see, the whole token usage logic relies on the `User::useToken()`.
    This method starts by looking for a user record with the given token. If none
    is found, it throws an `Exception`. If a valid token is being used, it checks
    to see if the token has been used. If so, we set the time limit since the first
    update of the token usage in the `$tokenTimeThreshold` local variable. If we are
    within this time frame, and if the number of token uses exceeds the configured
    setting, we return `false`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，整个令牌使用逻辑依赖于`User::useToken()`方法。该方法首先寻找带有给定令牌的用户记录。如果没有找到，它将抛出`Exception`异常。如果正在使用有效的令牌，它会检查该令牌是否已被使用。如果是，我们在`$tokenTimeThreshold`局部变量中设置自令牌使用首次更新以来的时间限制。如果我们处于这个时间范围内，并且令牌的使用次数超过了配置的设置，我们返回`false`。
- en: If none of the above conditions are met, then the token use is valid, so we
    either increment the number of uses if `$tokenTimeThreshold` is within the current
    time frame, or reset it.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述条件都不满足，则令牌使用有效，因此我们要么在`$tokenTimeThreshold`在当前时间范围内时增加使用次数，要么将其重置。
