- en: Chapter 7. Creating and Consuming Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an RSS feed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming a JSON service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building REST services with JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding authentication to REST services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing token-based authorization for API access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web services are essential when looking forward to expose application functionality
    to third-party applications, or when looking forward to integrate foreign services
    into our own applications. They offer a broad set of technologies and definitions
    so that systems written in different programming languages can communicate.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces a set of recipes to consume web services, and to expose
    parts of our application as web services.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an RSS feed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RSS feeds are a form of web services, as they provide a service, over the web,
    using a known format to expose data. Due to their simplicity, they are a great
    way to introduce us to the world of web services, particularly as CakePHP offers
    a built in method to create them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the recipe *Consuming RSS feeds with a datasource* from [Chapter 5](ch05.html
    "Chapter 5. Datasources"), *Datasources*, we learned how to fetch content from
    a foreign RSS feed. In this recipe, will do exactly the opposite: produce a feed
    for our site that can be used by other applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To go through this recipe we need a sample table to work with. Create a table
    named `posts`, using the following SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some sample data, using the following SQL statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We proceed now to create the required controller. Create the class `PostsController`
    in a file named `posts_controller.php` and place it in your `app/controllers`
    folder, with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a folder named `posts` in your `app/views` folder, and then create the
    `index` view in a file named `index.ctp` and place it in your `app/views/posts`
    folder, with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit your `app/config/routes.php` file and add the following statement at the
    end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit your `app/controllers/posts_controller.php` file and add the following
    property to the `PostsController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While still editing `PostsController`, make the following changes to the `index()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a folder named `rss` in your `app/views/posts` folder, and inside the
    `rss` folder create a file named `index.ctp`, with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit your `app/views/posts/index.ctp` file and add the following at the end
    of the view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you now browse to `http://localhost/posts`, you should see a listing of
    posts with a link entitled **Feed**. Clicking on this link should produce a valid
    RSS feed, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1926_07_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'If you view the source of the generated response, you can see that the source
    for the first item within the RSS document is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We started by telling CakePHP that our application accepts the `rss` extension
    with a call to `Router::parseExtensions()`, a method that accepts any number of
    extensions. Using extensions, we can create different versions of the same view.
    For example, if we wanted to accept both `rss` and `xml` as extensions, we would
    do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In our recipe, we added `rss` to the list of valid extensions. That way, if
    an action is accessed using that extension, for example, by using the URL `http://localhost/posts.rss`,
    then CakePHP will identify `rss` as a valid extension, and will execute the `ArticlesController::index()`
    action as it normally would, but using the `app/views/posts/rss/index.ctp` file
    to render the view. The process also uses the file `app/views/layouts/rss/default.ctp`
    as its layout, or CakePHP's default RSS layout if that file is not present.
  prefs: []
  type: TYPE_NORMAL
- en: We then modify how `ArticlesController::index()` builds the list of posts, and
    use the `RequestHandler` component to see if the current request uses the `rss`
    extension. If so, we use that knowledge to change the number and order of posts.
  prefs: []
  type: TYPE_NORMAL
- en: In the `app/views/posts/rss/index.ctp` view, we start by setting some view variables.
    Because a controller view is always rendered before the layout, we can add or
    change view variables from the view file, and have them available in the layout.
    CakePHP's default RSS layout uses a `$channel` view variable to describe the RSS
    feed. Using that variable, we set our feed's `title, link`, and `description`.
  prefs: []
  type: TYPE_NORMAL
- en: We proceed to output the actual item files. There are different ways to do so,
    the first one is making a call to the `RssHelper::item()` method for each item,
    and the other one requires only a call to `RssHelper::items()`, passing it an
    array of items. We chose the latter method due to its simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: While we build the array of items to be included in the feed, we only specify
    `title, link, description`, and `pubDate`. Looking at the generated XML source
    for the item, we can infer that the `RssHelper` used our value for the `link`
    element as the value for the `guid` (globally unique identifier) element.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `description` field is specified slightly differently than the
    values for the other fields in our item array. This is because our description
    may contain HTML code, so we want to make sure that the generated document is
    still a valid XML document.
  prefs: []
  type: TYPE_NORMAL
- en: By using the array notation for the `description` field, a notation that uses
    the `value` index to specify the actual value on the field, and by setting `cdata`
    to `true`, we are telling the `RssHelper` (actually the `XmlHelper` from which
    `RssHelper` descends) that the field should be wrapped in a section that should
    not be parsed as part of the XML document, denoted between a `<![CDATA[` prefix
    and a`]]>` postfix.
  prefs: []
  type: TYPE_NORMAL
- en: The final task in this recipe is adding a link to our feed that is shown in
    the `index.ctp` view file. While creating this link, we set the special `ext`
    URL setting to `rss`. This sets the extension for the generated link, which ends
    up being `http://localhost/posts.rss`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding view caching to an RSS feed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our feeds may be consumed by feed search crawlers. If we are lucky, we may get
    tons and tons of requests looking for updates to our blog. It is unlikely that
    we will update our blog so often that we would have new posts every second, so
    our server load may force us to add some caching.
  prefs: []
  type: TYPE_NORMAL
- en: When looking to improve performance, some developers are content to only cache
    their database queries. In our recipe, this would mean caching the results obtained
    from our `$this->Post->find('all')` call. Unless we have our database engine on
    a separate server that suffers from some considerable network latency, chances
    are this sort of caching will offer little or no benefit.
  prefs: []
  type: TYPE_NORMAL
- en: A much better solution is to use view caching. That is, caching the generated
    RSS feed, and using that cached document whenever a request is made to our feed,
    provided we are within the cache time. Fortunately, CakePHP offers us a view-caching
    implementation right from the dispatcher, speeding up the request considerably.
    If a cached view file is found, that file is rendered directly to the client,
    without any intervention by the controller, or the need to load models, components,
    or helpers.
  prefs: []
  type: TYPE_NORMAL
- en: We want to add caching only when our `PostsController::index()` action is accessed
    with the `rss` extension. That is, we don't want to cache the listing of posts,
    but its feed. So we will make sure to only specify caching information when a
    feed is requested. In fact, we are going to cache all actions in our `PostsController`
    whenever the `rss` extension is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is tell CakePHP to take view caching into account.
    Edit your `app/config/core.php` file and uncomment the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, edit your `app/controllers/posts_controller.php` file and add the `Cache`
    helper to the `PostsController` class. Without it, view caching will simply not
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'While still editing the `PostsController` class, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this `beforeFilter()` implementation, we are checking to see if the current
    request was made using the `rss` extension. If so, we add the current action (whatever
    that may be) to the list of cached actions, and set the cache time to be `1 hour`.
  prefs: []
  type: TYPE_NORMAL
- en: If we access the feed multiple times within the hour, we should see the same
    feed we have been getting so far, but coming from the cache instead of being built
    in real time.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Consuming RSS feeds with a datasource* in [Chapter 5](ch05.html "Chapter 5. Datasources"),
    *Datasources*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Building REST services with JSON*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming a JSON service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON** (**JavaScript Object Notation**) is probably one of the best formats
    available for exposing data, due to its easy-to-read syntax, which greatly simplifies
    the parsing. In fact, PHP (as of its 5.2.0 release) provides built-in methods
    to convert data from a JSON-formatted string to a PHP native data type and from
    PHP types to JSON.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the `HttpSocket` class to consume a
    JSON service from a foreign site. This time, we are going to use the YouTube JSON
    API to allow our users to search for YouTube videos that match a given search
    query.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON service we will be consuming from YouTube uses a variant of JSON, called
    JSON-C. JSON-C is nothing more than JSON, but Google is making a distinction between
    what YouTube used to provide as JSON, and the new version it is now producing.
    YouTube's JSON-C-based responses are far simpler than their JSON service. Consequently,
    Google has decided to deprecate JSON in favor of JSON-C in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by creating the main controller in a file named `videos_controller.php`
    and place it in your `app/controllers` folder, with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the required model in a file named `video.php` and place it in your
    `app/models` folder, with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a view folder named videos in your `app/views` folder. Then, create
    a file named `index.ctp` and place it in your `app/views/videos` folder, with
    the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you now browse to `http://localhost/videos`, you will see a search form.
    Entering **CakePHP** and clicking the button **Search** should give you a set
    of results similar to those shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1926_07_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The controller class (`ArticlesController`) and the view file (`index.ctp`)
    have no connection with the underlying web service we are consuming. In fact,
    if you look closely at their code, they look like a regular controller and a standard
    view file. This is because we decided to encapsulate the service logic in a model.
  prefs: []
  type: TYPE_NORMAL
- en: Doing so allows us to change how we communicate with the service provider without
    having to modify neither the controller nor the view. That is one of the many
    advantages of the MVC (Model View Controller) architecture that is the foundation
    of CakePHP.
  prefs: []
  type: TYPE_NORMAL
- en: We could have taken a more complex approach, and decided to build a datasource
    to interact with the server. Instead, we chose a simpler route, by creating a
    model method that would perform the actual search and return the results in a
    data format typical of any CakePHP application.
  prefs: []
  type: TYPE_NORMAL
- en: This is what the `Video` model is there for. As there's no underlying table
    for our videos, we set the model `$useTable` property to `false`. We also import
    the `HttpSocket` class, part of CakePHP's core, because it will be the mechanism
    we will use to communicate with the server.
  prefs: []
  type: TYPE_NORMAL
- en: The `search()` method is where the magic happens. The first thing we do is extract
    the search terms out of the submitted data. We then create an instance of `HttpSocket`,
    and use its get method to perform the request.
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpSocket::get()` takes three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$uri`: The URL to which we are making the request. This can be either a string,
    or an array that contains the different elements of the URL, such as `scheme,
    host, port`, and `path`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$query`: An array of parameters to append to the URL. The indexes in this
    array are the parameter names and the values their respective values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$request`: An array with any additional request information to send to the
    URL, such as `method, header`, and `body`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case we specify the URL to the YouTube video API, and we set the following
    query parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v`: The API version to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alt`: The format to get results in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`q`: The query to use for searching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orderby`: The order in which to get the results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we get the response, we decode it using PHP''s `json_decode()` function,
    which converts a JSON string into a PHP object or to `null` if it is not a valid
    JSON string. For example, the following JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Would be evaluated to a PHP class with two public attributes: `name`, and `profile`.
    The `profile` attribute will itself be a class, with one public attribute: `url`.
    If we had the above JSON string in a variable called `$json`, the following code
    would output **Mariano Iglesias has a website in http://marianoiglesias.com.ar**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Back to the `Video::search()` method. Once we have decoded the JSON response,
    we check to make sure there are resulting videos available in the `$response->data->items`
    property. If so, we iterate through them, and we add elements to our response
    array, specifying only a subset of the data we obtained.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the data prepared, we return it back to the controller, which sends
    it to the view to render the results.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. Datasources"), *Datasources*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Building REST services with JSON*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building REST services with JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the recipe *Consuming a JSON service*, we learnt how lightweight and convenient
    the JSON format can be for exchanging data. What happens if we not only want to
    expose data using JSON, but also allow the possibility to modify it? This is one
    of the reasons why the REST architecture exists. **REST** stands for **Representational
    State Transfer**, and is no more than a set of principles that guide the concepts
    that describe its proper implementation.
  prefs: []
  type: TYPE_NORMAL
- en: One of these main principles is that the client-server communication that is
    part of a REST request should be stateless. This means that no context exists
    in the server between requests from a specific client. All the information required
    to perform an operation is part of the request.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to add REST services to an application, using
    JSON as their exchange format. These services will allow any foreign application
    to get data from a post, create new posts, or delete existing posts.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe we need sample data to work with. Follow the *Getting
    ready* section of the *Creating an RSS feed* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `Post` model in a file named `post.php` and place it in your `app/models`
    folder, with the following contents. With the validation option, `required`, we
    are telling CakePHP that these fields should always be present when creating or
    modifying records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us add actions for creating, editing, and deleting posts. Edit your `app/controllers/posts_controller.php`
    file and add the following methods to the `PostsController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to add their respective views. Create a file named `edit.ctp` and
    place it in your `app/views/posts` folder, with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file named `delete.ctp` and place it in your `app/views/posts` folder,
    with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `app/views/posts/index.ctp` to add links to these actions by changing
    the whole view to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit your `app/config/routes.php` file and add the following statement at the
    end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit your `app/controllers/posts_controller.php` file and add the following
    property to the `PostsController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a folder named `json` in your `app/views/layouts` folder, and inside
    the `json` folder, create a file named `default.ctp`, with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a folder named `json` in your `app/views/posts` folder, and inside the
    `json` folder, create a file named `index.ctp`, with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit your `app/controllers/posts_controller.php` file and add the following
    method to the end of the `PostsController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the `PostsController::index()` method and make the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following methods to the beginning of the `PostsController` class below
    the declaration of the `components` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the `PostsController::edit()` method and make the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the `PostsController::delete()` method and make the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To test these services, we are going to create a small CakePHP shell that will
    create a new post, edit the created post, delete it, and show the list of posts
    throughout the process. Create a file named `consume.php` and place it in your
    `app/vendors/shells` folder, with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To run this shell script, invoke it with one argument: the base URL of your
    application. So change `http://localhost` below to suit your application''s URL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are on a GNU Linux / Mac / Unix system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are on Microsoft Windows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should be similar to that shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1926_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the first list of posts shows our newly created post entitled
    **New Post**. The second list shows how we successfully changed its title to **New
    Post Title**, and the third list shows how we deleted the post.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similarly to what was described in the *Creating an RSS feed* recipe, we started
    by specifying `json` as a valid extension and added the `RequestHandler` component
    to our list of components.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the `rss` and `xml` extensions, CakePHP does not provide a default layout
    for `json`, so we need to create one. Through the `beforeRender` callback, we
    turn debugging off, and we disable caching when a JSON request is made, to avoid
    any information that would break the JSON syntax and prevent client browsers from
    caching JSON requests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a JSON request is made to a controller that uses the `RequestHandler` component,
    the component will automatically set the content type of the response to `application/json`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our layout, we are ready to start implementing our JSON views.
    In this recipe, we only implement `index()` as a JSON action that returns JSON
    data through a view. All the other actions—`add(), edit()`, and `delete()`—will
    simply use HTTP status codes to communicate with the client. The JSON `index.ctp`
    view will simply add the full URL for each post, and echo the whole data structure
    as a JSON-formatted string using `json_encode()`.
  prefs: []
  type: TYPE_NORMAL
- en: As we will be changing some of the controller logic depending on the type of
    access (JSON versus normal access), we add a method named `_isJSON()` to our controller.
    This method uses the `ext` property of the `RequestHandler` component, which is
    set to the extension with which our action is requested. If no extension is used,
    and then it defaults to `html`. Using this property, we can check when a request
    is made using the `json` extension.
  prefs: []
  type: TYPE_NORMAL
- en: With `_isJSON(),` we can also add some extra checks to our methods, to make
    sure they are requested the proper way. For our `index` action, we make sure that
    if the request is made with JSON, we only allow GET requests to go through. If
    the request was made with any other method, for example, with POST, then we return
    an HTTP status of `400` (Bad Request), and we exit the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When no data needs to be sent back to the client, HTTP status codes are a great
    way to inform if a REST request has succeeded or failed.
  prefs: []
  type: TYPE_NORMAL
- en: To help users of our REST requests, we should allow them to POST data without
    having to know how the data needs to be formatted for CakePHP to process it automatically.
    Therefore, we override the `beforeFilter` callback, so if a request is made with
    JSON that is not a GET request, and if CakePHP did not find any data properly
    formatted (when data was indeed posted), then we set what was posted as the controller
    data. This way, when creating or modifying posts, client code can simply use `title`
    to refer to the post `title` field, rather than having to use `data[Post][title]`
    as the name for the field.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then proceed to make the necessary modifications to the `edit()` method.
    We start by making sure that we were accessing with the proper method (POST),
    and we change how we report success or failure: with an HTTP status of `200` (OK)
    when the post is saved, `403` (Forbidden) if the post cannot be saved, or `404`
    (Not Found) if trying to edit a post that does not exist.'
  prefs: []
  type: TYPE_NORMAL
- en: The modifications to the `delete()` method are almost identical to the ones
    made to the `edit()` method. The two main differences are that the expected method
    is DELETED, and that we don't enforce data to be posted when being accessed through
    JSON.
  prefs: []
  type: TYPE_NORMAL
- en: To test the code in this recipe, we built a shell script to consume our REST
    services. This script uses the `HttpSocket` class to fetch the content. In this
    shell script, we built a generic `request()` function that takes a URL, a method
    (we use GET, POST, and DELETE), and an optional array of data to post.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `request()` method to create a new post (notice how we specify the
    values for the `title` and `body` fields), get the list of posts that should include
    our newly created post, modify the created post, and finally delete it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating an RSS feed*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Adding authentication to REST services*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding authentication to REST services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, *Building REST services with JSON*, we learnt how to
    enable JSON access to our actions, including the ability to create, modify, or
    delete posts with a simple JSON request.
  prefs: []
  type: TYPE_NORMAL
- en: Modification of data through REST requests can lead to sensitive data loss if
    we don't add some sort of authentication. This recipe shows us how to enforce
    that our data-changing REST services are only utilized by valid users using HTTP
    Basic Authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe, we need some JSON-based REST services implemented.
    Follow the entire recipe *Building REST services with JSON*.
  prefs: []
  type: TYPE_NORMAL
- en: We also need a working authentication for our application. Follow the entire
    recipe *Setting up a basic authentication system* in the *Authentication* chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit your `app/controller/posts_controller.php` file and make the following
    changes to the `beforeFilter` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'While still editing the `PostsController` class, add the following method below
    the `beforeFilter()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If we now browse to `http://localhost/posts`, we will be presented with a login
    screen. As there are no users in the system, we need to create one by browsing
    to `http://localhost/users/add`, and specifying the desired user name and password.
  prefs: []
  type: TYPE_NORMAL
- en: Let us run the test shell script (remember to change `http://localhost` to suit
    your application's base URL).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are on a GNU Linux / Mac / Unix system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are on Microsoft Windows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Its output would inform us that the creation of the post fails with a `401`
    (Unauthorized) status code, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1926_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you haven't done so already while following the recipe *Setting up a basic
    authentication system*, create a user account by browsing to `http://localhost/users/add`
    and specifying the desired username and password.
  prefs: []
  type: TYPE_NORMAL
- en: We need to modify the script to specify the user and password we created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit your `app/vendors/shells/consume.php` shell script and add the following
    two properties to the `ConsumeShell` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'While still editing the script, make the following changes to the `main()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the following changes to the `request()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run the script specifying the username and password we created.
    Change `http://localhost` to match your application''s URL, `user` to match the
    username, and `password` to match the created password:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are on a GNU Linux / Mac / Unix system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are on Microsoft Windows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running the script should give the same successful output as shown in the recipe
    *Building REST services with JSON*.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We started by adding some special logic to the `beforeFilter` callback when
    being requested through JSON. In it, we start by telling the `Auth` component
    that the action being requested is public. If we didn't, the `Auth` component
    would render the login form to the client, which is obviously not a valid JSON
    response.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe uses a database-based authentication method. A simplier approach
    could have been taken by implementing basic HTTP authentication, a concept covered
    at [http://book.cakephp.org/view/1309/Basic-HTTP-Authentication](http://book.cakephp.org/view/1309/Basic-HTTP-Authentication).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have established that the `Auth` component will not handle authorization
    for any actions requested through JSON, we need to add support for HTTP Basic
    Authentication. We do so by first configuring the `loginOptions` property of the
    `Security` component with the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type`: Type of HTTP Authentication to use, which can be either `basic` or
    `digest`. We chose `basic`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`realm`: A descriptive name of the system being accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`login`: An optional function that is called when a client is trying to login
    through HTTP authentication. As we will use the `Auth` component to validate a
    login, we specify our own custom function, named `_restLogin`, to validate a user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we configured `Security`, we use its `requireLogin()` method to mark the
    current action as one that requires HTTP authentication.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to take into account a special check the `Security` component performs
    on certain requests. When data is posted, the component will look for a special
    token that should be saved in the session, and also posted as part of the request.
    This is a great feature that prevents the manipulation of hidden fields, because
    the token contains a hash of all known form values.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, this is something that should not be applicable for REST requests
    because as we learnt while describing the REST architecture in the introduction
    to the recipe *Building REST services with JSON*, REST requests are stateless.
    Therefore, we disable this feature by setting the `validatePost` property of the
    `Security` component to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is implementing the method that is called by the `Security`
    component whenever an HTTP authentication login is attempted. We named this method
    `_restLogin(),` prefixing it with an underscore to prevent direct access to it.
    This method takes only one parameter, an indexed array with two mandatory keys:
    `username`, and `password`.'
  prefs: []
  type: TYPE_NORMAL
- en: As the `Auth` component can be configured to use any field names for the `username`
    and `password` fields, we need to make sure we use the configured field names
    prior to attempting the login. The `fields` property of the `Auth` component contains
    this configuration in an array, indexed by `username`, and `password`.
  prefs: []
  type: TYPE_NORMAL
- en: When we receive a call to `_restLogin()`, the value for the `password` field
    is plain text, as this is the standard way HTTP Basic Authentication works. However,
    the `Auth` component only takes hashes as passwords, so we need to hash the given
    password by utilizing the `password()` method of the `Auth` component.
  prefs: []
  type: TYPE_NORMAL
- en: Once the correct field names are utilized, and the password is hashed, we are
    ready to attempt the login. We call the `login()` method of the `Auth` component,
    which returns `true` if the login is successful, or `false` otherwise. If the
    login fails, we use the `blackHole()` method of the `Security` component, specifying
    the reason for failure (login, which translates to a 401 HTTP status code), which
    stops the client request.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing token-based authorization for API access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, *Adding authentication to REST services*, we built a
    REST API using JSON for our `PostsController` actions. With it, clients that utilize
    our REST services use a user account to validate their requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without neglecting the need to authorize all requests, several companies take
    a different approach when publishing their APIs: the use of API tokens. The advantage
    of using API tokens is that our user accounts are not exposed in client scripts,
    so the authorization information can''t be used to log in to the site.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will take our authenticated REST service system and enable
    the use of tokens to use the exposed API. We will also add a usage limit, so client
    API usage is only allowed within a certain time and number of uses threshold.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe, we need some JSON-based REST services implemented
    with authentication in place, so follow the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by adding some fields to our `users` table. Issue the following SQL
    statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit your `app/controllers/users_controller.php` file and add the following
    method to the `UsersController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create its view in a file named `token.ctp` and place it in your `app/views/users`
    folder, with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us add the parameters that will define the API access limits. Edit your
    `app/config/bootstrap.php` file and add the following at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit your `app/controllers/posts_controller.php` file and change the `_restLogin()`
    method, replacing it with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `User` model in a file named `user.php` and place it in your `app/models`
    folder, with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit your `app/vendors/shells/consume.php` test script, remove the `$user`
    and `$password` properties, and then add the following property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While still editing the shell script, make the following changes to its `main()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, make the following changes to the `request()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you now browse to `http://localhost/users/token`, you will be asked to Log
    in. Log in with the user account you created during the *Getting Started* section
    and you will then obtain an API token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now run the testing script with the following command. Change `http://localhost`
    to match your application''s URL, and token to match the API token you just generated:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are on a GNU Linux / Mac / Unix system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are on Microsoft Windows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we specified the right token, we will get the same successful output as shown
    in the recipe *Building REST services with JSON*.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the script again within 2 minutes since the last run, you will get
    a `503` (Service Unavailable) HTTP status error, indicating that we are overusing
    our API token. We will have to wait two minutes to be able to successfully run
    the script again, because each run makes six requests to the API, and six is the
    maximum allowed requests within two minutes, as configured in `app/config/bootstrap.php`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by adding three fields to the `users` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '`token`: The API access token, unique to each user. This is what a user will
    use to use our API services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`token_used`: The last time the API usage counter (`token_uses`) was reset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`token_uses`: The number of API uses since the date and time specified in `token_used`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then create an action called `token` in the `UsersController` class to allow
    users to get new API access tokens. This action will simply create a new token
    by hashing a **UUID** (**Universally Unique Identifier**), and saving it to the
    `users` table record.
  prefs: []
  type: TYPE_NORMAL
- en: 'We proceed to set our application configuration in `bootstrap.php` by defining
    the API access limits with two settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`maximum`: The maximum number of API requests allowed within a given time frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time`: The time frame that is used to check for API overuse. Any string that
    can be used by the PHP function `strtotime()` is allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set `time` to `2` minutes, and `maximum` to `6` requests, which means that
    we will allow up to six API requests per user, every two minutes.
  prefs: []
  type: TYPE_NORMAL
- en: As we are no longer using real accounts to authenticate our API users, we changed
    the `_restLogin()` method in `ProfilesController` to only use the given `username`
    field value. This value is in fact a user's API token. The `password` field is
    therefore ignored, which allows our test client script to simply pass an empty
    value as the password.
  prefs: []
  type: TYPE_NORMAL
- en: We use the method `useToken()` of the `User` model to check the validity of
    the token. If the method throws an `Exception`, then the given token does not
    exist, so we end the request with a `401` status (Unauthorized) by calling the
    `blackhole()` method of the `Security` component. If the `useToken()` method returns
    `false`, then the token is being overused, so we send back a `503` (Service Unavailable)
    status. If we are given back a valid user ID, we convert this value to a string,
    and pass it to the `login()` method of the `Auth` component, which will log in
    a user with a given ID if the specified parameter is a string.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the whole token usage logic relies on the `User::useToken()`.
    This method starts by looking for a user record with the given token. If none
    is found, it throws an `Exception`. If a valid token is being used, it checks
    to see if the token has been used. If so, we set the time limit since the first
    update of the token usage in the `$tokenTimeThreshold` local variable. If we are
    within this time frame, and if the number of token uses exceeds the configured
    setting, we return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: If none of the above conditions are met, then the token use is valid, so we
    either increment the number of uses if `$tokenTimeThreshold` is within the current
    time frame, or reset it.
  prefs: []
  type: TYPE_NORMAL
