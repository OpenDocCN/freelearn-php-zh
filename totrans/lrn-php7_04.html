<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;4.&#xA0;Creating Clean Code with OOP"><div class="book" id="VF2I2-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Creating Clean Code with OOP</h1></div></div></div><p class="calibre8">When applications start growing, representing more complex data structures becomes necessary. Primitive types like integers, strings, or arrays are not enough when you want to associate specific behavior to data. More than half a century ago, computer scientists started using the concept of objects to refer to the encapsulation of properties and functionality that represented an object in real life.</p><p class="calibre8">Nowadays, OOP is one of the most used programming paradigms, and you will be glad to know that PHP supports it. Knowing OOP is not just a matter of knowing the syntax of the language, but knowing when and how to use it. But do not worry, after this chapter and a bit of practice, you will become a confident OOP developer.</p><p class="calibre8">In this chapter, you will learn about the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Classes and objects</li><li class="listitem">Visibility, static properties, and methods</li><li class="listitem">Namespaces</li><li class="listitem">Autoloading classes</li><li class="listitem">Inheritance, interfaces, and traits</li><li class="listitem">Handling exceptions</li><li class="listitem">Design patterns</li><li class="listitem">Anonymous functions</li></ul></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Creating Clean Code with OOP">
<div class="book" title="Classes and objects"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec27" class="calibre1"/>Classes and objects</h1></div></div></div><p class="calibre8">
<span class="strong"><strong class="calibre2">Objects</strong></span>
<a id="id240" class="calibre1"/> are representations of real-life elements. Each object has a set of attributes that differentiates it from the rest of the objects of the same class, and is capable of a set of actions. A <span class="strong"><strong class="calibre2">class</strong></span>
<a id="id241" class="calibre1"/> is the definition of what an object looks like and what it can do, like a pattern for objects.</p><p class="calibre8">Let's take our<a id="id242" class="calibre1"/> bookstore example, and think of the kind of real-life objects it contains. We store books, and let people take them if they are available. We could think of two types of objects: books and customers. We can define these two classes as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php

class Book {
}

class Customer {
}</pre></div><p class="calibre8">A class is defined by<a id="id243" class="calibre1"/> the keyword <code class="email">class</code> followed by a valid class name—that follows the same rules as any other PHP label, like variable names—and a block of code. But if we want to have a specific book, that is, an object <code class="email">Book</code>—or instance of the class <code class="email">Book</code>—we have to instantiate it. To instantiate an object, we use the keyword <code class="email">new</code> followed by the name of the class. We assign the instance to a variable, as if it was a primitive type:</p><div class="informalexample"><pre class="programlisting">$book = new Book();
$customer = new Customer();</pre></div><p class="calibre8">You can create as many instances as you need, as long as you assign them to different variables:</p><div class="informalexample"><pre class="programlisting">$book1 = new Book();
$book2 = new Book();</pre></div></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Creating Clean Code with OOP">
<div class="book" title="Classes and objects">
<div class="book" title="Class properties"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec55" class="calibre1"/>Class properties</h2></div></div></div><p class="calibre8">Let's think about the<a id="id244" class="calibre1"/> properties of books first: they have a title, an author, and an ISBN. They can also be available or unavailable. Write the following code inside <code class="email">Book.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

class Book {
<span class="strong"><strong class="calibre2">    public $isbn;</strong></span>
<span class="strong"><strong class="calibre2">    public $title;</strong></span>
<span class="strong"><strong class="calibre2">    public $author;</strong></span>
<span class="strong"><strong class="calibre2">    public $available;</strong></span>
}</pre></div><p class="calibre8">This preceding snippet defines a class that represents the properties that a book has. Do not bother about the word <code class="email">public</code>; we will explain what it means when talking about visibility in the next section. For now, just think of properties as variables inside the class. We can use these variables in objects. Try adding this code at the end of the <code class="email">Book.php</code> file:</p><div class="informalexample"><pre class="programlisting">$book = new Book();
$book-&gt;title = "1984";
$book-&gt;author = "George Orwell";
$book-&gt;available = true;
var_dump($book);</pre></div><p class="calibre8">Printing the object shows the value of each of its properties, in a way similar to the way arrays do with their keys. You can see that properties have a type at the moment of printing, but we did not define this type explicitly; instead, the variable took the type of the value assigned. This works exactly the same way that normal variables do.</p><p class="calibre8">When creating <a id="id245" class="calibre1"/>multiple instances of an object and assigning values to their properties, each object will have their own values, so you will not override them. The next bit of code shows you how this works:</p><div class="informalexample"><pre class="programlisting">$book1 = new Book();
$book1-&gt;title = "1984";
$book2 = new Book();
$book2-&gt;title = "To Kill a Mockingbird";
var_dump($book1, $book2);</pre></div></div></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Creating Clean Code with OOP">
<div class="book" title="Classes and objects">
<div class="book" title="Class methods"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec56" class="calibre1"/>Class methods</h2></div></div></div><p class="calibre8">
<span class="strong"><strong class="calibre2">Methods</strong></span> are <a id="id246" class="calibre1"/>functions defined inside a class. Like functions, methods get some arguments and perform some actions, optionally returning a value. The advantage of methods is that they can use the properties of the object that invoked them. Thus, calling the same method in two different objects might have two different results.</p><p class="calibre8">Even though it is usually a bad idea to mix HTML with PHP, for the sake of learning, let's add a method in our class <code class="email">Book</code> that returns the book as in our already existing function <code class="email">printableTitle</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

class Book {
    public $isbn;
    public $title;
    public $author;
    public $available;

<span class="strong"><strong class="calibre2">    public function getPrintableTitle(): string {</strong></span>
<span class="strong"><strong class="calibre2">        $result = '&lt;i&gt;' . $this-&gt;title</strong></span>
<span class="strong"><strong class="calibre2">            . '&lt;/i&gt; - ' . $this-&gt;author;</strong></span>
<span class="strong"><strong class="calibre2">        if (!$this-&gt;available) {</strong></span>
<span class="strong"><strong class="calibre2">            $result .= ' &lt;b&gt;Not available&lt;/b&gt;';</strong></span>
<span class="strong"><strong class="calibre2">        }</strong></span>
<span class="strong"><strong class="calibre2">        return $result;</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
}</pre></div><p class="calibre8">As with properties, we add the keyword <code class="email">public</code> at the beginning of the function, but other than that, the rest looks just as a normal function. The other special bit is the use of <code class="email">$this</code>: it represents the object itself, and allows you to access the properties and methods of that same object. Note how we refer to the title, author, and available properties.</p><p class="calibre8">You can also <a id="id247" class="calibre1"/>update the values of the current object from one of its functions. Let's use the available property as an integer that shows the number of units available instead of just a Boolean. With that, we can allow multiple customers to borrow different copies of the same book. Let's add a method to give one copy of a book to a customer, updating the number of units available:</p><div class="informalexample"><pre class="programlisting">public function getCopy(): bool {
    if ($this-&gt;available &lt; 1) {
        return false;
    } else {
        $this-&gt;available--;
        return true;
    }
}</pre></div><p class="calibre8">In this preceding method, we first check if we have at least one available unit. If we do not, we return <code class="email">false</code> to let them know that the operation was not successful. If we do have a unit for the customer, we decrease the number of available units, and then return <code class="email">true</code>, letting them know that the operation was successful. Let's see how you can use this class:</p><div class="informalexample"><pre class="programlisting">&lt;?php
$book = new Book();
$book-&gt;title = "1984";
$book-&gt;author = "George Orwell";
$book-&gt;isbn = 9785267006323;
$book-&gt;available = 12;

<span class="strong"><strong class="calibre2">if ($book-&gt;getCopy()) {</strong></span>
    echo 'Here, your copy.';
} else {
    echo 'I am afraid that book is not available.';
}</pre></div><p class="calibre8">What would this last piece of code print? Exactly, <span class="strong"><strong class="calibre2">Here, your copy.</strong></span> But what would be the value of the property available? It would be 11, which is the result of the invocation of <code class="email">getCopy</code>.</p></div></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Creating Clean Code with OOP">
<div class="book" title="Classes and objects">
<div class="book" title="Class constructors"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec57" class="calibre1"/>Class constructors</h2></div></div></div><p class="calibre8">You might have noticed <a id="id248" class="calibre1"/>that it looks like a pain to instantiate the <code class="email">Book</code> class, and set all its values each time. What if our class has 30 properties instead of four? Well, hopefully, you will never do that, as it is very bad practice. Still, there is a way to mitigate that pain: <span class="strong"><strong class="calibre2">constructors</strong></span>.</p><p class="calibre8">Constructors are functions that are invoked when someone creates a new instance of the class. They look like normal methods, with the exception that their name is always <code class="email">__construct</code>, and that they do not have a <code class="email">return</code> statement, as they always have to return the new instance. Let's see an example:</p><div class="informalexample"><pre class="programlisting">public function __construct(int $isbn, string $title, string $author, int $available) {
    $this-&gt;isbn = $isbn;
    $this-&gt;title = $title;
    $this-&gt;author = $author;
    $this-&gt;available = $available;
}</pre></div><p class="calibre8">The constructor takes four arguments, and then assigns the value of one of the arguments to each of the properties of the instance. To instantiate the <code class="email">Book</code> class, we use the following:</p><div class="informalexample"><pre class="programlisting">$book = new Book("1984", "George Orwell", 9785267006323, 12);</pre></div><p class="calibre8">This object is exactly the same as the object when we set the value to each of its properties manually. But this one looks cleaner, right? This does not mean you cannot set new values to this object manually, it just helps you in constructing new objects.</p><p class="calibre8">As a constructor is still a function, it can use default arguments. Imagine that the number of units will usually be 0 when creating the object, and later, the librarian will add units when available. We could set a default value to the <code class="email">$available</code> argument of the constructor, so if we do not send the number of units when creating the object, the object will be instantiated with its default value:</p><div class="informalexample"><pre class="programlisting">public function __construct(
    int $isbn,
    string $title,
    string $author,
    int $available = 0
) {
    $this-&gt;isbn = $isbn;
    $this-&gt;title = $title;
    $this-&gt;author = $author;
    $this-&gt;available = $available;
}</pre></div><p class="calibre8">We could use the preceding constructor in two different ways:</p><div class="informalexample"><pre class="programlisting">$book1 = new Book("1984", "George Orwell", 9785267006323, 12);
$book2 = new Book("1984", "George Orwell", 9785267006323);</pre></div><p class="calibre8">
<code class="email">$book1</code> will set the<a id="id249" class="calibre1"/> number of units available to <code class="email">12</code>, whereas <code class="email">$book2</code> will set it to the default value of 0. But do not trust me; try it by yourself!</p></div></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Creating Clean Code with OOP">
<div class="book" title="Classes and objects">
<div class="book" title="Magic methods"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch04lvl2sec58" class="calibre1"/>Magic methods</h2></div></div></div><p class="calibre8">There is a special group of methods that have a different behavior than the normal ones. Those methods are called <a id="id250" class="calibre1"/>
<span class="strong"><strong class="calibre2">magic methods</strong></span>, and they usually are triggered by the interaction of the class or object, and not by invocations. You have already seen one of them, the constructor of the class, <code class="email">__construct</code>. This method is not invoked directly, but rather used when creating a new instance with <code class="email">new</code>. You can easily identify magic methods, because they start with <code class="email">__</code>. The following are some of the most used magic methods:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">__toString</code>: This <a id="id251" class="calibre1"/>method is invoked when we try to cast an object to a string. It takes no parameters, and it is expected to return a string.</li><li class="listitem"><code class="email">__call</code>: This is<a id="id252" class="calibre1"/> the method that PHP calls when you try to invoke a method on a class that does not exist. It gets the name of the method as a string and the list of parameters used in the invocation as an array, through the argument.</li><li class="listitem"><code class="email">__get</code>: This is a version <a id="id253" class="calibre1"/>of <code class="email">__call</code> for properties. It gets the name of the property that the user was trying to access through parameters, and it can return anything.</li></ul></div><p class="calibre8">You could use the <code class="email">__toString</code> method to replace the current <code class="email">getPrintableTitle</code> method in our <code class="email">Book</code> class. To do that, just change the name of the method as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">public function __toString() {</strong></span>
    $result = '&lt;i&gt;' . $this-&gt;title . '&lt;/i&gt; - ' . $this-&gt;author;
    if (!$this-&gt;available) {
        $result .= ' &lt;b&gt;Not available&lt;/b&gt;';
    }
    return $result;
}</pre></div><p class="calibre8">To try the preceding code, you can just add the following snippet that creates an object <code class="email">book</code> and then casts it to a string, invoking the <code class="email">__toString</code> method:</p><div class="informalexample"><pre class="programlisting">$book = new Book(1234, 'title', 'author');
$string = (string) $book; // title - author Not available</pre></div><p class="calibre8">As the name suggests, those are magic methods, so most of the time their features will look like magic. For obvious reasons, we personally encourage developers to use constructors and maybe <code class="email">__toString</code>, but be careful about when to use the rest, as you might make your code quite unpredictable for people not familiar with it.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Properties and methods visibility"><div class="book" id="10DJ42-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec28" class="calibre1"/>Properties and methods visibility</h1></div></div></div><p class="calibre8">So far, all the properties <a id="id254" class="calibre1"/>and methods <a id="id255" class="calibre1"/>defined in our <code class="email">Book</code> class were tagged as <code class="email">public</code>. That means that they are accessible to anyone, or more precisely, from anywhere. This is called the <span class="strong"><strong class="calibre2">visibility</strong></span>
<a id="id256" class="calibre1"/> of the property or method, and there are three types of visibility. In the order of being more restrictive to less, they are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">private</code>: This type<a id="id257" class="calibre1"/> allows access only to members of the same class. If A and B are instances of the class C, A can access the properties and methods of B.</li><li class="listitem"><code class="email">protected</code>: This<a id="id258" class="calibre1"/> type allows access to members of the same class and instances from classes that inherit from that one only. You will see inheritance in the next section.</li><li class="listitem"><code class="email">public</code>: This<a id="id259" class="calibre1"/> type refers to a property or method that is accessible from anywhere. Any classes or code in general from outside the class can access it.</li></ul></div><p class="calibre8">In order to show some examples, let's first create a second class in our application. Save this into a <code class="email">Customer.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php

class Customer {
    private $id;
    private $firstname;
    private $surname;
    private $email;

    public function __construct(
        int $id,
        string $firstname,
        string $surname,
        string $email
    ) {
        $this-&gt;id = $id;
        $this-&gt;firstname = $firstname;
        $this-&gt;surname = $surname;
        $this-&gt;email = $email;
    }
}</pre></div><p class="calibre8">This class represents a customer, and its properties consist of the general information that the bookstores usually know about their customers. But for security reasons, we cannot let everybody know about the personal data of our customers, so we set every property as <code class="email">private</code>.</p><p class="calibre8">So far, we have <a id="id260" class="calibre1"/>been adding the code to create objects in the same <code class="email">Book.php</code> file, but since now we have two classes, it seems natural to leave the classes in their respective files, and create and play with objects in a separate file. Let's name this third file <code class="email">init.php</code>. In order to instantiate objects of a given class, PHP needs to know where the class is. For that, just include the file with <code class="email">require_once</code>.</p><div class="informalexample"><pre class="programlisting">&lt;?php

<span class="strong"><strong class="calibre2">require_once __DIR__ . '/Book.php';</strong></span>
<span class="strong"><strong class="calibre2">require_once __DIR__ . '/Customer.php';</strong></span>

$book1 = new Book("1984", "George Orwell", 9785267006323, 12);
$book2 = new Book("To Kill a Mockingbird", "Harper Lee", 9780061120084, 2);

$customer1 = new Customer(1, 'John', 'Doe', 'johndoe@mail.com');
$customer2 = new Customer(2, 'Mary', 'Poppins', 'mp@mail.com');</pre></div><p class="calibre8">You do not need to include the files every single time. Once you include them, PHP will know where to find the classes, even though your code is in a different file.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note12" class="calibre1"/>Note</h3><p class="calibre8">
<span class="strong"><strong class="calibre2">Conventions for classes</strong></span>
</p><p class="calibre8">When working with<a id="id261" class="calibre1"/> classes, you should know that there are some conventions that everyone tries to follow in order to ensure clean code which is easy to maintain. The most important ones are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Each class should be in a file named the same as the class along with the <code class="email">.php</code> extension</li><li class="listitem">Class names should be in CamelCase, that is, each word should start with an uppercase letter, followed by the rest of the word in lowercase</li><li class="listitem">A file should contain only the code of one class</li><li class="listitem">Inside a class, you should first place the properties, then the constructor, and finally, the rest of the methods</li></ul></div></div><p class="calibre8">To show how visibility works, let's try the following code:</p><div class="informalexample"><pre class="programlisting">$book1-&gt;available = 2; // OK
$customer1-&gt;id = 3; // Error!</pre></div><p class="calibre8">We already know<a id="id262" class="calibre1"/> that the properties of the <code class="email">Book</code> class' objects are public, and therefore, editable from outside. But when trying to change a value from <code class="email">Customer</code>, PHP complains, as its properties are private.</p></div>

<div class="book" title="Properties and methods visibility">
<div class="book" title="Encapsulation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec59" class="calibre1"/>Encapsulation</h2></div></div></div><p class="calibre8">When working with objects, one of the most important concepts you have to know and apply is <a id="id263" class="calibre1"/>
<span class="strong"><strong class="calibre2">encapsulation</strong></span>. Encapsulation tries to group the data of the object with its methods in an attempt to hide the internal structure of the object from the rest of the world. In simple words, you could say that you use encapsulation if the properties of an object are private, and the only way to update them is through public methods.</p><p class="calibre8">The reason for using encapsulation is to make it easier for a developer to make changes to the internal structure of the class without directly affecting the external code that uses that class. For example, imagine that our <code class="email">Customer</code> class, that now has two properties to define its name—<code class="email">firstname</code> and <code class="email">surname</code>—has to change. From now on, we only have one property name that contains both. If we were accessing its properties straightaway, we should change all of those accesses!</p><p class="calibre8">Instead, if we set the properties as private and enable two public methods, <code class="email">getFirstname</code> and <code class="email">getSurname</code>, even if we have to change the internal structure of the class, we could just change the implementation of those two methods—which is at one place only—and the rest of the code that uses our class will not be affected at all. This concept is also known as <a id="id264" class="calibre1"/>
<span class="strong"><strong class="calibre2">information hiding</strong></span>.</p><p class="calibre8">The easiest way to implement this idea is by setting all the properties of the class as private and enabling two methods for each of the properties: one will get the current value (also known as<a id="id265" class="calibre1"/> <span class="strong"><strong class="calibre2">getter</strong></span>), and the other will allow you to set a new value (known as<a id="id266" class="calibre1"/> <span class="strong"><strong class="calibre2">setter</strong></span>). That's at least the most common and easy way to encapsulate data.</p><p class="calibre8">But let's go one step further: when defining a class, think of the data that you want the user to be able to change and to retrieve, and only add setters and getters for them. For example, customers might change their e-mail address, but their name, surname, and ID remains the same once we create them. The new definition of the class would look like the following:</p><div class="informalexample"><pre class="programlisting">&lt;?php

class Customer {
    private $id;
    private $name;
    private $surname;
    private $email;

    public function __construct(
        int $id,
        string $firstname,
        string $surname,
        string $email
    ) {
        $this-&gt;id = $id;
        $this-&gt;firstname = $firstname;
        $this-&gt;surname = $surname;
        $this-&gt;email = $email;
    }

<span class="strong"><strong class="calibre2">    public function getId(): id {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;id;</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
<span class="strong"><strong class="calibre2">    public function getFirstname(): string {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;firstname;</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
<span class="strong"><strong class="calibre2">    public function getSurname(): string {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;surname;</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
<span class="strong"><strong class="calibre2">    public function getEmail(): string {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;email;</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
<span class="strong"><strong class="calibre2">    public function setEmail(string $email) {</strong></span>
<span class="strong"><strong class="calibre2">        $this-&gt;email = $email;</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
}</pre></div><p class="calibre8">On the other hand, our<a id="id267" class="calibre1"/> books also remain almost the same. The only change possible is the number of available units. But we usually take or add one book at a time instead of setting the specific number of units available, so a setter here is not really useful. We already have the <code class="email">getCopy</code> method that takes one copy when possible; let's add an <code class="email">addCopy</code> method, plus the rest of the getters:</p><div class="informalexample"><pre class="programlisting">&lt;?php

class Book {
    private $isbn;
    private $title;
    private $author;
    private $available;

    public function __construct(
        int $isbn,
        string $title,
        string $author,
        int $available = 0
    ) {
        $this-&gt;isbn = $isbn;
        $this-&gt;title = $title;
        $this-&gt;author = $author;
        $this-&gt;available = $available;
    }
<span class="strong"><strong class="calibre2">    public function getIsbn(): int {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;isbn;</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
<span class="strong"><strong class="calibre2">    public function getTitle(): string {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;title;</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
<span class="strong"><strong class="calibre2">    public function getAuthor(): string {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;author;</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
<span class="strong"><strong class="calibre2">    public function isAvailable(): bool {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;available;</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>

    public function getPrintableTitle(): string {
        $result = '&lt;i&gt;' . $this-&gt;title . '&lt;/i&gt; - ' . $this-&gt;author;
        if (!$this-&gt;available) {
            $result .= ' &lt;b&gt;Not available&lt;/b&gt;';
        }
        return $result;
    }

    public function getCopy(): bool {
        if ($this-&gt;available &lt; 1) {
            return false;
        } else {
            $this-&gt;available--;
            return true;
        }
    }

<span class="strong"><strong class="calibre2">    public function addCopy() {</strong></span>
<span class="strong"><strong class="calibre2">        $this-&gt;available++;</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
}</pre></div><p class="calibre8">When the number of <a id="id268" class="calibre1"/>classes in your application, and with it, the number of relationships between classes increases, it is helpful to represent these classes in a diagram. Let's call this diagram a UML diagram of classes, or just an hierarchic tree. The hierarchic tree for our two classes would look as follows:</p><div class="mediaobject"><img src="../images/00016.jpeg" alt="Encapsulation" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">We only show public methods, as the protected or private ones cannot be called from outside the class, and thus, they are not useful for a developer who just wants to use these classes externally.</p></div></div>
<div class="book" title="Static properties and methods" id="11C3M1-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec29" class="calibre1"/>Static properties and methods</h1></div></div></div><p class="calibre8">So far, all the <a id="id269" class="calibre1"/>properties and methods were linked to a specific instance; so two<a id="id270" class="calibre1"/> different instances could have two different values for the same property. PHP allows you to have properties and methods linked to the class itself rather than to the object. These properties and methods are defined with the keyword <code class="email">static</code>.</p><div class="informalexample"><pre class="programlisting">private static $lastId = 0;</pre></div><p class="calibre8">Add the preceding property to the <code class="email">Customer</code> class. This property shows the last ID assigned to a user, and is useful in order to know the ID that should be assigned to a new user. Let's change the constructor of our class as follows:</p><div class="informalexample"><pre class="programlisting">public function __construct(
    int $id,
    string $name,
    string $surname,
    string $email
) {
<span class="strong"><strong class="calibre2">    if ($id == null) {</strong></span>
<span class="strong"><strong class="calibre2">        $this-&gt;id = ++self::$lastId;</strong></span>
<span class="strong"><strong class="calibre2">    } else {</strong></span>
<span class="strong"><strong class="calibre2">        $this-&gt;id = $id;</strong></span>
<span class="strong"><strong class="calibre2">        if ($id &gt; self::$lastId) {</strong></span>
<span class="strong"><strong class="calibre2">            self::$lastId = $id;</strong></span>
<span class="strong"><strong class="calibre2">        }</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
    $this-&gt;name = $name;
    $this-&gt;surname = $surname;
    $this-&gt;email = $email;
}</pre></div><p class="calibre8">Note that when referring to a static property, we do not use the variable <code class="email">$this</code>. Instead, we use <code class="email">self::</code>, which is not tied to any instance but to the class itself. In this last constructor, we have two options. We are either provided with an ID value that is not null, or we send a null in its place. When the received ID is null, we use the static property <code class="email">$lastId</code> to know the last ID used, increase it by one, and assign it to the property <code class="email">$id</code>. If the last <a id="id271" class="calibre1"/>ID we inserted was 5, this will update the static property to<a id="id272" class="calibre1"/> 6, and then assign it to the instance property. Next time we create a new customer, the <code class="email">$lastId</code> static property will be 6. Instead, if we get a valid ID as part of the arguments, we assign it, and check if the assigned <code class="email">$id</code> is greater than the static <code class="email">$lastId</code>. If it is, we update it. Let's see how we would use this:</p><div class="informalexample"><pre class="programlisting">$customer1 = new Customer(3, 'John', 'Doe', 'johndoe@mail.com');
$customer2 = new Customer(null, 'Mary', 'Poppins', 'mp@mail.com');
$customer3 = new Customer(7, 'James', 'Bond', '007@mail.com');</pre></div><p class="calibre8">In the preceding example, <code class="email">$customer1</code> specifies that his ID is 3, probably because he is an existing customer and wants to keep the same ID. That sets both his ID and the last static ID to 3. When creating the second customer, we do not specify the ID, so the constructor will take the last ID, increase it by 1, and assign it to the customer. So <code class="email">$customer2</code> will have the ID 4, and the latest ID will be 4 too. Finally, our secret agent knows what he wants, so he forces the system to have the ID as 7. The latest ID will be updated to 7 too.</p><p class="calibre8">Another benefit of static properties and methods is that we do not need an object to use them. You can refer to a static property or method by specifying the name of the class, followed by <code class="email">::</code>, and the name of the property/method. That is, of course, if the visibility rules allow you to do that, which, in this case, it does not, as the property is private. Let's add a public static method to retrieve the last ID:</p><div class="informalexample"><pre class="programlisting">public static function getLastId(): int {
    return self::$lastId;
}</pre></div><p class="calibre8">You can reference it either using the class name or an existing instance, from anywhere in the code:</p><div class="informalexample"><pre class="programlisting">Customer::getLastId();
$customer1::getLastId();</pre></div></div>
<div class="book" title="Namespaces" id="12AK81-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec30" class="calibre1"/>Namespaces</h1></div></div></div><p class="calibre8">You know that you<a id="id273" class="calibre1"/> cannot have two classes with the same name, since PHP would not know which one is being referred to when creating a new object. To solve this issue, PHP allows the use of <span class="strong"><strong class="calibre2">namespaces</strong></span>, which act as paths in a filesystem. In this way, you can have as many classes with the same name as you need, as long as they are all defined in different namespaces. It is worth noting that, even though namespaces and the file path will usually be the same, this is enforced by the developer rather than by the language; you could actually use any namespace that has nothing to do with the filesystem.</p><p class="calibre8">Specifying a namespace has to be the first thing that you do in a file. In order to do that, use the <code class="email">namespace</code> keyword followed by the namespace. Each section of the namespace is separated by <code class="email">\</code>, as if it was a different directory. If you do not specify the namespace, the class will belong to the base namespace, or root. At the beginning of both files—<code class="email">Book.php</code> and <code class="email">Customer.php</code>—add the following:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Domain;</pre></div><p class="calibre8">The preceding line of code sets the namespace of our classes as <code class="email">Bookstore\Domain</code>. The full name of our classes then is <code class="email">Bookstore\Domain\Book</code> and <code class="email">Bookstore\Domain\Customer</code>. If you try to access the <code class="email">init.php</code> file from your browser, you will see an error saying that either the class <code class="email">Book</code> or the class <code class="email">Customer</code> were not found. But we included the files, right? That happens because PHP thinks that you are trying to access <code class="email">\Book</code> and <code class="email">\Customer</code> from the root. Do not worry, there are several ways to amend this.</p><p class="calibre8">One way would be to specify the full name of the classes when referencing them, that is, using <code class="email">$customer = new Bookstore\Domain\Book();</code> instead of <code class="email">$book = new Book();</code>. But that does not sound practical, does it?</p><p class="calibre8">Another way would be to say that the <code class="email">init.php</code> file belongs to the <code class="email">BookStore\Domain</code> namespace. That means that all the references to classes inside <code class="email">init.php</code> will have the <code class="email">BookStore\Domain</code> prefixed to them, and you will be able to use <code class="email">Book</code> and <code class="email">Customer</code>. The downside of this solution is that you cannot easily reference other classes from other namespaces, as any reference to a class will be prefixed with that namespace.</p><p class="calibre8">The best solution is to use the keyword <code class="email">use</code>. This keyword allows you to specify a full class name at the beginning of the file, and then use the simple name of the class in the rest of that file. Let's see an example:</p><div class="informalexample"><pre class="programlisting">&lt;?php

<span class="strong"><strong class="calibre2">use Bookstore\Domain\Book;</strong></span>
<span class="strong"><strong class="calibre2">use Bookstore\Domain\Customer;</strong></span>

require_once __DIR__ . '/Book.php';
require_once __DIR__ . '/Customer.php';
//...</pre></div><p class="calibre8">In the preceding file, each time that we reference <code class="email">Book</code> or <code class="email">Customer</code>, PHP will know that we actually want to use the full class name, that is, with <code class="email">Bookstore\Domain\</code> prefixed to it. This solution allows you to have a clean code when referencing those classes, and at the same time, to be able to reference classes from other namespaces if needed.</p><p class="calibre8">But what if you want to include two different classes with the same name in the same file? If you set two <code class="email">use</code> statements, PHP will not know which one to choose, so we still have the same problem as before! To fix that, either you use the full class name—with namespace—each time you want to reference any of the classes, or you use aliases.</p><p class="calibre8">Imagine that we <a id="id274" class="calibre1"/>have two <code class="email">Book</code> classes, the first one in the namespace <code class="email">Bookstore\Domain</code> and the second one in <code class="email">Library\Domain</code>. To solve the conflict, you could do as follows:</p><div class="informalexample"><pre class="programlisting">use Bookstore\Domain\Book;
<span class="strong"><strong class="calibre2">use Library\Domain\Book as LibraryBook;</strong></span>
</pre></div><p class="calibre8">The keyword <code class="email">as</code> sets an alias to that class. In that file, whenever you reference the class <code class="email">LibraryBook</code>, you will actually be referencing the class <code class="email">Library\Domain\Book</code>. And when referencing <code class="email">Book</code>, PHP will just use the one from <code class="email">Bookstore</code>. Problem solved!</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Autoloading classes" id="1394Q1-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec31" class="calibre1"/>Autoloading classes</h1></div></div></div><p class="calibre8">As you already know, in <a id="id275" class="calibre1"/>order to use a class, you need to include the file that defines it. So far, we have been including the files manually, as we only had a couple of classes and used them in one file. But what happens when we use several classes in several files? There must be a smarter way, right? Indeed there is. <span class="strong"><strong class="calibre2">Autoloading</strong></span>
<a id="id276" class="calibre1"/> to the rescue!</p><p class="calibre8">Autoloading is a PHP feature that allows your program to search and load files automatically given some set of predefined rules. Each time you reference a class that PHP does not know about, it will ask the<a id="id277" class="calibre1"/> <span class="strong"><strong class="calibre2">autoloader</strong></span>. If the autoloader can figure out which file that class is in, it will load it, and the execution of the program will continue as normal. If it does not, PHP will stop the execution.</p><p class="calibre8">So, what is the autoloader? It is no more than a PHP function that gets a class name as a parameter, and it is expected to load a file. There are two ways of implementing an autoloader: either by using the <code class="email">__autoload</code> function or the <code class="email">spl_autoload_register</code> one.</p></div>

<div class="book" title="Autoloading classes" id="1394Q1-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Using the __autoload function"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec60" class="calibre1"/>Using the __autoload function</h2></div></div></div><p class="calibre8">Defining a function <a id="id278" class="calibre1"/>named <code class="email">__autoload</code> tells PHP that the function is the autoloader that it must use. You could implement an easy solution:</p><div class="informalexample"><pre class="programlisting">function __autoload($classname) {
    $lastSlash = strpos($classname, '\\') + 1;
    $classname = substr($classname, $lastSlash);
    $directory = str_replace('\\', '/', $classname);
    $filename = __DIR__ . '/' . $directory . '.php';
    require_once($filename);
}</pre></div><p class="calibre8">Our intention is to keep all PHP files in <code class="email">src</code>, that is, the source. Inside this directory, the directory tree will emulate the namespace tree of the classes excluding the first section <code class="email">BookStore</code>, which is useful as a namespace but not necessary as a directory. That means that our <code class="email">Book</code> class, with full class name <code class="email">BookStore\Domain\Book</code>, will be in <code class="email">src/Domain/Book.php</code>.</p><p class="calibre8">In order to achieve that, our <code class="email">__autoload</code> function tries to find the first occurrence of the backslash <code class="email">\</code> with <code class="email">strpos</code>, and then extracts from that position until the end with <code class="email">substr</code>. This, in practice, just removes the first section of the namespace, <code class="email">BookStore</code>. After that, we replace all <code class="email">\</code> by <code class="email">/</code> so that the filesystem can understand the path. Finally, we concatenate the current directory, the class name as a directory, and the <code class="email">.php</code> extension.</p><p class="calibre8">Before trying that, remember to create the <code class="email">src/Domain</code> directory and move the two classes inside it. Also, to make sure that we are testing the autoloader, save the following as your <code class="email">init.php</code>, and go to <code class="email">http://localhost:8000/init.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

use Bookstore\Domain\Book;
use Bookstore\Domain\Customer;

function __autoload($classname) {
    $lastSlash = strpos($classname, '\\') + 1;
    $classname = substr($classname, $lastSlash);
    $directory = str_replace('\\', '/', $classname);
    $filename = __DIR__ . '/src/' . $directory . '.php'
    require_once($filename);
}

$book1 = new Book("1984", "George Orwell", 9785267006323, 12);
$customer1 = new Customer(5, 'John', 'Doe', 'johndoe@mail.com');</pre></div><p class="calibre8">The browser does not complain now, and there is no explicit <code class="email">require_once</code>. Also remember that the <code class="email">__autoload</code> function has to be defined only once, not in each file. So from now on, when you want to use your classes, as soon as the class is in a namespace and file that follows the <a id="id279" class="calibre1"/>convention, you only need to define the <code class="email">use</code> statement. Way cleaner than before, right?</p></div></div>

<div class="book" title="Autoloading classes" id="1394Q1-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="Using the spl_autoload_register function"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec61" class="calibre1"/>Using the spl_autoload_register function</h2></div></div></div><p class="calibre8">The <code class="email">__autoload</code> solution<a id="id280" class="calibre1"/> looks pretty good, but it has a small problem: what if our code is so complex that we do not have only one convention, and we need more than one implementation of the <code class="email">__autoload</code> function? As we cannot define two functions with the same name, we need a way to tell PHP to keep a list of possible implementations of the autoloader, so it can try all of them until one works.</p><p class="calibre8">That is the job of <code class="email">spl_autoload_register</code>. You define your autoloader function with a valid name, and then invoke the function <code class="email">spl_autoload_register</code>, sending the name of your autoloader as an argument. You can call this function as many times as the different autoloaders you have in your code. In fact, even if you have only one autoloader, using this system is still a better option than the <code class="email">__autoload</code> one, as you make it easier for someone else who has to add a new autoloader later:</p><div class="informalexample"><pre class="programlisting">function autoloader($classname) {
    $lastSlash = strpos($classname, '\\') + 1;
    $classname = substr($classname, $lastSlash);
    $directory = str_replace('\\', '/', $classname);
    $filename = __DIR__ . '/' . $directory . '.php';
    require_once($filename);
}
<span class="strong"><strong class="calibre2">spl_autoload_register('autoloader');</strong></span>
</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Inheritance"><div class="book" id="147LC2-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec32" class="calibre1"/>Inheritance</h1></div></div></div><p class="calibre8">We have presented the <a id="id281" class="calibre1"/>object-oriented paradigm as the panacea for complex data structures, and even though we have shown that we can define objects with properties and methods, and it looks pretty and fancy, it is not something that we could not solve with arrays. Encapsulation was one feature that made objects more useful than arrays, but their true power lies in inheritance.</p></div>

<div class="book" title="Inheritance">
<div class="book" title="Introducing inheritance"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec62" class="calibre1"/>Introducing inheritance</h2></div></div></div><p class="calibre8">Inheritance in OOP is <a id="id282" class="calibre1"/>the ability to pass the implementation of the class from parents to children. Yes, classes can have parents, and the technical way of referring to this feature is that a class <span class="strong"><em class="calibre12">extends</em></span> from another class. When extending a class, we get all the properties and methods that are not defined as private, and the child class can use them as if they were its own. The limitation is that a class can only extend from one parent.</p><p class="calibre8">To show an example, let's consider our <code class="email">Customer</code> class. It contains the properties <code class="email">firstname</code>, <code class="email">surname</code>, <code class="email">email</code>, and <code class="email">id</code>. A customer is actually a specific type of person, one that is registered in our system, so he/she can get books. But there can be other types of persons in our system, like librarian or guest. And all of them would have some common properties to all people, that is, <code class="email">firstname</code> and <code class="email">surname</code>. So it would make sense if we create a <code class="email">Person</code> class, and make the <code class="email">Customer</code> class extend from it. The hierarchic tree would look as follows:</p><div class="mediaobject"><img src="../images/00017.jpeg" alt="Introducing inheritance" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Note how <code class="email">Customer</code> is connected to <code class="email">Person</code>. The methods in <code class="email">Person</code> are not defined in <code class="email">Customer</code>, as they are implicit from the extension. Now save the new class in <code class="email">src/Domain/Person.php</code>, following our convention:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Domain;

class Person {
    protected $firstname;
    protected $surname;

    public function __construct(string $firstname, string $surname) {
        $this-&gt;firstname = $firstname;
        $this-&gt;surname = $surname;
    }

    public function getFirstname(): string {
        return $this-&gt;firstname;
    }

    public function getSurname(): string {
        return $this-&gt;surname;
    }
}</pre></div><p class="calibre8">The class defined in <a id="id283" class="calibre1"/>the preceding code snippet does not look special; we have just defined two properties, a constructor and two getters. Note though that we defined the properties as protected, because if we defined them as private, the children would not be able to access them. Now we can update our <code class="email">Customer</code> class by removing the duplicate properties and its getters:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Domain;

class Customer extends Person {
    private static $lastId = 0;
    private $id;
    private $email;

    public function __construct(
        int $id,
        string $name,
        string $surname,
        string $email
    ) {
        if (empty($id)) {
            $this-&gt;id = ++self::$lastId;
        } else {
            $this-&gt;id = $id;
            if ($id &gt; self::$lastId) {
                self::$lastId = $id;
            }
        }
        $this-&gt;name = $name;
        $this-&gt;surname = $surname;
        $this-&gt;email = $email;
    }

    public static function getLastId(): int {
        return self::$lastId;
    }

    public function getId(): int {
        return $this-&gt;id;
    }

    public function getEmail(): string {
        return $this-&gt;email;
    }

    public function setEmail($email): string {
        $this-&gt;email = $email;
    }
}</pre></div><p class="calibre8">Note the new <a id="id284" class="calibre1"/>keyword <code class="email">extends</code>; it tells PHP that this class is a child of the <code class="email">Person</code> class. As both <code class="email">Person</code> and <code class="email">Customer</code> are in the same namespace, you do not have to add any <code class="email">use</code> statement, but if they were not, you should let it know how to find the parent. This code works fine, but we can see that there is a bit of duplication of code. The constructor of the <code class="email">Customer</code> class is doing the same job as the constructor of the <code class="email">Person</code> class! We will try to fix it really soon.</p><p class="calibre8">In order to reference a method or property of the parent class from the child, you can use <code class="email">$this</code> as if the property or method was in the same class. In fact, you could say it actually is. But PHP allows you to redefine a method in the child class that was already present in the parent. If you want to reference the parent's implementation, you cannot use <code class="email">$this</code>, as PHP will invoke the one in the child. To force PHP to use the parent's method, use the keyword <code class="email">parent::</code> instead of <code class="email">$this</code>. Update the constructor of the <code class="email">Customer</code> class as follows:</p><div class="informalexample"><pre class="programlisting">public function __construct(
    int $id,
    string $firstname,
    string $surname,
    string $email
) {
<span class="strong"><strong class="calibre2">    parent::__construct($firstname, $surname);</strong></span>
    if (empty($id)) {
        $this-&gt;id = ++self::$lastId;
    } else {
        $this-&gt;id = $id;
        if ($id &gt; self::$lastId) {
            self::$lastId = $id;
        }
    }
    $this-&gt;email = $email;
}</pre></div><p class="calibre8">This new constructor does not duplicate code. Instead, it calls the constructor of the parent class <code class="email">Person</code>, sending <code class="email">$firstname</code> and <code class="email">$surname</code>, and letting the parent do what it already knows how to do. We avoid code duplication and, on top of that, we make it easier for any future changes to be made in the constructor of <code class="email">Person</code>. If we need to change the implementation of the constructor of <code class="email">Person</code>, we will change it in one place only, instead of in<a id="id285" class="calibre1"/> all the children.</p></div></div>

<div class="book" title="Inheritance">
<div class="book" title="Overriding methods"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec63" class="calibre1"/>Overriding methods</h2></div></div></div><p class="calibre8">As said before, when<a id="id286" class="calibre1"/> extending from a class, we get all the methods of the parent<a id="id287" class="calibre1"/> class. That is implicit, so they are not actually written down inside the child's class. What would happen if you implement another method with the same signature and/or name? You will be <span class="strong"><em class="calibre12">overriding the method</em></span>.</p><p class="calibre8">As we do not need this feature in our classes, let's just add some code in our <code class="email">init.php</code> file to show this behavior, and then you can just remove it. Let's define a class <code class="email">Pops</code>, a class <code class="email">Child</code> that extends from the parent, and a <code class="email">sayHi</code> method in both of them:</p><div class="informalexample"><pre class="programlisting">class Pops {
    public function sayHi() {
        echo "Hi, I am pops.";
    }
}

class Child extends Pops{
<span class="strong"><strong class="calibre2">    public function sayHi() {</strong></span>
<span class="strong"><strong class="calibre2">        echo "Hi, I am a child.";</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
}

$pops = new Pops();
$child = new Child();
echo $pops-&gt;sayHi(); // Hi, I am pops.
echo $child-&gt;sayHi(); // Hi, I am Child.</pre></div><p class="calibre8">The highlighted code shows you that the method has been overridden, so when invoking it from a child's point of view, we will be using it rather than the one inherited from its father. But what happens if we want to reference the inherited one too? You can always reference it with the keyword <code class="email">parent</code>. Let's see how it works:</p><div class="informalexample"><pre class="programlisting">class Child extends Pops{
    public function sayHi() {
        echo "Hi, I am a child.";
<span class="strong"><strong class="calibre2">        parent::sayHi();</strong></span>
    }
}

$child = new Child();
echo $child-&gt;sayHi(); // Hi, I am Child. Hi I am pops.</pre></div><p class="calibre8">Now the child is saying <code class="email">hi</code> for both himself and his father. It seems very easy and handy, right? Well, there is a<a id="id288" class="calibre1"/> restriction. Imagine that, as in real life, the child was very shy, and he would not say hi to everybody. We could try to set the visibility of the method as protected, but see what happens:</p><div class="informalexample"><pre class="programlisting">class Child extends Pops{
<span class="strong"><strong class="calibre2">    protected function sayHi() {</strong></span>
        echo "Hi, I am a child.";
    }
}</pre></div><p class="calibre8">When trying this code, even <a id="id289" class="calibre1"/>without trying to instantiate it, you will get a fatal error complaining about the access level of that method. The reason is that when overriding, the method has to have at least as much visibility as the one inherited. That means that if we inherit a protected one, we can override it with another protected or a public one, but never with a private one.</p></div></div>

<div class="book" title="Inheritance">
<div class="book" title="Abstract classes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec64" class="calibre1"/>Abstract classes</h2></div></div></div><p class="calibre8">Remember that you can <a id="id290" class="calibre1"/>extend only from one parent class each time. That means that <code class="email">Customer</code> can only extend from <code class="email">Person</code>. But if we want to make this hierarchic tree more<a id="id291" class="calibre1"/> complex, we can create children classes that extend from <code class="email">Customer</code>, and those classes will extend implicitly from <code class="email">Person</code> too. Let's create two types of customer: basic and premium. These two customers will have the same properties and methods from <code class="email">Customer</code> and from <code class="email">Person</code>, plus the new ones that we implement in each one of them.</p><p class="calibre8">Save the following code as <code class="email">src/Domain/Customer/Basic.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Domain\Customer;

use Bookstore\Domain\Customer;

class Basic extends Customer {
    public function getMonthlyFee(): float {
        return 5.0;
    }

    public function getAmountToBorrow(): int {
        return 3;
    }

    public function getType(): string {
        return 'Basic';
    }
}</pre></div><p class="calibre8">And the<a id="id292" class="calibre1"/> following <a id="id293" class="calibre1"/>code as <code class="email">src/Domain/Customer/Premium.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Domain\Customer;

use Bookstore\Domain\Customer;

class Premium extends Customer {
    public function getMonthlyFee(): float {
        return 10.0;
    }

    public function getAmountToBorrow(): int {
        return 10;
    }

    public function getType(): string {
        return 'Premium';
    }
}</pre></div><p class="calibre8">Things to note in the preceding two codes are that we extend from <code class="email">Customer</code> in two different classes, and it is perfectly legal— we can extend from classes in different namespaces. With this addition, the hierarchic tree for <code class="email">Person</code> would look as follows:</p><div class="mediaobject"><img src="../images/00018.jpeg" alt="Abstract classes" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">We define the same<a id="id294" class="calibre1"/> methods in these two classes, but their implementations are <a id="id295" class="calibre1"/>different. The aim of this approach is to use both types of customers indistinctively, without knowing which one it is each time. For example, we could temporally have the following code in our <code class="email">init.php</code>. Remember to add the <code class="email">use</code> statement to import the class <code class="email">Customer</code> if you do not have it.</p><div class="informalexample"><pre class="programlisting">function checkIfValid(Customer $customer, array $books): bool {
    return $customer-&gt;getAmountToBorrow() &gt;= count($books);
}</pre></div><p class="calibre8">The preceding function would tell us if a given customer could borrow all the books in the array. Notice that the type hinting of the method says <code class="email">Customer</code>, without specifying which one. This will accept objects that are instances of <code class="email">Customer</code> or any class that extends from <code class="email">Customer</code>, that is, <code class="email">Basic</code> or <code class="email">Premium</code>. Looks legit, right? Let's try to use it then:</p><div class="informalexample"><pre class="programlisting">$customer1 = new Basic(5, 'John', 'Doe', 'johndoe@mail.com');
var_dump(checkIfValid($customer1, [$book1])); // ok
$customer2 = new Customer(7, 'James', 'Bond', 'james@bond.com');
var_dump(checkIfValid($customer2, [$book1])); // fails</pre></div><p class="calibre8">The first invocation works as expected, but the second one fails, even though we are sending a <code class="email">Customer</code> object. The problem arises because the parent does not know about any <code class="email">getAmountToBorrow</code> method! It also looks dangerous that we rely on the children to always implement that method. The solution lies in using abstract classes.</p><p class="calibre8">An <span class="strong"><strong class="calibre2">abstract class</strong></span> is a class<a id="id296" class="calibre1"/> that cannot be instantiated. Its sole purpose is to make<a id="id297" class="calibre1"/> sure that its children are correctly implemented. Declaring a class as abstract is done with the keyword <code class="email">abstract</code>, followed by the definition of a normal class. We can also specify the methods that the children are forced to implement, without implementing them in the parent class. Those methods are called abstract methods, and are defined with the keyword <code class="email">abstract</code> at the beginning. Of course, the rest of the normal methods can stay there too, and will be inherited by its children:</p><div class="informalexample"><pre class="programlisting">&lt;?php
<span class="strong"><strong class="calibre2">abstract class Customer extends Person {</strong></span>
//...
<span class="strong"><strong class="calibre2">    abstract public function getMonthlyFee();</strong></span>
<span class="strong"><strong class="calibre2">    abstract public function getAmountToBorrow();</strong></span>
<span class="strong"><strong class="calibre2">    abstract public function getType();</strong></span>
//...
}</pre></div><p class="calibre8">The preceding abstraction solves both problems. First, we will not be able to send any instance of the class <code class="email">Customer</code>, because we cannot instantiate it. That means that all the objects that the <code class="email">checkIfValid</code> method is going to accept are only the children from <code class="email">Customer</code>. On the other hand, declaring abstract methods forces all the children that extend the class to implement them. With that, we make sure that all objects will implement <code class="email">getAmountToBorrow</code>, and our code is safe.</p><p class="calibre8">The new hierarchic tree will define the three abstract methods in <code class="email">Customer</code>, and will omit them for its children. It is true that we are implementing them in the children, but as they are enforced by <code class="email">Customer</code>, and thanks to abstraction, we are sure that all classes extending from it will have to implement them, and that it is safe to do so. Let's see how this is done:</p><div class="mediaobject"><img src="../images/00019.jpeg" alt="Abstract classes" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">With the last new <a id="id298" class="calibre1"/>addition, your <code class="email">init.php</code> file should fail. The reason is that it is<a id="id299" class="calibre1"/> trying to instantiate the class <code class="email">Customer</code>, but now it is abstract, so you cannot. Instantiate a concrete class, that is, one that is not abstract, to solve the problem.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Interfaces"><div class="book" id="1565U2-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec33" class="calibre1"/>Interfaces</h1></div></div></div><p class="calibre8">An <span class="strong"><strong class="calibre2">interface</strong></span>
<a id="id300" class="calibre1"/> is an OOP element that groups a set of function declarations without implementing them, that is, it specifies the name, return type, and arguments, but not the block of code. Interfaces are different from abstract classes, since they cannot contain any implementation at all, whereas abstract classes could mix both method definitions and implemented ones. The purpose of interfaces is to state what a class can do, but not how it is done.</p><p class="calibre8">From our code, we can identify a potential usage of interfaces. Customers have an expected behavior, but its implementation changes depending on the type of customer. So, <code class="email">Customer</code> could be an interface instead of an abstract class. But as an interface cannot implement any function, nor can it contain properties, we will have to move the concrete code from the <code class="email">Customer</code> class to somewhere else. For now, let's move it up to the <code class="email">Person</code> class. Edit the <code class="email">Person</code> class as shown:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Domain;

class Person {

<span class="strong"><strong class="calibre2">    private static $lastId = 0;</strong></span>
<span class="strong"><strong class="calibre2">    protected $id;</strong></span>
    protected $firstname;
    protected $surname;
<span class="strong"><strong class="calibre2">    protected $email;</strong></span>

<span class="strong"><strong class="calibre2">    public function __construct(</strong></span>
<span class="strong"><strong class="calibre2">        int $id,</strong></span>
<span class="strong"><strong class="calibre2">        string $firstname,</strong></span>
<span class="strong"><strong class="calibre2">        string $surname,</strong></span>
<span class="strong"><strong class="calibre2">        string $email</strong></span>
<span class="strong"><strong class="calibre2">    ) {</strong></span>
<span class="strong"><strong class="calibre2">        $this-&gt;firstname = $firstname;</strong></span>
<span class="strong"><strong class="calibre2">        $this-&gt;surname = $surname;</strong></span>
<span class="strong"><strong class="calibre2">        $this-&gt;email = $email;</strong></span>

<span class="strong"><strong class="calibre2">        if (empty($id)) {</strong></span>
<span class="strong"><strong class="calibre2">            $this-&gt;id = ++self::$lastId;</strong></span>
<span class="strong"><strong class="calibre2">        } else {</strong></span>
<span class="strong"><strong class="calibre2">            $this-&gt;id = $id;</strong></span>
<span class="strong"><strong class="calibre2">            if ($id &gt; self::$lastId) {</strong></span>
<span class="strong"><strong class="calibre2">                self::$lastId = $id;</strong></span>
<span class="strong"><strong class="calibre2">            }</strong></span>
<span class="strong"><strong class="calibre2">        }</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>

    public function getFirstname(): string {
        return $this-&gt;firstname;
    }
    public function getSurname(): string {
        return $this-&gt;surname;
    }
<span class="strong"><strong class="calibre2">    public static function getLastId(): int {</strong></span>
<span class="strong"><strong class="calibre2">        return self::$lastId;</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
<span class="strong"><strong class="calibre2">    public function getId(): int {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;id;</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
<span class="strong"><strong class="calibre2">    public function getEmail(): string {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;email;</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note13" class="calibre1"/>Note</h3><p class="calibre8">
<span class="strong"><strong class="calibre2">Complicating things more than necessary</strong></span>
</p><p class="calibre8">Interfaces are very useful, but there is always a place and a time for everything. As our application is very simple due to its didactic nature, there is no real place for them. The abstract class already defined in the previous section is the best approach for our scenario. But just for the sake of showing how interfaces work, we will be adapting our code to them.</p><p class="calibre8">Do not worry though, as most of the code that we are going to introduce now will be replaced by better practices once we introduce databases and the MVC pattern in <a class="calibre1" title="Chapter 5. Using Databases" href="part0045_split_000.html#1AT9A1-edcc22b134104d5db0bf3aa086c86851">Chapter 5</a>, <span class="strong"><em class="calibre12">Using Databases</em></span>, and <a class="calibre1" title="Chapter 6. Adapting to MVC" href="part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851">Chapter 6</a>, <span class="strong"><em class="calibre12">Adapting to MVC</em></span>.</p><p class="calibre8">When writing your own applications, do not try to complicate things more than necessary. It is a common pattern to see very complex code from developers that try to show up all the skills they have in a very simple scenario. Use only the necessary tools to leave clean code that is easy to maintain, and of course, that works as expected.</p></div><p class="calibre8">Change the<a id="id301" class="calibre1"/> content of <code class="email">Customer.php</code> with the following:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Domain;

interface Customer {
    public function getMonthlyFee(): float;
    public function getAmountToBorrow(): int;
    public function getType(): string;
}</pre></div><p class="calibre8">Note that an interface is very similar to an abstract class. The differences are that it is defined with the keyword <code class="email">interface</code>, and that its methods do not have the word <code class="email">abstract</code>. Interfaces cannot be instantiated, since their methods are not implemented as with abstract classes. The only thing you can do with them is make a class to implement them.</p><p class="calibre8">
<span class="strong"><em class="calibre12">Implementing</em></span> an interface means implementing all the methods defined in it, like when we extended an abstract class. It has all the benefits of the extension of abstract classes, such as belonging to that type—useful when type hinting. From the developer's point of view, using a class that implements an interface is like writing a contract: you ensure that your class will always have the methods declared in the interface, regardless of the implementation. Because of that, interfaces only care about public methods, which are the ones that other developers can use. The only change you need to make in your code is to replace the keywords <code class="email">extends</code> by <code class="email">implements</code>:</p><div class="informalexample"><pre class="programlisting">class Basic implements Customer {</pre></div><p class="calibre8">So, why would someone use an interface if we could always use an abstract class that not only enforces the implementation of methods, but also allows inheriting code as well? The reason is that you can only extend from one class, but you can implement multiple instances at the same time. Imagine that you had another interface that defined payers. This could identify someone that has the ability to pay something, regardless of what it is. Save the following code in <code class="email">src/Domain/Payer.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Domain;

interface Payer {
    public function pay(float $amount);
    public function isExtentOfTaxes(): bool;
}</pre></div><p class="calibre8">Now our basic and <a id="id302" class="calibre1"/>premium customers can implement both the interfaces. The basic customer will look like the following:</p><div class="informalexample"><pre class="programlisting">//...
use Bookstore\Domain\Customer; 
<span class="strong"><strong class="calibre2">use Bookstore\Domain\Person;</strong></span>

<span class="strong"><strong class="calibre2">class Basic extends Person implements Customer {</strong></span>
    public function getMonthlyFee(): float {
//...</pre></div><p class="calibre8">And the premium customer will change in the same way:</p><div class="informalexample"><pre class="programlisting">//...
use Bookstore\Domain\Customer; 
<span class="strong"><strong class="calibre2">use Bookstore\Domain\Person;</strong></span>

<span class="strong"><strong class="calibre2">class Premium extends Person implements Customer {</strong></span>
    public function getMonthlyFee(): float {
//...</pre></div><p class="calibre8">You should see that this code would no longer work. The reason is that although we implement a second interface, the methods are not implemented. Add these two methods to the basic customer class:</p><div class="informalexample"><pre class="programlisting">public function pay(float $amount) {
    echo "Paying $amount.";
}

public function isExtentOfTaxes(): bool {
    return false;
}</pre></div><p class="calibre8">Add these two methods to the premium customer class:</p><div class="informalexample"><pre class="programlisting">public function pay(float $amount) {
    echo "Paying $amount.";
}

public function isExtentOfTaxes(): bool {
    return true;
}</pre></div><p class="calibre8">If you know that <span class="strong"><em class="calibre12">all</em></span> customers will have to be payers, you could even make the <code class="email">Customer</code> interface to inherit from the <code class="email">Payer</code> interface:</p><div class="informalexample"><pre class="programlisting">interface Customer extends Payer {</pre></div><p class="calibre8">This change does not affect the usage of our classes at all. Other developers will see that our basic and premium customers inherit from <code class="email">Payer</code> and <code class="email">Customer</code>, and so they contain all the necessary methods. That these interfaces are independent, or they extend from each other is something that will not affect too much.</p><p class="calibre8">Interfaces can only <a id="id303" class="calibre1"/>extend from other interfaces, and classes can only extend from other classes. The only way to mix them is when a class implements an interface, but neither does a class extend from an interface, nor does an interface extend from a class. But from the point of view of type hinting, they can be used interchangeably.</p><p class="calibre8">To summarize this section and make things clear, let's show what the hierarchic tree looks like after all the new additions. As in abstract classes, the methods declared in an interface are shown in the interface rather than in each of the classes that implement it.</p><div class="mediaobject"><img src="../images/00020.jpeg" alt="Interfaces" class="calibre9"/></div><p class="calibre10"> </p></div>

<div class="book" title="Interfaces">
<div class="book" title="Polymorphism"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec65" class="calibre1"/>Polymorphism</h2></div></div></div><p class="calibre8">
<span class="strong"><strong class="calibre2">Polymorphism</strong></span>
<a id="id304" class="calibre1"/> is an OOP feature that allows us to work with different classes that implement the same interface. It is one of the beauties of object-oriented programming. It allows the developer to create a complex system of classes and hierarchic trees, but offers a simple way of working with them.</p><p class="calibre8">Imagine that we have a function that, given a payer, checks whether it is exempt of taxes or not, and makes it pay some amount of money. This piece of code does not really mind if the payer is a customer, a librarian, or someone who has nothing to do with the bookstore. The only thing that it cares about is that the payer has the ability to pay. The function could be as follows:</p><div class="informalexample"><pre class="programlisting">function processPayment(Payer $payer, float $amount) {
    if ($payer-&gt;isExtentOfTaxes()) {
        echo "What a lucky one...";
    } else {
        $amount *= 1.16;
    }
    $payer-&gt;pay($amount);
}</pre></div><p class="calibre8">You could send basic or premium customers to this function, and the behavior will be different. But, as both implement the <code class="email">Payer</code> interface, both objects provided are valid types, and both are capable of performing the actions needed.</p><p class="calibre8">The <code class="email">checkIfValid</code> function takes a customer and a list of books. We already saw that sending any kind of customer makes the function work as expected. But what happens if we send an object of the class <code class="email">Librarian</code>, which extends from <code class="email">Payer</code>? As <code class="email">Payer</code> does not know about <code class="email">Customer</code> (it is rather the other way around), the function will complain as the type hinting is not accomplished.</p><p class="calibre8">One useful feature that comes with<a id="id305" class="calibre1"/> PHP is the ability to check whether an object is an instance of a specific class or interface. The way to use it is to specify the variable followed by the keyword <code class="email">instanceof</code> and the name of the class or interface. It returns a Boolean, which is <code class="email">true</code> if the object is from a class that extends or implements the specified one, or <code class="email">false</code> otherwise. Let's see some examples:</p><div class="informalexample"><pre class="programlisting">$basic = new Basic(1, "name", "surname", "email");
$premium = new Premium(2, "name", "surname", "email");
var_dump($basic instanceof Basic); // true
var_dump($basic instanceof Premium); // false
var_dump($premium instanceof Basic); // false
var_dump($premium instanceof Premium); // true
var_dump($basic instanceof Customer); // true
var_dump($basic instanceof Person); // true
var_dump($basic instanceof Payer); // true</pre></div><p class="calibre8">Remember to add all the <code class="email">use</code> statements for each of the class or interface, otherwise PHP will understand that the specified class name is inside the namespace of the file.</p></div></div>
<div class="book" title="Traits"><div class="book" id="164MG2-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec34" class="calibre1"/>Traits</h1></div></div></div><p class="calibre8">So far, you have learned that extending from classes allows you to inherit code (properties and method implementations), but it has the limitation of extending only from one class each time. On the other hand, you can use interfaces to implement multiple behaviors from the same class, but you cannot inherit code in this way. To fill this gap, that is, to be able to inherit code from multiple places, you have traits.</p><p class="calibre8">
<span class="strong"><strong class="calibre2">Traits</strong></span> <a id="id306" class="calibre1"/>are mechanisms that allow you to reuse code, "inheriting", or rather copy-pasting code, from multiple sources at the same time. Traits, as abstract classes or interfaces, cannot be instantiated; they are just containers of functionality that can be used from other classes.</p><p class="calibre8">If you remember, we have some code in the <code class="email">Person</code> class that manages the assignment of IDs. This code is not really part of a person, but rather part of an ID system that could be used by some other entity that has to be identified with IDs too. One way to extract this functionality from <code class="email">Person</code>—and we are not saying that it is the best way to do so, but for the sake of seeing traits in action, we choose this one—is to move it to a trait.</p><p class="calibre8">To define a trait, do as <a id="id307" class="calibre1"/>if you were defining a class, just use the keyword <code class="email">trait</code> instead of <code class="email">class</code>. Define its namespace, add the <code class="email">use</code> statements needed, declare its properties and implement its methods, and place everything in a file that follows the same conventions. Add the following code to the <code class="email">src/Utils/Unique.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php

<span class="strong"><strong class="calibre2">namespace Bookstore\Utils;</strong></span>

<span class="strong"><strong class="calibre2">trait Unique {</strong></span>
    private static $lastId = 0;
    protected $id;

<span class="strong"><strong class="calibre2">    public function setId(int $id) {</strong></span>
        if (empty($id)) {
            $this-&gt;id = ++self::$lastId;
        } else {
            $this-&gt;id = $id;
            if ($id &gt; self::$lastId) {
                self::$lastId = $id;
            }
        }
    }

    public static function getLastId(): int {
        return self::$lastId;
    }
    public function getId(): int {
        return $this-&gt;id;
    }
}</pre></div><p class="calibre8">Observe that the namespace is not the same as usual, since we are storing this code in a different file. This is a matter of conventions, but you are entirely free to use the file structure that you consider better for each case. In this case, we do not think that this trait represents "business logic" like customers and books do; instead, it represents a utility for managing the assignment of IDs.</p><p class="calibre8">We include all the code related to IDs from <code class="email">Person</code>. That includes the properties, the getters, and the code inside the constructor. As the trait cannot be instantiated, we cannot add a constructor. Instead, we added a <code class="email">setId</code> method that contains the code. When constructing a new instance that uses this trait, we can invoke this <code class="email">setId</code> method to set the ID based on what the user sends as an argument.</p><p class="calibre8">The class <code class="email">Person</code> will have <a id="id308" class="calibre1"/>to change too. We have to remove all references to IDs and we will have to define somehow that the class is using the trait. To do that, we use the keyword <code class="email">use</code>, like in namespaces, but inside the class. Let's see what it would look like:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Domain;

<span class="strong"><strong class="calibre2">use Bookstore\Utils\Unique;</strong></span>

class Person {
<span class="strong"><strong class="calibre2">    use Unique;</strong></span>

    protected $firstname;
    protected $surname;
    protected $email;

    public function __construct(
        int $id,
        string $firstname,
        string $surname,
        string $email
    ) {
        $this-&gt;firstname = $firstname;
        $this-&gt;surname = $surname;
        $this-&gt;email = $email;
<span class="strong"><strong class="calibre2">       $this-&gt;setId($id);</strong></span>
    }

    public function getFirstname(): string {
        return $this-&gt;firstname;
    }
    public function getSurname(): string {
        return $this-&gt;surname;
    }
    public function getEmail(): string {
        return $this-&gt;email;
    }
    public function setEmail(string $email) {
        $this-&gt;email = $email;
    }
}</pre></div><p class="calibre8">We add the <code class="email">use Unique;</code> statement to let the class know that it is using the trait. We remove everything related to IDs, even inside the constructor. We still get an ID as the first argument of the constructor, but we ask the method <code class="email">setId</code> from the trait to do everything for us. Note that we refer to that method with <code class="email">$this</code>, as if the method was inside the class. The updated hierarchic tree would look like the following (note that we are not adding all the <a id="id309" class="calibre1"/>methods for all the classes or interfaces that are not involved in the recent changes in order to keep the diagram as small and readable as possible):</p><div class="mediaobject"><img src="../images/00021.jpeg" alt="Traits" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Let's see how it works, even though it does so in the way that you probably expect. Add this code into your <code class="email">init.php</code> file, include the necessary <code class="email">use</code> statements, and execute it in your browser:</p><div class="informalexample"><pre class="programlisting">$basic1 = new Basic(1, "name", "surname", "email");
$basic2 = new Basic(null, "name", "surname", "email");
var_dump($basic1-&gt;getId()); // 1
var_dump($basic2-&gt;getId()); // 2</pre></div><p class="calibre8">The preceding code instantiates two customers. The first of them has a specific ID, whereas the second one lets the system choose an ID for it. The result is that the second basic customer has the ID 2. That is to be expected, as both customers are basic. But what would happen if the customers are of different types?</p><div class="informalexample"><pre class="programlisting">$basic = new Basic(1, "name", "surname", "email");
$premium = new Premium(null, "name", "surname", "email");
var_dump($basic-&gt;getId()); // 1
var_dump($premium-&gt;getId()); // 2</pre></div><p class="calibre8">The IDs are still the same. That is to be expected, as the trait is included in the <code class="email">Person</code> class, so the static property <code class="email">$lastId</code> will be shared across all the instances of the class <code class="email">Person</code>, including <code class="email">Basic</code> and <code class="email">Premium</code> customers. If you used the trait from <code class="email">Basic</code> and <code class="email">Premium</code> customer instead of <code class="email">Person</code> (but you should not), you would have the following result:</p><div class="informalexample"><pre class="programlisting">var_dump($basic-&gt;getId()); // 1
var_dump($premium-&gt;getId()); // 1</pre></div><p class="calibre8">Each class will<a id="id310" class="calibre1"/> have its own static property. All <code class="email">Basic</code> instances will share the same <code class="email">$lastId</code>, different from the <code class="email">$lastId</code> of <code class="email">Premium</code> instances. This should make clear that the static members in traits are linked to whichever class uses them, rather than the trait itself. That could also be reflected on testing the following code which uses our original scenario where the trait is used from <code class="email">Person</code>:</p><div class="informalexample"><pre class="programlisting">$basic = new Basic(1, "name", "surname", "email");
$premium = new Premium(null, "name", "surname", "email");
var_dump(Person::getLastId()); // 2
var_dump(Unique::getLastId()); // 0
var_dump(Basic::getLastId()); // 2
var_dump(Premium::getLastId()); // 2</pre></div><p class="calibre8">If you have a good eye for problems, you might start thinking about some potential issues around the usage of traits. What happens if we use two traits that contain the same method? Or what happens if you use a trait that contains a method that is already implemented in that class?</p><p class="calibre8">Ideally, you should avoid running into these kinds of situations; they are warning lights for possible bad design. But as there will always be extraordinary cases, let's see some isolated examples on how they would behave.</p><p class="calibre8">The scenario where the trait and the class implement the same method is easy. The method implemented explicitly in the class is the one with more precedence, followed by the method implemented in the trait, and finally, the method inherited from the parent class. Let's see how it works. Take for example the following trait and class definitions:</p><div class="informalexample"><pre class="programlisting">&lt;?php

trait Contract {
    public function sign() {
        echo "Signing the contract.";
    }
}

class Manager {
    use Contract;

    public function sign() {
        echo "Signing a new player.";
    }
}</pre></div><p class="calibre8">Both implement the <code class="email">sign</code> method, which means that we have to apply the precedence rules defined previously. The method defined in the class takes precedence over the one from the trait, so in this case, the executed method will be the one from the class:</p><div class="informalexample"><pre class="programlisting">$manager = new Manager();
$manager-&gt;sign(); // Signing a new player.</pre></div><p class="calibre8">The most complicated scenario would be one where a class uses two traits with the same method. There are no rules that solve the conflict automatically, so you have to solve it explicitly. Check the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?php

trait Contract {
    public function sign() {
        echo "Signing the contract.";
    }
}

trait Communicator {
    public function sign() {
        echo "Signing to the waitress.";
    }
}

class Manager {
<span class="strong"><strong class="calibre2">    use Contract, Communicator;</strong></span>
}

$manager = new Manager();
$manager-&gt;sign();</pre></div><p class="calibre8">The preceding <a id="id311" class="calibre1"/>code throws a fatal error, as both traits implement the same method. To choose the one you want to use, you have to use the operator <code class="email">insteadof</code>. To use it, state the trait name and the method that you want to use, followed by <code class="email">insteadof</code> and the trait that you are rejecting for use. Optionally, use the keyword <code class="email">as</code> to add an alias like we did with namespaces so that you can use both the methods:</p><div class="informalexample"><pre class="programlisting">class Manager {
<span class="strong"><strong class="calibre2">    use Contract, Communicator {</strong></span>
<span class="strong"><strong class="calibre2">        Contract::sign insteadof Communicator;</strong></span>
<span class="strong"><strong class="calibre2">        Communicator::sign as makeASign;</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
}

$manager = new Manager();
$manager-&gt;sign(); // Signing the contract.
$manager-&gt;makeASign(); // Signing to the waitress.</pre></div><p class="calibre8">You can see how we decided to use the method of <code class="email">Contract</code> instead of <code class="email">Communicator</code>, but added the alias so that both methods are available. Hopefully, you can see that even the conflicts can be solved, and there are specific cases where there is nothing to do but deal with them; in <a id="id312" class="calibre1"/>general, they look like a bad sign—no pun intended.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Handling exceptions"><div class="book" id="173722-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec35" class="calibre1"/>Handling exceptions</h1></div></div></div><p class="calibre8">It does not matter<a id="id313" class="calibre1"/> how easy and intuitive your application is designed to be, there will be bad usage from the user or just random errors of connectivity, and your code has to be ready to handle these scenarios so that the user experience is a good as possible. We call these scenarios <span class="strong"><strong class="calibre2">exceptions</strong></span>: an element of the language that identifies a case that is not as we expected.</p></div>

<div class="book" title="Handling exceptions">
<div class="book" title="The try…catch block"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec66" class="calibre1"/>The try…catch block</h2></div></div></div><p class="calibre8">Your code can throw <a id="id314" class="calibre1"/>exceptions manually whenever you think it necessary. For example, take<a id="id315" class="calibre1"/> the <code class="email">setId</code> method from the <code class="email">Unique</code> trait. Thanks to type hinting, we are enforcing the ID to be a numeric one, but that is as far as it goes. What would happen if someone tries to set an ID that is a negative number? The code right now allows it to go through, but depending on your preferences, you would like to avoid it. That would be a good place for an exception to happen. Let's see how we would add this check and consequent exception:</p><div class="informalexample"><pre class="programlisting">public function setId($id) {
    if ($id &lt; 0) {
<span class="strong"><strong class="calibre2">        throw new \Exception('Id cannot be negative.');</strong></span>
    }
    if (empty($id)) {
        $this-&gt;id = ++self::$lastId;
    } else {
        $this-&gt;id = $id;
        if ($id &gt; self::$lastId) {
            self::$lastId = $id;
        }
    }
}</pre></div><p class="calibre8">As you can see, exceptions are objects of the class exception. Remember adding the backslash to the name of the class, unless you want to include it with <code class="email">use Exception;</code> at the top of the file. The constructor of the <code class="email">Exception</code> class takes some optional arguments, the first one of them being the message of the exception. Instances of the class <code class="email">Exception</code> do nothing by themselves; they have to be thrown in order to be noticed by the program.</p><p class="calibre8">Let's try forcing our program to throw this exception. In order to do that, let's try to create a customer with a negative ID. In your <code class="email">init.php</code> file, add the following:</p><div class="informalexample"><pre class="programlisting">$basic = new Basic(-1, "name", "surname", "email");</pre></div><p class="calibre8">If you try it now in your <a id="id316" class="calibre1"/>browser, PHP will throw a fatal error saying that there was an uncaught exception, which is the expected behavior. For PHP, an exception is something from what it cannot recover, so it will stop execution. That is far from ideal, as you would like to just display an error message to the user, and let them try again.</p><p class="calibre8">You can—and should—capture<a id="id317" class="calibre1"/> exceptions using the <code class="email">try…catch</code> blocks. You insert the code that might throw an exception in the <code class="email">try</code> block and if an exception happens, PHP will jump to the <code class="email">catch</code> block. Let's see how it works:</p><div class="informalexample"><pre class="programlisting">public function setId(int $id) {
<span class="strong"><strong class="calibre2">    try {</strong></span>
        if ($id &lt; 0) {
            throw new Exception('Id cannot be negative.');
        }
        if (empty($id)) {
            $this-&gt;id = ++self::$lastId;
        } else {
            $this-&gt;id = $id;
            if ($id &gt; self::$lastId) {
                self::$lastId = $id;
            }
        }
<span class="strong"><strong class="calibre2">    } catch (Exception $e) {</strong></span>
<span class="strong"><strong class="calibre2">        echo $e-&gt;getMessage();</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
}</pre></div><p class="calibre8">If we test the last code snippet in our browser, we will see the message printed from the <code class="email">catch</code> block. Calling the <code class="email">getMessage</code> method on an exception instance will give us the message—the first argument when creating the object. But remember that the argument of the constructor is optional; so, do not rely on the message of the exception too much if you are not sure how it is generated, as it might be empty.</p><p class="calibre8">Note that after the exception is thrown, nothing else inside the <code class="email">try</code> block is executed; PHP goes straight to the <code class="email">catch</code> block. Additionally, the block gets an argument, which is the exception thrown. Here, type hinting is mandatory—you will see why very soon. Naming the argument as <code class="email">$e</code> is a widely used convention, even though it is not a good practice to use poor descriptive names for variables.</p><p class="calibre8">Being a bit critical, so far, there is not any real advantage to be seen in using exceptions in this example. A simple <code class="email">if…else</code> block would do exactly the same job, right? But the real power of exceptions lies in the ability to be propagated across methods. That is, the exception thrown on the <code class="email">setId</code> method, if not captured, will be propagated to wherever the method was invoked, allowing us to capture it there. This is very useful, as different places in the code might want to handle the exception in a different way. To see how this is done, let's remove<a id="id318" class="calibre1"/> the <code class="email">try…catch</code> inserted in <code class="email">setId</code>, and place the following <a id="id319" class="calibre1"/>piece of code in your <code class="email">init.php</code> file, instead:</p><div class="informalexample"><pre class="programlisting">try {
    $basic = new Basic(-1, "name", "surname", "email");
} catch (Exception $e) {
    echo 'Something happened when creating the basic customer: '
        . $e-&gt;getMessage();
}</pre></div><p class="calibre8">The preceding example shows how useful it is to catch propagated exceptions: we can be more specific of what happens, as we know what the user was trying to do when the exception was thrown. In this case, we know that we were trying to create the customer, but this exception might have been thrown when trying to update the ID of an existing customer, which would need a different error message.</p></div></div>

<div class="book" title="Handling exceptions">
<div class="book" title="The finally block"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec67" class="calibre1"/>The finally block</h2></div></div></div><p class="calibre8">There is a third block that you <a id="id320" class="calibre1"/>can use when dealing with exceptions: the <code class="email">finally</code> block. This <a id="id321" class="calibre1"/>block is added after the <code class="email">try…catch</code> one, and it is optional. In fact, the <code class="email">catch</code> block is optional too; the restriction is that a <code class="email">try</code> must be followed by at least one of them. So you could have these three scenarios:</p><div class="informalexample"><pre class="programlisting">// scenario 1: the whole try-catch-finally
try {
    // code that might throw an exception
} catch (Exception $e) {
    // code that deals with the exception
} finally {
    // finally block
}

// scenario 2: try-finally without catch
try {
    // code that might throw an exception
} finally {
    // finally block
}

// scenario 3: try-catch without finally
try {
    // code that might throw an exception
} catch (Exception $e) {
    // code that deals with the exception
}</pre></div><p class="calibre8">The code inside the <code class="email">finally</code> block is executed when either the <code class="email">try</code> or the <code class="email">catch</code> blocks are executed completely. So, if we have a scenario where there is no exception, after all the code inside the <code class="email">try</code> block is executed, PHP will execute the code inside <code class="email">finally</code>. On the other hand, if there is an exception thrown inside the <code class="email">try</code> block, PHP will jump to the <code class="email">catch</code> block, and after <a id="id322" class="calibre1"/>executing everything there, it will execute the <code class="email">finally</code> block too.</p><p class="calibre8">In order to test this<a id="id323" class="calibre1"/> functionality, let's implement a function that contains a <code class="email">try…catch…finally</code> block, trying to create a customer with a given ID (through an argument), and logging all the actions that take place. You can add the following code snippet into your <code class="email">init.php</code> file:</p><div class="informalexample"><pre class="programlisting">function createBasicCustomer($id)
{
    try {
        echo "\nTrying to create a new customer.\n";
        return new Basic($id, "name", "surname", "email");
    } catch (Exception $e) {
        echo "Something happened when creating the basic customer: "
            . $e-&gt;getMessage() . "\n";
    } finally {
        echo "End of function.\n";
    }
}

createBasicCustomer(1);
createBasicCustomer(-1);</pre></div><p class="calibre8">If you try this, your browser will show you the following output—remember to display the source code of the page to see it formatted prettily:</p><div class="mediaobject"><img src="../images/00022.jpeg" alt="The finally block" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">The result might not be the one you expected. The first time we invoke the function, we are able to create the object without an issue, and that means we execute the <code class="email">return</code> statement. In a normal function, this should be the end of it, but since we are inside the <code class="email">try…catch…finally</code> block, we still need to execute the <code class="email">finally</code> code! The second example looks more intuitive, jumping from the <code class="email">try</code> to the <code class="email">catch</code>, and then to the <code class="email">finally</code> block.</p><p class="calibre8">The <code class="email">finally</code> block <a id="id324" class="calibre1"/>is very useful when dealing with expensive resources like<a id="id325" class="calibre1"/> database connections. In <a class="calibre1" title="Chapter 5. Using Databases" href="part0045_split_000.html#1AT9A1-edcc22b134104d5db0bf3aa086c86851">Chapter 5</a>, <span class="strong"><em class="calibre12">Using Databases</em></span>, you will see how to use them. Depending on the type of connection, you will have to close it after use for allowing other users to connect. The <code class="email">finally</code> block is used for closing those connections, regardless of whether the function throws an exception or not.</p></div></div>

<div class="book" title="Handling exceptions">
<div class="book" title="Catching different types of exceptions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec68" class="calibre1"/>Catching different types of exceptions</h2></div></div></div><p class="calibre8">Exceptions have <a id="id326" class="calibre1"/>already been proven useful, but there is still one important feature to show: catching different types of exceptions. As you already know, exceptions are instances of the class <code class="email">Exception</code>, and as with any other class, they can be extended. The main goal of extending from this class is to create different types of exceptions, but we will not add any logic inside—even though you can, of course. Let's create a class that extends from <code class="email">Exception</code>, and which identifies exceptions related to invalid IDs. Put this code inside the <code class="email">src/Exceptions/InvalidIdException.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Exceptions;

use Exception;

class InvalidIdException extends Exception {
    public function __construct($message = null) {
        $message = $message ?: 'Invalid id provided.';
        parent::__construct($message);
    }
}</pre></div><p class="calibre8">The <code class="email">InvalidIdException</code> class extends from the class <code class="email">Exception</code>, and so it can be thrown as one. The constructor of the class takes an optional argument, <code class="email">$message</code>. The following two lines inside it contain interesting code:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="email">?:</code> operator is a <a id="id327" class="calibre1"/>shorter version of a conditional, and works like this: the expression on the left is returned if it does not evaluate to <code class="email">false</code>, otherwise, the expression on the right will be returned. What we want here is to use the message given by the user, or a default one in case the user does not provide any. For more information and usages, you can visit the PHP documentation at <a class="calibre1" href="http://php.net/manual/en/language.operators.comparison.php">http://php.net/manual/en/language.operators.comparison.php</a>.</li><li class="listitem"><code class="email">parent::__construct</code> will invoke the parent's constructor, that is, the constructor of the class <code class="email">Exception</code>. As you already know, this constructor gets the message of the exception as the first argument. You could argue that, as we are extending from the <code class="email">Exception</code> class, we do not really need to call any functions, as we can edit the properties of the class straightaway. The reason for avoiding this is to let the parent class manage its own properties. Imagine that, for some reason, in a future version of PHP, <code class="email">Exception</code> changes the name of the property for the message. If you modify it directly, you will have to change that in your code, but if you use the constructor, you have nothing to fear. Internal implementations are more likely to change than external interfaces.</li></ul></div><p class="calibre8">We can use this new exception instead of the generic one. Replace it in your <code class="email">Unique</code> trait as follows:</p><div class="informalexample"><pre class="programlisting">throw new InvalidIdException('Id cannot be a negative number.');</pre></div><p class="calibre8">You can see that we are still sending a message: that is because we want to be even more specific. But the exception would work as well without one. Try your code again, and you will see that nothing changes.</p><p class="calibre8">Now imagine that we have a very small database and we cannot allow more than 50 users. We can create a new exception that identifies this case, let's say, as <code class="email">src/Exceptions/ExceededMaxAllowedException.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Exceptions;

use Exception;

class ExceededMaxAllowedException extends Exception {
    public function __construct($message = null) {
        $message = $message ?: 'Exceeded max allowed.';
        parent::__construct($message);
    }
}</pre></div><p class="calibre8">Let's modify our trait in order to check for this case. When setting an ID, if this ID is greater than 50, we can assume that we've reached the maximum number of users:</p><div class="informalexample"><pre class="programlisting">public function setId(int $id) {
        if ($id &lt; 0) {
            throw new InvalidIdException(
                'Id cannot be a negative number.'
            );
        }
        if (empty($id)) {
            $this-&gt;id = ++self::$lastId;
        } else {
            $this-&gt;id = $id;
            if ($id &gt; self::$lastId) {
                self::$lastId = $id;
            }
        }
<span class="strong"><strong class="calibre2">        if ($this-&gt;id &gt; 50) {</strong></span>
<span class="strong"><strong class="calibre2">            throw new ExceededMaxAllowedException(</strong></span>
<span class="strong"><strong class="calibre2">                'Max number of users is 50.'</strong></span>
<span class="strong"><strong class="calibre2">            );</strong></span>
<span class="strong"><strong class="calibre2">        }</strong></span>
    }</pre></div><p class="calibre8">Now the preceding <a id="id328" class="calibre1"/>function throws two different exceptions: <code class="email">InvalidIdException</code> and <code class="email">ExceededMaxAllowedException</code>. When catching them, you might want to behave in a different way depending on the type of exception caught. Remember how you have to declare an argument in your <code class="email">catch</code> block? Well, you can add as many <code class="email">catch</code> blocks as needed, specifying a different exception class in each of them. The code could look like this:</p><div class="informalexample"><pre class="programlisting">function createBasicCustomer(int $id)
{
    try {
        echo "\nTrying to create a new customer with id $id.\n";
        return new Basic($id, "name", "surname", "email");
<span class="strong"><strong class="calibre2">    } catch (InvalidIdException $e) {</strong></span>
        echo "You cannot provide a negative id.\n";
<span class="strong"><strong class="calibre2">    } catch (ExceededMaxAllowedException $e) {</strong></span>
        echo "No more customers are allowed.\n";
    } catch (Exception $e) {
        echo "Unknown exception: " . $e-&gt;getMessage();
    }
}

createBasicCustomer(1);
createBasicCustomer(-1);
createBasicCustomer(55);</pre></div><p class="calibre8">If you try this code, you should see the following output:</p><div class="mediaobject"><img src="../images/00023.jpeg" alt="Catching different types of exceptions" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Note that we catch <a id="id329" class="calibre1"/>three exceptions here: our two new exceptions and the generic one. The reason for doing this is that it might happen that some other piece of code throws an exception of a different type than the ones we defined, and we need to define a <code class="email">catch</code> block with the generic <code class="email">Exception</code> class to get it, as all exceptions will extend from it. Of course, this is absolutely optional, and if you do not do it, the exception will be just propagated.</p><p class="calibre8">Bear in mind the order of the <code class="email">catch</code> blocks. PHP tries to use the <code class="email">catch</code> blocks in the order that you defined them. So, if your first catch is for <code class="email">Exception</code>, the rest of the blocks will be never executed, as all exceptions extend from that class. Try it with the following code:</p><div class="informalexample"><pre class="programlisting">try {
    echo "\nTrying to create a new customer with id $id.\n";
    return new Basic($id, "name", "surname", "email");
} catch (Exception $e) {
    echo 'Unknown exception: ' . $e-&gt;getMessage() . "\n";
} catch (InvalidIdException $e) {
    echo "You cannot provide a negative id.\n";
} catch (ExceededMaxAllowedException $e) {
    echo "No more customers are allowed.\n";
}</pre></div><p class="calibre8">The result that you get from the <a id="id330" class="calibre1"/>browser will always be from the first catch:</p><div class="mediaobject"><img src="../images/00024.jpeg" alt="Catching different types of exceptions" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Design patterns"><div class="book" id="181NK2-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec36" class="calibre1"/>Design patterns</h1></div></div></div><p class="calibre8">Developers have been creating code since way before the appearance of with Internet, and they have been working on a number of different areas, not just web applications. Because of that, a lot of people have already had to confront similar scenarios, carrying the experience of previous attempts for fixing the same thing. In short, it means that almost surely, someone has already designed a good way of solving the problem that you are facing now.</p><p class="calibre8">A lot of books have been written trying to group solutions to common problems, also known as <a id="id331" class="calibre1"/>
<span class="strong"><strong class="calibre2">design patterns</strong></span>. Design patterns are not algorithms that you copy and paste into your program, showing how to fix something step-by-step, but rather recipes that show you, in a heuristic way, how to look for the answer.</p><p class="calibre8">Studying them is essential if you want to become a professional developer, not only for solving problems, but also for communicating with other developers. It is very common to get an answer like "You could use a factory here", when discussing your program design. It saves a lot of time knowing what a factory is, rather than explaining the pattern each time someone mentions it.</p><p class="calibre8">As we said, there are entire books that talk about design patterns, and we highly recommend you to have a look at some of them. The goal of this section is to show you what a design pattern is and how you can use it. Additionally, we will show you some of the most common design patterns used with PHP when writing web applications, excluding the MVC pattern, which we will study in <a class="calibre1" title="Chapter 6. Adapting to MVC" href="part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851">Chapter 6</a>, <span class="strong"><em class="calibre12">Adapting to MVC</em></span>.</p><p class="calibre8">Other than books, you <a id="id332" class="calibre1"/>could also visit the open source project <span class="strong"><strong class="calibre2">DesignPatternsPHP</strong></span>
<a id="id333" class="calibre1"/> at <a class="calibre1" href="http://designpatternsphp.readthedocs.org/en/latest/README.html">http://designpatternsphp.readthedocs.org/en/latest/README.html</a>. There is a good collection of them, and they are implemented in PHP, so it would be easier for you to adapt.</p></div>

<div class="book" title="Design patterns">
<div class="book" title="Factory"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec69" class="calibre1"/>Factory</h2></div></div></div><p class="calibre8">A <span class="strong"><strong class="calibre2">factory</strong></span>
<a id="id334" class="calibre1"/> is a design pattern of the creational group, which means that it<a id="id335" class="calibre1"/> allows you to create objects. You might think that we do not need such a thing, as creating an object is as easy as using the <code class="email">new</code> keyword, the class, and its arguments. But letting the user do that is dangerous for different reasons. Apart from the increased difficulty caused by using <code class="email">new</code> when unit testing our code (you will learn about unit testing in <a class="calibre1" title="Chapter 7. Testing Web Applications" href="part0064_split_000.html#1T1402-edcc22b134104d5db0bf3aa086c86851">Chapter 7</a>, <span class="strong"><em class="calibre12">Testing Web Applications</em></span>), a lot of coupling too gets added into our code.</p><p class="calibre8">When we discussed encapsulation, you learned that it is better to hide the internal implementation of a class, and you could consider the constructor as part of it. The reason is that the user needs to know at all times how to create objects, including what the arguments of the constructor are. And what if we want to change our constructor to accept different arguments? We need to go one by one to all the places where we have created objects and update them.</p><p class="calibre8">Another reason for using factories is to manage different classes that inherit a super class or implement the same interface. As you know, thanks to polymorphism, you can use one object without knowing the specific class that it instantiates, as long as you know the interface being implemented. It might so happen that your code needs to instantiate an object that implements an interface and use it, but the concrete class of the object may not be important at all.</p><p class="calibre8">Think about our bookstore example. We have two types of customers: basic and premium. But for most of the code, we do not really care what type of customer a specific instance is. In fact, we should implement our code to use objects that implement the <code class="email">Customer</code> interface, being unaware of the specific type. So, if we decide in the future to add a new type, as long as it implements the correct interface, our code will work without an issue. But, if that is the case, what do we do when we need to create a new customer? We cannot instantiate an interface, so let's use the factory pattern. Add the following code into <code class="email">src/Domain/Customer/CustomerFactory.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Domain\Customer;

use Bookstore\Domain\Customer;

class CustomerFactory {
    public static function factory(
        string $type,
        int $id,
        string $firstname,
        string $surname,
        string $email
    ): Customer {
        switch ($type) {
            case 'basic':
                return new Basic($id, $firstname, $surname, $email);
            case 'premium':
                return new Premium($id, $firstname, $surname, $email);
        }
    }
}</pre></div><p class="calibre8">The factory in the <a id="id336" class="calibre1"/>preceding code is less than ideal for different reasons. In the<a id="id337" class="calibre1"/> first one, we use a <code class="email">switch</code>, and add a case for all the existing customer types. Two types do not make much difference, but what if we have 19? Let's try to make this factory method a bit more dynamic.</p><div class="informalexample"><pre class="programlisting">public static function factory(
        string $type,
        int $id,
        string $firstname,
        string $surname,
        string $email
    ): Customer {
<span class="strong"><strong class="calibre2">    $classname = __NAMESPACE__ . '\\' . ucfirst($type);</strong></span>
<span class="strong"><strong class="calibre2">    if (!class_exists($classname)) {</strong></span>
<span class="strong"><strong class="calibre2">        throw new \InvalidArgumentException('Wrong type.');</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
<span class="strong"><strong class="calibre2">    return new $classname($id, $firstname, $surname, $email);</strong></span>
}</pre></div><p class="calibre8">Yes, you can do what we did in the preceding code in PHP. Instantiating classes dynamically, that is, using the content of a variable as the name of the class, is one of the things that makes PHP so flexible… and dangerous. Used wrongly, it will make your code horribly difficult to read and maintain, so be careful about it. Note too the constant <code class="email">__NAMESPACE__</code>, which contains the namespace of the current file.</p><p class="calibre8">Now this factory looks cleaner, and it is also very dynamic. You could add more customer types and, as long as they are inside the correct namespace and implement the interface, there is nothing to change on the factory side, nor in the usage of the factory.</p><p class="calibre8">In order to use it, let's <a id="id338" class="calibre1"/>change our <code class="email">init.php</code> file. You can remove all our tests, and <a id="id339" class="calibre1"/>just leave the autoloader code. Then, add the following:</p><div class="informalexample"><pre class="programlisting">CustomerFactory::factory('basic', 2, 'mary', 'poppins', 'mary@poppins.com');
CustomerFactory::factory('premium', null, 'james', 'bond', 'james@bond.com');</pre></div><p class="calibre8">The factory design pattern can be as complex as you need. There are different variants of it, and each one has its own place and time, but the general idea is always the same.</p></div></div>

<div class="book" title="Design patterns">
<div class="book" title="Singleton"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec70" class="calibre1"/>Singleton</h2></div></div></div><p class="calibre8">If someone with<a id="id340" class="calibre1"/> a bit of experience with design patterns, or web development in general, reads the title of this section, they will probably start tearing their hair out and claiming that singleton is the worst example of a design pattern. But just bear with me.</p><p class="calibre8">When explaining<a id="id341" class="calibre1"/> interfaces, I added a note about how developers tend to complicate their code too much just so they can use all the tools they know. Using design patterns is one of the cases where this happens. They have been so famous, and people claimed that good use of them is directly linked to great developers, that everybody that learns them tries to use them absolutely everywhere.</p><p class="calibre8">The singleton pattern is probably the most infamous of the design patterns used in PHP for web development. This pattern has a very specific purpose, and when that is the case, the pattern proves to be very useful. But this pattern is so easy to implement that developers continuously try to add singletons everywhere, turning their code into something unmaintainable. It is for this reason that people call this an anti-pattern, something that should be avoided rather than used.</p><p class="calibre8">I do agree with this point of view, but I still think that you should be very familiar with this design pattern. Even though you should avoid its overuse, people still use it everywhere, and they refer to it countless times, so you should be in a position to either agree with them or rather have enough reasons to discourage them to use it. Having said that, let's see what the aim of the singleton pattern is.</p><p class="calibre8">The idea is simple: singletons are used when you want one class to always have one unique instance. Every time, and everywhere you use that class, it has to be through the same instance. The reason is to avoid having too many instances of some heavy resource, or to keep always the same state everywhere—to be global. Examples of this are database connections or configuration handlers.</p><p class="calibre8">Imagine that in order to<a id="id342" class="calibre1"/> run, our application needs some configuration, such<a id="id343" class="calibre1"/> as credentials for the database, URLs of special endpoints, directory paths for finding libraries or important files, and so on. When you receive a request, the first thing you do is to load this configuration from the filesystem, and then you store it as an array or some other data structure. Save the following code as your <code class="email">src/Utils/Config.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Utils;

use Bookstore\Exceptions\NotFoundException;

class Config {
    private $data;

    public function __construct() {
    $json = file_get_contents(__DIR__ . '/../../config/app.json');
        $this-&gt;data = json_decode($json, true);
    }

    public function get($key) {
        if (!isset($this-&gt;data[$key])) {
            throw new NotFoundException("Key $key not in config.");
        }
        return $this-&gt;data[$key];
    }
}</pre></div><p class="calibre8">As you can see, this class uses a new exception. Create it under <code class="email">src/Utils/NotFoundException.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Exceptions;

use Exception;

class NotFoundException extends Exception {
}</pre></div><p class="calibre8">Also, the class reads a file, <code class="email">config/app.json</code>. You could add the following JSON map inside it:</p><div class="informalexample"><pre class="programlisting">{
  "db": {
    "user": "Luke",
    "password": "Skywalker"
  }
}</pre></div><p class="calibre8">In order to use this configuration, let's add the following code into your <code class="email">init.php</code> file.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$config = new Config();</strong></span>
$dbConfig = $config-&gt;get('db');
var_dump($dbConfig);</pre></div><p class="calibre8">That seems a very good <a id="id344" class="calibre1"/>way to read configuration, right? But pay attention<a id="id345" class="calibre1"/> to the highlighted line. We instantiate the <code class="email">Config</code> object, hence, we read a file, transform its contents from JSON to array, and store it. What if the file contains hundreds of lines instead of just six? You should notice then that instantiating this class is very expensive.</p><p class="calibre8">You do not want to read the files and transform them into arrays each time you ask for some data from your configuration. That is way too expensive! But, for sure, you will need the configuration array in very different places of your code, and you cannot carry this array everywhere you go. If you understood static properties and methods, you could argue that implementing a static array inside the object should fix the problem. You instantiate it once, and then just call a static method that will access an already populated static property. Theoretically, we skip the instantiation, right?</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Utils;

use Bookstore\Exceptions\NotFoundException;

class Config {
<span class="strong"><strong class="calibre2">    private static $data;</strong></span>

    public function __construct() {
        $json = file_get_contents(__DIR__ . '/../config/app.json');
<span class="strong"><strong class="calibre2">        self::$data = json_decode($json, true);</strong></span>
    }

<span class="strong"><strong class="calibre2">    public static function get($key) {</strong></span>
<span class="strong"><strong class="calibre2">        if (!isset(self::$data[$key])) {</strong></span>
            throw new NotFoundException("Key $key not in config.");
        }
<span class="strong"><strong class="calibre2">        return self::$data[$key];</strong></span>
    }
}</pre></div><p class="calibre8">This seems to be a good idea, but it is highly dangerous. How can you be absolutely sure that the array has already been populated? And how can you be sure that, even using a static context, the user will not keep instantiating this class again and again? That is where singletons come in handy.</p><p class="calibre8">Implementing a singleton implies the following points:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Make the <a id="id346" class="calibre1"/>constructor of the class private, so absolutely <a id="id347" class="calibre1"/>no one from outside the class can ever instantiate that class.</li><li class="listitem" value="2">Create a static property named <code class="email">$instance</code>, which will contain an instance of itself—that is, in our <code class="email">Config</code> class, the <code class="email">$instance</code> property will contain an instance of the class <code class="email">Config</code>.</li><li class="listitem" value="3">Create a static method, <code class="email">getInstance</code>, which will check if <code class="email">$instance</code> is null, and if it is, it will create a new instance using the private constructor. Either way, it will return the <code class="email">$instance</code> property.</li></ol><div class="calibre13"/></div><p class="calibre8">Let's see what the singleton class would look like:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Utils;

use Bookstore\Exceptions\NotFoundException;

class Config {
    private $data;
<span class="strong"><strong class="calibre2">    private static $instance;</strong></span>

<span class="strong"><strong class="calibre2">    private function __construct() {</strong></span>
        $json = file_get_contents(__DIR__ . '/../config/app.json');
        $this-&gt;data = json_decode($json, true);
    }

<span class="strong"><strong class="calibre2">    public static function getInstance(){</strong></span>
<span class="strong"><strong class="calibre2">        if (self::$instance == null) {</strong></span>
<span class="strong"><strong class="calibre2">            self::$instance = new Config();</strong></span>
<span class="strong"><strong class="calibre2">        }</strong></span>
<span class="strong"><strong class="calibre2">        return self::$instance;</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>

    public function get($key) {
        if (!isset($this-&gt;data[$key])) {
            throw new NotFoundException("Key $key not in config.");
        }
        return $this-&gt;data[$key];
    }
}</pre></div><p class="calibre8">If you run this code <a id="id348" class="calibre1"/>right now, it will throw you an error, as the constructor <a id="id349" class="calibre1"/>of this class is private. First achievement unlocked! Let's use this class properly:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$config = Config::getInstance();</strong></span>
$dbConfig = $config-&gt;get('db');
var_dump($dbConfig);</pre></div><p class="calibre8">Does it convince you? It proves to be very handy indeed. But I cannot emphasize this enough: be careful when you use this design pattern, as it has very, very, specific use cases. Avoid falling into the trap of implementing it everywhere!</p></div></div>
<div class="book" title="Anonymous functions"><div class="book" id="190862-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec37" class="calibre1"/>Anonymous functions</h1></div></div></div><p class="calibre8">
<span class="strong"><strong class="calibre2">Anonymous functions</strong></span>, or<a id="id350" class="calibre1"/> <span class="strong"><strong class="calibre2">lambda functions</strong></span>, are functions without a name. As they do not have a<a id="id351" class="calibre1"/> name, in order to be able to invoke them, we need to store them as variables. It might be strange at the beginning, but the idea is quite simple. At this point of time, we do not really need any anonymous function, so let's just add the code into <code class="email">init.php</code>, and then remove it:</p><div class="informalexample"><pre class="programlisting">$addTaxes = function (array &amp;$book, $index, $percentage) {
    $book['price'] += round($percentage * $book['price'], 2);
};</pre></div><p class="calibre8">This preceding anonymous function gets assigned to the variable <code class="email">$addTaxes</code>. It expects three arguments: <code class="email">$book</code> (an array as a reference), <code class="email">$index</code> (not used), and <code class="email">$percentage</code>. The function adds taxes to the price key of the book, rounded to 2 decimal places (<code class="email">round</code> is a native PHP function). Do not mind the argument <code class="email">$index</code>, it is not used in this function, but forced by how we will use it, as you will see.</p><p class="calibre8">You could instantiate a list of books as an array, iterate them, and then call this function each time. An example could be as follows:</p><div class="informalexample"><pre class="programlisting">$books = [
    ['title' =&gt; '1984', 'price' =&gt; 8.15],
    ['title' =&gt; 'Don Quijote', 'price' =&gt; 12.00],
    ['title' =&gt; 'Odyssey', 'price' =&gt; 3.55]
];
foreach ($books as $index =&gt; $book) {
<span class="strong"><strong class="calibre2">    $addTaxes($book, $index, 0.16);</strong></span>
}
var_dump($books);</pre></div><p class="calibre8">In order to use the <a id="id352" class="calibre1"/>function, you just invoke it as if <code class="email">$addTaxes</code> contained the name of the function to be invoked. The rest of the function works as if it was a normal function: it receives arguments, it can return a value, and it has a scope. What is the benefit of defining it in this way? One possible application would be to use it as a <a id="id353" class="calibre1"/>
<span class="strong"><strong class="calibre2">callable</strong></span>. A callable is a variable type that identifies a function that PHP can call. You send this callable variable as an argument, and the function that receives it can invoke it. Take the PHP native function, <code class="email">array_walk</code>. It gets an array, a callable, and some extra arguments. PHP will iterate the array, and for each element, it will invoke the callable function (just like the <code class="email">foreach</code> loop). So, you can replace the whole loop by just the following:</p><div class="informalexample"><pre class="programlisting">array_walk($books, $addTaxes, 0.16);</pre></div><p class="calibre8">The callable that <code class="email">array_walk</code> receives needs to take at least two arguments: the value and the index of the current element of the array, and thus, the <code class="email">$index</code> argument that we were forced to implement previously. It can optionally take extra arguments, which will be the extra arguments sent to <code class="email">array_walk</code>—in this case, the 0.16 as <code class="email">$percentage</code>.</p><p class="calibre8">Actually, anonymous functions are not the only callable in PHP. You can send normal functions and even class methods. Let's see how:</p><div class="informalexample"><pre class="programlisting">function addTaxes(array &amp;$book, $index, $percentage) {
    if (isset($book['price'])) {
        $book['price'] += round($percentage * $book['price'], 2);
    }
}

class Taxes {
    public static function add(array &amp;$book, $index, $percentage)
    {
        if (isset($book['price'])) {
            $book['price'] += round($percentage * $book['price'], 2);
        }
    }
    public function addTaxes(array &amp;$book, $index, $percentage)
    {
        if (isset($book['price'])) {
            $book['price'] += round($percentage * $book['price'], 2);
        }
    }
}

// using normal function
<span class="strong"><strong class="calibre2">array_walk($books, 'addTaxes', 0.16);</strong></span>
var_dump($books);

// using static class method
<span class="strong"><strong class="calibre2">array_walk($books, ['Taxes', 'add'], 0.16);</strong></span>
var_dump($books);

// using class method
<span class="strong"><strong class="calibre2">array_walk($books, [new Taxes(), 'addTaxes'], 0.16);</strong></span>
var_dump($books);</pre></div><p class="calibre8">In the preceding example, you can see how we can use each case as a callable. For normal methods, just send the name of the method as a string. For static methods of a class, send an array with the name of the class in a way that PHP understands (either the full name including namespace, or adding the <code class="email">use</code> keyword beforehand), and the name of the method, both as strings. To use a normal method of a class, you need to send an array with an instance of that class and the method name as a string.</p><p class="calibre8">OK, so anonymous<a id="id354" class="calibre1"/> functions can be used as callable, just as any other function or method can. So what is so special about them? One of the things is that anonymous functions are variables, and so they have all the advantages—or disadvantages—that a variable has. That includes scope—that is, the function is defined inside a scope, and as soon as this scope ends, the function will no longer be accessible. That can be useful if your function is extremely specific to that bit of code, and there is no way you will want to reuse it somewhere else. Moreover, as it is nameless, you will not have conflicts with any other existing function.</p><p class="calibre8">There is another benefit in using anonymous functions: inheriting variables from the parent scope. When you define an anonymous function, you can specify some variable from the scope where it is defined with the keyword <code class="email">use</code>, and use it inside the function. The value of the variable will be the one it had at the moment of declaring the function, even if it is updated later. Let's see an example:</p><div class="informalexample"><pre class="programlisting">$percentage = 0.16;
$addTaxes = function (array &amp;$book, $index) use ($percentage) {
    if (isset($book['price'])) {
        $book['price'] += round($percentage * $book['price'], 2);
    }
};
<span class="strong"><strong class="calibre2">$percentage = 100000;</strong></span>
array_walk($books, $addTaxes);
var_dump($books);</pre></div><p class="calibre8">The preceding example shows you how to use the keyword <code class="email">use</code>. Even when we update <code class="email">$percentage</code> after defining the function, the result shows you that the taxes were only 16%. This is useful, as it liberates you from having to send <code class="email">$percentage</code> everywhere you want to use the function <code class="email">$addTaxes</code>. If there is a scenario where you really need to have the updated value of the used variables, you can declare them as a reference as you would with a normal <a id="id355" class="calibre1"/>function's argument:</p><div class="informalexample"><pre class="programlisting">$percentage = 0.16;
$addTaxes = function (array &amp;$book, $index) use (&amp;$percentage) {
    if (isset($book['price'])) {
        $book['price'] += round($percentage * $book['price'], 2);
    }
};

array_walk($books, $addTaxes, 0.16);
var_dump($books);

$percentage = 100000;
array_walk($books, $addTaxes, 0.16);
var_dump($books);</pre></div><p class="calibre8">In this last example, the first <code class="email">array_walk</code> used the original value 0.16, as that was still the value of the variable. But on the second call, <code class="email">$percentage</code> had already changed, and it affected the result of the anonymous function.</p></div>
<div class="book" title="Summary" id="19UOO1-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec38" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, you have learned what object-oriented programming is, and how to apply it to our web application for creating a clean code, which is easy to maintain. You also know how to manage exceptions properly, the design patterns that are used the most, and how to use anonymous functions when necessary.</p><p class="calibre8">In the next chapter, we will explain how to manage the data of your application using databases so that you can completely separate data from code.</p></div></body></html>