<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer217">
			</div>
		</div>
		<div class="Content" id="_idContainer218">
			<h1 id="_idParaDest-301"><a id="_idTextAnchor309"/>8. Error Handling</h1>
		</div>
		<div class="Content" id="_idContainer256">
			<p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to describe the different error levels in PHP; use a custom error handler; trigger and log error messages; catch fatal errors at shutdown; explain how exceptions work in PHP; define, use, and catch multiple exception classes; and register a top-level exception handler.</p>
			<p class="callout">Also, in this chapter, you will trigger so-called user-level error messages and how they can be helpful. In the last part, you will learn about exceptions and how they can be used to control script flow.</p>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor310"/>Introduction</h1>
			<p>In the previous chapter, you were presented with the ways in which PHP can be used to interact with a filesystem in order to process uploaded files, write in text files, and create files and directories, to name but a few aspects. Also, you were shown how a SQL server can be used with PHP to manipulate structured data, such as user accounts or a contacts list.</p>
			<p>Handling errors in an application is very important and keeping an eye on them leads to early bug detection, performance improvements, and the overall robustness of the application. Errors can be triggered to signal a number of malfunctions—missing data, bad syntax, deprecated features, and more, and can bring a halt to the script process, depending on severity. For example, when a database connection is not possible, the application would emit a fatal error, which could be handled by writing in a log file, sending an alert email to maintainers/developers with rich trace information (such as connection details), and a nice, user-friendly message would be displayed on user output (a browser, for example). On a social media website, for example, when a user tries to add a comment to a post that has been deleted in the interim (or made inaccessible), an error would be shown providing notification of the failure to add the comment. </p>
			<h1 id="_idParaDest-303"><a id="_idTextAnchor311"/>Errors in PHP</h1>
			<p>Errors and error handlers in software programming are a priceless concept that helps developers to identify failure points at the application compile-time or at runtime. They can signal different levels of severity. Hence, the script could emit a fatal error that causes the process to stop, it could emit warnings that point to possible misuse of the script, and it could also emit some notifications hinting at code improvements (for example, using an uninitialized variable in an operation). Therefore, errors are grouped in different levels, based on severity—fatal errors, warnings, notices, and debug messages, to name but a few. All these messages are usually collected to persistent storage, in a process called logging. The most accessible logging method is writing to a file on a local filesystem, and this is the default method for most (if not all) applications. These logs are read by developers to identify issues or look for other specific information, such as memory usage or SQL query response times. Modern applications, like those based on the cloud, do not retain the application logs on the filesystem; instead, they send them out to specialized log handling applications.</p>
			<p>In PHP, errors are handled and logged using a series of built-in functions. They facilitate the tailoring of error handling and logging to suit an application's needs by registering custom error handlers or setting error reporting for a specific range of levels.</p>
			<p>Since these functions are incorporated in the PHP core, no other extensions need to be installed in order to use them. The settings in the <strong class="source-inline">php.ini</strong> configuration file, or the use of functions such as <strong class="source-inline">ini_set()</strong> at runtime, affect the behavior of these functions.</p>
			<p>Some of the most frequently encountered errors and widely used logging configuration options are listed in the following table:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer219">
					<img alt="Figure 8.1: Common error and logging configurations&#13;&#10;" src="image/C14196_08_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1: Common error and logging configurations</p>
			<p>It is always better to check these values after you install a certain version of PHP and set appropriate values. Of course, special attention should be paid to the PHP settings on the production server. If you prefer to change a configuration value at runtime, the <strong class="source-inline">ini_set()</strong> function can be used as follows:</p>
			<p class="source-code">ini_set('display_errors', 'Off');</p>
			<p>However, it is better to have all the configurations in files only. For example, in the case of setting the <strong class="source-inline">display_errors</strong> to "<strong class="source-inline">Off</strong>", to hide any error message from the user output, should the script fail to compile before the setting is reached and read, then the errors will be displayed to the user.</p>
			<p>Let's now say a few words about "compile-time" and "runtime." PHP runs in two major stages, the first being compilation, and the second, interpretation: </p>
			<ol>
				<li>In the first stage—the compile-time, PHP parses the script file and builds the so-called machine code. This is the raw binary format that is run by the machine (the computer and server) and is not human-readable. This step can be cached using tools such as Opcache or APC, which is recommended on account of the huge performance boost it brings.</li>
				<li>In the second stage—the runtime, the machine code is actually executed.</li>
			</ol>
			<p>Also, in order to communicate with the server on which PHP runs, it uses a server application programming interface (otherwise known as a server API, aka SAPI). For example, running PHP from the command line (in the Terminal), the command-line interface (CLI) SAPI would be used. For web traffic, Apache2 SAPI may be used (as a module in the Apache2 server), or FastCGI Process Manager (FPM) SAPI with the NGINX server. These are the most commonly used interfaces for PHP, and they are installed as needed, each containing their own configuration files, which usually import the main/default configuration and are extended with their own specific configuration files. We will talk about configuration files a bit later.</p>
			<p>Here are the most common predefined constants for error messages:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer220">
					<img alt="Figure 8.2: Predefined constants for error messages&#13;&#10;" src="image/C14196_08_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2: Predefined constants for error messages</p>
			<p>These errors are generated and reported by the PHP engine and will be reported in error handlers that we will encounter later. To change the error reporting level in PHP, the <strong class="source-inline">error_reporting()</strong> function, which requires only one parameter – the decimal number used as the <em class="italic">bit mask</em> (a bit mask is a binary sequence used in this case to match a triggered error message level), can be used. The <strong class="source-inline">error_reporting()</strong> function parameter is often used as a bitwise expression between two or more error-level constants. For example, if we only want to report errors and warnings, we would invoke <strong class="source-inline">error_reporting(E_ERROR | E_WARNING);</strong> at script runtime. Using bitwise expressions is also allowed for <strong class="source-inline">error_reporting</strong> entries in INI configuration files.</p>
			<p>Apart from these, there are some other error codes (including constants) that are used in user scripts to generate errors on request.</p>
			<p>Here is the list of predefined constants for user-level generated error messages, using the PHP function, <strong class="source-inline">trigger_error()</strong>:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer221">
					<img alt="Figure 8.3: Predefined constants for user-level generated error messages&#13;&#10;" src="image/C14196_08_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3: Predefined constants for user-level generated error messages</p>
			<p>These are useful when the developer wants to report something in a given context but does not want to halt the execution of the script. For example, when you refactor a component by "removing" a function, among other operations (in your application code or in a PHP library that you manage), you might prefer to include an <strong class="source-inline">E_USER_DEPRECATED</strong> level message in the function to remove, pointing to the preferred alternative, rather than just removing the function, thereby increasing the chances of calls to undefined function error messages that would stop your script.</p>
			<p>To set custom PHP settings before runtime, it's sufficient to add the custom configuration file inside the INI (configuration) directory of PHP. To find this directory, you should run <strong class="source-inline">php --ini</strong>; the output will be something like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer222">
					<img alt="Figure 8.4: Output of the php-ini command&#13;&#10;" src="image/C14196_08_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4: Output of the php-ini command</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">--ini</strong> option scans and loads all the <strong class="source-inline">.ini</strong> files within each directory.</p>
			<p>Look for <strong class="source-inline">Scan for additional .ini files</strong>, and there you will find the directory where your settings should go.</p>
			<p>You should make sure to add the custom configuration file for both CLI and FPM modes, if the configuration directories used are separate among them.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If the preceding directory contains <strong class="source-inline">/cli/</strong> in its path, this means that the configuration only applies to the CLI, and you should look for the FPM directory on the same level as the CLI and add the custom configuration there too.</p>
			<p>Next, please make sure that you have set the following values related to errors and logs in PHP in a custom INI file.</p>
			<p>Create the <strong class="source-inline">/etc/php/7.3/cli/conf.d/custom.ini</strong> file and set the following values:</p>
			<p class="source-code">error_reporting=E_ALL</p>
			<p class="source-code">display_errors=On</p>
			<p class="source-code">log_errors=Off</p>
			<p class="source-code">error_log=NULL</p>
			<p>Although we could make use of an <strong class="source-inline">error_log</strong> configuration to log everything in a file, we will leave this job to a logger component that will be able to handle multiple outputs instead of a single one – sending logs in a file, to a log server, to Slack, and so on.</p>
			<p>You should make a clear distinction between error reporting and handling and logging these errors.</p>
			<p>Furthermore, the preceding PHP configuration values will be considered set.</p>
			<p>Running a quick check, using <strong class="source-inline">ls -ln /etc/php/7.3/cli/conf.d</strong>, we should get the following:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer223">
					<img alt="Figure 8.5: Listing the configuration files under the folder&#13;&#10;" src="image/C14196_08_05.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5: Listing the configuration files under the folder</p>
			<p>As you will notice, the configuration for installed modules is linked to the common configuration file from <strong class="source-inline">/etc/php/7.3/mods-available/</strong>, as discussed previously.</p>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor312"/>Handling Errors</h2>
			<p>By default, PHP will output the error messages to user output (on the browser screen when accessing the program through a browser, or in the Terminal/commander when run in a command-line interface). This should be changed in the early stages of application development so that, after publishing the app, you can be certain that no error messages will be leaked to the user, because it would look unprofessional and may occasionally scare the end user. The application errors should be treated in such a way that the end user will not see some possible faults when they occur (such as failing to connect to the cache service), or user-friendly error messages pertaining to the operation that it was not possible to execute (for example, the inability to add a comment while connection to the database is not possible).</p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor313"/>The Default Error Handler</h2>
			<p>PHP uses a default error handler, provided no other error handler is specified by the user (developer), that simply outputs the error message to the user output, be it the browser or the Terminal/commander. This message contains the error message itself, the filename, and the line number where the error was triggered. By checking whether the default error handler in action is enough to run in a command-line interface with, <strong class="source-inline">php -r 'echo $iDontExist;'</strong>, you will get the following output:</p>
			<p class="source-code">PHP Notice: Undefined variable: iDontExist in Command line code on line 1</p>
			<p>Such types of error may be output from all over the application, for a variety of reasons: undefined variables, using strings as an array, attempting to not open an existing (or without read permissions) file, calling missing methods on an object, and so on. Even if you set up a custom error handler and do not show the end user such errors, it is best practice to resolve rather than hide them. Designing your application to avoid such error triggering will make your application more performant, more robust, and less prone to bugs.</p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor314"/>Using a Custom Error Handler</h2>
			<p>We always want to manage the reported errors in our application, instead of outputting them in response. For this, we have to register our own error handler, and we will use the built-in function, <strong class="source-inline">set_error_handler()</strong>.</p>
			<p>The syntax is as follows:</p>
			<p class="source-code">set_error_handler(callable $error_handler [, int $error_types = E_ALL |   E_STRICT ])</p>
			<p>The first argument is a callable, while the second argument will specify the levels for which this handler will be invoked. </p>
			<p>A callable is a function that will be run at a certain point in execution, being fed an expected list of parameters. For example, by running the following PHP code, <strong class="source-inline">php -r 'var_dump(array_map("intval", [ "10", "2.3", "ten" ]));'</strong>, the <strong class="source-inline">array_map()</strong> function will invoke the <strong class="source-inline">intval()</strong> function for each element of the array parameter, <strong class="source-inline">("10", "2.3", "ten")</strong>, providing the element value; as a result, we get an array of the same length, but with integer values:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer224">
					<img alt="Figure 8.6: Passing values to a function&#13;&#10;" src="image/C14196_08_06.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6: Passing values to a function</p>
			<p>The type of callable can be a declared function, a function variable (an anonymous function), an instantiated class method, a class static method, or a class instance implementing the <strong class="source-inline">__invoke()</strong> method.</p>
			<p>If the error raised is of a different type to the one specified in <strong class="source-inline">set_error_handler()</strong>, then the default error handler will be invoked. Also, the default handler will be invoked when the custom error handler returns the Boolean <strong class="source-inline">FALSE</strong>. The handler will only be used for specified <strong class="source-inline">$error_types</strong> parameters, regardless of the <strong class="source-inline">error_reporting</strong> value.</p>
			<p>The error handler should have the following signature:</p>
			<p class="source-code">handler(int $errno, string $errstr [, string $errfile [, int $errline [, array   $errcontext]]]): bool</p>
			<p>The arguments are as follows:</p>
			<ul>
				<li><strong class="source-inline">$errno (integer)</strong>: points to the error level of the message</li>
				<li><strong class="source-inline">$errstr (string)</strong>: is the error message itself</li>
				<li><strong class="source-inline">$errfile (string)</strong>: the file path where the error happened</li>
				<li><strong class="source-inline">$errline (integer)</strong>: the line number in the file where the error occurred</li>
				<li><strong class="source-inline">$errcontext (array)</strong>: a list of all variables available at the time the error occurred in <strong class="source-inline">$errfile</strong> at <strong class="source-inline">$errline</strong>, as name-value pairs in the associative array</li>
			</ul>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor315"/>Exercise 8.1: Using a Custom Error Handler</h2>
			<p>So far, we have learned about error codes and some configurations for error reporting using the default error handler. In this exercise, we will register a custom error handler and learn how we can use it:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">custom-handler.php</strong> and add the following content. First, we define the error handler – an anonymous function stored in the <strong class="source-inline">$errorHandler</strong> variable, which will print the current date and time, the message, the filename, the line number, and the error code in a format of our choosing:<p class="source-code">&lt;?php</p><p class="source-code">$errorHandler = function (int $code, string $message, string $file,   int $line) {</p><p class="source-code">    echo date(DATE_W3C), " :: $message, in [$file] on line [$line]       (error code $code)", PHP_EOL;</p><p class="source-code">};</p></li>
				<li>Then, we register the error handler defined previously for all types of errors, using the <strong class="source-inline">set_error_handler()</strong> function:<p class="source-code">set_error_handler($errorHandler, E_ALL);</p></li>
				<li>Finally, we write an expression that should trigger some error messages at runtime – a division operation, the variables of which are not yet defined:<p class="source-code">echo $width / $height, PHP_EOL;</p></li>
				<li>Execute the following command in the Terminal:<p class="source-code">php custom-handler.php</p><p>The output is as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer225">
					<img alt="Figure 8.7: Output of the program&#13;&#10;" src="image/C14196_08_07.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7: Output of the program</p>
			<p>So, we have two <strong class="source-inline">Undefined variable</strong> (<strong class="source-inline">code 8</strong>) errors and a <strong class="source-inline">Division by zero</strong> (<strong class="source-inline">code 2</strong>) error. And, on the last line, we got <strong class="source-inline">NAN</strong> – not-a-number, since division by zero doesn't make sense. Looking at the predefined constants table, we can see that the <strong class="source-inline">code 2</strong> error is a warning, while the <strong class="source-inline">code 8</strong> error is a notification.</p>
			<p>Congratulations! You have just used your first customized error handler.</p>
			<p>Now, let's see how you could use it better than just printing the errors onscreen. Do you recall that you don't want the visitors of your website to see all this stuff? So, instead of printing, let's just log them (write) in a file.</p>
			<p>As indicated earlier, the reason for logging the errors (or other kinds of messages) in files is to have them recorded in persistent storage so that they can be read at any time, by anybody with access to the server, even when the application is not running. This is particularly useful since many errors might arise once end users "exploit" the application, and logging turns out to be an appropriate way to check errors occurring after such usage.</p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor316"/>Exercise 8.2: Logging with the Custom Error Handler</h2>
			<p>Logging errors on a filesystem is just one of the many other logging methods, and it's probably the simplest. In this exercise, we will see how we can use the error handler to write in a log file, in the simplest way possible:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">log-handler.php</strong> and add the following content.</li>
				<li>The custom error handler will create a data stream resource using <strong class="source-inline">fopen()</strong>, if this has not already been done, using the <strong class="source-inline">"append" (a) flag</strong>. The target is the <strong class="source-inline">app.log</strong> file in the script directory. The stream is cached for subsequent calls, using the static keyword to initialize the <strong class="source-inline">$stream</strong> variable. The stream being written to is effected using the <strong class="source-inline">fwrite()</strong> function, and the message format is the same as in the previous exercise:<p class="source-code">&lt;?php</p><p class="source-code">$errorHandler = function (int $code, string $message, string $file, int $line) {</p><p class="source-code">    static $stream;</p><p class="source-code">    if (is_null($stream)) {</p><p class="source-code">        $stream = fopen(__DIR__ . '/app.log', 'a');</p><p class="source-code">    }</p><p class="source-code">    fwrite(</p><p class="source-code">        $stream,</p><p class="source-code">        date(DATE_W3C) . " :: $message, in [$file] on line [$line] (error code $code)" . PHP_EOL</p><p class="source-code">    );</p><p class="source-code">};</p></li>
				<li>Then, the error handler is set for all error types again, followed by the test arithmetical expression that will trigger the errors:<p class="source-code">set_error_handler($errorHandler, E_ALL);</p><p class="source-code">echo $width / $height, PHP_EOL;</p></li>
				<li>Now, run the file in the command-line interface with the following command:<p class="source-code">php log-handler.php</p><p>This time, as output, we only get <strong class="source-inline">NAN</strong>, as expected, since we are logging the errors in the <strong class="source-inline">app.log</strong> file:</p><div class="IMG---Figure" id="_idContainer226"><img alt="Figure 8.8: Output showing the NAN value&#13;&#10;" src="image/C14196_08_08.jpg"/></div><p class="figure-caption">Figure 8.8: Output showing the NAN value</p></li>
				<li>Check the <strong class="source-inline">app.log</strong> file content; you should discover the following:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer227">
					<img alt="Figure 8.9: Contents of the log file&#13;&#10;" src="image/C14196_08_09.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.9: Contents of the log file</p>
			<p>As you can see, the script output looks cleaner now, while in the log file, we have only error log messages. The end user does not see any under-the-hood errors, and the log file contains only the information relevant to the errors themselves.</p>
			<p>Using <strong class="source-inline">fopen()</strong> in this example, we did not check whether it successfully opened and returned the stream resource, with the probability of failing to do so being very small, since the script will create the file in the same directory where it itself resides. In a real-world application, where the target file might have a directory path that does not exist on disk yet, or no write permission for that location, and so on, you should treat all these failure cases in the way you consider the best, either by halting script execution, outputting to standard error output, by ignoring the error, and so on. My personal approach, in many cases, is to output to standard error output, having a health checker set up, which, at its invocation, will report the logger issue. But in cases where the logging component is considered vital (legal or business constraints), then you may decide to prevent the application from running at all in the case of logging issues.</p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor317"/>Triggering a User-Level Error</h2>
			<p>Sometimes, depending on the purpose, it is useful to trigger errors in a script. For example, module refactoring would result in deprecated methods or inputs, and deprecation errors would be appropriate until the application that relies on that module completes the migration, instead of just removing the methods of the old API.</p>
			<p>To achieve this, PHP provides the <strong class="source-inline">trigger_error()</strong> core function, and the syntax is the following:</p>
			<p class="source-code">trigger_error( string $error_msg [, int $error_type = E_USER_NOTICE ] ): bool</p>
			<p>The first parameter is the error message and is required. The second parameter is the level of the error message and is optional, <strong class="source-inline">E_USER_NOTICE</strong> being the default value.</p>
			<p>Before we continue, let's set up an error handler that we will include in further exercises. We will call this file <strong class="source-inline">error-handler.php</strong>, and its content will be the following:</p>
			<p class="source-code">&lt;?php</p>
			<p class="source-code">$errorHandler = function (int $code, string $message, string $file, int $line) {</p>
			<p class="source-code">    echo date(DATE_W3C), " :: $message, in [$file] on line [$line] (error code       $code)", PHP_EOL;</p>
			<p class="source-code">    if ($code === E_USER_ERROR) {</p>
			<p class="source-code">        exit(1);</p>
			<p class="source-code">    }</p>
			<p class="source-code">};</p>
			<p class="source-code">set_error_handler($errorHandler, E_ALL);</p>
			<p class="source-code">return $errorHandler;</p>
			<p>First, we define the error handler—an anonymous function that will print the error message on the screen, and then, for the fatal error, <strong class="source-inline">E_USER_ERROR</strong>, it will halt the execution of the script with exit code <strong class="source-inline">1</strong>. This is a handler we can use in production, or for command-line scripts since the output is printed onscreen, the script is halted in the event of fatal errors, and also the exit code would be non-zero (meaning the script did not complete successfully).</p>
			<p>Then, we set the error handler for all types of errors and return it so that it can eventually be used by the script that invokes this file.</p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor318"/>Exercise 8.3: Triggering Errors</h2>
			<p>In this exercise, you will trigger some errors in the script, purposely, only when specific conditions are met. In order to continue, please make sure you created the error handler file described previously since it will be used in this and in the following exercises.</p>
			<p>In this particular simple script, we aim to return the square root of the input argument:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">sqrt.php</strong> and add the following content. First, we include the error handler file that we created previously, to have our custom error handler set. Then, we check for the first argument presence and, if not there, we use <strong class="source-inline">trigger_error()</strong> to output the error message that will halt the execution of the script since we use <strong class="source-inline">E_USER_ERROR</strong> for the second parameter. If the first input argument exists, we store it in the <strong class="source-inline">$input</strong> variable for convenience: <p class="source-code">&lt;?php</p><p class="source-code">require_once 'error-handler.php';</p><p class="source-code">if (!array_key_exists(1, $argv)) {</p><p class="source-code">    trigger_error('This script requires a number as first argument',       E_USER_ERROR);</p><p class="source-code">}</p><p class="source-code">$input = $argv[1];</p></li>
				<li>Next, there's a list of input validation and sanitization. First, we check whether the input is a number, and if it's not, we then trigger the error that halts the script:<p class="source-code">if (!is_numeric($input)) {</p><p class="source-code">    trigger_error(sprintf('A number is expected, got %s', $input),       E_USER_ERROR);</p><p class="source-code">}</p></li>
				<li>The second validation is against the float number. Notice that we use the <strong class="source-inline">$input * 1</strong> expression trick (because the input is a numerical string) to convert to either an integer or float. <p>Since the input is a string, we need to make use of some functions to either convert it to the expected type (an integer, in our case) or to test its matching type by parsing it. We made use of the <strong class="source-inline">is_numeric()</strong> function that tells whether the input looks like a number, but to test whether the string input looks like a decimal, we will have to do this little trick of multiplying by 1, since what PHP does, in this case, is to convert the variables involved in the operation depending on the context; in our case, in the arithmetical multiplication operation, PHP would convert both operands to either a float or integer type. For example, <strong class="source-inline">"3.14" * 1</strong> will result in a floating-point number with a value of <strong class="source-inline">3.14</strong>:</p><div class="IMG---Figure" id="_idContainer228"><img alt="Figure 8.10: Floating point output&#13;&#10;" src="image/C14196_08_10.jpg"/></div><p class="figure-caption">Figure 8.10: Floating point output</p><p>If the input is a float, then use the <strong class="source-inline">round()</strong> function to round half up to the input value and assign the value to the same <strong class="source-inline">$input</strong> variable; also trigger a warning error letting users know that decimal numbers are not allowed for this operation. This constitutes an error that will not halt the script:</p><p class="source-code">if (is_float($input * 1)) {</p><p class="source-code">    $input = round($input);</p><p class="source-code">    trigger_error(</p><p class="source-code">        sprintf(</p><p class="source-code">            'Decimal numbers are not allowed for this operation. Will use               the rounded integer value [%d]',</p><p class="source-code">            $input</p><p class="source-code">        ),</p><p class="source-code">        E_USER_WARNING</p><p class="source-code">    );</p><p class="source-code">}</p></li>
				<li>And, in the end, we check whether the number provided is negative. If it's negative, then we simply use the absolute value, with the help of the <strong class="source-inline">abs()</strong> function. Also, we trigger a warning error to provide a notification that negative numbers are not allowed to run in this script, an error that will not halt the execution of the script:<p class="source-code">if ($input &lt; 0) {</p><p class="source-code">    $input = abs($input);</p><p class="source-code">    trigger_error(</p><p class="source-code">        sprintf(</p><p class="source-code">            'A negative number is not allowed for this operation. Will use               the absolute value [%d].',</p><p class="source-code">            $input</p><p class="source-code">        ),</p><p class="source-code">        E_USER_WARNING</p><p class="source-code">    );</p><p class="source-code">}</p></li>
				<li>In the last part of the script, we finally executed and printed the square root of the input:<p class="source-code">echo sprintf('sqrt(%d) = ', $input), sqrt((float)$input), PHP_EOL;</p></li>
				<li>Run this script in the command-line interface:<p class="source-code">php sqrt.php; </p><p>You will get the following output:</p><div class="IMG---Figure" id="_idContainer229"><img alt="Figure 8.11: Error message&#13;&#10;" src="image/C14196_08_11.jpg"/></div><p class="figure-caption">Figure 8.11: Error message</p><p>In this case, the first condition was not met, since the first argument was not provided. Therefore, the script was halted after the error message was printed.</p></li>
				<li>Now, execute the following command:<p class="source-code">php sqrt.php nine;</p><p>The output is as follows:</p><div class="IMG---Figure" id="_idContainer230"><img alt="" src="image/C14196_08_12.jpg"/></div><p class="figure-caption">Figure 8.12: Error on adding text as a value</p><p>Just like in the previous example, the script was halted because of <strong class="source-inline">E_USER_ERROR</strong> (code <strong class="source-inline">256</strong>) due to invalid input; that would be condition number two – the input must be a number.</p></li>
				<li>Now, run the following command:<p class="source-code">php sqrt.php -81.3; </p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer231">
					<img alt="Figure 8.13: Output of the command&#13;&#10;" src="image/C14196_08_13.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.13: Output of the command</p>
			<p>The first line is an error message (a warning – <strong class="source-inline">error code 512</strong>) that provides a notification of the fact that the <strong class="source-inline">-81.3</strong> input value was altered, and now the rounded value, <strong class="source-inline">-81</strong>, will be used to allow the script to continue.</p>
			<p>The second line is another warning that notices the sign change for the input value, so instead of the negative <strong class="source-inline">-81</strong>, it will use the absolute value, <strong class="source-inline">81</strong>, allowing the script to execute further.</p>
			<p>Finally, on the last line, we get the processing output, <strong class="source-inline">sqrt(81) = 9</strong>. This is the only line we would get if we give <strong class="source-inline">81</strong> as an input argument instead of <strong class="source-inline">-81.3</strong>, due to the correct format of the input. Of course, any number can be used, so by running <strong class="source-inline">php sqrt.php 123</strong>, we get <strong class="source-inline">sqrt(123) = 11.090536506409</strong> as output:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer232">
					<img alt="Figure 8.14: Printing the square root of 123&#13;&#10;" src="image/C14196_08_14.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.14: Printing the square root of 123</p>
			<p>As you can see, in this exercise, we made use of user-triggered errors that were handled by our custom error handler. The <strong class="source-inline">E_ERROR</strong> and <strong class="source-inline">E_USER_ERROR</strong> error types will cause the script to be halted immediately on account of their nature. Also, you saw that warnings show that the script did not execute following the ideal path; the input data was altered, or some assumptions were made (such as using a constant name that was not defined – PHP will assume that name to be a string instead of null or an empty value). So, in the event of warnings, it is better to take action immediately and resolve any ambiguity. In our example, we used some warnings for invalid input, but we could use some lower-level warnings, such as <strong class="source-inline">E_USER_NOTICE</strong>, to give less importance to the error log entry, or higher-level warnings, such as <strong class="source-inline">E_USER_ERROR</strong>, which would halt the script. As you can see, these warnings depend on task specifications, and, with PHP, it is easy to achieve this.</p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor319"/>Logging Errors at Script Shutdown</h2>
			<p>Fatal errors, such as a call to an undefined function or the instantiations of an unknown class, cannot be handled by the registered error handler. They would simply halt script execution. So, you might ask why we then use <strong class="source-inline">E_ALL</strong> as the <strong class="source-inline">$error_types</strong> argument in <strong class="source-inline">set_error_handler()</strong>. This is just for convenience, because it is easiest to remember, and it describes, in some way, the fact that it's covering all the error types it can cover. The thing is that fatal errors have to halt script execution, and if this simple responsibility was left to the custom error handler, it would have been easy to bypass by simply not invoking script halting with <strong class="source-inline">exit()</strong> or its alias, <strong class="source-inline">die()</strong>.</p>
			<p>It is still possible to <em class="italic">catch</em> and log some of the fatal errors, by using the <strong class="source-inline">register_shutdown_function()</strong> function – which does exactly this – registers a <em class="italic">function</em> (a callable) to be invoked at script shutdown, and <strong class="source-inline">error_get_last()</strong>, which will return the last error, if any:</p>
			<p class="source-code">register_shutdown_function( callable $callback [, mixed $... ] ): void</p>
			<p>Here, the first parameter is a callable to be invoked at shutdown, followed by optional parameters that will become <strong class="source-inline">$callback</strong> arguments. Consider the following snippet: </p>
			<p class="source-code">register_shutdown_function(</p>
			<p class="source-code">    function (string $file, int $line) {</p>
			<p class="source-code">        echo "I was registered in $file at line $line", PHP_EOL;</p>
			<p class="source-code">    },</p>
			<p class="source-code">    __FILE__,</p>
			<p class="source-code">    __LINE__</p>
			<p class="source-code">);</p>
			<p>In the snippet, the callable receives two arguments – the string <strong class="source-inline">$file</strong>, and the integer <strong class="source-inline">$line</strong> – values of which are set by the <strong class="source-inline">__FILE__</strong> and <strong class="source-inline">__LINE__</strong> magic constants, passed as parameters with number two and three in <strong class="source-inline">register_shutdown_function()</strong>.</p>
			<p>Multiple functions can be registered for invocation at shutdown, using <strong class="source-inline">register_shutdown_function()</strong>. These functions will be called in the order of their registration. If we call <strong class="source-inline">exit()</strong> within any of these registered functions, processing will stop immediately:</p>
			<p class="source-code">error_get_last(): array</p>
			<p>No parameters are expected by the <strong class="source-inline">error_get_last()</strong> function, and the output is the aforementioned associative array that describes the error or, if no error has happened thus far, then <strong class="source-inline">null</strong> is output.</p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor320"/>Exercise 8.4: Logging Fatal Errors at Shutdown</h2>
			<p>Spotting fatal errors is very important because it will give you important information on why exactly the application crashes when it does. In this exercise, we want to catch and print the information relating to script halting (the reason and the place where it happened). Therefore, you will log such errors using the custom error handler, previously created and registered in the <strong class="source-inline">error-handler.php</strong> file:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">on-shutdown.php</strong> and insert the following content. Unlike other examples, we now store the error handler file output, which is the custom error handler callback (remember the last line, <strong class="source-inline">return $errorHandler;</strong>, in the <strong class="source-inline">'error-handler.php'</strong> file?). We want to keep the error handler for later use:<p class="source-code">&lt;?php</p><p class="source-code">$errorHandler = require_once 'error-handler.php';</p></li>
				<li>In this step, we define the shutdown function, which gets the last error using the <strong class="source-inline">error_get_last()</strong> function, and stores it in the <strong class="source-inline">$error</strong> variable, which is evaluated, and, if it's not null, then goes to the next step. If you have an error type of <strong class="source-inline">E_ERROR</strong> or <strong class="source-inline">E_RECOVERABLE_ERROR</strong>, then proceed further:<p class="source-code">if ($error = error_get_last()) {</p><p class="source-code">    if (in_array($error['type'], [E_ERROR, E_RECOVERABLE_ERROR], true)) {</p><p class="callout-heading">Note</p><p class="callout">We used <strong class="source-inline">[E_ERROR, E_RECOVERABLE_ERROR]</strong> in this example; feel free to use all fatal error codes in your code.</p></li>
				<li>Now, it's time to use the error handler; it is invoked, and the parameters are specified in the appropriate order, so as to match the callback signature:<p class="source-code">$errorHandler(</p><p class="source-code">    $error['type'],</p><p class="source-code">    $error['message'],</p><p class="source-code">    $error['file'],</p><p class="source-code">    $error['line']</p><p class="source-code">);</p><p class="callout-heading">Note</p><p class="callout">Since the last error we got has the same structure as any other errors, instead of duplicating the logic of the handler (logging the error in a specific format), we have reused the error handler callback for this purpose.</p></li>
				<li>The shutdown function is registered using <strong class="source-inline">register_shutdown_function()</strong>:<p class="source-code">     register_shutdown_function(</p><p class="source-code">    function () use ($errorHandler) {</p><p class="source-code">        if ($error = error_get_last()) {</p><p class="source-code">            if (in_array($error['type'], [E_ERROR, E_RECOVERABLE_ERROR],               true)) {</p><p class="source-code">                $errorHandler(</p><p class="source-code">                    $error['type'],</p><p class="source-code">                    $error['message'],</p><p class="source-code">                    $error['file'],</p><p class="source-code">                    $error['line']</p><p class="source-code">                );</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">}</p><p class="source-code">);</p></li>
				<li>In the last line of the script, we simply try to instantiate a class that does not exist in order to trigger the fatal error:<p class="source-code">new UnknownClass();</p><p>Run the script in the command-line interface with <strong class="source-inline">php on-shutdown.php;</strong> you should see the following output:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer233">
					<img alt="Figure 8.15: Screenshot of the error message&#13;&#10;" src="image/C14196_08_15.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.15: Screenshot of the error message</p>
			<p>This message is an <strong class="source-inline">E_ERROR</strong> that is printed by the default error handler, which is also responsible for halting the script execution in the event of such a fatal error, as discussed earlier. So, you may be wondering whether we can handle it before the default handler gets invoked, and we can actually do that, but let's look at this further.</p>
			<p>This is a lot of information for a single error. Here is what happens:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer234">
					<img alt="Figure 8.16: Information for all the error messages&#13;&#10;" src="image/C14196_08_16.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.16: Information for all the error messages</p>
			<p>This message includes the same information – we have the call stack as well (the path the runtime process followed until reaching the error). This error message is a throwable error (better known as an exception) and is printed by the default exception handler. The exceptions are special objects, which contain error information, and which we will learn about in more detail. In this particular case, because no custom exception handler is registered, the exception is converted to an error.</p>
			<p>In the last block (the third message box), we print the converted error, which is sent to the custom error handler.</p>
			<p>The output may look unexpected, but it makes sense. Trying to instantiate an unknown class will trigger an error exception, which, in the absence of a registered custom exception handler, will convert the exception to an error and will fire both – the default error handler and the default exception handler. In the end, with the script shut down, the shutdown function gets invoked, where we catch the last error and send it to our custom error handler to be logged.</p>
			<h1 id="_idParaDest-313"><a id="_idTextAnchor321"/>Exceptions</h1>
			<p>An exception is an event that occurs during the runtime of a program, and that disrupts its normal flow.</p>
			<p>Starting with version 7, PHP changed the way in which errors are reported. Unlike the traditional error reporting mechanism used in PHP 5, in version 7, PHP uses an object-oriented approach to deal with errors. Consequently, many errors are now thrown as exceptions.</p>
			<p>The exception model in PHP (supported since version 5) is similar to other programming languages. Therefore, when an error occurs, it is transformed into an object – the exception object – that contains relevant information about the error and the location where it was triggered. We can throw and catch exceptions in a PHP script. When the exception is thrown, it is handed to the runtime system, which will try to find a place in the script where the exception can be handled. This place that is looked for is called the exception handler, and it will be searched for in the list of functions that are called in the current runtime, until the exception was thrown. This list of functions is known as the call stack. First, the system will look for the exception handler in the current function, proceeding through the call stack in reverse order. When an exception handler is found, before the system handles the exception, it will first match the type of exceptions that the found exception handler accepts. If there is a match, then the script execution will resume in that exception handler. When no exception handler is found in the call stack, the default PHP exception handler will be handed the exception, and the script execution will halt.</p>
			<p>The base class for exceptions was the <strong class="source-inline">Exception</strong> class, starting with PHP version 5 when exceptions were introduced to PHP.</p>
			<p>Now, let's go back to the error reporting in PHP 7. Starting with PHP 7, most fatal errors are converted to exceptions and, to ensure backward compatibility for existing scripts (and for libraries to be able to be consistent with exception handlers in both PHP 5.x and PHP 7.x), fatal error exceptions are thrown with a <em class="italic">new exception base class</em> called <strong class="source-inline">Error</strong>. At the same time, a new interface was added, called <strong class="source-inline">Throwable</strong>, which is implemented by both the <strong class="source-inline">Exception</strong> and <strong class="source-inline">Error</strong> classes. Therefore, catching <strong class="source-inline">Throwable</strong> in a <strong class="source-inline">try-catch</strong> block will result in catching any possible exception.</p>
			<h2 id="_idParaDest-314"><a id="_idTextAnchor322"/>Basic Usage</h2>
			<p>Consider the following block of code:</p>
			<p class="source-code">try {</p>
			<p class="source-code">    if (!isset($argv[1])) {</p>
			<p class="source-code">        throw new Exception('Argument #1 is required.');</p>
			<p class="source-code">    }</p>
			<p class="source-code">} catch (Exception $e) {</p>
			<p class="source-code">    echo $e-&gt;getMessage(), PHP_EOL;</p>
			<p class="source-code">} finally {</p>
			<p class="source-code">    echo "Done.", PHP_EOL;</p>
			<p class="source-code">}</p>
			<p>Here, we can distinguish four keywords: <strong class="source-inline">try</strong>, <strong class="source-inline">throw</strong>, <strong class="source-inline">catch</strong>, and <strong class="source-inline">finally</strong>. I'll explain the code block and keyword usage here:</p>
			<ul>
				<li>The <strong class="source-inline">try</strong> block is used to run any code that is expected to fail in an exceptional case (throwing an exception error). Inside this block, we may throw exceptions explicitly or not if (when the exception is thrown by a function, that we run inside the <strong class="source-inline">try</strong> block,), relying on the bubbling-up-stack exceptions, property of exceptions to go back through the call stack (searching for an exception handler mentioned previously);</li>
				<li><strong class="source-inline">throw</strong> is used to trigger a new exception, and it requires an exception class instance as an argument (any class that extends the <strong class="source-inline">Exception</strong> or <strong class="source-inline">Error</strong> class – more on this later).</li>
				<li>The <strong class="source-inline">catch</strong> block is used to handle exceptions, and requires the exception type (class) to "catch", and the variable name under which the exception will be stored; the exception type can be a concrete class name, an abstract class name, or an interface name – the caught exceptions are the ones that implement, extend, or indeed are the concrete-specified classes; multiple <strong class="source-inline">catch</strong> blocks may be specified, but only the first type-matching caught exception block will be executed; in the absence of any <strong class="source-inline">catch</strong> block, the <strong class="source-inline">finally</strong> block is required.</li>
				<li>The <strong class="source-inline">finally</strong> block will run the code inside it for each <strong class="source-inline">try</strong> attempt, even if no exception was thrown, or if the exception was thrown and caught, or if the exception was thrown but wasn't caught with any of the <strong class="source-inline">catch</strong> blocks. This is especially useful in the case of long-running processes for closing the open resources after the specific task ends (files, database connections, and so on).</li>
			</ul>
			<p>In the preceding example, the script enters the <strong class="source-inline">try</strong> block and checks whether the first argument is set at runtime and, if it isn't set, it will throw an exception of the <strong class="source-inline">Exception</strong> type, which is caught by the <strong class="source-inline">catch</strong> block, because it expects exceptions of the <strong class="source-inline">Exception</strong> class, <strong class="bold">or any other class that extends </strong>the <strong class="source-inline">Exception</strong> <strong class="bold">class</strong>. The caught exception is available under the <strong class="source-inline">$e</strong> variable after entering the <strong class="source-inline">catch</strong> block.</p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor323"/>Exercise 8.5: Implementing Exceptions</h2>
			<p>In this exercise, you will throw and catch exceptions in PHP. To achieve this, we will create a script that will instantiate a class based on user input. Also, the script will print several sentences to trace the script flow in order to understand better how the exception mechanism works in PHP:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">basic-try.php</strong> and add the following code. Mark the beginning of the script with a <strong class="source-inline">SCRIPT START</strong> message:<p class="source-code">&lt;?php</p><p class="source-code">echo 'SCRIPT START.', PHP_EOL;</p></li>
				<li>Open a <strong class="source-inline">try</strong> block and print the <strong class="source-inline">Run TRY block</strong> message:<p class="source-code">try {</p><p class="source-code">    echo 'Run TRY block.', PHP_EOL;</p></li>
				<li>If no class name is specified in the input argument, print the <strong class="source-inline">NO ARGUMENT: Will throw exception.</strong> message to give notification of the intention, and throw an exception:<p class="source-code">    if (!isset($argv[1])) {</p><p class="source-code">        echo 'NO ARGUMENT: Will throw exception.', PHP_EOL;</p><p class="source-code">        throw new LogicException('Argument #1 is required.');</p><p class="source-code">    }</p></li>
				<li>Otherwise, when we have an input argument, we print it and try an instantiation assuming the input argument is a known class name. The new object is dumped to output with the <strong class="source-inline">var_dump()</strong> function:<p class="source-code">    echo 'ARGUMENT: ', $argv[1], PHP_EOL;</p><p class="source-code">    var_dump(new $argv[1]);</p></li>
				<li>Close the <strong class="source-inline">try</strong> block and add the <strong class="source-inline">catch</strong> block, hinting the <strong class="source-inline">Exception</strong> class as the accepted exceptions type to be caught. In the <strong class="source-inline">catch</strong> block, we print the exception information formatted in a text message:<p class="source-code">} catch (Exception $e) {</p><p class="source-code">    echo 'EXCEPTION: ', sprintf('%s in %s at line %d', $e-&gt;getMessage(),       $e-&gt;getFile(), $e-&gt;getLine()), PHP_EOL;</p></li>
				<li>Add the <strong class="source-inline">finally</strong> block, which does nothing special in this script, except print the information about reaching this stage of the execution process:<p class="source-code">} finally {</p><p class="source-code">    echo "FINALLY block gets executed.\n";</p></li>
				<li>Finally, print the message informing the user that the script execution has exited the <strong class="source-inline">try/catch</strong> block and that the script will end:<p class="source-code">echo "Outside TRY-CATCH.\n";</p><p class="source-code">echo 'SCRIPT END.', PHP_EOL;</p></li>
				<li>Run the script in the command-line interface using the following command:<p class="source-code"> php basic-try.php; </p><p>The output should look like this:</p><div class="IMG---Figure" id="_idContainer235"><img alt="Figure 8.17: Output of the try/catch program&#13;&#10;" src="image/C14196_08_17.jpg"/></div><p class="figure-caption">Figure 8.17: Output of the try/catch program</p><p>Notice that the last two lines of the <strong class="source-inline">try</strong> block did not execute, and that's because an exception was thrown – <strong class="source-inline">LogicException</strong>, due to a missing input argument. The exception gets caught by the <strong class="source-inline">catch</strong> block, and some information is printed onscreen – the message, file, and the line of the <strong class="source-inline">throw</strong> location. Since the exception is caught, the script resumes its execution.</p></li>
				<li>Now, run <strong class="source-inline">php basic-try.php DateTime;</strong> the output will be as follows:<div class="IMG---Figure" id="_idContainer236"><img alt="Figure 8.18: Output of the command&#13;&#10;" src="image/C14196_08_18.jpg"/></div><p class="figure-caption">Figure 8.18: Output of the command</p><p>You will notice that, now, we have <strong class="source-inline">ARGUMENT: DateTime</strong> in the output, followed by the <strong class="source-inline">DateTime</strong> instance dump. The script flow is the <em class="italic">normal</em> one, without any exceptions thrown.</p></li>
				<li>Run the script with <strong class="source-inline">php basic-try.php DateTimeZone</strong>; the output is as follows:<div class="IMG---Figure" id="_idContainer237"><img alt="Figure 8.19: Throwing error due to missing parameter&#13;&#10;" src="image/C14196_08_19.jpg"/></div><p class="figure-caption">Figure 8.19: Throwing error due to missing parameter</p><p>Now, we got an exception error, and the interesting thing here is that the exception does not appear to be caught – see that the <strong class="source-inline">ARGUMENT</strong> line in the output is followed by the <strong class="source-inline">FINALLY</strong> line, and no <strong class="source-inline">EXCEPTION</strong> is printed. This is because the thrown exception does not extend the <strong class="source-inline">Exception</strong> class. </p><p>In the preceding example, <strong class="source-inline">ArgumentCountError</strong> is extending the <strong class="source-inline">Error</strong> exception class and is not caught by the <strong class="source-inline">catch (Exception $e)</strong> statement. Therefore, the exception was handled by the default exception handler and the script process was halted – notice that the <strong class="source-inline">FINALLY</strong> line is not followed by either the <strong class="source-inline">Outside TRY-CATCH.</strong> or <strong class="source-inline">SCRIPT END.</strong> lines.</p></li>
				<li>Copy the script to a new file called <strong class="source-inline">basic-try-all.php</strong> and add the <strong class="source-inline">catch (Error $e)</strong> block; the added code should be placed somewhere between the <strong class="source-inline">try</strong> and <strong class="source-inline">finally</strong> blocks:<p class="source-code">} catch (Error $e) {</p><p class="source-code">    echo 'ERROR: ', sprintf('%s in %s at line %d', $e-&gt;getMessage(),       $e-&gt;getFile(), $e-&gt;getLine()), PHP_EOL;</p></li>
				<li>Run the following command:<p class="source-code"> php basic-try-all.php DateTimeZone; </p><p>The output is as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer238">
					<img alt="Figure 8.20: Output of the command executed&#13;&#10;" src="image/C14196_08_20.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.20: Output of the command executed</p>
			<p>As expected, the error exception was now caught and printed in our format, and the script did not end unexpectedly.</p>
			<p>In this example, we saw how it is possible to catch exceptions. More than that, we learned the two base exception classes, and we now understand the difference between them.</p>
			<p>In the previous exercise, the throwable interface was mentioned, which is implemented by both the <strong class="source-inline">Error</strong> and <strong class="source-inline">Exception</strong> classes. Since the SPL (Standard PHP Library) offers a rich list of exceptions, let's display the exception hierarchy for <strong class="source-inline">Error</strong> exceptions that were added in version 7 of the PHP:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer239">
					<img alt="Figure 8.21: Exception hierarchy&#13;&#10;" src="image/C14196_08_21.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.21: Exception hierarchy</p>
			<p>Many other custom exception classes can be found in today's modern PHP libraries and frameworks.</p>
			<h2 id="_idParaDest-316"><a id="_idTextAnchor324"/>Custom Exceptions</h2>
			<p>In PHP, it is possible to define custom exceptions, and also to extend them with custom functionality. Custom exceptions are useful since the basic functionality can be extended according to application needs, bundling business logic in a base application exception class. Also, they bring meaning to the application flow, by being named according to the business logic to which they are related.</p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor325"/>Exercise 8.6: Custom Exceptions</h2>
			<p>In this exercise, we will define a custom exception, with extended functionality, which we will throw and catch, and the custom formatted message will then be printed on the screen. Specifically, this is a script that validates an email address:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">validate-email.php</strong> and define the custom exception class, called <strong class="source-inline">InvalidEmail</strong>, which will extend the <strong class="source-inline">Exception</strong> class. In addition, the new exception class provides the option to store and retrieve the context as an array:<p class="source-code">&lt;?php</p><p class="source-code">class InvalidEmail extends Exception</p><p class="source-code">{</p><p class="source-code">    private $context = [];</p><p class="source-code">    public function setContext(array $context)</p><p class="source-code">    {</p><p class="source-code">        $this-&gt;context = $context;</p><p class="source-code">    }</p><p class="source-code">    public function getContext(): array</p><p class="source-code">    {</p><p class="source-code">        return $this-&gt;context;</p><p class="source-code">    }</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">The suggested exception name does not include the <strong class="source-inline">Exception</strong> suffix, as this is used as a naming convention. Although exception names don't require a specific format, some developers prefer to add the <strong class="source-inline">Exception</strong> suffix, bringing the "specificity-in-class-name" argument, while others prefer not to include the suffix, bringing the "easier-to-read-the-code" argument. Either way, the PHP engine doesn't care, leaving the exception naming convention up to the developer or to the organization for which the code is written.</p></li>
				<li>Add the <strong class="source-inline">validateEmail()</strong> function, which returns nothing, but throws exceptions in the case of errors. The <strong class="source-inline">validateEmail()</strong> function expects the input parameter to be the same as script input arguments. If position <strong class="source-inline">1</strong> of the input array is not set (the first argument is not present), then an <strong class="source-inline">InvalidArgumentException</strong> exception is thrown. After this step, the function execution will stop. Otherwise, when position <strong class="source-inline">1</strong> is set, we validate the value with the built-in <strong class="source-inline">filter_var()</strong> function </li>
				<li>and the <strong class="source-inline">FILTER_VALIDATE_EMAIL</strong> flag. If the validation fails, then we instantiate the <strong class="source-inline">InvalidEmail</strong> exception class, set the context with the test value, and then throw it:<p class="source-code">function validateEmail(array $input)</p><p class="source-code">{</p><p class="source-code">    if (!isset($input[1])) {</p><p class="source-code">        throw new InvalidArgumentException('No value to check.');</p><p class="source-code">    }</p><p class="source-code">    $testInput = $input[1];</p><p class="source-code">    if (!filter_var($testInput, FILTER_VALIDATE_EMAIL)) {</p><p class="source-code">        $error = new InvalidEmail('The email validation has failed.');</p><p class="source-code">        $error-&gt;setContext(['testValue' =&gt; $testInput]);</p><p class="source-code">        throw $error;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Use a <strong class="source-inline">try-catch</strong> block to run the <strong class="source-inline">validateEmail()</strong> function and print the success message if no exceptions were thrown, or if the exception stipulates otherwise:<p class="source-code">try {</p><p class="source-code">    validateEmail($argv);</p><p class="source-code">    echo 'The input value is valid email.', PHP_EOL;</p><p class="source-code">} catch (Throwable $e) {</p><p class="source-code">    echo sprintf(</p><p class="source-code">            'Caught [%s]: %s (file: %s, line: %s, context: %s)',</p><p class="source-code">            get_class($e),</p><p class="source-code">            $e-&gt;getMessage(),</p><p class="source-code">            $e-&gt;getFile(),</p><p class="source-code">            $e-&gt;getLine(),</p><p class="source-code">            $e instanceof InvalidEmail ? json_encode($e-&gt;getContext()) :               'N/A'</p><p class="source-code">        ) . PHP_EOL;</p><p class="source-code">}</p><p>Therefore, in the <strong class="source-inline">try</strong> block, you will invoke the <strong class="source-inline">validateEmail()</strong> function and print the successful validation message. The message will be printed only if no exception is thrown by the <strong class="source-inline">validateEmail()</strong> function. Instead, if an exception is thrown, it will be caught in the <strong class="source-inline">catch</strong> block, where the error message will be printed onscreen. The error message will include the error type (the exception class name), the message, and the file and line number where the exception was created. Also, in the case of a custom exception, we will include the context as well, JSON-encoded.</p></li>
				<li>Run the<a id="_idTextAnchor326"/> script without an argument:<p class="source-code"> php validate-email.php; </p><p>The output will look like this:</p><div class="IMG---Figure" id="_idContainer240"><img alt="Figure 8.22: Executing code without passing arguments&#13;&#10;" src="image/C14196_08_22.jpg"/></div><p class="figure-caption">Figure 8.22: Executing code without passing arguments</p><p>We got <strong class="source-inline">InvalidArgumentException</strong>, as expected since no argument was provided to the script. </p></li>
				<li>Run the script with invalid arguments:<p class="source-code">php validate-email.php john.doe; </p><p>The output will look like this:</p><div class="IMG---Figure" id="_idContainer241"><img alt="Figure 8.23: Executing code with invalid arguments&#13;&#10;" src="image/C14196_08_23.jpg"/></div><p class="figure-caption">Figure 8.23: Executing code with invalid arguments</p><p>This time, the caught exception is <strong class="source-inline">InvalidEmail</strong>, and the context information is included in the message that is printed onscreen.</p></li>
				<li>Run the script with a valid email address:<p class="source-code"> php validate-email.php john.doe@mail.com; </p><p>The output will look like this:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer242">
					<img alt="Figure 8.24: Output for a valid email address&#13;&#10;" src="image/C14196_08_24.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.24: Output for a valid email address</p>
			<p>This time, the validation was successful, and the confirmation message is printed onscreen.</p>
			<p>In this exercise, you created your own custom exception class, and it can be used along with its extended functionality. The script is not only able to validate the input as email, but it will also give the reason (exception) in the case of validation failure, bundling some helpful context when appropriate.</p>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor327"/>Custom Exception Handler</h2>
			<p>Usually, you only want to catch and treat certain exceptions, allowing the application to run further. Sometimes, however, it is not possible to continue without the right data; you do want the application to stop, and you want to do it gracefully and consistently (for example, an error page for web applications, specific message formats and details for a command-line interface). </p>
			<p>To accomplish this, you can use the <strong class="source-inline">set_exception_handler()</strong> function. The syntax is as follows:</p>
			<p class="source-code">set_exception_handler (callable $exception_handler): callable</p>
			<p>This function expects a callable as an exception handler, and this handler should accept a <strong class="source-inline">Throwable</strong> as a first parameter. <strong class="source-inline">NULL</strong> can be passed as well, instead of a callable; in this case, the default handler will be restored. The return value is the previous exception handler or <strong class="source-inline">NULL</strong> in the case of errors or no previous exception handler. Usually, the return value is ignored.</p>
			<h2 id="_idParaDest-319"><a id="_idTextAnchor328"/>Using a Custom Exception Handler</h2>
			<p>Just like in the default error handler case, the default exception handler in PHP will print the error and will also halt script execution. Since you don't want any of these messages to reach the end user, you would prefer to register your own exception handler, where you can implement the same functionality as in the error handler – render the messages in a specific format and log them for debugging purposes.</p>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor329"/>Exercise 8.7: Using a Custom Exception Handler</h2>
			<p>In this exercise, you will define, register, and use a custom exception handler that will print errors in a specific format:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">exception-handler.php</strong> and add the following content. Define and register your own exception handler:<p class="source-code">&lt;?php</p><p class="source-code">set_exception_handler(function (Throwable $e) {</p><p class="source-code">    $msgLength = mb_strlen($e-&gt;getMessage());</p><p class="source-code">    $line = str_repeat('-', $msgLength);</p><p class="source-code">    echo $line, PHP_EOL;</p><p class="source-code">    echo $e-&gt;getMessage(), PHP_EOL;</p><p class="source-code">    echo '&gt; File: ', $e-&gt;getFile(), PHP_EOL;</p><p class="source-code">    echo '&gt; Line: ', $e-&gt;getLine(), PHP_EOL;</p><p class="source-code">    echo '&gt; Trace: ', PHP_EOL, $e-&gt;getTraceAsString(), PHP_EOL;</p><p class="source-code">    echo $line, PHP_EOL;</p><p class="source-code">});</p><p>In this file, we register the exception handler, which is an anonymous function that accepts the <strong class="source-inline">Throwable</strong> parameter as a <strong class="source-inline">$e</strong> variable. Then, we calculate the message length and create a line of dashes, of the same length as the error message, using the <strong class="source-inline">mb_strlen()</strong> and <strong class="source-inline">str_repeat()</strong> built-in functions. What follows is simple formatting for the message, including the file and line where the exception was created, and the exception trace; everything being wrapped by two dashed lines – one on top, and the other on the bottom, of the message block.</p></li>
				<li>We will use the <strong class="source-inline">basic-try.php</strong> file as the starting point for our example. Copy this file to <strong class="source-inline">basic-try-handler.php</strong> and include the <strong class="source-inline">exception-handler.php</strong> file in <strong class="source-inline">basic-try-handler.php</strong>, right after the <strong class="source-inline">SCRIPT START</strong> line:<p class="source-code">require_once 'exception-handler.php';</p></li>
				<li>Since we know that, in this example, we only catch <strong class="source-inline">Exception</strong>, while we skip <strong class="source-inline">Error</strong> exceptions, we'll run the command directly that would produce the <strong class="source-inline">Error</strong>, so that it can get caught by the handler. Therefore, run the following command: <p class="source-code">php basic-try-handler.php DateTimeZone; </p><p>Expect an output similar to the following:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer243">
					<img alt="Figure 8.25: Output of the command&#13;&#10;" src="image/C14196_08_25.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.25: Output of the command</p>
			<p>Now, the output looks cleaner than the one produced by the default exception handler. Of course, the exception handler can be used to log exceptions, especially unexpected ones, and add as much information as possible so that bugs are easier to identify and trace.</p>
			<p>As you may notice, the exception handler is very similar to the error handler in PHP. Hence, it would be great if we could use a single callback to perform error and exception handling. To help in this matter, PHP provides an exception class called <strong class="source-inline">ErrorException</strong>, which translates traditional PHP errors to exceptions.</p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor330"/>Translating Errors to Exceptions</h2>
			<p>To translate PHP errors (caught in the error handler) to exceptions, you can use the <strong class="source-inline">ErrorException</strong> class. This class extends the <strong class="source-inline">Exception</strong> class and, unlike the latter, it has a different constructor function signature from that of the class it extends.</p>
			<p>The constructor syntax of the <strong class="source-inline">ErrorException</strong> class is as follows:</p>
			<p class="source-code">public __construct (string $message = "", int $code = 0, int $severity = E_ERROR, string $filename = __FILE__, int $lineno = __LINE__, Exception $previous = NULL)</p>
			<p>The accepted parameters are the following:</p>
			<ul>
				<li><strong class="source-inline">$message</strong>: The exception message string</li>
				<li><strong class="source-inline">$code</strong>: Integer representing the exception code</li>
				<li><strong class="source-inline">$severity</strong>: The severity level of the exception (while this is an integer, it is recommended to use one of the <strong class="source-inline">E_*</strong> error code constants)</li>
				<li><strong class="source-inline">$filename</strong>: The filename where the exception was thrown</li>
				<li><strong class="source-inline">$lineno</strong>: The line number in the file where the exception was thrown</li>
				<li><strong class="source-inline">$previous</strong>: The previous exception used for the exception chaining</li>
			</ul>
			<p>Now, let's see how this class works.</p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor331"/>Exercise 8.8: Translating Errors to Exceptions</h2>
			<p>In this exercise, we will register an error handler that will only have to translate errors to exceptions and then invoke the exception handler. The exception handler will be responsible for handling all exceptions (including the translated errors) – this can be logging, rendering an error template, printing an error message in a specific format, and so on. In our exercise, we will use the exception handler to print the exception in a friendly format, as used in the previous exercise:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">all-errors-handler.php</strong>, define the exception handler, and then save it under the <strong class="source-inline">$exceptionHandler</strong> variable. This is the same callback function we used in the previous exercise:<p class="source-code">&lt;?php</p><p class="source-code">$exceptionHandler = function (Throwable $e) {</p><p class="source-code">    $msgLength = mb_strlen($e-&gt;getMessage());</p><p class="source-code">    $line = str_repeat('-', $msgLength);</p><p class="source-code">    echo $line, PHP_EOL;</p><p class="source-code">    echo get_class($e), sprintf(' [%d]: ', $e-&gt;getCode()),       $e-&gt;getMessage(),      PHP_EOL;</p><p class="source-code">    echo '&gt; File: ', $e-&gt;getFile(), PHP_EOL;</p><p class="source-code">    echo '&gt; Line: ', $e-&gt;getLine(), PHP_EOL;</p><p class="source-code">    echo '&gt; Trace: ', PHP_EOL, $e-&gt;getTraceAsString(), PHP_EOL;</p><p class="source-code">    echo $line, PHP_EOL;</p><p class="source-code">};</p></li>
				<li>Now, we define and assign the error handler to the <strong class="source-inline">$errorHandler</strong> variable. This function will instantiate <strong class="source-inline">ErrorException</strong>, using the function arguments for class constructor parameters. Then, the exception handler is invoked, passing the <strong class="source-inline">ErrorException</strong> instance as the only parameter. Finally, if the error severity is <strong class="source-inline">E_USER_ERROR</strong>, curtail execution of the script:<p class="source-code">$errorHandler = function (int $code, string $message, string $file, int   $line) use ($exceptionHandler) {</p><p class="source-code">    $exception = new ErrorException($message, $code, $code, $file, $line);</p><p class="source-code">    $exceptionHandler($exception);</p><p class="source-code">    if (in_array($code , [E_ERROR, E_RECOVERABLE_ERROR, E_USER_ERROR])) {</p><p class="source-code">        exit(1);</p><p class="source-code">    }</p><p class="source-code">};</p></li>
				<li>In the last part of the script, we simply set the error and the exception handlers:<p class="source-code">set_error_handler($errorHandler);</p><p class="source-code">set_exception_handler($exceptionHandler);</p></li>
				<li>Now, we will test the new handlers using an example where errors were reported, and the error handler was used. Let's pick the <strong class="source-inline">sqrt.php</strong> script, copy it to <strong class="source-inline">sqrt-all.php</strong>, and replace the <strong class="source-inline">require_once 'error-handler.php';</strong> line at the beginning of the file with <strong class="source-inline">require_once 'all-errors-handler.php';</strong>: <p class="source-code">&lt;?php</p><p class="source-code">require_once 'error-handler.php'; // removed</p><p class="source-code">require_once 'all-errors-handler.php'; // added</p></li>
				<li>The content of <strong class="source-inline">sqrt-all.php</strong> can be found at <a href="https://packt.live/2INXt9q">https://packt.live/2INXt9q</a> (the following code is explained in <em class="italic">Exercise 8.3</em>, <em class="italic">Triggering Errors</em>):</li>
				<li>Run the following commands in the following sequence:<p class="source-code">php sqrt-all.php</p><p class="source-code">php sqrt-all.php s5</p><p class="source-code">php sqrt-all.php -5</p><p class="source-code">php sqrt-all.php 9</p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer244">
					<img alt="Figure 8.26: Output for different cases&#13;&#10;" src="image/C14196_08_26.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.26: Output for different cases</p>
			<p>As before, <strong class="source-inline">E_USER_ERROR</strong> (<strong class="source-inline">code 256</strong>) brings the script to a halt, while <strong class="source-inline">E_USER_WARNING</strong> (<strong class="source-inline">code 512</strong>) allows the script to continue.</p>
			<p>In this exercise, we managed to forward all the errors caught with the error handler to the exception handler by converting each of them to an exception. This way, we can implement the code that handles both errors and exceptions in a single place in the script – in the exception handler. At the same time, we have used the <strong class="source-inline">trigger_error()</strong> function to generate some errors and have them printed by the exception handler. </p>
			<p>Yet, we are mixing application/technical error handling with business logic error handling. We want more control in terms of the flow of operations, so as to be able to handle issues on the spot and act accordingly. The exceptions in PHP allow us to do precisely that – to run a block of code for which some exceptions are expected, and which will be handled on the spot when they occur, controlling the flow of the operations. Looking at the previous exercise, we see that we can improve it by "catching" the errors before they reach the error handler, so we can print some less verbose error messages, for example. </p>
			<p>To achieve this, we will use the exceptions approach. Therefore, we will use <strong class="source-inline">try</strong>-<strong class="source-inline">catch</strong> blocks, which allow us to control the flow of operations, instead of the <strong class="source-inline">trigger_error()</strong> function, which sends the error directly to the error handler.</p>
			<h2 id="_idParaDest-323"><a id="_idTextAnchor332"/>Exercise 8.9: Simple Exception Handling</h2>
			<p>In the following exercise, we will implement a multipurpose script that aims to execute arbitrary PHP functions. In this case, we will not have so much control over input validation, since arbitrarily picked functions require different input parameter types, in a specific order, and a variable parameter count. In this case, we will use a method that validates and handles the input, and, in the event of validation failures, it will throw exceptions that are caught by the current function:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">run.php</strong> and include the error handler file. Then, we define a custom exception, called <strong class="source-inline">Disposable</strong>, so we can catch precisely the exception that we anticipate might be thrown:<p class="source-code">&lt;?php</p><p class="source-code">require_once 'all-errors-handler.php';</p><p class="source-code">class Disposable extends Exception</p><p class="source-code">{</p><p class="source-code">}</p></li>
				<li>Next, we declare the <strong class="source-inline">handle()</strong> function, which will be in charge of validation and running the script given the function name and arguments. A <strong class="source-inline">Disposable</strong> exception will be thrown when no function/class name argument is provided:<p class="source-code">function handle(array $input)</p><p class="source-code">{</p><p class="source-code">    if (!isset($input[1])) {</p><p class="source-code">        throw new Disposable('A function/class name is required as the           first argument.');</p><p class="source-code">    }</p></li>
				<li>Otherwise, the first argument is stored in the <strong class="source-inline">$calleeName</strong> variable:<p class="source-code">    $calleeName = $input[1];</p><p class="source-code">    $calleeArguments = array_slice($input, 2);</p><p>The <strong class="source-inline">callee</strong> arguments are prepared as a slice from the original input, since, in the first position (index 0) in the <strong class="source-inline">$input</strong> variable, where there is the script name and, at the second position (index <strong class="source-inline">1</strong>), where there is the <strong class="source-inline">callee</strong> name, we need a slice that starts index <strong class="source-inline">2</strong> from <strong class="source-inline">$input</strong>; for this purpose, we are using the <strong class="source-inline">array_slice()</strong> built-in function.</p></li>
				<li>If the callee is an existing function, then use the <strong class="source-inline">call_user_func_array()</strong> function to invoke the <strong class="source-inline">$calleeName</strong> function, providing the argument list of <strong class="source-inline">$calleeArguments</strong>:<p class="source-code">    if (function_exists($calleeName)) {</p><p class="source-code">        return call_user_func_array($calleeName, $calleeArguments);</p></li>
				<li>Otherwise, if <strong class="source-inline">$calleeName</strong> is an existing class name, then create an instance of the <strong class="source-inline">$calleeName</strong> class, providing the list of arguments for the <strong class="source-inline">constructor</strong> method:<p class="source-code">    } elseif (class_exists($calleeName)) {</p><p class="source-code">        return new $calleeName(...$calleeArguments);</p></li>
				<li>Finally, if the callee is not a function or a class name, then throw a <strong class="source-inline">Disposable</strong> exception:<p class="source-code">    } else {</p><p class="source-code">        throw new Disposable(sprintf('The [%s] function or class does not           exist.', $calleeName));</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In the last part of the script, we use the <strong class="source-inline">try</strong>-<strong class="source-inline">catch</strong> block. In the <strong class="source-inline">try</strong> part, we call the <strong class="source-inline">handle()</strong> function providing the script arguments, and store the output in the <strong class="source-inline">$output</strong> variable:<p class="source-code">try {</p><p class="source-code">    $output = handle($argv);</p><p class="source-code">    echo 'Result: ', $output ? print_r($output, true) :       var_export($output, true), PHP_EOL;</p><p>We display the result in the following manner: if <strong class="source-inline">$output</strong> evaluates to <strong class="source-inline">TRUE</strong> (a non-empty value such as zero, an empty string, or <strong class="source-inline">NULL</strong>), then use the <strong class="source-inline">print_r()</strong> function to display data in a friendly format; otherwise, use <strong class="source-inline">var_export()</strong> to give us a hint regarding the data type. Note that output printing will not happen if the <strong class="source-inline">handle()</strong> function throws an exception.</p></li>
				<li>The catch part will only catch <strong class="source-inline">Disposable</strong> exceptions, which are the anticipated error messages that will be printed on the screen. <strong class="source-inline">exit(1)</strong> is used to signal unsuccessful script execution:<p class="source-code">} catch (Disposable $e) {</p><p class="source-code">    echo '(!) ', $e-&gt;getMessage(), PHP_EOL;</p><p class="source-code">    exit(1);</p><p class="source-code">}</p></li>
				<li>Run the script with <strong class="source-inline">php run.php</strong> and then <strong class="source-inline">php run.php unknownFnName</strong>; expect the following output:<div class="IMG---Figure" id="_idContainer245"><img alt="Figure 8.27: Output of the commands&#13;&#10;" src="image/C14196_08_27.jpg"/></div><p class="figure-caption">Figure 8.27: Output of the commands</p><p>We got the expected output – the <strong class="source-inline">handle()</strong> function threw <strong class="source-inline">Disposable</strong> exceptions in both cases and, therefore, the function output was not printed.</p></li>
				<li>Run the script using the following command:<p class="source-code">php run.php substr 'PHP Essentials' 0 3; </p><p>The output will be the following:</p><div class="IMG---Figure" id="_idContainer246"><img alt="Figure 8.28: Printing a substring&#13;&#10;" src="image/C14196_08_28.jpg"/></div><p class="figure-caption">Figure 8.28: Printing a substring</p><p>In this case, <strong class="source-inline">substr</strong> is a valid function name and is therefore called, with three arguments being passed. <strong class="source-inline">substr</strong> is performing extraction from a string value (first parameter), starting a specific position (the second parameter – <strong class="source-inline">0</strong> in our case), and returns the desired length (the third parameter – <strong class="source-inline">3</strong> in our case). Since no exception was thrown, the output was printed on the screen.</p></li>
				<li>Run the script using the following command:<p class="source-code">php run.php substr 'PHP Essentials' 0 0; </p><p>The output will be the following:</p><div class="IMG---Figure" id="_idContainer247"><img alt="Figure 8.29: No string printed to the console&#13;&#10;" src="image/C14196_08_29.jpg"/></div><p class="figure-caption">Figure 8.29: No string printed to the console</p><p>Since we got an empty string, in this case, the output is printed with <strong class="source-inline">var_export()</strong>.</p></li>
				<li>Run the script using the following command:<p class="source-code">php run.php substr 'PHP Essentials';</p><p>The output will be as follows:</p><div class="IMG---Figure" id="_idContainer248"><img alt="Figure 8.30: Printing the warning message&#13;&#10;" src="image/C14196_08_30.jpg"/></div><p class="figure-caption">Figure 8.30: Printing the warning message</p><p>In this case, an <strong class="source-inline">E_WARNING</strong> message was reported, since the <strong class="source-inline">substr()</strong> function requires at least two parameters. Since this was not a fatal error, execution of the script continued, and <strong class="source-inline">NULL</strong> was returned. The output was again printed with the same <strong class="source-inline">var_export()</strong> function.</p></li>
				<li>Run the script using the following command:<p class="source-code">php run.php DateTime; </p><p>The output will be as follows:</p><div class="IMG---Figure" id="_idContainer249"><img alt="Figure 8.31: Printing the time details&#13;&#10;" src="image/C14196_08_31.jpg"/></div><p class="figure-caption">Figure 8.31: Printing the time details</p></li>
				<li>Run the script using the following command:<p class="source-code">php run.php DateTime '1 day ago' UTC; </p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer250">
					<img alt="Figure 8.32: Fatal error&#13;&#10;" src="image/C14196_08_32.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.32: Fatal error</p>
			<p>As you can see, we are now dealing with a fatal <strong class="source-inline">TypeError</strong> exception. This exception was not caught and was handled by the exception handler; therefore, the script was halted.</p>
			<p>Since this is a generic multi-purpose script, it is very difficult to handle all kinds of errors, validating specific inputs for each <strong class="source-inline">callee</strong>, be it a function name or a class name – in our case, you would write input validation rules for each function or class that is expected to be called. One thing to learn here is that being as precise as possible is a good approach to programming, since this gives you, the developer, control over your application.</p>
			<h2 id="_idParaDest-324"><a id="_idTextAnchor333"/>Exercise 8.10: Better Usage of Exceptions</h2>
			<p>In this exercise, we'll try a better approach to <strong class="source-inline">DateTime</strong> instantiation, compared with the previous example, for the purpose of showing how being precise gives you better control over your script. This approach is supposed to parse the input data and prepare the <strong class="source-inline">DateTime</strong> class arguments while respecting the accepted data types for each:</p>
			<ol>
				<li value="1">Create the <strong class="source-inline">date.php</strong> file, require the error handlers, and define the custom exception called <strong class="source-inline">Disposable</strong>:<p class="source-code">&lt;?php</p><p class="source-code">require_once 'all-errors-handler.php';</p><p class="source-code">class Disposable extends Exception</p><p class="source-code">{</p><p class="source-code">}</p></li>
				<li>Next, we define the <strong class="source-inline">handle()</strong> function, which will handle the request processing. First, it will check for the class name argument in <strong class="source-inline">$input[1]</strong>, with a <strong class="source-inline">Disposable</strong> exception being thrown if no such value is found:<p class="source-code">function handle(array $input)</p><p class="source-code">{</p><p class="source-code">    if (!isset($input[1])) {</p><p class="source-code">        throw new Disposable('A class name is required as the first           argument (one of DateTime or DateTimeImmutable).');</p><p class="source-code">    }</p></li>
				<li>Otherwise, the value is validated, with the requirement that only one of <strong class="source-inline">DateTime</strong> or <strong class="source-inline">DateTimeImmutable</strong> is allowed; a <strong class="source-inline">Disposable</strong> exception is thrown if another name is passed: <p class="source-code">    $calleeName = $input[1];</p><p class="source-code">    if (!in_array($calleeName, [DateTime::class,       DateTimeImmutable::class])) {</p><p class="source-code">        throw new Disposable('One of DateTime or DateTimeImmutable is           expected.');</p><p class="source-code">    }</p></li>
				<li>The desired time is stored in the <strong class="source-inline">$time</strong> variable, with the default value of <strong class="source-inline">now</strong> if no argument was set. The time zone is stored in the <strong class="source-inline">$timezone</strong> variable, with the default of <strong class="source-inline">UTC</strong> if no time zone argument was set: <p class="source-code">    $time = $input[2] ?? 'now';</p><p class="source-code">    $timezone = $input[3] ?? 'UTC';</p></li>
				<li>Next, the <strong class="source-inline">try</strong>-<strong class="source-inline">catch</strong> blocks are used when trying to instantiate <strong class="source-inline">DateTimeZone</strong> and the <strong class="source-inline">$calleeName</strong> objects. All <strong class="source-inline">Exception</strong> errors are caught, and a friendly message is thrown with the <strong class="source-inline">Disposable</strong> exception class instead:<p class="source-code">    try {</p><p class="source-code">        $dateTimeZone = new DateTimeZone($timezone);</p><p class="source-code">    } catch (Exception $e) {</p><p class="source-code">        throw new Disposable(sprintf('Unknown/Bad timezone: [%s]',           $timezone));</p><p class="source-code">    }</p><p class="source-code">    try {</p><p class="source-code">        $dateTime = new $calleeName($time, $dateTimeZone);</p><p class="source-code">    } catch (Exception $e) {</p><p class="source-code">        throw new Disposable(sprintf('Cannot build date from [%s]',           $time));</p><p class="source-code">    }</p></li>
				<li>Finally, if everything goes well, the <strong class="source-inline">$dateTime</strong> instance is returned:<p class="source-code">    return $dateTime;</p><p class="source-code">}</p></li>
				<li>The final part of the script is a try-catch block, as in the previous exercise, where <strong class="source-inline">handle()</strong> is run with the script input arguments, the output of which is stored in the <strong class="source-inline">$output</strong> variable, which is then printed onscreen using the <strong class="source-inline">print_r()</strong> function:<p class="source-code">try {</p><p class="source-code">    $output = handle($argv);</p><p class="source-code">    echo 'Result: ', print_r($output, true);</p></li>
				<li>If the <strong class="source-inline">handle()</strong> function throws a <strong class="source-inline">Disposable</strong> exception, this is caught and the error message is printed onscreen before the process is halted with exit code 1. Any other exception will be handled by the exception handler registered in <strong class="source-inline">all-errors-handler.php</strong>:<p class="source-code">} catch (Disposable $e) {</p><p class="source-code">    echo '(!) ', $e-&gt;getMessage(), PHP_EOL;</p><p class="source-code">    exit(1);</p><p class="source-code">}</p></li>
				<li>Run the script with <strong class="source-inline">php date.php</strong> and then with <strong class="source-inline">php date.php Date</strong>; the expected output is as follows:<div class="IMG---Figure" id="_idContainer251"><img alt="Figure 8.33: Printing the error messages for Disposable exceptions&#13;&#10;" src="image/C14196_08_33.jpg"/></div><p class="figure-caption">Figure 8.33: Printing the error messages for Disposable exceptions</p><p>As expected, the <strong class="source-inline">Disposable</strong> exceptions were caught, and the error messages were displayed onscreen. Since no exceptions were thrown, no output result is printed.</p></li>
				<li>Run the script using the following command: <p class="source-code">php date.php DateTimeImmutable midnight; </p><p>The output is as follows:</p><div class="IMG---Figure" id="_idContainer252"><img alt="Figure 8.34: Printing the time details&#13;&#10;" src="image/C14196_08_34.jpg"/></div><p class="figure-caption">Figure 8.34: Printing the time details</p><p>Now, the script printed the <strong class="source-inline">DateTimeImmutable</strong> object, which has today's date and the time set to midnight, while the default UTC is used for the time zone.</p></li>
				<li>Run the script with <strong class="source-inline">php date.php DateTimeImmutable summer</strong> and then with <strong class="source-inline">php date.php DateTimeImmutable yesterday Paris</strong>; see the output, which should look like this:<div class="IMG---Figure" id="_idContainer253"><img alt="Figure 8.35: Exceptions caught inside the functions&#13;&#10;" src="image/C14196_08_35.jpg"/></div><p class="figure-caption">Figure 8.35: Exceptions caught inside the functions</p><p>As you can see, these are the <strong class="source-inline">Exception</strong> class exceptions caught inside the <strong class="source-inline">handle()</strong> function, and then thrown as <strong class="source-inline">Disposable</strong> exceptions (to be caught in the upper level) with custom messages.</p></li>
				<li>Finally, run the program using the following command:<p class="source-code">php date.php DateTimeImmutable yesterday Europe/Paris </p><p>You should get something like this:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer254">
					<img alt="Figure 8.36: Printing Europe/Paris date time details&#13;&#10;" src="image/C14196_08_36.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.36: Printing Europe/Paris date time details</p>
			<p>This would be yesterday's date, midnight in the Europe/Paris time zone. In this case, the script has executed without exceptions; the second argument for <strong class="source-inline">DateTimeImmutable</strong> was a <strong class="source-inline">DateTimeZone</strong> object with the <strong class="source-inline">Europe/Paris</strong> time zone setting, and therefore the result was printed as expected.</p>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor334"/>Activity 8.1: Handling System and User-Level Errors </h2>
			<p>Let's say you have been asked to develop a script that would calculate the factorial number of the given input, with the following specifications:</p>
			<ul>
				<li>At least one input argument is required.</li>
				<li>The input arguments should be validated as positive integers (higher than zero).</li>
				<li>For each input provided, the script should calculate the factorial number; the result is printed line by line for each input argument.</li>
			</ul>
			<p>You should validate the inputs according to the specifications and handle any error (thrown exceptions). No exception should halt the execution of the script, the difference being that the expected exceptions are printed to the user output, while for unexpected exceptions, a generic error message is printed, and the exception is logged to a log file.</p>
			<p>Perform the following steps:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">factorial.php</strong>, which will run the script.</li>
				<li>Create the exception handler, which will log the formatted log message to a file; the message format is the same as in the exception handler of the <strong class="source-inline">all-errors-handler.php</strong> file.</li>
				<li>Create the error handler to deal with the system errors reported; this will forward the errors to the exception handler (translating the errors to exceptions).</li>
				<li>Register both the exception and the error handlers.</li>
				<li>Create the custom exceptions, one for each validation rule.</li>
				<li>Create the function that validates and calculates a single number input (for example, <strong class="source-inline">calculateFactorial()</strong>).</li>
				<li>Create a function that will print the error message in a specific format. It will prepend <strong class="source-inline">(!)</strong> to each message and will include a new line feed.</li>
				<li>If no input arguments are provided, display a message that highlights the requirement of at least one input number.</li>
				<li>Iterate through the input arguments and invoke the <strong class="source-inline">calculateFactorial()</strong> function providing the <strong class="source-inline">input</strong> argument. The result will be printed using the format: <strong class="source-inline">3! = 6</strong> (where <strong class="source-inline">3</strong> is the input number, and <strong class="source-inline">6</strong> is the result of <strong class="source-inline">calculateFactorial()</strong>).</li>
				<li>Catch any (expected) custom exception that might be thrown by the <strong class="source-inline">calculateFactorial()</strong> function and print the exception message.</li>
				<li>Catch any unexpected exception, other than the custom exceptions defined previously, and invoke the exception handler to have them logged in the log file. Also, display a generic error message to the user output (for example, an unexpected error occurred for input number N, where N is the input number provided in the <strong class="source-inline">calculateFactorial()</strong> function).</li>
			</ol>
			<p>The output should be similar to the following:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer255">
					<img alt="Figure 8.37: Printing factorials of integers&#13;&#10;" src="image/C14196_08_37.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.37: Printing factorials of integers</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 552.</p>
			<h1 id="_idParaDest-326"><a id="_idTextAnchor335"/>Summary</h1>
			<p>In this chapter, you learned how to deal with PHP errors and how to work with exceptions. Now, you also understand the difference between traditional errors and exceptions and their use cases. You learned how to set error and exception handlers. Now, you understand the different error levels in PHP, and why some will curtail the execution of the script, while most of them will allow the script to execute further. Also, to avoid code duplication, you learned how to translate traditional errors to exceptions and forward them to the exception handler.</p>
			<p>Finally, my advice to you is to consider setting up a logging server (some free solutions are available for download and use), where you can send all the logs, so that, when you access the logging platform, you can filter the entries (for example, by severity/log level or by a search term), create data visualizations with various aggregations (for example, counts of warnings in the last 12 hours at 30-minute intervals), and more. This will help you to identify certain error level messages much more quickly than browsing through a log file. </p>
			<p>The logging server is particularly useful when the application is deployed on at least two instances, due to the centralization of logs, which allows you not only to spot a problem very quickly, but you will also be able to see the instance that caused it and potentially more context information. In addition, a log management solution can be used for multiple applications.</p>
			<p>In fact, for the latter, you can check out titles including <em class="italic">Learning ELK Stack</em>; video courses including the ElasticSearch, LogStash, and Kibana ELK series; and many others on the <em class="italic">Packt Publishing</em> platform.</p>
			<p>While logging into a filesystem is perfectly acceptable, especially while developing, at some point, while developing your application, the production setup will require a centralized logging solution, be it HTTP access/error logs, application logs, or others (especially in a distributed architecture/microservices). You want to be productive and code or fix bugs, rather than lose yourself between files and lines of logs stored in a filesystem.</p>
			<p>In the next chapter, we will define the composer and manage libraries using Composer.</p>
		</div>
	</body></html>