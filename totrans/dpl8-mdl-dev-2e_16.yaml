- en: Working with Files and Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件和图像
- en: Drupal comes with many capabilities for handling and manipulating files and
    images and has been adding to its toolset more and more with recent versions.
    Of course, this is not to say that media management has not been always a pain
    point for Drupal developers. In Drupal 7, a complicated suite of contributed modules
    was needed to achieve a basic level of functionality, something that users of
    "competitors" like WordPress enjoy out of the box. In Drupal 8, there is more
    emphasis placed on media management, and with each release Media capabilities
    have gone into core. The Media (entity) module, with its essential source plugins
    for supporting Images, Files, Remote Videos (Oembed) and Audio, as well as the
    experimental Media library, make for great advancements in the area. And together
    with popular contributed modules such as Entity Browser, a lot of this gap has
    been filled.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 内置了许多处理和操作文件和图像的能力，并且随着最近版本的更新，其工具集也在不断增加。当然，这并不是说媒体管理从未是 Drupal 开发者的痛点。在
    Drupal 7 中，需要一套复杂的贡献模块来实现基本的功能，而像 WordPress 这样的“竞争对手”用户可以开箱即用享受这些功能。在 Drupal 8
    中，对媒体管理的重视程度更高，并且随着每个版本的发布，媒体功能已经集成到核心中。媒体（实体）模块，包括其支持图像、文件、远程视频（Oembed）和音频的基本源插件，以及实验性的媒体库，在该领域取得了重大进步。此外，与流行的贡献模块如实体浏览器一起，许多差距已经得到填补。
- en: In this chapter, we will look at how we can work with files and images in Drupal,
    supported by the core features. Although the Media module allows developers to
    provide new Source plugins to expose media entities to all sorts of types of media,
    we won't be going into this quite advanced topic. Instead, we'll focus on lower-level
    tools that can be used for working with files. And we will see some examples along
    the way. So, what are we going to discuss?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何在 Drupal 中使用核心功能处理文件和图像。尽管媒体模块允许开发者提供新的源插件来将媒体实体暴露给各种类型的媒体，但我们不会深入探讨这个相当高级的话题。相反，我们将专注于可以用于处理文件的底层工具，并在过程中展示一些示例。那么，我们将讨论什么呢？
- en: First, we are going to get an understanding of the Drupal *filesystems*. Developers
    from previous versions of Drupal should already be familiar with these in theory,
    and we will see how these work in Drupal 8\. Related to this, we're going to talk
    about *stream wrappers* and how Drupal handles native PHP file operations. We
    will even create our own custom stream wrapper a bit later in the chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将了解 Drupal 的*文件系统*。来自先前版本的 Drupal 的开发者应该已经在理论上熟悉这些，我们将看到这些在 Drupal 8 中的工作方式。与此相关，我们将讨论*流包装器*以及
    Drupal 如何处理原生 PHP 文件操作。我们甚至将在本章稍后创建我们自己的自定义流包装器。
- en: Then, we will talk a bit about the different ways to handle files in Drupal,
    namely, *managed* (tracked) and *unmanaged* files. In exemplifying the work with
    *managed* files, we will add an image field to our Product entity type and have
    images imported from a fictional remote environment. We will also create a brand-new
    CSV-based importer by which the product data is imported from a CSV file we read.
    In this process, we will note the Entity CRUD hooks, a very important extension
    point in Drupal 8, and see how we can use those in our example context.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将简要讨论在 Drupal 中处理文件的不同方式，即*管理*（跟踪）和*非管理*文件。在举例说明如何处理*管理*文件时，我们将向我们的产品实体类型添加一个图像字段，并将图像从虚构的远程环境中导入。我们还将创建一个全新的基于
    CSV 的导入器，通过该导入器从我们读取的 CSV 文件中导入产品数据。在这个过程中，我们将注意实体 CRUD 钩子，这是 Drupal 8 中非常重要的扩展点，并看看我们如何在示例上下文中使用它们。
- en: We will end the chapter by seeing how we can work with various APIs that deal
    specifically with images, especially for manipulating them via image toolkits
    and working with image styles. So let's get to it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章的结尾放在如何使用专门处理图像的各种 API 上，特别是通过图像工具包进行图像操作以及处理图像样式。让我们开始吧。
- en: The filesystem
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统
- en: 'Drupal defines four main types of file storage for any given site: the *public*,
    the *private,* the *temporary* and the *translation* filesystems. When installing
    Drupal, the folders that map to these filesystems are created automatically. In
    case that fails—most likely due to permission issues—we have to create them ourselves
    and give them the correct permissions. Drupal takes care of the rest (for example,
    adds relevant `.htaccess` files for security reasons). Make sure you check out
    the documentation on [Drupal.org](https://www.drupal.org/) for how to successfully
    install Drupal 8 if you are unsure how this works.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Public files are available to the world at large for viewing or downloading.
    This is where things such as image content, logos, and anything that can be downloaded
    are stored. Your public file directory must exist somewhere under Drupal's root,
    and it must be readable and writeable by whatever *user* your web server is running
    under. Public files have no access restrictions. Anyone, at any time, can navigate
    directly to a public file and view or download it. This also means that accessing
    these files does not require Drupal to bootstrap.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'We can configure the path to the public filesystem in our `settings.php` file:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Private files, on the other hand, are not available to the world for general
    download. Therefore, the private files' directory must not be accessible via the
    web. However, it still has to be writeable by the web server user. Isolating private
    files this way allows developers to control who can and can't access them. For
    instance, we could write a module that only allows users who have a specific role
    to access PDFs in the private filesystem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'We can configure the path to the private filesystem in our `settings.php` file:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Temporary file storage is typically only used by Drupal for internal operations.
    When files are first saved by Drupal, they are initially written into the temporary
    filesystem so they can be checked for security issues. After they have been deemed
    safe, they are written to their final location.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'We can configure the path to the temporary filesystem through the UI:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b23acfd3-953c-4d02-a981-50e876c256fc.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: On the same configuration screen, we can also specify the default file download
    method for the site. By default, this is set to the public filesystem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the translation file storage is used by Drupal for storing the `.po`
    files that contain string translation values that can be imported into the system
    in bulk. As with the temporary file storage, we can configure the location of
    translation files through the UI.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Stream wrappers
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''ve been writing PHP for a long time, you may have needed to work with
    local or remote files at some point. The following PHP code is a common way to
    read a file into a variable that you can do something with:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is pretty straightforward. We get a handle to a local file using `fopen()`
    and read 8 KB chunks of the file using `fread()` until `feof()` indicates that
    we've reached the end of the file. At that point, we use `fclose()` to close the
    handle. The contents of the file are now in the `$contents` variable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: In addition to local files, we can also access remote ones through `fopen()`
    in the exact same way but by specifying the actual remote path instead of the
    local one we saw before (starting with `http(s)://`).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Data that we can access this way is streamable, meaning we can open it, close
    it, or seek to a specific place in it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '*Stream wrappers* are an abstraction layer on top of these streams that tell
    PHP how to handle specific types of data. When using a stream wrapper, we refer
    to the file just like a traditional URL—`scheme://target`. As a matter of fact,
    the previous example uses one of PHP''s built-in stream wrappers: the `file://`
    wrapper for accessing files on local storage. It is actually the default scheme
    when none is specified, so that is why we got away with omitting it and just adding
    the file path. Had the file been on a remote location, we would have used something
    like `http://example.com/file/path/image.jpg`. That is another PHP built-in stream
    wrapper: `http://` (for the HTTP protocol).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: If that's not enough, PHP also allows us to define our own wrappers for schemes
    that PHP does not handle out of the box; the Drupal File API was built to take
    advantage of this. This is where we link back to the different types of file storage
    we talked about earlier, as they all have their own stream wrappers defined by
    Drupal.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The public filesystem uses the rather known `public://` stream wrapper, the
    private one uses `private://`, the temporary one `temporary://` and the translation
    one `translations://`. These map to the local file paths that we defined in the
    `settings.php` (or UI). Later in the chapter we will see how we can define our
    own stream wrapper and what some of the things that go into it are. First, though,
    let's talk a bit about the different ways we can manage files in Drupal 8.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Managed versus unmanaged files
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Drupal File API allows us to handle files in two different ways. Files
    essentially boil down to two categories: they are either *managed* or *unmanaged*.
    The difference between the two lies in the way the files are used.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '*Managed* files work hand in hand with the Entity system and are, in fact,
    tied to File entities. So whenever we create a *managed* file, an entity gets
    created for it as well, which we can use in all sorts of ways. And the table where
    these records are stored is called `file_managed`. Moreover, a key aspect of *managed*
    files is the fact that their usage is tracked. This means that if we reference
    them on an entity or even manually indicate that we use them, this usage is tracked
    in a secondary table called `file_usage`. This way, we can see where each file
    is used and how many times, and Drupal even provides a way to delete "orphaned"
    files after a specific time in case they are no longer needed.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*管理*文件与实体系统紧密协作，实际上是与文件实体相关联。因此，每当我们创建一个*管理*文件时，都会为其创建一个实体，我们可以以各种方式使用它。这些记录存储的表称为`file_managed`。此外，*管理*文件的一个关键方面是它们的用法是可跟踪的。这意味着如果我们在一个实体上引用它们或甚至手动指示我们使用它们，这种使用情况将在名为`file_usage`的辅助表中跟踪。这样，我们可以看到每个文件在哪里被使用以及使用次数，Drupal甚至提供了一个在特定时间后删除“孤儿”文件的方法，以防它们不再需要。'
- en: A notable example of using *managed* files is the simple `Image` field type
    that we can add to an entity type. Using these fields, we can upload a file and
    *attach* it to the respective entity. This attachment is nothing more than a special
    (tracked) entity reference between the two entities.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*管理*文件的一个显著例子是我们可以添加到实体类型的简单`Image`字段类型。使用这些字段，我们可以上传一个文件并将其*附加*到相应的实体。这种附件仅仅是两个实体之间的一种特殊（跟踪）实体引用。
- en: By understanding how *managed* files are used, it's not difficult to anticipate
    what *unmanaged* files are. The latter are the files we upload to make use of
    for various reasons but that, of course, do not need to be *attached* to any entity
    or have their usage tracked.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解*管理*文件的使用方式，预测*非管理*文件并不困难。后者是我们出于各种原因上传的文件，但当然不需要将其*附加*到任何实体或跟踪其使用情况。
- en: Using the File and Image fields
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文件和图像字段
- en: In order to demonstrate how to work with *managed* files, we will go back to
    our product entity importer and bring in some images for each product. However,
    in order to store them, we need to create a field on the Product entity. This
    will be an *image* field.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何与*管理*文件一起工作，我们将回到我们的产品实体导入器，并为每个产品引入一些图像。然而，为了存储它们，我们需要在产品实体上创建一个字段。这将是一个*图像*字段。
- en: 'Instead of creating this field through the UI and attaching it to a bundle,
    let''s do it the programmatic way and make it a base field (available on all bundles).
    We won''t need to do anything complex; for now we are only interested in a basic
    field that we can use to store the images we bring in from the remote API. It
    can look something like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不通过UI创建此字段并将其附加到包中，而是以编程方式完成，使其成为一个基础字段（在所有包上可用）。我们现在不需要做任何复杂的事情；目前我们只对可以用来存储从远程API引入的图像的基本字段感兴趣。它可以看起来像这样：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you remember from [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml),
    *Data Modeling and Storage*, and [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml),
    *Your Own Custom Entity and Plugin Types*, we are creating a base field definition
    that, in this case, is of the type `image`. This is the `FieldType` plugin ID
    of the `ImageItem` field type. So that is where we need to look and see what kind
    of field and storage options we may have. For example, we can have a file extension
    limitation (which by default contains `png`, `gif`, `jpg`, and `jpeg`) and things
    like `alt` and `title` attributes, as well as image dimension configuration. Do
    check out `ImageItem` to get an idea of the possible storage and field settings.
    However, we are fine with the defaults in this case so we don't even have any
    field settings.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得[第6章](77cab458-5612-468c-8010-12385708eb81.xhtml)“数据建模与存储”和[第7章](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml)“自定义实体和插件类型”，我们正在创建一个基础字段定义，在这种情况下，它是`image`类型。这是`ImageItem`字段类型的`FieldType`插件ID。因此，我们需要查看并了解可能有哪些字段和存储选项。例如，我们可以设置文件扩展名限制（默认包含`png`、`gif`、`jpg`和`jpeg`）以及`alt`和`title`属性，以及图像尺寸配置。请检查`ImageItem`以了解可能的存储和字段设置。然而，在这种情况下，我们使用默认设置，因此甚至没有任何字段设置。
- en: Another interesting thing to notice is that `ImageItem` extends the `FileItem`
    field type, which is a standalone `FieldType` plugin that we can use. However,
    it is more generic and lends itself for use with any kind of file upload situation.
    Since we are dealing with images, we might as well take advantage of the specific
    field type.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的有趣之处是`ImageItem`扩展了`FileItem`字段类型，这是一个独立的`FieldType`插件，我们可以使用。然而，它更通用，适用于任何类型的文件上传情况。由于我们处理的是图像，我们不妨利用特定的字段类型。
- en: For the moment, we do not configure our image field to have any kind of display.
    We'll look into that a bit later. However, we do specify the widget it should
    use on the entity form, namely the `FieldWidget` plugin with the ID of `image_image`.
    This maps to the default `ImageWidget` field widget. But again, we are fine with
    the setting defaults, so we don't specify anything extra.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们不需要配置我们的图像字段以显示任何类型。我们稍后再来看这个问题。然而，我们确实指定了在实体表单上它应该使用的部件，即ID为`image_image`的`FieldWidget`插件。这映射到默认的`ImageWidget`字段部件。但同样，我们对默认设置感到满意，所以没有指定任何额外的内容。
- en: 'With this, our field definition is done. To have Drupal create the necessary
    database tables, we need to run the Drush command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们的字段定义就完成了。为了让Drupal创建必要的数据库表，我们需要运行Drush命令：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now let''s create the interface methods for easily accessing and setting the
    images:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建接口方法，以便轻松访问和设置图像：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The getter method is supposed to return a `FileInterface` object (which is
    the actual File entity), while the setter is supposed to receive the ID (`fid`)
    of the File entity to save. As for the implementations, it should not be anything
    new to us:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 获取方法应该返回一个`FileInterface`对象（这是实际的文件实体），而设置方法应该接收要保存的文件实体的ID（`fid`）。至于实现，对我们来说不应该有任何新内容：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this, we are ready to proceed with the import of images from the remote
    API.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就准备好从远程API导入图像了。
- en: For taking advantage of the media management power in Drupal 8, instead of Image
    or File fields, you'd create entity reference fields to Media entities. And on
    the latter you'd create these fields. As such, Media entities basically wrap the
    File entities to provide some additional functionality and expose them to all
    the goodies of media management. For now, we work directly with these field types
    to learn about low-level file handling without the overhead of Media.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用Drupal 8中的媒体管理功能，而不是使用图像或文件字段，我们会创建指向媒体实体的实体引用字段。在后者上创建这些字段。因此，媒体实体基本上封装了文件实体，以提供一些额外的功能，并将它们暴露给所有媒体管理的优点。目前，我们直接与这些字段类型一起工作，以了解低级文件处理，而不需要媒体的开销。
- en: Working with managed files
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与管理文件一起工作
- en: In this section, we will look at two examples of working with managed files.
    First, we will see how we can import product images from our fictional remote
    JSON-based API. Second, we will see how to create a custom form element that allows
    us to upload a file and use it in a brand new CSV-based importer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看两个与管理工作文件一起工作的示例。首先，我们将看到如何从我们的虚构远程基于JSON的API导入产品图像。其次，我们将看到如何创建一个自定义表单元素，允许我们上传文件并在全新的基于CSV的导入器中使用它。
- en: Attaching managed files to entities
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将管理文件附加到实体
- en: 'Now that we have our product image field in place and we can store images,
    let''s revisit our JSON response that contains the product data and assume it
    looks something like this now:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了产品图像字段并且可以存储图像，让我们重新审视包含产品数据的JSON响应，并假设它现在看起来像这样：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What's new is the addition of the `image` key for each product, which simply
    references a filename for the image that goes with the respective product. The
    actual location of the images is at some other path we need to include in the
    code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 新增的是为每个产品添加了`image`键，它简单地引用了与相应产品一起的图像文件名。图像的实际位置在代码中需要包含的其他路径上。
- en: 'Going back to our `JsonImporter::persistProduct()` method, let''s delegate
    the handling of the image import to a helper method called `handleProductImage()`.
    We need to call this method both if we are creating a new Product entity and if
    we are updating an existing one (right before saving):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`JsonImporter::persistProduct()`方法，让我们将图像导入的处理委托给一个名为`handleProductImage()`的辅助方法。如果我们正在创建一个新的产品实体或者更新一个现有的实体（在保存之前），我们都需要调用这个方法：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And this is what the actual method looks like:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的方法看起来是这样的：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And the new *use* statement at the top:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以及顶部的新`use`语句：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we get the name of the image. Then we construct the path to where the
    product images are stored. In this example, it's left blank, but if the example
    were to work, we'd have to add a real path there. I leave that up to you for now.
    If you want to test it out, create a local folder with some images and reference
    that.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the native `file_get_contents()` function, we load the data of the image
    from the remote environment into a string. We then pass this string to the `file_save_data()` function
    which saves a new *managed* file to the public filesystem. This function takes
    three parameters: the data to be saved, the URI of the destination, and a flag
    indicating what to do if a file with the same name already exists. You''ll notice
    that we used the Drupal `public://` stream wrapper to build the URI and we already
    know which folder this maps to.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: As for the third parameter, we chose to replace the file in case one already
    exists. The alternative would have been to either use the `EXISTS_RENAME` or `EXISTS_ERROR`
    constants of the same interface. The first would have created a new file whose
    name would have gotten a number appended until the name became unique. The second
    would have simply not done anything and returned FALSE.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: If all goes well, this function returns a `File` entity (that implements `FileInterface`)
    whose ID we can use in the Product image setter method. With that in place, we
    can synchronize also the individual product images.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: If you run into issues after this, make sure you create the destination folder
    and have all the permissions in order in the public filesystem to allow the copy
    to take place properly. In the next section you'll learn about some helper functions
    you can use to better prepare with the destination folder.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, in our database, a record is created in the `file_usage` table to
    indicate that this file is being used on the respective Product entity.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Helpful functions for dealing with managed files
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from the staple `file_save_data()` function, we have a few other ones
    that can come in handy if we are dealing with *managed* files. Here's a few of
    them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to copy a file from one place to another while making sure a new
    database record is created, we can use `file_copy()`. It takes three parameters:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The `FileInterface` entity that needs to be copied
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The destination URI where it should go
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flag indicating what to do in case a file with the same name exists
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameters are the same as for `file_save_data()`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the actual copying, this function also invokes `hook_file_copy()`
    which allows modules to respond to files being copied.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Very similar to `file_copy()`, we also have `file_move()` which takes the same
    set of parameters but instead performs a file move. The database entry of the
    File entity gets updated to reflect the new file path. And `hook_file_move()`
    is invoked to allow modules to respond to this action.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Not strictly related to *managed* files, but rather useful in all cases, we
    also have the `\Drupal\Core\File\FileSystem` service (accessible via the `file_system`
    service name), which contains all sorts of useful methods for dealing with files.
    We''ll see some of them when we talk about *unmanaged* files. But one that is
    useful also for *managed* files is `::prepareDirectory()` which we can use to
    ensure the file destination is correct. It takes two arguments: the directory
    (a string representation of the path or stream URI) and a flag indicating what
    to do about the folder (constants on the interface):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '`FileSystemInterface::CREATE_DIRECTORY` : Will create the directory if it doesn''t
    already exist'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileSystemInterface::MODIFY_PERMISSION` : Will make the directory writable
    if it is found to be read-only'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function returns `TRUE` if the folder is good to go as a destination or
    `FALSE` if something went wrong or the folder doesn't exist.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Managed file uploads
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we are going to look at how we can work with *managed* files using a
    custom form element. And to demonstrate this, we are finally going to create another
    Product importer plugin. This time, instead of a remote JSON resource, we will
    allow users to upload a CSV file that contains product data and imports that into
    Product entities. This is what the example CSV data looks like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It basically has the same kind of data as the JSON resource we've been looking
    at so far but without the image reference. So let's get going with our new plugin
    class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our starting point:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We start by extending from the `ImporterBase` class and implement the obligatory
    `import()` method. Like before, we delegate to `getData()` to retrieve the product
    information, but in this case we simply loop over the resulting records and use
    the `persistProduct()` method to save the Product entities. So no batch operations.
    Apart from no longer saving images, this latter method looks exactly like the
    one from the `JsonImporter`, so I won't be copying it over again. But it makes
    for a good homework assignment to try to move it to the base class and abstract
    away the dynamic portions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Managed file form element
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The other obligatory method we need to implement is `getConfigurationForm()`,
    by which we define the form elements needed to configure this particular plugin.
    Here, we will create the `file` field allowing users to upload the CSV file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The form element type is called `managed_file` (implemented by the `ManagedFile`
    form element class). The rest of the definition is straightforward. However, there
    are a couple of problems.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'First, by default, using this form element, files are uploaded to the `temporary://`
    filesystem of Drupal. Since we don''t want that, we need to specify an upload
    location:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The root of our public files folder will suffice for this example as we assume
    the file does not contain any sensitive information. If so, we could upload it
    to the `private://` one and control who gets access. We'll talk about how that
    works later in the chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, by default, using this form element, the *allowed* file extensions
    for upload are limited to `jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp`.
    So if we want to allow CSV files, we need to specify the extension in a list of
    allowed upload extensions. And we do this by overriding the default upload validators:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is an array of validator callbacks we want Drupal to run when the file
    is uploaded. And allowing only CSV files is enough for our purposes. But another
    handy validator we could use is `file_validate_size()`. Moreover, we can implement
    `hook_file_validate()` ourselves and perform any custom validation to the files
    being uploaded. So that's also something to keep in mind when dealing with validation
    files that don't belong to your modules.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, our plugin configuration form is in place; it looks something like
    this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0495cf38-f200-4e96-8fd7-f8a98bc4c7b0.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: However, there is still something we need to do in order for the uploaded file
    to be *managed* properly. When using this form element, the file gets correctly
    uploaded and a record is added to the `file_managed` table. So we get our `File`
    entity. However, its status is not permanent because it doesn't have any usages.
    There are no records for it in the `file_usage` table. How could there be? So
    what we need to do is handle that ourselves and basically tell Drupal that the
    file uploaded in this form is *used* by the respective Importer configuration
    entity. And to do this, we need to know when the file is saved onto the entity,
    changed, and deleted.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we can also learn about something very important that we skipped
    in [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml), *Data Modeling and
    Storage*, and [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml), *Your Own
    Custom Entity and Plugin Types:* entity CRUD hooks. But right before we jump into
    that, let''s not forget about the configuration schema of this new configuration
    item—the `file` key of the plugin configuration:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are doing the same as we did for the `url` key of the JSON importer but,
    in this case, we need to account for the fact that `file` is actually an array.
    So we define it as a sequence whose individual items are integers. Feel free to
    check [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml), *Data Modeling
    and Storage*, for more information on configuration schemas whenever you need
    a reminder.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Entity CRUD hooks
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever entities are created, updated, or deleted, a set of hooks are fired
    that allow us to act on this information. We can use these hooks simply to perform
    some actions whenever this happens or even make changes to the entity being saved.
    So let's see what we have.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: A very useful one is `hook_entity_presave()`, which gets fired during the saving
    process of an entity (both content and configuration). This applies to both when
    the entity is first created, as well as when it is being updated. Moreover, it
    allows us to inspect the original entity and detect changes made to it. And finally,
    since the entity has not yet been persisted, it allows us to make changes to it
    ourselves. So very powerful stuff.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Since Drupal 8 is very flexible, we also have the `hook_ENTITY_TYPE_presave()`
    version which allows us to specifically target any entity type we want. We've
    already discussed the benefit of using more specific hooks to keep our code more
    organized as well as a little bit more performant. And this applies to all the
    entity CRUD hooks we are going to talk about next.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Then we have `hook_entity_insert()` and `hook_entity_update()`, which get fired
    after an entity is created for the first time and after an entity is updated,
    respectively. We cannot make changes to the entity itself as it has already been
    saved, but they can come in handy at other times. The latter also give us access
    to the original entity if we want to compare any changes. And similarly, we have
    `hook_entity_delete()`, which gets fired when an entity is deleted.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we also have `hook_entity_load()` which allows us to perform actions
    whenever an entity is loaded. For example, we can tack on additional information
    if we want. So keep in mind these hooks, as they are going to be a very important
    tool in your module developer arsenal.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Managed file usage service
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an idea of the available entity CRUD hooks, we can implement
    three of them to handle our *managed* file problem. Because, if you remember,
    *managed* files are actually represented by the `File` entity type, so the Entity
    CRUD hooks get fired for these as well.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: To mark a file as being used by *something,* we can use the `DatabaseFileUsageBackend`
    service (`file.usage`), which is an implementation of the `FileUsageInterface`.
    This has a few handy methods that allow us to add a usage or delete it. That is
    actually what we are going to do next.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'What we want to do first is add a file usage whenever a new Importer entity
    gets created (and a file uploaded with it):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are implementing the specific version of `hook_entity_insert()` for our
    own entity type, and the first thing we are checking is whether we are looking
    at one using the CSV plugin. We''re not interested in any importers that don''t
    have a CSV file upload. If we are, we get the File entity ID from the importer
    using a private helper function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You'll notice that the `file` key in our plugin configuration array is an array
    of File IDs, even if we only uploaded one single file. That is just something
    we need to account for here (we did so also in our configuration schema earlier
    on).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Then, we load the File entity based on this ID and use the `file.usage` service
    to add a usage to it. The first parameter of the `add()` method is the File entity
    itself, the second is the module name that marks this usage, the third is the
    type of *thing* the file is used by, while the fourth is the ID of this *thing*.
    The latter two depend on the use case; we choose to go with our own notation (`config:importer`)
    to make it clear that we are talking about a configuration entity of the type
    `importer`. Of course, we used the ID of the entity.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: With this, a new record will get created in the `file_usage` table whenever
    we save such an Importer entity for the first time. Now let's handle the case
    in which we delete this entity—we don't want this file usage lingering around,
    do we?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Most of what we are doing in this specific version of `hook_entity_delete()`
    is the same as before. However, we are using the `delete()` method of the `file.usage`
    service but passing the same arguments. These `$type` and `$id` parameters are
    actually optional, so we can "un-use" multiple files at once. Moreover, we have
    an optional fifth parameter (the count) whereby we can specifically choose to
    remove more than one usage from this file. By default, this is 1, and that makes
    sense for us.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we also want to account for the cases in which the user edits the
    importer entity and changes the CSV file. We want to make sure the old one is
    no longer marked as used for this Importer. And we can do this with `hook_entity_update()`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are using the specific variant of this hook that only gets fired for Importer
    entities. Just like we''ve been doing so far. And as I mentioned, we can access
    the original entity (before the changes have been made to it) like so:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And if the File ID that was on the original entity is not the same as the one
    we are currently saving with it (meaning the file was changed), we can delete
    the usage of that old File ID.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Processing the CSV file
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our plugin configuration works—and uploaded files are properly managed
    and marked as used—it''s time to implement the `getData()`method by which we process
    the CSV file of the Importer entity. The result needs to be an array of product
    information as expected by the `import()` method we saw earlier. So we can have
    something like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, quite expectedly, we check for the existence of the File ID in the Importer
    entity and load the corresponding File entity based on that. To do this, we use
    the entity manager we injected into the plugin base class. But then comes something
    new.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the File entity, we can ask it its URI, which will return something
    like this: `public://products.csv`. This is what is stored in the database. But
    in order to turn that into something useful, we need to use the *stream wrapper*
    that defines this filesystem. And to get that, we use the `StreamWrapperManager`
    service (`stream_wrapper_manager`) which has a handy method of returning the *stream
    wrapper* instance responsible for a given URI—`getViaUri()`. And once we have
    our `StreamWrapperInterface`, we can use its `realpath()` method to get the local
    path of the resource. We will come back to *stream wrappers* a bit later in this
    chapter and it will make more sense. But for the moment, it''s enough to understand
    that we are translating a URI in the `scheme://target` format into a useful path
    that we can use to create a new PHP-native `SplFileObject` instance, which, in
    turn, we can use to process the CSV file easily.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: When creating the `SplFileObject`, we used the external URL of the file. This
    worked just fine and we were able to also demonstrate how we can get our hands
    on the external URL if we ever need to. But, as we will see in the next chapter,
    it will also work directly with the stream URI, and we will switch to this approach
    instead.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: With three lines of code we are basically done getting all the rows from the
    CSV into the `$data` array. However, we also want to make this data look a bit
    more like what the JSON resource looked like—a map where the keys are the field
    names and the values are the respective product data. And we also want this map
    to contain PHP standard objects instead of arrays. Therefore, we loop through
    the data, establish the CSV header values, and use those as the keys in each row
    of a new `$products` array of objects. Our end result will look exactly like the
    product information coming from the decoded JSON response.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'And with this we are done. Well, not quite. We still need to inject the `StreamWrapperManager`
    service into our plugin. And to do that, we need to make sure we are injecting
    also all the things that the parent class needs and passing them along:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And the new *use* statements at the top:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Nothing we don't yet know how to do. However, there is one thing I'd like to
    point out here. In [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml), *Your
    Own Custom Entity and Plugin Types*, I mentioned how, at the time, I believed
    the Guzzle HTTP Client is a service that would be useful to all Importer plugins.
    Well, I was clearly wrong, as the CSV-based one we just created now doesn't need
    it. So there is no reason why it should be injected into it. What we need to do
    here is remove this dependency from the base plugin class and only use it in the
    JSON importer. However, I leave this up to you as homework.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Our CSV Importer plugin is now complete. If we did everything correctly, we
    can now create a new Importer entity that uses it, upload a correct CSV file,
    and import some Product entities via our Drush command. How neat.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Our own stream wrapper
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we briefly talked about stream wrappers and
    what they are used for. We saw that Drupal comes with four mainstream wrappers
    that map to the various types of file storage it needs. Now it's time to see how
    we can create our own. And the main reason why we would want to implement one
    is to expose resources at a specific location to PHP's native filesystem functions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will create a very simple stream wrapper that can basically
    only read the data from the resource. Just to keep things simple. And the data
    resource will be the product images hosted remotely (the ones we are importing
    via the JSON Importer). So there will be some rework there to use the new stream
    wrapper instead of the absolute URLs. Moreover, we will also learn how to use
    the site-wide settings service by which we can have environment-specific configurations
    set in the `settings.php` file and then read by our code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'The native way of registering a stream wrapper in PHP is by using the `stream_wrapper_register()`
    function. However, in Drupal 8, we have an abstraction layer on top of that in
    the form of services. So a stream wrapper is a simple tagged service, albeit with
    many potential methods. Let''s see its definition, which we add to the `products.services.yml`
    file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Nothing too complicated. The service is tagged with `stream_wrapper` and we
    use the `scheme` key to indicate the scheme of the wrapper. So the URIs will be
    in this format:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: One important thing to note about stream wrapper services is that we cannot
    pass dependencies to them. The reason is that they are not instantiated the normal
    way (by the container) but arbitrarily by PHP whenever some of its methods need
    to be called. So if we need to use some services, we'll have to use the static
    way of loading them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The stream wrapper service class needs to implement `StreamWrapperInterface`
    which comes with a lot of methods. There are many possible filesystem interactions
    that PHP can do and these methods need to account for them all. However, we will
    only be focusing on a few specific ones that have to do with reading data. After
    all, our resources are remote and we don't even have a clue how to make changes
    to them over there. So for the rest of the methods, we will be returning FALSE
    to indicate that the operation cannot be performed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this big class then:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first thing to look at is the constructor in which we statically load the
    `Settings` service and store it as a class property. And speaking of which, we
    also define a `$uri` property to hold the actual URI this wrapper *wraps* and
    a `$handle` property to hold a generic PHP resource handle.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The `getName()` and `getDescription()` methods are pretty straightforward and
    are used for identifying the stream wrapper, while the `getType()` method returns
    the type of stream. We'll go with the hidden type because we don't want it visible
    in the UI. It's strictly for programmatic use so that we can read our product
    images. Do check out the available types and their meanings by looking at the
    `StreamWrapperInterface` constants.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have a getter and setter for the `$uri` property by which the Drupal
    `StreamWrapperManager` can create an instance of our wrapper based on a given
    URI. The `getTarget()` method is actually not in the interface but is a helper
    to extract a clean target from the URI (the target being the second part of the
    URI that comes after `scheme://`). And we use this method in `getExternalUrl()`,
    which is quite an important method responsible for returning an absolute URL to
    the resource in question. But here we also use our `Settings` service to get the
    `product_images_path` key. If you remember in the beginning of the chapter, we
    saw that the path to the public filesystem is defined in the `settings.php` file
    like so:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That `$settings` variable is the data array that is wrapped by the `Settings`
    service. So we want to do the same for defining our own remote path to the product
    images:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This way we are not committing to Git the actual remote URL and we can also
    change it later if we want. And this is the URL we are reading inside the `getExternalUrl()`
    method.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The other pillar of our read-only stream wrapper is the ability to open a file
    handle to the resource and allow us to read the data from it. And the `stream_open()`
    method does this as it gets called when we run either `file_get_contents()` or
    `fopen()` on our URI. Using the `$mode` parameter, we ensure that the operation
    is read-only and return `FALSE` otherwise—we do not support *write* or other flags.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Any mode can have `b` appended to it to indicate that the file should be opened
    in binary mode. So, where `r` indicates read-only, `rb` indicates read-only in
    binary mode.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The third argument is a bitmask of options defined by PHP. The one we're dealing
    with here is `STREAM_REPORT_ERRORS`, which indicates whether or not PHP errors
    should be suppressed (for instance, if a file is not found). The second is `STREAM_USE_PATH`,
    which indicates whether PHP's include path should be checked if a file is not
    found. This is not relevant to us, so we ignore it. If a file is found on the
    include path, then the fourth argument, (`$opened_url)`), should be set with the
    file's real path.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: What we do then is translate the URI into the absolute URL of the external resource
    so that we can open a file handle on it. And in doing so, we make use of the `STREAM_REPORT_ERRORS`
    option to either prepend the `@` to the `fopen()` function or not (doing so suppresses
    errors). Finally, we store the reference to the resource handle and return a Boolean
    based on it to indicate whether the operation succeeded.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we also implement the `stream_read()`, `stream_eof()`, and `stream_close()`
    methods so that we can actually also stream the resources if we want to. As for
    the rest of the methods, as already mentioned, we return `FALSE`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'All we have to do now is clear the cache and make use of our stream. As long
    as we have a valid URL declared in the `settings.php` file, our stream should
    work fine. And here are the kinds of things we could do with a URI like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To get the entire file content into a string, we can do this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Or we can use the example from the beginning of the chapter and stream the
    file bit by bit:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: All these file operations, such as opening, reading, checking the end of a file
    and closing, are possible due to our `stream_*()` method implementations from
    the wrapper.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: And finally, maybe now it's also a bit clearer what we did when writing the
    CSV Importer and using the `StreamWrapperManager` to identify the stream wrapper
    responsible for a given URI, and based on that, the real path of the URI.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'To end the section on stream wrappers, let''s do some clean-up work by refactoring
    a bit our `JsonImporter::handleProductImage()` method. Our logic there involved
    hardcoding the URL to the remote API, which is really not a good idea. Instead,
    now that we have our stream wrapper, we can go ahead and use it. We can replace
    this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It's that simple. And now we can control the remote URL from outside the Git
    repository and, if it changes, we don't even have to alter our code. Granted,
    solely for this purpose, implementing a stream wrapper seems a bit excessive.
    After all, you can simply inject the `Settings` service and use the URL in the
    Importer plugin itself allowing for the same kind of flexibility. But we used
    the opportunity to learn about stream wrappers and how to create our own. And
    we even managed to find a small use case in the process.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Working with unmanaged files
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with *unmanaged* files is actually pretty similar to doing so with *managed*
    files, except that they are not tracked in the database using the File entity
    type. There is a set of helper functions similar to what we've seen for *managed*
    files that can be accessed through the `FileSystem` service I mentioned earlier.
    Let's see some examples.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'To save a new file, we do almost like we did before with *managed* files:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We load the file data from wherever and use the `saveData()` method on the service
    the same way as we did `file_save_data()`. The difference is that the file is
    going to be saved but no database record is created. So the only way to use it
    is to rely on the path it is saved at and either try to access it from the browser
    or use it for whatever purpose we need. This method returns the URI of where the
    file is now saved or `FALSE` if there was a problem with the operation. So if
    all went well with the previous example, `$path` would now be `public://tv.jpg`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: And just like with the *managed* files, we also have a few other helpful methods
    in that service, such as `move()`, `copy()`, and `delete()`. I recommend you inspect
    that service to get more details on how these work.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Private filesystem
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The private filesystem is used whenever we want to control access to the files
    being downloaded. Using the default public storage, users can get to the files
    simply by pointing to them in the browser, thereby bypassing Drupal completely.
    However, `.htaccess` rules prevent users from directly accessing any files in
    the private storage, making it necessary to create a route that delivers the requested
    file. It goes without saying that the latter is a hell of a lot less performant,
    as Drupal needs to be loaded for each file. Therefore, it's important to only
    use it when files should be restricted based on certain criteria.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Drupal already comes with a route and Controller ready to download private files,
    but we can create one as well if we really need to. For example, the image module
    does so in order to control the creation and download of image styles—`ImageStyleDownloadController`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'The route definition for the default Drupal path looks like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is a bit of an odd route definition. We have a `{scheme}` parameter but
    which will be the actual file path requested for download. The URI scheme itself
    defaults to `private`, as illustrated by the signature of `FileDownloadController::download()`.
    Moreover, access is allowed at all times as Drupal delegates this check to other
    modules—as we will see in a minute.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look inside `FileDownloadController::download()`, we can see that it
    isn''t actually much that it is doing itself. However, we also note that in the
    first line, it looks for the query parameter called `file` in order to get the
    URI of the requested file:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: But based on the route definition, we don't even have this parameter. This is
    where *Path Processors* come into play, more specifically, implementations of
    `InboundPathProcessorInterface`. These are tagged services that get invoked by
    the routing system when building up the routes by the requested path. And essentially,
    they allow the alteration of a given path as it comes in. For Drupal 7 veterans,
    these can be likened to implementations of `hook_url_inbound_alter()`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'The core *System* module implements its own path processor for the purpose
    of handling the download of private files:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It''s a simple tagged service definition whose class needs to implement the
    correct interface that has one method. In the case of `PathProcessorFiles`, it
    looks like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The goal of this method is to return a path that can be the same as the one
    requested or changed for whatever reason. And what Drupal does here is checks
    whether the path is the one defined earlier (starts with `/system/files/`) and
    extracts the requested file path that comes as the first argument after that.
    It takes that and adds it to the current request parameter keyed by `file`. Finally,
    it returns a cleaner path called simply `/system/files`. So this is why the `FileDownloadController::download()`
    method looks there for the file path.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Turning back to the Controller, we see that it essentially checks for the file
    and, if it is not found, throws a 404 (`NotFoundHttpException`). Otherwise, it
    invokes `hook_file_download()` which allows all modules to control access to the
    file. And these can do so in two ways: either by returning `-1`, which denies
    access, or by returning an array of headers to control the download for that specific
    file. By default, files in the private filesystem cannot be downloaded unless
    a specific module allows this to happen.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'So what does this mean? If we have a file in the private filesystem, we need
    to implement `hook_file_download()` and control access to it. Let''s see an example
    of how this might work by assuming we have a folder called `/pdfs` whose files
    we want to make accessible to users that have the `administer site configuration`
    permission:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This hook receives as an argument the URI of the file being requested. And based
    on that, we try to get the folder name it's in. To do this, we use the `file_system`
    service again.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'If the file is not in the private filesystem inside the `/pdfs` folder, we
    simply return `NULL` to signify that we don''t control the access to this file.
    Other modules may do so (and if none do, access is denied). If it is our file,
    we check for the permission we want and return `-1` if the user doesn''t have
    it. This will deny access. Finally, if access is allowed, we return an array of
    headers we want to use in the file delivery. In our case, we simply use the PDF-specific
    headers that facilitate the display of the PDF file in the browser. If we wanted
    to trigger a file download, we could do something like this instead:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We use the filesystem service to determine the file name being requested and
    adjust our headers accordingly to treat it like an attachment that has to be downloaded.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'And that is all there is to it. If we want more control (or a different path
    to download the files), we can implement our own route and follow the same approach.
    Without, of course, the need to invoke a hook, but simply handling the download
    inside the controller method. For example, this is what `FileDownloadController::download()`
    does to handle the actual response:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This type of response is used when we want to deliver files to the browser and
    it comes straight from Symfony.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Images
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going a bit deeper into the world of images in Drupal
    8 while keeping the focus on module developers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Image toolkits
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Drupal 8 Image toolkits provide an abstraction layer over the most common
    operations used for manipulating images. By default, Drupal uses the GD image
    management library that is included with PHP. However, it also offers the ability
    to switch to a different library if needed by using the `ImageToolkit` plugins:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7b498c0-1ae6-48cc-9948-62bd42895e6d.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: For instance, a contributed module could implement the `ImageMagick` library
    for developers who need support for additional image types such as TIFF, which
    GD does not support. However, only one library can be used at a time as it needs
    to be configured site-wide.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmatically manipulating images using a toolkit involves instantiating
    an `ImageInterface` object that wraps an image file. This interface (implemented
    by the `Image` class) contains all the needed methods for applying the common
    manipulations to images, as well as saving the resulting image to the filesystem.
    And to get our hands on such an object, we use the `ImageFactory` service:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The role of this factory is to create instances of `Image` using a given toolkit.
    And it works like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The second parameter to this method is the `ImageToolkit` plugin ID we want
    the `Image` object to work with. By default, it uses the default toolkit configured
    for the entire application.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'And now we can use the manipulation methods on the `ImageInterface` to change
    the file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this example, we scale the image to 50 x 50 and save it to a new path. Omitting
    the destination in the `save()` method would mean overwriting the original file
    with the changed version. If you need to perform such manipulations manually,
    I encourage you to explore the `ImageInterface` for all the available options.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Image styles
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even though, as we''ve seen, we can handle image manipulations programmatically
    ourselves, typically this is done as part of *Image Styles* which can be created
    and configured via the UI. These work similarly to how they did in Drupal 7 and
    involve the application of several possible *Image Effects* in order to create
    image variations used in different places. Drupal 8 comes with the same three
    default image styles as did Drupal 7:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e58c25de-664b-465b-97fd-078f54173c04.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: The image styles themselves are configuration entities that store configuration
    specific to the *ImageEffect* plugins they work with. Once they are created in
    the UI, we can make use of them in various ways. The most typical way is to use
    the image style in the *display* configuration of an entity field or even in Views
    when rendering an image field.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember, in the beginning of the chapter we created the image field
    on the product entity but we did not configure a display. So for the moment, the
    imported images do not show up on the main product page. But we can add some display
    configuration to our base field definition so that images are shown with a specific
    image style:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this example, we are using the default `image` field formatter plugin which
    can be configured to use an image style. So under the `settings` key, we reference
    the `large` image style configuration entity which actually comes with Drupal
    core. Omitting this would simply just render the original image. Make sure you
    check back to [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml), *Your Own
    Custom Entity and Plugin Types*, and [Chapter 9](f58fb5b9-3f39-4575-872d-c2ab9985828d.xhtml),
    *Custom Fields*, if you are a bit fuzzy on the base field definitions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Rendering images
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml), *Theming*, we talked
    about theme hooks and how we use them in render arrays to build output. And we
    also saw a few examples of theme hooks that come with Drupal core and that can
    be used for common things (such as links or tables). But images are also something
    we'll often end up rendering and there are two ways we can do so (both using theme
    hooks defined by Drupal core).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can use the `image` theme hook to simply render an image. And it''s
    pretty simple to use it:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: And this will render the image as is. We can also pass some more options like
    the *alt*, *title*, *width* or *height,* all of which being applied to the image
    tag as attributes, as well as an array of any other kinds of attributes we may
    want. Check out `template_preprocess_image()` for more information on how this
    works.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, the *Image* module defines the `image_style` theme hook which
    we can use to render the image using a given image style:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This theme hook works pretty much the same way, except that it has an extra
    parameter for the ID of the `ImageStyle` entity we want to use. And the rest of
    the parameters we find on the `image` theme hook can also be found here. In fact,
    `image_style` delegates to the `image` theme hook under the hood.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we may also find ourselves in a situation in which we need to get
    our hands on the URL of an image using a given image style. We need to work with
    the `ImageStyle` configuration entity for this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Once we load the image style we want, we simply call its `buildUrl()` method
    to which we pass the URI of the file for which we want the URL. The first time
    this URL is accessed, the image variation gets created and stored to disk. Future
    requests will load it directly from there for improved performance.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are closing this chapter after covering a lot of different topics that have
    to do with working with files in Drupal 8.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'We started with a couple of introductory sections in which we outlined some
    general concepts such as the various filesystems (storages) that Drupal 8 uses,
    as well as how stream wrappers come into play for working with them. We also introduced
    the different ways to work with files: *managed* versus *unmanaged*.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Next, we dove into working with *managed files* and created an image field on
    our Product entity type so that we could import images into it. The other example
    of working with *managed* files had us create a new Product importer based on
    a CSV file of data and we also saw how to upload, read and process such a file,
    as well as manually track its usage. As a parenthesis, we introduced a very powerful
    feature of Drupal 8 that allows us to hook into the entity CRUD operations and
    perform actions whenever these are fired. This is a majorly important technique
    module developers typically use in Drupal.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: We then switched gears and implemented our own stream wrapper to serve our imaginary
    remote API that stored the product images. Moreover, we talked about working with
    *unmanaged* files and some of the functions we can use for this—things similar
    to *managed* files except the function names are different and there are no File
    entities or usage tracking them.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: We then continued with the private filesystem and a talk about what this serves
    and how we can work with it to control access to our own files. As opposed to
    allowing users to bypass Drupal and download files from the public filesystem.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we finished the chapter with a look at the APIs surrounding images
    and how we can use toolkits to process images, both manually and as part of image
    styles. And even more useful, we saw how we can render images in all sorts of
    ways in Drupal 8 and get our hands on image style URLs.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we will look at automated testing and how we
    can ensure that our code works and that we don't introduce regressions along the
    way.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
