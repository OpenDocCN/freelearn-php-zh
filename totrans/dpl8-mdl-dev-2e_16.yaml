- en: Working with Files and Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drupal comes with many capabilities for handling and manipulating files and
    images and has been adding to its toolset more and more with recent versions.
    Of course, this is not to say that media management has not been always a pain
    point for Drupal developers. In Drupal 7, a complicated suite of contributed modules
    was needed to achieve a basic level of functionality, something that users of
    "competitors" like WordPress enjoy out of the box. In Drupal 8, there is more
    emphasis placed on media management, and with each release Media capabilities
    have gone into core. The Media (entity) module, with its essential source plugins
    for supporting Images, Files, Remote Videos (Oembed) and Audio, as well as the
    experimental Media library, make for great advancements in the area. And together
    with popular contributed modules such as Entity Browser, a lot of this gap has
    been filled.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at how we can work with files and images in Drupal,
    supported by the core features. Although the Media module allows developers to
    provide new Source plugins to expose media entities to all sorts of types of media,
    we won't be going into this quite advanced topic. Instead, we'll focus on lower-level
    tools that can be used for working with files. And we will see some examples along
    the way. So, what are we going to discuss?
  prefs: []
  type: TYPE_NORMAL
- en: First, we are going to get an understanding of the Drupal *filesystems*. Developers
    from previous versions of Drupal should already be familiar with these in theory,
    and we will see how these work in Drupal 8\. Related to this, we're going to talk
    about *stream wrappers* and how Drupal handles native PHP file operations. We
    will even create our own custom stream wrapper a bit later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will talk a bit about the different ways to handle files in Drupal,
    namely, *managed* (tracked) and *unmanaged* files. In exemplifying the work with
    *managed* files, we will add an image field to our Product entity type and have
    images imported from a fictional remote environment. We will also create a brand-new
    CSV-based importer by which the product data is imported from a CSV file we read.
    In this process, we will note the Entity CRUD hooks, a very important extension
    point in Drupal 8, and see how we can use those in our example context.
  prefs: []
  type: TYPE_NORMAL
- en: We will end the chapter by seeing how we can work with various APIs that deal
    specifically with images, especially for manipulating them via image toolkits
    and working with image styles. So let's get to it.
  prefs: []
  type: TYPE_NORMAL
- en: The filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Drupal defines four main types of file storage for any given site: the *public*,
    the *private,* the *temporary* and the *translation* filesystems. When installing
    Drupal, the folders that map to these filesystems are created automatically. In
    case that fails—most likely due to permission issues—we have to create them ourselves
    and give them the correct permissions. Drupal takes care of the rest (for example,
    adds relevant `.htaccess` files for security reasons). Make sure you check out
    the documentation on [Drupal.org](https://www.drupal.org/) for how to successfully
    install Drupal 8 if you are unsure how this works.'
  prefs: []
  type: TYPE_NORMAL
- en: Public files are available to the world at large for viewing or downloading.
    This is where things such as image content, logos, and anything that can be downloaded
    are stored. Your public file directory must exist somewhere under Drupal's root,
    and it must be readable and writeable by whatever *user* your web server is running
    under. Public files have no access restrictions. Anyone, at any time, can navigate
    directly to a public file and view or download it. This also means that accessing
    these files does not require Drupal to bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can configure the path to the public filesystem in our `settings.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Private files, on the other hand, are not available to the world for general
    download. Therefore, the private files' directory must not be accessible via the
    web. However, it still has to be writeable by the web server user. Isolating private
    files this way allows developers to control who can and can't access them. For
    instance, we could write a module that only allows users who have a specific role
    to access PDFs in the private filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can configure the path to the private filesystem in our `settings.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Temporary file storage is typically only used by Drupal for internal operations.
    When files are first saved by Drupal, they are initially written into the temporary
    filesystem so they can be checked for security issues. After they have been deemed
    safe, they are written to their final location.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can configure the path to the temporary filesystem through the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b23acfd3-953c-4d02-a981-50e876c256fc.png)'
  prefs: []
  type: TYPE_IMG
- en: On the same configuration screen, we can also specify the default file download
    method for the site. By default, this is set to the public filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the translation file storage is used by Drupal for storing the `.po`
    files that contain string translation values that can be imported into the system
    in bulk. As with the temporary file storage, we can configure the location of
    translation files through the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Stream wrappers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''ve been writing PHP for a long time, you may have needed to work with
    local or remote files at some point. The following PHP code is a common way to
    read a file into a variable that you can do something with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty straightforward. We get a handle to a local file using `fopen()`
    and read 8 KB chunks of the file using `fread()` until `feof()` indicates that
    we've reached the end of the file. At that point, we use `fclose()` to close the
    handle. The contents of the file are now in the `$contents` variable.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to local files, we can also access remote ones through `fopen()`
    in the exact same way but by specifying the actual remote path instead of the
    local one we saw before (starting with `http(s)://`).
  prefs: []
  type: TYPE_NORMAL
- en: Data that we can access this way is streamable, meaning we can open it, close
    it, or seek to a specific place in it.
  prefs: []
  type: TYPE_NORMAL
- en: '*Stream wrappers* are an abstraction layer on top of these streams that tell
    PHP how to handle specific types of data. When using a stream wrapper, we refer
    to the file just like a traditional URL—`scheme://target`. As a matter of fact,
    the previous example uses one of PHP''s built-in stream wrappers: the `file://`
    wrapper for accessing files on local storage. It is actually the default scheme
    when none is specified, so that is why we got away with omitting it and just adding
    the file path. Had the file been on a remote location, we would have used something
    like `http://example.com/file/path/image.jpg`. That is another PHP built-in stream
    wrapper: `http://` (for the HTTP protocol).'
  prefs: []
  type: TYPE_NORMAL
- en: If that's not enough, PHP also allows us to define our own wrappers for schemes
    that PHP does not handle out of the box; the Drupal File API was built to take
    advantage of this. This is where we link back to the different types of file storage
    we talked about earlier, as they all have their own stream wrappers defined by
    Drupal.
  prefs: []
  type: TYPE_NORMAL
- en: The public filesystem uses the rather known `public://` stream wrapper, the
    private one uses `private://`, the temporary one `temporary://` and the translation
    one `translations://`. These map to the local file paths that we defined in the
    `settings.php` (or UI). Later in the chapter we will see how we can define our
    own stream wrapper and what some of the things that go into it are. First, though,
    let's talk a bit about the different ways we can manage files in Drupal 8.
  prefs: []
  type: TYPE_NORMAL
- en: Managed versus unmanaged files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Drupal File API allows us to handle files in two different ways. Files
    essentially boil down to two categories: they are either *managed* or *unmanaged*.
    The difference between the two lies in the way the files are used.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Managed* files work hand in hand with the Entity system and are, in fact,
    tied to File entities. So whenever we create a *managed* file, an entity gets
    created for it as well, which we can use in all sorts of ways. And the table where
    these records are stored is called `file_managed`. Moreover, a key aspect of *managed*
    files is the fact that their usage is tracked. This means that if we reference
    them on an entity or even manually indicate that we use them, this usage is tracked
    in a secondary table called `file_usage`. This way, we can see where each file
    is used and how many times, and Drupal even provides a way to delete "orphaned"
    files after a specific time in case they are no longer needed.'
  prefs: []
  type: TYPE_NORMAL
- en: A notable example of using *managed* files is the simple `Image` field type
    that we can add to an entity type. Using these fields, we can upload a file and
    *attach* it to the respective entity. This attachment is nothing more than a special
    (tracked) entity reference between the two entities.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding how *managed* files are used, it's not difficult to anticipate
    what *unmanaged* files are. The latter are the files we upload to make use of
    for various reasons but that, of course, do not need to be *attached* to any entity
    or have their usage tracked.
  prefs: []
  type: TYPE_NORMAL
- en: Using the File and Image fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to demonstrate how to work with *managed* files, we will go back to
    our product entity importer and bring in some images for each product. However,
    in order to store them, we need to create a field on the Product entity. This
    will be an *image* field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of creating this field through the UI and attaching it to a bundle,
    let''s do it the programmatic way and make it a base field (available on all bundles).
    We won''t need to do anything complex; for now we are only interested in a basic
    field that we can use to store the images we bring in from the remote API. It
    can look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you remember from [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml),
    *Data Modeling and Storage*, and [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml),
    *Your Own Custom Entity and Plugin Types*, we are creating a base field definition
    that, in this case, is of the type `image`. This is the `FieldType` plugin ID
    of the `ImageItem` field type. So that is where we need to look and see what kind
    of field and storage options we may have. For example, we can have a file extension
    limitation (which by default contains `png`, `gif`, `jpg`, and `jpeg`) and things
    like `alt` and `title` attributes, as well as image dimension configuration. Do
    check out `ImageItem` to get an idea of the possible storage and field settings.
    However, we are fine with the defaults in this case so we don't even have any
    field settings.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting thing to notice is that `ImageItem` extends the `FileItem`
    field type, which is a standalone `FieldType` plugin that we can use. However,
    it is more generic and lends itself for use with any kind of file upload situation.
    Since we are dealing with images, we might as well take advantage of the specific
    field type.
  prefs: []
  type: TYPE_NORMAL
- en: For the moment, we do not configure our image field to have any kind of display.
    We'll look into that a bit later. However, we do specify the widget it should
    use on the entity form, namely the `FieldWidget` plugin with the ID of `image_image`.
    This maps to the default `ImageWidget` field widget. But again, we are fine with
    the setting defaults, so we don't specify anything extra.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, our field definition is done. To have Drupal create the necessary
    database tables, we need to run the Drush command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create the interface methods for easily accessing and setting the
    images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The getter method is supposed to return a `FileInterface` object (which is
    the actual File entity), while the setter is supposed to receive the ID (`fid`)
    of the File entity to save. As for the implementations, it should not be anything
    new to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With this, we are ready to proceed with the import of images from the remote
    API.
  prefs: []
  type: TYPE_NORMAL
- en: For taking advantage of the media management power in Drupal 8, instead of Image
    or File fields, you'd create entity reference fields to Media entities. And on
    the latter you'd create these fields. As such, Media entities basically wrap the
    File entities to provide some additional functionality and expose them to all
    the goodies of media management. For now, we work directly with these field types
    to learn about low-level file handling without the overhead of Media.
  prefs: []
  type: TYPE_NORMAL
- en: Working with managed files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at two examples of working with managed files.
    First, we will see how we can import product images from our fictional remote
    JSON-based API. Second, we will see how to create a custom form element that allows
    us to upload a file and use it in a brand new CSV-based importer.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching managed files to entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our product image field in place and we can store images,
    let''s revisit our JSON response that contains the product data and assume it
    looks something like this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What's new is the addition of the `image` key for each product, which simply
    references a filename for the image that goes with the respective product. The
    actual location of the images is at some other path we need to include in the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our `JsonImporter::persistProduct()` method, let''s delegate
    the handling of the image import to a helper method called `handleProductImage()`.
    We need to call this method both if we are creating a new Product entity and if
    we are updating an existing one (right before saving):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is what the actual method looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And the new *use* statement at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, we get the name of the image. Then we construct the path to where the
    product images are stored. In this example, it's left blank, but if the example
    were to work, we'd have to add a real path there. I leave that up to you for now.
    If you want to test it out, create a local folder with some images and reference
    that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the native `file_get_contents()` function, we load the data of the image
    from the remote environment into a string. We then pass this string to the `file_save_data()` function
    which saves a new *managed* file to the public filesystem. This function takes
    three parameters: the data to be saved, the URI of the destination, and a flag
    indicating what to do if a file with the same name already exists. You''ll notice
    that we used the Drupal `public://` stream wrapper to build the URI and we already
    know which folder this maps to.'
  prefs: []
  type: TYPE_NORMAL
- en: As for the third parameter, we chose to replace the file in case one already
    exists. The alternative would have been to either use the `EXISTS_RENAME` or `EXISTS_ERROR`
    constants of the same interface. The first would have created a new file whose
    name would have gotten a number appended until the name became unique. The second
    would have simply not done anything and returned FALSE.
  prefs: []
  type: TYPE_NORMAL
- en: If all goes well, this function returns a `File` entity (that implements `FileInterface`)
    whose ID we can use in the Product image setter method. With that in place, we
    can synchronize also the individual product images.
  prefs: []
  type: TYPE_NORMAL
- en: If you run into issues after this, make sure you create the destination folder
    and have all the permissions in order in the public filesystem to allow the copy
    to take place properly. In the next section you'll learn about some helper functions
    you can use to better prepare with the destination folder.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, in our database, a record is created in the `file_usage` table to
    indicate that this file is being used on the respective Product entity.
  prefs: []
  type: TYPE_NORMAL
- en: Helpful functions for dealing with managed files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from the staple `file_save_data()` function, we have a few other ones
    that can come in handy if we are dealing with *managed* files. Here's a few of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to copy a file from one place to another while making sure a new
    database record is created, we can use `file_copy()`. It takes three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The `FileInterface` entity that needs to be copied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The destination URI where it should go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flag indicating what to do in case a file with the same name exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameters are the same as for `file_save_data()`.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the actual copying, this function also invokes `hook_file_copy()`
    which allows modules to respond to files being copied.
  prefs: []
  type: TYPE_NORMAL
- en: Very similar to `file_copy()`, we also have `file_move()` which takes the same
    set of parameters but instead performs a file move. The database entry of the
    File entity gets updated to reflect the new file path. And `hook_file_move()`
    is invoked to allow modules to respond to this action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not strictly related to *managed* files, but rather useful in all cases, we
    also have the `\Drupal\Core\File\FileSystem` service (accessible via the `file_system`
    service name), which contains all sorts of useful methods for dealing with files.
    We''ll see some of them when we talk about *unmanaged* files. But one that is
    useful also for *managed* files is `::prepareDirectory()` which we can use to
    ensure the file destination is correct. It takes two arguments: the directory
    (a string representation of the path or stream URI) and a flag indicating what
    to do about the folder (constants on the interface):'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileSystemInterface::CREATE_DIRECTORY` : Will create the directory if it doesn''t
    already exist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileSystemInterface::MODIFY_PERMISSION` : Will make the directory writable
    if it is found to be read-only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function returns `TRUE` if the folder is good to go as a destination or
    `FALSE` if something went wrong or the folder doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: Managed file uploads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we are going to look at how we can work with *managed* files using a
    custom form element. And to demonstrate this, we are finally going to create another
    Product importer plugin. This time, instead of a remote JSON resource, we will
    allow users to upload a CSV file that contains product data and imports that into
    Product entities. This is what the example CSV data looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It basically has the same kind of data as the JSON resource we've been looking
    at so far but without the image reference. So let's get going with our new plugin
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We start by extending from the `ImporterBase` class and implement the obligatory
    `import()` method. Like before, we delegate to `getData()` to retrieve the product
    information, but in this case we simply loop over the resulting records and use
    the `persistProduct()` method to save the Product entities. So no batch operations.
    Apart from no longer saving images, this latter method looks exactly like the
    one from the `JsonImporter`, so I won't be copying it over again. But it makes
    for a good homework assignment to try to move it to the base class and abstract
    away the dynamic portions.
  prefs: []
  type: TYPE_NORMAL
- en: Managed file form element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The other obligatory method we need to implement is `getConfigurationForm()`,
    by which we define the form elements needed to configure this particular plugin.
    Here, we will create the `file` field allowing users to upload the CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The form element type is called `managed_file` (implemented by the `ManagedFile`
    form element class). The rest of the definition is straightforward. However, there
    are a couple of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, by default, using this form element, files are uploaded to the `temporary://`
    filesystem of Drupal. Since we don''t want that, we need to specify an upload
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The root of our public files folder will suffice for this example as we assume
    the file does not contain any sensitive information. If so, we could upload it
    to the `private://` one and control who gets access. We'll talk about how that
    works later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, by default, using this form element, the *allowed* file extensions
    for upload are limited to `jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp`.
    So if we want to allow CSV files, we need to specify the extension in a list of
    allowed upload extensions. And we do this by overriding the default upload validators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is an array of validator callbacks we want Drupal to run when the file
    is uploaded. And allowing only CSV files is enough for our purposes. But another
    handy validator we could use is `file_validate_size()`. Moreover, we can implement
    `hook_file_validate()` ourselves and perform any custom validation to the files
    being uploaded. So that's also something to keep in mind when dealing with validation
    files that don't belong to your modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, our plugin configuration form is in place; it looks something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0495cf38-f200-4e96-8fd7-f8a98bc4c7b0.png)'
  prefs: []
  type: TYPE_IMG
- en: However, there is still something we need to do in order for the uploaded file
    to be *managed* properly. When using this form element, the file gets correctly
    uploaded and a record is added to the `file_managed` table. So we get our `File`
    entity. However, its status is not permanent because it doesn't have any usages.
    There are no records for it in the `file_usage` table. How could there be? So
    what we need to do is handle that ourselves and basically tell Drupal that the
    file uploaded in this form is *used* by the respective Importer configuration
    entity. And to do this, we need to know when the file is saved onto the entity,
    changed, and deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we can also learn about something very important that we skipped
    in [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml), *Data Modeling and
    Storage*, and [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml), *Your Own
    Custom Entity and Plugin Types:* entity CRUD hooks. But right before we jump into
    that, let''s not forget about the configuration schema of this new configuration
    item—the `file` key of the plugin configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We are doing the same as we did for the `url` key of the JSON importer but,
    in this case, we need to account for the fact that `file` is actually an array.
    So we define it as a sequence whose individual items are integers. Feel free to
    check [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml), *Data Modeling
    and Storage*, for more information on configuration schemas whenever you need
    a reminder.
  prefs: []
  type: TYPE_NORMAL
- en: Entity CRUD hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever entities are created, updated, or deleted, a set of hooks are fired
    that allow us to act on this information. We can use these hooks simply to perform
    some actions whenever this happens or even make changes to the entity being saved.
    So let's see what we have.
  prefs: []
  type: TYPE_NORMAL
- en: A very useful one is `hook_entity_presave()`, which gets fired during the saving
    process of an entity (both content and configuration). This applies to both when
    the entity is first created, as well as when it is being updated. Moreover, it
    allows us to inspect the original entity and detect changes made to it. And finally,
    since the entity has not yet been persisted, it allows us to make changes to it
    ourselves. So very powerful stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Since Drupal 8 is very flexible, we also have the `hook_ENTITY_TYPE_presave()`
    version which allows us to specifically target any entity type we want. We've
    already discussed the benefit of using more specific hooks to keep our code more
    organized as well as a little bit more performant. And this applies to all the
    entity CRUD hooks we are going to talk about next.
  prefs: []
  type: TYPE_NORMAL
- en: Then we have `hook_entity_insert()` and `hook_entity_update()`, which get fired
    after an entity is created for the first time and after an entity is updated,
    respectively. We cannot make changes to the entity itself as it has already been
    saved, but they can come in handy at other times. The latter also give us access
    to the original entity if we want to compare any changes. And similarly, we have
    `hook_entity_delete()`, which gets fired when an entity is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we also have `hook_entity_load()` which allows us to perform actions
    whenever an entity is loaded. For example, we can tack on additional information
    if we want. So keep in mind these hooks, as they are going to be a very important
    tool in your module developer arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: Managed file usage service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have an idea of the available entity CRUD hooks, we can implement
    three of them to handle our *managed* file problem. Because, if you remember,
    *managed* files are actually represented by the `File` entity type, so the Entity
    CRUD hooks get fired for these as well.
  prefs: []
  type: TYPE_NORMAL
- en: To mark a file as being used by *something,* we can use the `DatabaseFileUsageBackend`
    service (`file.usage`), which is an implementation of the `FileUsageInterface`.
    This has a few handy methods that allow us to add a usage or delete it. That is
    actually what we are going to do next.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we want to do first is add a file usage whenever a new Importer entity
    gets created (and a file uploaded with it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We are implementing the specific version of `hook_entity_insert()` for our
    own entity type, and the first thing we are checking is whether we are looking
    at one using the CSV plugin. We''re not interested in any importers that don''t
    have a CSV file upload. If we are, we get the File entity ID from the importer
    using a private helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that the `file` key in our plugin configuration array is an array
    of File IDs, even if we only uploaded one single file. That is just something
    we need to account for here (we did so also in our configuration schema earlier
    on).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we load the File entity based on this ID and use the `file.usage` service
    to add a usage to it. The first parameter of the `add()` method is the File entity
    itself, the second is the module name that marks this usage, the third is the
    type of *thing* the file is used by, while the fourth is the ID of this *thing*.
    The latter two depend on the use case; we choose to go with our own notation (`config:importer`)
    to make it clear that we are talking about a configuration entity of the type
    `importer`. Of course, we used the ID of the entity.
  prefs: []
  type: TYPE_NORMAL
- en: With this, a new record will get created in the `file_usage` table whenever
    we save such an Importer entity for the first time. Now let's handle the case
    in which we delete this entity—we don't want this file usage lingering around,
    do we?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Most of what we are doing in this specific version of `hook_entity_delete()`
    is the same as before. However, we are using the `delete()` method of the `file.usage`
    service but passing the same arguments. These `$type` and `$id` parameters are
    actually optional, so we can "un-use" multiple files at once. Moreover, we have
    an optional fifth parameter (the count) whereby we can specifically choose to
    remove more than one usage from this file. By default, this is 1, and that makes
    sense for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we also want to account for the cases in which the user edits the
    importer entity and changes the CSV file. We want to make sure the old one is
    no longer marked as used for this Importer. And we can do this with `hook_entity_update()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the specific variant of this hook that only gets fired for Importer
    entities. Just like we''ve been doing so far. And as I mentioned, we can access
    the original entity (before the changes have been made to it) like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: And if the File ID that was on the original entity is not the same as the one
    we are currently saving with it (meaning the file was changed), we can delete
    the usage of that old File ID.
  prefs: []
  type: TYPE_NORMAL
- en: Processing the CSV file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our plugin configuration works—and uploaded files are properly managed
    and marked as used—it''s time to implement the `getData()`method by which we process
    the CSV file of the Importer entity. The result needs to be an array of product
    information as expected by the `import()` method we saw earlier. So we can have
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: First, quite expectedly, we check for the existence of the File ID in the Importer
    entity and load the corresponding File entity based on that. To do this, we use
    the entity manager we injected into the plugin base class. But then comes something
    new.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the File entity, we can ask it its URI, which will return something
    like this: `public://products.csv`. This is what is stored in the database. But
    in order to turn that into something useful, we need to use the *stream wrapper*
    that defines this filesystem. And to get that, we use the `StreamWrapperManager`
    service (`stream_wrapper_manager`) which has a handy method of returning the *stream
    wrapper* instance responsible for a given URI—`getViaUri()`. And once we have
    our `StreamWrapperInterface`, we can use its `realpath()` method to get the local
    path of the resource. We will come back to *stream wrappers* a bit later in this
    chapter and it will make more sense. But for the moment, it''s enough to understand
    that we are translating a URI in the `scheme://target` format into a useful path
    that we can use to create a new PHP-native `SplFileObject` instance, which, in
    turn, we can use to process the CSV file easily.'
  prefs: []
  type: TYPE_NORMAL
- en: When creating the `SplFileObject`, we used the external URL of the file. This
    worked just fine and we were able to also demonstrate how we can get our hands
    on the external URL if we ever need to. But, as we will see in the next chapter,
    it will also work directly with the stream URI, and we will switch to this approach
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: With three lines of code we are basically done getting all the rows from the
    CSV into the `$data` array. However, we also want to make this data look a bit
    more like what the JSON resource looked like—a map where the keys are the field
    names and the values are the respective product data. And we also want this map
    to contain PHP standard objects instead of arrays. Therefore, we loop through
    the data, establish the CSV header values, and use those as the keys in each row
    of a new `$products` array of objects. Our end result will look exactly like the
    product information coming from the decoded JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: 'And with this we are done. Well, not quite. We still need to inject the `StreamWrapperManager`
    service into our plugin. And to do that, we need to make sure we are injecting
    also all the things that the parent class needs and passing them along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And the new *use* statements at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Nothing we don't yet know how to do. However, there is one thing I'd like to
    point out here. In [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml), *Your
    Own Custom Entity and Plugin Types*, I mentioned how, at the time, I believed
    the Guzzle HTTP Client is a service that would be useful to all Importer plugins.
    Well, I was clearly wrong, as the CSV-based one we just created now doesn't need
    it. So there is no reason why it should be injected into it. What we need to do
    here is remove this dependency from the base plugin class and only use it in the
    JSON importer. However, I leave this up to you as homework.
  prefs: []
  type: TYPE_NORMAL
- en: Our CSV Importer plugin is now complete. If we did everything correctly, we
    can now create a new Importer entity that uses it, upload a correct CSV file,
    and import some Product entities via our Drush command. How neat.
  prefs: []
  type: TYPE_NORMAL
- en: Our own stream wrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we briefly talked about stream wrappers and
    what they are used for. We saw that Drupal comes with four mainstream wrappers
    that map to the various types of file storage it needs. Now it's time to see how
    we can create our own. And the main reason why we would want to implement one
    is to expose resources at a specific location to PHP's native filesystem functions.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will create a very simple stream wrapper that can basically
    only read the data from the resource. Just to keep things simple. And the data
    resource will be the product images hosted remotely (the ones we are importing
    via the JSON Importer). So there will be some rework there to use the new stream
    wrapper instead of the absolute URLs. Moreover, we will also learn how to use
    the site-wide settings service by which we can have environment-specific configurations
    set in the `settings.php` file and then read by our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The native way of registering a stream wrapper in PHP is by using the `stream_wrapper_register()`
    function. However, in Drupal 8, we have an abstraction layer on top of that in
    the form of services. So a stream wrapper is a simple tagged service, albeit with
    many potential methods. Let''s see its definition, which we add to the `products.services.yml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing too complicated. The service is tagged with `stream_wrapper` and we
    use the `scheme` key to indicate the scheme of the wrapper. So the URIs will be
    in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: One important thing to note about stream wrapper services is that we cannot
    pass dependencies to them. The reason is that they are not instantiated the normal
    way (by the container) but arbitrarily by PHP whenever some of its methods need
    to be called. So if we need to use some services, we'll have to use the static
    way of loading them.
  prefs: []
  type: TYPE_NORMAL
- en: The stream wrapper service class needs to implement `StreamWrapperInterface`
    which comes with a lot of methods. There are many possible filesystem interactions
    that PHP can do and these methods need to account for them all. However, we will
    only be focusing on a few specific ones that have to do with reading data. After
    all, our resources are remote and we don't even have a clue how to make changes
    to them over there. So for the rest of the methods, we will be returning FALSE
    to indicate that the operation cannot be performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this big class then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to look at is the constructor in which we statically load the
    `Settings` service and store it as a class property. And speaking of which, we
    also define a `$uri` property to hold the actual URI this wrapper *wraps* and
    a `$handle` property to hold a generic PHP resource handle.
  prefs: []
  type: TYPE_NORMAL
- en: The `getName()` and `getDescription()` methods are pretty straightforward and
    are used for identifying the stream wrapper, while the `getType()` method returns
    the type of stream. We'll go with the hidden type because we don't want it visible
    in the UI. It's strictly for programmatic use so that we can read our product
    images. Do check out the available types and their meanings by looking at the
    `StreamWrapperInterface` constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have a getter and setter for the `$uri` property by which the Drupal
    `StreamWrapperManager` can create an instance of our wrapper based on a given
    URI. The `getTarget()` method is actually not in the interface but is a helper
    to extract a clean target from the URI (the target being the second part of the
    URI that comes after `scheme://`). And we use this method in `getExternalUrl()`,
    which is quite an important method responsible for returning an absolute URL to
    the resource in question. But here we also use our `Settings` service to get the
    `product_images_path` key. If you remember in the beginning of the chapter, we
    saw that the path to the public filesystem is defined in the `settings.php` file
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'That `$settings` variable is the data array that is wrapped by the `Settings`
    service. So we want to do the same for defining our own remote path to the product
    images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This way we are not committing to Git the actual remote URL and we can also
    change it later if we want. And this is the URL we are reading inside the `getExternalUrl()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The other pillar of our read-only stream wrapper is the ability to open a file
    handle to the resource and allow us to read the data from it. And the `stream_open()`
    method does this as it gets called when we run either `file_get_contents()` or
    `fopen()` on our URI. Using the `$mode` parameter, we ensure that the operation
    is read-only and return `FALSE` otherwise—we do not support *write* or other flags.
  prefs: []
  type: TYPE_NORMAL
- en: Any mode can have `b` appended to it to indicate that the file should be opened
    in binary mode. So, where `r` indicates read-only, `rb` indicates read-only in
    binary mode.
  prefs: []
  type: TYPE_NORMAL
- en: The third argument is a bitmask of options defined by PHP. The one we're dealing
    with here is `STREAM_REPORT_ERRORS`, which indicates whether or not PHP errors
    should be suppressed (for instance, if a file is not found). The second is `STREAM_USE_PATH`,
    which indicates whether PHP's include path should be checked if a file is not
    found. This is not relevant to us, so we ignore it. If a file is found on the
    include path, then the fourth argument, (`$opened_url)`), should be set with the
    file's real path.
  prefs: []
  type: TYPE_NORMAL
- en: What we do then is translate the URI into the absolute URL of the external resource
    so that we can open a file handle on it. And in doing so, we make use of the `STREAM_REPORT_ERRORS`
    option to either prepend the `@` to the `fopen()` function or not (doing so suppresses
    errors). Finally, we store the reference to the resource handle and return a Boolean
    based on it to indicate whether the operation succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we also implement the `stream_read()`, `stream_eof()`, and `stream_close()`
    methods so that we can actually also stream the resources if we want to. As for
    the rest of the methods, as already mentioned, we return `FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we have to do now is clear the cache and make use of our stream. As long
    as we have a valid URL declared in the `settings.php` file, our stream should
    work fine. And here are the kinds of things we could do with a URI like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the entire file content into a string, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can use the example from the beginning of the chapter and stream the
    file bit by bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: All these file operations, such as opening, reading, checking the end of a file
    and closing, are possible due to our `stream_*()` method implementations from
    the wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, maybe now it's also a bit clearer what we did when writing the
    CSV Importer and using the `StreamWrapperManager` to identify the stream wrapper
    responsible for a given URI, and based on that, the real path of the URI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To end the section on stream wrappers, let''s do some clean-up work by refactoring
    a bit our `JsonImporter::handleProductImage()` method. Our logic there involved
    hardcoding the URL to the remote API, which is really not a good idea. Instead,
    now that we have our stream wrapper, we can go ahead and use it. We can replace
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'With this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It's that simple. And now we can control the remote URL from outside the Git
    repository and, if it changes, we don't even have to alter our code. Granted,
    solely for this purpose, implementing a stream wrapper seems a bit excessive.
    After all, you can simply inject the `Settings` service and use the URL in the
    Importer plugin itself allowing for the same kind of flexibility. But we used
    the opportunity to learn about stream wrappers and how to create our own. And
    we even managed to find a small use case in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Working with unmanaged files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with *unmanaged* files is actually pretty similar to doing so with *managed*
    files, except that they are not tracked in the database using the File entity
    type. There is a set of helper functions similar to what we've seen for *managed*
    files that can be accessed through the `FileSystem` service I mentioned earlier.
    Let's see some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'To save a new file, we do almost like we did before with *managed* files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We load the file data from wherever and use the `saveData()` method on the service
    the same way as we did `file_save_data()`. The difference is that the file is
    going to be saved but no database record is created. So the only way to use it
    is to rely on the path it is saved at and either try to access it from the browser
    or use it for whatever purpose we need. This method returns the URI of where the
    file is now saved or `FALSE` if there was a problem with the operation. So if
    all went well with the previous example, `$path` would now be `public://tv.jpg`.
  prefs: []
  type: TYPE_NORMAL
- en: And just like with the *managed* files, we also have a few other helpful methods
    in that service, such as `move()`, `copy()`, and `delete()`. I recommend you inspect
    that service to get more details on how these work.
  prefs: []
  type: TYPE_NORMAL
- en: Private filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The private filesystem is used whenever we want to control access to the files
    being downloaded. Using the default public storage, users can get to the files
    simply by pointing to them in the browser, thereby bypassing Drupal completely.
    However, `.htaccess` rules prevent users from directly accessing any files in
    the private storage, making it necessary to create a route that delivers the requested
    file. It goes without saying that the latter is a hell of a lot less performant,
    as Drupal needs to be loaded for each file. Therefore, it's important to only
    use it when files should be restricted based on certain criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Drupal already comes with a route and Controller ready to download private files,
    but we can create one as well if we really need to. For example, the image module
    does so in order to control the creation and download of image styles—`ImageStyleDownloadController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The route definition for the default Drupal path looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is a bit of an odd route definition. We have a `{scheme}` parameter but
    which will be the actual file path requested for download. The URI scheme itself
    defaults to `private`, as illustrated by the signature of `FileDownloadController::download()`.
    Moreover, access is allowed at all times as Drupal delegates this check to other
    modules—as we will see in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look inside `FileDownloadController::download()`, we can see that it
    isn''t actually much that it is doing itself. However, we also note that in the
    first line, it looks for the query parameter called `file` in order to get the
    URI of the requested file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: But based on the route definition, we don't even have this parameter. This is
    where *Path Processors* come into play, more specifically, implementations of
    `InboundPathProcessorInterface`. These are tagged services that get invoked by
    the routing system when building up the routes by the requested path. And essentially,
    they allow the alteration of a given path as it comes in. For Drupal 7 veterans,
    these can be likened to implementations of `hook_url_inbound_alter()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core *System* module implements its own path processor for the purpose
    of handling the download of private files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a simple tagged service definition whose class needs to implement the
    correct interface that has one method. In the case of `PathProcessorFiles`, it
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The goal of this method is to return a path that can be the same as the one
    requested or changed for whatever reason. And what Drupal does here is checks
    whether the path is the one defined earlier (starts with `/system/files/`) and
    extracts the requested file path that comes as the first argument after that.
    It takes that and adds it to the current request parameter keyed by `file`. Finally,
    it returns a cleaner path called simply `/system/files`. So this is why the `FileDownloadController::download()`
    method looks there for the file path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Turning back to the Controller, we see that it essentially checks for the file
    and, if it is not found, throws a 404 (`NotFoundHttpException`). Otherwise, it
    invokes `hook_file_download()` which allows all modules to control access to the
    file. And these can do so in two ways: either by returning `-1`, which denies
    access, or by returning an array of headers to control the download for that specific
    file. By default, files in the private filesystem cannot be downloaded unless
    a specific module allows this to happen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So what does this mean? If we have a file in the private filesystem, we need
    to implement `hook_file_download()` and control access to it. Let''s see an example
    of how this might work by assuming we have a folder called `/pdfs` whose files
    we want to make accessible to users that have the `administer site configuration`
    permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This hook receives as an argument the URI of the file being requested. And based
    on that, we try to get the folder name it's in. To do this, we use the `file_system`
    service again.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the file is not in the private filesystem inside the `/pdfs` folder, we
    simply return `NULL` to signify that we don''t control the access to this file.
    Other modules may do so (and if none do, access is denied). If it is our file,
    we check for the permission we want and return `-1` if the user doesn''t have
    it. This will deny access. Finally, if access is allowed, we return an array of
    headers we want to use in the file delivery. In our case, we simply use the PDF-specific
    headers that facilitate the display of the PDF file in the browser. If we wanted
    to trigger a file download, we could do something like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We use the filesystem service to determine the file name being requested and
    adjust our headers accordingly to treat it like an attachment that has to be downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that is all there is to it. If we want more control (or a different path
    to download the files), we can implement our own route and follow the same approach.
    Without, of course, the need to invoke a hook, but simply handling the download
    inside the controller method. For example, this is what `FileDownloadController::download()`
    does to handle the actual response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This type of response is used when we want to deliver files to the browser and
    it comes straight from Symfony.
  prefs: []
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going a bit deeper into the world of images in Drupal
    8 while keeping the focus on module developers.
  prefs: []
  type: TYPE_NORMAL
- en: Image toolkits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Drupal 8 Image toolkits provide an abstraction layer over the most common
    operations used for manipulating images. By default, Drupal uses the GD image
    management library that is included with PHP. However, it also offers the ability
    to switch to a different library if needed by using the `ImageToolkit` plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7b498c0-1ae6-48cc-9948-62bd42895e6d.png)'
  prefs: []
  type: TYPE_IMG
- en: For instance, a contributed module could implement the `ImageMagick` library
    for developers who need support for additional image types such as TIFF, which
    GD does not support. However, only one library can be used at a time as it needs
    to be configured site-wide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programmatically manipulating images using a toolkit involves instantiating
    an `ImageInterface` object that wraps an image file. This interface (implemented
    by the `Image` class) contains all the needed methods for applying the common
    manipulations to images, as well as saving the resulting image to the filesystem.
    And to get our hands on such an object, we use the `ImageFactory` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The role of this factory is to create instances of `Image` using a given toolkit.
    And it works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter to this method is the `ImageToolkit` plugin ID we want
    the `Image` object to work with. By default, it uses the default toolkit configured
    for the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now we can use the manipulation methods on the `ImageInterface` to change
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we scale the image to 50 x 50 and save it to a new path. Omitting
    the destination in the `save()` method would mean overwriting the original file
    with the changed version. If you need to perform such manipulations manually,
    I encourage you to explore the `ImageInterface` for all the available options.
  prefs: []
  type: TYPE_NORMAL
- en: Image styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even though, as we''ve seen, we can handle image manipulations programmatically
    ourselves, typically this is done as part of *Image Styles* which can be created
    and configured via the UI. These work similarly to how they did in Drupal 7 and
    involve the application of several possible *Image Effects* in order to create
    image variations used in different places. Drupal 8 comes with the same three
    default image styles as did Drupal 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e58c25de-664b-465b-97fd-078f54173c04.png)'
  prefs: []
  type: TYPE_IMG
- en: The image styles themselves are configuration entities that store configuration
    specific to the *ImageEffect* plugins they work with. Once they are created in
    the UI, we can make use of them in various ways. The most typical way is to use
    the image style in the *display* configuration of an entity field or even in Views
    when rendering an image field.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember, in the beginning of the chapter we created the image field
    on the product entity but we did not configure a display. So for the moment, the
    imported images do not show up on the main product page. But we can add some display
    configuration to our base field definition so that images are shown with a specific
    image style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are using the default `image` field formatter plugin which
    can be configured to use an image style. So under the `settings` key, we reference
    the `large` image style configuration entity which actually comes with Drupal
    core. Omitting this would simply just render the original image. Make sure you
    check back to [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml), *Your Own
    Custom Entity and Plugin Types*, and [Chapter 9](f58fb5b9-3f39-4575-872d-c2ab9985828d.xhtml),
    *Custom Fields*, if you are a bit fuzzy on the base field definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml), *Theming*, we talked
    about theme hooks and how we use them in render arrays to build output. And we
    also saw a few examples of theme hooks that come with Drupal core and that can
    be used for common things (such as links or tables). But images are also something
    we'll often end up rendering and there are two ways we can do so (both using theme
    hooks defined by Drupal core).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can use the `image` theme hook to simply render an image. And it''s
    pretty simple to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: And this will render the image as is. We can also pass some more options like
    the *alt*, *title*, *width* or *height,* all of which being applied to the image
    tag as attributes, as well as an array of any other kinds of attributes we may
    want. Check out `template_preprocess_image()` for more information on how this
    works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, the *Image* module defines the `image_style` theme hook which
    we can use to render the image using a given image style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This theme hook works pretty much the same way, except that it has an extra
    parameter for the ID of the `ImageStyle` entity we want to use. And the rest of
    the parameters we find on the `image` theme hook can also be found here. In fact,
    `image_style` delegates to the `image` theme hook under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we may also find ourselves in a situation in which we need to get
    our hands on the URL of an image using a given image style. We need to work with
    the `ImageStyle` configuration entity for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Once we load the image style we want, we simply call its `buildUrl()` method
    to which we pass the URI of the file for which we want the URL. The first time
    this URL is accessed, the image variation gets created and stored to disk. Future
    requests will load it directly from there for improved performance.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are closing this chapter after covering a lot of different topics that have
    to do with working with files in Drupal 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'We started with a couple of introductory sections in which we outlined some
    general concepts such as the various filesystems (storages) that Drupal 8 uses,
    as well as how stream wrappers come into play for working with them. We also introduced
    the different ways to work with files: *managed* versus *unmanaged*.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we dove into working with *managed files* and created an image field on
    our Product entity type so that we could import images into it. The other example
    of working with *managed* files had us create a new Product importer based on
    a CSV file of data and we also saw how to upload, read and process such a file,
    as well as manually track its usage. As a parenthesis, we introduced a very powerful
    feature of Drupal 8 that allows us to hook into the entity CRUD operations and
    perform actions whenever these are fired. This is a majorly important technique
    module developers typically use in Drupal.
  prefs: []
  type: TYPE_NORMAL
- en: We then switched gears and implemented our own stream wrapper to serve our imaginary
    remote API that stored the product images. Moreover, we talked about working with
    *unmanaged* files and some of the functions we can use for this—things similar
    to *managed* files except the function names are different and there are no File
    entities or usage tracking them.
  prefs: []
  type: TYPE_NORMAL
- en: We then continued with the private filesystem and a talk about what this serves
    and how we can work with it to control access to our own files. As opposed to
    allowing users to bypass Drupal and download files from the public filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we finished the chapter with a look at the APIs surrounding images
    and how we can use toolkits to process images, both manually and as part of image
    styles. And even more useful, we saw how we can render images in all sorts of
    ways in Drupal 8 and get our hands on image style URLs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, we will look at automated testing and how we
    can ensure that our code works and that we don't introduce regressions along the
    way.
  prefs: []
  type: TYPE_NORMAL
