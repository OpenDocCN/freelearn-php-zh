- en: Working with Files and Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件和图像
- en: Drupal comes with many capabilities for handling and manipulating files and
    images and has been adding to its toolset more and more with recent versions.
    Of course, this is not to say that media management has not been always a pain
    point for Drupal developers. In Drupal 7, a complicated suite of contributed modules
    was needed to achieve a basic level of functionality, something that users of
    "competitors" like WordPress enjoy out of the box. In Drupal 8, there is more
    emphasis placed on media management, and with each release Media capabilities
    have gone into core. The Media (entity) module, with its essential source plugins
    for supporting Images, Files, Remote Videos (Oembed) and Audio, as well as the
    experimental Media library, make for great advancements in the area. And together
    with popular contributed modules such as Entity Browser, a lot of this gap has
    been filled.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 内置了许多处理和操作文件和图像的能力，并且随着最近版本的更新，其工具集也在不断增加。当然，这并不是说媒体管理从未是 Drupal 开发者的痛点。在
    Drupal 7 中，需要一套复杂的贡献模块来实现基本的功能，而像 WordPress 这样的“竞争对手”用户可以开箱即用享受这些功能。在 Drupal 8
    中，对媒体管理的重视程度更高，并且随着每个版本的发布，媒体功能已经集成到核心中。媒体（实体）模块，包括其支持图像、文件、远程视频（Oembed）和音频的基本源插件，以及实验性的媒体库，在该领域取得了重大进步。此外，与流行的贡献模块如实体浏览器一起，许多差距已经得到填补。
- en: In this chapter, we will look at how we can work with files and images in Drupal,
    supported by the core features. Although the Media module allows developers to
    provide new Source plugins to expose media entities to all sorts of types of media,
    we won't be going into this quite advanced topic. Instead, we'll focus on lower-level
    tools that can be used for working with files. And we will see some examples along
    the way. So, what are we going to discuss?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何在 Drupal 中使用核心功能处理文件和图像。尽管媒体模块允许开发者提供新的源插件来将媒体实体暴露给各种类型的媒体，但我们不会深入探讨这个相当高级的话题。相反，我们将专注于可以用于处理文件的底层工具，并在过程中展示一些示例。那么，我们将讨论什么呢？
- en: First, we are going to get an understanding of the Drupal *filesystems*. Developers
    from previous versions of Drupal should already be familiar with these in theory,
    and we will see how these work in Drupal 8\. Related to this, we're going to talk
    about *stream wrappers* and how Drupal handles native PHP file operations. We
    will even create our own custom stream wrapper a bit later in the chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将了解 Drupal 的*文件系统*。来自先前版本的 Drupal 的开发者应该已经在理论上熟悉这些，我们将看到这些在 Drupal 8 中的工作方式。与此相关，我们将讨论*流包装器*以及
    Drupal 如何处理原生 PHP 文件操作。我们甚至将在本章稍后创建我们自己的自定义流包装器。
- en: Then, we will talk a bit about the different ways to handle files in Drupal,
    namely, *managed* (tracked) and *unmanaged* files. In exemplifying the work with
    *managed* files, we will add an image field to our Product entity type and have
    images imported from a fictional remote environment. We will also create a brand-new
    CSV-based importer by which the product data is imported from a CSV file we read.
    In this process, we will note the Entity CRUD hooks, a very important extension
    point in Drupal 8, and see how we can use those in our example context.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将简要讨论在 Drupal 中处理文件的不同方式，即*管理*（跟踪）和*非管理*文件。在举例说明如何处理*管理*文件时，我们将向我们的产品实体类型添加一个图像字段，并将图像从虚构的远程环境中导入。我们还将创建一个全新的基于
    CSV 的导入器，通过该导入器从我们读取的 CSV 文件中导入产品数据。在这个过程中，我们将注意实体 CRUD 钩子，这是 Drupal 8 中非常重要的扩展点，并看看我们如何在示例上下文中使用它们。
- en: We will end the chapter by seeing how we can work with various APIs that deal
    specifically with images, especially for manipulating them via image toolkits
    and working with image styles. So let's get to it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章的结尾放在如何使用专门处理图像的各种 API 上，特别是通过图像工具包进行图像操作以及处理图像样式。让我们开始吧。
- en: The filesystem
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统
- en: 'Drupal defines four main types of file storage for any given site: the *public*,
    the *private,* the *temporary* and the *translation* filesystems. When installing
    Drupal, the folders that map to these filesystems are created automatically. In
    case that fails—most likely due to permission issues—we have to create them ourselves
    and give them the correct permissions. Drupal takes care of the rest (for example,
    adds relevant `.htaccess` files for security reasons). Make sure you check out
    the documentation on [Drupal.org](https://www.drupal.org/) for how to successfully
    install Drupal 8 if you are unsure how this works.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 为任何给定站点定义了四种主要的文件存储类型：公共、私有、临时和翻译文件系统。在安装 Drupal 时，映射到这些文件系统的文件夹会自动创建。如果失败——最可能是由于权限问题——我们必须自己创建它们并赋予它们正确的权限。Drupal
    会处理其余部分（例如，出于安全原因添加相关的 `.htaccess` 文件）。如果您不确定如何操作，请确保查看 [Drupal.org](https://www.drupal.org/)
    上的文档，了解如何成功安装 Drupal 8。
- en: Public files are available to the world at large for viewing or downloading.
    This is where things such as image content, logos, and anything that can be downloaded
    are stored. Your public file directory must exist somewhere under Drupal's root,
    and it must be readable and writeable by whatever *user* your web server is running
    under. Public files have no access restrictions. Anyone, at any time, can navigate
    directly to a public file and view or download it. This also means that accessing
    these files does not require Drupal to bootstrap.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 公共文件对所有人公开，可供查看或下载。这是存储图像内容、标志以及任何可以下载的文件的地方。您的公共文件目录必须位于 Drupal 根目录下的某个位置，并且必须可由您的
    web 服务器运行的用户读取和写入。公共文件没有访问限制。任何人，在任何时候，都可以直接导航到公共文件并查看或下载它。这也意味着访问这些文件不需要 Drupal
    引导。
- en: 'We can configure the path to the public filesystem in our `settings.php` file:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `settings.php` 文件中配置公共文件系统的路径：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Private files, on the other hand, are not available to the world for general
    download. Therefore, the private files' directory must not be accessible via the
    web. However, it still has to be writeable by the web server user. Isolating private
    files this way allows developers to control who can and can't access them. For
    instance, we could write a module that only allows users who have a specific role
    to access PDFs in the private filesystem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，私有文件对公众不可用，不能用于一般下载。因此，私有文件目录不能通过网络访问。然而，它仍然必须可由 web 服务器用户写入。通过这种方式隔离私有文件允许开发者控制谁可以访问它们。例如，我们可以编写一个模块，只允许具有特定角色的用户访问私有文件系统中的
    PDF 文件。
- en: 'We can configure the path to the private filesystem in our `settings.php` file:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `settings.php` 文件中配置私有文件系统的路径：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Temporary file storage is typically only used by Drupal for internal operations.
    When files are first saved by Drupal, they are initially written into the temporary
    filesystem so they can be checked for security issues. After they have been deemed
    safe, they are written to their final location.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 临时文件存储通常仅由 Drupal 用于内部操作。当文件首次由 Drupal 保存时，它们最初会写入临时文件系统，以便检查安全问题。一旦被认为安全，它们就会被写入最终位置。
- en: 'We can configure the path to the temporary filesystem through the UI:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 UI 配置临时文件系统的路径：
- en: '![](img/b23acfd3-953c-4d02-a981-50e876c256fc.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b23acfd3-953c-4d02-a981-50e876c256fc.png)'
- en: On the same configuration screen, we can also specify the default file download
    method for the site. By default, this is set to the public filesystem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的配置屏幕上，我们还可以指定站点的默认文件下载方法。默认情况下，这设置为公共文件系统。
- en: Finally, the translation file storage is used by Drupal for storing the `.po`
    files that contain string translation values that can be imported into the system
    in bulk. As with the temporary file storage, we can configure the location of
    translation files through the UI.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Drupal 使用翻译文件存储来存储包含可以批量导入系统的字符串翻译值的 `.po` 文件。与临时文件存储一样，我们可以通过 UI 配置翻译文件的位置。
- en: Stream wrappers
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流包装器
- en: 'If you''ve been writing PHP for a long time, you may have needed to work with
    local or remote files at some point. The following PHP code is a common way to
    read a file into a variable that you can do something with:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你长期编写 PHP，你可能在某个时候需要处理本地或远程文件。以下 PHP 代码是将文件读入变量的常见方式，你可以对它进行一些操作：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is pretty straightforward. We get a handle to a local file using `fopen()`
    and read 8 KB chunks of the file using `fread()` until `feof()` indicates that
    we've reached the end of the file. At that point, we use `fclose()` to close the
    handle. The contents of the file are now in the `$contents` variable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当直接。我们使用 `fopen()` 获取本地文件的句柄，并使用 `fread()` 读取文件的 8 KB 数据块，直到 `feof()` 指示我们已到达文件末尾。在那个点上，我们使用
    `fclose()` 关闭句柄。文件的内容现在存储在 `$$contents` 变量中。
- en: In addition to local files, we can also access remote ones through `fopen()`
    in the exact same way but by specifying the actual remote path instead of the
    local one we saw before (starting with `http(s)://`).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本地文件外，我们还可以通过 `fopen()` 以相同的方式访问远程文件，但需要指定实际的远程路径而不是之前看到的本地路径（以 `http(s)://`
    开头）。
- en: Data that we can access this way is streamable, meaning we can open it, close
    it, or seek to a specific place in it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过这种方式访问的数据是可流式的，这意味着我们可以打开它、关闭它，或者定位到文件中的特定位置。
- en: '*Stream wrappers* are an abstraction layer on top of these streams that tell
    PHP how to handle specific types of data. When using a stream wrapper, we refer
    to the file just like a traditional URL—`scheme://target`. As a matter of fact,
    the previous example uses one of PHP''s built-in stream wrappers: the `file://`
    wrapper for accessing files on local storage. It is actually the default scheme
    when none is specified, so that is why we got away with omitting it and just adding
    the file path. Had the file been on a remote location, we would have used something
    like `http://example.com/file/path/image.jpg`. That is another PHP built-in stream
    wrapper: `http://` (for the HTTP protocol).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*流包装器* 是在这些流之上的一个抽象层，告诉 PHP 如何处理特定类型的数据。当使用流包装器时，我们就像引用传统 URL 一样引用文件——`scheme://target`。事实上，之前的例子使用了
    PHP 的内置流包装器之一：用于访问本地存储文件的 `file://` 包装器。实际上，这是默认方案，如果没有指定，所以我们可以省略它，只添加文件路径。如果文件位于远程位置，我们会使用类似
    `http://example.com/file/path/image.jpg` 的东西。这是另一个 PHP 内置流包装器：`http://`（用于 HTTP
    协议）。'
- en: If that's not enough, PHP also allows us to define our own wrappers for schemes
    that PHP does not handle out of the box; the Drupal File API was built to take
    advantage of this. This is where we link back to the different types of file storage
    we talked about earlier, as they all have their own stream wrappers defined by
    Drupal.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不够，PHP 还允许我们为 PHP 默认不处理的方案定义自己的包装器；Drupal 文件 API 就是构建来利用这一点的。这就是我们回溯到之前讨论的不同类型的文件存储的地方，因为它们都有自己的流包装器，由
    Drupal 定义。
- en: The public filesystem uses the rather known `public://` stream wrapper, the
    private one uses `private://`, the temporary one `temporary://` and the translation
    one `translations://`. These map to the local file paths that we defined in the
    `settings.php` (or UI). Later in the chapter we will see how we can define our
    own stream wrapper and what some of the things that go into it are. First, though,
    let's talk a bit about the different ways we can manage files in Drupal 8.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 公共文件系统使用相当知名的 `public://` 流包装器，私有文件系统使用 `private://`，临时文件系统使用 `temporary://`，翻译文件系统使用
    `translations://`。这些映射到我们在 `settings.php`（或用户界面）中定义的本地文件路径。在章节的后面部分，我们将看到如何定义我们自己的流包装器以及其中包含的一些内容。不过，首先让我们谈谈在
    Drupal 8 中管理文件的不同方式。
- en: Managed versus unmanaged files
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理文件与未管理文件
- en: 'The Drupal File API allows us to handle files in two different ways. Files
    essentially boil down to two categories: they are either *managed* or *unmanaged*.
    The difference between the two lies in the way the files are used.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 文件 API 允许我们以两种不同的方式处理文件。文件本质上归结为两类：它们要么是 *管理的*，要么是 *未管理的*。这两种文件之间的区别在于它们的使用方式。
- en: '*Managed* files work hand in hand with the Entity system and are, in fact,
    tied to File entities. So whenever we create a *managed* file, an entity gets
    created for it as well, which we can use in all sorts of ways. And the table where
    these records are stored is called `file_managed`. Moreover, a key aspect of *managed*
    files is the fact that their usage is tracked. This means that if we reference
    them on an entity or even manually indicate that we use them, this usage is tracked
    in a secondary table called `file_usage`. This way, we can see where each file
    is used and how many times, and Drupal even provides a way to delete "orphaned"
    files after a specific time in case they are no longer needed.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*管理*文件与实体系统紧密协作，实际上是与文件实体相关联。因此，每当我们创建一个*管理*文件时，都会为其创建一个实体，我们可以以各种方式使用它。这些记录存储的表称为`file_managed`。此外，*管理*文件的一个关键方面是它们的用法是可跟踪的。这意味着如果我们在一个实体上引用它们或甚至手动指示我们使用它们，这种使用情况将在名为`file_usage`的辅助表中跟踪。这样，我们可以看到每个文件在哪里被使用以及使用次数，Drupal甚至提供了一个在特定时间后删除“孤儿”文件的方法，以防它们不再需要。'
- en: A notable example of using *managed* files is the simple `Image` field type
    that we can add to an entity type. Using these fields, we can upload a file and
    *attach* it to the respective entity. This attachment is nothing more than a special
    (tracked) entity reference between the two entities.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*管理*文件的一个显著例子是我们可以添加到实体类型的简单`Image`字段类型。使用这些字段，我们可以上传一个文件并将其*附加*到相应的实体。这种附件仅仅是两个实体之间的一种特殊（跟踪）实体引用。
- en: By understanding how *managed* files are used, it's not difficult to anticipate
    what *unmanaged* files are. The latter are the files we upload to make use of
    for various reasons but that, of course, do not need to be *attached* to any entity
    or have their usage tracked.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解*管理*文件的使用方式，预测*非管理*文件并不困难。后者是我们出于各种原因上传的文件，但当然不需要将其*附加*到任何实体或跟踪其使用情况。
- en: Using the File and Image fields
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文件和图像字段
- en: In order to demonstrate how to work with *managed* files, we will go back to
    our product entity importer and bring in some images for each product. However,
    in order to store them, we need to create a field on the Product entity. This
    will be an *image* field.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何与*管理*文件一起工作，我们将回到我们的产品实体导入器，并为每个产品引入一些图像。然而，为了存储它们，我们需要在产品实体上创建一个字段。这将是一个*图像*字段。
- en: 'Instead of creating this field through the UI and attaching it to a bundle,
    let''s do it the programmatic way and make it a base field (available on all bundles).
    We won''t need to do anything complex; for now we are only interested in a basic
    field that we can use to store the images we bring in from the remote API. It
    can look something like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不通过UI创建此字段并将其附加到包中，而是以编程方式完成，使其成为一个基础字段（在所有包上可用）。我们现在不需要做任何复杂的事情；目前我们只对可以用来存储从远程API引入的图像的基本字段感兴趣。它可以看起来像这样：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you remember from [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml),
    *Data Modeling and Storage*, and [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml),
    *Your Own Custom Entity and Plugin Types*, we are creating a base field definition
    that, in this case, is of the type `image`. This is the `FieldType` plugin ID
    of the `ImageItem` field type. So that is where we need to look and see what kind
    of field and storage options we may have. For example, we can have a file extension
    limitation (which by default contains `png`, `gif`, `jpg`, and `jpeg`) and things
    like `alt` and `title` attributes, as well as image dimension configuration. Do
    check out `ImageItem` to get an idea of the possible storage and field settings.
    However, we are fine with the defaults in this case so we don't even have any
    field settings.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得[第6章](77cab458-5612-468c-8010-12385708eb81.xhtml)“数据建模与存储”和[第7章](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml)“自定义实体和插件类型”，我们正在创建一个基础字段定义，在这种情况下，它是`image`类型。这是`ImageItem`字段类型的`FieldType`插件ID。因此，我们需要查看并了解可能有哪些字段和存储选项。例如，我们可以设置文件扩展名限制（默认包含`png`、`gif`、`jpg`和`jpeg`）以及`alt`和`title`属性，以及图像尺寸配置。请检查`ImageItem`以了解可能的存储和字段设置。然而，在这种情况下，我们使用默认设置，因此甚至没有任何字段设置。
- en: Another interesting thing to notice is that `ImageItem` extends the `FileItem`
    field type, which is a standalone `FieldType` plugin that we can use. However,
    it is more generic and lends itself for use with any kind of file upload situation.
    Since we are dealing with images, we might as well take advantage of the specific
    field type.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的有趣之处是`ImageItem`扩展了`FileItem`字段类型，这是一个独立的`FieldType`插件，我们可以使用。然而，它更通用，适用于任何类型的文件上传情况。由于我们处理的是图像，我们不妨利用特定的字段类型。
- en: For the moment, we do not configure our image field to have any kind of display.
    We'll look into that a bit later. However, we do specify the widget it should
    use on the entity form, namely the `FieldWidget` plugin with the ID of `image_image`.
    This maps to the default `ImageWidget` field widget. But again, we are fine with
    the setting defaults, so we don't specify anything extra.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们不需要配置我们的图像字段以显示任何类型。我们稍后再来看这个问题。然而，我们确实指定了在实体表单上它应该使用的部件，即ID为`image_image`的`FieldWidget`插件。这映射到默认的`ImageWidget`字段部件。但同样，我们对默认设置感到满意，所以没有指定任何额外的内容。
- en: 'With this, our field definition is done. To have Drupal create the necessary
    database tables, we need to run the Drush command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们的字段定义就完成了。为了让Drupal创建必要的数据库表，我们需要运行Drush命令：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now let''s create the interface methods for easily accessing and setting the
    images:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建接口方法，以便轻松访问和设置图像：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The getter method is supposed to return a `FileInterface` object (which is
    the actual File entity), while the setter is supposed to receive the ID (`fid`)
    of the File entity to save. As for the implementations, it should not be anything
    new to us:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 获取方法应该返回一个`FileInterface`对象（这是实际的文件实体），而设置方法应该接收要保存的文件实体的ID（`fid`）。至于实现，对我们来说不应该有任何新内容：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this, we are ready to proceed with the import of images from the remote
    API.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就准备好从远程API导入图像了。
- en: For taking advantage of the media management power in Drupal 8, instead of Image
    or File fields, you'd create entity reference fields to Media entities. And on
    the latter you'd create these fields. As such, Media entities basically wrap the
    File entities to provide some additional functionality and expose them to all
    the goodies of media management. For now, we work directly with these field types
    to learn about low-level file handling without the overhead of Media.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用Drupal 8中的媒体管理功能，而不是使用图像或文件字段，我们会创建指向媒体实体的实体引用字段。在后者上创建这些字段。因此，媒体实体基本上封装了文件实体，以提供一些额外的功能，并将它们暴露给所有媒体管理的优点。目前，我们直接与这些字段类型一起工作，以了解低级文件处理，而不需要媒体的开销。
- en: Working with managed files
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与管理文件一起工作
- en: In this section, we will look at two examples of working with managed files.
    First, we will see how we can import product images from our fictional remote
    JSON-based API. Second, we will see how to create a custom form element that allows
    us to upload a file and use it in a brand new CSV-based importer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看两个与管理工作文件一起工作的示例。首先，我们将看到如何从我们的虚构远程基于JSON的API导入产品图像。其次，我们将看到如何创建一个自定义表单元素，允许我们上传文件并在全新的基于CSV的导入器中使用它。
- en: Attaching managed files to entities
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将管理文件附加到实体
- en: 'Now that we have our product image field in place and we can store images,
    let''s revisit our JSON response that contains the product data and assume it
    looks something like this now:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了产品图像字段并且可以存储图像，让我们重新审视包含产品数据的JSON响应，并假设它现在看起来像这样：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What's new is the addition of the `image` key for each product, which simply
    references a filename for the image that goes with the respective product. The
    actual location of the images is at some other path we need to include in the
    code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 新增的是为每个产品添加了`image`键，它简单地引用了与相应产品一起的图像文件名。图像的实际位置在代码中需要包含的其他路径上。
- en: 'Going back to our `JsonImporter::persistProduct()` method, let''s delegate
    the handling of the image import to a helper method called `handleProductImage()`.
    We need to call this method both if we are creating a new Product entity and if
    we are updating an existing one (right before saving):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`JsonImporter::persistProduct()`方法，让我们将图像导入的处理委托给一个名为`handleProductImage()`的辅助方法。如果我们正在创建一个新的产品实体或者更新一个现有的实体（在保存之前），我们都需要调用这个方法：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And this is what the actual method looks like:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的方法看起来是这样的：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And the new *use* statement at the top:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以及顶部的新`use`语句：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we get the name of the image. Then we construct the path to where the
    product images are stored. In this example, it's left blank, but if the example
    were to work, we'd have to add a real path there. I leave that up to you for now.
    If you want to test it out, create a local folder with some images and reference
    that.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取图像的名称。然后我们构建产品图像存储路径。在这个例子中，它是空的，但如果示例要工作，我们必须在那里添加一个真实路径。我现在把这个留给你。如果你想测试它，创建一个包含一些图像的本地文件夹并引用它。
- en: 'Using the native `file_get_contents()` function, we load the data of the image
    from the remote environment into a string. We then pass this string to the `file_save_data()` function
    which saves a new *managed* file to the public filesystem. This function takes
    three parameters: the data to be saved, the URI of the destination, and a flag
    indicating what to do if a file with the same name already exists. You''ll notice
    that we used the Drupal `public://` stream wrapper to build the URI and we already
    know which folder this maps to.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本地的`file_get_contents()`函数，我们将图像数据从远程环境加载到字符串中。然后我们将这个字符串传递给`file_save_data()`函数，该函数将新的*托管*文件保存到公共文件系统中。此函数接受三个参数：要保存的数据、目标URI以及一个标志，指示如果存在同名文件将执行什么操作。你会注意到我们使用了Drupal的`public://`流包装器来构建URI，并且我们已经知道它映射到哪个文件夹。
- en: As for the third parameter, we chose to replace the file in case one already
    exists. The alternative would have been to either use the `EXISTS_RENAME` or `EXISTS_ERROR`
    constants of the same interface. The first would have created a new file whose
    name would have gotten a number appended until the name became unique. The second
    would have simply not done anything and returned FALSE.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 至于第三个参数，我们选择在文件已存在的情况下替换该文件。另一种选择是使用相同接口的`EXISTS_RENAME`或`EXISTS_ERROR`常量。前者会创建一个新文件，其名称会附加一个数字，直到名称变得唯一。后者将简单地不执行任何操作并返回FALSE。
- en: If all goes well, this function returns a `File` entity (that implements `FileInterface`)
    whose ID we can use in the Product image setter method. With that in place, we
    can synchronize also the individual product images.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，此函数将返回一个`File`实体（实现了`FileInterface`），我们可以使用其ID在产品图像设置方法中。有了这个，我们还可以同步单个产品图像。
- en: If you run into issues after this, make sure you create the destination folder
    and have all the permissions in order in the public filesystem to allow the copy
    to take place properly. In the next section you'll learn about some helper functions
    you can use to better prepare with the destination folder.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在此之后遇到问题，请确保创建目标文件夹，并在公共文件系统中拥有所有必要的权限，以便正确地执行复制。在下一节中，你将了解一些可以帮助你更好地准备目标文件夹的辅助函数。
- en: Moreover, in our database, a record is created in the `file_usage` table to
    indicate that this file is being used on the respective Product entity.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在我们的数据库中，`file_usage`表中会创建一个记录，以指示该文件正在被相应的产品实体使用。
- en: Helpful functions for dealing with managed files
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理托管文件的有用函数
- en: Apart from the staple `file_save_data()` function, we have a few other ones
    that can come in handy if we are dealing with *managed* files. Here's a few of
    them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了主要的`file_save_data()`函数外，我们还有一些其他函数，在处理*托管*文件时可能会很有用。以下是一些例子。
- en: 'If we want to copy a file from one place to another while making sure a new
    database record is created, we can use `file_copy()`. It takes three parameters:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从一个地方复制文件到另一个地方，同时确保创建一个新的数据库记录，我们可以使用`file_copy()`。它接受三个参数：
- en: The `FileInterface` entity that needs to be copied
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要复制的`FileInterface`实体
- en: The destination URI where it should go
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该放置的目标URI
- en: The flag indicating what to do in case a file with the same name exists
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示在同名文件存在时如何处理的标志
- en: The parameters are the same as for `file_save_data()`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 参数与`file_save_data()`相同。
- en: Apart from the actual copying, this function also invokes `hook_file_copy()`
    which allows modules to respond to files being copied.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实际的复制操作外，此函数还会调用`hook_file_copy()`，允许模块对正在复制的文件做出响应。
- en: Very similar to `file_copy()`, we also have `file_move()` which takes the same
    set of parameters but instead performs a file move. The database entry of the
    File entity gets updated to reflect the new file path. And `hook_file_move()`
    is invoked to allow modules to respond to this action.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与`file_copy()`非常相似，我们还有一个`file_move()`，它接受相同的参数集，但执行文件移动操作。文件实体的数据库条目会更新以反映新的文件路径。并且会调用`hook_file_move()`以允许模块对此操作做出响应。
- en: 'Not strictly related to *managed* files, but rather useful in all cases, we
    also have the `\Drupal\Core\File\FileSystem` service (accessible via the `file_system`
    service name), which contains all sorts of useful methods for dealing with files.
    We''ll see some of them when we talk about *unmanaged* files. But one that is
    useful also for *managed* files is `::prepareDirectory()` which we can use to
    ensure the file destination is correct. It takes two arguments: the directory
    (a string representation of the path or stream URI) and a flag indicating what
    to do about the folder (constants on the interface):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与 *管理* 文件不是严格相关，但在所有情况下都很有用，我们还有 `\Drupal\Core\File\FileSystem` 服务（通过 `file_system`
    服务名称访问），它包含处理文件的各种有用方法。当我们谈到 *非管理* 文件时，我们会看到其中的一些。但其中一个对 *管理* 文件也很有用的是 `::prepareDirectory()`
    方法，我们可以用它来确保文件目标正确。它接受两个参数：目录（路径的字符串表示或流 URI）和一个标志，指示对文件夹的操作（接口上的常量）：
- en: '`FileSystemInterface::CREATE_DIRECTORY` : Will create the directory if it doesn''t
    already exist'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileSystemInterface::CREATE_DIRECTORY`：如果目录不存在，则创建目录'
- en: '`FileSystemInterface::MODIFY_PERMISSION` : Will make the directory writable
    if it is found to be read-only'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileSystemInterface::MODIFY_PERMISSION`：如果发现目录是只读的，则使其可写'
- en: This function returns `TRUE` if the folder is good to go as a destination or
    `FALSE` if something went wrong or the folder doesn't exist.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数如果文件夹可以作为目标使用则返回 `TRUE`，如果出现错误或文件夹不存在则返回 `FALSE`。
- en: Managed file uploads
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理文件上传
- en: 'Next, we are going to look at how we can work with *managed* files using a
    custom form element. And to demonstrate this, we are finally going to create another
    Product importer plugin. This time, instead of a remote JSON resource, we will
    allow users to upload a CSV file that contains product data and imports that into
    Product entities. This is what the example CSV data looks like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何使用自定义表单元素来处理 *管理* 文件。为了演示这一点，我们最终将创建另一个产品导入插件。这次，我们将允许用户上传包含产品数据的
    CSV 文件，并将其导入到产品实体中。这就是示例 CSV 数据的样子：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It basically has the same kind of data as the JSON resource we've been looking
    at so far but without the image reference. So let's get going with our new plugin
    class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上与我们迄今为止一直在查看的 JSON 资源具有相同类型的数据，但没有图像引用。所以让我们开始使用我们的新插件类。
- en: 'Here is our starting point:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的起点：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We start by extending from the `ImporterBase` class and implement the obligatory
    `import()` method. Like before, we delegate to `getData()` to retrieve the product
    information, but in this case we simply loop over the resulting records and use
    the `persistProduct()` method to save the Product entities. So no batch operations.
    Apart from no longer saving images, this latter method looks exactly like the
    one from the `JsonImporter`, so I won't be copying it over again. But it makes
    for a good homework assignment to try to move it to the base class and abstract
    away the dynamic portions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从 `ImporterBase` 类扩展，并实现必需的 `import()` 方法。像之前一样，我们将委托给 `getData()` 来检索产品信息，但在这个案例中，我们只是遍历结果记录，并使用
    `persistProduct()` 方法来保存产品实体。所以没有批处理操作。除了不再保存图像外，这个后者的方法看起来与 `JsonImporter` 中的方法完全一样，所以我不打算再次复制它。但这是一个很好的家庭作业，尝试将其移动到基类并抽象出动态部分。
- en: Managed file form element
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理文件表单元素
- en: 'The other obligatory method we need to implement is `getConfigurationForm()`,
    by which we define the form elements needed to configure this particular plugin.
    Here, we will create the `file` field allowing users to upload the CSV file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要实现的其他必需方法是 `getConfigurationForm()`，通过它我们定义配置此特定插件所需的表单元素。在这里，我们将创建 `file`
    字段，允许用户上传 CSV 文件：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The form element type is called `managed_file` (implemented by the `ManagedFile`
    form element class). The rest of the definition is straightforward. However, there
    are a couple of problems.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 表单元素类型称为 `managed_file`（由 `ManagedFile` 表单元素类实现）。其余的定义很简单。然而，有几个问题。
- en: 'First, by default, using this form element, files are uploaded to the `temporary://`
    filesystem of Drupal. Since we don''t want that, we need to specify an upload
    location:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，默认情况下，使用这个表单元素，文件会被上传到 Drupal 的 `temporary://` 文件系统。由于我们不希望这样，我们需要指定一个上传位置：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The root of our public files folder will suffice for this example as we assume
    the file does not contain any sensitive information. If so, we could upload it
    to the `private://` one and control who gets access. We'll talk about how that
    works later in the chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们公共文件文件夹的根目录就足够了，因为我们假设文件不包含任何敏感信息。如果是这样，我们可以将其上传到 `private://`，并控制谁可以访问。我们将在本章后面讨论它是如何工作的。
- en: 'Second, by default, using this form element, the *allowed* file extensions
    for upload are limited to `jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp`.
    So if we want to allow CSV files, we need to specify the extension in a list of
    allowed upload extensions. And we do this by overriding the default upload validators:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，默认情况下，使用此表单元素，允许上传的文件扩展名限于 `jpg jpeg gif png txt doc xls pdf ppt pps odt
    ods odp`。因此，如果我们想允许 CSV 文件，我们需要在允许上传的扩展名列表中指定扩展名。我们通过覆盖默认上传验证器来完成此操作：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is an array of validator callbacks we want Drupal to run when the file
    is uploaded. And allowing only CSV files is enough for our purposes. But another
    handy validator we could use is `file_validate_size()`. Moreover, we can implement
    `hook_file_validate()` ourselves and perform any custom validation to the files
    being uploaded. So that's also something to keep in mind when dealing with validation
    files that don't belong to your modules.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个验证器回调数组，我们希望 Drupal 在文件上传时运行。仅允许 CSV 文件就足够我们使用了。但另一个我们可能使用的实用验证器是 `file_validate_size()`。此外，我们可以实现
    `hook_file_validate()` 并对上传的文件执行任何自定义验证。所以这也是处理不属于您模块的验证文件时需要记住的事情。
- en: 'With this, our plugin configuration form is in place; it looks something like
    this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们的插件配置表单已经就绪；它看起来像这样：
- en: '![](img/0495cf38-f200-4e96-8fd7-f8a98bc4c7b0.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0495cf38-f200-4e96-8fd7-f8a98bc4c7b0.png)'
- en: However, there is still something we need to do in order for the uploaded file
    to be *managed* properly. When using this form element, the file gets correctly
    uploaded and a record is added to the `file_managed` table. So we get our `File`
    entity. However, its status is not permanent because it doesn't have any usages.
    There are no records for it in the `file_usage` table. How could there be? So
    what we need to do is handle that ourselves and basically tell Drupal that the
    file uploaded in this form is *used* by the respective Importer configuration
    entity. And to do this, we need to know when the file is saved onto the entity,
    changed, and deleted.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还需要做一些事情，以便正确地管理上传的文件。当使用此表单元素时，文件会被正确上传，并在 `file_managed` 表中添加一条记录。因此，我们得到了
    `File` 实体。然而，它的状态不是永久的，因为它没有任何用途。在 `file_usage` 表中没有关于它的记录。怎么会这样呢？所以我们需要自己处理这个问题，基本上告诉
    Drupal，在此表单中上传的文件是由相应的导入器配置实体所使用的。为此，我们需要知道文件何时被保存到实体中、何时更改以及何时被删除。
- en: 'With this, we can also learn about something very important that we skipped
    in [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml), *Data Modeling and
    Storage*, and [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml), *Your Own
    Custom Entity and Plugin Types:* entity CRUD hooks. But right before we jump into
    that, let''s not forget about the configuration schema of this new configuration
    item—the `file` key of the plugin configuration:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们还可以了解我们在[第 6 章](77cab458-5612-468c-8010-12385708eb81.xhtml)，*数据建模和存储*，以及[第
    7 章](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml)，*您的自定义实体和插件类型:* 实体 CRUD 钩子中跳过的一些非常重要的内容。但在我们深入之前，我们不要忘记这个新配置项的配置方案——插件配置中的
    `file` 键：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are doing the same as we did for the `url` key of the JSON importer but,
    in this case, we need to account for the fact that `file` is actually an array.
    So we define it as a sequence whose individual items are integers. Feel free to
    check [Chapter 6](77cab458-5612-468c-8010-12385708eb81.xhtml), *Data Modeling
    and Storage*, for more information on configuration schemas whenever you need
    a reminder.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在做与 JSON 导入器的 `url` 键相同的事情，但在这个情况下，我们需要考虑到 `file` 实际上是一个数组。因此，我们将其定义为一个序列，其单个项是整数。如果您需要提醒，随时查看[第
    6 章](77cab458-5612-468c-8010-12385708eb81.xhtml)，*数据建模和存储*，了解更多关于配置方案的信息。
- en: Entity CRUD hooks
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体 CRUD 钩子
- en: Whenever entities are created, updated, or deleted, a set of hooks are fired
    that allow us to act on this information. We can use these hooks simply to perform
    some actions whenever this happens or even make changes to the entity being saved.
    So let's see what we have.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时实体被创建、更新或删除，都会触发一系列钩子，使我们能够对此信息采取行动。我们可以简单地使用这些钩子在发生这种情况时执行一些操作，甚至可以更改正在保存的实体。那么，让我们看看我们有什么。
- en: A very useful one is `hook_entity_presave()`, which gets fired during the saving
    process of an entity (both content and configuration). This applies to both when
    the entity is first created, as well as when it is being updated. Moreover, it
    allows us to inspect the original entity and detect changes made to it. And finally,
    since the entity has not yet been persisted, it allows us to make changes to it
    ourselves. So very powerful stuff.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常有用的是`hook_entity_presave()`，它在实体保存过程中触发（无论是内容还是配置）。这适用于实体首次创建时，以及当它被更新时。此外，它允许我们检查原始实体并检测对其所做的更改。最后，由于实体尚未持久化，它允许我们自行对其进行更改。所以这是一些非常强大的功能。
- en: Since Drupal 8 is very flexible, we also have the `hook_ENTITY_TYPE_presave()`
    version which allows us to specifically target any entity type we want. We've
    already discussed the benefit of using more specific hooks to keep our code more
    organized as well as a little bit more performant. And this applies to all the
    entity CRUD hooks we are going to talk about next.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Drupal 8非常灵活，我们还有`hook_ENTITY_TYPE_presave()`版本，它允许我们特别针对我们想要的任何实体类型。我们之前已经讨论了使用更具体的钩子来保持代码更组织化以及提高性能的好处。这一点适用于我们接下来要讨论的所有实体CRUD钩子。
- en: Then we have `hook_entity_insert()` and `hook_entity_update()`, which get fired
    after an entity is created for the first time and after an entity is updated,
    respectively. We cannot make changes to the entity itself as it has already been
    saved, but they can come in handy at other times. The latter also give us access
    to the original entity if we want to compare any changes. And similarly, we have
    `hook_entity_delete()`, which gets fired when an entity is deleted.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有`hook_entity_insert()`和`hook_entity_update()`，分别是在实体首次创建后和实体更新后触发的。由于实体已经被保存，我们无法对其本身进行更改，但它们在其他时候可能会很有用。后者还允许我们访问原始实体，以便比较任何更改。同样，我们还有`hook_entity_delete()`，它在实体被删除时触发。
- en: Finally, we also have `hook_entity_load()` which allows us to perform actions
    whenever an entity is loaded. For example, we can tack on additional information
    if we want. So keep in mind these hooks, as they are going to be a very important
    tool in your module developer arsenal.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有`hook_entity_load()`，它允许我们在实体被加载时执行操作。例如，如果我们想添加额外的信息，我们可以这样做。所以请记住这些钩子，因为它们将成为你模块开发者工具箱中的非常重要的工具。
- en: Managed file usage service
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理文件使用服务
- en: Now that we have an idea of the available entity CRUD hooks, we can implement
    three of them to handle our *managed* file problem. Because, if you remember,
    *managed* files are actually represented by the `File` entity type, so the Entity
    CRUD hooks get fired for these as well.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了可用的实体CRUD钩子，我们可以实现其中的三个来处理我们的*管理*文件问题。因为，如果你记得的话，*管理*文件实际上是由`File`实体类型表示的，所以实体CRUD钩子也会为这些文件触发。
- en: To mark a file as being used by *something,* we can use the `DatabaseFileUsageBackend`
    service (`file.usage`), which is an implementation of the `FileUsageInterface`.
    This has a few handy methods that allow us to add a usage or delete it. That is
    actually what we are going to do next.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了标记一个文件被*某物*使用，我们可以使用`DatabaseFileUsageBackend`服务（`file.usage`），它是对`FileUsageInterface`的一个实现。这个服务有几个方便的方法，允许我们添加或删除使用记录。这正是我们接下来要做的。
- en: 'What we want to do first is add a file usage whenever a new Importer entity
    gets created (and a file uploaded with it):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想要做的是，每当创建新的导入器实体（以及与之一起上传的文件）时，添加文件使用记录：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are implementing the specific version of `hook_entity_insert()` for our
    own entity type, and the first thing we are checking is whether we are looking
    at one using the CSV plugin. We''re not interested in any importers that don''t
    have a CSV file upload. If we are, we get the File entity ID from the importer
    using a private helper function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在为我们的实体类型实现特定的`hook_entity_insert()`版本，我们首先检查的是是否正在使用CSV插件查看。我们不对没有CSV文件上传的任何导入器感兴趣。如果是的话，我们使用一个私有辅助函数从导入器中获取文件实体ID：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You'll notice that the `file` key in our plugin configuration array is an array
    of File IDs, even if we only uploaded one single file. That is just something
    we need to account for here (we did so also in our configuration schema earlier
    on).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在我们的插件配置数组中，`file`键是一个文件ID数组，即使我们只上传了一个单个文件。这只是我们需要在这里考虑的事情（我们也在我们的配置架构中这样做过）。
- en: Then, we load the File entity based on this ID and use the `file.usage` service
    to add a usage to it. The first parameter of the `add()` method is the File entity
    itself, the second is the module name that marks this usage, the third is the
    type of *thing* the file is used by, while the fourth is the ID of this *thing*.
    The latter two depend on the use case; we choose to go with our own notation (`config:importer`)
    to make it clear that we are talking about a configuration entity of the type
    `importer`. Of course, we used the ID of the entity.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们根据这个 ID 加载文件实体，并使用 `file.usage` 服务向其添加使用情况。`add()` 方法的第一个参数是文件实体本身，第二个是标记此使用的模块名称，第三个是文件被使用的
    *东西* 的类型，第四个是此 *东西* 的 ID。后两个取决于用例；我们选择使用自己的符号（`config:importer`）来清楚地表明我们正在谈论类型为
    `importer` 的配置实体。当然，我们使用了实体的 ID。
- en: With this, a new record will get created in the `file_usage` table whenever
    we save such an Importer entity for the first time. Now let's handle the case
    in which we delete this entity—we don't want this file usage lingering around,
    do we?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每当第一次保存此类导入器实体时，`file_usage` 表中都会创建一条新记录。现在让我们处理删除此实体的情况——我们不希望这个文件使用情况继续存在，对吧？
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Most of what we are doing in this specific version of `hook_entity_delete()`
    is the same as before. However, we are using the `delete()` method of the `file.usage`
    service but passing the same arguments. These `$type` and `$id` parameters are
    actually optional, so we can "un-use" multiple files at once. Moreover, we have
    an optional fifth parameter (the count) whereby we can specifically choose to
    remove more than one usage from this file. By default, this is 1, and that makes
    sense for us.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定版本的 `hook_entity_delete()` 中，我们做的许多事情与之前相同。然而，我们正在使用 `file.usage` 服务的 `delete()`
    方法，但传递相同的参数。这些 `$type` 和 `$id` 参数实际上是可选的，因此我们可以一次性“取消使用”多个文件。此外，我们还有一个可选的第五个参数（计数），我们可以通过它来特别选择从该文件中删除多个使用情况。默认情况下，这是
    1，这对我们来说是有意义的。
- en: 'Finally, we also want to account for the cases in which the user edits the
    importer entity and changes the CSV file. We want to make sure the old one is
    no longer marked as used for this Importer. And we can do this with `hook_entity_update()`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还想考虑用户编辑导入实体并更改 CSV 文件的情况。我们想要确保旧的文件不再被标记为用于此导入器。我们可以通过 `hook_entity_update()`
    来实现这一点：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are using the specific variant of this hook that only gets fired for Importer
    entities. Just like we''ve been doing so far. And as I mentioned, we can access
    the original entity (before the changes have been made to it) like so:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用这个钩子的特定变体，它只为导入器实体触发。就像我们到目前为止所做的那样。正如我提到的，我们可以这样访问原始实体（在对其做出更改之前）：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And if the File ID that was on the original entity is not the same as the one
    we are currently saving with it (meaning the file was changed), we can delete
    the usage of that old File ID.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果原始实体上的文件 ID 与我们当前保存的文件 ID 不相同（这意味着文件已更改），我们可以删除该旧文件 ID 的使用情况。
- en: Processing the CSV file
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 CSV 文件
- en: 'Now that our plugin configuration works—and uploaded files are properly managed
    and marked as used—it''s time to implement the `getData()`method by which we process
    the CSV file of the Importer entity. The result needs to be an array of product
    information as expected by the `import()` method we saw earlier. So we can have
    something like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在插件配置工作正常——上传的文件得到适当管理并标记为已使用——是时候实现 `getData()` 方法了，通过该方法我们处理导入器实体的 CSV 文件。结果需要是一个数组，其中包含我们之前看到的
    `import()` 方法期望的产品信息。所以我们可以有如下内容：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, quite expectedly, we check for the existence of the File ID in the Importer
    entity and load the corresponding File entity based on that. To do this, we use
    the entity manager we injected into the plugin base class. But then comes something
    new.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正如预期的那样，我们检查导入实体中文件 ID 的存在，并根据该 ID 加载相应的文件实体。为此，我们使用注入到插件基类中的实体管理器。但接下来出现了一些新情况。
- en: 'Once we have the File entity, we can ask it its URI, which will return something
    like this: `public://products.csv`. This is what is stored in the database. But
    in order to turn that into something useful, we need to use the *stream wrapper*
    that defines this filesystem. And to get that, we use the `StreamWrapperManager`
    service (`stream_wrapper_manager`) which has a handy method of returning the *stream
    wrapper* instance responsible for a given URI—`getViaUri()`. And once we have
    our `StreamWrapperInterface`, we can use its `realpath()` method to get the local
    path of the resource. We will come back to *stream wrappers* a bit later in this
    chapter and it will make more sense. But for the moment, it''s enough to understand
    that we are translating a URI in the `scheme://target` format into a useful path
    that we can use to create a new PHP-native `SplFileObject` instance, which, in
    turn, we can use to process the CSV file easily.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了文件实体，我们可以询问它的URI，它将返回类似这样的内容：`public://products.csv`。这就是存储在数据库中的内容。但是，为了将其转换为有用的东西，我们需要使用定义此文件系统的*流包装器*。为了获取它，我们使用`StreamWrapperManager`服务（`stream_wrapper_manager`），它有一个方便的方法可以返回负责给定URI的*流包装器*实例——`getViaUri()`。一旦我们有了`StreamWrapperInterface`，我们就可以使用它的`realpath()`方法来获取资源的本地路径。我们将在本章稍后回到*流包装器*，这将更有意义。但就目前而言，我们只需要理解我们将`scheme://target`格式的URI转换为我们可以用来创建新的PHP原生`SplFileObject`实例的有用路径，然后我们可以使用这个实例轻松地处理CSV文件。
- en: When creating the `SplFileObject`, we used the external URL of the file. This
    worked just fine and we were able to also demonstrate how we can get our hands
    on the external URL if we ever need to. But, as we will see in the next chapter,
    it will also work directly with the stream URI, and we will switch to this approach
    instead.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`SplFileObject`时，我们使用了文件的外部URL。这工作得很好，我们还能展示如果需要，我们如何获取外部URL。但是，正如我们将在下一章中看到的，它也可以直接与流URI一起工作，我们将切换到这种方法。
- en: With three lines of code we are basically done getting all the rows from the
    CSV into the `$data` array. However, we also want to make this data look a bit
    more like what the JSON resource looked like—a map where the keys are the field
    names and the values are the respective product data. And we also want this map
    to contain PHP standard objects instead of arrays. Therefore, we loop through
    the data, establish the CSV header values, and use those as the keys in each row
    of a new `$products` array of objects. Our end result will look exactly like the
    product information coming from the decoded JSON response.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 用三行代码，我们基本上就完成了将所有行从CSV文件中提取到`$data`数组中的工作。然而，我们还想让这些数据看起来更像是JSON资源的样子——一个键是字段名，值是相应产品数据的映射。我们还想让这个映射包含PHP标准对象而不是数组。因此，我们遍历数据，建立CSV标题值，并将这些值用作新`$products`数组中每一行的键。我们的最终结果将完全类似于从解码的JSON响应中获取的产品信息。
- en: 'And with this we are done. Well, not quite. We still need to inject the `StreamWrapperManager`
    service into our plugin. And to do that, we need to make sure we are injecting
    also all the things that the parent class needs and passing them along:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们就完成了。嗯，还不完全是。我们仍然需要将`StreamWrapperManager`服务注入到我们的插件中。为此，我们需要确保我们注入了父类需要的所有东西，并将它们传递下去：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And the new *use* statements at the top:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以及顶部的新的*use*语句：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Nothing we don't yet know how to do. However, there is one thing I'd like to
    point out here. In [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml), *Your
    Own Custom Entity and Plugin Types*, I mentioned how, at the time, I believed
    the Guzzle HTTP Client is a service that would be useful to all Importer plugins.
    Well, I was clearly wrong, as the CSV-based one we just created now doesn't need
    it. So there is no reason why it should be injected into it. What we need to do
    here is remove this dependency from the base plugin class and only use it in the
    JSON importer. However, I leave this up to you as homework.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有学到的东西。然而，这里有一件事我想指出。在[第7章](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml)“你自己的自定义实体和插件类型”中，我提到了当时我认为Guzzle
    HTTP客户端是一个对所有导入插件都很有用的服务。显然，我是错的，因为我们刚刚创建的基于CSV的插件不需要它。所以没有必要将其注入其中。我们需要在这里做的是从基础插件类中删除这个依赖关系，并且只在JSON导入器中使用它。然而，我将这个任务留给你作为作业。
- en: Our CSV Importer plugin is now complete. If we did everything correctly, we
    can now create a new Importer entity that uses it, upload a correct CSV file,
    and import some Product entities via our Drush command. How neat.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完成了CSV导入器插件。如果我们一切都做得正确，我们现在可以创建一个新的导入器实体，使用它，上传一个正确的CSV文件，并通过我们的Drush命令导入一些产品实体。多么方便。
- en: Our own stream wrapper
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的流包装器
- en: At the beginning of this chapter, we briefly talked about stream wrappers and
    what they are used for. We saw that Drupal comes with four mainstream wrappers
    that map to the various types of file storage it needs. Now it's time to see how
    we can create our own. And the main reason why we would want to implement one
    is to expose resources at a specific location to PHP's native filesystem functions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们简要地讨论了流包装器及其用途。我们了解到Drupal自带了四个主流包装器，它们映射到它所需的各类文件存储。现在，让我们看看我们如何创建自己的包装器。而我们想要实现一个包装器的主要原因，是为了将特定位置的资源暴露给PHP的本地文件系统函数。
- en: In this example, we will create a very simple stream wrapper that can basically
    only read the data from the resource. Just to keep things simple. And the data
    resource will be the product images hosted remotely (the ones we are importing
    via the JSON Importer). So there will be some rework there to use the new stream
    wrapper instead of the absolute URLs. Moreover, we will also learn how to use
    the site-wide settings service by which we can have environment-specific configurations
    set in the `settings.php` file and then read by our code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个非常简单的流包装器，它基本上只能从资源中读取数据。只是为了保持简单。数据资源将是远程托管的产品图片（我们通过JSON导入器导入的图片）。因此，我们需要进行一些修改，以使用新的流包装器而不是绝对URL。此外，我们还将学习如何使用全局设置服务，通过它可以设置特定环境的配置在`settings.php`文件中，然后由我们的代码读取。
- en: 'The native way of registering a stream wrapper in PHP is by using the `stream_wrapper_register()`
    function. However, in Drupal 8, we have an abstraction layer on top of that in
    the form of services. So a stream wrapper is a simple tagged service, albeit with
    many potential methods. Let''s see its definition, which we add to the `products.services.yml`
    file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中注册流包装器的本地方式是使用`stream_wrapper_register()`函数。然而，在Drupal 8中，我们有一个抽象层，以服务的形式存在。因此，流包装器是一个简单的标记服务，尽管它具有许多潜在的方法。让我们看看它的定义，我们将将其添加到`products.services.yml`文件中：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Nothing too complicated. The service is tagged with `stream_wrapper` and we
    use the `scheme` key to indicate the scheme of the wrapper. So the URIs will be
    in this format:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么太复杂的。服务被标记为`stream_wrapper`，我们使用`scheme`键来指示包装器的方案。因此，URI将采用以下格式：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: One important thing to note about stream wrapper services is that we cannot
    pass dependencies to them. The reason is that they are not instantiated the normal
    way (by the container) but arbitrarily by PHP whenever some of its methods need
    to be called. So if we need to use some services, we'll have to use the static
    way of loading them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 关于流包装器服务的一个重要注意事项是，我们不能向它们传递依赖项。原因是它们不是通过常规方式（通过容器）实例化的，而是在PHP需要调用其某些方法时任意实例化的。因此，如果我们需要使用某些服务，我们必须使用静态方式加载它们。
- en: The stream wrapper service class needs to implement `StreamWrapperInterface`
    which comes with a lot of methods. There are many possible filesystem interactions
    that PHP can do and these methods need to account for them all. However, we will
    only be focusing on a few specific ones that have to do with reading data. After
    all, our resources are remote and we don't even have a clue how to make changes
    to them over there. So for the rest of the methods, we will be returning FALSE
    to indicate that the operation cannot be performed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 流包装器服务类需要实现`StreamWrapperInterface`接口，该接口包含许多方法。PHP可以执行许多可能的文件系统交互，这些方法需要考虑所有这些交互。然而，我们只会关注与读取数据相关的一些特定方法。毕竟，我们的资源是远程的，我们甚至不知道如何在那里对其进行更改。因此，对于其余的方法，我们将返回FALSE以表示无法执行该操作。
- en: 'Let''s see this big class then:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个庞大的类：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first thing to look at is the constructor in which we statically load the
    `Settings` service and store it as a class property. And speaking of which, we
    also define a `$uri` property to hold the actual URI this wrapper *wraps* and
    a `$handle` property to hold a generic PHP resource handle.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要关注的是构造函数，我们在其中静态加载`Settings`服务并将其存储为类属性。说到这里，我们还定义了一个`$uri`属性来保存这个包装器实际封装的URI，以及一个`$handle`属性来保存通用的PHP资源句柄。
- en: The `getName()` and `getDescription()` methods are pretty straightforward and
    are used for identifying the stream wrapper, while the `getType()` method returns
    the type of stream. We'll go with the hidden type because we don't want it visible
    in the UI. It's strictly for programmatic use so that we can read our product
    images. Do check out the available types and their meanings by looking at the
    `StreamWrapperInterface` constants.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`getName()`和`getDescription()`方法相当直接，用于识别流包装器，而`getType()`方法返回流的类型。我们将使用隐藏类型，因为我们不希望在UI中可见。它是严格用于程序性使用的，这样我们就可以读取我们的产品图片。请通过查看`StreamWrapperInterface`常量来检查可用的类型及其含义。'
- en: 'Then, we have a getter and setter for the `$uri` property by which the Drupal
    `StreamWrapperManager` can create an instance of our wrapper based on a given
    URI. The `getTarget()` method is actually not in the interface but is a helper
    to extract a clean target from the URI (the target being the second part of the
    URI that comes after `scheme://`). And we use this method in `getExternalUrl()`,
    which is quite an important method responsible for returning an absolute URL to
    the resource in question. But here we also use our `Settings` service to get the
    `product_images_path` key. If you remember in the beginning of the chapter, we
    saw that the path to the public filesystem is defined in the `settings.php` file
    like so:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有`$uri`属性的getter和setter，通过它Drupal的`StreamWrapperManager`可以根据给定的URI创建我们包装器的实例。`getTarget()`方法实际上不在接口中，但它是一个辅助方法，用于从URI中提取干净的标靶（标靶是URI的第二部分，位于`scheme://`之后）。我们在`getExternalUrl()`中使用此方法，这是一个相当重要的方法，负责返回资源的绝对URL。但在这里，我们也使用我们的`Settings`服务来获取`product_images_path`键。如果你记得在章节开头，我们看到公共文件系统的路径是在`settings.php`文件中定义的，如下所示：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That `$settings` variable is the data array that is wrapped by the `Settings`
    service. So we want to do the same for defining our own remote path to the product
    images:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`$settings`变量是由`Settings`服务包装的数据数组。因此，我们希望为定义自己的产品图片远程路径做同样的事情：'
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This way we are not committing to Git the actual remote URL and we can also
    change it later if we want. And this is the URL we are reading inside the `getExternalUrl()`
    method.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就不需要在Git中提交实际的远程URL，我们也可以在需要时更改它。这正是我们在`getExternalUrl()`方法中读取的URL。
- en: The other pillar of our read-only stream wrapper is the ability to open a file
    handle to the resource and allow us to read the data from it. And the `stream_open()`
    method does this as it gets called when we run either `file_get_contents()` or
    `fopen()` on our URI. Using the `$mode` parameter, we ensure that the operation
    is read-only and return `FALSE` otherwise—we do not support *write* or other flags.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只读流包装器的另一个支柱是能够打开资源文件句柄，并允许我们从其中读取数据。`stream_open()`方法就是这样做的，当我们对URI运行`file_get_contents()`或`fopen()`时，它会调用。使用`$mode`参数，我们确保操作是只读的，否则返回`FALSE`——我们不支持写入或其他标志。
- en: Any mode can have `b` appended to it to indicate that the file should be opened
    in binary mode. So, where `r` indicates read-only, `rb` indicates read-only in
    binary mode.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 任何模式都可以附加`b`来表示文件应以二进制模式打开。所以，`r`表示只读，`rb`表示以二进制模式只读。
- en: The third argument is a bitmask of options defined by PHP. The one we're dealing
    with here is `STREAM_REPORT_ERRORS`, which indicates whether or not PHP errors
    should be suppressed (for instance, if a file is not found). The second is `STREAM_USE_PATH`,
    which indicates whether PHP's include path should be checked if a file is not
    found. This is not relevant to us, so we ignore it. If a file is found on the
    include path, then the fourth argument, (`$opened_url)`), should be set with the
    file's real path.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是由PHP定义的选项掩码。我们这里处理的是`STREAM_REPORT_ERRORS`，它表示是否应该抑制PHP错误（例如，如果文件未找到）。第二个是`STREAM_USE_PATH`，它表示如果文件未找到，是否应该检查PHP的包含路径。这与我们无关，所以我们忽略它。如果在包含路径上找到文件，那么第四个参数（`$opened_url`），应该设置为文件的实际路径。
- en: What we do then is translate the URI into the absolute URL of the external resource
    so that we can open a file handle on it. And in doing so, we make use of the `STREAM_REPORT_ERRORS`
    option to either prepend the `@` to the `fopen()` function or not (doing so suppresses
    errors). Finally, we store the reference to the resource handle and return a Boolean
    based on it to indicate whether the operation succeeded.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是将URI转换为外部资源的绝对URL，以便我们可以打开文件句柄。在这个过程中，我们使用`STREAM_REPORT_ERRORS`选项来决定是否在`fopen()`函数前添加`@`符号（这样做会抑制错误）。最后，我们存储资源句柄的引用，并根据它返回一个布尔值来指示操作是否成功。
- en: Finally, we also implement the `stream_read()`, `stream_eof()`, and `stream_close()`
    methods so that we can actually also stream the resources if we want to. As for
    the rest of the methods, as already mentioned, we return `FALSE`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还实现了`stream_read()`、`stream_eof()`和`stream_close()`方法，这样我们实际上也可以流式传输资源。至于其他方法，如前所述，我们返回`FALSE`。
- en: 'All we have to do now is clear the cache and make use of our stream. As long
    as we have a valid URL declared in the `settings.php` file, our stream should
    work fine. And here are the kinds of things we could do with a URI like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要做的就是清除缓存并利用我们的流。只要我们在`settings.php`文件中声明了一个有效的URL，我们的流应该可以正常工作。以下是我们可以使用此类URI进行的一些操作：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To get the entire file content into a string, we can do this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要将整个文件内容放入字符串中，我们可以这样做：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Or we can use the example from the beginning of the chapter and stream the
    file bit by bit:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用本章开头的例子，逐比特流文件：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: All these file operations, such as opening, reading, checking the end of a file
    and closing, are possible due to our `stream_*()` method implementations from
    the wrapper.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些文件操作，如打开、读取、检查文件末尾和关闭，都是由于我们在包装器中实现的`stream_*()`方法。
- en: And finally, maybe now it's also a bit clearer what we did when writing the
    CSV Importer and using the `StreamWrapperManager` to identify the stream wrapper
    responsible for a given URI, and based on that, the real path of the URI.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，也许现在写CSV导入器和使用`StreamWrapperManager`来识别给定URI负责的流包装器，以及基于此，URI的真实路径，也变得更清晰了。
- en: 'To end the section on stream wrappers, let''s do some clean-up work by refactoring
    a bit our `JsonImporter::handleProductImage()` method. Our logic there involved
    hardcoding the URL to the remote API, which is really not a good idea. Instead,
    now that we have our stream wrapper, we can go ahead and use it. We can replace
    this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束关于流包装器的部分，让我们通过重构一下我们的`JsonImporter::handleProductImage()`方法来做一些清理工作。我们那里的逻辑涉及硬编码远程API的URL，这实际上并不是一个好主意。现在，既然我们有流包装器，我们可以继续使用它。我们可以替换这个：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It's that simple. And now we can control the remote URL from outside the Git
    repository and, if it changes, we don't even have to alter our code. Granted,
    solely for this purpose, implementing a stream wrapper seems a bit excessive.
    After all, you can simply inject the `Settings` service and use the URL in the
    Importer plugin itself allowing for the same kind of flexibility. But we used
    the opportunity to learn about stream wrappers and how to create our own. And
    we even managed to find a small use case in the process.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。现在我们可以从Git仓库外部控制远程URL，如果它发生变化，我们甚至不需要更改我们的代码。当然，仅为此目的，实现流包装器似乎有点过度。毕竟，你可以简单地注入`Settings`服务，并在导入插件本身中使用URL，从而实现相同的灵活性。但我们利用这个机会学习了流包装器以及如何创建自己的包装器。我们甚至在过程中找到了一个小型的用例。
- en: Working with unmanaged files
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与非管理文件一起工作
- en: Working with *unmanaged* files is actually pretty similar to doing so with *managed*
    files, except that they are not tracked in the database using the File entity
    type. There is a set of helper functions similar to what we've seen for *managed*
    files that can be accessed through the `FileSystem` service I mentioned earlier.
    Let's see some examples.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 与*非管理*文件一起工作实际上与处理*管理*文件非常相似，只是它们不是使用文件实体类型在数据库中跟踪。有一组类似于我们之前看到的*管理*文件的辅助函数，可以通过我之前提到的`FileSystem`服务访问。让我们看看一些例子。
- en: 'To save a new file, we do almost like we did before with *managed* files:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存新文件，我们几乎和之前处理*管理*文件时一样：
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We load the file data from wherever and use the `saveData()` method on the service
    the same way as we did `file_save_data()`. The difference is that the file is
    going to be saved but no database record is created. So the only way to use it
    is to rely on the path it is saved at and either try to access it from the browser
    or use it for whatever purpose we need. This method returns the URI of where the
    file is now saved or `FALSE` if there was a problem with the operation. So if
    all went well with the previous example, `$path` would now be `public://tv.jpg`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从任何地方加载文件数据，并在服务上使用`saveData()`方法，就像我们使用`file_save_data()`一样。区别在于文件将被保存，但不会创建数据库记录。因此，唯一使用它的方法就是依赖于它保存的路径，或者尝试从浏览器访问它，或者用于我们需要的任何目的。此方法返回文件现在保存的URI或如果操作有问题则返回`FALSE`。所以如果前面的示例一切顺利，`$path`现在将是`public://tv.jpg`。
- en: And just like with the *managed* files, we also have a few other helpful methods
    in that service, such as `move()`, `copy()`, and `delete()`. I recommend you inspect
    that service to get more details on how these work.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 就像*管理*文件一样，我们也在该服务中提供了一些其他有用的方法，例如`move()`、`copy()`和`delete()`。我建议您检查该服务以获取有关这些方法如何工作的更多详细信息。
- en: Private filesystem
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有文件系统
- en: The private filesystem is used whenever we want to control access to the files
    being downloaded. Using the default public storage, users can get to the files
    simply by pointing to them in the browser, thereby bypassing Drupal completely.
    However, `.htaccess` rules prevent users from directly accessing any files in
    the private storage, making it necessary to create a route that delivers the requested
    file. It goes without saying that the latter is a hell of a lot less performant,
    as Drupal needs to be loaded for each file. Therefore, it's important to only
    use it when files should be restricted based on certain criteria.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要控制下载文件的访问权限时，会使用私有文件系统。使用默认的公共存储，用户只需在浏览器中指向文件即可访问它们，从而绕过Drupal。然而，`.htaccess`规则阻止用户直接访问私有存储中的任何文件，因此有必要创建一个提供请求文件的路径。不言而喻，后者性能要差得多，因为每次需要加载Drupal才能访问每个文件。因此，只有在基于某些标准需要限制文件访问时，才重要地使用它。
- en: Drupal already comes with a route and Controller ready to download private files,
    but we can create one as well if we really need to. For example, the image module
    does so in order to control the creation and download of image styles—`ImageStyleDownloadController`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal已经自带了一个用于下载私有文件的路径和控制器，但如果我们真的需要，我们也可以创建一个。例如，图像模块就是这样做的，以便控制图像样式的创建和下载——`ImageStyleDownloadController`。
- en: 'The route definition for the default Drupal path looks like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 默认Drupal路径的路由定义看起来是这样的：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is a bit of an odd route definition. We have a `{scheme}` parameter but
    which will be the actual file path requested for download. The URI scheme itself
    defaults to `private`, as illustrated by the signature of `FileDownloadController::download()`.
    Moreover, access is allowed at all times as Drupal delegates this check to other
    modules—as we will see in a minute.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有点奇怪的路径定义。我们有一个`{scheme}`参数，但将是实际请求下载的文件路径。URI方案本身默认为`private`，如`FileDownloadController::download()`的签名所示。此外，始终允许访问，因为Drupal将此检查委托给其他模块——我们将在下一分钟看到。
- en: 'If we look inside `FileDownloadController::download()`, we can see that it
    isn''t actually much that it is doing itself. However, we also note that in the
    first line, it looks for the query parameter called `file` in order to get the
    URI of the requested file:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`FileDownloadController::download()`内部，我们可以看到它实际上并没有做很多。然而，我们也注意到在第一行，它寻找名为`file`的查询参数，以便获取请求文件的URI：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: But based on the route definition, we don't even have this parameter. This is
    where *Path Processors* come into play, more specifically, implementations of
    `InboundPathProcessorInterface`. These are tagged services that get invoked by
    the routing system when building up the routes by the requested path. And essentially,
    they allow the alteration of a given path as it comes in. For Drupal 7 veterans,
    these can be likened to implementations of `hook_url_inbound_alter()`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但根据路由定义，我们甚至没有这个参数。这就是*路径处理器*发挥作用的地方，更具体地说，是`InboundPathProcessorInterface`的实现。这些是带有标签的服务，当路由系统根据请求的路径构建路由时会被调用。本质上，它们允许在路径到来时对其进行修改。对于Drupal
    7的老手来说，这些可以比作`hook_url_inbound_alter()`的实现。
- en: 'The core *System* module implements its own path processor for the purpose
    of handling the download of private files:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 核心的*系统*模块实现了自己的路径处理器，用于处理私有文件的下载：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It''s a simple tagged service definition whose class needs to implement the
    correct interface that has one method. In the case of `PathProcessorFiles`, it
    looks like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的标记服务定义，其类需要实现一个正确接口，该接口有一个方法。在`PathProcessorFiles`的情况下，它看起来是这样的：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The goal of this method is to return a path that can be the same as the one
    requested or changed for whatever reason. And what Drupal does here is checks
    whether the path is the one defined earlier (starts with `/system/files/`) and
    extracts the requested file path that comes as the first argument after that.
    It takes that and adds it to the current request parameter keyed by `file`. Finally,
    it returns a cleaner path called simply `/system/files`. So this is why the `FileDownloadController::download()`
    method looks there for the file path.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的目的是返回一条路径，这条路径可以是请求的路径，或者由于任何原因而改变。Drupal在这里所做的是检查路径是否是之前定义的路径（以`/system/files/`开头）并提取作为第一个参数的请求文件路径。然后，它将这个路径添加到当前请求参数中，以`file`作为键。最后，它返回一个简单的路径，即`/system/files`。这就是为什么`FileDownloadController::download()`方法会在那里查找文件路径的原因。
- en: 'Turning back to the Controller, we see that it essentially checks for the file
    and, if it is not found, throws a 404 (`NotFoundHttpException`). Otherwise, it
    invokes `hook_file_download()` which allows all modules to control access to the
    file. And these can do so in two ways: either by returning `-1`, which denies
    access, or by returning an array of headers to control the download for that specific
    file. By default, files in the private filesystem cannot be downloaded unless
    a specific module allows this to happen.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 回到控制器，我们看到它基本上检查文件是否存在，如果找不到，则抛出404（`NotFoundHttpException`）。否则，它调用`hook_file_download()`，允许所有模块控制文件的访问。它们可以通过两种方式做到这一点：要么返回`-1`，拒绝访问，要么返回一个包含头部的数组来控制特定文件的下载。默认情况下，私有文件系统中的文件不能下载，除非特定的模块允许这样做。
- en: 'So what does this mean? If we have a file in the private filesystem, we need
    to implement `hook_file_download()` and control access to it. Let''s see an example
    of how this might work by assuming we have a folder called `/pdfs` whose files
    we want to make accessible to users that have the `administer site configuration`
    permission:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着什么？如果我们有一个在私有文件系统中的文件，我们需要实现`hook_file_download()`并控制对其的访问。让我们通过假设我们有一个名为`/pdfs`的文件夹，我们希望让具有`administer
    site configuration`权限的用户可以访问其中的文件来查看这个例子可能的工作方式：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This hook receives as an argument the URI of the file being requested. And based
    on that, we try to get the folder name it's in. To do this, we use the `file_system`
    service again.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个钩子接收一个参数，即请求的文件的URI。基于这个URI，我们尝试获取它所在的文件夹名称。为此，我们再次使用`file_system`服务。
- en: 'If the file is not in the private filesystem inside the `/pdfs` folder, we
    simply return `NULL` to signify that we don''t control the access to this file.
    Other modules may do so (and if none do, access is denied). If it is our file,
    we check for the permission we want and return `-1` if the user doesn''t have
    it. This will deny access. Finally, if access is allowed, we return an array of
    headers we want to use in the file delivery. In our case, we simply use the PDF-specific
    headers that facilitate the display of the PDF file in the browser. If we wanted
    to trigger a file download, we could do something like this instead:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件不在`/pdfs`文件夹内的私有文件系统中，我们简单地返回`NULL`以表示我们不控制对这个文件的访问。其他模块可能这样做（如果没有模块这样做，则访问被拒绝）。如果是我们的文件，我们检查所需的权限，如果用户没有这个权限，则返回`-1`。这将拒绝访问。最后，如果允许访问，我们返回一个包含我们希望在文件传输中使用的头部的数组。在我们的例子中，我们简单地使用PDF特定的头部，这些头部有助于在浏览器中显示PDF文件。如果我们想触发文件下载，我们可以这样做：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We use the filesystem service to determine the file name being requested and
    adjust our headers accordingly to treat it like an attachment that has to be downloaded.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用文件系统服务来确定请求的文件名，并相应地调整我们的头部，将其视为必须下载的附件。
- en: 'And that is all there is to it. If we want more control (or a different path
    to download the files), we can implement our own route and follow the same approach.
    Without, of course, the need to invoke a hook, but simply handling the download
    inside the controller method. For example, this is what `FileDownloadController::download()`
    does to handle the actual response:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容。如果我们想要更多的控制（或者不同的文件下载路径），我们可以实现自己的路由并遵循相同的方法。当然，不需要调用钩子，只需在控制器方法中处理下载即可。例如，这就是`FileDownloadController::download()`如何处理实际响应的：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This type of response is used when we want to deliver files to the browser and
    it comes straight from Symfony.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望将文件发送到浏览器且文件直接来自Symfony时，会使用此类响应。
- en: Images
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像
- en: In this section, we are going a bit deeper into the world of images in Drupal
    8 while keeping the focus on module developers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨Drupal 8中的图像世界，同时保持对模块开发者的关注。
- en: Image toolkits
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像工具包
- en: 'The Drupal 8 Image toolkits provide an abstraction layer over the most common
    operations used for manipulating images. By default, Drupal uses the GD image
    management library that is included with PHP. However, it also offers the ability
    to switch to a different library if needed by using the `ImageToolkit` plugins:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 8图像工具包为处理图像的常见操作提供了一个抽象层。默认情况下，Drupal使用包含在PHP中的GD图像管理库。然而，它还提供了通过使用`ImageToolkit`插件来切换到不同库的能力：
- en: '![](img/d7b498c0-1ae6-48cc-9948-62bd42895e6d.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7b498c0-1ae6-48cc-9948-62bd42895e6d.png)'
- en: For instance, a contributed module could implement the `ImageMagick` library
    for developers who need support for additional image types such as TIFF, which
    GD does not support. However, only one library can be used at a time as it needs
    to be configured site-wide.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个贡献的模块可以为需要支持GD不支持的其他图像类型（如TIFF）的开发者实现`ImageMagick`库。然而，一次只能使用一个库，因为它需要全局配置。
- en: 'Programmatically manipulating images using a toolkit involves instantiating
    an `ImageInterface` object that wraps an image file. This interface (implemented
    by the `Image` class) contains all the needed methods for applying the common
    manipulations to images, as well as saving the resulting image to the filesystem.
    And to get our hands on such an object, we use the `ImageFactory` service:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工具包程序化地处理图像涉及实例化一个包装图像文件的`ImageInterface`对象。此接口（由`Image`类实现）包含应用常见操作到图像的所有所需方法，以及将结果图像保存到文件系统。要获取此类对象，我们使用`ImageFactory`服务：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The role of this factory is to create instances of `Image` using a given toolkit.
    And it works like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此工厂的作用是使用给定的工具包创建`Image`实例。它的工作方式如下：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The second parameter to this method is the `ImageToolkit` plugin ID we want
    the `Image` object to work with. By default, it uses the default toolkit configured
    for the entire application.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的第二个参数是我们希望`Image`对象与之一起工作的`ImageToolkit`插件ID。默认情况下，它使用为整个应用程序配置的默认工具包。
- en: 'And now we can use the manipulation methods on the `ImageInterface` to change
    the file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`ImageInterface`上的操作方法来更改文件：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this example, we scale the image to 50 x 50 and save it to a new path. Omitting
    the destination in the `save()` method would mean overwriting the original file
    with the changed version. If you need to perform such manipulations manually,
    I encourage you to explore the `ImageInterface` for all the available options.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将图像缩放到50 x 50像素，并将其保存到新的路径。在`save()`方法中省略目标路径意味着将更改后的版本覆盖原始文件。如果您需要手动执行此类操作，我鼓励您探索`ImageInterface`提供的所有可用选项。
- en: Image styles
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像样式
- en: 'Even though, as we''ve seen, we can handle image manipulations programmatically
    ourselves, typically this is done as part of *Image Styles* which can be created
    and configured via the UI. These work similarly to how they did in Drupal 7 and
    involve the application of several possible *Image Effects* in order to create
    image variations used in different places. Drupal 8 comes with the same three
    default image styles as did Drupal 7:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经看到我们可以自己程序化处理图像操作，但通常这是作为*Image Styles*的一部分完成的，这些样式可以通过UI创建和配置。它们的工作方式与Drupal
    7中类似，涉及应用几个可能的*Image Effects*以创建在不同地方使用的图像变体。Drupal 8提供了与Drupal 7相同的三个默认图像样式：
- en: '![](img/e58c25de-664b-465b-97fd-078f54173c04.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e58c25de-664b-465b-97fd-078f54173c04.png)'
- en: The image styles themselves are configuration entities that store configuration
    specific to the *ImageEffect* plugins they work with. Once they are created in
    the UI, we can make use of them in various ways. The most typical way is to use
    the image style in the *display* configuration of an entity field or even in Views
    when rendering an image field.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图像样式本身是存储与它们所工作的*ImageEffect*插件相关的特定配置的配置实体。一旦在UI中创建，我们就可以以各种方式使用它们。最典型的方式是使用图像样式在实体字段的*显示*配置中，甚至在渲染图像字段时使用视图。
- en: 'If you remember, in the beginning of the chapter we created the image field
    on the product entity but we did not configure a display. So for the moment, the
    imported images do not show up on the main product page. But we can add some display
    configuration to our base field definition so that images are shown with a specific
    image style:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，在本章的开头，我们在产品实体上创建了图像字段，但我们没有配置显示。因此，目前，导入的图像不会显示在主产品页面上。但我们可以向我们的基本字段定义中添加一些显示配置，以便以特定的图像样式显示图像：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this example, we are using the default `image` field formatter plugin which
    can be configured to use an image style. So under the `settings` key, we reference
    the `large` image style configuration entity which actually comes with Drupal
    core. Omitting this would simply just render the original image. Make sure you
    check back to [Chapter 7](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml), *Your Own
    Custom Entity and Plugin Types*, and [Chapter 9](f58fb5b9-3f39-4575-872d-c2ab9985828d.xhtml),
    *Custom Fields*, if you are a bit fuzzy on the base field definitions.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在使用默认的`image`字段格式化插件，该插件可以配置为使用图像样式。因此，在`settings`键下，我们引用了`large`图像样式配置实体，它实际上是Drupal核心的一部分。省略此选项将简单地渲染原始图像。确保您回顾了[第7章](392cdb70-e52a-42d1-b782-28d6eb726810.xhtml)，*您自己的自定义实体和插件类型*，以及[第9章](f58fb5b9-3f39-4575-872d-c2ab9985828d.xhtml)，*自定义字段*，如果您对基本字段定义有些模糊。
- en: Rendering images
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染图像
- en: In [Chapter 4](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml), *Theming*, we talked
    about theme hooks and how we use them in render arrays to build output. And we
    also saw a few examples of theme hooks that come with Drupal core and that can
    be used for common things (such as links or tables). But images are also something
    we'll often end up rendering and there are two ways we can do so (both using theme
    hooks defined by Drupal core).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml)，*主题化*中，我们讨论了主题钩子以及我们如何在渲染数组中使用它们来构建输出。我们还看到了一些Drupal核心提供的主题钩子示例，这些钩子可以用于常见事物（如链接或表格）。但图像也是我们经常会渲染的东西，我们可以通过两种方式做到这一点（两种都使用由Drupal核心定义的主题钩子）。
- en: 'First, we can use the `image` theme hook to simply render an image. And it''s
    pretty simple to use it:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以使用`image`主题钩子简单地渲染一个图像。使用它相当简单：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: And this will render the image as is. We can also pass some more options like
    the *alt*, *title*, *width* or *height,* all of which being applied to the image
    tag as attributes, as well as an array of any other kinds of attributes we may
    want. Check out `template_preprocess_image()` for more information on how this
    works.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就会以原始形式渲染图像。我们还可以传递一些其他选项，如`alt`、`title`、`width`或`height`，所有这些都将作为属性应用于图像标签，以及我们可能想要的任何其他类型的属性数组。有关如何工作的更多信息，请查看`template_preprocess_image()`。
- en: 'Alternatively, the *Image* module defines the `image_style` theme hook which
    we can use to render the image using a given image style:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，`Image`模块定义了`image_style`主题钩子，我们可以使用它来使用给定的图像样式渲染图像：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This theme hook works pretty much the same way, except that it has an extra
    parameter for the ID of the `ImageStyle` entity we want to use. And the rest of
    the parameters we find on the `image` theme hook can also be found here. In fact,
    `image_style` delegates to the `image` theme hook under the hood.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题钩子的工作方式几乎相同，但它有一个额外的参数，用于我们想要使用的`ImageStyle`实体的ID。其余的参数我们可以在`image`主题钩子中找到。实际上，`image_style`在底层委托给`image`主题钩子。
- en: 'Finally, we may also find ourselves in a situation in which we need to get
    our hands on the URL of an image using a given image style. We need to work with
    the `ImageStyle` configuration entity for this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可能会发现自己处于这样一种情况：需要使用给定的图像样式获取图像的URL。为此，我们需要与`ImageStyle`配置实体一起工作：
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Once we load the image style we want, we simply call its `buildUrl()` method
    to which we pass the URI of the file for which we want the URL. The first time
    this URL is accessed, the image variation gets created and stored to disk. Future
    requests will load it directly from there for improved performance.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们加载了想要的图像样式，我们只需调用它的`buildUrl()`方法，并将我们想要URL的文件的URI传递给它。第一次访问此URL时，图像变体会被创建并存储到磁盘上。未来的请求将直接从那里加载，以提高性能。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We are closing this chapter after covering a lot of different topics that have
    to do with working with files in Drupal 8.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在涵盖了与Drupal 8中文件操作相关的大量不同主题后关闭了这一章。
- en: 'We started with a couple of introductory sections in which we outlined some
    general concepts such as the various filesystems (storages) that Drupal 8 uses,
    as well as how stream wrappers come into play for working with them. We also introduced
    the different ways to work with files: *managed* versus *unmanaged*.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从几个介绍性章节开始，概述了一些一般概念，例如Drupal 8使用的各种文件系统（存储），以及流包装器如何用于处理它们。我们还介绍了处理文件的不同方式：*管理*与*非管理*。
- en: Next, we dove into working with *managed files* and created an image field on
    our Product entity type so that we could import images into it. The other example
    of working with *managed* files had us create a new Product importer based on
    a CSV file of data and we also saw how to upload, read and process such a file,
    as well as manually track its usage. As a parenthesis, we introduced a very powerful
    feature of Drupal 8 that allows us to hook into the entity CRUD operations and
    perform actions whenever these are fired. This is a majorly important technique
    module developers typically use in Drupal.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们深入探讨了如何使用*管理文件*，并在我们的产品实体类型上创建了一个图像字段，以便我们可以将其导入其中。另一个使用*管理*文件的例子是，我们基于数据CSV文件创建了一个新的产品导入器，我们还看到了如何上传、读取和处理此类文件，以及如何手动跟踪其使用情况。作为一个旁注，我们介绍了一个非常强大的Drupal
    8功能，它允许我们挂钩到实体CRUD操作，并在这些操作被触发时执行操作。这是模块开发者通常在Drupal中使用的关键技术。
- en: We then switched gears and implemented our own stream wrapper to serve our imaginary
    remote API that stored the product images. Moreover, we talked about working with
    *unmanaged* files and some of the functions we can use for this—things similar
    to *managed* files except the function names are different and there are no File
    entities or usage tracking them.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转换了方向，并实现了我们自己的流包装器来服务于我们的虚拟远程API，该API存储产品图像。此外，我们还讨论了如何使用*非管理*文件以及我们可以用于此的一些函数——与*管理*文件类似的东西，但函数名称不同，并且没有文件实体或使用跟踪。
- en: We then continued with the private filesystem and a talk about what this serves
    and how we can work with it to control access to our own files. As opposed to
    allowing users to bypass Drupal and download files from the public filesystem.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着讨论了私有文件系统，并探讨了它的用途以及如何用它来控制对我们自己文件的访问。这与允许用户绕过Drupal并从公共文件系统中下载文件相反。
- en: Finally, we finished the chapter with a look at the APIs surrounding images
    and how we can use toolkits to process images, both manually and as part of image
    styles. And even more useful, we saw how we can render images in all sorts of
    ways in Drupal 8 and get our hands on image style URLs.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过查看围绕图像的API以及如何使用工具包来处理图像（无论是手动还是作为图像样式的一部分）来结束这一章。更有用的一点是，我们看到了如何在Drupal
    8中以各种方式渲染图像，并获取图像样式URL。
- en: In the next and final chapter, we will look at automated testing and how we
    can ensure that our code works and that we don't introduce regressions along the
    way.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章和最后一章中，我们将探讨自动化测试以及如何确保我们的代码正常工作，并在过程中不引入回归。
