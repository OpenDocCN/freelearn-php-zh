- en: Indexes
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引
- en: Indexes, which are a synonym for keys, are fields that do not need any special
    behavior as do the rest of the keys but they are important enough in our queries.
    So, we will ask MySQL to do some work with them in order to perform better when
    querying by this field. Do you remember when adding a foreign key that MySQL added
    extra keys to the table? Those were indexes too.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 索引，是键的同义词，是那些不需要像其他键那样有特殊行为的字段，但它们在我们的查询中非常重要。因此，我们将要求MySQL对这些字段做一些工作，以便在通过此字段进行查询时表现更好。你还记得在添加外键时MySQL添加了额外的键到表中吗？那些也是索引。
- en: 'Think about how the application will use the database. We want to show the
    catalog of books to our customers, but we cannot show all of them at once for
    sure. The customer will want to filter the results, and one of the most common
    ways of filtering is by specifying the title of the book that they are looking
    for. From this, we can extract that the title will be used to filter books quite
    often, so we want to add an index to this field. Let''s add the index via the
    following code:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑应用程序将如何使用数据库。我们希望向我们的客户展示书籍目录，但我们肯定不能一次性展示所有书籍。客户将想要过滤结果，而最常见的一种过滤方式是指定他们正在寻找的书籍标题。从这个角度来看，我们可以得出结论，标题将被频繁用于过滤书籍，因此我们希望为这个字段添加索引。让我们通过以下代码添加索引：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Remember that all other keys also provide indexing. IDs of books, customers
    and sales, ISBNs, and e-mails are already indexed, so there is no need to add
    another index here. Also, try not to add indexes to every single field as in doing
    so you will be **overindexing**, which would make some types of queries even slower
    than if they were without indexes!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，所有其他键也提供了索引。书籍、客户和销售、ISBN和电子邮件的ID已经建立了索引，因此在这里添加另一个索引是没有必要的。此外，尽量不要为每个字段都添加索引，因为这样做会导致**过度索引**，这会使某些类型的查询比没有索引时还要慢！
- en: Inserting data
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入数据
- en: We have created the perfect tables to hold our data, but so far they are empty.
    It is time that we populate them. We delayed this moment as altering tables with
    data is more difficult than when they are empty.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了完美的表来存储我们的数据，但到目前为止它们是空的。现在是时候填充它们了。我们推迟了这个时刻，因为当表中有数据时更改表比它们为空时更困难。
- en: 'In order to insert this data, we will use the `INSERT INTO` command. This command
    will take the name of the table, the fields that you want to populate, and the
    data for each field. Note that you can choose not to specify the value for a field,
    and there are different reasons to do this, which are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了插入这些数据，我们将使用`INSERT INTO`命令。此命令将包含表名、你想要填充的字段以及每个字段的值。请注意，你可以选择不指定字段的值，这样做有不同的原因，如下所述：
- en: The field has a default value, and we are happy using it for this specific row
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该字段有一个默认值，并且我们很高兴为这个特定的行使用它
- en: Even though the field does not have an explicit default value, the field can
    take null values; so, by not specifying the field, MySQL will automatically insert
    a null here
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使该字段没有显式的默认值，该字段也可以接受null值；因此，如果不指定该字段，MySQL将自动在此插入null值
- en: The field is a primary key and is autoincremental, and we want to let MySQL
    take the next ID for us
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该字段是主键，并且是自增的，我们希望让MySQL为我们获取下一个ID
- en: 'There are different reasons that can cause an `INSERT INTO` command to fail:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的原因可能导致`INSERT INTO`命令失败：
- en: If you do not specify the value of a field and MySQL cannot provide a valid
    default value
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你没有指定字段的值，并且MySQL无法提供有效的默认值
- en: If the value provided is not of the type of the field and MySQL fails to find
    a valid conversion
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提供的值不是字段的数据类型，并且MySQL无法找到有效的转换
- en: If you specify that you want to set the value for a field but you fail to provide
    a value
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你指定了要设置字段的值，但你未能提供值
- en: If you provide a foreign key with an ID but the ID does not exist in the referenced
    table
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你提供了一个带有ID的外键，但该ID在引用的表中不存在
- en: 'Let''s take a look at how to add rows. Let''s start with our `customer` table,
    adding one `basic` and one `premium`, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何添加行。让我们从我们的`customer`表开始，添加一个`basic`和一个`premium`，如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that MySQL shows you some return information; in this case, it shows that
    there was one row affected, which is the row that we inserted. We did not provide
    an ID, so MySQL just added the next ones in the list. As it is the first time
    that we are adding data, MySQL used the IDs 1 and 2.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，MySQL会显示一些返回信息；在这种情况下，它显示影响了一行，即我们插入的那一行。我们没有提供ID，所以MySQL只是添加了列表中的下一个ID。由于这是我们第一次添加数据，MySQL使用了ID
    1和2。
- en: 'Let''s try to trick MySQL and add another customer, repeating the e-mail address
    field that we set as unique in the previous section:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试欺骗MySQL并添加另一个客户，重复我们在上一节中设置为唯一的电子邮件地址字段：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: An error is returned with an error code and an error message, and the row was
    not inserted, of course. The error message usually contains enough information
    in order to understand the issue and how to fix it. If this is not the case, we
    can always try to search on the Internet using the error code and note what either
    the official documentation or other users have to say about it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 返回了一个带有错误代码和错误信息的错误，当然，行没有被插入。错误信息通常包含足够的信息，以便理解问题及其解决方法。如果不是这样，我们总是可以尝试使用错误代码在互联网上搜索，并注意官方文档或其他用户对此有何评论。
- en: 'In case you need to introduce multiple rows to the same table and they contain
    the same fields, there is a shorter version of the command, in which you can specify
    the fields and then provide the groups of values for each row. Let''s take a look
    at how to use it when adding books to our `book` table, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要向同一表中引入多行，并且它们包含相同的字段，则有一个简短的命令版本，您可以在其中指定字段，然后为每行提供值组。让我们看看在向我们的`book`表添加书籍时如何使用它，如下所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As with customers, we will not specify the ID and let MySQL choose the appropriate
    one. Note also that now the amount of affected rows is `5` as we inserted five
    rows.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与客户一样，我们不会指定ID，让MySQL选择合适的ID。注意，现在受影响的行数是`5`，因为我们插入了五行。
- en: 'How can we take advantage of the explicit defaults that we defined in our tables?
    Well, we can do this in the same way as we did with the primary keys: do not specify
    them in the fields list or in the values list, and MySQL will just use the default
    value. For example, we defined a default value of `1` for our `book.stock` field,
    which is a useful notation for the `book` table and the `stock` field. Let''s
    add another row using this default, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何利用我们在表中定义的显式默认值？嗯，我们可以用与处理主键相同的方式来做这件事：不要在字段列表或值列表中指定它们，MySQL将直接使用默认值。例如，我们为`book.stock`字段定义了一个默认值`1`，这对于`book`表和`stock`字段来说是一个有用的表示法。让我们使用这个默认值添加另一行，如下所示：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have books and customers, let''s add some historic data about customers
    borrowing books. For this, use the numeric IDs from `book` and `customer`, as
    in the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了书籍和客户，让我们添加一些关于客户借阅书籍的历史数据。为此，使用`book`和`customer`的数字ID，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Querying data
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询数据
- en: 'It took quite a lot of time, but we are finally in the most exciting—and useful—section
    related to databases: querying data. Querying data refers to asking MySQL to return
    rows from the specified table and optionally filtering these results by a set
    of rules. You can also choose to get specific fields instead of the whole row.
    In order to query data, we will use the `SELECT` command, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 花了相当多的时间，但我们终于到达了与数据库最激动人心——也是最有用——的部分：查询数据。查询数据是指要求MySQL从指定的表中返回行，并可选择通过一组规则过滤这些结果。您也可以选择获取特定的字段而不是整个行。为了查询数据，我们将使用`SELECT`命令，如下所示：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: One of the simplest ways to query data is to specify the fields of interest
    after `SELECT` and specify the table with the `FROM` keyword. As we did not add
    any filters—mostly known as conditions—to the query, we got all the rows there.
    Sometimes, this is the desired behavior, but the most common thing to do is to
    add conditions to the query to retrieve only the rows that we need. Use the `WHERE`
    keyword to achieve this.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 查询数据的一种最简单的方法是在`SELECT`之后指定感兴趣的字段，并使用`FROM`关键字指定表。由于我们没有在查询中添加任何过滤器——通常称为条件——所以我们得到了所有这些行。有时，这可能是期望的行为，但最常见的事情是向查询中添加条件，以检索我们需要的行。使用`WHERE`关键字来实现这一点。
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Adding conditions is very similar to when we created Boolean expressions in
    PHP. We will specify the name of the field, an operator, and a value, and MySQL
    will retrieve only the rows that return `true` to this expression. In this case,
    we asked for the customers that had the ID 1, and MySQL returned one row: the
    one that had an ID of exactly 1.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 添加条件与我们在PHP中创建布尔表达式时非常相似。我们将指定字段名、运算符和值，MySQL将只检索返回此表达式的`true`的行。在这种情况下，我们要求具有ID
    1的客户，MySQL返回了一行：具有确切ID为1的那一行。
- en: 'A common query would be to get the books that start with some text. We cannot
    construct this expression with any comparison operand that you know, such as `=`
    and `<` or `>`, since we want to match only a part of the string. For this, MySQL
    has the `LIKE` operator, which takes a string that can contain wildcards. A wildcard
    is a character that represents a rule, matching any number of characters that
    follows the rule. For example, the `%` wildcard represents any number of characters,
    so using the `1%` string would match any string that starts with 1 and is followed
    by any number or characters, matching strings such as `1984` or `1Q84`. Let''s
    consider the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的查询需求是获取以某些文本开头的书籍。由于我们只想匹配字符串的一部分，因此不能使用您所知的任何比较运算符来构造这个表达式，例如 `=` 和 `<`
    或 `>`。为此，MySQL 有一个 `LIKE` 运算符，它接受一个可以包含通配符的字符串。通配符是一个代表规则的字符，可以匹配符合规则后的任意数量的字符。例如，`%`
    通配符代表任意数量的字符，因此使用 `1%` 字符串将匹配以 1 开头并跟随后续任意数量或字符的任何字符串，例如 `1984` 或 `1Q84`。让我们考虑以下示例：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We asked for all the books whose title starts with `1`, and we got three rows.
    You can imagine how useful this operator is, especially when we implement a search
    utility in our application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们请求了所有标题以 `1` 开头的书籍，并得到了三行。您可以想象这个运算符有多有用，尤其是在我们实现应用程序中的搜索工具时。
- en: 'As in PHP, MySQL also allows you to add logical operators—that is, operators
    that take operands and perform a logical operation, returning Boolean values as
    a result. The most common logical operators are, as in PHP, `AND` and `OR`. `AND`
    returns `true` if both the expressions are `true` and `OR` returns `true` if either
    of the operands is `true`. Let''s consider an example, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与 PHP 一样，MySQL 也允许您添加逻辑运算符——即接受操作数并执行逻辑运算的运算符，结果返回布尔值。最常用的逻辑运算符与 PHP 一样是 `AND`
    和 `OR`。`AND` 在两个表达式都为 `true` 时返回 `true`，而 `OR` 在任一操作数为 `true` 时返回 `true`。让我们考虑以下示例：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This example is very similar to the previous one, but we added an extra condition.
    We asked for all titles starting with `1` and whether there is stock available.
    This is why one of the books does not show as it does not satisfy both conditions.
    You can add as many conditions as you need with logical operators but bear in
    mind that `AND` operators take precedence over `OR`. If you want to change this
    precedence, you can always wrap expressions with a parenthesis, as in PHP.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与上一个例子非常相似，但我们添加了一个额外的条件。我们请求了所有以 `1` 开头的标题以及是否有库存。这就是为什么一本书没有显示，因为它不满足这两个条件。您可以使用逻辑运算符添加所需数量的条件，但请注意
    `AND` 运算符的优先级高于 `OR`。如果您想改变这个优先级，您总是可以用括号将表达式括起来，就像在 PHP 中一样。
- en: 'So far, we have retrieved specific fields when querying for data, but we could
    ask for all the fields in a given table. To do this, we will just use the `*`
    wildcard in `SELECT`. Let''s select all the fields for the customers via the following
    code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在查询数据时检索了特定的字段，但我们可以请求给定表中的所有字段。为此，我们只需在 `SELECT` 中使用 `*` 通配符。让我们通过以下代码选择所有客户的字段：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can retrieve more information than just fields. For example, you can use
    `COUNT` to retrieve the amount of rows that satisfy the given conditions instead
    of retrieving all the columns. This way is faster than retrieving all the columns
    and then counting them because you save time in reducing the size of the response.
    Let''s consider how it would look:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以检索的信息不仅仅是字段。例如，您可以使用 `COUNT` 来检索满足给定条件的行数，而不是检索所有列。这种方法比检索所有列然后再计数要快，因为您通过减少响应的大小来节省时间。让我们考虑一下它将如何看起来：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can note, the response says `1`, which means that there is only one
    borrowed book that satisfies the conditions. However, check the conditions; you
    will note that we used another familiar logical operator: `NOT`. `NOT` negates
    the expression, as `!` does in PHP. Note also that we do not use the equal sign
    to compare with null values. In MySQL, you have to use `IS` instead of the equals
    sign in order to compare with `NULL`. So, the second condition would be satisfied
    when a borrowed book has an end date that is not null.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所注意到的，响应显示 `1`，这意味着只有一个借阅的书籍满足条件。然而，检查一下条件；您会注意到我们使用了另一个熟悉的逻辑运算符：`NOT`。`NOT`
    取反表达式，就像 PHP 中的 `!` 一样。请注意，我们不用等号来与空值比较。在 MySQL 中，您必须使用 `IS` 而不是等号来与 `NULL` 进行比较。因此，第二个条件会在借阅的书籍有一个非空的结束日期时得到满足。
- en: 'Let''s finish this section by adding two more features when querying data.
    The first one is the ability to specify in what order the rows should be returned.
    To do this, just use the keyword `ORDER BY` followed by the name of the field
    that you want to order by. You could also specify whether you want to order in
    ascending mode, which is by default, or in the descending mode, which can be done
    by appending `DESC`. The other feature is the ability to limit the amount of rows
    to return using `LIMIT` and the amount of rows to retrieve. Now, run the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在查询数据时添加两个更多功能来完成这个部分。第一个功能是能够指定返回行的顺序。要做到这一点，只需使用关键字`ORDER BY`后跟你想排序的字段名称。你也可以指定是否想要以升序排序，这是默认的，或者以降序排序，可以通过附加`DESC`来实现。另一个功能是使用`LIMIT`和要检索的行数来限制返回的行数。现在，运行以下代码：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using PDO
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PDO
- en: So far, we have worked with MySQL, and you already have a good idea of what
    you can do with it. However, connecting to the client and performing queries manually
    is not our goal. What we want to achieve is that our application can take advantage
    of the database in an automatic way. In order to do this, we will use a set of
    classes that comes with PHP and allows you to connect to the database and perform
    queries from the code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经与MySQL一起工作过，你对它能做什么已经有了一个很好的了解。然而，手动连接到客户端并执行查询并不是我们的目标。我们想要实现的是，我们的应用程序可以自动利用数据库。为了做到这一点，我们将使用一组PHP附带类，允许你从代码中连接到数据库并执行查询。
- en: '**PHP Data Objects** (**PDO**) is the class that connects to the database and
    allows you to interact with it. This is the popular way to work with databases
    for PHP developers, even though there are other ways that we will not discuss
    here. PDO allows you to work with different database systems, so you are not tied
    to MySQL only. In the following sections, we will consider how to connect to a
    database, insert data, and retrieve it using this class.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**PHP数据对象**（**PDO**）是连接到数据库并允许你与之交互的类。这是PHP开发者处理数据库的流行方式，尽管还有其他方式，我们在这里不会讨论。PDO允许你与不同的数据库系统一起工作，所以你不仅限于MySQL。在接下来的章节中，我们将考虑如何使用这个类连接到数据库、插入数据以及检索数据。'
- en: Connecting to the database
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'In order to connect to the database, it is good practice to keep the credentials—that
    is, the user and password—separated from the code in a configuration file. We
    already have this file as `config/app.json` from when we worked with the `Config`
    class. Let''s add the correct credentials for our database. If you have the configuration
    by default, the configuration file should look similar to this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接到数据库，将凭证（即用户名和密码）与代码分开存储在配置文件中是一个好习惯。我们已经有这个文件，即`config/app.json`，因为我们之前与`Config`类一起工作过。让我们为我们的数据库添加正确的凭证。如果你有默认的配置，配置文件应该看起来像这样：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Developers usually specify other information related to the connection, such
    as the host, port, or name of the database. This will depend on how your application
    is installed, whether MySQL is running on a different server, and so on, and it
    is up to you how much information you want to keep on your code and in your configuration
    files.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者通常会指定与连接相关的其他信息，例如主机、端口或数据库名称。这取决于你的应用程序是如何安装的，MySQL是否运行在不同的服务器上，等等，至于你希望在代码和配置文件中保留多少信息，这取决于你。
- en: 'In order to connect to the database, we need to instantiate an object from
    the `PDO` class. The constructor of this class expects three arguments: **Data
    Source Name** (**DSN**), which is a string that represents the type of database
    to use; the name of the user; and the password. We already have the username and
    password from the `Config` class, but we still need to build DSN.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接到数据库，我们需要从`PDO`类实例化一个对象。这个类的构造函数期望三个参数：**数据源名称**（**DSN**），它是一个表示要使用哪种数据库的字符串；用户的名称；以及密码。我们已经从`Config`类中获得了用户名和密码，但我们仍然需要构建DSN。
- en: 'One of the formats for MySQL databases is `<database type>:host=<host>;dbname=<schema
    name>`. As our database system is MySQL, it runs on the same server, and the schema
    name is `bookstore`, DSN will be `mysql:host=127.0.0.1;dbname=bookstore`. Let''s
    take a look at how we will put everything together:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL数据库的一种格式是`<database type>:host=<host>;dbname=<schema name>`。由于我们的数据库系统是MySQL，它运行在同一个服务器上，模式名称是`bookstore`，DSN将是`mysql:host=127.0.0.1;dbname=bookstore`。让我们看看我们将如何将所有这些放在一起：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note also that we will invoke the `setAttribute` method from the `PDO` instance.
    This method allows you to set some options to the connection; in this case, it
    sets the format of the results coming from MySQL. This option forces MySQL to
    return the arrays whose keys are the names of the fields, which is way more useful
    than the default one, returning numeric keys based on the order of the fields.
    Setting this option now will affect all the queries performed with the `$db` instance,
    rather than setting the option each time we perform a query.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还将从`PDO`实例调用`setAttribute`方法。此方法允许你设置一些选项到连接；在这种情况下，它设置了从MySQL返回的结果的格式。此选项强制MySQL返回键为字段名的数组，这比默认的基于字段顺序返回数字键的方式更有用。设置此选项现在将影响使用`$db`实例执行的所有查询，而不是每次执行查询时设置选项。
- en: Performing queries
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行查询
- en: 'The easiest way to retrieve data from your database is to use the `query` method.
    This method accepts the query as a string and returns a list of rows as arrays.
    Let''s consider an example: write the following after the initialization of the
    database connection—for example, in the `init.php` file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的数据库中检索数据的最简单方法是使用`query`方法。此方法接受查询作为字符串，并返回一个作为数组的行列表。让我们考虑一个例子：在数据库连接初始化之后写入以下内容——例如，在`init.php`文件中：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This query tries to get all the books in the database, ordering them by the
    title. This could be the content of a function such as `getAllBooks`, which is
    used when we display our catalog. Each row is an array that contains all the fields
    as keys and the data as values.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询试图获取数据库中的所有书籍，并按标题排序。这可能是`getAllBooks`函数的内容，该函数在我们显示目录时使用。每一行都是一个数组，包含所有字段作为键和数据作为值。
- en: 'If you run the application on your browser, you will get the following result:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将应用程序运行在你的浏览器上，你将得到以下结果：
- en: '![Performing queries](img/00027.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![执行查询](img/00027.jpeg)'
- en: 'The `query` function is useful when we want to retrieve data, but in order
    to execute queries that insert rows, PDO provides the `exec` function. This function
    also expects the first parameter as a string, defining the query to execute, but
    it returns a Boolean specifying whether the execution was successful or not. A
    good example would be to try to insert books. Type the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要检索数据时，`query`函数很有用，但为了执行插入行的查询，PDO提供了`exec`函数。此函数也期望第一个参数为字符串，定义要执行的查询，但它返回一个布尔值，指定执行是否成功。一个很好的例子是尝试插入书籍。输入以下内容：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code also uses a new way of representing strings: heredoc. We will enclose
    the string between `<<<SQL` and `SQL;`, both in different lines, instead of quotes.
    The benefit of this is the ability to write strings in multiple lines with tabulations
    or any other blank space, and PHP will respect it. We can construct queries that
    are easy to read rather than writing them on a single line or having to concatenate
    the different strings. Note that `SQL` is a token to represent the start and end
    of the string, but you could use any text that you consider.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码还使用了一种新的字符串表示方法：heredoc。我们将字符串放在`<<<SQL`和`SQL;`之间，这两者都在不同的行上，而不是用引号。这种方法的优点是能够用制表符或任何其他空白字符在多行中编写字符串，而PHP会尊重这一点。我们可以构建易于阅读的查询，而不是将它们写在单行上或者需要连接不同的字符串。请注意，`SQL`是一个表示字符串开始和结束的标记，但你也可以使用你认为是的任何文本。
- en: The first time you run the application with this code, the query will be executed
    successfully, and thus, the result will be the Boolean `true`. However, if you
    run it again, it will return `false` as the ISBN that we inserted is the same
    but we set its restriction to be unique.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次使用此代码运行应用程序时，查询将成功执行，因此，结果将是布尔值`true`。然而，如果你再次运行它，它将返回`false`，因为我们插入的ISBN相同，但我们将其限制设置为唯一。
- en: 'It is useful to know that a query failed, but it is better if we know why.
    The `PDO` instance has the `errorInfo` method that returns an array with the information
    of the last error. The key `2` contains the description, so it is probably the
    one that we will use more often. Update the previous code with the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 了解查询失败是有用的，但如果我们知道原因会更好。`PDO`实例有一个`errorInfo`方法，它返回一个包含最后错误信息的数组。键`2`包含描述，所以我们可能更经常使用它。用以下代码更新之前的代码：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The result is that the query failed because the ISBN entry was duplicated. Now,
    we can build more meaningful error messages for our customers or just for debugging
    purposes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是查询失败，因为ISBN条目重复。现在，我们可以为我们的客户或仅用于调试目的构建更有意义的错误消息。
- en: Prepared statements
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预处理语句
- en: The previous two functions are very useful when you need to run quick queries
    that are always the same. However, in the second example you might note that the
    string of the query is not very useful as it always inserts the same book. Although
    it is true that you could just replace the values by variables, it is not good
    practice as these variables usually come from the user side and can contain malicious
    code. It is always better to first sanitize these values.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个函数在你需要运行总是相同的快速查询时非常有用。然而，在第二个例子中，你可能注意到查询字符串并不很有用，因为它总是插入相同的书籍。虽然确实可以通过变量替换这些值，但这不是好的做法，因为这些变量通常来自用户端，可能包含恶意代码。总是先清理这些值会更好。
- en: 'PDO provides the ability to prepare a statement—that is, a query that is parameterized.
    You can specify parameters for the fields that will change in the query and then
    assign values to these parameters. Let''s consider first an example, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: PDO提供了准备语句的能力——即参数化的查询。你可以指定将改变查询的字段参数，然后为这些参数分配值。让我们首先考虑以下示例：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The query is a normal one except that it has `:author` instead of the string
    of the author that we want to find. This is a parameter, and we will identify
    them using the prefix `:`. The `prepare` method gets the query as an argument
    and returns a `PDOStatement` instance. This class contains several methods to
    bind values, execute statements, fetch results, and more. In this piece of code,
    we use only three of them, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 查询本身是一个普通的查询，只是它使用`:author`而不是我们想要查找的作者字符串。这是一个参数，我们将使用前缀`:`来识别它们。`prepare`方法将查询作为参数接收并返回一个`PDOStatement`实例。这个类包含多个方法来绑定值、执行语句、获取结果等。在这段代码中，我们只使用了其中三个，如下所示：
- en: '`bindValue`: This takes two arguments: the name of the parameter as described
    in the query and the value to assign. If you provide a parameter name that is
    not in the query, this will throw an exception.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bindValue`：它接受两个参数：查询中描述的参数名称和要分配的值。如果你提供了一个不在查询中的参数名称，这将抛出异常。'
- en: '`execute`: This will send the query to MySQL with the replacement of the parameters
    by the provided values. If there is any parameter that is not assigned to a value,
    the method will throw an exception. As its brother `exec`, `execute` will return
    a Boolean, specifying whether the query was executed successfully or not.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute`：这将发送查询到MySQL，并用提供的值替换参数。如果有任何参数没有分配值，该方法将抛出异常。与它的兄弟`exec`一样，`execute`将返回一个布尔值，指定查询是否成功执行。'
- en: '`fetchAll`: This will retrieve the data from MySQL in case it was a `SELECT`
    query. As a query, `fetchAll` will return a list of all rows as arrays.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchAll`：如果这是一个`SELECT`查询，这将从MySQL检索数据。作为一个查询，`fetchAll`将返回所有行的数组列表。'
- en: If you try this code, you will note that the result is very similar to when
    using `query`; however, this time, the code is much more dynamic as you can reuse
    it for any author that you need.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试这段代码，你会注意到结果与使用`query`时非常相似；然而，这次代码要动态得多，因为你可以为任何需要的作者重用它。
- en: '![Prepared statements](img/00028.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![准备好的语句](img/00028.jpeg)'
- en: 'There is another way to bind values to parameters of a query than using the
    `bindValue` method. You could prepare an array where the key is the name of the
    parameter and the value is the value you want to assign to it, and then you can
    send it as the first argument of the `execute` method. This way is quite useful
    as usually you already have this array prepared and do not need to call `bindValue`
    several times with its content. Add this code in order to test it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`bindValue`方法外，还有另一种方法可以将值绑定到查询的参数。你可以准备一个数组，其中键是参数的名称，值是你想要分配给它的值，然后你可以将其作为`execute`方法的第一个参数发送。这种方法非常有用，因为你通常已经准备好了这个数组，不需要多次调用`bindValue`及其内容。添加以下代码以进行测试：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this last example, we created a new book with almost all the parameters,
    but we did not specify the ID, which is the desired behavior as we want MySQL
    to choose a valid one for us. However, what happens if you want to know the ID
    of the inserted row? Well, you could query MySQL for the book with the same ISBN
    and the returned row would contain the ID, but this seems like a lot of work.
    Instead, PDO has the `lastInsertId` method, which returns the last ID inserted
    by a primary key, saving us from one extra query.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的例子中，我们创建了一本几乎包含所有参数的新书，但我们没有指定 ID，这是期望的行为，因为我们希望 MySQL 为我们选择一个有效的 ID。然而，如果你想知道插入行的
    ID 会发生什么？好吧，你可以查询具有相同 ISBN 的 MySQL 中的书籍，返回的行将包含 ID，但这似乎很麻烦。相反，PDO 有一个 `lastInsertId`
    方法，它返回由主键插入的最后一个 ID，这样我们就避免了额外的查询。
- en: Joining tables
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接表
- en: 'Even though querying MySQL is quite fast, especially if it is in the same server
    as our PHP application, we should try to reduce the number of queries that we
    will execute to improve the performance of our application. So far, we have queried
    data from just one table, but this is rarely the case. Imagine that you want to
    retrieve information about borrowed books: the table contains only IDs and dates,
    so if you query it, you will not get very meaningful data, right? One approach
    would be to query the data in `borrowed_books`, and based on the returning IDs,
    query the `book` and `customer` tables by filtering by the IDs we are interested
    in. However, this approach consists of at least three queries to MySQL and a lot
    of work with arrays in PHP. It seems as though there should be a better option!'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管查询 MySQL 很快，尤其是在它与我们的 PHP 应用程序在同一服务器上时，我们仍然应该尝试减少将要执行的查询数量，以提高我们应用程序的性能。到目前为止，我们只从一个表中查询数据，但这很少是情况。想象一下，你想检索关于借阅书籍的信息：该表只包含
    ID 和日期，所以如果你查询它，你不会得到非常有意义的数据，对吧？一种方法是对 `borrowed_books` 中的数据进行查询，并根据返回的 ID，通过过滤我们感兴趣的
    ID 来查询 `book` 和 `customer` 表。然而，这种方法至少需要向 MySQL 发出三个查询，并在 PHP 中进行大量的数组操作。这似乎应该有更好的选择！
- en: In SQL, you can execute **join queries**. A join query is a query that joins
    two or more tables through a common field and, thus, allows you to retrieve data
    from these tables, reducing the amount of queries needed. Of course, the performance
    of a join query is not as good as the performance of a normal query, but if you
    have the correct keys and relationships defined, this option is way better than
    querying separately.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 中，你可以执行 **连接查询**。连接查询是一种通过公共字段连接两个或更多表，从而允许你从这些表中检索数据，减少所需查询数量的查询。当然，连接查询的性能不如普通查询，但如果你有正确的键和关系定义，这个选项比单独查询要好得多。
- en: 'In order to join tables, you need to link them using a common field. Foreign
    keys are very useful in this matter as you know that both the fields are the same.
    Let''s take a look at how we would query for all the important info related to
    the borrowed books:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接表，你需要使用公共字段将它们链接起来。外键在这个问题中非常有用，因为你知道这两个字段是相同的。让我们看看我们如何查询与借阅书籍相关的所有重要信息：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are several new concepts introduced in this last query. Especially with
    joining queries, as we joined the fields of different tables, it might occur that
    two tables have the same field name, and MySQL needs us to differentiate them.
    The way we will differentiate two fields of two different tables is by prepending
    the name of the table. Imagine that we want to differentiate the ID of a customer
    from the ID of the book; we should use them as `customer.id` and `book.id`. However,
    writing the name of the table each time would make our queries endless.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的查询中引入了几个新概念。特别是当我们进行连接查询时，因为我们连接了不同表的字段，可能会出现两个表有相同字段名的情况，MySQL 需要我们区分它们。我们将通过在字段名前添加表名来区分两个不同表的两个字段。想象一下，如果我们想区分客户
    ID 和书籍 ID，我们应该使用 `customer.id` 和 `book.id`。然而，每次都写表名会让我们的查询变得冗长。
- en: MySQL has the ability to add an alias to a table by just writing next to the
    table's real name, as we did in `borrowed_books` (`bb`), `customer` (`c`) or `book`
    (`b`). Once you add an alias, you can use it to reference this table, allowing
    us to write things such as `bb.customer_id` instead of `borrowed_books.customer_id`.
    It is also good practice to write the table of the field even if the field is
    not duplicated anywhere else as joining tables makes it a bit confusing to know
    where each field comes from.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 具有通过在表的真正名称旁边写入别名来向表添加别名的功能，就像我们在 `borrowed_books` (`bb`)、`customer` (`c`)
    或 `book` (`b`) 中所做的那样。一旦添加了别名，您就可以使用它来引用此表，允许我们编写类似 `bb.customer_id` 而不是 `borrowed_books.customer_id`
    的内容。即使字段在其他任何地方都没有重复，将表作为字段写入也是良好的实践，因为连接表会使知道每个字段来自哪里变得有些混乱。
- en: When joining tables, you need to write them in the `FROM` clause using `LEFT
    JOIN`, followed by the name of the table, an optional alias, and the fields that
    connect both tables. There are different joining types, but let's focus on the
    most useful for our purposes. **Left joins** take each row from the first table—the
    one on the left-hand side of the definition—and search for the equivalent field
    in the right-hand side table. Once it finds it, it will concatenate both rows
    as if they were one. For example, when joining `borrowed_books` with `customer`
    for each `borrowed_books` row, MySQL will search for an ID in `customer` that
    matches the current `customer_id`, and then it will add all the information of
    this row in our current row in `borrowed_books` as if they were only one big table.
    As `customer_id` is a foreign key, we are certain that there will always be a
    customer to match.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接表时，您需要在 `FROM` 子句中使用 `LEFT JOIN`，然后是表名、可选的别名以及连接两个表的字段。有不同的连接类型，但让我们关注对我们最有用的类型。**左连接**将第一个表（定义中的左侧表）的每一行取出来，并在右侧表中搜索等效字段。一旦找到，它将像是一个整体一样连接这两行。例如，当将
    `borrowed_books` 与 `customer` 连接时，对于每一行 `borrowed_books`，MySQL 将在 `customer` 中搜索一个与当前
    `customer_id` 匹配的ID，然后它将像它们是一个大表一样将此行的所有信息添加到我们的当前行 `borrowed_books` 中。由于 `customer_id`
    是外键，我们可以确定总会有一个客户与之匹配。
- en: 'You can join several tables, and MySQL will just resolve them from left to
    right; that is, it will first join the two first tables as one, then try to join
    this resulting one with the third table, and so on. This is, in fact, what we
    did in our example: we first joined `borrowed_books` with `customer` and then
    joined these two with `book`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以连接多个表，MySQL 将从左到右解决它们；也就是说，它将首先将前两个表作为一个整体连接起来，然后尝试将这个结果与第三个表连接起来，依此类推。这正是我们在示例中所做的：我们首先将
    `borrowed_books` 与 `customer` 连接起来，然后将这两个连接起来。
- en: As you can note, there are also aliases for fields. Sometimes, we do more than
    just getting a field; an example was when we got how many rows a query matched
    with `COUNT(*)`. However, the title of the column when retrieving this information
    was also `COUNT(*)`, which is not always useful. At other times, we used two tables
    with colliding field names, and it makes everything confusing. When this happens,
    just add an alias to the field in the same way we did with table names; `AS` is
    optional, but it helps to understand what you are doing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所注意到的，字段也有别名。有时，我们不仅仅是获取一个字段；一个例子是我们如何使用 `COUNT(*)` 来获取查询匹配的行数。然而，当检索此信息时，列的标题也是
    `COUNT(*)`，这并不总是有用的。在其他时候，我们使用了具有冲突字段名的两个表，这会使一切变得混乱。当这种情况发生时，只需像我们对表名所做的那样给字段添加别名即可；`AS`
    是可选的，但它有助于理解您正在做什么。
- en: Let's move now to the usage of dates in this query. On one hand, we will use
    `DATE_FORMAT` for the first time. It accepts the date/time/datetime value and
    the string with the format. In this case, we used `%d-%m-%y`, which means day-month-year,
    but we could use `%h-%i-%s` to specify hours-minutes-seconds or any other combination.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在转到查询中日期的使用。一方面，我们将首次使用 `DATE_FORMAT`。它接受日期/时间/日期时间值和带有格式的字符串。在这种情况下，我们使用了
    `%d-%m-%y`，这意味着日-月-年，但我们也可以使用 `%h-%i-%s` 来指定小时-分钟-秒或任何其他组合。
- en: Note also how we compared dates in the `WHERE` clause. Given two dates or time
    values of the same type, you can use the comparison operators as if they were
    numbers. In this case, we will do `bb.start >= "2015-01-01"`, which will give
    us the borrowed books from January 1, 2015, onward.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意我们在 `WHERE` 子句中比较日期的方式。对于相同类型的两个日期或时间值，您可以使用比较运算符，就像它们是数字一样。在这种情况下，我们将执行
    `bb.start >= "2015-01-01"`，这将给我们从2015年1月1日起借阅的书籍。
- en: The final thing to note about this complex query is the use of the `CONCAT`
    function. Instead of returning two fields, one for the name and one for the surname,
    we want to get the full name. To do this, we will concatenate the fields using
    this function, sending as many strings as we want as arguments of the function
    and getting back the concatenated string. As you can see, you can send both fields
    and strings enclosed by single quotes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个复杂查询的最后一件事是`CONCAT`函数的使用。我们不想返回两个字段，一个用于名字，一个用于姓氏，我们想要得到全名。为此，我们将使用这个函数连接字段，将我们想要的字符串作为函数的参数发送，并得到连接后的字符串。正如你所看到的，你可以发送字段和用单引号括起来的字符串。
- en: Well, if you fully understood this query, you should feel satisfied with yourself;
    this was the most complex query we will see in this chapter. We hope you can get
    a sense of how powerful a database system can be and that from now on, you will
    try to process the data as much as you can on the database side instead of the
    PHP side. If you set the correct indexes, it will perform better.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果你完全理解了这个查询，你应该对自己感到满意；这是我们本章中将要看到的最为复杂的查询。我们希望你能感受到数据库系统是多么强大，并且从现在开始，你将尽可能在数据库端而不是PHP端处理数据。如果你设置了正确的索引，它将表现得更好。
- en: Grouping queries
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组查询
- en: 'The last feature that we will discuss about querying is the `GROUP BY` clause.
    This clause allows you to group rows of the same table with a common field. For
    example, let''s say we want to know how many books each author has in just one
    query. Try the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的查询的最后一个特性是`GROUP BY`子句。这个子句允许您使用一个公共字段将同一表的行分组。例如，假设我们只想通过一个查询知道每位作者有多少本书。尝试以下操作：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `GROUP BY` clause, always after the `WHERE` clause, gets a field—or many,
    separated by a coma—and treats all the rows with the same value for this field,
    as though they were just one. Thus, selecting by author will group all the rows
    that contain the same author. The feature might not seem very useful, but there
    are several functions in MySQL that take advantage of it. In this example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`GROUP BY`子句，始终在`WHERE`子句之后，获取一个字段——或者多个，用逗号分隔——并将具有该字段相同值的所有行视为一个整体。因此，按作者选择将分组包含相同作者的所有行。这个特性可能看起来不太有用，但MySQL中有几个函数可以利用它。在这个例子中：'
- en: '`COUNT(*)` is used in queries with `GROUP BY` and shows how many rows this
    field groups. In this case, we will use it to know how many books each author
    has. In fact, it always works like this; however, for queries without `GROUP BY`,
    MySQL treats the whole set of rows as one group.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COUNT(*)`在带有`GROUP BY`的查询中使用，显示该字段分组了多少行。在这种情况下，我们将用它来知道每位作者有多少本书。实际上，它总是这样工作的；然而，对于没有`GROUP
    BY`的查询，MySQL将整个行集视为一个组。'
- en: '`GROUP_CONCAT` is similar to `CONCAT`, which we discussed earlier. The only
    difference is that this time the function will concatenate the fields of all the
    rows of a group. If you do not specify `SEPARATOR`, MySQL will use a single coma.
    However, in our case, we needed a coma and a space to make it readable, so we
    added `SEPARATOR '', ''` at the end. Note that you can add as many things to concatenate
    as you need in `CONCAT`, the separator will just separate the concatenations by
    rows.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GROUP_CONCAT`与我们在前面讨论的`CONCAT`类似。唯一的区别是这次函数将连接一个组中所有行的字段。如果您没有指定`SEPARATOR`，MySQL将使用单个逗号。然而，在我们的情况下，我们需要一个逗号和一个空格来使其可读，所以我们添加了`SEPARATOR
    '', ''`在末尾。请注意，您可以在`CONCAT`中添加您需要的任何要连接的内容，分隔符将仅按行分隔连接。'
- en: Even though it is not about grouping, note the `ORDER` clause that we added.
    We ordered by two fields instead of one. This means that MySQL will order all
    the rows by the `amount` field; note that this is an alias, but you can use it
    here as well. Then, MySQL will order each group of rows with the same `amount`
    value by the `title` field.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这不是关于分组的，请注意我们添加的`ORDER`子句。我们按两个字段而不是一个字段排序。这意味着MySQL将按`amount`字段对所有行进行排序；请注意，这是一个别名，但您也可以在这里使用它。然后，MySQL将按`title`字段对具有相同`amount`值的每一组行进行排序。
- en: 'There is one last thing to remember as we already presented all the important
    clauses that a `SELECT` query can contain: MySQL expects the clauses of the query
    to be always in the same order. If you write the same query but change this order,
    you will get an error. The order is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们已经介绍了`SELECT`查询可以包含的所有重要子句之后，还有一件事需要记住：MySQL期望查询的子句始终以相同的顺序排列。如果你写了一个相同的查询但改变了这个顺序，你会得到一个错误。顺序如下：
- en: '`SELECT`'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SELECT`'
- en: '`FROM`'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FROM`'
- en: '`WHERE`'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WHERE`'
- en: '`GROUP BY`'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GROUP BY`'
- en: '`ORDER BY`'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ORDER BY`'
- en: Updating and deleting data
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新和删除数据
- en: 'We already know quite a lot about inserting and retrieving data, but if applications
    could only do this, they would be quite static. Editing this data as we need is
    what makes an application dynamic and what gives to the user some value. In MySQL,
    and in most database systems, you have two commands to change data: `UPDATE` and
    `DELETE`. Let''s discuss them in detail.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对插入和检索数据有了相当多的了解，但如果应用程序只能做到这一点，它们将非常静态。根据我们的需要编辑这些数据使应用程序变得动态，并给用户带来价值。在
    MySQL 以及大多数数据库系统中，你有两个命令来更改数据：`UPDATE` 和 `DELETE`。让我们详细讨论它们。
- en: Updating data
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新数据
- en: 'When updating data in MySQL, the most important thing is to have a unique reference
    of the row that you want to update. For this, primary keys are very useful; however,
    if you have a table with no primary keys, which should not be the case most of
    the time, you can still update the rows based on other fields. Other than the
    reference, you will need the new value and, of course, the table name and field
    to update. Let''s take a look at a very simple example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MySQL 中更新数据时，最重要的是有一个你想要更新的行的唯一引用。为此，主键非常有用；然而，如果你有一个没有主键的表，这在大多数情况下不应该发生，你仍然可以根据其他字段更新行。除了引用之外，你还需要新值，当然还有要更新的表名和字段。让我们看看一个非常简单的例子：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this `UPDATE` query, we set the price of the book with the ID 2 to `12.75`.
    The `SET` clause does not need to specify only one change; you can specify several
    changes on the same row as soon as you separate them by commas—for example, `SET
    price = 12.75, stock = 14`. Also, note the `WHERE` clause, in which we specify
    which rows we want to change. MySQL gets all the rows of this table based on these
    conditions as though it were a `SELECT` query and apply the change to this set
    of rows.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `UPDATE` 查询中，我们将 ID 为 2 的书的售价设置为 `12.75`。`SET` 子句不需要指定仅一个更改；你可以在用逗号分隔的情况下指定同一行的多个更改——例如，`SET
    price = 12.75, stock = 14`。此外，请注意 `WHERE` 子句，其中我们指定了要更改的行。MySQL 根据这些条件获取此表的所有行，就像它是一个
    `SELECT` 查询一样，并将更改应用于这些行集。
- en: 'What MySQL will return is very important: the number of rows matched and the
    number of rows changed. The first one is the number of rows that match the conditions
    in the `WHERE` clause. The second one specifies the amount of rows that can be
    changed. There are different reasons not to change a row—for example when the
    row already has the same value. To see this, let''s run the same query again:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 将返回的内容非常重要：匹配的行数和更改的行数。第一个是匹配 `WHERE` 子句条件的行数。第二个指定了可以更改的行数。有不同原因不更改一行——例如，当行已经具有相同的值时。为了看到这一点，让我们再次运行相同的查询：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The same row now says that there was `1` row matched, as expected, but `0` rows
    were changed. The reason is that we already set the price of this book to `12.75`,
    so MySQL does not need to do anything about this now.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在相同的行显示有 `1` 行匹配，这是预期的，但 `0` 行被更改。原因是我们已经将这本书的价格设置为 `12.75`，所以 MySQL 现在不需要对此做任何事情。
- en: As mentioned before, the `WHERE` clause is the most important bit in this query.
    Way too many times, we find developers that run a priori innocent `UPDATE` queries
    end up changing the whole table because they miss the `WHERE` clause; thus, MySQL
    matches the whole table as valid rows to update. This is usually not the intention
    of the developer, and it is something not very pleasant, so try to make sure you
    always provide a valid set of conditions. It is good practice to first write down
    the `SELECT` query that returns the rows you need to edit, and once you are sure
    that the conditions match the desired set of rows, you can write the `UPDATE`
    query.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`WHERE` 子句是此查询中最重要的部分。很多时候，我们发现一些开发者运行先验无辜的 `UPDATE` 查询，结果却因为遗漏了 `WHERE`
    子句而改变了整个表；因此，MySQL 会将整个表匹配为有效的更新行。这通常不是开发者的意图，而且这种情况并不愉快，所以请务必确保你总是提供一组有效的条件。首先写下返回你需要编辑的行的
    `SELECT` 查询是一个好习惯，一旦你确定条件与所需的行集匹配，你就可以编写 `UPDATE` 查询。
- en: 'However, sometimes, affecting multiple rows is the intended scenario. Imagine
    that we are going through tough times and need to increase the price of all our
    books. We decide that we want to increase the price by 16%, which is the same
    as the current price times 1.16\. We can run the following query to perform these
    changes:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时影响多行是预期的场景。想象一下，我们正经历艰难时期，需要提高我们所有书籍的价格。我们决定将价格提高 16%，即当前价格的 1.16 倍。我们可以运行以下查询来执行这些更改：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This query does not contain any `WHERE` clause as we want to match all our books.
    Also note that the `SET` clause uses the `price` field to get the current value
    for the price, which is perfectly valid. Finally, note the number of rows matched
    and changed, which is `8`—the whole set of rows for this table.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询不包含任何`WHERE`子句，因为我们想要匹配所有的书籍。此外，请注意，`SET`子句使用`price`字段来获取当前的价格值，这是完全有效的。最后，请注意匹配并更改的行数，这是`8`——这个表的整个行集。
- en: 'To finish with this subsection, let''s consider how we can use `UPDATE` queries
    from PHP through PDO. One very common scenario is when we want to add copies of
    the already existing books to our inventory. Given a book ID and an optional amount
    of books—by default, this value will be 1—we will increase the stock value of
    this book by these many copies. Write this function in your `init.php` file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个子节，让我们考虑如何使用PHP通过PDO执行`UPDATE`查询。一个非常常见的场景是我们想要将现有书籍的副本添加到我们的库存中。给定一个书籍ID和一个可选的书籍数量——默认情况下，这个值将是1——我们将通过这些副本增加这本书的库存值。在`init.php`文件中编写这个函数：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'There are two arguments: `$id` and `$amount`. The first one will always be
    mandatory, whereas the second one can be omitted, and the default value will be
    1\. The function first prepares a query similar to the first one of this section,
    in which we increased the amount of stock of a given book, then binds both parameters
    to the statement, and finally executes the query. If something happens and `execute`
    returns `false`, we will throw an exception with the content of the error message
    from MySQL.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个参数：`$id`和`$amount`。第一个始终是必需的，而第二个可以省略，默认值为1。函数首先准备一个类似于本节第一个查询的查询，其中我们增加了指定书籍的库存量，然后绑定这两个参数到语句中，并最终执行查询。如果发生某些情况并且`execute`返回`false`，我们将抛出一个包含MySQL错误消息内容的异常。
- en: This function is very useful when we either buy more stock or a customer returns
    a book. We could even use it to remove books by providing a negative value to
    `$amount`, but this is very bad practice. The reason is that even if we forced
    the stock field to be unsigned, setting it to a negative value will not trigger
    any error, only a warning. MySQL will not set the row to a negative value, but
    the `execute` invocation will return `true`, and we will not know about it. It
    is better to just create a second method, `removeBook`, and verify first that
    the amount of books to remove is lower than or equal to the current stock.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在我们购买更多股票或顾客归还书籍时非常有用。我们甚至可以通过给`$amount`提供一个负值来用它来移除书籍，但这是一种非常不好的做法。原因是即使我们强制股票字段为无符号，将其设置为负值也不会触发任何错误，只会显示警告。MySQL不会将行设置为负值，但`execute`调用将返回`true`，而我们却不会知道。更好的做法是创建一个名为`removeBook`的第二个方法，并首先验证要移除的书籍数量是否低于或等于当前库存。
- en: Foreign key behaviors
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外键行为
- en: One tricky thing to manage when updating or deleting rows is when the row that
    we update is part of a foreign key somewhere else. For example, our `borrowed_books`
    table contains the IDs of customers and books, and as you already know, MySQL
    enforces that these IDs are always valid and exist on these respective tables.
    What would happen, then, if we changed the ID of the book itself on the `book`
    table? Or even worse, what would happen if we removed one of the books from `book`,
    and there is a row in `borrowed_books` that references this ID?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新或删除行时需要管理的一个棘手问题是当我们更新的行是其他地方外键的一部分。例如，我们的`borrowed_books`表包含客户和书籍的ID，正如你所知道的那样，MySQL强制这些ID始终有效并且存在于这些相应的表中。那么，如果我们更改`book`表上书籍本身的ID会发生什么？或者更糟糕的是，如果我们从`book`中移除了一本书，并且`borrowed_books`表中有一行引用了这个ID，会发生什么？
- en: 'MySQL allows you to set the desired reaction when one of these scenarios takes
    place. It has to be defined when adding the foreign key; so, in our case, we will
    need to first remove the existing ones and then add them again. To remove or drop
    a key, you need to know the name of this key, which we can find using the `SHOW
    CREATE TABLE` command, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL允许你设置当这些场景之一发生时的期望反应。这必须在添加外键时定义；因此，在我们的情况下，我们首先需要删除现有的外键，然后再次添加。要删除或丢弃一个键，你需要知道这个键的名称，我们可以使用`SHOW
    CREATE TABLE`命令找到它，如下所示：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The two foreign keys that we want to remove are `borrowed_books_ibfk_1` and
    `borrowed_books_ibfk_2`. Let''s remove them using the `ALTER TABLE` command, as
    we did before:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要删除的两个外键是`borrowed_books_ibfk_1`和`borrowed_books_ibfk_2`。让我们使用`ALTER TABLE`命令来移除它们，就像我们之前做的那样：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we need to add the foreign keys again. The format of the command will
    be the same as when we added them, but appending the new desired behavior. In
    our case, if we remove a customer or book from our tables, we want to remove the
    rows referencing these books and customers from `borrowed_books`; so, we need
    to use the `CASCADE` option. Let''s consider what they would look like:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要再次添加外键。命令的格式将与添加时相同，但需要附加新的期望行为。在我们的情况下，如果我们从表中删除客户或书籍，我们希望从 `borrowed_books`
    中删除引用这些书籍和客户的行；因此，我们需要使用 `CASCADE` 选项。让我们考虑它们会是什么样子：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note that we can define the `CASCADE` behavior for both actions: when updating
    and when deleting rows. There are other options instead of `CASCADE`—for example
    `SET NULL`, which sets the foreign keys columns to `NULL` and allows the original
    row to be deleted, or the default one, `RESTRICT`, which rejects the update/delete
    commands.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以为这两种操作定义 `CASCADE` 行为：在更新和删除行时。除了 `CASCADE` 之外，还有其他选项——例如 `SET NULL`，它将外键列设置为
    `NULL`，允许删除原始行，或者默认的 `RESTRICT`，它拒绝更新/删除命令。
- en: Deleting data
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除数据
- en: Deleting data is almost the same as updating it. You need to provide a `WHERE`
    clause that will match the rows that you want to delete. Also, as with when updating
    data, it is highly recommended to first build the `SELECT` query that will retrieve
    the rows that you want to delete before performing the `DELETE` command. Do not
    think that you are wasting time with this methodology; as the saying goes, measure
    twice, cut once. Not always is it possible to recover data after deleting rows!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 删除数据几乎与更新相同。你需要提供一个 `WHERE` 子句来匹配你想要删除的行。同样，就像更新数据时一样，强烈建议在执行 `DELETE` 命令之前，首先构建一个
    `SELECT` 查询来检索你想要删除的行。不要认为你在这种方法上浪费时间；俗话说，量两次，切一次。删除行后，并不总是可能恢复数据！
- en: 'Let''s try to delete a book by observing how the `CASCADE` option we set earlier
    behaves. For this, let''s first query for the existing borrowed books list via
    the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过观察我们之前设置的 `CASCADE` 选项的行为来删除一本书。为此，我们首先通过以下查询获取现有的借阅书籍列表：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There are two different books, `1` and `4`, with each of them borrowed twice.
    Let''s try to delete the book with the ID 4\. First, build a query such as `SELECT
    * FROM book WHERE id = 4` to make sure that the condition in the `WHERE` clause
    is the appropriate one. Once you are sure, perform the following query:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有两本不同的书，`1` 和 `4`，每本书都被借阅了两次。让我们尝试删除 ID 为 4 的书籍。首先，构建一个查询，例如 `SELECT * FROM
    book WHERE id = 4`，以确保 `WHERE` 子句中的条件是适当的。一旦你确定，执行以下查询：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can note, we only specified the `DELETE FROM` command followed by the
    name of the table and the `WHERE` clause. MySQL tells us that there was `1` row
    affected, which makes sense, given the previous `SELECT` statement we made.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，我们只指定了 `DELETE FROM` 命令，后面跟着表名和 `WHERE` 子句。MySQL 告诉我们影响了 `1` 行，考虑到我们之前执行的
    `SELECT` 语句，这是有道理的。
- en: 'If we go back to our `borrowed_books` table and query for the existing ones,
    we will note that all the rows referencing the book with the ID 4 are gone. This
    is because when deleting them from the `book` table, MySQL noticed the foreign
    key reference, checked what it needed to do while deleting—in this case, `CASCADE`—and
    deleted also the rows in `borrowed_books`. Take a look at the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到我们的 `borrowed_books` 表并查询现有的记录，我们会注意到引用 ID 为 4 的书籍的所有行都消失了。这是因为当我们从 `book`
    表中删除它们时，MySQL 注意到了外键引用，检查了在删除时需要做什么——在这种情况下，`CASCADE`——然后也删除了 `borrowed_books`
    中的行。看看下面的例子：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Working with transactions
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事务
- en: In the previous section, we reiterated how important it is to make sure that
    an update or delete query contain the desirable matching set of rows. Even though
    this will always apply, there is a way to revert the changes that you just made,
    which is working with **transactions**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们再次强调了确保更新或删除查询包含期望的匹配行集的重要性。尽管这始终适用，但有一种方法可以撤销你刚刚所做的更改，那就是使用 **事务**。
- en: A transaction is a state where MySQL keeps track of all the changes that you
    make in your data in order to be able to revert all of them if needed. You need
    to explicitly start a transaction, and before you close the connection to the
    server, you need to commit your changes. This means that MySQL does not really
    perform these changes until you tell it to do so. If during a transaction you
    want to revert the changes, you should roll back instead of making a commit.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 事务是一个状态，MySQL 跟踪你在数据中做出的所有更改，以便在需要时能够撤销所有更改。你需要显式地开始一个事务，并且在关闭与服务器的连接之前，你需要提交你的更改。这意味着
    MySQL 不会真正执行这些更改，直到你告诉它这样做。如果在事务期间你想撤销更改，你应该回滚而不是提交。
- en: 'PDO allows you to do this with three functions:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: PDO 允许你通过三个函数来完成这个操作：
- en: '`beginTransaction`: This will start the transaction.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beginTransaction`: 这将开始事务。'
- en: '`commit`: This will commit your changes. Keep in mind that if you do not commit
    and the PHP script finishes or you close the connection explicitly, MySQL will
    reject all the changes you made during this transaction.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`commit`: 这将提交你的更改。请注意，如果你没有提交并且 PHP 脚本结束或者你显式地关闭了连接，MySQL 将会拒绝你在这次事务中做出的所有更改。'
- en: '`rollBack`: This will roll back all the changes that were made during this
    transaction.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rollBack`: 这将回滚在这次事务中做出的所有更改。'
- en: 'One possible use of transactions in your application is when you need to perform
    multiple queries and all of them have to be successful and the whole set of queries
    should not be performed otherwise. This would be the case when adding a sale into
    the database. Remember that our sales are stored in two tables: one for the sale
    itself and one for the list of books related to this sale. When adding a new one,
    you need to make sure that all the books are added to this database; otherwise,
    the sale will be corrupted. What you should do is execute all the queries, checking
    for their returning values. If any of them returns `false`, the whole sale should
    be rolled back.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中，事务的一个可能用途是在你需要执行多个查询，并且所有这些查询都必须成功，否则整个查询集不应该被执行的情况下。这将是将销售添加到数据库的情况。记住，我们的销售存储在两个表中：一个用于销售本身，另一个用于与这次销售相关的书籍列表。当你添加一个新的时，你需要确保所有书籍都添加到这个数据库中；否则，销售将被破坏。你应该执行所有查询，检查它们的返回值。如果任何一个返回
    `false`，整个销售应该被回滚。
- en: 'Let''s create an `addSale` function in your `init.php` file in order to emulate
    this behavior. The content should be as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `init.php` 文件中创建一个 `addSale` 函数来模拟这种行为。内容应该如下所示：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function is quite complex. It gets as arguments the ID of the customer
    and the list of books as we assume that the date of the sale is the current date.
    The first thing we will do is connect to the database, instantiating the `PDO`
    class. Right after this, we will begin our transaction, which will last only during
    the course of this function. Once we begin the transaction, we will open a `try…catch`
    block that will enclose the rest of the code of the function. The reason is that
    if we throw an exception, the `catch` block will capture it, rolling back the
    transaction and propagating the exception. The code inside the `try` block just
    adds first the sale and then iterates the list of books, inserting them into the
    database too. At all times, we will check the response of the `execute` function,
    and if it's `false`, we will throw an exception with the information of the error.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数相当复杂。它接受客户 ID 和书籍列表作为参数，因为我们假设销售日期是当前日期。我们首先要做的事情是连接到数据库，实例化 `PDO` 类。紧接着，我们将开始事务，这个事务只在这个函数的执行过程中持续。一旦开始事务，我们将打开一个
    `try…catch` 块，它将包含函数的其余代码。原因是如果我们抛出一个异常，`catch` 块将捕获它，回滚事务并传播异常。`try` 块内的代码只是首先添加销售，然后迭代书籍列表，并将它们也插入到数据库中。在所有时候，我们都会检查
    `execute` 函数的响应，如果它是 `false`，我们将抛出一个包含错误信息的异常。
- en: 'Let''s try to use this function. Write the following code that tries to add
    a sale for three books; however, one of them does not exist, which is the one
    with the ID 200:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用这个函数。编写以下代码尝试为三本书添加销售；然而，其中一本不存在，就是 ID 为 200 的那本：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This code will echo the error message, complaining about the nonexistent book.
    If you check in MySQL, there will be no rows in the `sales` table as the function
    rolled back when the exception was thrown.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将输出错误信息，抱怨不存在这本书。如果你在 MySQL 中检查，`sales` 表中将没有行，因为当抛出异常时函数已经回滚。
- en: 'Finally, let''s try the following code instead. This one will add three valid
    books so that the queries are always successful and the `try` block can go until
    the end, where we will commit the changes:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们尝试以下代码。这个代码将添加三本有效的书籍，以确保查询总是成功的，并且`try`块可以一直执行到末尾，在那里我们将提交更改：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Test it, and you will see how there is no message printed on your browser. Then,
    go to your database to make sure that there is a new `sales` row and there are
    three books linked to it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一下，你就会看到在你的浏览器上没有打印出任何消息。然后，前往你的数据库以确保有一个新的`sales`行，并且有三本书与之关联。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned the importance of databases and how to use them
    from our web application: from setting up the connection using PDO and creating
    and fetching data on demand to constructing more complex queries that fulfill
    our needs. With all of this, our application looks way more useful now than when
    it was completely static.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了数据库的重要性以及如何在我们的Web应用程序中使用它们：从使用PDO设置连接到按需创建和获取数据，再到构建满足我们需求的更复杂的查询。有了所有这些，我们的应用程序现在看起来比完全静态时更有用得多。
- en: In the next chapter, we will discover how to apply the most important design
    patterns for web applications through **Model View Controller** (**MVC**). You
    will gain a sense of clarity in your code when you organize your application in
    this way.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将发现如何通过**模型-视图-控制器**（**MVC**）应用Web应用程序最重要的设计模式。当你以这种方式组织应用程序时，你的代码将变得更加清晰。
