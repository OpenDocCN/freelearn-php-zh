- en: Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Indexes, which are a synonym for keys, are fields that do not need any special
    behavior as do the rest of the keys but they are important enough in our queries.
    So, we will ask MySQL to do some work with them in order to perform better when
    querying by this field. Do you remember when adding a foreign key that MySQL added
    extra keys to the table? Those were indexes too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about how the application will use the database. We want to show the
    catalog of books to our customers, but we cannot show all of them at once for
    sure. The customer will want to filter the results, and one of the most common
    ways of filtering is by specifying the title of the book that they are looking
    for. From this, we can extract that the title will be used to filter books quite
    often, so we want to add an index to this field. Let''s add the index via the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Remember that all other keys also provide indexing. IDs of books, customers
    and sales, ISBNs, and e-mails are already indexed, so there is no need to add
    another index here. Also, try not to add indexes to every single field as in doing
    so you will be **overindexing**, which would make some types of queries even slower
    than if they were without indexes!
  prefs: []
  type: TYPE_NORMAL
- en: Inserting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created the perfect tables to hold our data, but so far they are empty.
    It is time that we populate them. We delayed this moment as altering tables with
    data is more difficult than when they are empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to insert this data, we will use the `INSERT INTO` command. This command
    will take the name of the table, the fields that you want to populate, and the
    data for each field. Note that you can choose not to specify the value for a field,
    and there are different reasons to do this, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The field has a default value, and we are happy using it for this specific row
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though the field does not have an explicit default value, the field can
    take null values; so, by not specifying the field, MySQL will automatically insert
    a null here
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The field is a primary key and is autoincremental, and we want to let MySQL
    take the next ID for us
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are different reasons that can cause an `INSERT INTO` command to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: If you do not specify the value of a field and MySQL cannot provide a valid
    default value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value provided is not of the type of the field and MySQL fails to find
    a valid conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you specify that you want to set the value for a field but you fail to provide
    a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you provide a foreign key with an ID but the ID does not exist in the referenced
    table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to add rows. Let''s start with our `customer` table,
    adding one `basic` and one `premium`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that MySQL shows you some return information; in this case, it shows that
    there was one row affected, which is the row that we inserted. We did not provide
    an ID, so MySQL just added the next ones in the list. As it is the first time
    that we are adding data, MySQL used the IDs 1 and 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to trick MySQL and add another customer, repeating the e-mail address
    field that we set as unique in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: An error is returned with an error code and an error message, and the row was
    not inserted, of course. The error message usually contains enough information
    in order to understand the issue and how to fix it. If this is not the case, we
    can always try to search on the Internet using the error code and note what either
    the official documentation or other users have to say about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you need to introduce multiple rows to the same table and they contain
    the same fields, there is a shorter version of the command, in which you can specify
    the fields and then provide the groups of values for each row. Let''s take a look
    at how to use it when adding books to our `book` table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As with customers, we will not specify the ID and let MySQL choose the appropriate
    one. Note also that now the amount of affected rows is `5` as we inserted five
    rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we take advantage of the explicit defaults that we defined in our tables?
    Well, we can do this in the same way as we did with the primary keys: do not specify
    them in the fields list or in the values list, and MySQL will just use the default
    value. For example, we defined a default value of `1` for our `book.stock` field,
    which is a useful notation for the `book` table and the `stock` field. Let''s
    add another row using this default, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have books and customers, let''s add some historic data about customers
    borrowing books. For this, use the numeric IDs from `book` and `customer`, as
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Querying data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It took quite a lot of time, but we are finally in the most exciting—and useful—section
    related to databases: querying data. Querying data refers to asking MySQL to return
    rows from the specified table and optionally filtering these results by a set
    of rules. You can also choose to get specific fields instead of the whole row.
    In order to query data, we will use the `SELECT` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: One of the simplest ways to query data is to specify the fields of interest
    after `SELECT` and specify the table with the `FROM` keyword. As we did not add
    any filters—mostly known as conditions—to the query, we got all the rows there.
    Sometimes, this is the desired behavior, but the most common thing to do is to
    add conditions to the query to retrieve only the rows that we need. Use the `WHERE`
    keyword to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding conditions is very similar to when we created Boolean expressions in
    PHP. We will specify the name of the field, an operator, and a value, and MySQL
    will retrieve only the rows that return `true` to this expression. In this case,
    we asked for the customers that had the ID 1, and MySQL returned one row: the
    one that had an ID of exactly 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A common query would be to get the books that start with some text. We cannot
    construct this expression with any comparison operand that you know, such as `=`
    and `<` or `>`, since we want to match only a part of the string. For this, MySQL
    has the `LIKE` operator, which takes a string that can contain wildcards. A wildcard
    is a character that represents a rule, matching any number of characters that
    follows the rule. For example, the `%` wildcard represents any number of characters,
    so using the `1%` string would match any string that starts with 1 and is followed
    by any number or characters, matching strings such as `1984` or `1Q84`. Let''s
    consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We asked for all the books whose title starts with `1`, and we got three rows.
    You can imagine how useful this operator is, especially when we implement a search
    utility in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in PHP, MySQL also allows you to add logical operators—that is, operators
    that take operands and perform a logical operation, returning Boolean values as
    a result. The most common logical operators are, as in PHP, `AND` and `OR`. `AND`
    returns `true` if both the expressions are `true` and `OR` returns `true` if either
    of the operands is `true`. Let''s consider an example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This example is very similar to the previous one, but we added an extra condition.
    We asked for all titles starting with `1` and whether there is stock available.
    This is why one of the books does not show as it does not satisfy both conditions.
    You can add as many conditions as you need with logical operators but bear in
    mind that `AND` operators take precedence over `OR`. If you want to change this
    precedence, you can always wrap expressions with a parenthesis, as in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have retrieved specific fields when querying for data, but we could
    ask for all the fields in a given table. To do this, we will just use the `*`
    wildcard in `SELECT`. Let''s select all the fields for the customers via the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can retrieve more information than just fields. For example, you can use
    `COUNT` to retrieve the amount of rows that satisfy the given conditions instead
    of retrieving all the columns. This way is faster than retrieving all the columns
    and then counting them because you save time in reducing the size of the response.
    Let''s consider how it would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can note, the response says `1`, which means that there is only one
    borrowed book that satisfies the conditions. However, check the conditions; you
    will note that we used another familiar logical operator: `NOT`. `NOT` negates
    the expression, as `!` does in PHP. Note also that we do not use the equal sign
    to compare with null values. In MySQL, you have to use `IS` instead of the equals
    sign in order to compare with `NULL`. So, the second condition would be satisfied
    when a borrowed book has an end date that is not null.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s finish this section by adding two more features when querying data.
    The first one is the ability to specify in what order the rows should be returned.
    To do this, just use the keyword `ORDER BY` followed by the name of the field
    that you want to order by. You could also specify whether you want to order in
    ascending mode, which is by default, or in the descending mode, which can be done
    by appending `DESC`. The other feature is the ability to limit the amount of rows
    to return using `LIMIT` and the amount of rows to retrieve. Now, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using PDO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have worked with MySQL, and you already have a good idea of what
    you can do with it. However, connecting to the client and performing queries manually
    is not our goal. What we want to achieve is that our application can take advantage
    of the database in an automatic way. In order to do this, we will use a set of
    classes that comes with PHP and allows you to connect to the database and perform
    queries from the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**PHP Data Objects** (**PDO**) is the class that connects to the database and
    allows you to interact with it. This is the popular way to work with databases
    for PHP developers, even though there are other ways that we will not discuss
    here. PDO allows you to work with different database systems, so you are not tied
    to MySQL only. In the following sections, we will consider how to connect to a
    database, insert data, and retrieve it using this class.'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to connect to the database, it is good practice to keep the credentials—that
    is, the user and password—separated from the code in a configuration file. We
    already have this file as `config/app.json` from when we worked with the `Config`
    class. Let''s add the correct credentials for our database. If you have the configuration
    by default, the configuration file should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Developers usually specify other information related to the connection, such
    as the host, port, or name of the database. This will depend on how your application
    is installed, whether MySQL is running on a different server, and so on, and it
    is up to you how much information you want to keep on your code and in your configuration
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to connect to the database, we need to instantiate an object from
    the `PDO` class. The constructor of this class expects three arguments: **Data
    Source Name** (**DSN**), which is a string that represents the type of database
    to use; the name of the user; and the password. We already have the username and
    password from the `Config` class, but we still need to build DSN.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the formats for MySQL databases is `<database type>:host=<host>;dbname=<schema
    name>`. As our database system is MySQL, it runs on the same server, and the schema
    name is `bookstore`, DSN will be `mysql:host=127.0.0.1;dbname=bookstore`. Let''s
    take a look at how we will put everything together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note also that we will invoke the `setAttribute` method from the `PDO` instance.
    This method allows you to set some options to the connection; in this case, it
    sets the format of the results coming from MySQL. This option forces MySQL to
    return the arrays whose keys are the names of the fields, which is way more useful
    than the default one, returning numeric keys based on the order of the fields.
    Setting this option now will affect all the queries performed with the `$db` instance,
    rather than setting the option each time we perform a query.
  prefs: []
  type: TYPE_NORMAL
- en: Performing queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to retrieve data from your database is to use the `query` method.
    This method accepts the query as a string and returns a list of rows as arrays.
    Let''s consider an example: write the following after the initialization of the
    database connection—for example, in the `init.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This query tries to get all the books in the database, ordering them by the
    title. This could be the content of a function such as `getAllBooks`, which is
    used when we display our catalog. Each row is an array that contains all the fields
    as keys and the data as values.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the application on your browser, you will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performing queries](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `query` function is useful when we want to retrieve data, but in order
    to execute queries that insert rows, PDO provides the `exec` function. This function
    also expects the first parameter as a string, defining the query to execute, but
    it returns a Boolean specifying whether the execution was successful or not. A
    good example would be to try to insert books. Type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This code also uses a new way of representing strings: heredoc. We will enclose
    the string between `<<<SQL` and `SQL;`, both in different lines, instead of quotes.
    The benefit of this is the ability to write strings in multiple lines with tabulations
    or any other blank space, and PHP will respect it. We can construct queries that
    are easy to read rather than writing them on a single line or having to concatenate
    the different strings. Note that `SQL` is a token to represent the start and end
    of the string, but you could use any text that you consider.'
  prefs: []
  type: TYPE_NORMAL
- en: The first time you run the application with this code, the query will be executed
    successfully, and thus, the result will be the Boolean `true`. However, if you
    run it again, it will return `false` as the ISBN that we inserted is the same
    but we set its restriction to be unique.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is useful to know that a query failed, but it is better if we know why.
    The `PDO` instance has the `errorInfo` method that returns an array with the information
    of the last error. The key `2` contains the description, so it is probably the
    one that we will use more often. Update the previous code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The result is that the query failed because the ISBN entry was duplicated. Now,
    we can build more meaningful error messages for our customers or just for debugging
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Prepared statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous two functions are very useful when you need to run quick queries
    that are always the same. However, in the second example you might note that the
    string of the query is not very useful as it always inserts the same book. Although
    it is true that you could just replace the values by variables, it is not good
    practice as these variables usually come from the user side and can contain malicious
    code. It is always better to first sanitize these values.
  prefs: []
  type: TYPE_NORMAL
- en: 'PDO provides the ability to prepare a statement—that is, a query that is parameterized.
    You can specify parameters for the fields that will change in the query and then
    assign values to these parameters. Let''s consider first an example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The query is a normal one except that it has `:author` instead of the string
    of the author that we want to find. This is a parameter, and we will identify
    them using the prefix `:`. The `prepare` method gets the query as an argument
    and returns a `PDOStatement` instance. This class contains several methods to
    bind values, execute statements, fetch results, and more. In this piece of code,
    we use only three of them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bindValue`: This takes two arguments: the name of the parameter as described
    in the query and the value to assign. If you provide a parameter name that is
    not in the query, this will throw an exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execute`: This will send the query to MySQL with the replacement of the parameters
    by the provided values. If there is any parameter that is not assigned to a value,
    the method will throw an exception. As its brother `exec`, `execute` will return
    a Boolean, specifying whether the query was executed successfully or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetchAll`: This will retrieve the data from MySQL in case it was a `SELECT`
    query. As a query, `fetchAll` will return a list of all rows as arrays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you try this code, you will note that the result is very similar to when
    using `query`; however, this time, the code is much more dynamic as you can reuse
    it for any author that you need.
  prefs: []
  type: TYPE_NORMAL
- en: '![Prepared statements](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is another way to bind values to parameters of a query than using the
    `bindValue` method. You could prepare an array where the key is the name of the
    parameter and the value is the value you want to assign to it, and then you can
    send it as the first argument of the `execute` method. This way is quite useful
    as usually you already have this array prepared and do not need to call `bindValue`
    several times with its content. Add this code in order to test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this last example, we created a new book with almost all the parameters,
    but we did not specify the ID, which is the desired behavior as we want MySQL
    to choose a valid one for us. However, what happens if you want to know the ID
    of the inserted row? Well, you could query MySQL for the book with the same ISBN
    and the returned row would contain the ID, but this seems like a lot of work.
    Instead, PDO has the `lastInsertId` method, which returns the last ID inserted
    by a primary key, saving us from one extra query.
  prefs: []
  type: TYPE_NORMAL
- en: Joining tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even though querying MySQL is quite fast, especially if it is in the same server
    as our PHP application, we should try to reduce the number of queries that we
    will execute to improve the performance of our application. So far, we have queried
    data from just one table, but this is rarely the case. Imagine that you want to
    retrieve information about borrowed books: the table contains only IDs and dates,
    so if you query it, you will not get very meaningful data, right? One approach
    would be to query the data in `borrowed_books`, and based on the returning IDs,
    query the `book` and `customer` tables by filtering by the IDs we are interested
    in. However, this approach consists of at least three queries to MySQL and a lot
    of work with arrays in PHP. It seems as though there should be a better option!'
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, you can execute **join queries**. A join query is a query that joins
    two or more tables through a common field and, thus, allows you to retrieve data
    from these tables, reducing the amount of queries needed. Of course, the performance
    of a join query is not as good as the performance of a normal query, but if you
    have the correct keys and relationships defined, this option is way better than
    querying separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to join tables, you need to link them using a common field. Foreign
    keys are very useful in this matter as you know that both the fields are the same.
    Let''s take a look at how we would query for all the important info related to
    the borrowed books:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There are several new concepts introduced in this last query. Especially with
    joining queries, as we joined the fields of different tables, it might occur that
    two tables have the same field name, and MySQL needs us to differentiate them.
    The way we will differentiate two fields of two different tables is by prepending
    the name of the table. Imagine that we want to differentiate the ID of a customer
    from the ID of the book; we should use them as `customer.id` and `book.id`. However,
    writing the name of the table each time would make our queries endless.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL has the ability to add an alias to a table by just writing next to the
    table's real name, as we did in `borrowed_books` (`bb`), `customer` (`c`) or `book`
    (`b`). Once you add an alias, you can use it to reference this table, allowing
    us to write things such as `bb.customer_id` instead of `borrowed_books.customer_id`.
    It is also good practice to write the table of the field even if the field is
    not duplicated anywhere else as joining tables makes it a bit confusing to know
    where each field comes from.
  prefs: []
  type: TYPE_NORMAL
- en: When joining tables, you need to write them in the `FROM` clause using `LEFT
    JOIN`, followed by the name of the table, an optional alias, and the fields that
    connect both tables. There are different joining types, but let's focus on the
    most useful for our purposes. **Left joins** take each row from the first table—the
    one on the left-hand side of the definition—and search for the equivalent field
    in the right-hand side table. Once it finds it, it will concatenate both rows
    as if they were one. For example, when joining `borrowed_books` with `customer`
    for each `borrowed_books` row, MySQL will search for an ID in `customer` that
    matches the current `customer_id`, and then it will add all the information of
    this row in our current row in `borrowed_books` as if they were only one big table.
    As `customer_id` is a foreign key, we are certain that there will always be a
    customer to match.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can join several tables, and MySQL will just resolve them from left to
    right; that is, it will first join the two first tables as one, then try to join
    this resulting one with the third table, and so on. This is, in fact, what we
    did in our example: we first joined `borrowed_books` with `customer` and then
    joined these two with `book`.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can note, there are also aliases for fields. Sometimes, we do more than
    just getting a field; an example was when we got how many rows a query matched
    with `COUNT(*)`. However, the title of the column when retrieving this information
    was also `COUNT(*)`, which is not always useful. At other times, we used two tables
    with colliding field names, and it makes everything confusing. When this happens,
    just add an alias to the field in the same way we did with table names; `AS` is
    optional, but it helps to understand what you are doing.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move now to the usage of dates in this query. On one hand, we will use
    `DATE_FORMAT` for the first time. It accepts the date/time/datetime value and
    the string with the format. In this case, we used `%d-%m-%y`, which means day-month-year,
    but we could use `%h-%i-%s` to specify hours-minutes-seconds or any other combination.
  prefs: []
  type: TYPE_NORMAL
- en: Note also how we compared dates in the `WHERE` clause. Given two dates or time
    values of the same type, you can use the comparison operators as if they were
    numbers. In this case, we will do `bb.start >= "2015-01-01"`, which will give
    us the borrowed books from January 1, 2015, onward.
  prefs: []
  type: TYPE_NORMAL
- en: The final thing to note about this complex query is the use of the `CONCAT`
    function. Instead of returning two fields, one for the name and one for the surname,
    we want to get the full name. To do this, we will concatenate the fields using
    this function, sending as many strings as we want as arguments of the function
    and getting back the concatenated string. As you can see, you can send both fields
    and strings enclosed by single quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Well, if you fully understood this query, you should feel satisfied with yourself;
    this was the most complex query we will see in this chapter. We hope you can get
    a sense of how powerful a database system can be and that from now on, you will
    try to process the data as much as you can on the database side instead of the
    PHP side. If you set the correct indexes, it will perform better.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last feature that we will discuss about querying is the `GROUP BY` clause.
    This clause allows you to group rows of the same table with a common field. For
    example, let''s say we want to know how many books each author has in just one
    query. Try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GROUP BY` clause, always after the `WHERE` clause, gets a field—or many,
    separated by a coma—and treats all the rows with the same value for this field,
    as though they were just one. Thus, selecting by author will group all the rows
    that contain the same author. The feature might not seem very useful, but there
    are several functions in MySQL that take advantage of it. In this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`COUNT(*)` is used in queries with `GROUP BY` and shows how many rows this
    field groups. In this case, we will use it to know how many books each author
    has. In fact, it always works like this; however, for queries without `GROUP BY`,
    MySQL treats the whole set of rows as one group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GROUP_CONCAT` is similar to `CONCAT`, which we discussed earlier. The only
    difference is that this time the function will concatenate the fields of all the
    rows of a group. If you do not specify `SEPARATOR`, MySQL will use a single coma.
    However, in our case, we needed a coma and a space to make it readable, so we
    added `SEPARATOR '', ''` at the end. Note that you can add as many things to concatenate
    as you need in `CONCAT`, the separator will just separate the concatenations by
    rows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though it is not about grouping, note the `ORDER` clause that we added.
    We ordered by two fields instead of one. This means that MySQL will order all
    the rows by the `amount` field; note that this is an alias, but you can use it
    here as well. Then, MySQL will order each group of rows with the same `amount`
    value by the `title` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one last thing to remember as we already presented all the important
    clauses that a `SELECT` query can contain: MySQL expects the clauses of the query
    to be always in the same order. If you write the same query but change this order,
    you will get an error. The order is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FROM`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`WHERE`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GROUP BY`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ORDER BY`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating and deleting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already know quite a lot about inserting and retrieving data, but if applications
    could only do this, they would be quite static. Editing this data as we need is
    what makes an application dynamic and what gives to the user some value. In MySQL,
    and in most database systems, you have two commands to change data: `UPDATE` and
    `DELETE`. Let''s discuss them in detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Updating data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When updating data in MySQL, the most important thing is to have a unique reference
    of the row that you want to update. For this, primary keys are very useful; however,
    if you have a table with no primary keys, which should not be the case most of
    the time, you can still update the rows based on other fields. Other than the
    reference, you will need the new value and, of course, the table name and field
    to update. Let''s take a look at a very simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this `UPDATE` query, we set the price of the book with the ID 2 to `12.75`.
    The `SET` clause does not need to specify only one change; you can specify several
    changes on the same row as soon as you separate them by commas—for example, `SET
    price = 12.75, stock = 14`. Also, note the `WHERE` clause, in which we specify
    which rows we want to change. MySQL gets all the rows of this table based on these
    conditions as though it were a `SELECT` query and apply the change to this set
    of rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'What MySQL will return is very important: the number of rows matched and the
    number of rows changed. The first one is the number of rows that match the conditions
    in the `WHERE` clause. The second one specifies the amount of rows that can be
    changed. There are different reasons not to change a row—for example when the
    row already has the same value. To see this, let''s run the same query again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The same row now says that there was `1` row matched, as expected, but `0` rows
    were changed. The reason is that we already set the price of this book to `12.75`,
    so MySQL does not need to do anything about this now.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, the `WHERE` clause is the most important bit in this query.
    Way too many times, we find developers that run a priori innocent `UPDATE` queries
    end up changing the whole table because they miss the `WHERE` clause; thus, MySQL
    matches the whole table as valid rows to update. This is usually not the intention
    of the developer, and it is something not very pleasant, so try to make sure you
    always provide a valid set of conditions. It is good practice to first write down
    the `SELECT` query that returns the rows you need to edit, and once you are sure
    that the conditions match the desired set of rows, you can write the `UPDATE`
    query.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, sometimes, affecting multiple rows is the intended scenario. Imagine
    that we are going through tough times and need to increase the price of all our
    books. We decide that we want to increase the price by 16%, which is the same
    as the current price times 1.16\. We can run the following query to perform these
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This query does not contain any `WHERE` clause as we want to match all our books.
    Also note that the `SET` clause uses the `price` field to get the current value
    for the price, which is perfectly valid. Finally, note the number of rows matched
    and changed, which is `8`—the whole set of rows for this table.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish with this subsection, let''s consider how we can use `UPDATE` queries
    from PHP through PDO. One very common scenario is when we want to add copies of
    the already existing books to our inventory. Given a book ID and an optional amount
    of books—by default, this value will be 1—we will increase the stock value of
    this book by these many copies. Write this function in your `init.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two arguments: `$id` and `$amount`. The first one will always be
    mandatory, whereas the second one can be omitted, and the default value will be
    1\. The function first prepares a query similar to the first one of this section,
    in which we increased the amount of stock of a given book, then binds both parameters
    to the statement, and finally executes the query. If something happens and `execute`
    returns `false`, we will throw an exception with the content of the error message
    from MySQL.'
  prefs: []
  type: TYPE_NORMAL
- en: This function is very useful when we either buy more stock or a customer returns
    a book. We could even use it to remove books by providing a negative value to
    `$amount`, but this is very bad practice. The reason is that even if we forced
    the stock field to be unsigned, setting it to a negative value will not trigger
    any error, only a warning. MySQL will not set the row to a negative value, but
    the `execute` invocation will return `true`, and we will not know about it. It
    is better to just create a second method, `removeBook`, and verify first that
    the amount of books to remove is lower than or equal to the current stock.
  prefs: []
  type: TYPE_NORMAL
- en: Foreign key behaviors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One tricky thing to manage when updating or deleting rows is when the row that
    we update is part of a foreign key somewhere else. For example, our `borrowed_books`
    table contains the IDs of customers and books, and as you already know, MySQL
    enforces that these IDs are always valid and exist on these respective tables.
    What would happen, then, if we changed the ID of the book itself on the `book`
    table? Or even worse, what would happen if we removed one of the books from `book`,
    and there is a row in `borrowed_books` that references this ID?
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL allows you to set the desired reaction when one of these scenarios takes
    place. It has to be defined when adding the foreign key; so, in our case, we will
    need to first remove the existing ones and then add them again. To remove or drop
    a key, you need to know the name of this key, which we can find using the `SHOW
    CREATE TABLE` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The two foreign keys that we want to remove are `borrowed_books_ibfk_1` and
    `borrowed_books_ibfk_2`. Let''s remove them using the `ALTER TABLE` command, as
    we did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to add the foreign keys again. The format of the command will
    be the same as when we added them, but appending the new desired behavior. In
    our case, if we remove a customer or book from our tables, we want to remove the
    rows referencing these books and customers from `borrowed_books`; so, we need
    to use the `CASCADE` option. Let''s consider what they would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we can define the `CASCADE` behavior for both actions: when updating
    and when deleting rows. There are other options instead of `CASCADE`—for example
    `SET NULL`, which sets the foreign keys columns to `NULL` and allows the original
    row to be deleted, or the default one, `RESTRICT`, which rejects the update/delete
    commands.'
  prefs: []
  type: TYPE_NORMAL
- en: Deleting data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deleting data is almost the same as updating it. You need to provide a `WHERE`
    clause that will match the rows that you want to delete. Also, as with when updating
    data, it is highly recommended to first build the `SELECT` query that will retrieve
    the rows that you want to delete before performing the `DELETE` command. Do not
    think that you are wasting time with this methodology; as the saying goes, measure
    twice, cut once. Not always is it possible to recover data after deleting rows!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to delete a book by observing how the `CASCADE` option we set earlier
    behaves. For this, let''s first query for the existing borrowed books list via
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two different books, `1` and `4`, with each of them borrowed twice.
    Let''s try to delete the book with the ID 4\. First, build a query such as `SELECT
    * FROM book WHERE id = 4` to make sure that the condition in the `WHERE` clause
    is the appropriate one. Once you are sure, perform the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can note, we only specified the `DELETE FROM` command followed by the
    name of the table and the `WHERE` clause. MySQL tells us that there was `1` row
    affected, which makes sense, given the previous `SELECT` statement we made.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we go back to our `borrowed_books` table and query for the existing ones,
    we will note that all the rows referencing the book with the ID 4 are gone. This
    is because when deleting them from the `book` table, MySQL noticed the foreign
    key reference, checked what it needed to do while deleting—in this case, `CASCADE`—and
    deleted also the rows in `borrowed_books`. Take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Working with transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we reiterated how important it is to make sure that
    an update or delete query contain the desirable matching set of rows. Even though
    this will always apply, there is a way to revert the changes that you just made,
    which is working with **transactions**.
  prefs: []
  type: TYPE_NORMAL
- en: A transaction is a state where MySQL keeps track of all the changes that you
    make in your data in order to be able to revert all of them if needed. You need
    to explicitly start a transaction, and before you close the connection to the
    server, you need to commit your changes. This means that MySQL does not really
    perform these changes until you tell it to do so. If during a transaction you
    want to revert the changes, you should roll back instead of making a commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'PDO allows you to do this with three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`beginTransaction`: This will start the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`commit`: This will commit your changes. Keep in mind that if you do not commit
    and the PHP script finishes or you close the connection explicitly, MySQL will
    reject all the changes you made during this transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rollBack`: This will roll back all the changes that were made during this
    transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One possible use of transactions in your application is when you need to perform
    multiple queries and all of them have to be successful and the whole set of queries
    should not be performed otherwise. This would be the case when adding a sale into
    the database. Remember that our sales are stored in two tables: one for the sale
    itself and one for the list of books related to this sale. When adding a new one,
    you need to make sure that all the books are added to this database; otherwise,
    the sale will be corrupted. What you should do is execute all the queries, checking
    for their returning values. If any of them returns `false`, the whole sale should
    be rolled back.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an `addSale` function in your `init.php` file in order to emulate
    this behavior. The content should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This function is quite complex. It gets as arguments the ID of the customer
    and the list of books as we assume that the date of the sale is the current date.
    The first thing we will do is connect to the database, instantiating the `PDO`
    class. Right after this, we will begin our transaction, which will last only during
    the course of this function. Once we begin the transaction, we will open a `try…catch`
    block that will enclose the rest of the code of the function. The reason is that
    if we throw an exception, the `catch` block will capture it, rolling back the
    transaction and propagating the exception. The code inside the `try` block just
    adds first the sale and then iterates the list of books, inserting them into the
    database too. At all times, we will check the response of the `execute` function,
    and if it's `false`, we will throw an exception with the information of the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to use this function. Write the following code that tries to add
    a sale for three books; however, one of them does not exist, which is the one
    with the ID 200:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This code will echo the error message, complaining about the nonexistent book.
    If you check in MySQL, there will be no rows in the `sales` table as the function
    rolled back when the exception was thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s try the following code instead. This one will add three valid
    books so that the queries are always successful and the `try` block can go until
    the end, where we will commit the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Test it, and you will see how there is no message printed on your browser. Then,
    go to your database to make sure that there is a new `sales` row and there are
    three books linked to it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned the importance of databases and how to use them
    from our web application: from setting up the connection using PDO and creating
    and fetching data on demand to constructing more complex queries that fulfill
    our needs. With all of this, our application looks way more useful now than when
    it was completely static.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discover how to apply the most important design
    patterns for web applications through **Model View Controller** (**MVC**). You
    will gain a sense of clarity in your code when you organize your application in
    this way.
  prefs: []
  type: TYPE_NORMAL
