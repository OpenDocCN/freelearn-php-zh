- en: Indexes
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Indexes, which are a synonym for keys, are fields that do not need any special
    behavior as do the rest of the keys but they are important enough in our queries.
    So, we will ask MySQL to do some work with them in order to perform better when
    querying by this field. Do you remember when adding a foreign key that MySQL added
    extra keys to the table? Those were indexes too.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about how the application will use the database. We want to show the
    catalog of books to our customers, but we cannot show all of them at once for
    sure. The customer will want to filter the results, and one of the most common
    ways of filtering is by specifying the title of the book that they are looking
    for. From this, we can extract that the title will be used to filter books quite
    often, so we want to add an index to this field. Let''s add the index via the
    following code:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Remember that all other keys also provide indexing. IDs of books, customers
    and sales, ISBNs, and e-mails are already indexed, so there is no need to add
    another index here. Also, try not to add indexes to every single field as in doing
    so you will be **overindexing**, which would make some types of queries even slower
    than if they were without indexes!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Inserting data
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created the perfect tables to hold our data, but so far they are empty.
    It is time that we populate them. We delayed this moment as altering tables with
    data is more difficult than when they are empty.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to insert this data, we will use the `INSERT INTO` command. This command
    will take the name of the table, the fields that you want to populate, and the
    data for each field. Note that you can choose not to specify the value for a field,
    and there are different reasons to do this, which are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The field has a default value, and we are happy using it for this specific row
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though the field does not have an explicit default value, the field can
    take null values; so, by not specifying the field, MySQL will automatically insert
    a null here
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The field is a primary key and is autoincremental, and we want to let MySQL
    take the next ID for us
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are different reasons that can cause an `INSERT INTO` command to fail:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: If you do not specify the value of a field and MySQL cannot provide a valid
    default value
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value provided is not of the type of the field and MySQL fails to find
    a valid conversion
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you specify that you want to set the value for a field but you fail to provide
    a value
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you provide a foreign key with an ID but the ID does not exist in the referenced
    table
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to add rows. Let''s start with our `customer` table,
    adding one `basic` and one `premium`, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that MySQL shows you some return information; in this case, it shows that
    there was one row affected, which is the row that we inserted. We did not provide
    an ID, so MySQL just added the next ones in the list. As it is the first time
    that we are adding data, MySQL used the IDs 1 and 2.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to trick MySQL and add another customer, repeating the e-mail address
    field that we set as unique in the previous section:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试欺骗MySQL并添加另一个客户，重复我们在上一节中设置为唯一的电子邮件地址字段：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: An error is returned with an error code and an error message, and the row was
    not inserted, of course. The error message usually contains enough information
    in order to understand the issue and how to fix it. If this is not the case, we
    can always try to search on the Internet using the error code and note what either
    the official documentation or other users have to say about it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 返回了一个带有错误代码和错误信息的错误，当然，行没有被插入。错误信息通常包含足够的信息，以便理解问题及其解决方法。如果不是这样，我们总是可以尝试使用错误代码在互联网上搜索，并注意官方文档或其他用户对此有何评论。
- en: 'In case you need to introduce multiple rows to the same table and they contain
    the same fields, there is a shorter version of the command, in which you can specify
    the fields and then provide the groups of values for each row. Let''s take a look
    at how to use it when adding books to our `book` table, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要向同一表中引入多行，并且它们包含相同的字段，则有一个简短的命令版本，您可以在其中指定字段，然后为每行提供值组。让我们看看在向我们的`book`表添加书籍时如何使用它，如下所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As with customers, we will not specify the ID and let MySQL choose the appropriate
    one. Note also that now the amount of affected rows is `5` as we inserted five
    rows.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与客户一样，我们不会指定ID，让MySQL选择合适的ID。注意，现在受影响的行数是`5`，因为我们插入了五行。
- en: 'How can we take advantage of the explicit defaults that we defined in our tables?
    Well, we can do this in the same way as we did with the primary keys: do not specify
    them in the fields list or in the values list, and MySQL will just use the default
    value. For example, we defined a default value of `1` for our `book.stock` field,
    which is a useful notation for the `book` table and the `stock` field. Let''s
    add another row using this default, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何利用我们在表中定义的显式默认值？嗯，我们可以用与处理主键相同的方式来做这件事：不要在字段列表或值列表中指定它们，MySQL将直接使用默认值。例如，我们为`book.stock`字段定义了一个默认值`1`，这对于`book`表和`stock`字段来说是一个有用的表示法。让我们使用这个默认值添加另一行，如下所示：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have books and customers, let''s add some historic data about customers
    borrowing books. For this, use the numeric IDs from `book` and `customer`, as
    in the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了书籍和客户，让我们添加一些关于客户借阅书籍的历史数据。为此，使用`book`和`customer`的数字ID，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Querying data
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询数据
- en: 'It took quite a lot of time, but we are finally in the most exciting—and useful—section
    related to databases: querying data. Querying data refers to asking MySQL to return
    rows from the specified table and optionally filtering these results by a set
    of rules. You can also choose to get specific fields instead of the whole row.
    In order to query data, we will use the `SELECT` command, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 花了相当多的时间，但我们终于到达了与数据库最激动人心——也是最有用——的部分：查询数据。查询数据是指要求MySQL从指定的表中返回行，并可选择通过一组规则过滤这些结果。您也可以选择获取特定的字段而不是整个行。为了查询数据，我们将使用`SELECT`命令，如下所示：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: One of the simplest ways to query data is to specify the fields of interest
    after `SELECT` and specify the table with the `FROM` keyword. As we did not add
    any filters—mostly known as conditions—to the query, we got all the rows there.
    Sometimes, this is the desired behavior, but the most common thing to do is to
    add conditions to the query to retrieve only the rows that we need. Use the `WHERE`
    keyword to achieve this.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 查询数据的一种最简单的方法是在`SELECT`之后指定感兴趣的字段，并使用`FROM`关键字指定表。由于我们没有在查询中添加任何过滤器——通常称为条件——所以我们得到了所有这些行。有时，这可能是期望的行为，但最常见的事情是向查询中添加条件，以检索我们需要的行。使用`WHERE`关键字来实现这一点。
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Adding conditions is very similar to when we created Boolean expressions in
    PHP. We will specify the name of the field, an operator, and a value, and MySQL
    will retrieve only the rows that return `true` to this expression. In this case,
    we asked for the customers that had the ID 1, and MySQL returned one row: the
    one that had an ID of exactly 1.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 添加条件与我们在PHP中创建布尔表达式时非常相似。我们将指定字段名、运算符和值，MySQL将只检索返回此表达式的`true`的行。在这种情况下，我们要求具有ID
    1的客户，MySQL返回了一行：具有确切ID为1的那一行。
- en: 'A common query would be to get the books that start with some text. We cannot
    construct this expression with any comparison operand that you know, such as `=`
    and `<` or `>`, since we want to match only a part of the string. For this, MySQL
    has the `LIKE` operator, which takes a string that can contain wildcards. A wildcard
    is a character that represents a rule, matching any number of characters that
    follows the rule. For example, the `%` wildcard represents any number of characters,
    so using the `1%` string would match any string that starts with 1 and is followed
    by any number or characters, matching strings such as `1984` or `1Q84`. Let''s
    consider the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We asked for all the books whose title starts with `1`, and we got three rows.
    You can imagine how useful this operator is, especially when we implement a search
    utility in our application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'As in PHP, MySQL also allows you to add logical operators—that is, operators
    that take operands and perform a logical operation, returning Boolean values as
    a result. The most common logical operators are, as in PHP, `AND` and `OR`. `AND`
    returns `true` if both the expressions are `true` and `OR` returns `true` if either
    of the operands is `true`. Let''s consider an example, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This example is very similar to the previous one, but we added an extra condition.
    We asked for all titles starting with `1` and whether there is stock available.
    This is why one of the books does not show as it does not satisfy both conditions.
    You can add as many conditions as you need with logical operators but bear in
    mind that `AND` operators take precedence over `OR`. If you want to change this
    precedence, you can always wrap expressions with a parenthesis, as in PHP.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have retrieved specific fields when querying for data, but we could
    ask for all the fields in a given table. To do this, we will just use the `*`
    wildcard in `SELECT`. Let''s select all the fields for the customers via the following
    code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can retrieve more information than just fields. For example, you can use
    `COUNT` to retrieve the amount of rows that satisfy the given conditions instead
    of retrieving all the columns. This way is faster than retrieving all the columns
    and then counting them because you save time in reducing the size of the response.
    Let''s consider how it would look:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can note, the response says `1`, which means that there is only one
    borrowed book that satisfies the conditions. However, check the conditions; you
    will note that we used another familiar logical operator: `NOT`. `NOT` negates
    the expression, as `!` does in PHP. Note also that we do not use the equal sign
    to compare with null values. In MySQL, you have to use `IS` instead of the equals
    sign in order to compare with `NULL`. So, the second condition would be satisfied
    when a borrowed book has an end date that is not null.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s finish this section by adding two more features when querying data.
    The first one is the ability to specify in what order the rows should be returned.
    To do this, just use the keyword `ORDER BY` followed by the name of the field
    that you want to order by. You could also specify whether you want to order in
    ascending mode, which is by default, or in the descending mode, which can be done
    by appending `DESC`. The other feature is the ability to limit the amount of rows
    to return using `LIMIT` and the amount of rows to retrieve. Now, run the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using PDO
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have worked with MySQL, and you already have a good idea of what
    you can do with it. However, connecting to the client and performing queries manually
    is not our goal. What we want to achieve is that our application can take advantage
    of the database in an automatic way. In order to do this, we will use a set of
    classes that comes with PHP and allows you to connect to the database and perform
    queries from the code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '**PHP Data Objects** (**PDO**) is the class that connects to the database and
    allows you to interact with it. This is the popular way to work with databases
    for PHP developers, even though there are other ways that we will not discuss
    here. PDO allows you to work with different database systems, so you are not tied
    to MySQL only. In the following sections, we will consider how to connect to a
    database, insert data, and retrieve it using this class.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the database
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to connect to the database, it is good practice to keep the credentials—that
    is, the user and password—separated from the code in a configuration file. We
    already have this file as `config/app.json` from when we worked with the `Config`
    class. Let''s add the correct credentials for our database. If you have the configuration
    by default, the configuration file should look similar to this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Developers usually specify other information related to the connection, such
    as the host, port, or name of the database. This will depend on how your application
    is installed, whether MySQL is running on a different server, and so on, and it
    is up to you how much information you want to keep on your code and in your configuration
    files.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to connect to the database, we need to instantiate an object from
    the `PDO` class. The constructor of this class expects three arguments: **Data
    Source Name** (**DSN**), which is a string that represents the type of database
    to use; the name of the user; and the password. We already have the username and
    password from the `Config` class, but we still need to build DSN.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the formats for MySQL databases is `<database type>:host=<host>;dbname=<schema
    name>`. As our database system is MySQL, it runs on the same server, and the schema
    name is `bookstore`, DSN will be `mysql:host=127.0.0.1;dbname=bookstore`. Let''s
    take a look at how we will put everything together:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note also that we will invoke the `setAttribute` method from the `PDO` instance.
    This method allows you to set some options to the connection; in this case, it
    sets the format of the results coming from MySQL. This option forces MySQL to
    return the arrays whose keys are the names of the fields, which is way more useful
    than the default one, returning numeric keys based on the order of the fields.
    Setting this option now will affect all the queries performed with the `$db` instance,
    rather than setting the option each time we perform a query.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Performing queries
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to retrieve data from your database is to use the `query` method.
    This method accepts the query as a string and returns a list of rows as arrays.
    Let''s consider an example: write the following after the initialization of the
    database connection—for example, in the `init.php` file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This query tries to get all the books in the database, ordering them by the
    title. This could be the content of a function such as `getAllBooks`, which is
    used when we display our catalog. Each row is an array that contains all the fields
    as keys and the data as values.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the application on your browser, you will get the following result:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![Performing queries](img/00027.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: 'The `query` function is useful when we want to retrieve data, but in order
    to execute queries that insert rows, PDO provides the `exec` function. This function
    also expects the first parameter as a string, defining the query to execute, but
    it returns a Boolean specifying whether the execution was successful or not. A
    good example would be to try to insert books. Type the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code also uses a new way of representing strings: heredoc. We will enclose
    the string between `<<<SQL` and `SQL;`, both in different lines, instead of quotes.
    The benefit of this is the ability to write strings in multiple lines with tabulations
    or any other blank space, and PHP will respect it. We can construct queries that
    are easy to read rather than writing them on a single line or having to concatenate
    the different strings. Note that `SQL` is a token to represent the start and end
    of the string, but you could use any text that you consider.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The first time you run the application with this code, the query will be executed
    successfully, and thus, the result will be the Boolean `true`. However, if you
    run it again, it will return `false` as the ISBN that we inserted is the same
    but we set its restriction to be unique.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'It is useful to know that a query failed, but it is better if we know why.
    The `PDO` instance has the `errorInfo` method that returns an array with the information
    of the last error. The key `2` contains the description, so it is probably the
    one that we will use more often. Update the previous code with the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The result is that the query failed because the ISBN entry was duplicated. Now,
    we can build more meaningful error messages for our customers or just for debugging
    purposes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Prepared statements
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous two functions are very useful when you need to run quick queries
    that are always the same. However, in the second example you might note that the
    string of the query is not very useful as it always inserts the same book. Although
    it is true that you could just replace the values by variables, it is not good
    practice as these variables usually come from the user side and can contain malicious
    code. It is always better to first sanitize these values.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个函数在你需要运行总是相同的快速查询时非常有用。然而，在第二个例子中，你可能注意到查询字符串并不很有用，因为它总是插入相同的书籍。虽然确实可以通过变量替换这些值，但这不是好的做法，因为这些变量通常来自用户端，可能包含恶意代码。总是先清理这些值会更好。
- en: 'PDO provides the ability to prepare a statement—that is, a query that is parameterized.
    You can specify parameters for the fields that will change in the query and then
    assign values to these parameters. Let''s consider first an example, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: PDO提供了准备语句的能力——即参数化的查询。你可以指定将改变查询的字段参数，然后为这些参数分配值。让我们首先考虑以下示例：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The query is a normal one except that it has `:author` instead of the string
    of the author that we want to find. This is a parameter, and we will identify
    them using the prefix `:`. The `prepare` method gets the query as an argument
    and returns a `PDOStatement` instance. This class contains several methods to
    bind values, execute statements, fetch results, and more. In this piece of code,
    we use only three of them, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 查询本身是一个普通的查询，只是它使用`:author`而不是我们想要查找的作者字符串。这是一个参数，我们将使用前缀`:`来识别它们。`prepare`方法将查询作为参数接收并返回一个`PDOStatement`实例。这个类包含多个方法来绑定值、执行语句、获取结果等。在这段代码中，我们只使用了其中三个，如下所示：
- en: '`bindValue`: This takes two arguments: the name of the parameter as described
    in the query and the value to assign. If you provide a parameter name that is
    not in the query, this will throw an exception.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bindValue`：它接受两个参数：查询中描述的参数名称和要分配的值。如果你提供了一个不在查询中的参数名称，这将抛出异常。'
- en: '`execute`: This will send the query to MySQL with the replacement of the parameters
    by the provided values. If there is any parameter that is not assigned to a value,
    the method will throw an exception. As its brother `exec`, `execute` will return
    a Boolean, specifying whether the query was executed successfully or not.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute`：这将发送查询到MySQL，并用提供的值替换参数。如果有任何参数没有分配值，该方法将抛出异常。与它的兄弟`exec`一样，`execute`将返回一个布尔值，指定查询是否成功执行。'
- en: '`fetchAll`: This will retrieve the data from MySQL in case it was a `SELECT`
    query. As a query, `fetchAll` will return a list of all rows as arrays.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetchAll`：如果这是一个`SELECT`查询，这将从MySQL检索数据。作为一个查询，`fetchAll`将返回所有行的数组列表。'
- en: If you try this code, you will note that the result is very similar to when
    using `query`; however, this time, the code is much more dynamic as you can reuse
    it for any author that you need.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试这段代码，你会注意到结果与使用`query`时非常相似；然而，这次代码要动态得多，因为你可以为任何需要的作者重用它。
- en: '![Prepared statements](img/00028.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![准备好的语句](img/00028.jpeg)'
- en: 'There is another way to bind values to parameters of a query than using the
    `bindValue` method. You could prepare an array where the key is the name of the
    parameter and the value is the value you want to assign to it, and then you can
    send it as the first argument of the `execute` method. This way is quite useful
    as usually you already have this array prepared and do not need to call `bindValue`
    several times with its content. Add this code in order to test it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`bindValue`方法外，还有另一种方法可以将值绑定到查询的参数。你可以准备一个数组，其中键是参数的名称，值是你想要分配给它的值，然后你可以将其作为`execute`方法的第一个参数发送。这种方法非常有用，因为你通常已经准备好了这个数组，不需要多次调用`bindValue`及其内容。添加以下代码以进行测试：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this last example, we created a new book with almost all the parameters,
    but we did not specify the ID, which is the desired behavior as we want MySQL
    to choose a valid one for us. However, what happens if you want to know the ID
    of the inserted row? Well, you could query MySQL for the book with the same ISBN
    and the returned row would contain the ID, but this seems like a lot of work.
    Instead, PDO has the `lastInsertId` method, which returns the last ID inserted
    by a primary key, saving us from one extra query.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Joining tables
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even though querying MySQL is quite fast, especially if it is in the same server
    as our PHP application, we should try to reduce the number of queries that we
    will execute to improve the performance of our application. So far, we have queried
    data from just one table, but this is rarely the case. Imagine that you want to
    retrieve information about borrowed books: the table contains only IDs and dates,
    so if you query it, you will not get very meaningful data, right? One approach
    would be to query the data in `borrowed_books`, and based on the returning IDs,
    query the `book` and `customer` tables by filtering by the IDs we are interested
    in. However, this approach consists of at least three queries to MySQL and a lot
    of work with arrays in PHP. It seems as though there should be a better option!'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, you can execute **join queries**. A join query is a query that joins
    two or more tables through a common field and, thus, allows you to retrieve data
    from these tables, reducing the amount of queries needed. Of course, the performance
    of a join query is not as good as the performance of a normal query, but if you
    have the correct keys and relationships defined, this option is way better than
    querying separately.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to join tables, you need to link them using a common field. Foreign
    keys are very useful in this matter as you know that both the fields are the same.
    Let''s take a look at how we would query for all the important info related to
    the borrowed books:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are several new concepts introduced in this last query. Especially with
    joining queries, as we joined the fields of different tables, it might occur that
    two tables have the same field name, and MySQL needs us to differentiate them.
    The way we will differentiate two fields of two different tables is by prepending
    the name of the table. Imagine that we want to differentiate the ID of a customer
    from the ID of the book; we should use them as `customer.id` and `book.id`. However,
    writing the name of the table each time would make our queries endless.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: MySQL has the ability to add an alias to a table by just writing next to the
    table's real name, as we did in `borrowed_books` (`bb`), `customer` (`c`) or `book`
    (`b`). Once you add an alias, you can use it to reference this table, allowing
    us to write things such as `bb.customer_id` instead of `borrowed_books.customer_id`.
    It is also good practice to write the table of the field even if the field is
    not duplicated anywhere else as joining tables makes it a bit confusing to know
    where each field comes from.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: When joining tables, you need to write them in the `FROM` clause using `LEFT
    JOIN`, followed by the name of the table, an optional alias, and the fields that
    connect both tables. There are different joining types, but let's focus on the
    most useful for our purposes. **Left joins** take each row from the first table—the
    one on the left-hand side of the definition—and search for the equivalent field
    in the right-hand side table. Once it finds it, it will concatenate both rows
    as if they were one. For example, when joining `borrowed_books` with `customer`
    for each `borrowed_books` row, MySQL will search for an ID in `customer` that
    matches the current `customer_id`, and then it will add all the information of
    this row in our current row in `borrowed_books` as if they were only one big table.
    As `customer_id` is a foreign key, we are certain that there will always be a
    customer to match.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'You can join several tables, and MySQL will just resolve them from left to
    right; that is, it will first join the two first tables as one, then try to join
    this resulting one with the third table, and so on. This is, in fact, what we
    did in our example: we first joined `borrowed_books` with `customer` and then
    joined these two with `book`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: As you can note, there are also aliases for fields. Sometimes, we do more than
    just getting a field; an example was when we got how many rows a query matched
    with `COUNT(*)`. However, the title of the column when retrieving this information
    was also `COUNT(*)`, which is not always useful. At other times, we used two tables
    with colliding field names, and it makes everything confusing. When this happens,
    just add an alias to the field in the same way we did with table names; `AS` is
    optional, but it helps to understand what you are doing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Let's move now to the usage of dates in this query. On one hand, we will use
    `DATE_FORMAT` for the first time. It accepts the date/time/datetime value and
    the string with the format. In this case, we used `%d-%m-%y`, which means day-month-year,
    but we could use `%h-%i-%s` to specify hours-minutes-seconds or any other combination.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Note also how we compared dates in the `WHERE` clause. Given two dates or time
    values of the same type, you can use the comparison operators as if they were
    numbers. In this case, we will do `bb.start >= "2015-01-01"`, which will give
    us the borrowed books from January 1, 2015, onward.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The final thing to note about this complex query is the use of the `CONCAT`
    function. Instead of returning two fields, one for the name and one for the surname,
    we want to get the full name. To do this, we will concatenate the fields using
    this function, sending as many strings as we want as arguments of the function
    and getting back the concatenated string. As you can see, you can send both fields
    and strings enclosed by single quotes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Well, if you fully understood this query, you should feel satisfied with yourself;
    this was the most complex query we will see in this chapter. We hope you can get
    a sense of how powerful a database system can be and that from now on, you will
    try to process the data as much as you can on the database side instead of the
    PHP side. If you set the correct indexes, it will perform better.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Grouping queries
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last feature that we will discuss about querying is the `GROUP BY` clause.
    This clause allows you to group rows of the same table with a common field. For
    example, let''s say we want to know how many books each author has in just one
    query. Try the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `GROUP BY` clause, always after the `WHERE` clause, gets a field—or many,
    separated by a coma—and treats all the rows with the same value for this field,
    as though they were just one. Thus, selecting by author will group all the rows
    that contain the same author. The feature might not seem very useful, but there
    are several functions in MySQL that take advantage of it. In this example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '`COUNT(*)` is used in queries with `GROUP BY` and shows how many rows this
    field groups. In this case, we will use it to know how many books each author
    has. In fact, it always works like this; however, for queries without `GROUP BY`,
    MySQL treats the whole set of rows as one group.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GROUP_CONCAT` is similar to `CONCAT`, which we discussed earlier. The only
    difference is that this time the function will concatenate the fields of all the
    rows of a group. If you do not specify `SEPARATOR`, MySQL will use a single coma.
    However, in our case, we needed a coma and a space to make it readable, so we
    added `SEPARATOR '', ''` at the end. Note that you can add as many things to concatenate
    as you need in `CONCAT`, the separator will just separate the concatenations by
    rows.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though it is not about grouping, note the `ORDER` clause that we added.
    We ordered by two fields instead of one. This means that MySQL will order all
    the rows by the `amount` field; note that this is an alias, but you can use it
    here as well. Then, MySQL will order each group of rows with the same `amount`
    value by the `title` field.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one last thing to remember as we already presented all the important
    clauses that a `SELECT` query can contain: MySQL expects the clauses of the query
    to be always in the same order. If you write the same query but change this order,
    you will get an error. The order is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT`'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FROM`'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`WHERE`'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GROUP BY`'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ORDER BY`'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating and deleting data
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already know quite a lot about inserting and retrieving data, but if applications
    could only do this, they would be quite static. Editing this data as we need is
    what makes an application dynamic and what gives to the user some value. In MySQL,
    and in most database systems, you have two commands to change data: `UPDATE` and
    `DELETE`. Let''s discuss them in detail.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Updating data
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When updating data in MySQL, the most important thing is to have a unique reference
    of the row that you want to update. For this, primary keys are very useful; however,
    if you have a table with no primary keys, which should not be the case most of
    the time, you can still update the rows based on other fields. Other than the
    reference, you will need the new value and, of course, the table name and field
    to update. Let''s take a look at a very simple example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this `UPDATE` query, we set the price of the book with the ID 2 to `12.75`.
    The `SET` clause does not need to specify only one change; you can specify several
    changes on the same row as soon as you separate them by commas—for example, `SET
    price = 12.75, stock = 14`. Also, note the `WHERE` clause, in which we specify
    which rows we want to change. MySQL gets all the rows of this table based on these
    conditions as though it were a `SELECT` query and apply the change to this set
    of rows.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'What MySQL will return is very important: the number of rows matched and the
    number of rows changed. The first one is the number of rows that match the conditions
    in the `WHERE` clause. The second one specifies the amount of rows that can be
    changed. There are different reasons not to change a row—for example when the
    row already has the same value. To see this, let''s run the same query again:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The same row now says that there was `1` row matched, as expected, but `0` rows
    were changed. The reason is that we already set the price of this book to `12.75`,
    so MySQL does not need to do anything about this now.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, the `WHERE` clause is the most important bit in this query.
    Way too many times, we find developers that run a priori innocent `UPDATE` queries
    end up changing the whole table because they miss the `WHERE` clause; thus, MySQL
    matches the whole table as valid rows to update. This is usually not the intention
    of the developer, and it is something not very pleasant, so try to make sure you
    always provide a valid set of conditions. It is good practice to first write down
    the `SELECT` query that returns the rows you need to edit, and once you are sure
    that the conditions match the desired set of rows, you can write the `UPDATE`
    query.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'However, sometimes, affecting multiple rows is the intended scenario. Imagine
    that we are going through tough times and need to increase the price of all our
    books. We decide that we want to increase the price by 16%, which is the same
    as the current price times 1.16\. We can run the following query to perform these
    changes:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This query does not contain any `WHERE` clause as we want to match all our books.
    Also note that the `SET` clause uses the `price` field to get the current value
    for the price, which is perfectly valid. Finally, note the number of rows matched
    and changed, which is `8`—the whole set of rows for this table.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish with this subsection, let''s consider how we can use `UPDATE` queries
    from PHP through PDO. One very common scenario is when we want to add copies of
    the already existing books to our inventory. Given a book ID and an optional amount
    of books—by default, this value will be 1—we will increase the stock value of
    this book by these many copies. Write this function in your `init.php` file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'There are two arguments: `$id` and `$amount`. The first one will always be
    mandatory, whereas the second one can be omitted, and the default value will be
    1\. The function first prepares a query similar to the first one of this section,
    in which we increased the amount of stock of a given book, then binds both parameters
    to the statement, and finally executes the query. If something happens and `execute`
    returns `false`, we will throw an exception with the content of the error message
    from MySQL.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: This function is very useful when we either buy more stock or a customer returns
    a book. We could even use it to remove books by providing a negative value to
    `$amount`, but this is very bad practice. The reason is that even if we forced
    the stock field to be unsigned, setting it to a negative value will not trigger
    any error, only a warning. MySQL will not set the row to a negative value, but
    the `execute` invocation will return `true`, and we will not know about it. It
    is better to just create a second method, `removeBook`, and verify first that
    the amount of books to remove is lower than or equal to the current stock.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Foreign key behaviors
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One tricky thing to manage when updating or deleting rows is when the row that
    we update is part of a foreign key somewhere else. For example, our `borrowed_books`
    table contains the IDs of customers and books, and as you already know, MySQL
    enforces that these IDs are always valid and exist on these respective tables.
    What would happen, then, if we changed the ID of the book itself on the `book`
    table? Or even worse, what would happen if we removed one of the books from `book`,
    and there is a row in `borrowed_books` that references this ID?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL allows you to set the desired reaction when one of these scenarios takes
    place. It has to be defined when adding the foreign key; so, in our case, we will
    need to first remove the existing ones and then add them again. To remove or drop
    a key, you need to know the name of this key, which we can find using the `SHOW
    CREATE TABLE` command, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The two foreign keys that we want to remove are `borrowed_books_ibfk_1` and
    `borrowed_books_ibfk_2`. Let''s remove them using the `ALTER TABLE` command, as
    we did before:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we need to add the foreign keys again. The format of the command will
    be the same as when we added them, but appending the new desired behavior. In
    our case, if we remove a customer or book from our tables, we want to remove the
    rows referencing these books and customers from `borrowed_books`; so, we need
    to use the `CASCADE` option. Let''s consider what they would look like:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note that we can define the `CASCADE` behavior for both actions: when updating
    and when deleting rows. There are other options instead of `CASCADE`—for example
    `SET NULL`, which sets the foreign keys columns to `NULL` and allows the original
    row to be deleted, or the default one, `RESTRICT`, which rejects the update/delete
    commands.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Deleting data
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deleting data is almost the same as updating it. You need to provide a `WHERE`
    clause that will match the rows that you want to delete. Also, as with when updating
    data, it is highly recommended to first build the `SELECT` query that will retrieve
    the rows that you want to delete before performing the `DELETE` command. Do not
    think that you are wasting time with this methodology; as the saying goes, measure
    twice, cut once. Not always is it possible to recover data after deleting rows!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to delete a book by observing how the `CASCADE` option we set earlier
    behaves. For this, let''s first query for the existing borrowed books list via
    the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There are two different books, `1` and `4`, with each of them borrowed twice.
    Let''s try to delete the book with the ID 4\. First, build a query such as `SELECT
    * FROM book WHERE id = 4` to make sure that the condition in the `WHERE` clause
    is the appropriate one. Once you are sure, perform the following query:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can note, we only specified the `DELETE FROM` command followed by the
    name of the table and the `WHERE` clause. MySQL tells us that there was `1` row
    affected, which makes sense, given the previous `SELECT` statement we made.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'If we go back to our `borrowed_books` table and query for the existing ones,
    we will note that all the rows referencing the book with the ID 4 are gone. This
    is because when deleting them from the `book` table, MySQL noticed the foreign
    key reference, checked what it needed to do while deleting—in this case, `CASCADE`—and
    deleted also the rows in `borrowed_books`. Take a look at the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Working with transactions
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we reiterated how important it is to make sure that
    an update or delete query contain the desirable matching set of rows. Even though
    this will always apply, there is a way to revert the changes that you just made,
    which is working with **transactions**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: A transaction is a state where MySQL keeps track of all the changes that you
    make in your data in order to be able to revert all of them if needed. You need
    to explicitly start a transaction, and before you close the connection to the
    server, you need to commit your changes. This means that MySQL does not really
    perform these changes until you tell it to do so. If during a transaction you
    want to revert the changes, you should roll back instead of making a commit.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'PDO allows you to do this with three functions:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '`beginTransaction`: This will start the transaction.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`commit`: This will commit your changes. Keep in mind that if you do not commit
    and the PHP script finishes or you close the connection explicitly, MySQL will
    reject all the changes you made during this transaction.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rollBack`: This will roll back all the changes that were made during this
    transaction.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One possible use of transactions in your application is when you need to perform
    multiple queries and all of them have to be successful and the whole set of queries
    should not be performed otherwise. This would be the case when adding a sale into
    the database. Remember that our sales are stored in two tables: one for the sale
    itself and one for the list of books related to this sale. When adding a new one,
    you need to make sure that all the books are added to this database; otherwise,
    the sale will be corrupted. What you should do is execute all the queries, checking
    for their returning values. If any of them returns `false`, the whole sale should
    be rolled back.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an `addSale` function in your `init.php` file in order to emulate
    this behavior. The content should be as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function is quite complex. It gets as arguments the ID of the customer
    and the list of books as we assume that the date of the sale is the current date.
    The first thing we will do is connect to the database, instantiating the `PDO`
    class. Right after this, we will begin our transaction, which will last only during
    the course of this function. Once we begin the transaction, we will open a `try…catch`
    block that will enclose the rest of the code of the function. The reason is that
    if we throw an exception, the `catch` block will capture it, rolling back the
    transaction and propagating the exception. The code inside the `try` block just
    adds first the sale and then iterates the list of books, inserting them into the
    database too. At all times, we will check the response of the `execute` function,
    and if it's `false`, we will throw an exception with the information of the error.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to use this function. Write the following code that tries to add
    a sale for three books; however, one of them does not exist, which is the one
    with the ID 200:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This code will echo the error message, complaining about the nonexistent book.
    If you check in MySQL, there will be no rows in the `sales` table as the function
    rolled back when the exception was thrown.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s try the following code instead. This one will add three valid
    books so that the queries are always successful and the `try` block can go until
    the end, where we will commit the changes:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Test it, and you will see how there is no message printed on your browser. Then,
    go to your database to make sure that there is a new `sales` row and there are
    three books linked to it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned the importance of databases and how to use them
    from our web application: from setting up the connection using PDO and creating
    and fetching data on demand to constructing more complex queries that fulfill
    our needs. With all of this, our application looks way more useful now than when
    it was completely static.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discover how to apply the most important design
    patterns for web applications through **Model View Controller** (**MVC**). You
    will gain a sense of clarity in your code when you organize your application in
    this way.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
