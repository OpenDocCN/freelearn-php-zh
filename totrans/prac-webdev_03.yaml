- en: Chapter 3. CSS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。CSS
- en: 'In the previous chapter, we learned how to create HTML documents using HTML
    elements and attributes. We can even include images and links to other documents
    and images. But when you look at the result on a screen, you are probably disappointed.
    I hope you are, because that was done on purpose (oops, I almost said by design,
    but the design part is what this chapter is all about). When I wrote my first
    web pages, I was disappointed too, in particular when discovering how hard it
    was to do something that should be simple: putting a photograph on a page and
    some text right next to it. Well now, it''s time to turn disappointment into excitement!'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用HTML元素和属性创建HTML文档。我们甚至可以包括图片和指向其他文档和图片的链接。但是当你看到屏幕上的结果时，你可能感到失望。我希望你是这样的，因为那是故意的（哎呀，我差点说成是有意为之，但设计部分正是本章的主题）。当我写我的第一个网页时，我也感到失望，特别是在发现做一件本应简单的事情有多难：在页面上放一张照片，旁边有一些文本。现在，是时候将失望转化为兴奋了！
- en: 'In this chapter, we will learn how to add the presentation part—in other words
    the layout—to our web pages, using **Cascading Style Sheets** (**CSS**). Style
    sheets are a common feature in Desktop Publishing software. They allow you to
    specify (or modify) the style of a section of a certain kind in your document:
    for example, every paragraph of text. When I developed my first book in Adobe
    InDesign, I knew exactly what I wanted every component to look like, so I modified
    the letter type and size of all of them by hand. I did not want to spend the time
    learning how to create style sheets. I have, however, since regretted that decision
    as at that point it had become a time-consuming affair.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用**层叠样式表**（**CSS**）添加演示部分——换句话说，就是布局——到我们的网页中。样式表是桌面出版软件中的常见功能。它们允许你指定（或修改）文档中某一类部分的样式：例如，每个文本段落。当我用Adobe
    InDesign开发我的第一本书时，我知道每个组件应该是什么样子，所以我手动修改了它们的字体和大小。我不想花时间去学习如何创建样式表。然而，我后来后悔了这个决定，因为那时它已经变成了一件耗时的事情。
- en: Today, I love style sheets and not only do I recommend using them but to let
    them be the first thing that you create when you start a new project. A style
    sheet is like a plan for a plan, where you can fill out the details later.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我喜欢样式表，并且不仅推荐使用它们，还建议在开始一个新项目时，让它们成为你首先创建的东西。样式表就像一个计划的计划，你可以在以后填写细节。
- en: By using style sheets you can separate the design part from the content part.
    You can even have this done at separate times or by separate people and it will
    give all of your pages a consistent look and feel. Simply switch two style sheets
    and your entire site will look completely different. Are we excited now?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用样式表，你可以将设计部分与内容部分分开。你甚至可以在不同的时间或由不同的人完成，这将使所有页面看起来都保持一致。只需切换两个样式表，你的整个网站看起来就会完全不同。我们现在兴奋了吗？
- en: 'Let us start with a sample piece of CSS code:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一段CSS代码的示例开始：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Comments in CSS can be found in-between the strings `/*` and `*/` similar to
    that used within the C programming language. So, to encourage good behavior, we
    included some comments in our first example. Let's analyze the rest of this code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: CSS中的注释可以在字符串`/*`和`*/`之间找到，类似于C编程语言中使用的。因此，为了鼓励良好的行为，我们在第一个例子中包含了一些注释。让我们分析一下这段代码的其余部分。
- en: The part before the curly brace is called the **selector**. It represents one
    or several elements in our page. In our example, that would include all `<p>`
    elements with class red.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号之前的部分被称为**选择器**。它代表我们页面中的一个或多个元素。在我们的例子中，这包括所有具有class red的`<p>`元素。
- en: In-between the curly braces, we find the CSS rules we want. In this example,
    we want all text inside paragraphs to be red, size 12 pixels, in italics, and
    in the **Baskerville** typeface. On systems where that font is not available,
    we want **Cambria** to be used instead.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在花括号之间，我们可以找到我们想要的CSS规则。在这个例子中，我们希望段落内的所有文本都是红色，大小为12像素，斜体，并且使用**Baskerville**字体。在那些没有该字体的系统上，我们希望使用**Cambria**字体代替。
- en: 'Note that every rule ends with a *semicolon* and consists of two parts separated
    by a colon: a **property** and a **value**. Color is a property and in our example
    the value chosen is `red`.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个规则都以一个**分号**结束，由一个冒号分隔成两部分：一个**属性**和一个**值**。颜色是一个属性，在我们的例子中，选择的值是`red`。
- en: In old versions of HTML, the same could have been achieved by placing `<font>`
    elements inside your `<p>` tags. Imagine having 40 `<p>` sections in your document
    and someone wants to change the `red` into `maroon`! You would have to change
    your HTML file in 40 different places, and no- a global find and replace would
    not even help you, as there might be other red "things". By using CSS, you only
    need to change one line.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 的旧版本中，可以通过在 `<p>` 标签内放置 `<font>` 元素来实现相同的效果。想象一下，您的文档中有 40 个 `<p>` 部分，有人想要将
    `red` 改为 `maroon`！您将不得不在 HTML 文件中的 40 个不同位置进行更改，而且全局查找和替换也无法帮助您，因为可能还有其他红色的“东西”。通过使用
    CSS，您只需更改一行。
- en: 'It is more common to find CSS code similar to this one:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的是找到类似以下的 CSS 代码：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will not only have the same effect for red `<p>` s , but it will also
    put all other paragraphs in the same typeface and size. This is the C in CSS:
    the properties of the overall `<p>` flows into the subset of red ones, like in
    a real cascade.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅会对红色 `<p>` 标签产生相同的效果，而且还会将所有其他段落设置为相同的字体和大小。这是 CSS 中的 C：整体 `<p>` 的属性会流入红色段落的子集中，就像在真实的水流中一样。
- en: Adding styles to our documents
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的文档添加样式
- en: 'So how do the CSS rules become part of our document? There are three ways:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 CSS 规则是如何成为我们文档的一部分的呢？有三种方式：
- en: External style sheets
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部样式表
- en: Internal CSS
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部 CSS
- en: Inline styles
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行内样式
- en: External style sheets
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部样式表
- en: 'This is the recommended way to add CSS to your site. It should be your goal
    for all style sheets of the production version of your site to be external. Simply
    add a line to the `<head>` section of your site, which should look like the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是向您的网站添加 CSS 的推荐方式。您的目标应该是所有网站生产版本的样式表都是外部的。只需在网站的 `<head>` 部分添加一行，如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`<link>` is an HTML element we had not yet introduced. Its attributes are listed
    below:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`<link>` 是一个我们尚未介绍的 HTML 元素。其属性如下所示：'
- en: '`rel`, to indicate the relationship between the HTML document and the linked
    file.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rel`，用于指示 HTML 文档与链接文件之间的关系。'
- en: '`type` specifies the MIME type of the document so the browser knows how to
    load it.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type` 指定了文档的 MIME 类型，以便浏览器知道如何加载它。'
- en: '`href` is used to specify the location of the file. You may expect a `src`
    attribute here, like is used for `<img>` tags, but the attribute to specify the
    file name in a `<link>` element is `href`. For the file name, we recommend that
    you always use relative pathnames. We suggest that you collect all your style
    sheets together in a folder with a meaningful name, like `css` or `styles`. Of
    course, the file itself should have a meaningful name too.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`href` 用于指定文件的地址。您可能会期望在这里使用 `src` 属性，就像 `<img>` 标签中使用的那样，但指定 `<link>` 元素中文件名的属性是
    `href`。对于文件名，我们建议您始终使用相对路径名。我们建议您将所有样式表收集到一个具有有意义名称的文件夹中，例如 `css` 或 `styles`。当然，文件本身也应该有一个有意义的名称。'
- en: When the file does indeed exist, it will be loaded. That is why it is important
    that your `<link>` element resides in the `<head>` section of the document so
    all the CSS rules are read before the body of your document.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件确实存在时，它将被加载。这就是为什么您的 `<link>` 元素必须位于文档的 `<head>` 部分中，以便在文档的主体之前读取所有 CSS 规则。
- en: Internal CSS
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部 CSS
- en: 'For small projects, or projects you would like to limit to a single HTML file
    so that it is easy to email to someone, you can use internal CSS. All the CSS
    rules can then be placed inside the `<head>` section of your document, inside
    a `<style>` tag. That tag needs to, at a minimum, include a `type` attribute,
    as in the following example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型项目，或者您希望限制为单个 HTML 文件以便于发送给他人，您可以使用内部 CSS。然后，所有的 CSS 规则都可以放置在文档的 `<head>`
    部分内，在一个 `<style>` 标签中。该标签至少需要包含一个 `type` 属性，如下例所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Inline styles
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行内样式
- en: 'Styles can be given to an individual HTML element by using the `style` attribute
    inside the HTML element itself, as in the following example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在 HTML 元素内部使用 `style` 属性来给单个 HTML 元素添加样式，如下例所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We do not recommend using this in your final product, but it is extremely useful
    to instantly see the effect of a change during development. If, for some reason,
    you leave one of the inline style attributes inside a page, it might take you
    forever to find out why your cool style sheet is not doing what it is supposed
    to be doing, on this one line of this one page.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不建议在最终产品中使用这种方法，但在开发过程中立即看到更改的效果是非常有用的。如果由于某种原因，您在页面中留下了一个行内样式属性，那么您可能永远也找不到为什么您的样式表没有按照预期在页面的一行上工作。
- en: On the other hand, I use it everyday, as I introduce and test new elements on
    a page while not disturbing anything else on the site, as modifying the external
    `.css` file would.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我每天都在使用它，因为我可以在不干扰网站其他内容的情况下，在页面上引入和测试新元素，就像修改外部的 `.css` 文件那样。
- en: The Document Object Model (DOM)
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档对象模型（DOM）
- en: As we learned in the previous chapter, an HTML document consists of a tree structure
    of nested tags, with HTML as the root. In programming, the contents of that tree
    can be stored in a large object and subtrees can be accessed, modified, or added
    by using smaller objects.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一章中学到的，一个HTML文档由一个嵌套标签的树结构组成，HTML作为根。在编程中，该树的内容可以存储在一个大对象中，子树可以通过使用较小的对象来访问、修改或添加。
- en: The whole lot is referred to as the **Document Object Model** (**DOM**). In
    subsequent chapters, we will learn a programming language (JavaScript) to do exactly
    that and a JavaScript library (jQuery) to make it easier. In this chapter, we
    will not be learning how to change our content, but we will learn how to change
    the style of our content. In all cases, we need a way to access our document.
    This is where **selectors** fit in.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些统称为**文档对象模型**（**DOM**）。在随后的章节中，我们将学习一种编程语言（JavaScript）来做到这一点，以及一个JavaScript库（jQuery）来简化这个过程。在本章中，我们将不会学习如何更改我们的内容，而是学习如何更改内容的样式。在所有情况下，我们需要一种方法来访问我们的文档。这就是**选择器**发挥作用的地方。
- en: Selectors
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择器
- en: 'The first part of a CSS rule, the part before the opening curly brace, is the
    selector, or several selectors separated by commas. A selector represents a *collection*
    of elements in the page to which the subsequent rules apply. The simplest selector
    is a single tag name, such as the one we already used in a previous example. Following
    is a code snippet as another example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: CSS规则的第一部分，即开大括号之前的部分，是选择器，或者由逗号分隔的多个选择器。选择器代表页面中一系列元素，后续规则将应用于这些元素。最简单的选择器是一个单一的标签名，就像我们在之前的例子中已经使用过的那样。以下是一个代码片段作为另一个例子：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The selector `p` means all paragraph elements in the entire page. Applying
    this rule will result in all paragraphs in the entire page being rendered in blue.
    Similarly, we could use a class name. Refer to the following example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器 `p` 表示整个页面中所有的段落元素。应用此规则将导致整个页面中的所有段落都以蓝色渲染。同样，我们也可以使用类名。参考以下示例：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The selector `.blue` represents all the elements in the page that have the
    class `blue`, whether they are paragraphs, headings, or so on. Now we can combine
    the two, as shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器 `.blue` 表示页面中所有具有 `class` `blue` 的元素，无论它们是段落、标题还是其他。现在我们可以将这两个结合起来，如下所示：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This selector represents the collection of all paragraph elements on the page
    with the class set to blue. For those of you that like set theory, this is the
    intersection of the `p` collection and the `.blue` collection.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此选择器表示页面中所有具有 `class` 设置为蓝色的段落元素的集合。对于那些喜欢集合理论的人来说，这是 `p` 集合和 `.blue` 集合的交集。
- en: 'Let''s go for some more set theory in the next simple example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一个简单的例子中继续探讨一些集合理论：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The set of elements that matches this selector is, at best, a singleton, as
    it matches the element with its **id** set to `errorbox`, if present. I cannot
    remind you often enough that no two elements can share the same id. Equally valid,
    but slightly more restrictive, is the following rule:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与此选择器匹配的元素集合，在最理想的情况下，是一个单例，因为它匹配具有 `id` 设置为 `errorbox` 的元素，如果存在的话。我无法经常提醒你，没有两个元素可以共享相同的
    `id`。同样有效，但稍微更严格的是以下规则：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The former rule was about any element with an id `errorbox`: the latter only
    applies to a `div` element with the id `errorbox`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前一条规则是关于任何具有 `id` `errorbox` 的元素：后一条规则仅适用于具有 `id` `errorbox` 的 `div` 元素。
- en: Multiple classes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个类
- en: 'We learned that several different classes can be assigned to an element by
    assigning a space separated string to its `class` attribute, for example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，可以通过将一个由空格分隔的字符串分配给其 `class` 属性来将多个不同的类分配给一个元素，例如：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you want to create a CSS rule for an element like this, the selector could
    look like the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为这样的元素创建一个CSS规则，选择器可能看起来像以下这样：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When used as a selector in a CSS rule, the rule would apply to all `h2` elements
    of class `green`, as well as `cool` and `awesome`. So the style would be changed
    to the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当用作CSS规则中的选择器时，该规则将应用于所有具有 `class` `green`、`cool` 和 `awesome` 的 `h2` 元素。因此，样式将更改为以下内容：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is completely different from a rule with the following selector:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下选择器的规则完全不同：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This would be part of a rule applying to elements that have the class `awesome`,
    are descendant of elements with the class `cool`, which are in turn descendants
    of tags with the class set to `green`, while being themselves a descendant of
    an `h2` element.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是应用于具有`awesome`类、是具有`cool`类的元素的后代、这些元素又是设置为`green`类的标签的后代、同时自身又是`h2`元素的后代的元素的规则的一部分。
- en: 'This is a very important distinction, so it is very important to remember:
    if you allow me to paraphrase a famous song: *What a difference a space makes*!'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常重要的区别，因此非常重要要记住：如果允许我改写一首著名的歌曲：*空格带来的差异有多大*！
- en: Descendants
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后代
- en: 'The sample selectors we used so far are all top level selectors: an element,
    a class, or an identifier. Now we are going to add more detail, and more complexity.
    Look at the following example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止使用的示例选择器都是顶级选择器：一个元素、一个类或一个标识符。现在我们将添加更多细节和复杂性。看看以下示例：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This rule applies only to the `h2` elements that are inside an element with
    the `id="container"`, no matter how many levels deep they are. So if this was
    a chunk of your HTML file, the rule would apply to the `h2` element that contains
    it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则仅适用于位于具有`id="container"`的元素内部的`h2`元素，无论它们有多少层级。所以如果这是你HTML文件的一部分，这条规则将适用于包含它的`h2`元素：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following CSS rule will make the heading `grey` as well, but if by any
    chance there are other `h2` elements inside the `#header` div, they would not
    be affected by this rule:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下CSS规则也会使标题变为灰色，但如果不幸有其他`h2`元素位于`#header` div内部，它们不会受到这条规则的影响：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Selecting children or siblings
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择子元素或兄弟元素
- en: 'In some cases, you want to be more specific in your selection and have a rule
    for elements that are the **children** of other elements, not descendants of arbitrary
    numbers of differing levels down in the document tree. For this purpose you can
    use the **child selector**, as in the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你想要在选择上更加具体，并为其他元素的**子元素**设置规则，而不是在文档树中任意数量的不同层级下的后代元素。为此，你可以使用**子选择器**，如下面的示例所示：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`h2` is a child of the div element with the id `main`, so with this rule also,
    the heading in our little chunk of code will be displayed in `grey`. Now consider
    the following example: On the other hand:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`h2`是具有id `main`的div元素的子元素，因此，根据这条规则，我们小块代码中的标题将以灰色显示。现在考虑以下示例：另一方面：'
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, there will be no effect as `h2` is not a child of `div#container`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将没有效果，因为`h2`不是`div#container`的子元素。
- en: 'There is a similar syntax for specifying an element that is adjacent to another
    one, or a **sibling** as this would be called in a family tree. Refer to the next
    example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 存在类似的语法来指定一个与另一个元素相邻的元素，或者称为家族树中的**兄弟元素**。参考下一个示例：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This would not give a top margin to a `p` element that immediately follows
    a `h2`, but would not apply this rule to subsequent `p` tags. Look at the following
    small piece of HTML:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会给紧随`h2`之后的`p`元素添加顶部边距，但不会将此规则应用于后续的`p`标签。看看以下小块HTML：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The first paragraph would not have a top margin; all others would have margins
    based on how the browser renders the paragraphs by default. Of course, this is
    true if this CSS rule is the only one and not overruled by others, and this brings
    us to the next topic: **specificity**.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第一段不会有顶部边距；所有其他段落会有基于浏览器默认渲染段落的边距。当然，如果这条CSS规则是唯一的，并且没有被其他规则覆盖，那么这是真的，这带我们到下一个主题：**特定性**。
- en: Specificity
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特定性
- en: From time to time, as a CSS beginner or an experienced web developer, you will
    be frustrated if you just added a new CSS rule to your style sheet and discovered
    that it has no effect. More often than not, this happens because there is another
    rule with a higher specificity that has priority.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，作为一个CSS初学者或经验丰富的网络开发者，如果你只是在你样式表中添加了一条新的CSS规则，却发现它没有任何效果，你会感到沮丧。这种情况通常发生是因为有另一个具有更高特定性的规则具有优先权。
- en: 'We already mentioned that inline styles take precedence over external style
    sheets. So it seems more than logical that the order of internal CSS and links
    to external style sheets will influence how the page will end up looking. Now
    consider the following rule:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到内联样式比外部样式表具有优先权。因此，内部CSS和外部样式表的链接顺序似乎会影响页面的最终外观。现在考虑以下规则：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Suppose the previous stated rule is followed by this next rule:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设前面的规则后面跟着这条规则：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In such a scenario, all paragraph elements with the class `warning` will appear
    in `orange`, not `red`, because the orange rule appeared later.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，所有具有`warning`类的段落元素将以橙色显示，而不是红色，因为橙色规则出现得较晚。
- en: 'But these two rules happen to share a common selector: it is a `p` with the
    class `warning`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但这两个规则恰好共享一个共同的选择器：它是一个具有`warning`类的`p`标签。
- en: 'Things would be different if you had rules with selectors such as the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有的规则选择器如下：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And along with that, if you also had the next rule:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你还有下一个规则：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let us now consider the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在考虑以下内容：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Logic or intuition, but not the order in the CSS, would make us think that the
    text `What you typed is incorrect` would be displayed in red and not in orange.
    This is, in fact, correct, but we do not want to rely on intuition, do we? Fortunately,
    there are formulas to determine which CSS rule wins if there are several that
    could influence the layout of a particular element. It is slightly mathematical
    and referred to as **specificity**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑或直觉，但不是CSS中的顺序，会让我们认为文本`你输入的内容不正确`将以红色显示，而不是橙色。实际上，这是正确的，但我们不希望依赖直觉，对吧？幸运的是，有公式可以确定如果有多个规则可能影响特定元素的布局，哪个CSS规则会获胜。这稍微有些数学性，被称为**特定性**。
- en: 'The specificity of a CSS rule is a sequence of four numbers that are calculated
    as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: CSS规则的特定性是一系列四个数字，其计算方法如下：
- en: If the rule is an inline style, the first number is 1, otherwise it is 0
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果规则是内联样式，第一个数字是1，否则是0
- en: Add 1 to the second number for every occurrence of an **identifier**
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个出现的**标识符**，将第二个数字加1
- en: Add 1 to the third number for every **class** specified
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个指定的**类**，将第三个数字加1
- en: Increase the fourth number by one for every **element** present
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个存在的**元素**，将第四个数字加1
- en: 'When two rules are compared, the first number is looked at first. If one of
    them is higher, then that rule has more **weight**. Next, the second number is
    looked at, and if needed, the third, and finally the last. The specificity of
    our two sample rules is: 0,1,0,1 and 0,0,3,4.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较两个规则时，首先查看第一个数字。如果其中一个更高，那么该规则就有更多的**权重**。接下来查看第二个数字，如果需要，再查看第三个，最后查看最后一个。我们两个示例规则的特定性是：0,1,0,1和0,0,3,4。
- en: So our intuition is now confirmed by mere arithmetic.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的直觉现在得到了简单的算术的证实。
- en: Block elements and inline elements
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块级元素和内联元素
- en: 'Before we finally get into a description of the most important CSS properties
    by category, we need to say a few words on two categories of elements: **block**
    elements and **inline** elements.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最终按类别描述最重要的CSS属性之前，我们需要就两种元素类别说几句话：**块级**元素和**内联**元素。
- en: Think of block elements as rectangular areas of your screen or page. They can
    contain text, data, and other block elements, as well as inline elements. Typical
    block elements are the `<div>` and `<p>` tags. Before and after every block element,
    a new line of text is created.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将块级元素想象成你的屏幕或页面上的矩形区域。它们可以包含文本、数据和其它块级元素，以及内联元素。典型的块级元素是`<div>`和`<p>`标签。在每个块级元素之前和之后，都会创建一个新的文本行。
- en: Inline elements can only contain inline elements and not block elements. Also,
    they cannot be given a width. They inherit the width from the container that they
    are inside of. The most popular inline element is the `<span>` element, typically
    used to change the look of a chunk of text inside more text.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 内联元素只能包含内联元素，不能包含块级元素。此外，它们不能被赋予宽度。它们从它们所在的容器继承宽度。最流行的内联元素是`<span>`元素，通常用于改变更多文本中某段文本的外观。
- en: 'For starters this can be confusing, because block elements like `<div>` may
    be block elements, but when they have no content inside of them, they appear not
    to have any width or height. Moreover, you can change the way these elements are
    displayed with the CSS `display` property. Consider the following lines of code
    and have a browser render it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这可能会让人困惑，因为像`<div>`这样的块级元素可能是块级元素，但如果没有内容，它们看起来似乎没有宽度或高度。此外，你可以使用CSS的`display`属性更改这些元素的显示方式。考虑以下代码行，并让浏览器渲染它：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The first four lines are displayed as block elements and are true paragraphs:
    there will be a new line in-between them, and the distance between these paragraphs
    will be determined by the default `font` and `margin` values the browser has chosen.
    Font and margin belong to the most important CSS property families. We will learn
    about them when we discuss the font properties and the so called `box` model for
    `margin`, `border,` and `padding`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前四行被显示为块级元素，并且是真正的段落：它们之间会有一个新行，这些段落之间的距离将由浏览器选择的默认`font`和`margin`值决定。字体和边距属于最重要的CSS属性家族。当我们讨论字体属性以及所谓的`margin`、`border`和`padding`的`box`模型时，我们将了解它们。
- en: The second set of paragraphs will all appear on one line, if permitted by room
    in the viewport, because we explicitly declared them to be inline elements.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果视口有足够的空间，第二组段落将全部显示在同一行，因为我们明确声明它们是内联元素。
- en: Before we discuss the box model, let us look at one more example. Experiment
    with the first half set of divs as it will, as is, display nothing. Once you insert
    text in between the `<div>` tags, that text will appear along with the background
    colors. The `<div>` elements in the second set actually have a width and height,
    so you will see four perfect colorful squares, but maybe not the way you expected
    them. We grouped them two by two, yet they all appear stacked on top of each other.
    Welcome to the world of browser indifference!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论`box`模型之前，让我们再看一个例子。尝试使用第一组div的前半部分，因为它们本身不会显示任何内容。一旦你在`<div>`标签之间插入文本，这些文本就会与背景颜色一起显示。第二组中的`<div>`元素实际上有宽度和高度，所以你会看到四个完美的彩色方块，但可能不是你预期的样子。我们将它们两两分组，但它们都堆叠在一起。欢迎来到浏览器无所谓的世界！
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Colors
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 颜色
- en: What can make a site look instantly more pleasant is the proper use of colors.
    It is also a useful tool for doing some debugging. By adding different background
    colors to some block elements, you are increasing your chances of finding the
    location of that one missing, closing tag that messes things up. I just used it
    today.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使网站看起来瞬间更加愉悦的是正确使用颜色。这同样也是进行一些调试的有用工具。通过给某些块级元素添加不同的背景颜色，你增加了找到那个缺失的、导致混乱的闭合标签的位置的机会。我今天刚刚就用到了它。
- en: There is a world of difference between publishing printed books, documents,
    and even packaging components or media faceart through a professional manufacturing
    company, and web publishing. In the world of printing, you have full control over
    the colors you use and, also extremely critical, the fonts or typefaces. You should
    be very exigent and expect the resulting product to match exactly in color and
    typeface to what you specified. Color information is exchanged in either RGB (**red-green-blue**)
    or CMYK (**cyan-magenta-yellow-black**) values. In CSS also, you can specify the
    desired color through its RGB values. But this is where the comparison begins
    and ends.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过专业制造公司发布印刷书籍、文档，甚至包装组件或媒体封面，与网络发布之间有着天壤之别。在印刷的世界里，你可以完全控制你使用的颜色，以及同样至关重要的字体或字型。你应该非常挑剔，并期望最终产品在颜色和字型上与你的指定完全一致。颜色信息以RGB（**红色-绿色-蓝色**）或CMYK（**青色-品红色-黄色-黑色**）的值进行交换。在CSS中，你也可以通过其RGB值指定所需的颜色。但比较就从这里开始了，并且结束了。
- en: 'Because of this, we know that colors of a quality printed item should look
    exactly the way we expect them to. However, when we prepare web content, we cannot
    tell how the colors on our site will look to our visitors. It depends on too many
    things. For example, what device do they use: a computer, a tablet, or a mobile
    phone? The screen they look at can be large or small, be of high or low resolution,
    and support millions of colors or just a small number. Once we realize that, we
    are fine. I therefore recommend using colors that are sufficiently distinct, and
    to not bother using extravagant RGB combinations.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，我们知道高质量印刷品的颜色应该与我们预期的完全一致。然而，当我们准备网络内容时，我们无法知道我们的网站上的颜色将如何呈现给我们的访客。这取决于太多因素。例如，他们使用什么设备：电脑、平板电脑还是手机？他们查看的屏幕可以是大或小，高分辨率或低分辨率，支持数百万种颜色或只有少数几种。一旦我们意识到这一点，我们就可以放心了。因此，我建议使用足够鲜明的颜色，并且不要麻烦使用奢侈的RGB组合。
- en: Colors can be specified in several ways. The two most common ones are by **name**
    and by **RGB** value. Names are easier, but may be more subject to browser interpretation.
    So I only use them for quick and temporary things, or when they are *black* or
    *white*. In all other cases, I prefer to use the RGB values, which are written
    as the `#` sign followed by three two digit hex numbers, for example, `#FFDEAD`,
    one of my favorite colors. It is called **Navajo**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色可以通过几种方式指定。最常见的是通过**名称**和通过**RGB**值。名称更容易，但可能更容易受到浏览器的解释。所以我只在使用快速和临时的事情，或者它们是**黑色**或**白色**时使用它们。在其他所有情况下，我更喜欢使用RGB值，它们以`#`符号后跟三个两位十六进制数字的形式书写，例如，`#FFDEAD`，这是我最喜欢的颜色之一。它被称为**纳瓦霍**。
- en: You can use colors for the foreground and the background, with the **color**
    and **background-color** properties. Color indicates the color that will be used
    to display the text inside an element or the descendants of an element; background-color,
    as the property name suggests, will set the background color of a block element.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**颜色**和**背景颜色**属性来设置前景和背景颜色。颜色表示将用于显示元素内部或元素的子代文本的颜色；背景颜色，正如属性名所暗示的，将设置块元素的背景颜色。
- en: Fonts
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字体
- en: I am a typography enthusiast. I even spent money buying fonts, just for personal
    use. So I would like to point out that, even more so than with colors, there is
    a huge difference between using typography for print publishing and web publishing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我是一个字体爱好者。我甚至花钱购买字体，只是为了个人使用。所以我想指出，与颜色相比，打印出版和网页出版中使用字体的差异更大。
- en: In print publishing, you are in full control of `fonts` or `typefaces` (this
    is not a typography book, so allow me to use these terms interchangeably) that
    you use in your work. You just have to make sure that all the fonts that you plan
    to use are installed on the system that holds your `Desktop Publishing` program,
    so you can use them for your development. Next, make sure that they are **embedded**
    in the final document you send to your printer, and that both you and your printing
    company have a legitimate license for all the fonts used. Then all the people
    who will read the printed copy or even a PDF version online, will see it just
    the way you designed it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在印刷出版中，你可以完全控制你在工作中使用的`字体`或`字型`（这不是一本关于字体的书，所以请允许我交替使用这些术语）。你只需确保你计划使用的所有字体都已安装在你持有`桌面出版`程序的系统上，这样你就可以用于开发。接下来，确保它们被嵌入到你发送给打印机的最终文档中，并且你和你的印刷公司都有所有使用的字体的合法许可证。然后，所有将阅读印刷副本或甚至在线PDF版本的人都会看到它就像你设计的那样。
- en: When publishing on the web, the text that the visitor will see on your page
    can only be displayed in a font that is actually installed on the device he or
    she is using. The worst case, yet the best looking, scenario is the one where
    you use a very nice, expensive font that is installed on the system used to design
    and test your site. It is possible that is it installed on no other computer on
    the planet.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在网上发布时，访问者将在你的页面上看到的文本只能使用他们使用的设备上实际安装的字体显示。最糟糕的情况，但看起来最好的情况是，你使用了一个非常漂亮、昂贵的字体，这个字体安装在了设计和测试你网站的系统中。它可能安装在其他任何电脑上都没有。
- en: That website will look absolutely fabulous on your own computer but potentially
    dreadful where it matters most. That is why in CSS we work with **font families**,
    and not single fonts.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 那个网站在你的电脑上看起来绝对棒，但在最关键的地方可能看起来很糟糕。这就是为什么在CSS中，我们与**字体族**而不是单个字体一起工作。
- en: Before getting into more detail, one thing to note about the web **middle ages**,
    is that there used to be a tag `<font>`—simply think—ah! middle ages and do not
    use it. It is one of those presentational HTML elements we talked about.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，关于网络**中世纪**的一个需要注意的事情是，曾经有一个标签 `<font>`——简单想一下——啊！中世纪，不要使用它。它是我们之前提到的那些表现性HTML元素之一。
- en: So what are fonts?
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么，什么是字体？
- en: In simple terms, fonts are a series of pictures, or **glyphs**, determining
    how letters, numbers, and other characters should be displayed. In the early days
    of printing, some 500 years ago, Gutenberg, Plantijn, or Moretus created metal
    casts, one letter at a time. These metal letters would be placed in wooden cases,
    the larger ones in the upper and the smaller in the lower case. This is how the
    terms uppercase and lowercase were born.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，字体是一系列图片，或者说**符号**，决定了字母、数字和其他字符应该如何显示。在印刷的早期，大约500年前，古腾堡、普拉廷或莫雷图斯一次制作一个金属铸模。这些金属字母会被放在木箱里，大的放在上面，小的放在下面。这就是大写和小写这两个术语的由来。
- en: 'To compose a single page of text, metal letters had to be put in a frame to
    hold them together and then inserted in the world''s first printing press. Add
    some ink and paper and there you had it: you had one page of one copy of a book.
    Of course, for every different size, thickness, and style (for example *italic*
    versus *normal*), there had to be a separate case with letters.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要组成一页文本，必须将金属字母放入一个框架中，以将它们固定在一起，然后插入世界上第一台印刷机。再加上一些墨水和纸张，你就有了：一本书的一页的一个副本。当然，对于每一种不同的尺寸、厚度和样式（例如*斜体*与*正常体*），都必须有一个单独的字母框。
- en: The people who created those metal letters were called punch-cutters and the
    fonts were named after them. A famous one was Claude Garamond. You can spot the
    original Garamond metal fonts, wrapped in paper to protect for posterity, at the
    Plantijn-Moretus Museum in Antwerp (it is my favorite museum in Belgium). You
    will discover there that the 16th century equivalent of a combined architect,
    portraitist, and "web designer" was Peter Paul Rubens, known to most other people
    only as a painter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 那些制作金属字母的人被称为冲床工人，字体以他们的名字命名。一个著名的例子是Claude Garamond。你可以在安特卫普的Plantijn-Moretus博物馆看到原始的Garamond金属字体，它们被纸包裹起来以保护后世。那里你会发现，16世纪的结合建筑师、肖像画家和“网页设计师”是彼得·保罗·鲁本斯，大多数人只知道他是一位画家。
- en: Today, the fonts we talk about are no longer small blocks of metal, but computer
    files with information on the font layout. The more glyph collections a font contains
    (more sizes, styles, or weight or thickness), the more accurately a letter will
    be reproduced.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们谈论的字体不再是小块金属，而是包含字体布局信息的计算机文件。一个字体包含的符号集合越多（更多的大小、样式或粗细），字母的再现就越准确。
- en: Font families
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字体家族
- en: Fonts can be divided into different categories or families. The three most important
    ones are called **serif**, **sans-serif** and **monospace** fonts.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 字体可以被分为不同的类别或家族。其中最重要的三个被称为**衬线**、**无衬线**和**等宽**字体。
- en: Serif fonts
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 衬线字体
- en: Serif fonts are typefaces that have glyphs with small decorations or serifs
    at some of the edges of the letter. For example, the short lines at the bottom
    of each leg in the letter *m*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 衬线字体是具有在字母边缘某些部分带有小装饰或衬线的字型。例如，字母*m*底部每条腿的短线条。
- en: The font designed by Garamond, mentioned in the previous section, is an example
    of a serif font. Serif fonts are popular because they make reading text pleasant.
    Publishers use well crafted serif fonts, combined with high quality printing paper,
    in the hardcover versions of their books. **Times New Roman**, designed for a
    British newspaper The Times, is a very commonly used serif font. The very text
    you are now reading is in Times New Roman. The creators used a font called Plantin
    as a model, which in turn was named after **Plantijn,** the printer person I mentioned
    earlier.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中提到的由Garamond设计的字体是一个衬线字体的例子。衬线字体因其使阅读文本愉悦而受到欢迎。出版商在他们的书籍的精装版本中使用精心制作的衬线字体，并结合高质量的印刷纸张。**Times
    New Roman**，专为英国报纸《泰晤士报》设计，是一种非常常用的衬线字体。你现在正在阅读的文本就是使用Times New Roman字体。创作者以一个名为Plantin的字体为模型，而这个模型的名字来源于我之前提到的印刷师**Plantijn**。
- en: Baskerville is another example of a serif font and is used a lot for eBooks.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Baskerville是衬线字体的另一个例子，常用于电子书。
- en: Using serif fonts for the text portion of a website is subject to discussion.
    As glyphs have to be displayed using pixels on a screen, the decorations that
    cause a pleasant read in print may result in just the opposite on a screen,. This
    is because on lower resolution screens, those same decorations may look too pixilated.
    I personally recommend at least experimenting with some serif fonts for the main
    text part of your site before making that call.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在网站的文字部分使用衬线字体是值得讨论的。因为符号必须使用屏幕上的像素来显示，那些在印刷中引起愉悦阅读的装饰在屏幕上可能会产生相反的效果。这是因为，在低分辨率屏幕上，那些相同的装饰可能会看起来过于像素化。我个人建议在做出决定之前，至少尝试在你的网站的主要文本部分实验一些衬线字体。
- en: Sans-serif fonts
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无衬线字体
- en: 'Sans-serif fonts are the counterpart of serif fonts. They do not contain the
    small decorations or serifs at the end of the stroke, hence the name sans (French
    for without) serif. In print, sans-serif fonts are used for headings, titles,
    and so on. This is in contrast to the serif fonts used for the body of the text.
    Sans-serif fonts, for the reason mentioned previously, are now more common for
    text that needs to be displayed on computer screens. Common sans-serif typefaces
    are: **Arial**, **Open Sans,** and **Helvetica**. Headings in this book are in
    Arial.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 无衬线字体是衬线字体的对立面。它们不包含笔画末尾的小装饰或衬线，因此得名无衬线（法语中意为没有衬线）。在印刷中，无衬线字体用于标题、标题等。这与用于正文文本的衬线字体形成对比。由于之前提到的原因，无衬线字体现在更常用于需要在计算机屏幕上显示的文本。常见的无衬线字体包括：**Arial**、**Open
    Sans**和**Helvetica**。本书的标题使用Arial字体。
- en: Monospace fonts
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等宽字体
- en: 'In the typefaces we have discussed so far, not all characters have the same
    width: the letter `m` is clearly wider than the letter `i`. A monospaced font,
    also called a fixed-width, is a font where letters and characters do indeed have
    the same width. The first monospaced typefaces were for typewriters, as the carriage
    always moves the same distance forward with each letter typed. They were also
    used in early computers and computer terminals. Software text editors still use
    them today, as it makes it easier to align source code when every character has
    the same width.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前讨论过的字体中，并非所有字符的宽度都相同：字母`m`显然比字母`i`宽。等宽字体，也称为固定宽度字体，是一种字母和字符确实具有相同宽度的字体。最早的等宽字体是为打字机设计的，因为打字机的字车在每次输入字母时都会向前移动相同的距离。它们也被用于早期的计算机和计算机终端。软件文本编辑器至今仍在使用它们，因为当每个字符都有相同宽度时，这使对齐源代码变得更容易。
- en: The source code displayed on web sites is usually displayed in a monospace font,
    as are the code examples in this book. The most common monospace font is probably
    **Courier**. Another example is **Lucida Console**.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 网站上显示的源代码通常以等宽字体显示，本书中的代码示例也是如此。最常用的等宽字体可能是**Courier**。另一个例子是**Lucida Console**。
- en: Let us now get back from our trip into the science and the history of typography,
    to our CSS story.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在从对排版科学和历史的研究中回到我们的CSS故事。
- en: The font-family property
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字体家族属性
- en: 'To specify how the text of an element needs to be displayed, we use the **font-family**
    property in the CSS style sheet. For example, consider the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定元素文本的显示方式，我们在CSS样式表中使用**font-family**属性。例如，考虑以下内容：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So why is there more than one font specified: a letter can only be in one font,
    can''t it?'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么会有多个字体指定：一个字母只能在一个字体中，不是吗？
- en: This is how it works. When someone visits your site, with this sentence in your
    style sheet, a paragraph of text will be displayed in the `Open Sans` typeface,
    if it is installed on the visitor's computer. If it is not found, `Helvetica Neue`
    will be looked for; if that one is not there then `Verdana` is attempted, and
    so on. If everything fails, some default sans-serif typeface will be used. For
    this example, the last scenario is very unlikely, as I cannot imagine a system
    that would not have Verdana or Helvetica installed. Yet, it is recommended to
    always conclude the list with sans-serif, serif, or monospace. Note the use of
    quotes (For example, for 'Helevtica Neue') when font names consist of more than
    one word.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的运作方式。当有人访问您的网站时，如果您的样式表中包含这句话，那么一个段落文本将使用`Open Sans`字体显示，如果它在访问者的计算机上安装了。如果找不到，将寻找`Helvetica
    Neue`；如果那个也没有，则尝试`Verdana`，依此类推。如果所有尝试都失败，将使用一些默认的无衬线字体。对于这个例子，最后一种情况非常不可能，因为我无法想象一个没有安装Verdana或Helvetica的系统。然而，建议始终以无衬线、衬线或等宽字体结束列表。注意，当字体名称由多个单词组成时，使用引号（例如，对于'Helvetica
    Neue'）。
- en: Font-weight and font-style
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字体粗细和字体样式
- en: 'When you select a font using one of the desktop applications you use, you can
    also select style from `picklist`. A typical `picklist` could include: normal,
    italic, semi-bold, semi-bold italic, bold, and bold italic. The number of items
    on that list typically matches the number of glyph collections that came with
    the font. You can visit a website of a company that sells fonts, to get a better
    feel for how many variations there can be on the theme of a single font.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用桌面应用程序中选择字体时，您还可以从`选择列表`中选择样式。一个典型的`选择列表`可能包括：正常、斜体、半粗体、半粗体斜体、粗体和粗体斜体。列表上的项目数量通常与字体附带的字形集合数量相匹配。您可以访问销售字体的公司网站，以更好地了解单个字体主题上可能有多少种变化。
- en: 'In CSS, the equivalent of this is provided through two different properties:
    **font-weight** and **font-style**.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS中，这通过两个不同的属性提供：**font-weight**和**font-style**。
- en: The two most common values for font-style are **normal** and **italic**. The
    ones for font-weight are **normal** and **bold**, and the numbers `100`, `200`,
    and so on, through `900`. `400` is the same as normal and `700` the same as bold.
    All others can have unpredictable results depending on the presence of, let's
    say, a semi-bold version of your font and the browser used. So until we reach
    the second part of the book, the message should be loud and clear—only use the
    basic normal or italic, and normal or bold.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 字体样式的两个最常见值是**正常**和**斜体**。字体粗细的值是**正常**和**粗体**，以及数字`100`、`200`等等，直到`900`。`400`与正常相同，`700`与粗体相同。所有其他值可能取决于字体中是否存在，比如说，半粗体版本以及所使用的浏览器。所以，直到我们达到书的第二部分，信息应该是响亮且清晰的——只使用基本的正常或斜体，以及正常或粗体。
- en: Font-size
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字体大小
- en: Finally, as in our desktop applications, we can specify now which font our text
    needs to be displayed in, and what size all these letters should have.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就像在我们的桌面应用程序中一样，我们现在可以指定文本需要显示的字体，以及所有这些字母应该有什么大小。
- en: Size can be specified in `pixels`, `percentages,` or `ems`. Another one that
    exists is called `rem`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 大小可以用`像素`、`百分比`或`ems`来指定。另一个存在的是称为`rem`的单位。
- en: 'When no font-size is specified anywhere, a typical browser will set that size
    to `16px`. The `em` unit, a term that comes from typography to refer to the size
    of the letter `m` in a font, is, in CSS, nothing other than the calculated size
    of the font for the current element. Its use is highly recommended over fixed
    pixel sizes. Let''s illustrate this with an example. Look at the following CSS
    code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何地方都没有指定字体大小时，典型的浏览器会将该大小设置为`16px`。`em`单位，一个来自排版的术语，指的是字体中字母`m`的大小，在CSS中，它只是当前元素的字体计算大小。强烈建议使用它而不是固定像素大小。让我们用一个例子来说明这一点。看看下面的CSS代码：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If no font-size was specified for the body element, we know that this would
    be `16px`, with all descendants inheriting it. This means that our `h1` heading
    would become `32px` and the `h2` would be `24px`. Simply changing the font-size
    for the body element to, let us say, `20px` would proportionally change the sizes
    of our `h2` and `h1` headings to `30px` and `40px` respectively. If we had given
    them a size of, for example, `20px` and `24px` we would have ended up with headings
    the same size as the font used for regular text.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有为body元素指定字体大小，我们知道这将是`16px`，所有后代都将继承它。这意味着我们的`h1`标题将变为`32px`，而`h2`将是`24px`。只需将body元素的字体大小更改为，比如说，`20px`，就会按比例将我们的`h2`和`h1`标题的大小分别更改为`30px`和`40px`。如果我们给它们指定的大小是，例如，`20px`和`24px`，我们最终会得到与常规文本使用的字体大小相同的标题。
- en: The same is true when the user uses the browser to zoom in or zoom out. We retain
    the proportions. In the interests of creating responsive designs, using proportional
    sizes rather than fixed ones is the way to go. Of course you have to be careful
    and realize that when you change the font-size of an element, all children will
    inherit it, and when you change that, by mistake or not, of a child element, the
    size of `em` will no longer be what it was a minute ago.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户使用浏览器放大或缩小视图时，我们保持比例。为了创建响应式设计，使用比例大小而不是固定大小是最佳选择。当然，你必须小心，并意识到当你更改元素的字体大小时，所有子元素都将继承它，并且当你错误地或不是错误地更改子元素的大小时，`em`的大小将不再是刚才的大小。
- en: 'Consider the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Following are the CSS rules to go with it:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相应的CSS规则：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You have just made the font-size twice as small, so that the letters in this
    paragraph of text will be `0.64`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚将字体大小缩小了一半，所以这段文字中的字母大小将是`0.64`。
- en: 'In general, I like using percentages, as shown next:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我喜欢使用百分比，如下所示：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Line-height
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行高
- en: 'There is one more important property for dealing with text: the **line-height**.
    In practice, this determines how much vertical space there will be between two
    lines of text. Line-height can be specified as a number, which is multiplied with
    the font size, a `pixel` value, a `percentage,` or the word `normal`. Normal is
    typically determined by the browser and is usually somewhere between `1.2` and
    `1.4`. So the height of every line is `1.2` or `1.4` times the font size. That
    way there is some room for white space above and below the letters.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理文本还有一个重要的属性：**行高**。在实践中，这决定了两行文本之间的垂直空间。行高可以指定为一个数字，该数字乘以字体大小，一个`像素`值，一个`百分比`，或者单词`normal`。通常，`normal`由浏览器决定，通常在`1.2`和`1.4`之间。所以每一行的长度是字体大小的`1.2`或`1.4`倍。这样在字母的上下方就有一些空白空间。
- en: 'For a font with size `16px`, the following three lines of CSS would have the
    same effect:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大小为`16px`的字体，以下三行CSS会有相同的效果：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that this specifies the space between lines of a paragraph, not the space
    between paragraphs. That would be determined by the margin, and the margin is
    one aspect of the single most important concept of CSS: the **box model**.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这指定的是段落行之间的空间，而不是段落之间的空间。那将由边距决定，而边距是CSS最重要的概念之一：**盒模型**的一个方面。
- en: The box model
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 盒模型
- en: 'All HTML elements can be treated as boxes. In CSS, the term box model is used
    while talking about design and layout. It is essentially a box that wraps around
    HTML elements and that can consist of, from outside to inside: margins, borders,
    padding, and the actual content.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所有HTML元素都可以被视为盒子。在CSS中，当我们谈论设计和布局时使用术语盒模型。它本质上是一个围绕HTML元素的盒子，它可以由外向内包括：边距、边框、填充和实际内容。
- en: 'So far in this book, we have given only short examples so that you could study
    away from a computer, and we will treat this as a textbook for as long as we can.
    However, to illustrate the box model, and for you to understand it, it is essential
    to take our examples and check them in a browser. Consider the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们只给出了简短的例子，这样你就可以在没有电脑的情况下学习，我们将尽可能将其作为教科书。然而，为了说明盒模型，以及让你理解它，检查我们的例子并在浏览器中查看是至关重要的。考虑以下代码：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And next is the content of the style sheet file, where we use some of what
    we just learned, combined with introducing all the box model properties:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是样式表文件的內容，其中我们使用了一些刚刚学到的知识，并结合引入所有的盒模型属性：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When we display this is in a browser, we will see two square boxes nicely stacked
    on top of each other. Both boxes have text in them; one is colored green with
    an orange border, the other one blue and yellow. There is an equal distance between
    the left of the viewport and the boxes, the top of the window and the top box,
    and in-between the boxes. Feel free to change the values in the CSS and the HTML
    of box `#box` and see what happens.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中显示这个时，我们将看到两个整齐堆叠在一起的方形盒子。两个盒子中都有文本；一个是绿色的，带有橙色的边框，另一个是蓝色和黄色的。视口的左侧和盒子之间、窗口的顶部和顶部盒子之间以及盒子之间的距离是相等的。你可以自由地更改CSS和HTML中`#box`盒子的值，看看会发生什么。
- en: We have our content where our text goes, which we have specified as `150` by
    `150` pixels. If we had not specified width and height, we would have ended up
    with a thick, green rectangular area with text and border across our viewport.
    If we remove only border and padding, we just see the text with a background-color;
    if we only remove the text, we see a bordered, colored rectangle; and if we remove
    both, we end up seeing nothing. Finally, if you put just the width and height
    back, we have a green square of exactly 150 x 150 pixels.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有内容，我们的文本就在那里，我们指定为`150`乘以`150`像素。如果我们没有指定宽度和高度，我们最终会得到一个厚厚的、绿色的矩形区域，文本和边框跨越我们的视口。如果我们只移除边框和填充，我们只看到有背景色的文本；如果我们只移除文本，我们看到一个有边框和颜色的矩形；如果我们两者都移除，我们最终什么也看不到。最后，如果我们只放回宽度和高度，我们就有了一个精确的150
    x 150像素的绿色正方形。
- en: 'So starting from the inner side, we have our content with a *specified* or
    *calculated* size. That is the size of our element: `150` by `150` pixels in our
    example.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所以从内部开始，我们有*指定*或*计算*大小的内容。这就是我们元素的大小：在我们的例子中是`150`乘以`150`像素。
- en: Next we can have **padding**. This takes the same background-color as the element
    and increases the inner portion of our box. In our example, `20px` are added on
    all four sides of the element.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们可以有**填充**。这会使用与元素相同的背景色，并增加我们盒子的内部部分。在我们的例子中，元素的所有四边都增加了`20px`。
- en: Then we can have a **border**. This puts a border around our element with the
    thickness, color, and shape we specify. We used a solid border of `5px` around
    all the sides, and thus, so far our box is already (5 + 25 + 150 + 25 + 5 = 210)
    x 210 pixels.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以有一个**边框**。这会在我们指定的元素周围添加一个具有厚度、颜色和形状的边框。我们在所有边上使用了 `5px` 的实线边框，因此，到目前为止，我们的盒子已经是（5
    + 25 + 150 + 25 + 5 = 210）x 210 像素。
- en: Finally, there is the **margin**. The margin, if we want one, is the area on
    the outer side of our element box. It is transparent, so it has the background
    color of the parent element. It merely creates a distance between the box and
    the adjacent box(es). In this example, we used a margin of `40px`. This makes
    the total size of our box (40 + 210 + 40 = 290) x 290 pixels.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是**边距**。如果我们要边距，它就是元素盒子外部的区域。它是透明的，所以它有父元素的背景颜色。它仅仅在盒子与相邻盒子之间创建距离。在这个例子中，我们使用了
    `40px` 的边距。这使得我们的盒子总大小为（40 + 210 + 40 = 290）x 290 像素。
- en: If you try this out and are an attentive kind of person, you may notice something
    that does not compute. Good catch! We will explain this in a little while. We
    will now go over all the box model properties you can use.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试了这个并且是一个细心的人，你可能注意到了一些不合理的地方。好样的！我们稍后会解释这个问题。现在，我们将回顾所有你可以使用的盒子模型属性。
- en: Padding
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充
- en: 'You can specify, or not, padding on all four sides of your element. For this
    purpose, there are four properties you can use:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定或取消元素四周的填充。为此，你可以使用以下四个属性：
- en: padding-top
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶部填充
- en: padding-right
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧填充
- en: padding-bottom
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底部填充
- en: padding-left
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧填充
- en: 'Here is an example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Did you notice that I changed the order? I did that on purpose. The first order
    I used is the one supported by the shorthand version of the `padding` property.
    The second one is the order I think about when I do my design: what is it horizontally,
    next vertically. So, the same four lines of CSS can be replaced by the following
    single one:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到我改变了顺序吗？我是故意这样做的。我使用的第一个顺序是 `padding` 属性简写版本支持的顺序。第二个顺序是我设计时考虑的顺序：水平方向上是什么，然后是垂直方向。所以，相同的四行
    CSS 可以替换为以下单行：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the first example we used a single value, which means four times the same.
    There are also two and three value variants of the shorthand version as well.
    For example, the following will set both top and bottom to `10px,` and left and
    right to `15px`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们使用了一个单一值，这意味着四倍相同的值。简写版本也有两个和三个值的变体。例如，以下将顶部和底部设置为 `10px`，左侧和右侧设置为
    `15px`：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Border
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边框
- en: 'For the border property also, you have the option to specify different values
    for top, right, bottom, and left, but there is more than just the width. You can
    also specify the shape, style, and the color. So, following are the properties
    for all three:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于边框属性，你也可以为顶部、右侧、底部和左侧指定不同的值，但不仅仅是宽度。你还可以指定形状、样式和颜色。所以，以下是所有三个的属性：
- en: '**border-width**'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边框宽度**'
- en: '**border-style**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边框样式**'
- en: '**border-color**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边框颜色**'
- en: There is even a property you can use for any of these three in any direction,
    such as **border-top-style**, so there are many properties to choose from- not
    that having so many would be practical. I do not believe a border with a different
    shape, color, and size on each side would make for a nice design!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这三个中的任何一个，你都可以在任意方向上使用一个属性，例如 **border-top-style**，所以有很多属性可以选择——虽然拥有这么多并不实用。我不认为每个边都有不同形状、颜色和大小的边框会设计得很好！
- en: 'The most common shapes or styles to choose from are:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择的最常见的形状或样式有：
- en: '**none**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无**'
- en: '**solid**'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实线**'
- en: '**double**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双倍**'
- en: There are, of course, more. Double gives you a double border and can be quite
    decorative at times. Solid is what I recommend you use most of the time.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有更多。双倍边框可以提供双重边框，有时甚至可以起到装饰作用。实线是我建议你大多数时候使用的。
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'So why would you need none? If I do not want a border, I just do not specify
    one, right? *Wrong!* Some browsers, such as Internet Explorer, automatically put
    a white border of 1px around any `img` element. So be glad you have the option
    to deal with that:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 那为什么你需要没有边框呢？如果我不想有边框，我直接不指定不就行了，对吧？*错误！* 一些浏览器，例如 Internet Explorer，会自动在任意的
    `img` 元素周围添加一个 1px 的白色边框。所以，很高兴你有选项来处理这种情况：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We already used the shorthand notation in our examples, so I only have to remind
    you of the order of things to include; I constantly forget them myself: **width
    style color**.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在例子中使用了简写表示法，所以我只需要提醒你包含事物的顺序；我自己也经常忘记：**宽度 样式 颜色**。
- en: Having the ability to put borders around things is a very cool feature, in particular
    for photographs. The web equivalent of the "mat" part of a matted photograph can
    simply be a well-crafted border for the `img` element.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在事物周围添加边框是一个非常酷的特性，特别是对于照片来说。网络上的照片“边框”部分可以简单地是一个精心制作的`img`元素的边框。
- en: Margin
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边距
- en: 'Finally, there is the margin property, which clears an element around its borders.
    It has no background color because it is transparent. The five properties are:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有边距属性，它清除元素周围的边框。它没有背景颜色，因为它是不透明的。这五个属性是：
- en: margin
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`margin`'
- en: margin-top
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`margin-top`'
- en: margin-right
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`margin-right`'
- en: margin-bottom
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`margin-bottom`'
- en: margin-left
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`margin-left`'
- en: 'You can specify margin sizes in pixels, in percentages, and so on, just like
    you can with padding. However, there is one extra, extremely useful value you
    can set the margin to: **auto**. Change the margin setting in our example to:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定边距大小，无论是像素、百分比还是其他，就像你可以指定填充一样。然而，你可以设置边距的一个额外、极其有用的值：**auto**。将我们示例中的边距设置更改为：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Like magic, your two square boxes will be centered horizontally. If you make
    your browser window smaller or bigger, they will still be centered. With the margin
    set to auto, the browser will calculate the left and right margin for you, relative
    to the parent element. Many websites have a main `div`, child of the body element,
    styled similar to the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 就像魔法一样，你的两个正方形盒子将在水平方向上居中。如果你调整浏览器窗口的大小，它们仍然会居中。将边距设置为auto时，浏览器会为你计算相对于父元素的左右边距。许多网站都有一个主要的`div`元素，它是`body`元素的子元素，样式类似于以下内容：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Classical web development uses a canvas with a fixed width, and often fixed
    height as well, to place everything inside. This example uses `980px`. Thanks
    to the `auto` margin, there will be an automatic margin on left and right, calculated
    as half of the remaining horizontal space. The `max-width` is new and differs
    from `width`. Width will always give you 980 px, max-width only when 980 horizontal
    pixels are available. If that is not the case, on smartphones for instance, the
    (smaller) full width of the viewport will become the width. This is one tiny step
    towards **responsive design**.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的网页开发使用一个固定宽度的画布，以及固定的高度，将所有内容放置其中。这个例子使用了`980px`。多亏了`auto`边距，左右将会有自动边距，计算为剩余水平空间的一半。`max-width`是新的，与`width`不同。宽度总是给你980像素，而`max-width`只有在有980个水平像素可用时才会生效。如果不是这样，比如在智能手机上，视口的（较小的）完整宽度将成为宽度。这是向**响应式设计**迈出的一小步。
- en: Collapsing margins
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边距合并
- en: You have been learning about the box model, have used our example, and may have
    been wondering why two square boxes with top and bottom margins of 40px are only
    `40`, not 80 pixels apart.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学习了盒模型，使用了我们的示例，可能也在想为什么两个顶部和底部边距为40px的正方形盒子之间只有`40`像素，而不是80像素。
- en: Well, this is not a bug, but a feature. The W3C specification stipulates that
    when the vertical margins of two elements are touching, the larger of the two
    will take effect and the other one is reduced to 0\. Some other CSS settings can
    change this, but this is the default. Once you have done a lot of web development
    and have gotten used to it, you may decide that it actually makes a lot of sense.
    We will finish this section by adding two more boxes, with pictures inside of
    them, to our HTML and CSS, basically creating the first two entries of a photo
    gallery. We will incorporate what we have learned and discover what is still missing.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这并不是一个错误，而是一个特性。W3C规范规定，当两个元素的垂直边距相接触时，较大的那个将生效，而另一个将被减小到0。一些其他的CSS设置可以改变这一点，但这是默认行为。一旦你做了很多网页开发并习惯了这一点，你可能会觉得这实际上很有道理。我们将通过向HTML和CSS中添加两个带有图片的盒子来结束本节，基本上创建了一个相册的前两个条目。我们将结合所学内容，并找出仍有哪些不足。
- en: 'Here is the HTML:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是HTML：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Put the following in your `stylesheet`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容放入你的`stylesheet`：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you run this example in a browser, you will notice that despite wrapping
    them with another `div` tag, the pictures and the text that goes with it are still
    not side by side, but stacked on top of each other. The solution is already there,
    but placed inside the `/*` and `*/` string as a comment. Uncomment those lines,
    and like magic everything will look the way you want it to.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个例子中运行浏览器，你会注意到，尽管用另一个`div`标签包裹了它们，图片和与之相关的文本仍然不是并排的，而是堆叠在一起的。解决方案已经存在，但被放在了`/*`和`*/`字符串中作为注释。取消注释这些行，就像魔法一样，一切都会看起来像你想要的那样。
- en: Positioning
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位
- en: 'There are several CSS properties you can use to alter the position of an element
    on the page. The one with clearly the most impact is called **float** (each time
    I use it, it reminds me of the clown character in the Stephen King novel and movie
    *It!* when it says: *And they all float!*)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用几个 CSS 属性来改变页面元素的位置。最具影响力的一个被称为 **float**（每次我使用它时，它都会让我想起斯蒂芬·金小说和电影《它！》中的小丑角色，当它说：“它们都飘浮着！”）
- en: Float
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮动
- en: 'I interpret the CSS float property as the CSS way to stack elements horizontally.
    If you give all of them a:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为 CSS 浮动属性是 CSS 堆叠元素的另一种方式。如果您给所有这些元素一个：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You stack them from left to right. With a:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从左到右堆叠它们。使用一个：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You stack them from right to left. This can become very handy when you want
    to put the first part of your page, an introduction for example, on the right
    if room is available, and on top if not. In our above example, changing the float
    left into a float right will put the pictures on the right.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从右到左堆叠它们。当您想在有空间的情况下将页面的一部分，例如一个介绍，放在右侧，如果没有空间则放在顶部时，这会非常有用。在我们的上述示例中，将左浮动改为右浮动会将图片放在右侧。
- en: position:relative
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: position:relative
- en: 'The CSS **position** property can be used to position elements in a spot on
    the page that is different to where they would normally go. "Normally" is the
    same as `position:static`. Look at the following code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: CSS **position** 属性可以用来将元素定位在页面上一个不同于它们通常位置的地方。"通常" 与 `position:static` 相同。看看以下代码：
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This produces a red square in the upper-left corner of its parent element.
    Now, try the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在其父元素的左上角产生一个红色方块。现在，尝试以下操作：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The red square moves `100px` down and `10px` to the right.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 红色方块向下移动 `100px`，向右移动 `10px`。
- en: position:absolute
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: position:absolute
- en: 'Let''s add:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加：
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: and
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The red square box is now inside the teal box, `100px` down, and `10px` to the
    right. When you replace relative by **absolute**, the red box will be `100px`
    down and `10px` to the right, relative to the ancestor element instead. This is
    typically the browser window itself.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 红色方块现在位于青色方块内部，向下 `100px`，向右 `10px`。当您将相对改为 **绝对** 时，红色方块将向下 `100px`，向右 `10px`，相对于祖先元素。这通常是浏览器窗口本身。
- en: Styling lists
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表样式
- en: 'One element that you will end up using a lot is the `<ul>` tag: the unordered
    list. By default, every item in the list will be shown with a round bullet in
    front of the text. With CSS, you can change the style of your list.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您最终会大量使用的一个元素是 `<ul>` 标签：无序列表。默认情况下，列表中的每个项目都将显示一个圆形项目符号在文本前面。使用 CSS，您可以更改列表的样式。
- en: list-style-type
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: list-style-type
- en: 'Using this property, you can change the shape of the bullet. Some of the values
    you can use are: `none` (no bullet at all), `square` (a square), `circle` (a small
    circle), or `disc` (the default).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此属性，您可以更改项目符号的形状。您可以使用的某些值包括：`none`（根本不显示项目符号），`square`（一个方块），`circle`（一个小圆圈），或
    `disc`（默认）。
- en: list-style-image
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: list-style-image
- en: 'You can provide your own image for the bullet by using the **list-style-image**
    property. The default value is `none`, which means that the bullet image is determined
    by the value of **list-style-type**. However if you specify `url`, followed by
    a path to an image, that image will be used instead, for example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 **list-style-image** 属性来为项目符号提供自己的图像。默认值是 `none`，这意味着项目符号图像由 **list-style-type**
    的值决定。但是，如果您指定 `url`，然后是图像的路径，则将使用该图像，例如：
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: list-style-position
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: list-style-position
- en: By default, the bullets appear outside the content flow. If you specify inside
    as the value of **list-style-position**, the bullets will move to the inside and
    the text more to the right.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，项目符号出现在内容流之外。如果您将 **list-style-position** 的值指定为 `inside`，则项目符号将移动到内部，文本将更靠右。
- en: Styling anchors – pseudo-classes
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锚样式 – 伪类
- en: We conclude our selection on CSS properties with the introduction of some pseudo-classes,
    typically but not solely used with `<a>`, the **anchor** tag. The anchor tag is
    used mainly for links. To make it visible that they are indeed links, the default
    styling of `<a>` happens to be a blue color and the text is underlined, which
    is not very attractive.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过介绍一些伪类来结束对 CSS 属性的选择，这些伪类通常但不仅限于与 `<a>` 标签一起使用，即 **锚** 标签。锚标签主要用于链接。为了使它们确实看起来像是链接，`<a>`
    的默认样式恰好是蓝色，并且文本被下划线，这并不太吸引人。
- en: 'Using pseudo-classes, you can give an anchor tag, in theory any tag, a different
    look depending on where the cursor is, relative to the link and whether or not
    the link has already been visited. Here is an example:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用伪类，你可以根据光标相对于链接的位置以及链接是否已被访问，给锚标签（理论上任何标签）赋予不同的外观。以下是一个示例：
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Firebug
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Firebug
- en: No matter how well you studied this chapter and various online references about
    CSS, from time to time things will not look as expected. This is where a debugging
    tool like **Firebug** comes in handy. Firebug is an extension to the Firefox browser.
    It lets you click on parts of your page, and then the program will show you the
    HTML and CSS that is involved and even a picture of the box model showing the
    padding, border, and margin. Most other browsers, Safari and Chrome in particular,
    have comparable counterparts.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你如何学习这一章节以及关于CSS的各种在线参考资料，时不时地你会发现事物并不像预期的那样显示。这时，一个调试工具如**Firebug**就派上用场了。Firebug是Firefox浏览器的扩展程序。它允许你点击页面上的部分，然后程序会显示相关的HTML和CSS，甚至还会显示一个显示填充、边框和边距的盒模型图片。大多数其他浏览器，特别是Safari和Chrome，都有类似的对应工具。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we gave you an overview of CSS. This is not a complete reference
    but we did include the most frequently used and useful CSS properties that should
    be supported by all browsers. We did not include (on purpose) some of the newer
    ones that were introduced in CSS3\. One important new CSS feature that will be
    introduced in the second part of this book will be **media queries**. This is
    essential for building responsive designs, but this topic earns at least one chapter
    of its own.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为您概述了CSS。这不是一个完整的参考，但我们确实包括了所有浏览器都应该支持的常用和有用的CSS属性。我们故意没有包括一些在CSS3中引入的新属性。本书的第二部分将介绍一个重要的新CSS特性：**媒体查询**。这对于构建响应式设计至关重要，但这个主题至少需要一章来详细讨论。
- en: 'So far, we have learned two languages we need to create websites: HTML and
    CSS. Without further delay, we now move on to the next one, a true programming
    language: **JavaScript**.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了创建网站所需的两种语言：HTML和CSS。无需进一步延迟，我们现在继续学习下一个，一种真正的编程语言：**JavaScript**。
