<html><head></head><body>
<div id="_idContainer010">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.2.1">What Is Test-Driven Development and Why Use It in PHP?</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Developing web applications is fun and productive when using the PHP programming language. </span><span class="koboSpan" id="kobo.3.2">The learning curve to get started with PHP is relatively shallow, which is a very important trait of a programming language. </span><span class="koboSpan" id="kobo.3.3">There are a lot of open source learning materials, frameworks, packages, and full-blown extendable products backed by a very large open source community available for PHP developers. </span><span class="koboSpan" id="kobo.3.4">PHP</span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.4.1"> is an enterprise-ready programming language and is widely used as a web-based solution to solve different business problems. </span><span class="koboSpan" id="kobo.4.2">Businesses and developers can quickly develop and deploy web applications with PHP. </span><span class="koboSpan" id="kobo.4.3">Once these businesses start to succeed and grow, they’ll need more features, bug fixes, and improvements to be released on top of the original solution. </span><span class="koboSpan" id="kobo.4.4">This is where it starts to get interesting. </span><span class="koboSpan" id="kobo.4.5">Maintenance of commercially successful software can be one of the biggest contributing factors to the cost of the software, especially when it’s not built to be easily maintainable or testable from the beginning. </span><span class="koboSpan" id="kobo.4.6">Implementing </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">test-driven development</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.7.1">TDD</span></strong><span class="koboSpan" id="kobo.8.1">) will </span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.9.1">improve the maintainability of the software and will help reduce the cost and time to market for </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">a feature.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">There’s a problem that most of us developers might have already experienced or observed: a feature or a bug fix has been released and it has caused more problems, regressions, or unintended software behavior. </span><span class="koboSpan" id="kobo.11.2">If you are coming from a development environment where most or all the </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">quality assurance</span></strong><span class="koboSpan" id="kobo.13.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.14.1">QA</span></strong><span class="koboSpan" id="kobo.15.1">) tests</span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.16.1"> are done manually post-, pre-, or even mid-development, then you might have experienced the issues that I have mentioned. </span><span class="koboSpan" id="kobo.16.2">This is where implementing TDD can really help. </span><span class="koboSpan" id="kobo.16.3">TDD not only helps in implementing automated tests but also guides or even forces us in a way to develop cleaner and more loosely coupled codes. </span><span class="koboSpan" id="kobo.16.4">TDD helps developers write and build tests before even writing a single feature code – this helps ensure that whenever a feature or solution code is being written, there will be a corresponding test already written for it. </span><span class="koboSpan" id="kobo.16.5">It also helps us developers stop saying “</span><em class="italic"><span class="koboSpan" id="kobo.17.1">I’ll add my unit </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.18.1">tests later</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">.”</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">Before writing any codes, it’s very important to understand what TDD is, and what it is not. </span><span class="koboSpan" id="kobo.20.2">There are some common misconceptions about TDD that we need to clear up to help us stay focused on what TDD really is. </span><span class="koboSpan" id="kobo.20.3">In this chapter, we will also try to use a very simple analogy and try to emphasize why we would want to implement TDD as a part of a </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">software project.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">In this chapter, we will be covering </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.24.1">What </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">is TDD?</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Common misconceptions </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">about TDD</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">Why should we even </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">consider TDD?</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">What are we planning to achieve in </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">this book?</span></span></li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.32.1">What is TDD?</span></h1>
<p><span class="koboSpan" id="kobo.33.1">TDD</span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.34.1"> is a simple way of developing software where we think about and define </span><em class="italic"><span class="koboSpan" id="kobo.35.1">what</span></em><span class="koboSpan" id="kobo.36.1"> needs to be the outcome of our programs before we start writing the actual codes that solve </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">a problem.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">TDD is a software development process where test cases are developed first before writing the actual code that solves a problem. </span><span class="koboSpan" id="kobo.38.2">The test cases will be written as PHP code that will use or call the solution code that developers will be building. </span><span class="koboSpan" id="kobo.38.3">The test case code that you build will trigger the development of the solution code that you will write to solve </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">a problem.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">From what I’ve seen, this literal description is what demotivates a lot of developers from applying this process. </span><span class="koboSpan" id="kobo.40.2">TDD is a process, and it’s a way of thinking. </span><span class="koboSpan" id="kobo.40.3">It’s not simply about writing </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">unit tests.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">The test program you write should always fail the first time you run it because you haven’t built the programs the test needs to pass yet. </span><span class="koboSpan" id="kobo.42.2">Then, you will basically have to build the solution codes that the test program will use until the test program itself gets the expected results from your solution codes. </span><span class="koboSpan" id="kobo.42.3">Literally, the failing test will drive you to write the codes to pass the test – hence the term TDD. </span><span class="koboSpan" id="kobo.42.4">Maybe you can even call it failing-TDD. </span><span class="koboSpan" id="kobo.42.5">It’s like saying “</span><em class="italic"><span class="koboSpan" id="kobo.43.1">I wrote a test to fail my code, now I need to </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.44.1">fix it</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">.”</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">In TDD, I can see four main reasons why it’s important to write a failing test first. </span><span class="koboSpan" id="kobo.46.2">First, you will write a failing test and make sure your test framework application can recognize it. </span><span class="koboSpan" id="kobo.46.3">This ensures that your development environment is properly configured and you can run your test programs. </span><span class="koboSpan" id="kobo.46.4">Second, your failing test will help you define what solution or feature code you’d like to write, and what is expected for that test to pass. </span><span class="koboSpan" id="kobo.46.5">This will help you as a developer, in setting or focusing your mindset on the purpose of the feature code you are writing. </span><span class="koboSpan" id="kobo.46.6">Third, the failing tests you write will serve as reminders to know what other programs you need to complete. </span><span class="koboSpan" id="kobo.46.7">Fourth, writing your tests first will help ensure that your solution code is covered by </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">automated tests.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">By trying to make your solution code unit-testable, you are sometimes inadvertently making your codes less coupled – it’s like a cycle. </span><span class="koboSpan" id="kobo.48.2">As you continue to write loosely coupled codes, you will notice that your codes will start to look more organized and less of a tangled mess. </span><span class="koboSpan" id="kobo.48.3">As you continue writing solution code following the</span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.49.1"> TDD process, it will continuously help you spot where tight couplings are in your product, sometimes encouraging you to refactor and decouple your code just to make it unit-testable. </span><span class="koboSpan" id="kobo.49.2">There are software development principles that will help you further improve your codes, such as the Single-Responsibility Principle, which will be discussed more in </span><a href="B18318_08.xhtml#_idTextAnchor121"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.50.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.51.1">, </span><em class="italic"><span class="koboSpan" id="kobo.52.1">Using TDD with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.53.1">SOLID Principles</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">Now that we have defined and have a brief understanding of what TDD is, let’s go through some of the common misconceptions associated </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">with it.</span></span></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.57.1">Common misconceptions about TDD</span></h1>
<p><span class="koboSpan" id="kobo.58.1">In this section, we’ll look at </span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.59.1">some of the misconceptions that I have personally observed that developers have about TDD. </span><span class="koboSpan" id="kobo.59.2">Time and time again, I’ve encountered people who have a poor understanding of TDD. </span><span class="koboSpan" id="kobo.59.3">When I talk to some of them about why they’re not a fan of TDD, they sometimes tell me reasons that are not even related </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">to TDD.</span></span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.61.1">Testing software is not my job as a developer; therefore, I don’t need TDD </span></h2>
<p><span class="koboSpan" id="kobo.62.1">I have said this myself. </span><span class="koboSpan" id="kobo.62.2">I used to think that I just needed to churn out solution code as fast as possible, test a little bit manually, and let the testing department ensure that everything is built correctly. </span><span class="koboSpan" id="kobo.62.3">This is probably the worst misconception I’ve ever had about TDD. </span><span class="koboSpan" id="kobo.62.4">As software developers, we develop software as solutions to problems. </span><span class="koboSpan" id="kobo.62.5">If we developers are the ones causing more problems, then we are not doing our jobs. </span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.63.1">Developing with TDD is unnecessarily slow</span></h2>
<p><span class="koboSpan" id="kobo.64.1">I would be surprised if this were the first time you are hearing this. </span><span class="koboSpan" id="kobo.64.2">I first heard this from a client who had a technical background, not from a developer. </span><span class="koboSpan" id="kobo.64.3">I wasn’t a fan of TDD myself and willingly agreed with my client back then. </span><span class="koboSpan" id="kobo.64.4">Sure, it’s slower to write test codes and solution codes together; I would have to type more characters on my keyboard, </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">after all!</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">When working on enterprise projects, from what I have experienced, TDD is what saved us from months of bugs and regressions. </span><span class="koboSpan" id="kobo.66.2">Writing tests and having good test coverage, which is discussed in </span><a href="B18318_05.xhtml#_idTextAnchor070"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.67.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.68.1">, </span><em class="italic"><span class="koboSpan" id="kobo.69.1">Unit Testing</span></em><span class="koboSpan" id="kobo.70.1">, will help ensure that the next time someone else touches the code or adds new features, no regressions will be introduced. </span><span class="koboSpan" id="kobo.70.2">TDD will help you build a lot of automated tests, and running these tests is cheaper and quicker than handing over your untested solution code to a testing team or testing company for </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">manual</span></span><span class="No-Break"><a id="_idIndexMarker006"/></span><span class="No-Break"><span class="koboSpan" id="kobo.72.1"> testing.</span></span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.73.1">Writing automated or unit tests is TDD</span></h2>
<p><span class="koboSpan" id="kobo.74.1">TDD is not about writing automated tests or unit tests for existing functionalities. </span><span class="koboSpan" id="kobo.74.2">TDD is not about getting your QA department or getting a third-party company to write automated tests for existing software. </span><span class="koboSpan" id="kobo.74.3">This is the exact opposite </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">of TDD.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">The most common misconception I have observed is that some developers and testers assume that TDD has something to do with testers writing automated tests for the codes that the developers build. </span><span class="koboSpan" id="kobo.76.2">I believe that this is a very bad misconception. </span><span class="koboSpan" id="kobo.76.3">It’s no different from developing a program and sending it to the QA department for manual testing.  </span></p>
<p><span class="koboSpan" id="kobo.77.1">Getting testers to write automated functional tests is a very good thing, especially for existing functionalities that do not have automated tests, but this should only be thought of as supplementary test coverage for software and not be confused </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">with TDD.</span></span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.79.1">TDD is a silver bullet</span></h2>
<p><span class="koboSpan" id="kobo.80.1">The last</span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.81.1"> misconception that I have encountered is assuming that if we developers have built excellent test coverage by following TDD, we will no longer need input from the software development department and QA department or team. </span><span class="koboSpan" id="kobo.81.2">Time and time again, I’ve proven myself wrong, believing that code that’s written via the TDD methodology is bulletproof. </span><span class="koboSpan" id="kobo.81.3">I am very fortunate to work with knowledgeable and skilled software engineers and test engineers. </span><span class="koboSpan" id="kobo.81.4">Code reviews are critical; always get your codes and test scenarios peer-reviewed. </span><span class="koboSpan" id="kobo.81.5">Edge-case tests and functional scenarios that the developers might have overlooked will cause problems – and in my experience, they have caused big problems. </span></p>
<p><span class="koboSpan" id="kobo.82.1">It is very important for the development and testing teams to properly understand the functional and acceptance test cases so that all imaginable scenarios are covered: the different types of tests will be covered in </span><a href="B18318_05.xhtml#_idTextAnchor070"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.83.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.84.1">, </span><em class="italic"><span class="koboSpan" id="kobo.85.1">Unit Testing</span></em><span class="koboSpan" id="kobo.86.1">. </span><span class="koboSpan" id="kobo.86.2">This is where </span><strong class="bold"><span class="koboSpan" id="kobo.87.1">behavioral-driven development</span></strong><span class="koboSpan" id="kobo.88.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.89.1">BDD</span></strong><span class="koboSpan" id="kobo.90.1">) will start to </span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.91.1">make sense; BDD will be discussed in more detail in </span><a href="B18318_06.xhtml#_idTextAnchor094"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.92.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.93.1">, </span><em class="italic"><span class="koboSpan" id="kobo.94.1">Applying Behaviour-Driven Development</span></em><span class="koboSpan" id="kobo.95.1">. </span><span class="koboSpan" id="kobo.95.2">I have worked with test engineers and QA personnel who can come up with edge cases that </span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.96.1">I couldn’t have imagined. </span></p>
<p><span class="koboSpan" id="kobo.97.1">We have gone through some common misconceptions I have encountered about TDD. </span><span class="koboSpan" id="kobo.97.2">Now let’s try to make a case for why we’d want to consider using TDD in our </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">development process.</span></span></p>
<h1 id="_idParaDest-24"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.99.1">Why should we even consider TDD?</span></h1>
<p><span class="koboSpan" id="kobo.100.1">Why</span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.101.1"> would I want my codes to be driven by tests? </span><span class="koboSpan" id="kobo.101.2">I want my codes to be driven by requirements and happy clients! </span><span class="koboSpan" id="kobo.101.3">You may have heard about the term TDD and felt uncomfortable with it. </span><span class="koboSpan" id="kobo.101.4">When I first heard about the term TDD, I was a bit uncomfortable with it too. </span><span class="koboSpan" id="kobo.101.5">Why would you want to waste time writing test code to test solution code that doesn’t exist yet? </span><span class="koboSpan" id="kobo.101.6">Seriously, I need to write the actual code that solves the business problem, and you want me to write tests first? </span><span class="koboSpan" id="kobo.101.7">As a matter of fact, some developers I have trained and worked with have had this same question too – and it’s the exact same question that was stopping them from getting interested in TDD! </span></p>
<p><span class="koboSpan" id="kobo.102.1">When I started my software development career, I was working for a small company where we were required to deliver results as soon as possible, in very few iterations. </span><span class="koboSpan" id="kobo.102.2">Just thinking about writing automated tests for my super-quickly written codes was a big waste of time! </span><span class="koboSpan" id="kobo.102.3">Therefore, when I read about TDD for the first time, I was not interested. </span><span class="koboSpan" id="kobo.102.4">I ignored my meatball spaghetti codes; all I cared about was making sure that the client got the intended business results in the shortest amount of time. </span><span class="koboSpan" id="kobo.102.5">Solving the regressions that would be caused by the bad codes as a problem for later. </span><span class="koboSpan" id="kobo.102.6">I needed to make the client happy as soon as possible – that is, right now. </span><span class="koboSpan" id="kobo.102.7">This is probably one of the most short-sighted mistakes I made in my professional career. </span><span class="koboSpan" id="kobo.102.8">Most of the time, my colleagues and I had to add features and maintain our own bowl of spaghetti mess. </span><span class="koboSpan" id="kobo.102.9">Time and time again, we would hate our past selves when we saw the mess we had made. </span><span class="koboSpan" id="kobo.102.10">Early in our careers as software developers, we have a lot of mistakes, inefficiencies, and short-sightedness. </span><span class="koboSpan" id="kobo.102.11">Thankfully, we are not the first ones to encounter these problems. </span><span class="koboSpan" id="kobo.102.12">There are processes that we can follow to help us improve the quality of the software we produce, and one of them is TDD. </span></p>
<p><span class="koboSpan" id="kobo.103.1">Now, after making so many mistakes, so many failures, and after working on hundreds of business-critical software projects, I can’t even imagine living a day without writing tests by following TDD. </span><span class="koboSpan" id="kobo.103.2">When working on a project, I don’t think I can even sleep properly at night without knowing whether my automated tests have passed or failed; at least I have the tests! </span></p>
<p><span class="koboSpan" id="kobo.104.1">Imagine creating a </span><em class="italic"><span class="koboSpan" id="kobo.105.1">clean my home</span></em><span class="koboSpan" id="kobo.106.1"> to-do list on your phone: you only have one item on it and it’s </span><em class="italic"><span class="koboSpan" id="kobo.107.1">clean the coffee machine</span></em><span class="koboSpan" id="kobo.108.1">. </span><span class="koboSpan" id="kobo.108.2">You write that item down, get distracted and forget about it, and go on with your day. </span><span class="koboSpan" id="kobo.108.3">When you check your list again, you will realize that you have not cleaned the coffee machine yet! </span><span class="koboSpan" id="kobo.108.4">You then go ahead and clean the machine, and mark the item as completed. </span></p>
<p><span class="koboSpan" id="kobo.109.1">Well, that’s a bit</span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.110.1"> like how TDD works. </span><span class="koboSpan" id="kobo.110.2">You write a failing test, then you write the codes to pass the test – and with the to-do list, you write out “</span><em class="italic"><span class="koboSpan" id="kobo.111.1">clean the coffee machine</span></em><span class="koboSpan" id="kobo.112.1">”; then after you clean the actual coffee machine, you cross it out from </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">your list.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.114.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.115.1">Before anything else, I mean right now, you need to understand that it is very normal for a test to fail in the beginning and you need to be very comfortable with it and accept it. </span><span class="koboSpan" id="kobo.115.2">It’s like writing the coffee machine checklist item on your phone. </span><span class="koboSpan" id="kobo.115.3">Once you add that to your to-do list, the to-do list is failing you until you pass it by marking the to-do item as complete. </span><span class="koboSpan" id="kobo.115.4">You need to write the failing test first before writing any program to pass that test. </span><span class="koboSpan" id="kobo.115.5">This is a part of</span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.116.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.117.1">Red, Green, Refactor</span></strong><span class="koboSpan" id="kobo.118.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.119.1">RGR</span></strong><span class="koboSpan" id="kobo.120.1">) concept, which will be discussed further in </span><a href="B18318_07.xhtml#_idTextAnchor108"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.121.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.122.1">, </span><em class="italic"><span class="koboSpan" id="kobo.123.1">Building Solution Code with BDD </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.124.1">and TDD</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">Going </span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.127.1">back to your phone, you add more items to that list: </span><em class="italic"><span class="koboSpan" id="kobo.128.1">clean the kitchen</span></em><span class="koboSpan" id="kobo.129.1">, </span><em class="italic"><span class="koboSpan" id="kobo.130.1">clean the bedroom</span></em><span class="koboSpan" id="kobo.131.1">, </span><em class="italic"><span class="koboSpan" id="kobo.132.1">clean the bathroom</span></em><span class="koboSpan" id="kobo.133.1">… You then go to the gym and get distracted. </span><span class="koboSpan" id="kobo.133.2">You remember your list and want to know whether you have actually cleaned your home before going out, so you view your to-do list. </span><span class="koboSpan" id="kobo.133.3">You realize you only completed one item on the list; you will have to go back and finish the other tasks to fully satisfy the </span><em class="italic"><span class="koboSpan" id="kobo.134.1">clean my home</span></em><span class="koboSpan" id="kobo.135.1"> to-do list. </span><span class="koboSpan" id="kobo.135.2">When you return home, you can continue cleaning your home and ticking off your </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">to-do list:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.137.1"><img alt="Figure 1.1 – Incomplete to-do list" src="image/Figure_1.1_B18318.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.138.1">Figure 1.1 – Incomplete to-do list</span></p>
<p><span class="koboSpan" id="kobo.139.1">You can think of the incomplete items on your to-do list as failing tests. </span><span class="koboSpan" id="kobo.139.2">The action of cleaning something is writing the codes to satisfy the failing to-do list item. </span><span class="koboSpan" id="kobo.139.3">You, finishing the task of cleaning the bedroom or bathroom, is akin to passing a test. </span><span class="koboSpan" id="kobo.139.4">Now imagine you have completed all the cleanings and so on, and you’ve marked all the items as checked on your </span><em class="italic"><span class="koboSpan" id="kobo.140.1">clean my home</span></em><span class="koboSpan" id="kobo.141.1"> list on your phone: you’re done! </span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.142.1"><img alt="Figure 1.2 – Completed to-do list" src="image/Figure_1.2_B18318.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.143.1">Figure 1.2 – Completed to-do list</span></p>
<p><span class="koboSpan" id="kobo.144.1">Now you </span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.145.1">can imagine your </span><em class="italic"><span class="koboSpan" id="kobo.146.1">clean my home</span></em><span class="koboSpan" id="kobo.147.1"> list as a test as well. </span><span class="koboSpan" id="kobo.147.2">Your test is satisfied by the overall completeness of the codes that were built to satisfy your smaller unit and integration tests (the types of tests will be discussed in detail in </span><a href="B18318_07.xhtml#_idTextAnchor108"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.148.1">Chapter 7</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.149.1">, Building Solution Code with BDD </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.150.1">and TDD</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.152.1">We can consider the </span><em class="italic"><span class="koboSpan" id="kobo.153.1">clean my home</span></em><span class="koboSpan" id="kobo.154.1"> list as a test. </span><span class="koboSpan" id="kobo.154.2">This test runs through all the processes of cleaning a home. </span><span class="koboSpan" id="kobo.154.3">Some objects inside it involve cleaning the bathroom, some the kitchen, and so on. </span><span class="koboSpan" id="kobo.154.4">Just as we did when writing the to-do list, you write the failing test that represents the bigger picture first and not the smaller, more </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">detailed tests:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.156.1">
// Test Method
public function testCanCleanMyHome()
{
     $isMyHomeClean = $this-&gt;getCleaner()-&gt;clean();
     $this-&gt;assertTrue($isMyHomeClean);
}</span></pre>
<p><span class="koboSpan" id="kobo.157.1">After writing the failing </span><em class="italic"><span class="koboSpan" id="kobo.158.1">clean my home</span></em><span class="koboSpan" id="kobo.159.1"> test, which can only be satisfied by building the programs to clean each part of the house, we can start writing the failing tests for the smaller parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">the solution:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.161.1">
// Test Method
public function testCanCleanCoffeeMachine()
{
     $isMyCoffeeMachineClean = $this-&gt;getCleaner()-&gt;
         clean();
     $this-&gt;assertTrue($isMyCoffeeMachineClean);
}</span></pre>
<p><span class="koboSpan" id="kobo.162.1">Now imagine after cleaning your home, you ended up making a mess of the bedroom and you have unchecked the </span><em class="italic"><span class="koboSpan" id="kobo.163.1">clean my bedroom</span></em><span class="koboSpan" id="kobo.164.1"> item on your list. </span><span class="koboSpan" id="kobo.164.2">Technically speaking, your </span><em class="italic"><span class="koboSpan" id="kobo.165.1">clean my home</span></em><span class="koboSpan" id="kobo.166.1"> to-do list is now incomplete again. </span><span class="koboSpan" id="kobo.166.2">The same thing happens when after you have passed all the tests and someone in your team or you modifies the code and changes the expected behavior. </span><span class="koboSpan" id="kobo.166.3">If you then run your </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">testCanCleanMyHome()</span></strong><span class="koboSpan" id="kobo.168.1"> test, it will fail. </span><span class="koboSpan" id="kobo.168.2">If we then run these automated tests before we deploy our codes to production, we will be able to catch regressions early on! </span><span class="koboSpan" id="kobo.168.3">It will be easier to catch code changes that break expected behaviors!  </span></p>
<p><span class="koboSpan" id="kobo.169.1">This is an oversimplification, but you will realize as we go along that this is what TDD is like. </span><span class="koboSpan" id="kobo.169.2">It’s not a bad, time-wasting exercise </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">after all!</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">We are humans and we tend to make mistakes – at least that’s what I believe. </span><span class="koboSpan" id="kobo.171.2">Although if you think you don’t make mistakes, you might as well just pry the </span><em class="italic"><span class="koboSpan" id="kobo.172.1">Delete</span></em><span class="koboSpan" id="kobo.173.1"> key out of your keyboard as you don’t need it. </span><span class="koboSpan" id="kobo.173.2">I’ve made so many mistakes, and to help build confidence in my code, I ensure to pass all the tests and get the </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">code peer-reviewed.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">Implementing </span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.176.1">TDD and having a lot of test coverage for your software is a great way of helping you and your team spot mistakes before they cause harm in production. </span><span class="koboSpan" id="kobo.176.2">Having all these different types of tests running before deployment helps me sleep better </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">at night.</span></span></p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.178.1">What are we planning to achieve in this book?</span></h1>
<p><span class="koboSpan" id="kobo.179.1">Well, obviously, we want to get a better understanding of TDD – not just with theories but with actual usable and applicable understanding. </span><span class="koboSpan" id="kobo.179.2">We want to help ourselves write better codes that will benefit other developers who will work on your own codes as well. </span><span class="koboSpan" id="kobo.179.3">We want to be able to lay a foundation for how to write software that will be robust and sturdy, self-diagnosing, and more extensible. </span></p>
<p><span class="koboSpan" id="kobo.180.1">We used a very simple analogy earlier using the </span><em class="italic"><span class="koboSpan" id="kobo.181.1">clean my home</span></em><span class="koboSpan" id="kobo.182.1"> to-do list to try to explain what TDD is and how it is done – but this will not be very exciting if it’s all just theory. </span><span class="koboSpan" id="kobo.182.2">In this book, we will try to implement TDD for real using an </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">example project!</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">We will be building an example project that will help us do </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.186.1">Identify what a client or a business wants </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">to achieve</span></span></li>
<li><span class="koboSpan" id="kobo.188.1">Translate those requirements into </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">actual tickets</span></span></li>
<li><span class="koboSpan" id="kobo.190.1">Learn how to implement TDD </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">and BDD</span></span></li>
<li><span class="koboSpan" id="kobo.192.1">Write clean codes following design patterns and </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">best practices</span></span></li>
<li><span class="koboSpan" id="kobo.194.1">Automatically run all tests using </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">continuous integration</span></span></li>
<li><span class="koboSpan" id="kobo.196.1">Automatically deploy our codes using </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">continuous deployment</span></span></li>
</ul>
<h1 id="_idParaDest-26"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.198.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.199.1">In this chapter, we have defined what TDD is and what it is not. </span><span class="koboSpan" id="kobo.199.2">We tried to relate TDD to simple everyday tasks such as cleaning certain parts of your home. </span><span class="koboSpan" id="kobo.199.3">By trying to clear up common misconceptions about TDD, hopefully, we will have a clearer understanding of what TDD is. </span><span class="koboSpan" id="kobo.199.4">TDD is a process; it’s not solely about writing unit tests and </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">automated tests.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">We also covered why we would want to use TDD when developing PHP applications. </span><span class="koboSpan" id="kobo.201.2">TDD helps us develop cleaner, decoupled, maintainable codes, and it helps us be more confident that we won’t introduce regressions whenever we release codes, thanks to the automated test coverage that is inherently built by </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">following TDD.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">In the next chapter, we will start building the example project by coming up with a simple hypothetical business challenge first and making sense of what needs to be built to solve </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">the problem.</span></span></p>
</div>
</body></html>