- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying Behavior-Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned how to create and use unit tests to our
    advantage. We used unit tests and integration tests to help ensure the stability
    of our solution code. That was probably like learning how to do a basic punch
    on a punching bag. If you go to a boxing class, they’ll probably teach you how
    to use your basic punch more effectively and teach you how to use that basic punch
    to do combinations of punches, as well as how to defend against them. That’s akin
    to what **behavior-driven development** (**BDD**) and **test-driven development**
    (**TDD**) are. We first need to start with the basics: unit and integration testing.
    Now that we have those basics, we can start applying processes or techniques so
    that we can use them more effectively.'
  prefs: []
  type: TYPE_NORMAL
- en: A lot of developers know how to write unit tests and integration tests—after
    all, these tests are just programs that we developers write. From my personal
    experience, what I’ve noticed is that a lot of developers won’t know how to utilize
    their unit tests and integration tests effectively on their projects. Some developers
    know how to write unit tests but could not even write one for their project. So,
    merely having basic or technical knowledge of how to write a unit test is not
    enough to help improve a project. Applying and using it effectively is what counts.
  prefs: []
  type: TYPE_NORMAL
- en: With BDD and TDD, that’s what we’ll try to do. We will utilize those testing
    skills by following a process to help us build our example project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is BDD?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying BDD using Behat and Gherkin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing PHP code based on Gherkin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser emulators and Mink
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why bother with Gherkin, then?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to write behavior-driven features,
    scenarios, and solution code.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter requires you to have all the containers, configurations, and testing
    tools we have utilized in [*Chapter 5*](B18318_05.xhtml#_idTextAnchor070), *Unit
    Testing*. You can download the source files from this URL and run the containers:
    [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%205](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%205).'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the development environment for the chapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, get the base code for [*Chapter 6*](B18318_06.xhtml#_idTextAnchor094),
    found in [https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%206/base/phptdd](https://github.com/PacktPublishing/Test-Driven-Development-with-PHP-8/tree/main/Chapter%206/base/phptdd)
    or simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To run the containers and execute the commands in this chapter, you should be
    inside the `docker-server-web-1` container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to confirm the container name for our web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the containers, run the following command from the `/phptdd/docker`
    directory from the repository in your host machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once inside the container, run the following command to install the libraries
    required through Composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What is BDD?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BDD is a way or a process to develop software where the intended behavior of
    a solution is first defined by the business and then translated into automated
    test scenarios, before starting the actual development of the solution code.
  prefs: []
  type: TYPE_NORMAL
- en: This development process promotes collaboration among the different departments
    or teams in a software company. It might sound ridiculous, but in my experience,
    understanding exactly “what” needs to be built and what is the actual goal of
    the project is what I always see as the most elusive part when starting a project.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when the business or a client doesn’t even know what it wants,
    or maybe the business or client does not know how to express or relay those goals
    effectively. Now, imagine being a software developer for a company—your job is
    to develop solutions to problems to achieve a goal. What if that goal is not defined
    clearly? Or, what if the goal was defined by the business but not relayed properly
    to the software developers? Basically, the developers will end up developing the
    wrong solution and—worse—for the wrong problem! That’s why collaboration among
    different departments in a software company is very important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Business analysts, project managers, architects, and developers can define
    what the goals are for a project, and why the project is needed in the first place.
    The test engineers and software developers can then coordinate, debate, and discuss
    with the business analysts to come up with expected or intended behaviors of a
    solution, then break them down into smaller pieces. This is the first step that’s
    needed in BDD: knowing exactly what the goal is, what needs to be built, and knowing
    which behaviors are expected from a solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what BDD is, we can start applying it to our example project.
  prefs: []
  type: TYPE_NORMAL
- en: Applying BDD using Behat and Gherkin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help us easily understand what BDD is and how it is used, we will try to
    apply it to example scenarios in a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to [*Chapter 2*](B18318_02.xhtml#_idTextAnchor027), *Understanding
    and Organizing the Business Requirements of Our Project*, we have created some
    Jira tickets to help us break down the features that we need to build. Within
    the **Inventory Clerk Solution** epic, we have created a user story with the following
    title:'
  prefs: []
  type: TYPE_NORMAL
- en: '*As an inventory clerk, I want to be able to log in to the system so that I
    can access the* *inventory system.*'
  prefs: []
  type: TYPE_NORMAL
- en: With this user story, we can deduce that we will need a user for the application
    and that user will need to be able to authenticate themself so that they can access
    a restricted feature.
  prefs: []
  type: TYPE_NORMAL
- en: So, usually, as software developers, we’ll then go ahead and start building
    the solution code for that– write code, then check the results from the controller
    or web page we just created. We won’t be doing that.
  prefs: []
  type: TYPE_NORMAL
- en: With BDD, we’ll first start with a failing scenario. Sounds familiar? Yes—from
    the previous chapter, it’s just like writing our failing unit test before we write
    the solution code to pass that failing test.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start writing our BDD test, we’ll need to use some PHP packages to
    let us do this. We’ll use the Behat testing framework to help us build and organize
    our BDD tests.
  prefs: []
  type: TYPE_NORMAL
- en: What is Behat?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Behat is a PHP framework built for implementing BDD in PHP. It’s a framework
    to help us PHP developers write behavior-driven tests and programs. This will
    help us write better behavior-driven programs quicker so that we won’t have to
    reinvent the wheel in coming up with bootstrap code or skeleton code to write
    these behavior-driven tests. Behat uses Gherkin to describe the actual features
    we want to test.
  prefs: []
  type: TYPE_NORMAL
- en: What is Gherkin?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gherkin is a language used to define business scenarios and goals. It’s in plain
    English text, so anyone in the company—even non-technical staff—will be able to
    understand the business scenario being described.
  prefs: []
  type: TYPE_NORMAL
- en: What is Mink?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is where it gets very interesting, at least for a PHP developer like me.
    Mink is a PHP library that will serve as an emulator for a web browser. We web
    application developers develop PHP applications; our users will be using our web
    applications through a web browser. So, it will be very beneficial for us if we
    automate the process of testing our application through a web browser. Instead
    of manually clicking on buttons or filling out forms, and so on, we can just use
    some programs to do this for us. So, think about a robot version of yourself testing
    your program for you through a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be installing Behat.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Behat and Mink
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start writing our first behavior-driven test programs, we’ll first
    need to install all the libraries and dependencies we need. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory named `behat` under the `codebase` directory so that
    we can have a separate installation directory from our Symfony application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Behat root directory](img/Figure_6.01_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Behat root directory
  prefs: []
  type: TYPE_NORMAL
- en: After creating the new directory, we can go ahead and start installing the Behat
    PHP package through Composer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using your terminal, inside the `behat` directory, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the installation, you can verify whether Behat was successfully installed
    by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once done, you should then see the Behat version that you just installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Behat installed](img/Figure_6.02_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Behat installed
  prefs: []
  type: TYPE_NORMAL
- en: Now, we also need to install Mink so that we can do some frontend testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to install Mink:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now, we need to let Behat create some skeleton files to help us get
    started. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You should now see a new directory called `features`. This is where we will
    be putting our business feature scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Behat feature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have installed Behat and initialized it, we can create our first
    example feature file. We will use the Gherkin language to define the feature’s
    story. It’s literally like telling a story.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `features` directory, create a new file called `home.feature` and add
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: /var/www/html/behat/features/home.feature
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have created `feature` and `scenario` files using the Gherkin language. They
    are descriptive and very easy to understand. You don’t need a programmer to understand
    what they mean. So, showing them to your colleagues such as business analysts
    or test engineers won’t be an issue; they’ll even be able to help you fine-tune
    or improve your features and scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll focus on the `Feature` keyword itself and its content.
  prefs: []
  type: TYPE_NORMAL
- en: Feature keyword
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As you can see in the preceding code snippet, we have written three sections
    below the `Feature` keyword. The three sections below it are set out here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In order to` <business goal>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`As` `a/an` <actor>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`I need to be able to` <what the actor defined previously should be able to
    do>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `In order to` section, we define what the business wants to achieve in
    this feature. In our example, we want our site visitors to feel welcomed when
    they land on our home page.
  prefs: []
  type: TYPE_NORMAL
- en: In the `As a/an` section, we define who is performing the action. In our example,
    this is the site visitor who is accessing the home page.
  prefs: []
  type: TYPE_NORMAL
- en: And lastly, in the `I need to be able to` section, we define what the actor
    should be able to do or achieve so that the business can achieve its end goal.
    In our example, we just want the actor or visitor to see the Symfony logo and
    the welcome message.
  prefs: []
  type: TYPE_NORMAL
- en: Next, as a part of a feature, we will need to add scenarios using the `Scenario`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario keyword
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside a feature, we can have one or more scenarios. In the `home.feature`
    file we created, you’ll notice that the `Scenario` tag is indented compared to
    the `Feature` tag above it. A scenario is written in plain English; it is just
    a written outline of a sequence of events. In Gherkin, we will divide a scenario
    into three sections as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Given`: Used to declare the existing or current state or value of the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`When`: Used to define verbs or actions performed on the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Then`: The expected result after performing the verbs or actions declared
    in the `When` section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have defined both an example feature and scenario, let’s try to
    run Behat and see what we get.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should then see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Missing snippets](img/Figure_6.03_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Missing snippets
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that Behat tried to look for some PHP code that represents the
    scenario we declared earlier, but we did not do that. So, that means that we also
    have to write some PHP code for Behat to execute in relation to the actual `Given`,
    `When`, and `Then` definitions we have created.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll write the PHP code needed to support the features and scenarios
    we just created.
  prefs: []
  type: TYPE_NORMAL
- en: Writing PHP code based on Gherkin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need PHP programs to represent the features and scenarios we created
    using Gherkin. The Behat framework will follow the features and scenarios we created
    in the previous section, but it will also look for PHP code that represents each
    feature and scenario. Within this PHP code, we can add any custom logic we want
    to interpret the features and scenarios into programs. Create the following files
    that the Behat framework needs to run our features and scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a new context class. A context class is what Behat
    uses to represent Gherkin features into PHP programs.Create the following file
    with the content shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/behat/features/bootstrap/HomeContext.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, after creating the `HomeContext.php` class, we also need to tell Behat
    that we have a new context class. We can do this by creating a configuration file.
    Create the following file with the content shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/behat/behat.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can declare more PHP context classes. By default, you can use the `FeatureContext.php`
    file that’s been automatically created earlier in this chapter, but if we keep
    on adding different steps inside the `FeatureContext.php` class, we’ll end up
    with a mess.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s try running Behat again, but this time, we’ll use the following
    command to automatically generate the missing snippets for our `Given`, `When`,
    and `Then` steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll then be prompted to enter which specific context class you want to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Selecting a context class](img/Figure_6.04_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Selecting a context class
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter `2` into the CLI, then press *Enter*. Now, you should get the following
    result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Automatically generated snippets](img/Figure_6.05_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Automatically generated snippets
  prefs: []
  type: TYPE_NORMAL
- en: Behat has automatically generated the PHP snippets needed to represent the `Given`,
    `When`, and `Then` steps we have defined inside the `home.feature` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `HomeContext.php` class we created earlier, and there you should see
    the new automatically generated methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `iShouldSeeTheSymfonyLogo()` method, replace the `PendingException` class
    with just an `Exception` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Great! Now, let’s run Behat again, and see what we get:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the automatically generated snippets return a `PendingException` object,
    we’ll get the following result from Behat:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Behat with automatically generated PHP snippets](img/Figure_6.06_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Behat with automatically generated PHP snippets
  prefs: []
  type: TYPE_NORMAL
- en: We should now see the warm and comforting failed test message. So far, we were
    able to use Gherkin to define our feature. Then, we created a separate context
    class to house the methods that Behat will execute in relation to each of the
    `Given`, `When`, and `Then` steps we have defined using Gherkin. Then, we used
    Behat to automatically generate those methods. Now, how do make all these tests
    pass? Well, we can remove the exception we are throwing from the `iShouldSeeTheSymfonyLogo()`
    method! As you can see, this is all happening inside PHP land. But to really pass
    the test, we have to let Behat fire up a browser, visit the home page URL, and
    verify whether it can see the Symfony logo.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we do that? Remember when we installed Mink earlier? We will now
    have to use Mink and a browser emulator to do the browser work for us.
  prefs: []
  type: TYPE_NORMAL
- en: Browser emulators and Mink
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Browser emulators are programs that emulate or mimic the functionalities and
    behaviors of a web browser. These emulators can then be used by another program,
    such as Behat or Codeception, to simulate what a real user would do on a web browser
    while using your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of browser emulators:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Headless**: These types of emulators fire HTTP requests and simply listen
    for the returned DOM or response from the web application. They will be best suited
    for lightweight testing, without the need for complicated checks such as checking
    for an AJAX response after a mouseover event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controllers**: These types of emulators use real browsers, and they basically
    act like a person who controls a real browser. The good thing about using these
    types of emulators, in my experience, is that we can set the type of browser we
    want to test with. We can also check for the JavaScript and AJAX results on a
    page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example, we will use the headless browser as we won’t need to do any
    JavaScript/AJAX actions. If you need to use a real browser emulator for your project,
    I highly recommend using Selenium2\. You can read more about Selenium from the
    Selenium website at https://www.selenium.dev.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to let our Behat application start interacting with a browser emulator,
    in place of a real user, create the following program files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `HomeContext.php` class we created earlier and replace it with the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: codebase/behat/features/bootstrap/HomeContext.php
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, we have instantiated an instance of Mink, which we injected
    with a `Session` object. We have injected a driver object into the session with
    an instance of the Goutte headless emulator. Mink supports different types of
    browser emulators; you can read more about them here: [https://mink.behat.org/en/latest/at-a-glance.html](https://mink.behat.org/en/latest/at-a-glance.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following functions inside the same class. These methods represent
    each of the steps you have defined in your scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Within the `iVisitTheHomePage()` method, we retrieved the Goutte-injected session
    we just created, and then we let the emulator visit the URL and click on a link.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run the test and see whether it works! Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should then see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Failed headless browser assertion](img/Figure_6.07_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Failed headless browser assertion
  prefs: []
  type: TYPE_NORMAL
- en: 'We failed the test again, but why is that? Notice that inside the `iVisitTheHomePage()`
    method, we have this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This line tells the emulator to click on the **Tutorials** option on the home
    page, which uses the **Create your first page** anchor text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Create your first page link ](img/Figure_6.08_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Create your first page link
  prefs: []
  type: TYPE_NORMAL
- en: What happened was the emulator successfully loaded the Symfony home page, and
    then clicked on the tutorial link, and therefore the browser was redirected to
    a different page! That’s why we failed the test. So, if we update the `iVisitTheHomePage()`
    method and remove the offending line, we should now be able to pass the test!
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the test again by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should then see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – The first Behat test passed](img/Figure_6.09_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – The first Behat test passed
  prefs: []
  type: TYPE_NORMAL
- en: Great! We finally passed our first Behat test! In the `iShouldSeeTheSymfonyLogo()`
    method, you’ll notice that we have two assertions. In the first assertion, we
    wanted to check whether an element exists in the returned DOM, which is the *logo*
    element. We then added another assertion to check for the **Welcome to Symfony
    6** text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your web browser and visit the following page: `http://127.0.0.1:8081/symfony/public/`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your element inspector; you should see the logo element. This is what
    we told Mink to look for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Logo element](img/Figure_6.10_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Logo element
  prefs: []
  type: TYPE_NORMAL
- en: Since both the *logo* element and **Welcome to Symfony 6** text exists when
    the browser emulator visited the home page, it finally passed the test!
  prefs: []
  type: TYPE_NORMAL
- en: Now, I think you’ll have an idea of how useful and powerful these tools can
    be. This can save you and your team hours of manual testing.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, you can start writing behaviors represented by features and scenarios
    using the Gherkin language, then use Behat to execute those tests, then develop
    features using PHP to satisfy those tests. If you follow this process, your development
    will be driven by the behaviors that were defined before writing a single line
    of code. Now, your development is behavior driven!
  prefs: []
  type: TYPE_NORMAL
- en: Why bother with Gherkin, then?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example we used in this chapter is very simple, but you might be tempted
    to think that we can just skip the features written in the Gherkin language. Well,
    I did that too. I thought: it’s not that useful. But when I started working on
    bigger projects, with bigger teams, with different companies working collaboratively
    on the same project and goal, I thought to myself: I wish there were a common
    format that we could share so that we all understand what the business is trying
    to achieve. I was working collaboratively with a third-party company, and I wanted
    to ask them whether I could borrow or get a copy of their test cases, but the
    thing is, they wrote down their test cases directly into their application, which
    is not written in PHP. I then realized how important it is to have some sort of
    a common language that we can use to understand the intended behavior of a system
    that is programming-language agnostic!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents how useful the Gherkin language is in being
    a platform-agnostic, intermediary language to represent how the intended software
    solution should behave:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Gherkin features and scenarios](img/Figure_6.11_B18318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Gherkin features and scenarios
  prefs: []
  type: TYPE_NORMAL
- en: By using a common language to define the intended features and scenarios in
    a project, we can easily coordinate with different teams that do not do any software
    programming at all. This is very important for a business. People across different
    teams will be able to collaborate and understand each other easier and quicker,
    and by doing so, the developers can also be more confident and certain that what
    they are building is correct. It might sound ridiculous, but I’ve seen a lot of
    projects go wrong simply because of a breakdown in communication between different
    teams in a business.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we defined and explained what BDD is and why we need it. By
    implementing BDD, we will be able to develop our solutions better to properly
    address the actual business goal. We can start defining these business goals using
    features and scenarios, written in the Gherkin language, which is just plain English.
    By doing so, different people from different teams in the company will be able
    to coordinate and understand each other better in defining the system’s intended
    behavior. This will help bridge the gap and language barrier between different
    teams.
  prefs: []
  type: TYPE_NORMAL
- en: We created a feature and a scenario, then used Behat, Mink, and Goutte to define
    the intended system behavior, open a headless browser, visit the web application,
    and verify the content of the home page.
  prefs: []
  type: TYPE_NORMAL
- en: This is just the tip of the BDD iceberg. In the next chapter, we will start
    writing solution code while making sure that our code is maintainable and testable
    by using BDD and TDD together.
  prefs: []
  type: TYPE_NORMAL
