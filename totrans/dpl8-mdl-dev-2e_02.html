<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating Your First Module</h1>
                </header>
            
            <article>
                
<p>Now that we have covered some of the introductory aspects of Drupal 8 module development, it's time to dive right into the meat of what we are doing here—module creation.</p>
<p><span class="packtscreen">Here are some of the important topics that we will cover in this chapter:</span></p>
<ul>
<li>Creating a new Drupal 8 module—the files that are necessary to get started</li>
<li>Creating a route and controller</li>
<li>Creating and using a service</li>
<li>Creating a form</li>
<li>Creating a custom block</li>
<li>Working with links</li>
<li>Using the Event Dispatcher</li>
</ul>
<p>Concretely, in this chapter, we will create a new custom module called <em>Hello World</em>. In this module, we will define a route that maps to a Controller and that outputs the age-old programming message. So, this will be our first win.</p>
<p>Next, we will define a service that our Controller will use to pimp up our message. After all, we don't want the same message presented to the user all day long. This simple example, however, will illustrate what services are and how to interact with the Service Container in order to make use of them.</p>
<p>Then, we will create a form where an administrator will be able to override the message shown on our page. It will be stored in configuration, and we will alter our service to make use of that configuration. The key takeaway here will be the use of the Form API. However, we will also discuss how to store some basic configuration values and add dependencies to our existing services.</p>
<p>Finally, we want to become a bit more flexible. Why should users only be greeted on a specific page? We will create a custom block that can be placed anywhere on the site and will display the same message. Here, we will see how block plugins are defined and how they can expose their own configuration forms to be more flexible.</p>
<p>Although not strictly related to our <em>Hello World</em> example, we will also look at how to work with links programmatically in Drupal 8. It's a very common task any Drupal 8 developer needs to do very often. Moreover, we will also look at using the Event Dispatcher component and, more importantly, subscribing to events. We'll illustrate this with a fairly common example of when you'd need to do this—performing redirects from incoming requests.</p>
<p>By the end of this chapter, you should have the foundational knowledge necessary to build your own module from scratch. Moreover, you should be able to understand and implement some of the most commonly used techniques in Drupal 8 module development.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a module</h1>
                </header>
            
            <article>
                
<p>Creating a simple Drupal 8 module is not difficult. You only need one file to get it recognized by the core installation and to be able to enable it. In this state, it won't do much, but it will be installable. Let's first take a look at how to do this, and then we will progressively add meat to it in order to achieve the goals set out at the beginning of the chapter.</p>
<p>Custom Drupal 8 modules typically belong inside the <kbd>/custom</kbd> directory of the <kbd>/modules</kbd> folder found inside the root Drupal installation. You would put contributed modules inside a <kbd>/contrib</kbd> directory instead, in order to have a clear distinction. This is a standard practice, so that is where we will place our custom module, called <em>Hello World</em>.</p>
<p>We will start by creating a folder called <kbd>hello_world</kbd>. This will also be the module's machine name used in many other places. Inside, we will need to create an <em>info</em> file that describes our module. This file is named <kbd>hello_world.info.yml</kbd>. This naming structure is important—first, the module name, then <kbd>info</kbd>, followed by the <kbd>.yml</kbd> extension. You will hear this file often referred to as the module's <kbd>info</kbd> file (due to it having had the <kbd>.info</kbd> extension in past versions of Drupal).</p>
<p>Inside this file, we will need to add some minimal information that describes our module. We will go with something like this:</p>
<pre>name: Hello World<br/>description: Hello World module<br/>type: module<br/>core: 8.x<br/>package: Custom</pre>
<p>Some of this is self-explanatory, but let's see what these lines mean:</p>
<ul>
<li>The first two represent the human-readable name and description of the module.</li>
<li>The <kbd>type</kbd> key means that this is a module <em>info</em> file rather than a theme. In Drupal 8, this has become mandatory.</li>
<li>The <kbd>core</kbd> key specifies that this module works with version 8 of Drupal, and it won't be installable on previous or future versions.</li>
<li>Finally, we place this in a generic <kbd>Custom</kbd> package so that it gets categorized in this group on the modules' administration screen.</li>
</ul>
<p>That is pretty much it. The module can now be enabled either through the UI at <kbd>/admin/modules</kbd> or via Drush using the <kbd>drush en hello_world</kbd> command.</p>
<p>Before we move on, let's see what other options you can add (and probably will need to add at some point or another) to the info file:</p>
<p><em>Module dependencies</em>: If your module depends on other modules, you can specify this in its info file like so:</p>
<pre>dependencies:<br/>  - drupal:views<br/>  - ctools:ctools</pre>
<p>The dependencies should be named in the <kbd>project:module</kbd> format, where <kbd>project</kbd> is the project name as it appears in the URL of the project on Drupal.org and <kbd>module</kbd> is the machine name of the module. You can even include version restrictions, for example, <kbd>ctools:ctools (&gt;=8.x-3.x)</kbd>.</p>
<p><em>Configuration:</em> If your module has a general configuration form that centralizes the configuration options of the module, you can specify the route of that form in the info file. Doing so will add a link to that form on the <kbd>admin/modules</kbd> UI page where modules are being installed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Your first hook implementation</h1>
                </header>
            
            <article>
                
<p>The module as it stands doesn't do much. In fact, it does nothing. However, do pat yourself on the back, as you have created your first Drupal 8 module. Before we move on to the interesting stuff we planned out, let's implement our first hook responsible for providing some helpful information about our module.</p>
<p>As we hinted at in the first chapter, when Drupal encounters an event for which there is a hook (and there are hundreds of such events), it will look through all of the modules for matching hook implementations. Now, how does it find the matching implementations? It looks for the functions that are named in the <kbd>module_name_hook_name</kbd> format, where <kbd>hook_name</kbd> is replaced by the name of the hook being implemented. The name of a hook is whatever comes after <kbd>hook_</kbd>. We will see an example below when we implement <kbd>hook_help()</kbd>. However, once it finds the implementations, it will then execute each of them, one after another. Once all hook implementations have been executed, Drupal will continue its processing.</p>
<p>Depending on the module size, it's recommended that you place all your hook implementations inside a <kbd>.module</kbd> file. There will be cases, however, when you'll organize them in other files, either by including those files inside the <kbd>.module</kbd> file yourself or by using specific file naming conventions that gets them included by Drupal. However, for now, we stick with the default.</p>
<p>So, let's create a <kbd>.module</kbd> file in our module folder called <kbd>hello_world.module</kbd> and place an opening PHP tag at the top. Then, we can have the following <kbd>hook_help()</kbd> implementation inside (and typically all other hook implementations):</p>
<pre><span>use </span><span>Drupal\Core\Routing\RouteMatchInterface</span><span>;<br/></span><span><br/></span><span>/**<br/></span><span> * Implements hook_help().<br/></span><span> */<br/></span><span>function </span><span>hello_world_help(</span><span>$route_name</span><span>, </span><span>RouteMatchInterface </span><span>$route_match</span><span>) {<br/></span><span>  </span><span>switch </span><span>(</span><span>$route_name</span><span>) {<br/></span><span>    </span><span>case </span><span>'help.page.hello_world'</span><span>:<br/></span><span>      </span><span>$output </span><span>= </span><span>''</span><span>;<br/></span><span>      </span><span>$output </span><span>.= </span><span>'&lt;h3&gt;' </span><span>. t(</span><span>'About'</span><span>) . </span><span>'&lt;/h3&gt;'</span><span>;<br/></span><span>      </span><span>$output </span><span>.= </span><span>'&lt;p&gt;' </span><span>. t(</span><span>'This is an example module.'</span><span>) . </span><span>'&lt;/p&gt;'</span><span>;<br/></span><span>      </span><span>return </span><span>$output</span><span>;<br/></span><span><br/></span><span>    </span><span>default</span><span>:<br/></span><span>  }<br/></span><span>}</span></pre>
<p>As you can see, the name of the function respects the abovementioned format—<kbd>module_name_hook_name</kbd>—because we are implementing <kbd>hook_help</kbd>. So, we replaced <kbd>hook</kbd> with the module name and <kbd>hook_name</kbd> with <kbd>help</kbd>. Moreover, this particular hook takes two parameters that we can use inside it; though, in our case, we only use one, that is, the route name.</p>
<p>The purpose of this hook is to provide Drupal some help text about what this module does. You won't always implement this hook, but it's good to be aware of it. The way it works is that each new module receives its own route inside the main module, where users can browse this info—ours is <kbd>help.page.hello_world</kbd>. So, in this implementation, we will tell Drupal (and, more specifically, the core <kbd>Help</kbd> module) the following: if a user is looking at our module's help route (page), show the info contained in the <kbd>$output</kbd> variable. And that's pretty much it.</p>
<p>According to the Drupal coding standards, the DocBlock message above the hook implementation needs to stay short and concise, as in the preceding example. We do not generally document anything further for Drupal core hooks or popular <kbd>contrib</kbd> module hooks because they should be documented elsewhere. If, however, you are implementing a custom hook defined in one of your modules, it's okay to add a second paragraph describing what it does.</p>
<p>Users can now reach this page from the module administration page by clicking on the <span class="packt_screen">Help</span> link for each individual module that has this hook implemented. Easy, right?</p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/6be3b4cd-9dc3-4b8b-8271-ea4a4a415267.png" style="width:13.00em;height:9.75em;"/></p>
<p>Even though we are not really providing any useful info through this hook, implementing it helped us understand how hooks work and what the naming convention is for using them. Additionally, we saw an example of a traditional (procedural) Drupal extension point that module developers can use. In doing so, we literally extended the capability of the <span class="packt_screen">Help</span> module by allowing it to give more info to users.</p>
<p>Now, let's move on to creating something of our own.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Route and controller</h1>
                </header>
            
            <article>
                
<p>The first real piece of functionality we set out to create was a simple Drupal page that outputs the age-old <em>Hello World</em> string. To do this, we will need two things—a route and a controller. So, let's start with the first one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The route</h1>
                </header>
            
            <article>
                
<p>Inside our module, we will need to create our routing file that will hold all our statically defined routes. The name of this file will be <kbd>hello_world.routing.yml</kbd>. By now, I assume that you understand what the deal is with the file naming conventions in a Drupal 8 module. However, in any case, this is another YAML file in which we will need to put the YAML formatted data:</p>
<pre><span>hello_world.hello:<br/></span><span>  path: </span><span>'/hello'<br/></span><span>  </span><span>defaults:<br/></span><span>    _controller: </span><span>'\Drupal\hello_world\Controller\HelloWorldController::helloWorld'<br/></span><span>    </span><span>_title: </span><span>'Our first route'<br/></span><span>  </span><span>requirements:<br/></span><span>    _permission: </span><span>'access content'</span></pre>
<p>This is our first route definition. It starts with the route name (<kbd>hello_world.hello</kbd>), followed by all the necessary info about it, underneath, in a YAML-formatted multidimensional array. The standard practice is to have the route name start with the module name it is in, followed by route qualifiers as needed.</p>
<p>So, what does the route definition contain? There can be many options here but, for now, we will stick with the simple ones that serve our purpose.</p>
<div class="packt_infobox">For more info about all route configuration options, visit the relevant documentation page at<span class="URLPACKT"><a href="https://www.drupal.org/docs/8/api/routing-system/structure-of-routes"> https://www.drupal.org/docs/8/api/routing-system/structure-of-routes</a>.</span> It is a good resource to keep on hand.</div>
<p>First, we have a path key, which indicates the path we want this route to work on. Then, we have a <kbd>defaults</kbd> section, which usually contains info relevant to the handlers responsible for delivering something when this route is accessed. In our case, we set the controller and method responsible for delivering the page, as well as its title. Finally, we have a <kbd>requirements</kbd> section, which usually has to do with conditions that need to be met for this route to be accessible (or be hit)—things such as permissions and format. In our case, we will require users to have the <kbd>access content</kbd> permission, which most visitors will have. Don't worry<span><span>;</span></span> we will cover more about access in a later chapter.</p>
<p>That is all we need for our first route definition. Now, we will need to create the Controller that maps to it and can deliver something to the user.</p>
<p>Before we do that, let's look at an example of a very common routing requirement you will most likely have to use really soon. We don't need this for the functionality we're building in this chapter, so I won't include it in the final code. However, it's important that you know how this works.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Route variables</h1>
                </header>
            
            <article>
                
<p>A very common requirement is to have a variable route parameter (or more) that gets used by the code that maps to the route, for example, the ID or path alias of the page you want to show. These parameters can be added by wrapping a certain path element into curly braces, like so:</p>
<pre>path: '/hello/{param}' </pre>
<p>Here, <kbd>{param}</kbd> will map to a <kbd>$param</kbd> variable that gets passed as an argument to the controller or handler responsible for this route. So, if the user goes to the <kbd>hello/jack</kbd> path, the <kbd>$param</kbd> variable will have the <kbd>jack</kbd> value and the controller can use that.</p>
<p>Additionally, Drupal 8 comes with parameter converters that transform the parameter into something more meaningful. For example, an entity can be autoloaded and passed to the Controller directly instead of an ID. Also, if no entity is found, the route acts as a 404, saving us a few good lines of code. To achieve this, we will also need to describe the parameter so that Drupal knows how to autoload it. We can do so by adding a route option for that parameter:</p>
<pre>options:<br/>   parameters:<br/>     param:<br/>       type: entity:node</pre>
<p>So, we have now mapped the <kbd>{param}</kbd> parameter to the node entity type. Hence, if the user goes to <kbd>hello/1</kbd>, the node with the ID of 1 will be loaded (if it exists).</p>
<p>We can do one better. If, instead of <kbd>{param},</kbd>we name the parameter <kbd>{node}</kbd> (the machine name of the entity type), we can avoid having to write the parameters option in the route completely. Drupal will figure out that it is an entity and will try to load that node by itself. Neat, no?</p>
<p>So keep these things in mind the next time you need to write dynamic routes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Namespaces</h1>
                </header>
            
            <article>
                
<p>Before moving on with the Controller we set out to write, let's break down the namespace situation in Drupal 8 and how the folder structure needs to be inside a module.</p>
<p>Drupal 8 uses the PSR-4 namespace autoloading standard. In effect, this means that the namespace of all Drupal core and module classes starts with <kbd>\Drupal</kbd>. For modules, the base namespace is <kbd>\Drupal\module_name</kbd>, where <kbd>module_name</kbd> is the machine name of the module. This then maps to the <kbd>/src</kbd> folder found inside the module directory (for main integration files). For PHPUnit tests, we have a different namespace, as we will see later in the book.</p>
<p>So essentially, we will need a <kbd>/src</kbd> folder inside our module to place all of our classes that need to be autoloaded. So, we can go ahead and create it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Controller</h1>
                </header>
            
            <article>
                
<p>Now that we have found out more or less where we have to place our Controller, let's begin by creating a <kbd>Controller</kbd> folder inside our module's <kbd>/src</kbd> folder. Although not mandatory, this is a standard practice for Controller placement. Inside this folder, we can have our first Controller class file: <kbd>HelloWorldController.php</kbd>.</p>
<p>Inside the file, we again have something simple (after the opening PHP tags):</p>
<pre><span>namespace </span><span>Drupal\hello_world\Controller</span><span>;<br/></span><span><br/></span><span>use </span><span>Drupal\Core\Controller\ControllerBase</span><span>;<br/></span><span><br/></span><span>/**<br/></span><span> * Controller for the salutation message.<br/></span><span> */<br/></span><span>class </span><span>HelloWorldController </span><span>extends </span><span>ControllerBase {<br/></span><span><br/></span><span>  </span><span>/**<br/></span><span>   * Hello World.<br/></span><span>   *<br/></span><span>   * </span><span>@return </span><span>array<br/></span><span>   */<br/></span><span>  </span><span>public function </span><span>helloWorld</span><span>() {<br/></span><span>    </span><span>return </span><span>[<br/></span><span>      </span><span>'#markup' </span><span>=&gt; </span><span>$this</span><span>-&gt;</span><span>t</span><span>(</span><span>'Hello World'</span><span>)<br/></span><span>    ]</span><span>;<br/></span><span>  </span><span>}</span><span><br/></span><span>}</span></pre>
<p>As expected, we start with the namespace declaration. If you read the preceding section, the namespace choice will make sense. Then, we have our Controller class that extends the Drupal 8 <kbd>ControllerBase</kbd>, which happens to provide some helper tools (such as the <kbd>StringTranslationTrait</kbd>, which I will explain later in the book when we talk about languages). If you remember our route definition, we have a <kbd>helloWorld</kbd> method that returns an array.</p>
<p>If you've worked with previous versions of Drupal, this array (called a <em>render array</em>) will be familiar. Otherwise, what you need to know right now is that we are returning simple markup with the <kbd>Hello World</kbd> text wrapped in the translation service I hinted at in the previous paragraph. After the Controller returns this array, there will be an <kbd>EventSubscriber</kbd> that takes this array, runs it through the Drupal theme layer, and returns the HTML page as a response. The actual content returned in the Controller will be wrapped in the <kbd>Main page content</kbd> block that is usually placed in the main content region of the theme.</p>
<p>Now, our simple Controller is done. If we clear the cache and go to <kbd>/hello</kbd>, we should encounter a new page that outputs the <span class="packt_screen">Our first route</span> title and the <span class="packt_screen">Hello World</span> content. Success!</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5100e2d4-a562-4d97-8534-5a6bd99b6e26.png" style="width:29.92em;height:22.42em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Services</h1>
                </header>
            
            <article>
                
<p>Why don't I like this approach?</p>
<p>I don't want the Controller making decisions on how to greet my users. First of all, because Controllers need to stay lean. I want my users to be greeted a bit more dynamically, depending on the time of day, and that will increase the complexity. Second of all, maybe I will want this greeting to be done elsewhere as well, and there is no way I am copying and pasting this logic somewhere else, nor am I going to misuse the Controller just to be able to call that method. The solution? We delegate the logic of constructing the greeting to a service and use that service in our Controller to output the greeting.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is a service?</h1>
                </header>
            
            <article>
                
<p>A service is an object that gets instantiated by a Service Container and is used to handle operations in a reusable way, for example, performing calculations and interacting with the database, an external API, or any number of things. Moreover, it can take dependencies (other services) and use them to help out. Services are a core part of the <strong>dependency injection</strong> (<strong>DI</strong>) principle that is commonly used in modern PHP applications and in Drupal 8.</p>
<p>If you don't have any experience with these concepts, an important thing to note is also that they are globally registered with the service container and instantiated only once per request. This means that altering them after you requested them from the container means that they stay altered even if you request them again. In essence, they are singletons. So, you should write your services in such a way that they stay immutable, and most of the data they need to process is either from a dependency or passed in from the client that uses it (and does not affect it).</p>
<div class="packt_tip">Many Drupal 8 core service definitions can be found inside the <kbd>core.services.yml</kbd> file located in the root <kbd>/core</kbd> folder. So, if you are ever looking for service names to use, your best bet is to look there. Additionally, core modules also have service definitions inside their respective <kbd>*.services.yml</kbd> files. So, make sure that you also check there.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The HelloWorldSalutation service</h1>
                </header>
            
            <article>
                
<p>Now that we have a general idea as to what a service is, let's create one to see all this in practice.</p>
<p>As I mentioned earlier, I want my greetings to be more dynamic, that is, I want the salutation to depend on the time of day. So, we will create a (<kbd>HelloWorldSalutation</kbd>) class that is responsible for doing that and place it in the <kbd>/src</kbd> folder (our module's namespace root in a file naturally called <kbd>HelloWorldSalutation.php</kbd>):</p>
<pre><span>namespace </span><span>Drupal\hello_world</span><span>;<br/></span><span><br/></span><span>use </span><span>Drupal\Core\StringTranslation\StringTranslationTrait</span><span>;<br/></span><span><br/></span><span>/**<br/></span><span> * Prepares the salutation to the world.<br/></span><span> */<br/></span><span>class </span><span>HelloWorldSalutation {<br/></span><span><br/></span><span>  </span><span>use </span><span>StringTranslationTrait</span><span>;<br/></span><span><br/></span><span>  </span><span>/**<br/></span><span>   * Returns the salutation<br/></span><span>   */<br/></span><span>  </span><span>public function </span><span>getSalutation</span><span>() {<br/></span><span>    </span><span>$time </span><span>= </span><span>new </span><span>\DateTime()</span><span>;<br/></span><span>    </span><span>if </span><span>((int) </span><span>$time</span><span>-&gt;</span><span>format</span><span>(</span><span>'G'</span><span>) &gt;= </span><span>00 </span><span>&amp;&amp; (int) </span><span>$time</span><span>-&gt;</span><span>format</span><span>(</span><span>'G'</span><span>) &lt; </span><span>12</span><span>) {<br/></span><span>      </span><span>return </span><span>$this</span><span>-&gt;</span><span>t</span><span>(</span><span>'Good morning world'</span><span>)</span><span>;<br/></span><span>    </span><span>}<br/></span><span><br/></span><span>    </span><span>if </span><span>((int) </span><span>$time</span><span>-&gt;</span><span>format</span><span>(</span><span>'G'</span><span>) &gt;= </span><span>12 </span><span>&amp;&amp; (int) </span><span>$time</span><span>-&gt;</span><span>format</span><span>(</span><span>'G'</span><span>) &lt; </span><span>18</span><span>) {<br/></span><span>      </span><span>return </span><span>$this</span><span>-&gt;</span><span>t</span><span>(</span><span>'Good afternoon world'</span><span>)</span><span>;<br/></span><span>    </span><span>}<br/></span><span><br/></span><span>    </span><span>if </span><span>((int) </span><span>$time</span><span>-&gt;</span><span>format</span><span>(</span><span>'G'</span><span>) &gt;= </span><span>18</span><span>) {<br/></span><span>      </span><span>return </span><span>$this</span><span>-&gt;</span><span>t</span><span>(</span><span>'Good evening world'</span><span>)</span><span>;<br/></span><span>    </span><span>}<br/></span><span>  }<br/></span><span>}</span></pre>
<div class="packt_infobox">From now on I will not always mention the file name a particular class goes into. So you can safely assume one file per class, named after the class itself.</div>
<p>By now, I assume that the namespace business is clear, so I won't explain it again. Let's see what else we did here. First, we used the <kbd>StringTranslationTrait</kbd> in order to expose the translation function (I will explain this later on). Second, we created a rudimentary method that returns a different greeting depending on the time of day. This could probably have been done better, but for the purposes of this example, it works just fine.</p>
<div class="packt_tip">In this example I used the native PHP function <kbd>time()</kbd> to get the current time. And that's ok. But you should know that Drupal has its very own <kbd>Drupal\Component\Datetime\Time</kbd> service that we can use to get the current time. It also has additional methods for requesting time specific information, so make sure you check it out and use when appropriate.</div>
<p>Now that we have our class, it's time to define it as a service. We don't want to be going <kbd>new HelloWorldSalutation()</kbd> all over our code base, but instead, register it with the Service Container and use it from there as a dependency. How do we do that?</p>
<p>First, we will need, yet again, a <kbd>YAML</kbd> file: <kbd>hello_world.services.yml</kbd>. This file starts with the <kbd>services</kbd> key, under which will be all the service definitions of our module. So, our file will look like this (for now):</p>
<pre>services:<br/>  hello_world.salutation:<br/>    class: Drupal\hello_world\HelloWorldSalutation</pre>
<p>This is the simplest possible service definition you can have. You give it a name (<kbd>hello_world.salutation</kbd>) and map it to a class to be instantiated. It is a standard practice to have the service name start with your module name.</p>
<p>Once we clear the cache, the service will get registered with the Service Container and will be available to use.</p>
<div class="packt_tip">If there is any reason to believe that you will have more than one salutation service, you should create an interface this class can implement. This way, you'll be able to always type hint that interface instead of the class and make the implementations swappable.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tagged services</h1>
                </header>
            
            <article>
                
<p>Service definitions can also be tagged in order to inform the container if they serve a specific purpose. Typically, these are picked up by a collector service that uses them for a given subsystem. As an example, if we wanted to tag the <kbd>hello_world.salutation</kbd> service, it would look something this:</p>
<pre>hello_world.salutation:<br/>  class: Drupal\hello_world\HelloWorldSalutation<br/>  tags:<br/>    - {name: tag_name}</pre>
<p>Tags can also get a priority, as we will see in some examples later in this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using services in Drupal 8</h1>
                </header>
            
            <article>
                
<p>Before we go and use our service in the Controller we created, let's take a breather and run through the ways you can make use of services once they are registered.</p>
<p>There are essentially two ways—statically and injected. The first is done by a static call to the Service Container, whereas the second uses dependency injection to pass the object through the constructor (or in some rare cases, a setter method). However, let's check out how, why, and what is the real difference.</p>
<p>Statically, you would use the global <kbd>Drupal</kbd> class to instantiate a service:</p>
<pre>$service = \Drupal::service('hello_world.salutation');  </pre>
<p>This is how we use services in the <kbd>.module</kbd> files and classes which are not exposed to the Service Container and into which we cannot inject. Instances of the latter are rare though, most of the time we use the static calls only from within static contexts.</p>
<p>A few popular services also have shorthand methods on the <kbd>\Drupal</kbd> class: for example, <kbd>\Drupal::entityTypeManager().</kbd> I recommend that you inspect the <kbd>\Drupal</kbd> class and take a look at the ones with shorthand methods available.</p>
<p>It is not best practice and, for me, it is personally unacceptable to use the static method of service instantiation inside a Controller, service, plugin or any other class where dependency injection is an option. The reason is that it defeats much of the purpose of using a service, as it couples the two, making it a nightmare to test. Inside hook implementations and other Drupal-specific procedural code, on the other hand, we have no choice, and it is normal to do so.</p>
<div class="packt_infobox">Just because a code is inside a <kbd>.module</kbd> file, it doesn't mean that it should be there. In general, these modules should only contain things such as hook implementations or any other implementations that require a certain naming convention to be respected. They should also be lean and have their work delegated to services.</div>
<p>The proper way to use services is to inject them where needed. Admittedly, this approach is a bit more time-consuming but, as you progress, it will become second nature. Also, since there are a few different ways to inject dependencies (based on the receiver), we will not cover them here. Instead, we will see how they work throughout this book, at the right time. We will take a look at a very important example right now in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Injecting the service into our Controller</h1>
                </header>
            
            <article>
                
<p>Let's now continue with our module and take a look at how to inject the newly created service into our Controller.</p>
<p>We will need to add some code to the Controller (typically at the beginning of the class so that we can immediately identify the presence of this code when looking at it):</p>
<pre><span>/**<br/></span><span> * </span><span>@var </span><span>\Drupal\hello_world\HelloWorldSalutation<br/></span><span> */<br/></span><span>protected </span><span>$salutation</span><span>;<br/></span><span><br/></span><span>/**<br/></span><span> * HelloWorldController constructor.<br/></span><span> *<br/></span><span> * </span><span>@param </span><span>\Drupal\hello_world\HelloWorldSalutation $salutation<br/></span><span> */<br/></span><span>public function </span><span>__construct</span><span>(HelloWorldSalutation </span><span>$salutation</span><span>) {<br/></span><span>  </span><span>$this</span><span>-&gt;</span><span>salutation </span><span>= </span><span>$salutation</span><span>;<br/></span><span>}<br/></span><span><br/></span><span>/**<br/></span><span> * {</span><span>@inheritdoc</span><span>}<br/></span><span> */<br/></span><span>public static function </span><span>create</span><span>(ContainerInterface </span><span>$container</span><span>) {<br/></span><span>  </span><span>return new static</span><span>(<br/></span><span>    </span><span>$container</span><span>-&gt;</span><span>get</span><span>(</span><span>'hello_world.salutation'</span><span>)<br/></span><span>  )</span><span>;<br/></span><span>}</span></pre>
<p>In addition to this, ensure that you include the relevant <em>use</em> statements at the top of the file:</p>
<pre>use Drupal\hello_world\HelloWorldSalutation;<br/>use Symfony\Component\DependencyInjection\ContainerInterface;</pre>
<p>So, what is going on here? First, we give the Controller a constructor method, which takes our service as an argument and stores it as a property. For me, this is usually the very first method in the class. But how does this constructor get its argument? It gets it via the <kbd>create()</kbd> method, which receives the Service Container as a parameter and is free to choose the service(s) needed by the Controller constructor. This is usually my second method in a class. I prefer this order because it's very easy to check whether they are present. Also, their presence is important, especially when inheriting and observing what the parent is injecting.</p>
<p>OK, but how does this injection business work in reality?</p>
<p>In a nutshell, after the route is found and the responsible Controller is resolved, a check is made to see whether the latter implements <kbd>ContainerInjectionInterface</kbd>. Our Controller does so via its parent <kbd>ControllerBase</kbd>. If it does, the Controller gets instantiated via the <kbd>create()</kbd> method and the container is passed to it. From there, it is responsible for creating a new static version of itself with the required services from the container—not that complicated, really!</p>
<p>The <kbd>create()</kbd> method is a staple practice in the Drupal 8 dependency injection pattern, so you will see it quite a lot. However, one thing to keep in mind is that you should never pass the entire container to the class you instantiate with it because you are no longer doing dependency injection then.</p>
<p>A note about <kbd>ControllerBase</kbd>, which we are extending—it is a standard practice to extend it. It provides some nice traits, implements interfaces that are required and shows what the class purpose is immediately. However, from the point of view of dependency injection, I advise against using the helper methods that return services (for example, <kbd>entityTypeManager()</kbd>). They, unfortunately, load services statically, which is not the best practice in this case. You should instead inject them yourself, as we did just now.</p>
<p>Okay, let's turn back to our example. Now that we have the service injected, we can use it to render the dynamic salutation:</p>
<pre><span>return </span><span>[<br/></span><span>  </span><span>'#markup' </span><span>=&gt; </span><span>$this</span><span>-&gt;</span><span>salutation</span><span>-&gt;</span><span>getSalutation</span><span>()</span><span>,<br/></span><span>]</span><span>;</span></pre>
<p>There we have it. Now, our greeting is dependent on the time of day and our Controller is dependent on our salutation service.</p>
<p>One thing I would like to specify about our example is that I disregarded caching for the sake of simplicity. With the cache turned on, the page would be cached and served with potentially the wrong salutation. However, in <a href="13739cad-2542-40b4-ae42-9a7f9e159716.xhtml">Chapter 11</a>, <em>Caching</em>, we will cover all these intricacies, so there is no point in complicating our example now.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Invoked Controllers</h1>
                </header>
            
            <article>
                
<p>Now that we know what routes, Controllers and services are, I'd also like to quickly note that Controllers can be defined as services and <em>invoked</em> by the routing system. In other words, just as we defined our <kbd>hello_world.salutation</kbd> service, we could define another one that would act as a Controller and reference that service ID in the routing file instead of the fully qualified class name. Then, in order for Drupal to know which method inside the service to call when a user accesses the route, we would need to implement the magic <kbd>__invoke</kbd> method inside the service. And the rest would work pretty much in the same way.</p>
<p>This capability was introduced in Drupal 8.7 and is typical to the <span class="MsoHyperlink"><a href="https://en.wikipedia.org/wiki/Action%E2%80%93domain%E2%80%93responder">Action-Domain-Responder</a></span> architectural pattern. We won't use it going forward but it's good to know that it's available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The form</h1>
                </header>
            
            <article>
                
<p>Our page displays a greeting dynamically, depending on the time of day. However, we now want an administrator to specify what the greeting should actually be, in other words, to override the default behavior of our salutation if they so choose.</p>
<p>The ingredients for achieving this will be as follows:</p>
<ul>
<li>A route (a new page) that displays a form where the administrator can set the greeting</li>
<li>A configuration object that will store the greeting</li>
</ul>
<p>In building this functionality, we will also take a look at how to add a dependency to our existing service. So, let's get started with our new route that naturally goes inside the <kbd>hello_world.routing.yml</kbd> file we already created:</p>
<pre><span>hello_world.greeting_form:<br/></span><span>  path: </span><span>'/admin/config/salutation-configuration'<br/></span><span>  </span><span>defaults:<br/></span><span>    _form: </span><span>'\Drupal\hello_world\Form\SalutationConfigurationForm'<br/></span><span>    </span><span>_title: </span><span>'Salutation configuration'<br/></span><span>  </span><span>requirements:<br/></span><span>    _permission: </span><span>'administer site configuration'</span></pre>
<p>Most of this route definition is the same as we saw earlier. There is one change, though, in that it maps to a form instead of a Controller. This means that the entire page is a form page. Also, since the path is within the administration space, it will use the administration theme of the site. What is left to do now is to create our form class inside the <kbd>/Form</kbd> folder of our namespace (a standard practice directory for storing forms, but not mandatory).</p>
<p>Due to the power of inheritance, our form is actually very simple. However, I will explain what goes on in the background and guide you on your path to building more complex forms. So, here we have our form:</p>
<pre><span>namespace </span><span>Drupal\hello_world\Form</span><span>;<br/></span><span><br/></span><span>use </span><span>Drupal\Core\Form\ConfigFormBase</span><span>;<br/></span><span>use </span><span>Drupal\Core\Form\FormStateInterface</span><span>;<br/></span><span><br/></span><span>/**<br/></span><span> * Configuration form definition for the salutation message.<br/></span><span> */<br/></span><span>class </span><span>SalutationConfigurationForm </span><span>extends </span><span>ConfigFormBase {<br/></span><span><br/></span><span>  </span><span>/**<br/></span><span>   * {</span><span>@inheritdoc</span><span>}<br/></span><span>   */<br/></span><span>  </span><span>protected function </span><span>getEditableConfigNames</span><span>() {<br/></span><span>    </span><span>return </span><span>[</span><span>'hello_world.custom_salutation'</span><span>]</span><span>;<br/></span><span>  </span><span>}<br/></span><span><br/></span><span>  </span><span>/**<br/></span><span>   * {</span><span>@inheritdoc</span><span>}<br/></span><span>   */<br/></span><span>  </span><span>public function </span><span>getFormId</span><span>() {<br/></span><span>    </span><span>return </span><span>'salutation_configuration_form'</span><span>;<br/></span><span>  </span><span>}<br/></span><span><br/></span><span>  </span><span>/**<br/></span><span>   * {</span><span>@inheritdoc</span><span>}<br/></span><span>   */<br/></span><span>  </span><span>public function </span><span>buildForm</span><span>(</span><span>array </span><span>$form</span><span>, </span><span>FormStateInterface </span><span>$form_state</span><span>) {<br/></span><span>    </span><span>$config </span><span>= </span><span>$this</span><span>-&gt;</span><span>config</span><span>(</span><span>'hello_world.custom_salutation'</span><span>)</span><span>;<br/></span><span><br/></span><span>    </span><span>$form</span><span>[</span><span>'salutation'</span><span>] = </span><span>array</span><span>(<br/></span><span>      </span><span>'#type' </span><span>=&gt; </span><span>'textfield'</span><span>,<br/></span><span>      </span><span>'#title' </span><span>=&gt; </span><span>$this</span><span>-&gt;</span><span>t</span><span>(</span><span>'Salutation'</span><span>)</span><span>,<br/></span><span>      </span><span>'#description' </span><span>=&gt; </span><span>$this</span><span>-&gt;</span><span>t</span><span>(</span><span>'Please provide the salutation you want to use.'</span><span>)</span><span>,<br/></span><span>      </span><span>'#default_value' </span><span>=&gt; </span><span>$config</span><span>-&gt;</span><span>get</span><span>(</span><span>'salutation'</span><span>)</span><span>,<br/></span><span>    </span><span>)</span><span>;<br/></span><span><br/></span><span>    </span><span>return parent</span><span>::</span><span>buildForm</span><span>(</span><span>$form</span><span>, </span><span>$form_state</span><span>)</span><span>;<br/></span><span>  </span><span>}<br/></span><span><br/></span><span>  </span><span>/**<br/></span><span>   * {</span><span>@inheritdoc</span><span>}<br/></span><span>   */<br/></span><span>  </span><span>public function </span><span>submitForm</span><span>(</span><span>array </span><span>&amp;</span><span>$form</span><span>, </span><span>FormStateInterface </span><span>$form_state</span><span>) {<br/></span><span>    </span><span>$this</span><span>-&gt;</span><span>config</span><span>(</span><span>'hello_world.custom_salutation'</span><span>)<br/></span><span>      -&gt;</span><span>set</span><span>(</span><span>'salutation'</span><span>, </span><span>$form_state</span><span>-&gt;</span><span>getValue</span><span>(</span><span>'salutation'</span><span>))<br/></span><span>      -&gt;</span><span>save</span><span>()</span><span>;<br/></span><span><br/></span><span>    </span><span>parent</span><span>::</span><span>submitForm</span><span>(</span><span>$form</span><span>, </span><span>$form_state</span><span>)</span><span>;<br/></span><span>  </span><span>}<br/></span><span>}</span></pre>
<p>Before going into the explanation, I should say that this is it. Clearing the cache and navigating to <kbd>admin/config/salutation-configuration</kbd> will present you with your simple configuration form via which you can save a custom salutation message:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/71e94a82-012c-4c2b-9ff4-1cfbbb448185.png" style="width:21.42em;height:14.00em;"/></p>
<p>Later on, we will make use of that value. However, first, let's talk a bit about forms in general, and then this form in particular.</p>
<p>A form in Drupal 8 is represented by a class that implements <kbd>FormInterface</kbd>. Typically, we either extend from <kbd>FormBase</kbd> or from <kbd>ConfigFormBase</kbd>, depending on what its purpose is. In this case, we created a configuration form so we extended from the latter class.</p>
<p>There are four main methods that come into play in this interface:</p>
<ul>
<li><kbd>getFormId()</kbd>: Returns a unique, machine-readable name for the form.</li>
<li><kbd>buildForm()</kbd>: Returns the form definition (an array of form element definitions and some extra metadata, as needed).</li>
</ul>
<ul>
<li><kbd>validateForm()</kbd>: The handler that gets called to validate the form submission. It receives the form definition and a <kbd>$form_state</kbd> object that contains, among others, the submitted values. You can flag invalid values on their respective form elements, which means that the form is not submitted but refreshed (with the offending elements highlighted).</li>
<li><kbd>submitForm()</kbd>: The handler that gets called when the form is submitted (if validation has passed without errors). It receives the same arguments as <kbd>validateForm()</kbd>. You can perform operations such as saving the submitted values or triggering some other kind of flow.</li>
</ul>
<p>Defining a form, in a nutshell, means creating an array of form element definitions. The resulting form is very similar to the render array we mentioned earlier and which we will describe in more depth in <a href="601b4dd0-c521-459e-9342-2645a109642c.xhtml"><span class="MsoHyperlink">Chapter 2</span></a>, <em>Creating Your First Module</em>. When creating your forms, you have a large number of form element types to use. A complete reference of what they are and what their options are (their definition specificities) can be found on the Drupal Form API reference page (<span class="URLPACKT"><a href="https://api.drupal.org/api/drupal/elements/8.7.x">https://api.drupal.org/api/drupal/elements/8.7.x</a></span>). Keep this page close to you throughout your Drupal 8 development.</p>
<p>From a dependency injection point of view, forms can receive arguments from the Service Container in the same way we injected the salutation service into our Controller. As a matter of fact, <kbd>ConfigFormBase</kbd>, which we are extending in our preceding form, injects the <kbd>config.factory</kbd> service because it needs to use it for reading and storing configuration values. This is why we extend from that form. Drupal is full of these helpful classes we can extend and that provide a bunch of useful boilerplate code that is very commonly used across the Drupal ecosystem.</p>
<p>If the form you are building is not storing or working with your configuration, you will typically extend from <kbd>FormBase</kbd>, which provides some static methods and traits, and also implements some interfaces. The same word of caution goes for its helper service methods as for the <kbd>ControllerBase</kbd>: if you need services, you should always inject them.</p>
<p>Let's turn to our preceding form class and dissect it a bit now that we know a thing or two about forms.</p>
<p>We have the <kbd>getFormId()</kbd> method. Check. We also have <kbd>buildForm()</kbd> and <kbd>submitForm()</kbd>, but not <kbd>validateForm()</kbd>. The latter is not mandatory, and we don't actually need it for our example, but if we did, we could have something like this:</p>
<pre><span>/**<br/></span><span> * {</span><span>@inheritdoc</span><span>}<br/></span><span> */<br/></span><span>public function </span><span>validateForm</span><span>(</span><span>array </span><span>&amp;</span><span>$form</span><span>, </span><span>FormStateInterface </span><span>$form_state</span><span>) {<br/></span><span>  </span><span>$salutation </span><span>= </span><span>$form_state</span><span>-&gt;</span><span>getValue</span><span>(</span><span>'salutation'</span><span>)</span><span>;<br/></span><span>  </span><span>if </span><span>(strlen(</span><span>$salutation</span><span>) &gt; </span><span>20</span><span>) {<br/></span><span>    </span><span>$form_state</span><span>-&gt;</span><span>setErrorByName</span><span>(</span><span>'salutation'</span><span>, </span><span>$this</span><span>-&gt;</span><span>t</span><span>(</span><span>'This salutation is too long'</span><span>))</span><span>;<br/></span><span>  </span><span>}<br/></span><span>}<br/></span></pre>
<p>In this validation handler, we basically check whether the submitted value for the <kbd>salutation</kbd> element is longer than 20 characters. If so, we set an error on that element (to turn it red usually) and specify an error message on the form state specific to this error. The form will then be refreshed and the error will be presented, and the submit handler, in this case, will not be called.</p>
<p>For the purposes of our example, this is, however, not necessary, so I will not include it in the final code.</p>
<div class="packt_infobox">Form validation error messages, by default, are printed at the top of the page. However, with the core <strong>Inline Form Errors</strong> module we can have the form errors printed right beneath the actual elements. This is much better for accessibility, as well as for clarity when dealing with large forms. Note that the standard Drupal 8 installation doesn't have this module enabled so you'll have to enable it yourself if you want to use it.</div>
<p>If we turn back to our form class, we also see a strange <kbd>getEditableConfigNames()</kbd> method. This is required by the <kbd>ConfigFormBaseTrait</kbd>, which is used in the <kbd>ConfigFormBase</kbd> class that we are extending, and it needs to return an array of configuration object names that this form intends to edit. This is because there are two ways of loading configuration objects: for editing and for reading (immutable). With this method, we inform it that we want to edit that configuration item.</p>
<p>As we see on the first line of <kbd>buildForm()</kbd>, we are using the <kbd>config()</kbd> method of the abovementioned trait to load up our editable configuration object from the Drupal configuration factory. This is to check the value that is currently stored in it. Then, we define our form elements (in our case, one—a simple text field). As <kbd>#default_value</kbd> (the value present in the element when the user goes to the form), we put whatever is in the configuration object. The rest of the element options are self-explanatory and pretty standard across all element types. Consult the Form API reference to see what other options are available and for which element types. Finally, at the end of the method, we also call the parent method because that provides the form's submit button, which for our purposes is enough.</p>
<p>The last method we wrote is the submit handler, which basically loads up the editable configuration object, puts the submitted value in it and then saves it. Finally, it also calls the parent method, which then simply sets a success message to the user on the screen using <kbd>Messenger</kbd> service—a standard way of showing the user a success or error message from a code context.</p>
<p>That is pretty much it; this will work just fine.</p>
<div class="packt_infobox">For much of Drupal's lifespan, the way to output such a message to the user has been via the <kbd>drupal_set_message()</kbd> global function. This has been the case also in Drupal 8 but has been deprecated starting with version 8.5 in favor of the <kbd>Messenger</kbd> service (accessed by the <kbd>messenger</kbd> service name). For Drupal 7 veterans this is quite the adjustment but it's important to understand that although using <kbd>drupal_set_message()</kbd> will still work, it will be removed in Drupal 9. So it's best to already start using the correct service instead. <span class="fontstyle0">Going forward, there will be places I use the old version for the sake of avoiding lots of boilerplate code in the book. But you should no longer use it in your own code.</span></div>
<p>From the point of view of configuration, we used <kbd>ConfigFormBase</kbd> to make our lives easier and combine the form aspect with that of the configuration storage. In a later chapter, we will talk a bit more about the different types of storage and also cover how to work with the configuration objects in more detail, as well as what these entail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Altering forms</h1>
                </header>
            
            <article>
                
<p>Before going ahead with our proposed functionality, I would like to open a parenthesis and discuss forms in a bit more detail. An important thing that you will do as a module developer is alter forms defined by other modules or Drupal core. So, it behooves us to talk about it early on and what better moment than now, when defining the form itself is still fresh in our minds.</p>
<p>Obviously, the form we just created belongs to us and we can change it however we want. However, many forms out there have been defined by other modules and there will be just as many times that you will want to make changes to them. Drupal provides us with a very flexible, albeit still procedural way of doing so—a suite of <em>alter</em> hooks; but what are <em>alter</em> hooks?</p>
<p>The first thing we did in this chapter was implement <kbd>hook_help()</kbd>. That is an example of an invoked hook by which a caller (Drupal core or any module) asks all other modules to provide input. This input is then aggregated in some way and made use of. The other type of hooks we have in Drupal are the <em>alter</em> hooks, which are used to allow other modules to make changes to an array or an object before that array or object is used for whatever it is used for. So, in the case of forms, there are some alter hooks that allow modules to make changes to the form before it's processed for rendering.</p>
<p>You may be wondering why I am saying that, for making changes to a form, we have more than one <em>alter</em> hook. Let me explain by giving an example of how other modules could alter the form we just defined:</p>
<pre><span>/**<br/></span><span> * Implements hook_form_alter().<br/></span><span> */<br/></span><span>function </span><span>my_module_form_alter</span><span>(&amp;</span><span>$form</span><span>, </span><span>\Drupal\Core\Form\FormStateInterface </span><span>$form_state</span><span>, </span><span>$form_id</span><span>) {<br/></span><span>  </span><span>if </span><span>(</span><span>$form_id </span><span>== </span><span>'salutation_configuration_form'</span><span>) {<br/></span><span>    </span><span>// Perform alterations. <br/></span><span>  </span><span>}<br/></span><span>}<br/></span></pre>
<p>In the preceding code, we implemented the generic <kbd>hook_form_alter()</kbd> inside a module called <kbd>my_module</kbd>, which gets fired for all forms when being built. The first two arguments are the form and form state (the same as we saw in the form definition), the former being passed by reference. This is the typical <em>alter</em> concept—we make changes to an existing variable and don't return anything. The third parameter is the form ID, the one we defined in the <kbd>getFormId()</kbd> method of our form class. We check to ensure that the form is correct and then we can make alterations to the form.</p>
<p>This is, however, almost always the wrong approach, because the hook is fired for all forms indiscriminately. Even if we don't actually do anything for most of them, it's still a useless function call, not to mention that if we want to alter 10 forms in our module, there will be a lot of <kbd>if</kbd> conditionals in there—the price we pay for procedural functions. Instead, though, we can do this:</p>
<pre><span>/**<br/></span><span> * Implements hook_form_FORM_ID_alter().<br/></span><span> */<br/></span><span>function </span><span>my_module_form_salutation_configuration_form_alter</span><span>(&amp;</span><span>$form</span><span>, </span><span>\Drupal\Core\Form\FormStateInterface </span><span>$form_state</span><span>, </span><span>$form_id</span><span>) {<br/></span><span>  </span><span>// Perform alterations. <br/></span><span>}</span></pre>
<p>Here, we are implementing <kbd>hook_form_FORM_ID_alter()</kbd>, which is a dynamic alter hook in that its name contains the actual ID of the form we want to alter. So, with this approach, we ensure that this function is called only when it's time to alter our form, and the other benefit is that if we need to alter another one, we can implement the same for that and have our logic neatly separated.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom submit handlers</h1>
                </header>
            
            <article>
                
<p>So, up to now, we have seen how other modules can make changes to our form. That means adding new form elements, changing existing ones, etc. But what about our validation and submit handlers (those methods that get called when the form is submitted). How can those be altered?</p>
<p>Typically, for the forms defined as we did, it's pretty simple. Once we alter the form and inspect the <kbd>$form</kbd> array, we can find a <kbd>#submit</kbd> key, which is an array that has one item—<kbd>::submitForm</kbd>. This is simply the <kbd>submitForm()</kbd> method on the form class. So, what we can do is either remove this item and add our own function, or simply add another item to that array:</p>
<pre>/** 
 * Implements hook_form_FORM_ID_alter(). */ function my_module_form_salutation_configuration_form_alter(&amp;$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) { // Perform alterations. $form['#submit'][] = 'hello_world_salutation_configuration_form_submit'; } </pre>
<p>And the callback we added to the <kbd>#submit</kbd> array above can look like this:</p>
<pre>/** 
 * Custom submit handler for the form_salutation_configuration form. 
 * 
 * @param $form 
 * @param \Drupal\Core\Form\FormStateInterface $form_state 
 */ 
function my_module_salutation_configuration_form_submit(&amp;$form, \Drupal\Core\Form\FormStateInterface $form_state) { 
  // Do something when the form is submitted. 
} </pre>
<p>So, the cool thing is that you can choose to tack on your own callback or replace the existing one. Keep in mind that the order they are in located in that array is the order in which they get executed. So, you can also change the order if you want.</p>
<p>There is another case though. If the submit button on the form has a <kbd>#submit</kbd> property specifying its own handler, the default form <kbd>#submit</kbd> handlers we saw just now won't fire anymore. This was not the case with our form. So, in that situation, you will need to add your own handler to that array. Hence, the only difference is the place you tack on the submit handler. A prominent example of such a form is the Node add/edit form.</p>
<p>Finally, when it comes to the validation handler, it works exactly the same as with the submit handler, but it all happens under the <kbd>#validate</kbd> array key.</p>
<p>Feel free to experiment with altering existing forms and inspect the variables they receive as arguments. I strongly encourage you to become familiar with the common form data and keep the documentation on form elements close by (<span class="URLPACKT"><a href="https://api.drupal.org/api/drupal/elements/8.7.x">https://api.drupal.org/api/drupal/elements/8.7.x</a></span>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rendering forms</h1>
                </header>
            
            <article>
                
<p>Staying on forms for just a bit longer, let's quickly learn how to render forms programmatically. We have already seen how to map a form to a route definition so that the page being built contains the form when accessing the route path. However, there are times when we need to render a form programmatically, either inside a Controller or a block, or wherever you want. We can do this using the <kbd>FormBuilder</kbd> service.</p>
<p>The form builder can be injected using the <kbd>form_builder</kbd> service key or used statically via the shorthand:</p>
<pre>$builder = \Drupal::formBuilder(); </pre>
<p>Once we have it, we can build a form, like so:</p>
<pre>$form = $builder-&gt;getForm('Drupal\hello_world\Form\SalutationConfigurationForm'); </pre>
<p>In the preceding code, <kbd>$form</kbd> will be a render array of the form that we can return, for example, inside a Controller. We'll talk more about render arrays a bit later on, and you'll understand how they get turned into actual form markup. However, for now, this is all you need to know about rendering forms programmatically—you get the form builder and request from it the form using the fully qualified name of the form class.</p>
<p>With this, we can close the parenthesis on forms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Service dependencies</h1>
                </header>
            
            <article>
                
<p>In the previous section we created a form that allows administrators to set a custom salutation message to be shown on the page. This message was stored in a configuration object that we can now load in our <kbd>HelloWorldSalutation</kbd> service. So, let's do just that in a two-step process.</p>
<p>First, we will need to alter our service definition to give our service an argument—the Drupal 8 configuration factory (the service responsible for loading config objects). This is how our service definition should look now:</p>
<pre><span>hello_world.salutation:<br/></span><span>  class: </span>Drupal\hello_world\HelloWorldSalutation<br/>  <span>arguments: </span>[<span>'@config.factory'</span>]</pre>
<p>The addition is the argument's key, which is an array of service names proceeded by <kbd>@</kbd>. In this case, <kbd>config.factory</kbd> is the responsible service name, which, if we check in the <kbd>core.services.yml</kbd> file, we note that it maps to the <kbd>Drupal\Core\Config\ConfigFactory</kbd> class.</p>
<p>So, with this change, the <kbd>HelloWorldSalutation</kbd> class will be passed an instance of <kbd>ConfigFactory</kbd>. All we need to do now is adjust our class to actually receive it:</p>
<pre><span>/**<br/></span><span> * </span><span>@var </span><span>\Drupal\Core\Config\ConfigFactoryInterface<br/></span><span> */<br/></span><span>protected </span><span>$configFactory</span><span>;<br/></span><span><br/></span><span>/**<br/></span><span> * HelloWorldSalutation constructor.<br/></span><span> *<br/></span><span> * </span><span>@param </span><span>\Drupal\Core\Config\ConfigFactoryInterface $config_factory<br/></span><span> */<br/></span><span>public function </span><span>__construct</span><span>(ConfigFactoryInterface </span><span>$config_factory</span><span>) {<br/></span><span>  </span><span>$this</span><span>-&gt;</span><span>configFactory </span><span>= </span><span>$config_factory</span><span>;<br/></span><span>}</span></pre>
<p>There's nothing too complicated going on here. We added a constructor and set the config factory service on a property. We can now use it to load our configuration object that we saved in the form. However, before we do that, we should also <em>use</em> the <kbd>ConfigFactoryInterface</kbd> class at the top of the file:</p>
<pre>use Drupal\Core\Config\ConfigFactoryInterface;  </pre>
<p>Now, at the top of the <kbd>getSalutation()</kbd> method, we can add the following bit:</p>
<pre><span>$config </span><span>= </span><span>$this</span><span>-&gt;</span><span>configFactory</span><span>-&gt;</span><span>get</span><span>(</span><span>'hello_world.custom_salutation'</span><span>)</span><span>;<br/></span><span>$salutation </span><span>= </span><span>$config</span><span>-&gt;</span><span>get</span><span>(</span><span>'salutation'</span><span>)</span><span>;<br/></span><span>if </span><span>(</span><span>$salutation </span><span>!= </span><span>""</span><span>) {<br/></span><span>  </span><span>return </span><span>$salutation</span><span>;<br/></span><span>}</span></pre>
<p>With this addition, we are loading the configuration object we saved in the form, and from it, we request the <kbd>salutation</kbd> key, where if you remember, we stored our message. If there is a value in there, we will return it. Otherwise, the code will continue, and our previous logic of time-based greeting will apply.</p>
<p>So, now if we reload our initial page, the message we saved through the form should show up. If we then return to the form and remove the message, this page should default back to the original dynamic greeting. Neat, right?</p>
<p>Let's now take a look at how we can create a custom block that we can place anywhere we like and which will output the same thing as our page.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Blocks</h1>
                </header>
            
            <article>
                
<p>Blocks in Drupal 8 are plugins. However, the blocks you create in the UI are content entities and the placement of both in the block layout are configuration entities. So, the block system is a good example of how entities and plugins work hand in hand in Drupal 8. We will talk in more detail about plugin types and entities later in the book.</p>
<p>The block system in Drupal 8 is a great shift from its predecessor. Before, you had to implement two obligatory hooks plus two optional hooks if you wanted the block to have a configuration, and the latter was always saved somewhere that had nothing to do with the block itself. In Drupal 8, we work with a simple plugin class that can be made container-aware (that is, we can inject dependencies into it) and we can store configuration in a logical fashion.</p>
<p>So, how do we create a custom block plugin? All we need is one class, placed in the right namespace—<kbd>Drupal\module_name\Plugin\Block</kbd>. In this case (with plugins), the folder naming is important. The plugin discoverability is dependent on the plugin type itself, and this one has the <kbd>Plugin\Block</kbd> namespace bit in it. But enough talk, let's create a simple block that just renders the same as our Controller did previously, and I will explain things along the way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Our first block plugin</h1>
                </header>
            
            <article>
                
<p>So, this is our plugin class—<kbd>HelloWorldSalutationBlock</kbd>—that does just that:</p>
<pre><span>namespace </span><span>Drupal\hello_world\Plugin\Block</span><span>;<br/></span><span><br/></span><span>use </span><span>Drupal\Core\Block\BlockBase</span><span>;<br/></span><span>use </span><span>Drupal\Core\Plugin\ContainerFactoryPluginInterface</span><span>;<br/></span><span>use </span><span>Symfony\Component\DependencyInjection\ContainerInterface</span><span>;<br/></span><span>use </span><span>Drupal\hello_world\HelloWorldSalutation </span><span>as </span><span>HelloWorldSalutationService</span><span>;<br/></span><span><br/></span><span>/**<br/></span><span> * Hello World Salutation block.<br/></span><span> *<br/></span><span> * </span><span>@Block</span><span>(<br/></span><span> *  id = "hello_world_salutation_block",<br/></span><span> *  admin_label = </span><span>@Translation</span><span>("Hello world salutation"),<br/></span><span> * )<br/></span><span> */<br/></span><span>class </span><span>HelloWorldSalutationBlock </span><span>extends </span><span>BlockBase </span><span>implements </span><span>ContainerFactoryPluginInterface {<br/></span><span><br/></span><span>  </span><span>/**<br/></span><span>   * The salutation service.<br/></span><span>   *<br/></span><span>   * </span><span>@var </span><span>\Drupal\hello_world\HelloWorldSalutation<br/></span><span>   */<br/></span><span>  </span><span>protected </span><span>$salutation</span><span>;<br/></span><span><br/></span><span>  </span><span>/**<br/></span><span>   * Construct.<br/></span><span>   *<br/></span><span>   * </span><span>@param </span><span>array $configuration<br/></span><span>   *   A configuration array containing information about the plugin instance.<br/></span><span>   * </span><span>@param </span><span>string $plugin_id<br/></span><span>   *   The plugin_id for the plugin instance.<br/></span><span>   * </span><span>@param </span><span>string $plugin_definition<br/></span><span>   *   The plugin implementation definition.<br/></span><span>   * </span><span>@param </span><span>\Drupal\hello_world\HelloWorldSalutation $salutation   *   The salutation service.<br/></span><span>   */<br/></span><span>  </span><span>public function </span><span>__construct</span><span>(</span><span>array </span><span>$configuration</span><span>, </span><span>$plugin_id</span><span>, </span><span>$plugin_definition</span><span>, </span><span>HelloWorldSalutationService </span><span>$salutation</span><span>) {<br/></span><span>    </span><span>parent</span><span>::</span><span>__construct</span><span>(</span><span>$configuration</span><span>, </span><span>$plugin_id</span><span>, </span><span>$plugin_definition</span><span>)</span><span>;<br/></span><span>    </span><span>$this</span><span>-&gt;</span><span>salutation </span><span>= </span><span>$salutation</span><span>;<br/></span><span>  </span><span>}<br/></span><span><br/></span><span>  </span><span>/**<br/></span><span>   * {</span><span>@inheritdoc</span><span>}<br/></span><span>   */<br/></span><span>  </span><span>public static function </span><span>create</span><span>(ContainerInterface </span><span>$container</span><span>, </span><span>array </span><span>$configuration</span><span>, </span><span>$plugin_id</span><span>, </span><span>$plugin_definition</span><span>) {<br/></span><span>    </span><span>return new static</span><span>(<br/></span><span>      </span><span>$configuration</span><span>,<br/></span><span>      </span><span>$plugin_id</span><span>,<br/></span><span>      </span><span>$plugin_definition</span><span>,<br/></span><span>      </span><span>$container</span><span>-&gt;</span><span>get</span><span>(</span><span>'hello_world.salutation'</span><span>)<br/></span><span>    )</span><span>;<br/></span><span>  </span><span>}<br/></span><span><br/></span><span>  </span><span>/**<br/></span><span>   * {</span><span>@inheritdoc</span><span>}<br/></span><span>   */<br/></span><span>  </span><span>public function </span><span>build</span><span>() {<br/></span><span>    </span><span>return </span><span>[<br/></span><span>      </span><span>'#markup' </span><span>=&gt; </span><span>$this</span><span>-&gt;</span><span>salutation</span><span>-&gt;</span><span>getSalutation</span><span>()</span><span>,<br/></span><span>    </span><span>]</span><span>;<br/></span><span>  </span><span>}<br/></span><span>}</span></pre>
<p>Before even going through the explanation, you should know that clearing the cache and placing this block through the UI block management will do what we wanted. However, let's understand what is going on here first.</p>
<p>Perhaps the strangest thing you'll note is the DocBlock comment at the top of the class. This is called an <em>annotation</em> and denotes that this class is a <kbd>Block</kbd> plugin. As I mentioned in the first chapter, annotations are the most common discovery mechanisms for plugins in Drupal core. In this case, the plugin definition we need is made up of an ID and an administration label.</p>
<div class="packt_tip">Properly defined plugin types have an <kbd>AnnotationInterface</kbd> implementation, which describes the properties that can or should be used in the annotation. So if you are unsure as to what needs to be there, look for this class for that specific plugin type.</div>
<p>Then, we see that our class extends <kbd>BlockBase</kbd> and also implements the <kbd>ContainerFactoryPluginInterface</kbd>. The former, similar to the Controller and Form we saw earlier, provides a number of helpful things a block plugin needs. However, we cannot really get around extending this class because block plugins are quite complex, working with things such as context and configuration. So, ensure that you always extend this class. The latter is, however, optional. That interface makes this block plugin container-aware, that is, at the moment of instantiation, it uses the <kbd>create()</kbd> method to build itself using the container for dependencies and, sure enough, we have our <kbd>create()</kbd> method below.</p>
<p>Before moving on to the actual block building, we need to talk a bit about dependency injection in plugins. As you see, the signature of this <kbd>create()</kbd> method is different to the one we saw in the Controller. This is also why we are using a different container-aware interface. The reason is that plugins are constructed with a few extra parameters: <kbd>$configuration</kbd>, <kbd>$plugin_id</kbd>, and <kbd>$plugin_definition</kbd>. The first contains any configuration values that were stored with the plugin (or passed when building), the second is the ID set in the plugin annotation (or other discovery mechanism), and the third is an array that contains the metadata of this plugin (including all the info found in the annotation). However, apart from this, it's business as usual when it comes to dependency injection. If a plugin type base class doesn't implement this interface, you can do so yourself directly in your plugin. And this works with most plugins, save for a few exceptions which cannot be made container-aware, but this happens very rarely.</p>
<p>Finally, we have a <kbd>build()</kbd> method, which is responsible for building the block content. It needs to return a render array (just like our Controller did), and as you can see, we are using our injected service and return the same greeting. That is pretty much what we need to do to achieve our goal. There are other important aspects to block plugins we will cover later, such as caching and access, but we have specific chapters for those topics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Block configuration</h1>
                </header>
            
            <article>
                
<p>Before we close the book on our custom block plugin, let's take a look at how we can add a configuration form to it. This way, we can practice using some more Form API elements and see how we can store and use block configuration.</p>
<p>Even though our functionality is complete (for the moment), let's imagine that we need a Boolean-like control on our block configuration so that when an admin places the block, they can toggle something and that value can be used in the <kbd>build()</kbd> method. We could achieve this with three to four methods on our plugin class.</p>
<p>First, we would need to implement the <kbd>defaultConfiguration()</kbd> method, in which we describe the items of configuration that we are storing for this block and the default values for these items. So, we could have something like this:</p>
<pre><span>/**<br/></span><span> * {</span><span>@inheritdoc</span><span>}<br/></span><span> */<br/></span><span>public function </span><span>defaultConfiguration</span><span>() {<br/></span><span>  </span><span>return </span><span>[<br/></span><span>    </span><span>'enabled' </span><span>=&gt; </span><span>1</span><span>,<br/></span><span>  </span><span>]</span><span>;<br/></span><span>}</span></pre>
<p>We return an array of keys and values that will be in the configuration. Also, since we said we are going with a Boolean field, we use the number 1 as the value to a fictitious key named <kbd>enabled</kbd>.</p>
<p>Next, we would need to implement the <kbd>blockForm()</kbd> method which provides our form definition for this configuration item:</p>
<pre><span>/**<br/></span><span> * {</span><span>@inheritdoc</span><span>}<br/></span><span> */<br/></span><span>public function </span><span>blockForm</span><span>(</span><span>$form</span><span>, </span><span>FormStateInterface </span><span>$form_state</span><span>) {<br/></span><span>  </span><span>$config </span><span>= </span><span>$this</span><span>-&gt;</span><span>getConfiguration</span><span>()</span><span>;<br/></span><span><br/></span><span>  </span><span>$form</span><span>[</span><span>'enabled'</span><span>] = </span><span>array</span><span>(<br/></span><span>    </span><span>'#type' </span><span>=&gt; </span><span>'checkbox'</span><span>,<br/></span><span>    </span><span>'#title' </span><span>=&gt; t(</span><span>'Enabled'</span><span>)</span><span>,<br/></span><span>    </span><span>'#description' </span><span>=&gt; t(</span><span>'Check this box if you want to enable this feature.'</span><span>)</span><span>,<br/></span><span>    </span><span>'#default_value' </span><span>=&gt; </span><span>$config</span><span>[</span><span>'enabled'</span><span>]</span><span>,<br/></span><span>  </span><span>)</span><span>;<br/></span><span><br/></span><span>  </span><span>return </span><span>$form</span><span>;<br/></span><span>}</span></pre>
<p>With the appropriate extra <em>use</em> statement at the top of the file:</p>
<pre>use Drupal\Core\Form\FormStateInterface;  </pre>
<p>As you can see, this is a typical Form API definition for one form element of the type <kbd>checkbox</kbd>. Additionally, we are using the<span class="fontstyle0"> handy</span> <span class="fontstyle2"><kbd>getConfiguration()</kbd></span> <span class="fontstyle0">method</span><br/>
 of the parent class to load up the configuration values that get saved with this block. If none have been saved, note that the <kbd>enabled</kbd> key will be present in it with the default value we set above (1).</p>
<p>Lastly, we would need the submit handler that will do the necessaries to "store" the configuration. I used inverted commas because we don't actually have to do anything related to storage, but just map the value submitted in the form to the relevant key in the configuration. The block system does it for us:</p>
<pre><span>/**<br/></span><span> * {</span><span>@inheritdoc</span><span>}<br/></span><span> */<br/></span><span>public function </span><span>blockSubmit</span><span>(</span><span>$form</span><span>, </span><span>FormStateInterface </span><span>$form_state</span><span>) {<br/></span><span>  </span><span>$this</span><span>-&gt;</span><span>configuration</span><span>[</span><span>'enabled'</span><span>] = </span><span>$form_state</span><span>-&gt;</span><span>getValue</span><span>(</span><span>'enabled'</span><span>)</span><span>;<br/></span><span>}<br/></span></pre>
<p>It couldn't be simpler than this. Now if we placed our custom block somewhere, the form we are presented with would incorporate our form element that allows us to toggle the <kbd>enabled</kbd> key. What remains to be done is to make use of this value inside the <kbd>build()</kbd> method. We could do that similarly to how we loaded the configuration values inside the <kbd>buildForm()</kbd> method:</p>
<pre>$config = $this-&gt;getConfiguration();</pre>
<p>Alas, we don't really need this configuration in our example block, so we won't be adding it to our code. However, it is important for you to know how to do it, so we covered it here. Moreover, before moving on, I also want to specify that you can use an optional method to handle validation on the configuration form. The method name is <kbd>blockValidate()</kbd>, has the same signature as <kbd>blockSubmit()</kbd> and works the same way as the validation handler we saw when we built our standalone form. So, I won't repeat that here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with links</h1>
                </header>
            
            <article>
                
<p>One of the principal characteristics of a web application is the myriad of links between its resources. They are in fact the glue that brings it together. So, in this section, I want to show you a few common techniques used while working with links programmatically in Drupal 8.</p>
<p>There are two main aspects when talking about link building in Drupal—the URL and the actual link tag itself. So, creating a link involves a two-step process, but can also be shortened into a single call via some helper methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The URL</h1>
                </header>
            
            <article>
                
<p>URLs in Drupal 8 are represented with the <kbd>Drupal\Core\Url</kbd> class, which has a number of static methods that allow you to create an instance. The most important of these is <kbd>::fromRoute()</kbd>, which takes a route name, route parameters (if any are needed for that route), and an array of options to create a new instance of <kbd>Url</kbd>. There are other such methods available that turn all sorts of other things into a <kbd>Url</kbd>, most notably the <kbd>::fromUri()</kbd> method which takes an internal or external URI. These methods can be very helpful, especially when dealing with dynamically obtained data. However, when hardcoding, it's always best to work with route names because that allows you to later change the actual path behind that route without affecting your code.</p>
<p>There are many options that can be passed to <kbd>Url</kbd> when instantiating it, inside the <kbd>$options</kbd> array. You can pass an array of query parameters, a fragment, and others. These will then help construct a URL as complex as you need without having to deal with strings yourself. I suggest that you check out the documentation above the <kbd>::fromUri()</kbd> method because it describes them all. Also, keep in mind that the options are pretty much the same, regardless of the method that you use to create the <kbd>Url</kbd> object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The link</h1>
                </header>
            
            <article>
                
<p>Now that we have a <kbd>Url</kbd> object, we can use it to generate a link. We can do this in two ways:</p>
<ul>
<li>Use the <kbd>LinkGenerator</kbd> service (named <kbd>link_generator</kbd>) and call its <kbd>generate()</kbd> method by passing the link text and the <kbd>Url</kbd> object we have obtained. This will return a <kbd>GeneratedLink</kbd> object, which contains the actual string representation of the link as well as some cache metadata.</li>
<li>Use the <kbd>\Drupal\Core\Link</kbd> class, which wraps a render element (we will talk more about render elements in the <kbd>Theming</kbd> chapter) to represent the link.</li>
</ul>
<p>Let's take a look at an example of both, from start to finish.</p>
<p>Consider this example of generating a link using the service:</p>
<pre>$url = Url::fromRoute('my_route', ['param_name' =&gt; $param_value]);<br/>$link = \Drupal::service('link_generator')-&gt;generate('My link', $url);</pre>
<p>We can then directly print <kbd>$link</kbd> because it implements the <kbd>__toString()</kbd> method.</p>
<p>Now, consider this example of generating a link using the <kbd>Link</kbd> class:</p>
<pre>$url = Url::fromRoute('my_other_route');<br/>$link = Link::fromTextAndUrl('My link', $url);</pre>
<p>We now have <kbd>$link</kbd> as a <kbd>Link</kbd> object whose <kbd>toRenderable()</kbd> method returns a render array of the <kbd>#type =&gt; 'link'</kbd>. Behind the scenes, at render time, it will also use the link generator to transform that into a link string.</p>
<p>If we have a <kbd>Link</kbd> object, we can also use the link generator ourselves to generate a link based on its own data:</p>
<pre>$link = \Drupal::service('link_generator')-&gt;generateFromLink($linkObject); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Which way to link?</h1>
                </header>
            
            <article>
                
<p>As we saw, we have a number of ways to create links and URL representations, but when it comes to creating a link, which method should we use? There are advantages and disadvantages to each one.</p>
<p>When it comes to URL, as mentioned, it's a good idea to stick to hardcoding routes rather than URIs. However, if you are working with dynamic data, such as user input or stored strings, the other methods are perfectly valid. I recommend that you look at the <kbd>Url</kbd> class in detail because you will be using it quite a bit as you develop Drupal 8 modules.</p>
<p>Regarding the actual links, using the service to generate a link means that you are creating a string at that point in the code. This means that it cannot be altered later in the process. However, using the <kbd>Link</kbd> class falls nicely in line with the entire render array rationale of delaying the actual generation to the last possible moment. We will talk more about render arrays later on. So, the choice you make depends on the link you need to generate and your answer to the following question: is the link something that might have to be alterable by other modules/themes? If so, proceed with the render array. Otherwise, you might consider generating if you can inject the service properly.</p>
<p>When it comes to entities, it's always better to use the helper methods on the base entity classes to generate links and URLs to these entities. We will talk more about entities later in this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Event Dispatcher and redirects</h1>
                </header>
            
            <article>
                
<p>A common thing you'll have to do as a module developer is to intercept a given request and redirect it to another page, and more often than not, this will have to be dynamic, depending on the current user or other contextual info. Drupal 7 developers know very well that this has always been an easy task. Simply implement <kbd>hook_init()</kbd>, which gets called on each request and then use the famous <kbd>drupal_goto()</kbd> function. This, however, is no longer the case in Drupal 8. What we have to do now is subscribe to the <kbd>kernel.request</kbd> event (remember this from the preceding chapter?) and then change the response directly. However, before seeing an example of this, let's take a look at how we can perform a simpler redirect from within a Controller. You know, since we're on the subject.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Redirecting from a Controller</h1>
                </header>
            
            <article>
                
<p>In this chapter, we wrote a Controller that returns a render array. We know from the preceding chapter that this is picked up by the theme system and turned into a response. In <a href="feada4d1-f255-4dd6-83b5-8d66bab5f852.xhtml"><span class="MsoHyperlink">Chapter 4</span></a>, <em>Theming</em>, we will go into a bit more detail and see how this process is done. However, this render pipeline can also be bypassed if the Controller returns a response directly. Let's consider the following example:</p>
<pre>return new \Symfony\Component\HttpFoundation\Response('my text');  </pre>
<p>This will bypass much of that processing and return a blank white page with only the "my text" string on it. The <kbd>Response</kbd> class we're using is from the Symfony HTTP Foundation component.</p>
<p>However, we also have a handy <kbd>RedirectResponse</kbd> class that we can use, and it will redirect the browser to another page:</p>
<pre>return new \Symfony\Component\HttpFoundation\RedirectResponse('node/1')  </pre>
<p>The first parameter is the URL where we want to redirect. Typically, this should be an absolute URL; however, browsers nowadays are smart enough to handle a relative path as well. So, in this case, the Controller will redirect us to that path.</p>
<div class="packt_infobox">Typically, when returning redirect responses, you'll want to use a child class of <kbd>RedirectResponse</kbd>. For example, we have the <kbd>LocalRedirectResponse</kbd> and <kbd>TrustedRedirectResponse</kbd> classes which both extend from <kbd>SecuredRedirectResponse</kbd>. The purpose of these utilities is to ensure that redirects are safe.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Redirecting from a subscriber</h1>
                </header>
            
            <article>
                
<p>Many times, our business logic dictates that we need to perform a redirect from a certain page to another if various conditions match. For these, we can subscribe to the request event and simply change the response, essentially bypassing the normal process, which would have gone through all the layers of Drupal. However, before we see an example, let's talk about the Event Dispatcher for just a bit.</p>
<p>The central player in this system is the <kbd>event_dispatcher</kbd> service, which is an instance of the <kbd>ContainerAwareEventDispatcher</kbd> class. This service allows the dispatching of named events that take a payload in the form of an <kbd>Event</kbd> object, which wraps the data that needs to be passed around. Typically, when dispatching events, you'll create an <kbd>Event</kbd> subclass with some handy methods for accessing the data that needs to be passed around. Finally, instances of <kbd>EventSubscriberInterface</kbd> listen to events that have certain names and can alter the <kbd>Event</kbd> object that has been passed. Essentially, then, this system allows subscribers to change data before the business logic uses it for something. In this respect, it is a prime example of an extension point in Drupal 8. Finally, registering event subscribers is a matter of creating a service tagged with <kbd>event_subscriber</kbd> and that implements the interface.</p>
<p>Let's now take a look at an example event subscriber that listens to the <kbd>kernel.request</kbd> event and redirects to the home page if a user with a certain role tries to access our <em>Hello World</em> page. This will demonstrate both how to subscribe to events and how to perform a redirect. It will also show us how to use the current route match service to inspect the current route.</p>
<p>Let's create this subscriber by first writing the service definition for it:</p>
<pre>hello_world.redirect_subscriber:<br/>  class: \Drupal\hello_world\EventSubscriber\HelloWorldRedirectSubscriber<br/>  arguments: ['@current_user']<br/>  tags:<br/>    - { name: event_subscriber }</pre>
<p>As you can see, we have the regular service definition with one argument and with the <kbd>event_subscriber</kbd> tag. The dependency is actually the service that points to the current user (either logged in or anonymous) in the form of an <kbd>AccountProxyInterface</kbd>. This is a wrapper to the <kbd>AccountInterface</kbd>, which represents the actual current user. Also, when I say <em>user</em>, I mean an object that has certain data about the user and not the actual entity object with all the field data (the user session basically). Certain things about the user are, however, accessible from the <kbd>AccountInterface</kbd>, such as the ID, the name, roles, and email. I recommend that you check out the interface for more info. However, for our example, we will use it to check whether the user has the <kbd>non_grata</kbd> role, which will trigger the redirect I mentioned.</p>
<p>Next, let's look at the event subscriber class itself:</p>
<pre><span>namespace </span><span>Drupal\hello_world\EventSubscriber</span><span>;<br/></span><span><br/></span><span>use </span><span>Drupal\Core\Session\AccountProxyInterface</span><span>;<br/></span><span>use </span><span>Symfony\Component\EventDispatcher\EventSubscriberInterface</span><span>;<br/></span><span>use </span><span>Symfony\Component\HttpFoundation\RedirectResponse</span><span>;<br/></span><span>use </span><span>Symfony\Component\HttpKernel\Event\GetResponseEvent</span><span>;<br/></span><span>use </span><span>Symfony\Component\HttpKernel\KernelEvents</span><span>;<br/></span><span><br/></span><span>/**<br/></span><span> * Subscribes to the Kernel Request event and redirects to the homepage<br/></span><span> * when the user has the "non_grata" role.<br/></span><span> */<br/></span><span>class </span><span>HelloWorldRedirectSubscriber </span><span>implements </span><span>EventSubscriberInterface {<br/></span><span><br/></span><span>  </span><span>/**<br/></span><span>   * </span><span>@var </span><span>\Drupal\Core\Session\AccountProxyInterface<br/></span><span>   */<br/></span><span>  </span><span>protected </span><span>$currentUser</span><span>;<br/></span><span><br/></span><span>  </span><span>/**<br/></span><span>   * HelloWorldRedirectSubscriber constructor.<br/></span><span>   *<br/></span><span>   * </span><span>@param </span><span>\Drupal\Core\Session\AccountProxyInterface $currentUser<br/></span><span>   */<br/></span><span>  </span><span>public function </span><span>__construct</span><span>(AccountProxyInterface </span><span>$currentUser</span><span>) {<br/></span><span>    </span><span>$this</span><span>-&gt;</span><span>currentUser </span><span>= </span><span>$currentUser</span><span>;<br/></span><span>  </span><span>}<br/></span><span><br/></span><span>  </span><span>/**<br/></span><span>   * {</span><span>@inheritdoc</span><span>}<br/></span><span>   */<br/></span><span>  </span><span>public static function </span><span>getSubscribedEvents</span><span>() {<br/></span><span>    </span><span>$events</span><span>[</span><span>'kernel.request'</span><span>][] = [</span><span>'onRequest'</span><span>, </span><span>0</span><span>]</span><span>;<br/></span><span>    </span><span>return </span><span>$events</span><span>;<br/></span><span>  </span><span>}<br/></span><span><br/></span><span>  </span><span>/**<br/></span><span>   * Handler for the kernel request event.<br/></span><span>   *<br/></span><span>   * </span><span>@param </span><span>\Symfony\Component\HttpKernel\Event\GetResponseEvent $event<br/></span><span>   */<br/></span><span>  </span><span>public function </span><span>onRequest</span><span>(GetResponseEvent </span><span>$event</span><span>) {<br/></span><span>    </span><span>$request </span><span>= </span><span>$event</span><span>-&gt;</span><span>getRequest</span><span>()</span><span>;<br/></span><span>    </span><span>$path </span><span>= </span><span>$request</span><span>-&gt;</span><span>getPathInfo</span><span>()</span><span>;<br/></span><span>    </span><span>if </span><span>(</span><span>$path </span><span>!== </span><span>'/hello'</span><span>) {<br/></span><span>      </span><span>return</span><span>;<br/></span><span>    </span><span>}<br/></span><span><br/></span><span>    </span><span>$roles </span><span>= </span><span>$this</span><span>-&gt;</span><span>currentUser</span><span>-&gt;</span><span>getRoles</span><span>()</span><span>;<br/></span><span>    </span><span>if </span><span>(in_array(</span><span>'non_grata'</span><span>, </span><span>$roles</span><span>)) {<br/></span><span>      </span><span>$event</span><span>-&gt;</span><span>setResponse</span><span>(</span><span>new </span><span>RedirectResponse(</span><span>'/'</span><span>))</span><span>;<br/></span><span>    </span><span>}<br/></span><span>  }<br/></span><span>}</span></pre>
<p>As expected, we store the current user as a class property so that we can use it later on. Then, we implement the <kbd>EventSubscriberInterface::getSubscribedEvents()</kbd> method. This method needs to return a multidimensional array, which is basically a mapping between event names and the class methods to be called if that event is intercepted. And this is how we actually register methods to listen to one event or another, and we can listen to multiple events in the same subscriber class if we want. It's typically a good idea to separate these, however, into different, more topical, classes. The callback method name is inside an array whose second value represents the priority of this callback compared to others you or other modules may define. The higher the number, the higher the priority, the earlier in the process it will run. Do check the documentation on the interface itself for a good description of the ways you can subscribe to events.</p>
<p>In our example, we listen to the <kbd>kernel.request</kbd> event I mentioned in the previous chapter. This event is dispatched by Symfony's <kbd>HttpKernel</kbd>, passing an instance of <kbd>GetResponseEvent</kbd>, which basically wraps the <kbd>Request</kbd> object. The name of the <kbd>Event</kbd> class usually well describes the purpose of the event. In this case it is looking for a <kbd>Response</kbd> object to deliver to the browser. If we inspect the class, we can note that it has a <kbd>setResponse()</kbd> method on it, which we can use to set the response. If a subscriber provides one, it stops the event propagation (none of the other listeners with a lower priority are given a chance) and the response is returned.</p>
<p>So, in our <kbd>onRequest()</kbd> callback method, we check the current path being requested, and if it is ours and the current user has the <kbd>non_grata</kbd> role, we set the <kbd>RedirectResponse</kbd> onto the event to redirect it to the home page. This will do the job we set out to do. If you go to the <kbd>/hello</kbd> page as a user with that role, you should be redirected to the home page. That being said, I don't like many aspects about this implementation. So, let's fix them.</p>
<p>First, we hardcoded the <kbd>kernel.request</kbd> event name (I did, can't blame you for that). Any decent code that dispatches events will use a class constant to define the event name and the subscribers should also reference that constant. Symfony has the <kbd>KernelEvents</kbd> class just for that purpose. Check it out and see what other events are dispatched by the HttpKernel, as they are all referenced there.</p>
<p>So, instead of hardcoding the string, we can have this:</p>
<pre>$events[KernelEvents::REQUEST][] = ['onRequest', 0];</pre>
<p>Second, the way we do the path handling in the <kbd>onRequest()</kbd> method is all sorts of wrong. We are hardcoding the <kbd>/hello</kbd> path in this condition. What if we change the route path because our boss wants the path to be <kbd>/greeting</kbd>? I also don't like the way we passed the path to the <kbd>RedirectResponse</kbd>. The same thing applies (although in the case of the home page, not so much): what if the path we want to redirect to changes? Let's fix these problems using routes instead of paths. They are system-specific and are unlikely to change because of business requirements.</p>
<p>The problem is that we are unable to understand which route is being accessed from the <kbd>Request</kbd> object. Instead then, we can use the <kbd>current_route_match</kbd> service—a very popular one you'll use often—which gives us loads of info about the current route. So, let's inject that into our event subscriber. By now, you should know how to do this on your own (check the final code if you still have trouble). Once that is done, we can do this instead:</p>
<pre><span>public function </span><span>onRequest</span><span>(GetResponseEvent </span><span>$event</span><span>) {<br/></span><span>  </span><span>$route_name </span><span>= </span><span>$this</span><span>-&gt;</span><span>currentRouteMatch</span><span>-&gt;</span><span>getRouteName</span><span>()</span><span>;<br/></span><span><br/></span><span>  </span><span>if </span><span>(</span><span>$route_name </span><span>!== </span><span>'hello_world.hello'</span><span>) {<br/></span><span>    </span><span>return</span><span>;<br/></span><span>  </span><span>}<br/></span><span><br/></span><span>  </span><span>$roles </span><span>= </span><span>$this</span><span>-&gt;</span><span>currentUser</span><span>-&gt;</span><span>getRoles</span><span>()</span><span>;<br/></span><span>  </span><span>if </span><span>(in_array(</span><span>'non_grata'</span><span>, </span><span>$roles</span><span>)) {<br/></span><span>    </span><span>$url </span><span>= Url::</span><span>fromUri</span><span>(</span><span>'internal:/'</span><span>)</span><span>;<br/></span><span>    </span><span>$event</span><span>-&gt;</span><span>setResponse</span><span>(</span><span>new </span><span>LocalRedirectResponse(</span><span>$url</span><span>-&gt;</span><span>toString</span><span>()))</span><span>;<br/></span><span>  </span><span>}<br/></span><span>}</span></pre>
<p>From the <kbd>CurrentRouteMatch</kbd> service, we can figure out the name of the current route, the entire route object, parameters from the URL, and other useful things. Do check out the class for more info on what you can do, as I guarantee that they will come in handy.</p>
<p>Instead of checking against the pathname, we now check against the route name. So, if we change the path in the route definition, our code will still work. Then, instead of just adding the path to the <kbd>RedirectResponse</kbd>, we can build it first using the <kbd>Url</kbd> class we learned about in the previous section. Granted, in our example, it is probably overkill, but had we redirected it to a known route, we could have built it based on that, and our code would have been more robust. Additionally, using the <kbd>Url</kbd> class, we can also check other things such as access, and its <kbd>toString()</kbd> method simply turns it into a string that can be used for the <kbd>RedirectResponse</kbd>. Finally, instead of the simple <kbd>RedirectResponse</kbd>, we are using the <kbd>LocalRedirectResponse</kbd> class instead as we are redirecting to a local (safe) path.</p>
<p>With this, we will get the same redirect, but in a much cleaner and more robust way. Of course, only after adjusting the <em>use</em> statements at the top by removing the one for the <kbd>RedirectResponse</kbd> and adding the following:</p>
<pre>use Drupal\Core\Routing\CurrentRouteMatch; 
use Drupal\Core\Routing\LocalRedirectResponse; 
use Symfony\Component\HttpKernel\KernelEvents; 
use Drupal\Core\Url; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dispatching events</h1>
                </header>
            
            <article>
                
<p>Since we have discussed how to subscribe to events in Drupal 8, we should also take a look at how we can dispatch our own events. After all, the Symfony Event Dispatcher component is one of the principal vectors of extensibility in Drupal 8.</p>
<p>To demonstrate this, we will create an event to be dispatched whenever our <kbd>HelloWorldSalutation::getSalutation()</kbd> method is called. The purpose is to inform other modules that this has happened and potentially allow them to alter the message that comes out of the configuration object—not really a solid use case, but good enough to demonstrate how we can dispatch events.</p>
<p>The first thing that we will need to do is to create an event class that will be dispatched. It can go into the root of our module's namespace:</p>
<pre>namespace Drupal\hello_world; 
 
use Symfony\Component\EventDispatcher\Event; 
 
/** 
 * Event class to be dispatched from the HelloWorldSalutation service. 
 */ 
class SalutationEvent extends Event { 
 
  const EVENT = 'hello_world.salutation_event'; 
 
  /** 
   * The salutation message. 
   * 
   * @var string 
   */ 
  protected $message; 
 
  /** 
   * @return mixed 
   */ 
  public function getValue() { 
    return $this-&gt;message; 
  } 
 
  /** 
   * @param mixed $message 
   */ 
  public function setValue($message) { 
    $this-&gt;message = $message; 
  } 
}  </pre>
<p>The main purpose of this event class is that an instance of it will be used to transport the value of our salutation message. This is why we created the <kbd>$message</kbd> property on the class and added the getter and setter methods. Moreover, we use it to define a constant for the actual name of the event that will be dispatched. Finally, the class extends from the base <kbd>Event</kbd> class that comes with the Event Dispatcher component as a standard practice. We could also use that class directly, but we would not have our data stored in it as we do now.</p>
<p>Next, it's time to inject the Event Dispatcher service into our <kbd>HelloWorldSalutation</kbd> service. We have already injected <kbd>config.factory</kbd>, so we just need to add a new argument to the service definition:</p>
<pre>arguments: ['@config.factory', '@event_dispatcher'] </pre>
<p>Of course, we will also receive it in the constructor and store it as a class property:</p>
<pre>/** 
 * @var \Symfony\Component\EventDispatcher\EventDispatcherInterface 
 */ 
protected $eventDispatcher; 
 
/** 
 * HelloWorldSalutation constructor. 
 * 
 * @param \Drupal\Core\Config\ConfigFactoryInterface $config_factory 
 * @param \Symfony\Component\EventDispatcher\EventDispatcherInterface $eventDispatcher 
 */ 
public function __construct(ConfigFactoryInterface $config_factory, EventDispatcherInterface $eventDispatcher) { 
  $this-&gt;configFactory = $config_factory; 
  $this-&gt;eventDispatcher = $eventDispatcher; 
} </pre>
<p>We will also have the obligatory <em>use</em> statement for the <kbd>EventDispatcherInterface</kbd> at the top of the file:</p>
<pre>use Symfony\Component\EventDispatcher\EventDispatcherInterface;  </pre>
<p>Now, we can make use of the dispatcher. So instead of the following code inside the <kbd>getSalutation()</kbd> method:</p>
<pre>if ($salutation != "") { 
  return $salutation; 
}  </pre>
<p>We can have the following:</p>
<pre>if ($salutation != "") { 
  $event = new SalutationEvent(); 
  $event-&gt;setValue($salutation); 
  $event = $this-&gt;eventDispatcher-&gt;dispatch(SalutationEvent::EVENT, $event); 
  return $event-&gt;getValue(); 
}</pre>
<p>So with the above, we decided that if we are to return a salutation message from the configuration object, we want to inform other modules and allow them to change it. We first create an instance of our Event class and feed it the relevant data (the message). Then, we dispatch the named event and pass the event object along with it. The Event Dispatcher returns the event that has been dispatched with any changes that might have been applied to it by subscribers. Finally, we get the data from that instance and return it.</p>
<p>Pretty simple, isn't it? What can subscribers do? It's very similar to what we saw regarding the example on redirects in the preceding section. All a subscriber needs to do is listen for the <kbd>SalutationEvent::EVENT</kbd> event and do something based on that. The main thing that it can do is use the <kbd>setValue()</kbd> method on the received event object to change the salutation message. It can also use the <kbd>stopPropagation()</kbd> method from the base <kbd>Event</kbd> class to inform the Event Dispatcher to no longer trigger other listeners that have subscribed to this event.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered a great deal of info about the things you need to know when developing Drupal 8 modules. The first thing we did was create our very own module skeleton that can be installed on a Drupal 8 site. Then, we saw how to create a new page at a specific path (route) and show some basic data on that page. Nothing too complex, but enough to illustrate one of the most common tasks you will do as a module developer. We then took that to a new level and abstracted the logic for that data calculation into a service. Not only that, but we also saw how we can use that service and, more importantly, how we <em>should</em> use it. Next, we saw how we can work with the Form API in Drupal 8 to allow administrators to add some configuration to the site. A very important takeaway here was also that the Form API page in Drupal 8 will prove invaluable because you have many different types of form elements at your disposal. So, keep that close by. Also, since we talked about forms, we saw how we can alter existing forms defined by other modules—a useful technique for any module developer.</p>
<p>Next, we created our first custom block which allowed us to reuse our service and be more flexible with where we show our data.</p>
<p>Then, we looked at how to create URLs and links programmatically in Drupal 8. In the functionality we built in this module, we don't need any links, yet. However, it is a common practice to work with them, so we had to learn early how to generate links and work with URLs properly in Drupal 8.</p>
<p>In the last section, we explored the Symfony <em>Event Dispatcher</em> component, something that allows us to dispatch and subscribe to events. We saw some examples of how we can subscribe to one of the main Kernel events in order to redirect the page, but we also saw how to dispatch our own event. The latter was meant to allow subscribers to make changes to our data.</p>
<p>Most of the topics we covered in this chapter were meant to give you an initial boost and the tools to start developing modules in Drupal 8. They represent the absolute most common things—I believe—any new Drupal developer encounters and has to do.</p>
<p>In the next chapter, we will look at two important aspects most applications will need to use. One is logging—the better your site logs its errors and important actions, the easier it will be to debug and trace back issues. Another is mailing—websites usually need to send out emails to users in one way or another, so it's important that we see how that works in Drupal 8.</p>


            </article>

            
        </section>
    </body></html>