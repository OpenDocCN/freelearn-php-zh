<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;13.&#xA0;Debugging and Deploying"><div class="book" id="2BASE2-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch13" class="calibre1"/>Chapter 13. Debugging and Deploying</h1></div></div></div><p class="calibre9">One of the most important tasks when working with modern web applications is determining what went wrong during the development and runtime of our application. Without knowing what went wrong, it's impossible to determine the correct steps to correct the problem. Yii2 provides several tools and components that make the debugging of our applications painless and simple. In this chapter, we'll explore several different ways in which we can debug our applications. We'll also outline some of the best practices for the deployment of our Yii2 application once we've completed the development.</p></div>

<div class="book" title="Chapter&#xA0;13.&#xA0;Debugging and Deploying">
<div class="book" title="Debugging"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch13lvl1sec73" class="calibre1"/>Debugging</h1></div></div></div><p class="calibre9">
<span class="strong"><strong class="calibre2">Debugging</strong></span> is<a id="id684" class="calibre1"/> an important process in which we can discover what went wrong with our application. Whether we're solving a problem locally or trying to identify an issue in our production, our applications need to be configured to supply us with the required information to quickly and effectively identify and resolve issues as they arise. In this section, we'll cover how to enable logging within our application, how to benchmark certain sections of code and handler errors, and general debugging tools and guidelines.</p></div></div>

<div class="book" title="Chapter&#xA0;13.&#xA0;Debugging and Deploying">
<div class="book" title="Debugging">
<div class="book" title="Logging"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch13lvl2sec150" class="calibre1"/>Logging</h2></div></div></div><p class="calibre9">To help <a id="id685" class="calibre1"/>us debug our applications, Yii2 comes built with several different logging components and log methods that we can implement within our application. To get started with logging in Yii2, we first need to implement a log component within our application. Yii2 comes with several different components that we can implement in concert with one another or disjointedly.</p><div class="note"><table border="1" class="calibre16"><colgroup class="calibre17"><col class="calibre18"/><col class="calibre18"/><col class="calibre18"/></colgroup><thead class="calibre19"><tr class="calibre20"><th valign="bottom" class="calibre21">
<p class="calibre22">Logger Class</p>
</th><th valign="bottom" class="calibre21">
<p class="calibre22">Description</p>
</th><th valign="bottom" class="calibre21">
<p class="calibre22">Class Reference</p>
</th></tr></thead><tbody class="calibre23"><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\log\DbTarget</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Logs <a id="id686" class="indexterm"/>information to a database table</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<a class="indexterm" href="http://www.yiiframework.com/doc-2.0/yii-log-dbtarget.html">http://www.yiiframework.com/doc-2.0/yii-log-dbtarget.html</a>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\log\EmailTarget</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">On logging <a id="id687" class="indexterm"/>events, sends an email to a specified email address</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<a class="indexterm" href="http://www.yiiframework.com/doc-2.0/yii-log-emailtarget.html">http://www.yiiframework.com/doc-2.0/yii-log-emailtarget.html</a>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\log\FileTarget</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Logs events to <a id="id688" class="indexterm"/>a file</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<a class="indexterm" href="http://www.yiiframework.com/doc-2.0/yii-log-filetarget.html">http://www.yiiframework.com/doc-2.0/yii-log-filetarget.html</a>
</p>
</td></tr><tr class="calibre20"><td valign="top" class="calibre24">
<p class="calibre22">
<code class="literal">yii\log\SyslogTarget</code>
</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">Logs events using <a id="id689" class="indexterm"/>PHP's <code class="literal">syslog()</code> function</p>
</td><td valign="top" class="calibre24">
<p class="calibre22">
<a class="indexterm" href="http://www.yiiframework.com/doc-2.0/yii-log-syslogtarget.html">http://www.yiiframework.com/doc-2.0/yii-log-syslogtarget.html</a>
</p>
</td></tr></tbody></table></div><div class="note" title="Note"><h3 class="title2"><a id="tip199" class="calibre1"/>Tip</h3><p class="calibre9">Each of the previously listed loggers have slight variations in their configuration. For more information on how to specifically configure each log target, refer to the class reference for that logger class.</p></div><p class="calibre9">To<a id="id690" class="calibre1"/> enable a log target within our application, we first need to bootstrap the log component and then specify the logger target that we want to use within the components section of our application configuration, as shown in the following example:</p><div class="note"><pre class="programlisting">return [
    // [...],
    <code class="email">'bootstrap' =&gt; ['log'],</code>
    
    // [...],
    'components' =&gt; [
        // [...],
        <code class="email">'log' =&gt; [</code>
<code class="email">            'targets' =&gt; [</code>
<code class="email">                [</code>
<code class="email">                    'class' =&gt; 'yii\log\FileTarget',</code>
<code class="email">                    'levels' =&gt; ['error', 'warning'],</code>
<code class="email">                ]</code>
<code class="email">            ],</code>
<code class="email">        ],</code>
    ],
];</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip200" class="calibre1"/>Tip</h3><p class="calibre9">In the previous example, we enabled <code class="email">yii\log\FileTarget</code> by itself for any error and warning log events. Note that multiple loggers can be enabled concurrently by specifying additional loggers within the <code class="email">targets</code> array.</p></div><p class="calibre9">Each logging<a id="id691" class="calibre1"/> target can be configured to listen to certain events. Yii2 provides five distinct events that we can log to and several logging methods that we can add to our code:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Error</strong></span>: This is triggered by <code class="email">Yii:error()</code> when a regular error or a fatal error occurs. These types of events should be acted upon immediately as they indicate failure within the application.</li><li class="listitem"><span class="strong"><strong class="calibre2">Warning</strong></span>: This is triggered by <code class="email">Yii::warning()</code>. These events indicate that something went wrong within the application.</li><li class="listitem"><span class="strong"><strong class="calibre2">Info</strong></span>: This is triggered by <code class="email">Yii::info()</code>. Typically, these events are used to log something useful or interesting that has occurred.</li><li class="listitem"><span class="strong"><strong class="calibre2">Trace</strong></span>: This is triggered by <code class="email">Yii::trace()</code>, which is usually used during development to trace a particular piece of code.</li><li class="listitem"><span class="strong"><strong class="calibre2">Profile</strong></span>: This is triggered by <code class="email">Yii::beginProfile()</code> and <code class="email">Yii::endProfile()</code>.</li></ul></div><div class="note" title="Note"><h3 class="title2"><a id="note24" class="calibre1"/>Note</h3><p class="calibre9">Most of these methods are simply wrappers around <code class="email">Yii::log()</code>.</p></div><p class="calibre9">Each log target can be configured to listen to a specific set of events by specifying the <code class="email">level</code> property of that logger target, and by default, if the <code class="email">level</code> property is not specified, Yii2 will process messages of any severity.</p><p class="calibre9">Each log method shares a similar method signature:</p><div class="note"><pre class="programlisting">
<code class="email">function($message, $category='application')</code>
</pre></div><p class="calibre9">Yii2's log method will allow strings and complex data objects or arrays through the <code class="email">yii\helpers\VarDumper::export()</code> method. When logging information, it's important that you specify a category, as that category can be searched and filtered within our log. As shown in the method signature, Yii2 will log information to the <code class="email">application</code> category by default. When specifying a category, it's generally good to specify it in a hierarchical way, such as in a slash-like format:</p><div class="note"><pre class="programlisting">app\components\MyEvent</pre></div><p class="calibre9">Another effective format is to use the PHP magic method, <code class="email">__METHOD__</code>, which will return the namespace and method the logger was called in:</p><div class="note"><pre class="programlisting">app\components\MyEvent::myMethod</pre></div><p class="calibre9">Within <a id="id692" class="calibre1"/>our logger components, we can specify which categories we want our logger to handle by specifying the <code class="email">categories</code> parameter. The categories parameter can be configured to listen to specific categories such as <code class="email">yii\db\Connection</code>, but it can also be configured with wildcards. For instance, if we want to send an email anytime a category within <code class="email">yii\db</code> is called, we can configure the following logger target:</p><div class="note"><pre class="programlisting">return [
    // [...],
    'bootstrap' =&gt; ['log'],
    
    // [...],
    'components' =&gt; [
        // [...],
        'log' =&gt; [
            'targets' =&gt; [
                [
                    'class' =&gt; 'yii\log\EmailTarget',
                    'categories' =&gt; ['yii\db\*'],
                    'message' =&gt; [
                       'from' =&gt; ['systems@example.com'],
                       'to' =&gt; ['administrator@example.com'],
                       'subject' =&gt; 'Database errors for example.com',
                    ],
                ]
            ],
        ],
    ],
];
</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip201" class="calibre1"/>Tip</h3><p class="calibre9">If you decide to use email logging, you can quickly flood your inbox with multiple messages or even be rate-limited by your email provider. It's highly recommended that you specify only the most critical categories for email logging.</p></div><p class="calibre9">In situations where we're logging multiple categories, such as <code class="email">yii\web\HttpException</code>, we can also exclude certain categories from being logged by specifying the <code class="email">except</code> property. For instance, if we want to log all non-HTTP 404 exceptions, we<a id="id693" class="calibre1"/> can configure our logger as follows to accomplish this:</p><div class="note"><pre class="programlisting">
return [
    // [...],
    'bootstrap' =&gt; ['log'],
    
    // [...],
    'components' =&gt; [
        // [...],
        'log' =&gt; [
            'targets' =&gt; [
                [
                'class' =&gt; 'yii\log\FileTarget',
                'levels' =&gt; ['error', 'warning', 'info'],
                'categories' =&gt; ['yii\web\HttpException:*'],
                'except' =&gt; [
                    'yii\web\HttpException:404',
                ],
            ]
            ],
        ],
    ],
];</pre></div><p class="calibre9">Finally, within our application, loggers can be toggled on and off by setting the <code class="email">enabled</code> property of the logger target. To programmatically disable a logging target, we first need to specify a key for our logger target:</p><div class="note"><pre class="programlisting">return [
    // [...],
    'bootstrap' =&gt; ['log'],
    
    // [...],
    'components' =&gt; [
        // [...],
        'log' =&gt; [
            'targets' =&gt; [
                <span class="strong"><strong class="calibre2">'file' =&gt; [</strong></span>
<span class="strong"><strong class="calibre2">                 'class' =&gt; 'yii\log\FileTarget',</strong></span>
<span class="strong"><strong class="calibre2">                 'levels' =&gt; ['error', 'warning', 'info'],</strong></span>
<span class="strong"><strong class="calibre2">                 'categories' =&gt; ['yii\web\HttpException:*'],</strong></span>
<span class="strong"><strong class="calibre2">                 'except' =&gt; [</strong></span>
<span class="strong"><strong class="calibre2">                    'yii\web\HttpException:404',</strong></span>
<span class="strong"><strong class="calibre2">                ],</strong></span>
<span class="strong"><strong class="calibre2">            ]</strong></span>
            ],
        ],
    ],
];</pre></div><p class="calibre9">Then, within <a id="id694" class="calibre1"/>our code, we can temporarily disable our<code class="email"> file </code>target, as specified in the previous example, using the following code:</p><div class="note"><pre class="programlisting">Yii::$app-&gt;log-&gt;targets['file']-&gt;enabled = false;</pre></div></div></div></div>

<div class="book" title="Chapter&#xA0;13.&#xA0;Debugging and Deploying">
<div class="book" title="Debugging">
<div class="book" title="Benchmarking"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch13lvl2sec151" class="calibre1"/>Benchmarking</h2></div></div></div><p class="calibre9">Another<a id="id695" class="calibre1"/> tool that we can use to debug our applications is the profiler tool. The profile tool allows us to gain an insight into how long a certain piece of code takes to execute. To use the profiler, we simply need to wrap the code we want to examine in the following code block:</p><div class="note"><pre class="programlisting">Yii::beginProfile('myProfile');
    // Code inside this will be profiled
Yii::endProfile('myProfile');</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip202" class="calibre1"/>Tip</h3><p class="calibre9">The <code class="email">beginProfile()</code> and <code class="email">endProfile()</code> methods can be nested within another profiler section. The code within these methods will be outputted to your log targets for profiling. In production, you should disable profiling.</p></div></div></div></div>

<div class="book" title="Chapter&#xA0;13.&#xA0;Debugging and Deploying">
<div class="book" title="Debugging">
<div class="book" title="Error handling"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch13lvl2sec152" class="calibre1"/>Error handling</h2></div></div></div><p class="calibre9">By <a id="id696" class="calibre1"/>default, Yii2 has a fairly comprehensive error handler that will automatically catch and display all nonfatal PHP errors. The error handler can be an extremely powerful tool during development as it can provide complete stack traces in the event that something fails.</p><div class="mediaobject"><img src="../images/00060.jpeg" alt="Error handling" class="calibre10"/></div><p class="calibre11"> </p><div class="note" title="Note"><h3 class="title2"><a id="tip203" class="calibre1"/>Tip</h3><p class="calibre9">By default, the error handler is automatically enabled as part of our application, but it can be disabled by setting the <code class="email">YII_ENABLE_ERROR_HANDLER</code> constant within our bootstrap file to <code class="email">false</code>.</p></div><p class="calibre9">The <a id="id697" class="calibre1"/>error handler is configured within our main application configuration file, and it supports several different configuration options, as shown in the following example:</p><div class="note"><pre class="programlisting">return [
    // [...],
    'components' =&gt; [
        // [...],
        'errorHandler' =&gt; [
            'maxSourceLines' =&gt; 20,
            'errorAction' =&gt; 'site/error',
            'maxTraceSourceLines' =&gt; 13,
            // [...]
        ],
    ],
];</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip204" class="calibre1"/>Tip</h3><p class="calibre9">More <a id="id698" class="calibre1"/>information on the error handler and its properties can be found on the Yii2 class reference page at <a class="calibre1" href="http://www.yiiframework.com/doc-2.0/yii-web-errorhandler.html">http://www.yiiframework.com/doc-2.0/yii-web-errorhandler.html</a>.</p></div><p class="calibre9">By<a id="id699" class="calibre1"/> default, the error handler will use two views to display errors:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">@yii/views/errorHandler/error.php</code>: This will be used to display errors without a call stack and is the default view that is used when <code class="email">YII_DEBUG</code> is set to <code class="email">false</code></li><li class="listitem"><code class="email">@yii/views/errorHandler/exception.php</code>: This will be used when errors display a complete call stack</li></ul></div><p class="calibre9">We can define our own error view files by specifying the <code class="email">errorView</code> and <code class="email">exceptionView</code> properties of our error handler.</p><p class="calibre9">As an alternative to the default error page, as presented in the previous screenshot, errors can be redirected to a different action by specifying the <code class="email">errorAction</code> property of the error handler. We can then handle errors separately from our application by adding an errors action to our <code class="email">actions()</code> method and defining an <code class="email">actionError()</code> action within the specified controller:</p><div class="note"><pre class="programlisting">&lt;?php
namespace app\controllers;

use Yii;
use yii\web\Controller;

class SiteController extends Controller
{
    public function actions()
    {
        return [
            'error' =&gt; [
                'class' =&gt; 'yii\web\ErrorAction',
            ],
        ];
    }

   public function actionError()
    {
        $exception = Yii::$app-&gt;errorHandler-&gt;exception;
        if ($exception !== null) {
            return $this-&gt;render('error', ['exception' =&gt; $exception]);
        }
    }
}</pre></div><p class="calibre9">Our<a id="id700" class="calibre1"/> custom error handler page can then be created within our <code class="email">views/site/error.php</code> file.</p><div class="book" title="Handling errors within non HTML responses"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch13lvl3sec53" class="calibre1"/>Handling errors within non HTML responses</h3></div></div></div><p class="calibre9">When<a id="id701" class="calibre1"/> working with non-HTML responses such as JSON or XML, Yii2 will be presented as a simplified error response, as shown in the following example:</p><div class="note"><pre class="programlisting">{
    "name": "Not Found Exception",
    "message": "The requested resource was not found.",
    "code": 0,
    "status": 404
} </pre></div><p class="calibre9">In the event that you wish to display more debugging information in nonproduction environments, you can create a custom response handler by overwriting the <code class="email">on beforeSend</code> event of the response component. Our response handler can be rewritten as follows to achieve this:</p><div class="note"><pre class="programlisting">&lt;?php 
return [
    // [...],
    'components' =&gt; [
        // [...],
        'response' =&gt; [
            'format' =&gt; yii\web\Response::FORMAT_JSON,
            'charset'        =&gt; 'UTF-8',
            'on beforeSend'  =&gt; ['app\components\ResponseEvent', 'beforeSend']
        ],
        // [...]
    ]
];</pre></div><p class="calibre9">Our<a id="id702" class="calibre1"/> response handler class located at <code class="email">@app/components/ResponseEvent.php</code> can be written as follows to change the error behavior when <code class="email">YII_DEBUG</code> is set to <code class="email">true</code>:</p><div class="note"><pre class="programlisting">&lt;?php

namespace app\components;

use Yii;

/**
 * Event handler for response object
 */
class ResponseEvent extends yii\base\Event
{
    /**
     * Before Send event handler
     * @param yii\base\Event $event
     */
    public function beforeSend($event)
    {
        $response = $event-&gt;sender;

        if (\Yii::$app-&gt;request-&gt;getIsOptions())
        {
            $response-&gt;statusCode = 200;
            $response-&gt;data = null;
        }

        if ($response-&gt;data !== null)
        {
            $return = ($response-&gt;statusCode == 200 ? $response-&gt;data : $response-&gt;data['message']);

            $response-&gt;data = [
                'data'  =&gt; $return
            ];

            // Handle and display errors in the API for easy debugging
            $exception = \Yii::$app-&gt;errorHandler-&gt;exception;
            if ($exception &amp;&amp; get_class($exception) !== "yii\web\HttpException" &amp;&amp; !is_subclass_of($exception, 'yii\web\HttpException') &amp;&amp; YII_DEBUG)
            {
                $response-&gt;data['success'] = false;
                $response-&gt;data['exception'] = [
                    'message'   =&gt; $exception-&gt;getMessage(),
                    'file'      =&gt; $exception-&gt;getFile(),
                    'line'      =&gt; $exception-&gt;getLine(),
                    'trace'     =&gt; $exception-&gt;getTraceAsString()
                ];
            }
        }
    }
}</pre></div><p class="calibre9">Now<a id="id703" class="calibre1"/> when an error occurs, output similar to the following will be displayed, saving us the time taken to flip between our browser and our application log:</p><div class="note"><pre class="programlisting">{
    "data": "&lt;message&gt;",
    "success": false,
    "exception": {
        "message": "Invalid",
        "file": "/path/to/SiteController.php",
        "line": 48,
        "trace": "#0 [internal function]: app\\controllers\\SiteController-&gt;actionIndex()\n# ... {main}"
    }
}</pre></div></div></div></div></div>

<div class="book" title="Chapter&#xA0;13.&#xA0;Debugging and Deploying">
<div class="book" title="Debugging">
<div class="book" title="Debugging with the Yii2 debug extension"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch13lvl2sec153" class="calibre1"/>Debugging with the Yii2 debug extension</h2></div></div></div><p class="calibre9">Another <a id="id704" class="calibre1"/>powerful tool that we can use to debug our applications is the <code class="email">yii2-debug</code> extension. When enabled, the debug extension provides deep insights into every aspect of our request, ranging from logs, configurations, profiling, requests, asset bundles, and even emails sent by our application. With this tool, we can find out exactly what happened during a specific request.</p><p class="calibre9">To get started with using the <code class="email">yii2-debug</code> extension, we first need to install it as part of our composer dependencies:</p><div class="note"><pre class="programlisting"><span class="strong"><strong class="calibre2">composer require --dev --prefer-dist yiisoft/yii2-debug</strong></span>
</pre></div><p class="calibre9">After installing the package and running the composer update, we can configure the debug extension by adding the following to our <code class="email">config/web.php</code> configuration file:</p><div class="note"><pre class="programlisting">if (YII_DEBUG)
{ 
    $config['bootstrap'][] = 'debug';
    $config['modules']['debug'] = [
       'class' =&gt; 'yii\debug\Module',
       'allowedIPs' =&gt; ['*']
    ];
}</pre></div><p class="calibre9">After enabling the extension, we will be able to view it at the bottom of every view of our application.</p><div class="mediaobject"><img src="../images/00061.jpeg" alt="Debugging with the Yii2 debug extension" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre9">By default, the extension will show some basic things about our application; however, if we click<a id="id705" class="calibre1"/> on it, we can gain deep insights into every aspect of our application for a particular request.</p><div class="mediaobject"><img src="../images/00062.jpeg" alt="Debugging with the Yii2 debug extension" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre9">Alternatively, we can navigate to the <code class="email">/debug</code> endpoint of our application to view all the debug requests captured by the extension.</p><div class="mediaobject"><img src="../images/00063.jpeg" alt="Debugging with the Yii2 debug extension" class="calibre10"/></div><p class="calibre11"> </p></div></div></div>
<div class="book" title="Deploying" id="2C9D01-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch13lvl1sec74" class="calibre1"/>Deploying</h1></div></div></div><p class="calibre9">The final <a id="id706" class="calibre1"/>step in working with any Yii2 application is to move it to production and create a deployment strategy. There are many different tools that we can use to deploy our code, ranging from Bamboo, TravisCI, Jenkins, Capistrano, and even manual SSH deployments—just to name a few.</p><p class="calibre9">In general, however, there are several key concepts we should keep in mind when deploying our code:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Deployments should be automated and hands off. In order to be consistent, your deployments should be run by a tool or service that can run the same tasks every time. This eliminates any human error during the deployment and ensures consistency.</li><li class="listitem">Deployments should be fast, providing you with the ability to quickly push out new features and bug fixes.</li><li class="listitem">The actual building of your application (such as combined and compressed JavaScript, CSS, and other configurations) should occur on a build server and then be pushed to your production server in a pre-build manner. This ensures that your production servers don't have extra tools on them that may contain security vulnerabilities while also ensuring that your project is built with the same tools each time.</li><li class="listitem">Deployments should be reversible. If we deploy code and our application breaks, we should be able to easily roll back to a previous version.</li><li class="listitem">When deploying, we should remove any development tools, scripts, and our DCVS<a id="id707" class="calibre1"/> repository information. This ensures that in case there is a bug or security vulnerability in our code or our web server, this information is not exposed.</li><li class="listitem">Directories that contain logs of our other information (such as <code class="email">runtime</code>) should be stored in a persistent directory and then symlinked back into our project. This ensures that our logs and other data can persist across multiple deployments.</li><li class="listitem">Our deployments should be structured in such a way that there is no interruption of service. Typically, this is achieved by storing our deployment in a specific folder and then renaming or symlinking it into the directory our web server is pointed to. This ensures that our site does not experience an outage when we are making a change.</li><li class="listitem">When deploying new code, we should clear any application-specific caches, such as our schema cache, configuration cache, and PHP OPCache, to ensure that our new code changes take effect.</li><li class="listitem">Configuration files should never be committed to our DCVS as they contain database usernames, passwords, and other secret information. Consider storing this data as environment variables on the servers themselves, or encrypting them in a way such that only your production servers can decrypt and use the data.</li></ul></div><p class="calibre9">By following these general guidelines, we can ensure that our Yii2 applications are deployed seamlessly and easily.</p></div>
<div class="book" title="Summary" id="2D7TI1-ad3e09b384df46aea690d9c8897d5fe7"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch13lvl1sec75" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">In this chapter, we covered the basics of debugging and deploying our application. We covered how to set up logging and benchmarking and how to debug our application with the <code class="email">yii2-debug</code> extension while also detailing general guidelines and a few tools we can use to deploy our applications to production.</p><p class="calibre9">As you may expect, there's more to Yii2 than what is covered in this book. When developing Yii2 applications, remember that the Yii2 API documentation located at <a class="calibre1" href="http://www.yiiframework.com/doc-2.0/">http://www.yiiframework.com/doc-2.0/</a> provides excellent class reference documentation along with superb documentation on how to use many of the classes. Having reached the end of the book, you should feel confident in your knowledge and mastery of Yii2, and you should feel ready to take on any project with Yii2.</p></div></body></html>