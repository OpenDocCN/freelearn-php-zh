- en: Chapter 2. Building the Database with the Schema Builder Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hey hero!
  prefs: []
  type: TYPE_NORMAL
- en: 'Our development environment is now ready. No more worries, and a whole new
    world awaits: the hero left his home. Little by little, step by step, he is going
    forward toward the goal. The hero knows what is really important: to stay grounded.
    Having a good foundation helps. No big differences for an application: a well-designed
    database for your project is always the best start.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from this important assumption, the question naturally arises: is
    there a way, with Laravel, to deal with the design of a database before using
    it, maybe in a smart way that you can easily manage? The answer is, as you can
    imagine, yes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the Schema Builder class. A very important
    class that lets you design your entire database without writing a single SQL line!
    Quite impressive if you think about it, considering that it is quite possible
    that you will build your entire application on a SQL database without using SQL!
    We will analyze everything you can do with the class: creating, dropping, and
    updating a table; adding, removing, and renaming columns. Also, we will look at
    indexing in many ways: not only simple indexes but also unique indexes and foreign
    keys. Also, we are going to look at some methods that the Schema class provides
    in order to have a real and total control over everything. Sometimes, you will
    need to be sure about what exists in your database!'
  prefs: []
  type: TYPE_NORMAL
- en: After all this stuff, it is not be over yet. In fact, we will explore the world
    of **migrations**, which is something Laravel uses to do versioning of your database.
    Combining the power of the Schema class with the **migrations system** will give
    you great power over your data design. Also, it will be very easy to share your
    application with another new member of your team! You know that versioning is
    always the best choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important note before going forward: even if the Schema Builder class and
    migrations system are not tightly related to Eloquent, they easily create a database
    with a structure that fits perfectly for the Eloquent standards and conventions.
    Also, the Schema Builder and migrations system are a part of the `illuminate/database`
    ([https://github.com/illuminate/database](https://github.com/illuminate/database))
    package; yes, the same package from Eloquent! Let''s go.'
  prefs: []
  type: TYPE_NORMAL
- en: The Schema Builder class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database versioning with the migrations system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Schema Builder class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Schema Builder class is a tool that provides you with a *database agnostic*
    way to deal with your database design. The term *database agnostic* means that
    you will never have to worry about what database you are using: the only important
    thing is to use the right driver, as we saw before in the configuration part of
    the first chapter. So, if you think of switching your database system from SQLite
    to MySQL or SQL Server, don''t worry: you will always have your structure ready
    to be used.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first part of this chapter, we will use some simple routes. All you have
    to do is to add them to the `app/routes.php` file.
  prefs: []
  type: TYPE_NORMAL
- en: Working with tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the very, very basic phenomena. The following is the `Schema::create()`
    method that you can use to create a new table in your database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with tables](img/3634_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `create()` method accepts two parameters: the first method is the name
    of the table you want to create, and the second method is a closure where we will
    specify all the table fields. To be more precise, the closure parameter is a Blueprint
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When possible, I like to use type-hinting for a better code readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you may read something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry, it's the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also be able to rename a table: in this case, just use the `rename()`
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Finally, what about dropping a table? The method `drop()` is here for you.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: There is also a similar method, `dropIfExists()`, with the same syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As the awesomely expressive name suggests, the method drops the table only if
    it exists in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I often use this method instead of the simple `drop()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that if you want to check if a table exists, you can use the `hasTable()`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's take a look at how you can work with table columns.
  prefs: []
  type: TYPE_NORMAL
- en: Working with columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with columns is quite easy. First of all, let's see how to create new
    columns while adding a new table to the database.
  prefs: []
  type: TYPE_NORMAL
- en: As I told you before, we will use the `$table` parameter of `Schema::create()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `Blueprint $table` object has many methods, which are related to the creation
    of a single new column. You can easily see that all the methods' names represent
    a specific type of column. For example, `string` is the equivalent of `VARCHAR`
    on MySQL, and `integer` is the equivalent of `INT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also some utility methods: if you take a look at the very first code
    line of the closure, you will read an `increments()` method. Nothing complex,
    however, it just creates an `id` integer field (also setting it as a primary key)
    with `autoincrement`.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can see the `timestamps()` method in the last line. The Schema
    Builder class also has methods that are related to some Eloquent functionalities.
    In this case, the `timestamps()` method automatically creates two `DATETIME` equivalent
    fields, named `created_at` and `updated_at`. They can be quite useful if you want
    to track the time of insert and last update operations.
  prefs: []
  type: TYPE_NORMAL
- en: Now, why don't we make some tests, before going further?
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a matter of seconds: just create a new `GET` route in the `app/routes.php`
    file and add that `Schema::create()` method we saw like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create a table named `books` on our database. This table will have
    seven columns:'
  prefs: []
  type: TYPE_NORMAL
- en: The unique, primary key `id` as an integer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `title` column as a string (with 30 characters maximum)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pages_count` integer column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `price` decimal column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `description` text column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `created_at` and `updated_at` columns, created by the `timestamps()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's navigate to the `/create_books_table` URL and then open your Adminer (or
    whatever tool you like to deal with your database) to verify if everything went
    well.
  prefs: []
  type: TYPE_NORMAL
- en: This is the result!
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with columns](img/3634_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Good job! Let's take a look at the structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with columns](img/3634_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Perfect. Exactly what we wanted—without a single SQL line!
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that as we had done before for tables, we can also check if a specific
    column exists with the `hasColumn()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Columns' methods reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a quick reference for all the methods you can use on the Blueprint
    `$table` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->bigIncrements(''id'');` | Incrementing ID using a *big integer*
    equivalent |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->bigInteger(''votes'');` | `BIGINT` equivalent to the table |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->binary(''data'');` | `BLOB` equivalent to the table |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->boolean(''confirmed'');` | `BOOLEAN` equivalent to the table |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->char(''name'', 4);` | `CHAR` equivalent with the length |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->date(''created_at'');` | `DATE` equivalent to the table |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->dateTime(''created_at'');` | `DATETIME` equivalent to the table
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->decimal(''amount'', 5, 2);` | `DECIMAL` equivalent with a precision
    and scale |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->double(''column'', 15, 8);` | `DOUBLE` equivalent with precision,
    15 digits in total and 8 after the decimal point |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->enum(''choices'', [''foo'', ''bar'']);` | `ENUM` equivalent to the
    table |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->float(''amount'');` | `FLOAT` equivalent to the table |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->increments(''id'');` | Incrementing `ID` to the table (primary key)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->integer(''votes'');` | `INTEGER` equivalent to the table |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->json(''options'');` | `JSON` equivalent to the table |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->longText(''description'');` | `LONGTEXT` equivalent to the table
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->mediumInteger(''numbers'');` | `MEDIUMINT` equivalent to the table
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->mediumText(''description'');` | `MEDIUMTEXT` equivalent to the table
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->nullableTimestamps();` | Same as `timestamps()`, except the fact
    that this allows NULLs |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->smallInteger(''votes'');` | `SMALLINT` equivalent to the table |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->tinyInteger(''numbers'');` | `TINYINT` equivalent to the table |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->string(''email'');` | `VARCHAR` equivalent column |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->string(''name'', 100);` | `VARCHAR` equivalent with the length of
    a string |'
  prefs: []
  type: TYPE_TB
- en: '| `$table->text(''description'');` | `TEXT` equivalent to the table |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also find the complete reference in the Laravel official documentation,
    at the [http://laravel.com/docs/5.0/schema#adding-columns](http://laravel.com/docs/5.0/schema#adding-columns)
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Other $table object methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you take a look at the methods reference in the Laravel documentation, you
    will probably see some more than in the list you just saw.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first methods reference is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I already used this in the example. It creates the table timestamps `created_at`
    and `updated_at` columns, which are really useful if you want to track chronological
    information about the creation or update of a specific record.
  prefs: []
  type: TYPE_NORMAL
- en: Eloquent also manages timestamps columns automatically, so you don't have to
    worry about them in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important (and really similar) method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is used to add a `deleted_at` column to the desired table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, in your applications, it is really useful to keep some information
    even if you don''t want to show it to the final user. Think about an e-commerce
    orders'' history: the customer can choose to clean his history but you can''t
    allow him/her to physically delete records!'
  prefs: []
  type: TYPE_NORMAL
- en: The soft delete system solves this problem by adding a `deleted_at` column to
    a table in order to keep track of the delete date of a record.
  prefs: []
  type: TYPE_NORMAL
- en: Eloquent handles this system automatically, so you will be able to show a clean
    history to your customer and a complete list of orders to the shop administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you can see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This method adds a `remember_token` column.
  prefs: []
  type: TYPE_NORMAL
- en: The Laravel authentication system uses this token (a simple `VARCHAR 100`) to
    track the user status. It is used when you click on a **Remember Me** checkbox
    in the login page of your application.
  prefs: []
  type: TYPE_NORMAL
- en: There are also some methods you can chain after some table columns' definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to make a numeric column unsigned, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can use it with every numeric field (float, decimal, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also specify if a column is nullable with `nullable()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to specify a default value, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, you will need to use `BIGINT` or equivalent for your primary keys.
    If this is the case, use `bigIncrements()` instead of `increments()` (that uses
    `INT` or equivalent).
  prefs: []
  type: TYPE_NORMAL
- en: Updating tables and columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What? Yeah, I know what you are thinking—what if I have to add a book named
    The Awesome Super Life of the Marvelous Francesco Malatesta? It's a 60-character-long
    name!
  prefs: []
  type: TYPE_NORMAL
- en: Things change, so our database will have to change too. In a simple way, though.
    You will use the `table` method to update an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you can see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s make a little update. Create a new route in our routes file and
    name it `update_books_table`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we used the `change()` method right after the `string()` method.
    You will use `change()` on changing a column. If you simply want to add a new
    column to an existing table, just use this as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need the `doctrine/dbal` package to change columns. To obtain it,
    just add the `doctrine/dbal` to your `composer.json` file: 2.5.0 dependency.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, type `composer update` in your terminal and you are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Browse to the new URL and update the table. Now you will be able to add my awesome
    biography to your library in the future. Be proud of it.
  prefs: []
  type: TYPE_NORMAL
- en: Indexes and foreign keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take another step forward. Let's imagine that we are upgrading our application
    and we want to add the possibility to store book authors and related data. Also,
    we will give the possibility to the user to search a book by its title.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would have to do a couple of the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `authors` table to store authors' data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the `books` table to insert an external foreign key and an index to the
    `title` column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You already know how to update an existing table but what about indexing columns
    and creating foreign keys?
  prefs: []
  type: TYPE_NORMAL
- en: Adding indexes is quite easy with the Schema Builder. There are some expressive
    methods you can use.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, you can create a primary key with the `primary()` method. The
    parameter is the field you want to index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you need, you can specify an array of columns as a single index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The method `unique()` is used to create a unique key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if you want to add a simple index, you can use the `index()` method!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can also add a foreign key, if you need. In the following example, we are
    referencing the `author_id` column (on a hypothetical books table, maybe) to the
    `id` column in the `authors` table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Specifying `onDelete` and `onUpdate` constraint operations is not a problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t need your indexes anymore, you can easily drop them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The convention used to create an index name is `table-name_column-name_index-type`.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, now that you have a good overview of indexes with the Schema Builder
    class, let's add the new functionality to our example.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `GET` route. This time it is named `update_books_table_2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all! Let''s verify all with Adminer, as we did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Indexes and foreign keys](img/3634_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Yeah! It worked.
  prefs: []
  type: TYPE_NORMAL
- en: Database versioning with the migrations system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until this point, we worked with the Schema class using some simple routes.
    Quite easy, but it''s not a very good practice. You know: the single responsibility
    principle is not just a bedtime story.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, it''s not just about the code: the database too should have a fully functional
    version control system in order to keep track of all the updates and facilitate
    a new member in your team.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, the migrations system is here to help. You can see it as a version control
    system for your database, which is made up of many files. Every single one of
    these files is a class with the two methods: `up()` and `down()`. In the `up()`
    method, you will put all of your database construction logic. In the `down()`
    method, instead, you will put anything related to *rolling back* what you did
    in the `up()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating migrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's make the first basic example. We already have the `books` and `authors`
    tables. Imagine that we want to gather data about our books' publishers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new table called `publishers`, with at least the name of the publisher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new foreign key `publisher_id` in `books`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s make it with a migration file! Open your terminal and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for a few seconds and then go to the `database/migrations` folder. You
    will find a file named like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Open it. This class already has empty `up()` and `down()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, fill them with some Schema Builder instructions, like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Quite linear: what we do in `up()` we undo in `down()`. Of course, in the reverse
    order. Remember, it''s a *mirror* operation!'
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to run your migrations. All you have to do is run `php artisan
    migrate`; it loads all the migration classes and executes their `up()` method.
    In this way, you can build your database accordingly to your files. The execution
    order is decided by the file name. The file we just created is named `2015_03_06_105131_publishers_update.php`.
  prefs: []
  type: TYPE_NORMAL
- en: This means that this file was created on March 6, 2015 at 10:51:31\. As you
    can easily imagine, all the migrations will be executed in a chronological order.
    To make things clearer, delete the two `2014_10_12_000000_create_users_table.php`
    and `2014_10_12_100000_create_password_resets_table.php`. We won't need them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to your terminal and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for a few seconds and you will get an output really similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, return to your database. The update was done successfully, but we have
    another new table: the `migrations` table. Laravel uses this table to keep track
    of every update to the database. So, if you make another update to your application
    (with another new migration) and you run again the `php artisan migrate` command,
    you will execute only the new migrations and not the old ones. Exactly, version
    control, as I mentioned before.'
  prefs: []
  type: TYPE_NORMAL
- en: Rolling back migrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's try this *rollback* thing right now. In your terminal, type
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, go back to your database: no more `publishers` table and no more related
    foreign key! Cool!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Got it? Good. Now, type this again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Let's go forward.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You could get a `class not found` error while executing the `php artisan migrate`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry, just type `composer dump-autoload` in your terminal and try again!
    Even the best, sometimes, make mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: More examples, more migrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, what about another example?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine another feature. Alright, I have an idea: imagine that you want
    to specify some tags for every book you store with your application. This time
    you will have two things to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `tags` table to store tags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new `book_tag` table, as we are going to represent a many-to-many relationship.
    In this table, you will find the `book_id` and `tag_id`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First of all, create a new migration. Open your terminal and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, update the file as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I like to write in the `up()` and `down()` methods at the *same time*. In that
    example you just saw, I put in `up()` the `create` method for `tags`. Then, I
    passed to the `down()` method and added the `drop('tags')` method call. Then,
    I went back to `up()` and added the `book_tag` table, and I finally went to `down()`
    again to drop the `book_tag` table.
  prefs: []
  type: TYPE_NORMAL
- en: Working in this way helps me reduce distraction errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the terminal and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to your database. Open the `migrations` table to see what happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '![More examples, more migrations](img/3634_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have two different batches here. The first batch (*1*) is related to the
    publisher's update. The second batch (*2*) is related to the tags system update.
  prefs: []
  type: TYPE_NORMAL
- en: Why am I telling this to you? Who cares?
  prefs: []
  type: TYPE_NORMAL
- en: Well, when you type `php artisan migrate:rollback` in your terminal, the migrations
    system searches for the last batch and rolls it back. Not every batch, just the
    last batch. This means that the first `rollback` command will undo everything
    related to the tags system. If you type it again, the migrations system will also
    undo everything about the publisher's update.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the batch number, you can know how many iterations you did on your database.
    However, there is another important thing you need to know: regarding our example,
    if you roll back two times and then migrate again, both migration files will be
    grouped under batch 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you can roll back everything with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can roll back and migrate everything again with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you will get a list of all the migrated/rolled back migrations with
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: That's all! With this last command, we are also done with migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, the hero leaves his home. After the training and obtaining the right
    foundations, he is really ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the Schema Builder class and migrations system are not just about
    building your DB. In this chapter, you learned how to improve your database design
    method in a smarter way without the need for a single SQL line. Also, by using
    migrations, you are not going to need anymore to download database dumps or, in
    some *extreme* way, install any extra tool to deal with it.
  prefs: []
  type: TYPE_NORMAL
- en: Everything is done with the `artisan migrate` commands. However, as I already
    told you, this was just a *sample*. The real thing is arriving.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will go deeply and straight into the most important
    and *atomic* Eloquent component: the model.'
  prefs: []
  type: TYPE_NORMAL
- en: Are you ready, hero?
  prefs: []
  type: TYPE_NORMAL
