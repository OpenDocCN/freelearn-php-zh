- en: Chapter 2. Building the Database with the Schema Builder Class
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章. 使用 Schema Builder 类构建数据库
- en: Hey hero!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，英雄！
- en: 'Our development environment is now ready. No more worries, and a whole new
    world awaits: the hero left his home. Little by little, step by step, he is going
    forward toward the goal. The hero knows what is really important: to stay grounded.
    Having a good foundation helps. No big differences for an application: a well-designed
    database for your project is always the best start.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的开发环境现在已经准备好了。不再有担忧，一个全新的世界在等待：英雄离开了他的家。一步一步，他朝着目标前进。英雄知道什么才是真正重要的：保持脚踏实地。有一个良好的基础是有帮助的。对于应用程序来说，没有太大的区别：为你的项目设计一个良好的数据库始终是最好的开始。
- en: 'Starting from this important assumption, the question naturally arises: is
    there a way, with Laravel, to deal with the design of a database before using
    it, maybe in a smart way that you can easily manage? The answer is, as you can
    imagine, yes.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个重要的假设开始，问题自然而然地产生：在使用 Laravel 之前，是否有处理数据库设计的方法，也许是一种聪明的方法，你可以轻松管理？答案是，正如你所想象的那样，是的。
- en: 'In this chapter, we will look at the Schema Builder class. A very important
    class that lets you design your entire database without writing a single SQL line!
    Quite impressive if you think about it, considering that it is quite possible
    that you will build your entire application on a SQL database without using SQL!
    We will analyze everything you can do with the class: creating, dropping, and
    updating a table; adding, removing, and renaming columns. Also, we will look at
    indexing in many ways: not only simple indexes but also unique indexes and foreign
    keys. Also, we are going to look at some methods that the Schema class provides
    in order to have a real and total control over everything. Sometimes, you will
    need to be sure about what exists in your database!'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将探讨 Schema Builder 类。一个非常重要的类，它让你能够不写一行 SQL 就设计整个数据库！如果你考虑一下，这确实很令人印象深刻，考虑到你完全可能在没有使用
    SQL 的情况下构建整个基于 SQL 的数据库！我们将分析你可以使用这个类做的一切：创建、删除和更新表；添加、删除和重命名列。我们还将从许多方面探讨索引：不仅包括简单的索引，还包括唯一索引和外键。此外，我们还将探讨
    Schema 类提供的一些方法，以便对一切拥有真正的和完全的控制。有时，你需要确保你的数据库中存在什么！
- en: After all this stuff, it is not be over yet. In fact, we will explore the world
    of **migrations**, which is something Laravel uses to do versioning of your database.
    Combining the power of the Schema class with the **migrations system** will give
    you great power over your data design. Also, it will be very easy to share your
    application with another new member of your team! You know that versioning is
    always the best choice.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之后，事情还没有结束。事实上，我们将探索**迁移**的世界，这是 Laravel 用于对数据库进行版本控制的方法。结合 Schema 类和**迁移系统**的力量，将赋予你对数据设计极大的控制权。此外，将你的应用程序与团队的新成员共享将变得非常容易！你知道版本控制始终是最好的选择。
- en: 'An important note before going forward: even if the Schema Builder class and
    migrations system are not tightly related to Eloquent, they easily create a database
    with a structure that fits perfectly for the Eloquent standards and conventions.
    Also, the Schema Builder and migrations system are a part of the `illuminate/database`
    ([https://github.com/illuminate/database](https://github.com/illuminate/database))
    package; yes, the same package from Eloquent! Let''s go.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前的一个重要注意事项：即使 Schema Builder 类和迁移系统与 Eloquent 并没有紧密相关，它们也能轻松地创建一个结构完美适合
    Eloquent 标准和约定的数据库。此外，Schema Builder 和迁移系统是 `illuminate/database` ([https://github.com/illuminate/database](https://github.com/illuminate/database))
    包的一部分；是的，就是 Eloquent 的同一个包！让我们开始吧。
- en: The Schema Builder class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Schema Builder 类
- en: Database versioning with the migrations system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迁移系统进行数据库版本控制
- en: The Schema Builder class
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Schema Builder 类
- en: 'The Schema Builder class is a tool that provides you with a *database agnostic*
    way to deal with your database design. The term *database agnostic* means that
    you will never have to worry about what database you are using: the only important
    thing is to use the right driver, as we saw before in the configuration part of
    the first chapter. So, if you think of switching your database system from SQLite
    to MySQL or SQL Server, don''t worry: you will always have your structure ready
    to be used.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Schema Builder 类是一个工具，它为你提供了一个*数据库无关*的方式来处理你的数据库设计。术语*数据库无关*意味着你永远不必担心你使用的是哪种数据库：唯一重要的是使用正确的驱动程序，就像我们在第一章的配置部分所看到的那样。所以，如果你考虑将你的数据库系统从
    SQLite 切换到 MySQL 或 SQL Server，不用担心：你总是有你的结构准备好使用。
- en: In the first part of this chapter, we will use some simple routes. All you have
    to do is to add them to the `app/routes.php` file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们将使用一些简单的路由。你所要做的就是将它们添加到 `app/routes.php` 文件中。
- en: Working with tables
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理表
- en: 'Let''s start with the very, very basic phenomena. The following is the `Schema::create()`
    method that you can use to create a new table in your database:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本的物理现象开始。以下是你可以在数据库中创建新表的 `Schema::create()` 方法：
- en: '![Working with tables](img/3634_02_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![处理表](img/3634_02_01.jpg)'
- en: 'The `create()` method accepts two parameters: the first method is the name
    of the table you want to create, and the second method is a closure where we will
    specify all the table fields. To be more precise, the closure parameter is a Blueprint
    object.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`create()` 方法接受两个参数：第一个参数是你想要创建的表名，第二个参数是一个闭包，我们将在这里指定所有表字段。更准确地说，闭包参数是一个 Blueprint
    对象。'
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When possible, I like to use type-hinting for a better code readability.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当可能时，我喜欢使用类型提示来提高代码的可读性。
- en: 'So, you may read something like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能读到如下内容：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Don't worry, it's the same.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，它是一样的。
- en: 'You will also be able to rename a table: in this case, just use the `rename()`
    method.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将能够重命名一个表：在这种情况下，只需使用 `rename()` 方法。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Finally, what about dropping a table? The method `drop()` is here for you.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于删除表怎么办？`drop()` 方法就是为你准备的。
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There is also a similar method, `dropIfExists()`, with the same syntax.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个类似的方法，`dropIfExists()`，语法相同。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As the awesomely expressive name suggests, the method drops the table only if
    it exists in the database.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如令人惊叹的表达性名称所暗示的，该方法仅在表存在于数据库中时才会删除表。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I often use this method instead of the simple `drop()` method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常使用这个方法而不是简单的 `drop()` 方法。
- en: 'Remember that if you want to check if a table exists, you can use the `hasTable()`
    method, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你想检查一个表是否存在，你可以使用 `hasTable()` 方法，如下所示：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, let's take a look at how you can work with table columns.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何处理表列。
- en: Working with columns
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理列
- en: Working with columns is quite easy. First of all, let's see how to create new
    columns while adding a new table to the database.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 处理列相当简单。首先，让我们看看在向数据库添加新表时如何创建新列。
- en: As I told you before, we will use the `$table` parameter of `Schema::create()`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前告诉你的，我们将使用 `Schema::create()` 的 `$table` 参数。
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Blueprint $table` object has many methods, which are related to the creation
    of a single new column. You can easily see that all the methods' names represent
    a specific type of column. For example, `string` is the equivalent of `VARCHAR`
    on MySQL, and `integer` is the equivalent of `INT`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Blueprint $table` 对象有许多方法，这些方法与创建单个新列有关。你可以很容易地看到所有方法的名字代表了一种特定的列类型。例如，`string`
    是 MySQL 中的 `VARCHAR` 的等价物，而 `integer` 是 `INT` 的等价物。'
- en: 'There are also some utility methods: if you take a look at the very first code
    line of the closure, you will read an `increments()` method. Nothing complex,
    however, it just creates an `id` integer field (also setting it as a primary key)
    with `autoincrement`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些实用方法：如果你查看闭包的第一个代码行，你会看到一个 `increments()` 方法。然而，这并不复杂，它只是创建了一个带有 `autoincrement`
    的 `id` 整数字段（并将其设置为主键）。
- en: Finally, you can see the `timestamps()` method in the last line. The Schema
    Builder class also has methods that are related to some Eloquent functionalities.
    In this case, the `timestamps()` method automatically creates two `DATETIME` equivalent
    fields, named `created_at` and `updated_at`. They can be quite useful if you want
    to track the time of insert and last update operations.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在最后一行看到 `timestamps()` 方法。Schema Builder 类还有一些与 Eloquent 功能相关的方法。在这种情况下，`timestamps()`
    方法自动创建了两个 `DATETIME` 等效字段，分别命名为 `created_at` 和 `updated_at`。如果你想要跟踪插入和最后更新操作的时间，它们可能非常有用。
- en: Now, why don't we make some tests, before going further?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们继续前进之前，为什么不进行一些测试呢？
- en: 'It''s a matter of seconds: just create a new `GET` route in the `app/routes.php`
    file and add that `Schema::create()` method we saw like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这只需要几秒钟：只需在 `app/routes.php` 文件中创建一个新的 `GET` 路由，并添加我们看到的 `Schema::create()`
    方法，如下所示：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will create a table named `books` on our database. This table will have
    seven columns:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在数据库中创建一个名为 `books` 的表。这个表将包含七个列：
- en: The unique, primary key `id` as an integer
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一的主键 `id` 是一个整数
- en: The `title` column as a string (with 30 characters maximum)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title` 列作为一个字符串（最多30个字符）'
- en: The `pages_count` integer column
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pages_count` 整数列'
- en: The `price` decimal column
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`price` 小数列'
- en: The `description` text column
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description` 文本列'
- en: The `created_at` and `updated_at` columns, created by the `timestamps()` method
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 `timestamps()` 方法创建的 `created_at` 和 `updated_at` 字段
- en: Let's navigate to the `/create_books_table` URL and then open your Adminer (or
    whatever tool you like to deal with your database) to verify if everything went
    well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导航到 `/create_books_table` URL，然后打开你的 Adminer（或你喜欢的任何数据库处理工具）来验证是否一切顺利。
- en: This is the result!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是结果！
- en: '![Working with columns](img/3634_02_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![处理列](img/3634_02_02.jpg)'
- en: Good job! Let's take a look at the structure.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！让我们看看结构。
- en: '![Working with columns](img/3634_02_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![处理列](img/3634_02_03.jpg)'
- en: Perfect. Exactly what we wanted—without a single SQL line!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。正是我们想要的——没有一行 SQL 代码！
- en: 'Note that as we had done before for tables, we can also check if a specific
    column exists with the `hasColumn()` method:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，就像我们之前为表所做的那样，我们也可以使用 `hasColumn()` 方法来检查是否存在特定的列：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Columns' methods reference
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列的方法参考
- en: 'Here''s a quick reference for all the methods you can use on the Blueprint
    `$table` instance:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是所有可以在 Blueprint `$table` 实例上使用的所有方法的快速参考：
- en: '| Method | Description |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `$table->bigIncrements(''id'');` | Incrementing ID using a *big integer*
    equivalent |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `$table->bigIncrements(''id'');` | 使用 *大整数* 等价项进行 ID 增量 |'
- en: '| `$table->bigInteger(''votes'');` | `BIGINT` equivalent to the table |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `$table->bigInteger(''votes'');` | `BIGINT` 等价于表中的字段 |'
- en: '| `$table->binary(''data'');` | `BLOB` equivalent to the table |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `$table->binary(''data'');` | `BLOB` 等价于表中的字段 |'
- en: '| `$table->boolean(''confirmed'');` | `BOOLEAN` equivalent to the table |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `$table->boolean(''confirmed'');` | `BOOLEAN` 等价于表中的字段 |'
- en: '| `$table->char(''name'', 4);` | `CHAR` equivalent with the length |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `$table->char(''name'', 4);` | `CHAR` 等价，长度为 |'
- en: '| `$table->date(''created_at'');` | `DATE` equivalent to the table |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `$table->date(''created_at'');` | `DATE` 等价于表中的字段 |'
- en: '| `$table->dateTime(''created_at'');` | `DATETIME` equivalent to the table
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `$table->dateTime(''created_at'');` | `DATETIME` 等价于表中的字段 |'
- en: '| `$table->decimal(''amount'', 5, 2);` | `DECIMAL` equivalent with a precision
    and scale |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `$table->decimal(''amount'', 5, 2);` | `DECIMAL` 等价，具有精度和小数位数 |'
- en: '| `$table->double(''column'', 15, 8);` | `DOUBLE` equivalent with precision,
    15 digits in total and 8 after the decimal point |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `$table->double(''column'', 15, 8);` | `DOUBLE` 等价，精度为总精度15位，小数点后8位 |'
- en: '| `$table->enum(''choices'', [''foo'', ''bar'']);` | `ENUM` equivalent to the
    table |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `$table->enum(''choices'', [''foo'', ''bar'']);` | `ENUM` 等价于表中的字段 |'
- en: '| `$table->float(''amount'');` | `FLOAT` equivalent to the table |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `$table->float(''amount'');` | `FLOAT` 等价于表中的字段 |'
- en: '| `$table->increments(''id'');` | Incrementing `ID` to the table (primary key)
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `$table->increments(''id'');` | 将 `ID` 增量到表中（主键） |'
- en: '| `$table->integer(''votes'');` | `INTEGER` equivalent to the table |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `$table->integer(''votes'');` | `INTEGER` 等价于表中的字段 |'
- en: '| `$table->json(''options'');` | `JSON` equivalent to the table |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `$table->json(''options'');` | `JSON` 等价于表中的字段 |'
- en: '| `$table->longText(''description'');` | `LONGTEXT` equivalent to the table
    |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `$table->longText(''description'');` | `LONGTEXT` 等价于表中的字段 |'
- en: '| `$table->mediumInteger(''numbers'');` | `MEDIUMINT` equivalent to the table
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `$table->mediumInteger(''numbers'');` | `MEDIUMINT` 等价于表中的字段 |'
- en: '| `$table->mediumText(''description'');` | `MEDIUMTEXT` equivalent to the table
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `$table->mediumText(''description'');` | `MEDIUMTEXT` 等价于表中的字段 |'
- en: '| `$table->nullableTimestamps();` | Same as `timestamps()`, except the fact
    that this allows NULLs |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `$table->nullableTimestamps();` | 与 `timestamps()` 相同，但允许 NULL |'
- en: '| `$table->smallInteger(''votes'');` | `SMALLINT` equivalent to the table |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `$table->smallInteger(''votes'');` | `SMALLINT` 等价于表中的字段 |'
- en: '| `$table->tinyInteger(''numbers'');` | `TINYINT` equivalent to the table |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `$table->tinyInteger(''numbers'');` | `TINYINT` 等价于表中的字段 |'
- en: '| `$table->string(''email'');` | `VARCHAR` equivalent column |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `$table->string(''email'');` | `VARCHAR` 等价列 |'
- en: '| `$table->string(''name'', 100);` | `VARCHAR` equivalent with the length of
    a string |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `$table->string(''name'', 100);` | `VARCHAR` 等价，字符串长度为 |'
- en: '| `$table->text(''description'');` | `TEXT` equivalent to the table |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `$table->text(''description'');` | `TEXT` 等价于表中的字段 |'
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also find the complete reference in the Laravel official documentation,
    at the [http://laravel.com/docs/5.0/schema#adding-columns](http://laravel.com/docs/5.0/schema#adding-columns)
    page.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 Laravel 官方文档的 [http://laravel.com/docs/5.0/schema#adding-columns](http://laravel.com/docs/5.0/schema#adding-columns)
    页面找到完整的参考。
- en: Other $table object methods
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他 $table 对象方法
- en: If you take a look at the methods reference in the Laravel documentation, you
    will probably see some more than in the list you just saw.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 Laravel 文档中的方法参考，你可能会看到一些你刚才看到的列表中没有的内容。
- en: 'The first methods reference is:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法参考是：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I already used this in the example. It creates the table timestamps `created_at`
    and `updated_at` columns, which are really useful if you want to track chronological
    information about the creation or update of a specific record.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在示例中使用了这个方法。它创建了一个包含 `created_at` 和 `updated_at` 列的表，如果你想要跟踪特定记录的创建或更新时间，这些列非常有用。
- en: Eloquent also manages timestamps columns automatically, so you don't have to
    worry about them in your code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent 还会自动管理时间戳列，所以你不需要在你的代码中担心它们。
- en: 'Another important (and really similar) method is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要（并且非常相似）的方法如下：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is used to add a `deleted_at` column to the desired table.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它用于向目标表添加一个 `deleted_at` 列。
- en: 'Sometimes, in your applications, it is really useful to keep some information
    even if you don''t want to show it to the final user. Think about an e-commerce
    orders'' history: the customer can choose to clean his history but you can''t
    allow him/her to physically delete records!'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在你的应用程序中，保留一些信息即使你不想向最终用户展示也是非常有用的。想想电子商务订单的历史记录：客户可以选择清理他的历史记录，但你不能允许他/她物理删除记录！
- en: The soft delete system solves this problem by adding a `deleted_at` column to
    a table in order to keep track of the delete date of a record.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 软删除系统通过向表中添加一个 `deleted_at` 列来跟踪记录的删除日期，从而解决了这个问题。
- en: Eloquent handles this system automatically, so you will be able to show a clean
    history to your customer and a complete list of orders to the shop administrator.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent 会自动处理这个系统，所以你将能够向客户展示一个干净的历史记录，并向商店管理员展示完整的订单列表。
- en: 'Next, you can see this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以看到这个：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method adds a `remember_token` column.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法添加一个 `remember_token` 列。
- en: The Laravel authentication system uses this token (a simple `VARCHAR 100`) to
    track the user status. It is used when you click on a **Remember Me** checkbox
    in the login page of your application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 认证系统使用这个令牌（一个简单的 `VARCHAR 100`）来跟踪用户状态。当你在应用程序的登录页面点击 **记住我** 复选框时，它会用到这个令牌。
- en: There are also some methods you can chain after some table columns' definitions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些表格列定义之后，还有一些你可以链式调用的方法。
- en: 'If you want to make a numeric column unsigned, use the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使一个数值列无符号，可以使用以下方法：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Of course, you can use it with every numeric field (float, decimal, and so on).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以将它与每个数值字段（浮点数、十进制数等）一起使用。
- en: 'You can also specify if a column is nullable with `nullable()`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `nullable()` 来指定一个列是否可以为空：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you want to specify a default value, you can use the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要指定一个默认值，可以使用以下方法：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Sometimes, you will need to use `BIGINT` or equivalent for your primary keys.
    If this is the case, use `bigIncrements()` instead of `increments()` (that uses
    `INT` or equivalent).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能需要为你的主键使用 `BIGINT` 或等效类型。如果是这种情况，请使用 `bigIncrements()` 而不是 `increments()`（它使用
    `INT` 或等效类型）。
- en: Updating tables and columns
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新表格和列
- en: What? Yeah, I know what you are thinking—what if I have to add a book named
    The Awesome Super Life of the Marvelous Francesco Malatesta? It's a 60-character-long
    name!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？是的，我知道你在想什么——如果我必须添加一个名为《了不起的弗朗切斯科·马拉泰斯塔的超级精彩生活》的书名怎么办？这是一个60个字符长的名字！
- en: Things change, so our database will have to change too. In a simple way, though.
    You will use the `table` method to update an existing one.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 事情会变化，所以我们的数据库也必须随之改变。简单来说，你会使用 `table` 方法来更新现有的表格。
- en: 'Here you can see an example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到一个示例：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'So, let''s make a little update. Create a new route in our routes file and
    name it `update_books_table`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们进行一点更新。在我们的路由文件中创建一个新的路由，并将其命名为 `update_books_table`：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note that we used the `change()` method right after the `string()` method.
    You will use `change()` on changing a column. If you simply want to add a new
    column to an existing table, just use this as usual:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 `string()` 方法之后立即使用了 `change()` 方法。你将在更改列时使用 `change()`。如果你只是想向现有表中添加一个新列，只需像平常一样使用它：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You will need the `doctrine/dbal` package to change columns. To obtain it,
    just add the `doctrine/dbal` to your `composer.json` file: 2.5.0 dependency.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要 `doctrine/dbal` 包来更改列。要获取它，只需将 `doctrine/dbal` 添加到你的 `composer.json` 文件中的
    2.5.0 依赖项。
- en: Then, type `composer update` in your terminal and you are good to go.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你的终端中输入 `composer update`，然后你就可以开始了。
- en: Browse to the new URL and update the table. Now you will be able to add my awesome
    biography to your library in the future. Be proud of it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到新的URL并更新表格。现在你将能够在未来将我的精彩传记添加到你的图书馆中。为此感到自豪吧。
- en: Indexes and foreign keys
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引和外键
- en: Let's take another step forward. Let's imagine that we are upgrading our application
    and we want to add the possibility to store book authors and related data. Also,
    we will give the possibility to the user to search a book by its title.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再向前迈一步。让我们想象一下，我们正在升级我们的应用程序，并希望添加存储书籍作者和相关数据的功能。此外，我们还将给用户提供通过书名搜索书籍的可能性。
- en: 'We would have to do a couple of the following things:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要做以下几件事情：
- en: Create the `authors` table to store authors' data
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`authors`表以存储作者数据
- en: Update the `books` table to insert an external foreign key and an index to the
    `title` column
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`books`表，插入一个外部外键和一个索引到`title`列
- en: You already know how to update an existing table but what about indexing columns
    and creating foreign keys?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何更新现有的表，但关于索引列和创建外键呢？
- en: Adding indexes is quite easy with the Schema Builder. There are some expressive
    methods you can use.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Schema Builder添加索引相当简单。有一些表达性的方法你可以使用。
- en: First of all, you can create a primary key with the `primary()` method. The
    parameter is the field you want to index.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用`primary()`方法创建一个主键。参数是你想要索引的字段。
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you need, you can specify an array of columns as a single index.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要，你可以指定一个列的数组作为单个索引。
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The method `unique()` is used to create a unique key:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`unique()`方法来创建一个唯一键：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, if you want to add a simple index, you can use the `index()` method!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你想添加一个简单的索引，你可以使用`index()`方法！
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can also add a foreign key, if you need. In the following example, we are
    referencing the `author_id` column (on a hypothetical books table, maybe) to the
    `id` column in the `authors` table.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你也可以添加外键。在下面的例子中，我们正在将假设的书籍表中的`author_id`列（可能）引用到`authors`表中的`id`列。
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Specifying `onDelete` and `onUpdate` constraint operations is not a problem.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 指定`onDelete`和`onUpdate`约束操作不是问题。
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you don''t need your indexes anymore, you can easily drop them:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不再需要你的索引，你可以轻松地删除它们：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The convention used to create an index name is `table-name_column-name_index-type`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 创建索引名称的约定是`table-name_column-name_index-type`。
- en: Alright, now that you have a good overview of indexes with the Schema Builder
    class, let's add the new functionality to our example.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在你对Schema Builder类中的索引有了很好的了解，让我们给我们的示例添加新的功能。
- en: Create a new `GET` route. This time it is named `update_books_table_2`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`GET`路由。这次它被命名为`update_books_table_2`。
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That''s all! Let''s verify all with Adminer, as we did before:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！让我们用Adminer验证所有内容，就像我们之前做的那样：
- en: '![Indexes and foreign keys](img/3634_02_04.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![索引和外键](img/3634_02_04.jpg)'
- en: Yeah! It worked.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 哟！它成功了。
- en: Database versioning with the migrations system
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迁移系统进行数据库版本控制
- en: 'Until this point, we worked with the Schema class using some simple routes.
    Quite easy, but it''s not a very good practice. You know: the single responsibility
    principle is not just a bedtime story.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用Schema类和一些简单的路由进行工作。相当简单，但这并不是一个好的实践。你知道：单一责任原则不仅仅是一个睡前故事。
- en: 'Also, it''s not just about the code: the database too should have a fully functional
    version control system in order to keep track of all the updates and facilitate
    a new member in your team.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这不仅仅关乎代码：数据库也应该有一个功能齐全的版本控制系统，以便跟踪所有更新并帮助新成员加入你的团队。
- en: 'Well, the migrations system is here to help. You can see it as a version control
    system for your database, which is made up of many files. Every single one of
    these files is a class with the two methods: `up()` and `down()`. In the `up()`
    method, you will put all of your database construction logic. In the `down()`
    method, instead, you will put anything related to *rolling back* what you did
    in the `up()` method.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，迁移系统就在这里帮助你。你可以把它看作是你数据库的版本控制系统，它由许多文件组成。这些文件中的每一个都是一个类，包含两个方法：`up()`和`down()`。在`up()`方法中，你会放置所有数据库构建逻辑。而在`down()`方法中，你将放置与在`up()`方法中执行的操作相关的任何回滚操作。
- en: Creating migrations
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建迁移
- en: Let's make the first basic example. We already have the `books` and `authors`
    tables. Imagine that we want to gather data about our books' publishers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制作第一个基本示例。我们已经有`books`和`authors`表。想象一下，我们想要收集关于我们书籍出版者的数据。
- en: 'We will have to:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不：
- en: Create a new table called `publishers`, with at least the name of the publisher
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`publishers`的新表，至少包含出版者的名称
- en: Create a new foreign key `publisher_id` in `books`
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`books`表中创建一个新的外键`publisher_id`
- en: 'Let''s make it with a migration file! Open your terminal and type the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过迁移文件来实现！打开你的终端并输入以下命令：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Wait for a few seconds and then go to the `database/migrations` folder. You
    will find a file named like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几秒钟，然后转到`database/migrations`文件夹。你将找到一个类似这样的文件：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Open it. This class already has empty `up()` and `down()` methods:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 打开它。这个类已经有了空的`up()`和`down()`方法：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, fill them with some Schema Builder instructions, like this.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用一些Schema Builder指令填充它们，就像这样。
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Quite linear: what we do in `up()` we undo in `down()`. Of course, in the reverse
    order. Remember, it''s a *mirror* operation!'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 非常线性：我们在`up()`中做的，我们在`down()`中撤销。当然，顺序相反。记住，这是一个*镜像*操作！
- en: Now, it's time to run your migrations. All you have to do is run `php artisan
    migrate`; it loads all the migration classes and executes their `up()` method.
    In this way, you can build your database accordingly to your files. The execution
    order is decided by the file name. The file we just created is named `2015_03_06_105131_publishers_update.php`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候运行你的迁移了。你所要做的就是运行`php artisan migrate`；它加载所有迁移类并执行它们的`up()`方法。这样，你可以根据你的文件构建你的数据库。执行顺序由文件名决定。我们刚刚创建的文件名为`2015_03_06_105131_publishers_update.php`。
- en: This means that this file was created on March 6, 2015 at 10:51:31\. As you
    can easily imagine, all the migrations will be executed in a chronological order.
    To make things clearer, delete the two `2014_10_12_000000_create_users_table.php`
    and `2014_10_12_100000_create_password_resets_table.php`. We won't need them.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这个文件是在2015年3月6日10:51:31创建的。正如你可以轻易想象的，所有的迁移都将按时间顺序执行。为了使事情更清晰，删除两个`2014_10_12_000000_create_users_table.php`和`2014_10_12_100000_create_password_resets_table.php`。我们不需要它们。
- en: 'Return to your terminal and type:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 回到你的终端并输入：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Wait for a few seconds and you will get an output really similar to the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几秒钟，你将得到一个与以下输出非常相似的结果：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, return to your database. The update was done successfully, but we have
    another new table: the `migrations` table. Laravel uses this table to keep track
    of every update to the database. So, if you make another update to your application
    (with another new migration) and you run again the `php artisan migrate` command,
    you will execute only the new migrations and not the old ones. Exactly, version
    control, as I mentioned before.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到你的数据库。更新已经成功完成，但我们还有一个新的表：`migrations`表。Laravel使用这个表来跟踪数据库的每一次更新。所以，如果你对你的应用程序（通过另一个新的迁移）进行另一次更新，并且再次运行`php
    artisan migrate`命令，你将只执行新的迁移，而不是旧的迁移。没错，就像我之前提到的，这是版本控制。
- en: Rolling back migrations
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回滚迁移
- en: Let's try this *rollback* thing right now. In your terminal, type
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在尝试这个`rollback`操作。在你的终端中输入
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, go back to your database: no more `publishers` table and no more related
    foreign key! Cool!'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，回到你的数据库：没有更多的`publishers`表和没有更多的相关外键！太酷了！
- en: 'Got it? Good. Now, type this again:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 明白了？好。现在，再次输入这个：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let's go forward.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进。
- en: Tip
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You could get a `class not found` error while executing the `php artisan migrate`
    command.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`php artisan migrate`命令时，你可能会遇到`class not found`错误。
- en: Don't worry, just type `composer dump-autoload` in your terminal and try again!
    Even the best, sometimes, make mistakes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，只需在终端中输入`composer dump-autoload`并再次尝试！即使是最好的，有时也会犯错误。
- en: More examples, more migrations
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多示例，更多迁移
- en: Now, what about another example?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于另一个示例呢？
- en: 'Let''s imagine another feature. Alright, I have an idea: imagine that you want
    to specify some tags for every book you store with your application. This time
    you will have two things to do:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再想象另一个功能。好吧，我有一个想法：想象一下，你想为你的应用程序中存储的每一本书指定一些标签。这次你将有两件事情要做：
- en: Create a new `tags` table to store tags.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的`tags`表来存储标签。
- en: Create a new `book_tag` table, as we are going to represent a many-to-many relationship.
    In this table, you will find the `book_id` and `tag_id`.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的`book_tag`表，因为我们将要表示多对多关系。在这个表中，你会找到`book_id`和`tag_id`。
- en: 'First of all, create a new migration. Open your terminal and type:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的迁移。打开你的终端并输入：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Also, update the file as the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，更新文件如下：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I like to write in the `up()` and `down()` methods at the *same time*. In that
    example you just saw, I put in `up()` the `create` method for `tags`. Then, I
    passed to the `down()` method and added the `drop('tags')` method call. Then,
    I went back to `up()` and added the `book_tag` table, and I finally went to `down()`
    again to drop the `book_tag` table.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢同时编写`up()`和`down()`方法。在你刚才看到的例子中，我把`tags`的`create`方法放入了`up()`中。然后，我传递到`down()`方法并添加了`drop('tags')`方法调用。然后，我回到`up()`并添加了`book_tag`表，最后我又回到`down()`来删除`book_tag`表。
- en: Working in this way helps me reduce distraction errors.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式工作有助于我减少分心错误。
- en: 'Now, open the terminal and type:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开终端并输入：
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Go to your database. Open the `migrations` table to see what happened:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 前往你的数据库。打开`migrations`表来查看发生了什么：
- en: '![More examples, more migrations](img/3634_02_05.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![更多示例，更多迁移](img/3634_02_05.jpg)'
- en: We have two different batches here. The first batch (*1*) is related to the
    publisher's update. The second batch (*2*) is related to the tags system update.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个不同的批次。第一个批次（*1*）与发布者更新相关。第二个批次（*2*）与标签系统更新相关。
- en: Why am I telling this to you? Who cares?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我为什么要告诉你这些？谁在乎呢？
- en: Well, when you type `php artisan migrate:rollback` in your terminal, the migrations
    system searches for the last batch and rolls it back. Not every batch, just the
    last batch. This means that the first `rollback` command will undo everything
    related to the tags system. If you type it again, the migrations system will also
    undo everything about the publisher's update.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，当你你在终端中输入`php artisan migrate:rollback`时，迁移系统会寻找最后一个批次并将其回滚。不是每个批次，而是最后一个批次。这意味着第一个`rollback`命令将撤销与标签系统相关的一切。如果你再次输入，迁移系统也将撤销与发布者更新相关的一切。
- en: 'With the batch number, you can know how many iterations you did on your database.
    However, there is another important thing you need to know: regarding our example,
    if you roll back two times and then migrate again, both migration files will be
    grouped under batch 1.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过批次号，你可以知道你在数据库上进行了多少次迭代。然而，还有另一件重要的事情你需要知道：关于我们的例子，如果你回滚两次然后再次迁移，这两个迁移文件都将被归入批次1。
- en: 'Also, you can roll back everything with this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你也可以使用以下命令回滚所有内容：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can roll back and migrate everything again with this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令回滚并再次迁移所有内容：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, you will get a list of all the migrated/rolled back migrations with
    this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用以下命令获取所有已迁移/回滚的迁移列表：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That's all! With this last command, we are also done with migrations.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了！使用这个最后的命令，我们也完成了迁移。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Finally, the hero leaves his home. After the training and obtaining the right
    foundations, he is really ready to go.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，英雄离开了他的家。经过培训和获得正确的基石后，他真的准备好了。
- en: Remember that the Schema Builder class and migrations system are not just about
    building your DB. In this chapter, you learned how to improve your database design
    method in a smarter way without the need for a single SQL line. Also, by using
    migrations, you are not going to need anymore to download database dumps or, in
    some *extreme* way, install any extra tool to deal with it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Schema Builder类和迁移系统不仅仅是关于构建你的数据库。在本章中，你学习了如何以更智能的方式改进你的数据库设计方法，而不需要写一行SQL语句。此外，通过使用迁移，你将不再需要下载数据库备份，或者在某些*极端*情况下，安装任何额外的工具来处理它。
- en: Everything is done with the `artisan migrate` commands. However, as I already
    told you, this was just a *sample*. The real thing is arriving.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作都是通过`artisan migrate`命令完成的。然而，正如我已经告诉你的，这只是一个*示例*。真正的事情即将到来。
- en: 'In the next chapter, we will go deeply and straight into the most important
    and *atomic* Eloquent component: the model.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨最重要的、*原子*的Eloquent组件：模型。
- en: Are you ready, hero?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好了吗，英雄？
