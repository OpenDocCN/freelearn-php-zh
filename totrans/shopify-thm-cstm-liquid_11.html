<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer109">
			<h1 id="_idParaDest-152"><em class="italic"><a id="_idTextAnchor152"/></em><a href="B17606_08_Final_PD_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 8</em></a>: Exploring the Shopify Ajax API</h1>
			<p>In the previous chapters, we learned about the basics of Shopify and Liquid, which provided us with some solid groundwork for future development. After setting up a proper foundation for our future learning, we learned how Liquid core works. By learning about objects, tags, and filters, we have learned how to create complex functionalities using a somewhat simple and insignificant set of features. Lastly, we learned how to create easily configurable elements throughout the store using various input type settings, combined with the <strong class="source-inline">sections</strong> and <strong class="source-inline">blocks</strong> attributes.</p>
			<p>Throughout these chapters, we have learned how to create elements with static content. <em class="italic">However, what if we were looking to update the content of our pages dynamically?</em> This is where the Shopify Ajax API comes to help. In this final chapter, we will go over the Shopify Ajax API, explain its requirements and limitations, as well as its possible use cases.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Introduction to the Shopify Ajax API</li>
				<li>Updating the cart session with a POST request</li>
				<li>Retrieving data with a GET request</li>
			</ul>
			<p>After completing this chapter, we will understand what the Shopify Ajax API is and the types of requests we can make, such as retrieving product information, adding products to the cart, or even reading the cart's current content. Additionally, we will learn about the typical uses cases for the Shopify Ajax API by working on some of our previous projects and improving them with the Ajax API.</p>
			<p>Lastly, we will learn how to pull and render an automatically generated list of recommended products based on Shopify's algorithms, and then turn a general search input into a predictive search feature that's often requested by store owners.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor153"/>Technical requirements</h1>
			<p>While we will explain each topic and present it with the accompanying graphics, we will need an internet connection to follow the steps outlined in this chapter, considering that <strong class="bold">Shopify</strong> is a hosted service.</p>
			<p>The code for this chapter is available on GitHub at <a href="https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter08">https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter08</a>.</p>
			<p>While this chapter will contain several real-life examples and use cases for each topic, we will need a basic understanding and knowledge of Ajax to be able to follow this chapter thoroughly.</p>
			<p>Note that we will only show examples and work on projects related to the Shopify API and not Ajax in general. For detailed information on Ajax, we can consult <a href="https://www.w3schools.com/js/js_ajax_intro.asp">https://www.w3schools.com/js/js_ajax_intro.asp</a>, which provides a great introduction to Ajax.</p>
			<p>The Code in Action video for the chapter can be found here: <a href="https://bit.ly/2VUZ7Qp">https://bit.ly/2VUZ7Qp</a></p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor154"/>Introduction to the Shopify Ajax API</h1>
			<p><strong class="bold">Ajax</strong>, or <strong class="bold">Asynchronous JavaScript and XML</strong>, is a method that we can use to exchange <a id="_idIndexMarker640"/>small amounts of data with the server and <a id="_idIndexMarker641"/>update the parts of any page, without the need to reload it in its entirety. <em class="italic">So, what exactly is the Shopify Ajax API?</em></p>
			<p>The Shopify Ajax API is a REST API endpoint through which we can send out requests to read or update certain information. For example, we can use a <strong class="bold">GET</strong> request to read the product or even the current cart data, or we can use a <strong class="bold">POST</strong> request to update the current content session of the cart.</p>
			<p>Shopify Ajax is an unauthenticated API, which means that it does not require any tokens or API keys to gain access to store information. Shopify also provides us with an authenticated <a id="_idIndexMarker642"/>API named the <strong class="bold">Shopify Admin API</strong>, which apps and services use to communicate with Shopify servers.</p>
			<p>Through the Shopify API, we can access most of our store data, whose responses will return JSON-formatted data, though we can't read customer and order data or update any store data – we can only do this using the Shopify Admin API.</p>
			<p>Note that Shopify has certain rate limitations regarding the Ajax API to prevent abuse (sending an unlimited number of requests to Shopify servers). One such limitation is that there's a maximum input array size limit, currently limited to 250. Let's say that we are looking to pull information about all the products in a collection of over 1,000 products. We will <a id="_idIndexMarker643"/>have to use multiple queries to achieve this since we are limited to a maximum of 250 products per query.</p>
			<p class="callout-heading">Tip:</p>
			<p class="callout">To keep everything concise and to the point, we won't mention all of the rate limitations here. For more <a id="_idIndexMarker644"/>information on Ajax API rate limitations, please refer to <a href="https://shopify.dev/api/usage/rate-limits">https://shopify.dev/api/usage/rate-limits</a>.</p>
			<p>Now that we have familiarized ourselves with the need-to-know Shopify Ajax API basics, we can learn more about the Ajax API from a practical standpoint. </p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor155"/>Updating the cart session with a POST request</h1>
			<p>Previously, we mentioned that we can use a POST request to update the current cart session. Depending <a id="_idIndexMarker645"/>on the type of action we <a id="_idIndexMarker646"/>are looking to perform, we can pair the POST request with the following cart endpoints:</p>
			<ul>
				<li><strong class="source-inline">/cart/add.js</strong></li>
				<li><strong class="source-inline">/cart/update.js</strong></li>
				<li><strong class="source-inline">/cart/change.js</strong></li>
				<li><strong class="source-inline">/cart/clear.js</strong></li>
			</ul>
			<p>While this might sound trivial, it is an essential aspect of today's e-commerce stores, where we expect to perform an action without refreshing an entire page.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor156"/>The /cart/add.js endpoint</h2>
			<p>As its name <a id="_idIndexMarker647"/>suggests, the <strong class="source-inline">/cart/add.js</strong> endpoint <a id="_idIndexMarker648"/>allows us to add one or multiple product variants to the cart, without the need to refresh the cart. To perform this action, we need to create an array named <strong class="source-inline">items</strong> with an object inside containing the following two keys:</p>
			<ul>
				<li>The <strong class="source-inline">id</strong> key, whose value should contain the number type value of the variant ID we are adding to the cart.</li>
				<li>The <strong class="source-inline">quantity</strong> key, whose value should contain the number type value of the quantity we are adding to the cart.</li>
			</ul>
			<p>If we need to include multiple variants, we can simply append multiple objects inside the <strong class="source-inline">items</strong> array:</p>
			<p class="source-code">items: [</p>
			<p class="source-code">  {</p>
			<p class="source-code">    id: 40065085407386</p>
			<p class="source-code">  },</p>
			<p class="source-code">  {</p>
			<p class="source-code">    id: 40065085603994,</p>
			<p class="source-code">    quantity: 5</p>
			<p class="source-code">  }</p>
			<p class="source-code">]</p>
			<p>In the previous <a id="_idIndexMarker649"/>example, we can see an array with two objects <a id="_idIndexMarker650"/>containing a different set of variant <strong class="source-inline">id</strong> and <strong class="source-inline">quantity</strong> keys. However, note that the first object does not contain the <strong class="source-inline">quantity</strong> key. The reason for this is that the <strong class="source-inline">quantity</strong> key is entirely optional, and if we fail to include it, it assumes that the <strong class="source-inline">quantity</strong> value is equal to <strong class="source-inline">1</strong>.</p>
			<p>Let's look at how we could use this in a real-life example:</p>
			<ol>
				<li>As you may recall, in <a href="B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079"><em class="italic">Chapter 4</em></a>, <em class="italic">Diving into Liquid Core with Objects</em>, and later in <a href="B17606_05_Final_PD_ePub.xhtml#_idTextAnchor097"><em class="italic">Chapter 5</em></a>, <em class="italic">Diving into Liquid Core with Filters</em>, we worked on a <strong class="source-inline">Custom collection</strong> project by adding the additional collection to the collection template. However, the current functionality is that if we click on the <strong class="bold">Add to Cart</strong> button, the current form flow will add the respective variant to the cart and redirect us to the cart page. Let's change that by creating a POST request.<p>Before we include the Ajax API, we should review the current flow of the <strong class="source-inline">Custom collection</strong> form that we developed through <a href="B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079"><em class="italic">Chapter 4</em></a>, <em class="italic">Diving into Liquid Core with Objects</em>, and <a href="B17606_05_Final_PD_ePub.xhtml#_idTextAnchor097"><em class="italic">Chapter 5</em></a>, <em class="italic">Diving into Liquid Core with Filters</em>. We can <a id="_idIndexMarker651"/>find the <strong class="source-inline">Custom collection</strong> form <a id="_idIndexMarker652"/>inside the <strong class="source-inline">Snippet</strong> directory, under <strong class="source-inline">collection-form.liquid</strong>:</p><p class="source-code">{% if product.compare_at_price != blank %}</p><p class="source-code">&lt;div class="custom-collection--item"&gt;</p><p class="source-code">  &lt;a href="{{ product.url }}"&gt;</p><p class="source-code">    &lt;img src="{{ product | img_url: "300x300" }}"/&gt;</p><p class="source-code">    &lt;p class="h4 custom-collection--title"&gt;{{ </p><p class="source-code">        product.title }}&lt;/p&gt;</p><p class="source-code">    &lt;p class="custom-collection--price"&gt;</p><p class="source-code">      {{ product.price | money }}</p><p class="source-code">      {% assign discount-price =            product.compare_at_price |                   minus: product.price %}</p><p class="source-code">      &lt;span&gt;Save {{ discount-price | money }}&lt;/span&gt;</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">    &lt;span class="custom-collection--sale-badge"&gt;{{       product.compare_at_price | minus: product.price |         times: 100 | divided_by: product.compare_at_price     }}%&lt;/span&gt;</p><p class="source-code">  &lt;/a&gt;</p><p class="source-code"><strong class="bold">  {% form "product", product %}</strong></p><p class="source-code"><strong class="bold">    &lt;input type="hidden" name="id" value="{{ </strong></p><p class="source-code"><strong class="bold">        product.first_available_variant.id }}" /&gt;</strong></p><p class="source-code"><strong class="bold">    &lt;input type="submit" value="Add to Cart"/&gt;</strong></p><p class="source-code"><strong class="bold">  {% endform %}</strong></p><p class="source-code">&lt;/div&gt;</p><p class="source-code">{% endif %}</p></li>
				<li>As we can see, the collection form that we have created already contains the two necessary things we need: the <strong class="source-inline">submit</strong> button and the variant <strong class="source-inline">id</strong> that we have stored <a id="_idIndexMarker653"/>inside a hidden input. For more straightforward <a id="_idIndexMarker654"/>navigation, let's start by assigning a new class called <strong class="source-inline">collection-submit</strong> to the <strong class="source-inline">submit</strong> button:<p class="source-code">{% form "product", product %}</p><p class="source-code">  &lt;input type="hidden" name="id" value="{{     product.first_available_variant.id }}" /&gt;</p><p class="source-code">  &lt;input type="submit" <strong class="bold">class="collection-submit"</strong>     value="Add to Cart"/&gt;</p><p class="source-code">{% endform %}</p></li>
				<li>With the proper selector in place, we can now use an <strong class="source-inline">addEventListener</strong> on the <strong class="source-inline">submit</strong> button to capture the click event and pass the object to the function that we will create next:<p class="source-code">const addSelector = document.querySelectorAll   (".collection-submit");</p><p class="source-code">if (addSelector.length) {</p><p class="source-code">  for (let i = 0; i &lt; addSelector.length; i++) {</p><p class="source-code">    addSelector[i].addEventListener('click', function(e) { </p><p class="source-code">      e.preventDefault();</p><p class="source-code">      addCart(this);</p><p class="source-code">    });</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>In the preceding example, we created an <strong class="source-inline">addSelector</strong> constant for capturing the click event. Using <strong class="source-inline">preventDefault()</strong>, we canceled any current events' flows and <a id="_idIndexMarker655"/>passed the object of the clicked <a id="_idIndexMarker656"/>element to the <strong class="source-inline">addCart</strong> function. Now, let's look at creating the <strong class="source-inline">addCart</strong> function:<p class="source-code">const addCart = (el) =&gt; {</p><p class="source-code">  let formData = {</p><p class="source-code">    'items': [</p><p class="source-code">      {</p><p class="source-code">        id: el.previousElementSibling.value</p><p class="source-code">      }</p><p class="source-code">    ]</p><p class="source-code">  };</p><p class="source-code">}</p><p>We started by creating an arrow function with an <strong class="source-inline">el</strong> parameter that we will pass the object of the previously clicked element to. Inside the <strong class="source-inline">addCart</strong> function, we created a local variable, inside which we assigned an array. This array contains an object that contains the <strong class="source-inline">id</strong> property of the variable we want to add to the cart.</p></li>
				<li>Considering that we previously passed the clicked-on object to the arrow function, we used <strong class="source-inline">previousElementSibling</strong> to select the correct input element and return its value accordingly. Now that we have all the necessary assets in place, all we need to do is use the <strong class="source-inline">fetch</strong> request to <strong class="source-inline">POST</strong> the data to the Shopify server and update the current cart session:<p class="source-code">const addCart = (el) =&gt; {</p><p class="source-code">  let formData = {</p><p class="source-code">    'items': [</p><p class="source-code">      {</p><p class="source-code">        id: el.previousElementSibling.value</p><p class="source-code">      }</p><p class="source-code">    ]</p><p class="source-code">  };</p><p class="source-code">  <strong class="bold">fetch('/cart/add.js', {</strong></p><p class="source-code">    <strong class="bold">method: 'POST',</strong></p><p class="source-code">    <strong class="bold">headers: {</strong></p><p class="source-code">      <strong class="bold">'Content-Type': 'application/json'</strong></p><p class="source-code">    <strong class="bold">},</strong></p><p class="source-code">    <strong class="bold">body: JSON.stringify(formData)</strong></p><p class="source-code">  <strong class="bold">})</strong></p><p class="source-code">  <strong class="bold">.then(success =&gt; {</strong></p><p class="source-code">    <strong class="bold">console.log("Success:", success);</strong></p><p class="source-code">  <strong class="bold">})</strong></p><p class="source-code">  <strong class="bold">.catch((error) =&gt; {</strong></p><p class="source-code">    <strong class="bold">console.error('Error:', error);</strong></p><p class="source-code">  <strong class="bold">});</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>With that, we <a id="_idIndexMarker657"/>have successfully created a fully functional Ajax API <a id="_idIndexMarker658"/>POST request, allowing us to add any number of items to the current cart session without reloading the page. Additionally, we included the <strong class="source-inline">then()</strong> and <strong class="source-inline">catch()</strong> methods to return <strong class="source-inline">success</strong> and <strong class="source-inline">error</strong> messages inside the console log.</p>
			<p>We also learned how to add specific products in selected quantities to the current cart session through the <strong class="source-inline">/cart/add.js</strong> endpoint. <em class="italic">However, what if we had certain line item properties on the specific product that we were looking to carry over to the cart?</em></p>
			<p>We can easily <a id="_idIndexMarker659"/>resolve this by simply including an additional <a id="_idIndexMarker660"/>parameter, <strong class="source-inline">properties</strong>, which accepts a key-value type object:</p>
			<p class="source-code">let formData = {</p>
			<p class="source-code">  'items': [</p>
			<p class="source-code">    {</p>
			<p class="source-code">      id: el.previousElementSibling.value<strong class="bold">,</strong></p>
			<p class="source-code">      <strong class="bold">properties: {</strong></p>
			<p class="source-code">        <strong class="bold">'Engraving message': 'Learning Liquid is fantastic!'</strong></p>
			<p class="source-code">      <strong class="bold">}</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">  ]</p>
			<p class="source-code">};</p>
			<p>We should set the key so that it's equal to the name of the line item's input or the first part of the line item property, where the value should equal the value that was retrieved from the input or the second part of the line item property. Suppose we need to recall how line item properties work. In that case, we can revisit <a href="B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079"><em class="italic">Chapter 4</em></a>, <em class="italic">Diving into Liquid Core with Objects</em>, where, in the <em class="italic">Product customization</em> subtopic, located in the <em class="italic">Working with global objects</em> section, we explained how line item properties work.</p>
			<p>If we need to pass a hidden line item that will only be visible in the order section part of the admin, we will need to append an <em class="italic">underscore</em> to the key:</p>
			<p class="source-code">let formData = {</p>
			<p class="source-code">  'items': [</p>
			<p class="source-code">    {</p>
			<p class="source-code">      id: el.previousElementSibling.value,</p>
			<p class="source-code">      properties: {</p>
			<p class="source-code">        '<strong class="bold">_</strong>Engraving message': 'Learning Liquid is fantastic!'</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  ]</p>
			<p class="source-code">};</p>
			<p>If we <a id="_idIndexMarker661"/>decide to use <strong class="source-inline">jQuery</strong>, we can make the code a lot more <a id="_idIndexMarker662"/>compact:</p>
			<p class="source-code">jQuery.post('/cart/add.js', {</p>
			<p class="source-code">  items: [</p>
			<p class="source-code">    {</p>
			<p class="source-code">      quantity: 1,</p>
			<p class="source-code">      id: 40065085407386,</p>
			<p class="source-code">      properties: {</p>
			<p class="source-code">        '_Engraving message': 'Learning Liquid is fantastic!'</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  ]</p>
			<p class="source-code">});</p>
			<p>However, we should check whether the theme we are working on already contains a <strong class="source-inline">jQuery</strong> library. Otherwise, we should avoid introducing a new library to the theme.</p>
			<p>By covering both the <strong class="source-inline">JavaScript</strong> and <strong class="source-inline">jQuery</strong> solutions, we are now sure that we will be able to use our skills to produce the necessary Ajax API code. <em class="italic">However, what if we accidentally added a much higher quantity than we needed, and we need to update the product's quantity?</em></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor157"/>The /cart/update.js endpoint</h2>
			<p>As its name suggests, the <strong class="source-inline">/cart/update.js</strong> endpoint allows us to update the line item <a id="_idIndexMarker663"/>values inside the current cart session.</p>
			<p>While <strong class="source-inline">/cart/update.js</strong> works similarly to <strong class="source-inline">/cart/update.js</strong>, there are a few noticeable <a id="_idIndexMarker664"/>differences. For example, in <strong class="source-inline">/cart/add.js</strong>, we had to create a separate object when working with multiple variants, whereas with <strong class="source-inline">/cart/update.js</strong>, we only have to create a single object:</p>
			<p class="source-code">updates: {</p>
			<p class="source-code">    40065085407386: 5,</p>
			<p class="source-code">    40065085603994: 3</p>
			<p class="source-code">}</p>
			<p>Notice that instead of using two sets of key values, we use only one here, where the key is represented by the variant ID and the <strong class="source-inline">quantity</strong> value represents the key value. Additionally, instead of items, we are now using updates. Let's create a function that will help us test out our new knowledge:</p>
			<p class="source-code">const <strong class="bold">updateCart</strong> = (el) =&gt; {</p>
			<p class="source-code">  let formData = {</p>
			<p class="source-code">    <strong class="bold">updates: {</strong></p>
			<p class="source-code">      <strong class="bold">[el.previousElementSibling.value]: 5</strong></p>
			<p class="source-code">    <strong class="bold">}</strong></p>
			<p class="source-code">  };</p>
			<p class="source-code">  fetch('<strong class="bold">/cart/update.js'</strong>, {</p>
			<p class="source-code">    method: 'POST',</p>
			<p class="source-code">    headers: {</p>
			<p class="source-code">      'Content-Type': 'application/json'</p>
			<p class="source-code">    },</p>
			<p class="source-code">    body: JSON.stringify(formData)</p>
			<p class="source-code">  })</p>
			<p class="source-code">  .then(success =&gt; {</p>
			<p class="source-code">    console.log("Success:", success);</p>
			<p class="source-code">  })</p>
			<p class="source-code">  .catch((error) =&gt; {</p>
			<p class="source-code">    console.error('Error:', error);</p>
			<p class="source-code">  });</p>
			<p class="source-code">}</p>
			<p>As we <a id="_idIndexMarker665"/>can see, the general code for updating the <a id="_idIndexMarker666"/>cart session is similar to adding the product cart, which is not surprising. Besides updating the cart's content, <strong class="source-inline">/cart/update.js</strong> also allows us to add the product to the current cart session.</p>
			<p>By using <strong class="source-inline">/cart/update.js</strong>, we can easily update the quantity of every item inside the cart by using the variant ID to identify which variant we are looking to update. <em class="italic">But what if the variant we are looking to update is not present inside the cart?</em> This is where the <strong class="source-inline">/cart/update.js</strong> alternate function triggers, updating the current cart session by adding the product variant to the cart with the selected quantity.</p>
			<p>For example, in the previous <strong class="source-inline">updateCart</strong> function, we set the <strong class="source-inline">quantity</strong> value to a static value of <strong class="source-inline">5</strong>. No matter how many times we call the preceding function, the total quantity of any variant inside the cart will never exceed <strong class="source-inline">5</strong>. For this reason, we recommend always using <strong class="source-inline">/cart/update.js</strong> to update the existing cart items and <strong class="source-inline">/cart/add.js</strong> to add additional items to the cart.</p>
			<p>With that, we have learned how to update the line items in the current cart session. However, as you may recall from <a href="B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079"><em class="italic">Chapter 4</em></a>, <em class="italic">Diving into Liquid Core with Objects</em>, in the <em class="italic">Product customization</em> subtopic, located in the <em class="italic">Working with global objects</em> section, we learned that it is possible to implement a different type of customization using line items. Consequently, this will sort the same product variants into different lines if their customization differs.</p>
			<p>While these products might be on different lines, they will all have the same variant ID. <em class="italic">So, what will happen if we run </em><strong class="source-inline">/cart/update.js</strong><em class="italic"> to update the specific variant on three different lines?</em></p>
			<p>The <strong class="source-inline">/cart/update.js</strong> endpoint would successfully perform its operation. However, since it does not know <a id="_idIndexMarker667"/>which line item we are looking to update, it will <a id="_idIndexMarker668"/>only update the first occurrence of the line item with the matching variant ID, and then it will stop. It will not update any additional occurrence with the same variant ID. <em class="italic">But what if we were looking to update a specific line item and not the first occurrence?</em></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor158"/>The /cart/change.js endpoint</h2>
			<p>The <strong class="source-inline">/cart/change.js</strong> endpoint works similarly to the <strong class="source-inline">/cart/update.js</strong> endpoint as it allows us to update the line item inside the current cart session. However, two crucial <a id="_idIndexMarker669"/>differences are that we can only modify a single line <a id="_idIndexMarker670"/>item at a time and that (more importantly) we can specify exactly which line item we are looking to change.</p>
			<p>Similar to the <strong class="source-inline">/cart/add.js</strong> endpoint, the <strong class="source-inline">/cart/change.js</strong> endpoint also uses an object with two key-value pairs – one to identify the line item and one to assign the needed quantity:</p>
			<p class="source-code">{</p>
			<p class="source-code">  'id': 40065085407386,</p>
			<p class="source-code">  'quantity': 7</p>
			<p class="source-code">}</p>
			<p>While using <strong class="source-inline">id</strong> and the variant ID to identify the line item will not cause any errors, this will not resolve our problem as we can have multiple line items with the same variant ID in the cart. To resolve this, we can use the <strong class="source-inline">line</strong> property to identify the specific line item we want to change:</p>
			<p class="source-code">{</p>
			<p class="source-code">  'line': 3,</p>
			<p class="source-code">  'quantity': 7</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">line</strong> value is based on the index position of the line items inside the current cart session, where the base value starts with <strong class="source-inline">1</strong>. For example, if we have four items within the cart and we are looking to update the line item at the third position, we can set the <strong class="source-inline">line</strong> value to <strong class="source-inline">3</strong>, as per our previous example. Note that the most common use for the <strong class="source-inline">/cart/change.js</strong> endpoint is to easily update the quantity of each line item inside the cart page.</p>
			<p>Perform the <a id="_idIndexMarker671"/>following steps to implement <a id="_idIndexMarker672"/>the <strong class="source-inline">/cart/update.js</strong> endpoint successfully:</p>
			<ol>
				<li value="1">As we mentioned previously, to use the <strong class="source-inline">/cart/update.js</strong> endpoint successfully, we need two things: the <strong class="source-inline">quantity</strong> value, which we can quickly return from the input value that we modify, and the current position of the line item. To determine the position of the line item, we can use the JavaScript <strong class="source-inline">indexOf()</strong> method. Alternatively, we can introduce a <strong class="source-inline">data</strong> attribute and set its value to <strong class="source-inline">forloop.index</strong> if the quantity input is inside a Liquid <strong class="source-inline">for</strong> loop. We will use the second approach to add <strong class="source-inline">forloop.index</strong> as a <strong class="source-inline">data</strong> attribute here:<p class="source-code">&lt;input type="number" name="quantity" value="0" <strong class="bold">data-</strong>  <strong class="bold">quantityItem="{{ forloop.index }}"</strong>/&gt;</p></li>
				<li>After making sure that we have all the necessary attributes in place, all we need to do is use <strong class="source-inline">addEventListener</strong> to detect the <strong class="source-inline">change</strong> event on the input, and then pass the object to the <strong class="source-inline">changeCart()</strong> arrow function:<p class="source-code">const <strong class="bold">changeCart</strong> = (el) =&gt; {</p><p class="source-code">  let formData = {</p><p class="source-code">    <strong class="bold">line: el.dataset.quantityItem,</strong></p><p class="source-code">    <strong class="bold">quantity: el.value</strong></p><p class="source-code">  };</p><p class="source-code">  fetch('<strong class="bold">/cart/change.js</strong>', {</p><p class="source-code">    method: 'POST',</p><p class="source-code">    headers: {</p><p class="source-code">      'Content-Type': 'application/json'</p><p class="source-code">    },</p><p class="source-code">    body: JSON.stringify(formData)</p><p class="source-code">  })</p><p class="source-code">  .then(success =&gt; {</p><p class="source-code">    console.log("Success:", success);</p><p class="source-code">  })</p><p class="source-code">  .catch((error) =&gt; {</p><p class="source-code">    console.error('Error:', error);</p><p class="source-code">  });</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">changeCart()</strong> arrow function is similar to the previous functions that we have created. The only difference is that now, we are using the <strong class="source-inline">/cart/change.js</strong> endpoint and <a id="_idIndexMarker673"/>no longer using static values for <a id="_idIndexMarker674"/>key-value pairs. Instead, we are pulling both values from the object that we passed previously.</p>
			<p>While we can use both <strong class="source-inline">/cart/update.js</strong> and <strong class="source-inline">/cart/change.js</strong> to remove the item from the cart by simply setting the <strong class="source-inline">quantity</strong> value to <strong class="source-inline">0</strong>, we would have to adjust the quantity of each <strong class="source-inline">line</strong> item to <strong class="source-inline">0</strong> manually. <em class="italic">But what if we wanted an easy way to clear out the entire cart with a single click?</em></p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor159"/>The /cart/clear.js endpoint</h2>
			<p>The <strong class="source-inline">/cart/clear.js</strong> endpoint is pretty simple to use compared to the previous endpoints as <a id="_idIndexMarker675"/>it does not accept any parameters. All we have to <a id="_idIndexMarker676"/>do is simply submit a POST request with <strong class="source-inline">/cart/clear.js</strong> and the cart will automatically clear all present items:</p>
			<p class="source-code">const <strong class="bold">clearCart</strong> = () =&gt; {</p>
			<p class="source-code">  fetch('<strong class="bold">/cart/clear.js</strong>', {</p>
			<p class="source-code">    method: 'POST',</p>
			<p class="source-code">    headers: {</p>
			<p class="source-code">      'Content-Type': 'application/json'</p>
			<p class="source-code">    }</p>
			<p class="source-code">  })</p>
			<p class="source-code">  .then(success =&gt; {</p>
			<p class="source-code">    console.log("Success:", success);</p>
			<p class="source-code">  })</p>
			<p class="source-code">  .catch((error) =&gt; {</p>
			<p class="source-code">    console.error('Error:', error);</p>
			<p class="source-code">  });</p>
			<p class="source-code">}</p>
			<p>Note that if we were to run the preceding code on the cart, we would successfully clear all the items from the cart. However, we would still have to refresh the cart page to see the change because although we have cleared all the items from the current cart session, we have not removed the items from the actual DOM. We can implement a short <strong class="source-inline">while</strong> statement inside the <strong class="source-inline">success</strong> function and remove all line item elements to resolve this:</p>
			<p class="source-code">const cartItems = document.querySelector("[data-cart-line-  items]");</p>
			<p class="source-code">while (cartItems.firstChild) {</p>
			<p class="source-code">  cartItems.removeChild(cartItems.firstChild);</p>
			<p class="source-code">}</p>
			<p>Using the preceding code example, we have successfully removed all the items from our current cart session and the DOM. Notice that there are many additional fine-tuning aspects that we will need to handle, such as clearing the price, removing the cart table, and displaying a message stating that the cart is empty. However, to keep this book concise and to the point, we will not be getting into this, but you are free (and it is advisable) to keep upgrading the preceding code as you will only benefit from it.</p>
			<p>So far, we have <a id="_idIndexMarker677"/>learned how to add products to the current cart <a id="_idIndexMarker678"/>session using the <strong class="source-inline">/cart/add.js</strong> endpoint, update the existing line items using <strong class="source-inline">/cart/update.js</strong> and <strong class="source-inline">/cart/change.js</strong>, and how to clear the current cart session using the <strong class="source-inline">/cart/clear.js</strong> endpoint. However, as we had a chance to see, while we could add easily, update, or even clear items from the current cart session, we still had to reload the page to see specific results, such as updating the item <strong class="source-inline">counter</strong> near the <em class="italic">cart</em> icon inside the header or the line item price when updating the item quantity.</p>
			<p>While it would do so, we could quickly simply increment the item <strong class="source-inline">counter</strong> by the number of products we are adding to the cart. A more straightforward solution to achieve this is to use a GET request in combination with the Shopify Ajax API, which will allow us to retrieve all kinds of data from Shopify servers, including the number of products in the current cart session.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor160"/>Retrieving data with a GET request</h1>
			<p>As we <a id="_idIndexMarker679"/>mentioned previously, using a GET request, we can <a id="_idIndexMarker680"/>pull all types of data from Shopify servers, except for customer and order information, which can only be accessed using an authenticated Shopify Admin API. Depending on the type of action we are looking to perform, we can pair the GET request with the following endpoints:</p>
			<ul>
				<li><strong class="source-inline">/cart.js</strong></li>
				<li><strong class="source-inline">/products/{product-handle}.js</strong></li>
				<li><strong class="source-inline">/recommendations/products.json</strong></li>
				<li><strong class="source-inline">/search/suggest.json</strong></li>
			</ul>
			<p>The GET request <a id="_idIndexMarker681"/>is a pretty powerful method that we <a id="_idIndexMarker682"/>will commonly use in combination with a POST request to retrieve data after making changes to the current cart session. However, we can also use a GET request to retrieve and create complex functionalities, as we are about to learn.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor161"/>The /cart.js endpoint</h2>
			<p>The <strong class="source-inline">/cart.js</strong> endpoint, as its name suggests, allows us to access the current cart session <a id="_idIndexMarker683"/>and retrieve all the information about the cart, as well as <a id="_idIndexMarker684"/>products inside the cart. We can use it to dynamically update the cart page or even create a cart drawer for the store and improve the purchase flow significantly. Let's take a look:</p>
			<ol>
				<li value="1">We can retrieve information about the cart using the following <strong class="source-inline">fetch</strong> method:<p class="source-code">fetch('/cart.js')</p><p class="source-code">  .then(response =&gt; response.json())</p><p class="source-code">  .then(data =&gt; {</p><p class="source-code">    console.log(data);</p><p class="source-code">});</p><p>Note that the response of a successful GET request is a JSON object. The following example shows the response we will receive using the previous code to fetch the cart data:</p><p class="source-code"><strong class="bold">{</strong></p><p class="source-code"><strong class="bold">  "token": "fd2d9bc86cfa72228b4de6bff52fe915",</strong></p><p class="source-code"><strong class="bold">  "note": null,</strong></p><p class="source-code"><strong class="bold">  "attributes": {},</strong></p><p class="source-code"><strong class="bold">  "original_total_price": 78594,</strong></p><p class="source-code"><strong class="bold">  "total_price": 78594,</strong></p><p class="source-code"><strong class="bold">  "total_discount": 0,</strong></p><p class="source-code"><strong class="bold">  "total_weight": 0,</strong></p><p class="source-code"><strong class="bold">  </strong><strong class="bold">"item_count": 9,</strong></p><p class="source-code"><strong class="bold">  "items": [],</strong></p><p class="source-code"><strong class="bold">  "requires_shipping": true,</strong></p><p class="source-code"><strong class="bold">  "currency": "USD",</strong></p><p class="source-code"><strong class="bold">  "items_subtotal_price": 78594,</strong></p><p class="source-code"><strong class="bold">  "cart_level_discount_applications": []</strong></p><p class="source-code"><strong class="bold">}</strong></p><p>As we can see, the JSON object provides us with all the necessary information about the cart and each product separately. Note that the variant information can be accessed through the <strong class="source-inline">items</strong> array object, which we have minified to keep everything concise.</p></li>
				<li>Now that <a id="_idIndexMarker685"/>we have learned how to retrieve current cart session <a id="_idIndexMarker686"/>information, we can combine it with the <strong class="source-inline">POST</strong> request for <strong class="source-inline">/cart/add.js</strong> that we worked on previously, and then ensure that the cart counter is updated correctly each time we add a new product to the cart:<p class="source-code">fetch('/cart/add.js', {</p><p class="source-code">  method: 'POST',</p><p class="source-code">  headers: {</p><p class="source-code">    'Content-Type': 'application/json'</p><p class="source-code">  },</p><p class="source-code">  body: JSON.stringify(formData)</p><p class="source-code">})</p><p class="source-code">.then(success =&gt; {</p><p class="source-code">  console.log("Success:", success);</p><p class="source-code">  <strong class="bold">fetch('/cart.js')</strong></p><p class="source-code">  <strong class="bold">.then(response =&gt; response.json())</strong></p><p class="source-code">  <strong class="bold">.then(data =&gt; {</strong></p><p class="source-code">    <strong class="bold">document.querySelector("[data-cart-</strong>        <strong class="bold">count]").innerHTML = data.item_count;</strong></p><p class="source-code">  <strong class="bold">});</strong></p><p class="source-code">})</p><p class="source-code">.catch((error) =&gt; {</p><p class="source-code">  console.error('Error:', error);</p><p class="source-code">});</p><p>We now have all the knowledge necessary to retrieve different types of information <a id="_idIndexMarker687"/>from the current cart session. However, notice that <a id="_idIndexMarker688"/>the price values are pure strings within the cart response and have no currency format.</p></li>
				<li>For example, let's say that we were looking to update the total price on the cart page every time we update the product quantity. To start, we will use the <strong class="source-inline">fetch</strong> method to retrieve the total price value:<p class="source-code">fetch('/cart.js')</p><p class="source-code">  .then(response =&gt; response.json())</p><p class="source-code">  .then(data =&gt; {</p><p class="source-code">    <strong class="bold">console.log(data.total_price);</strong></p><p class="source-code">});</p><p>While we successfully retrieved the price, all that we have received is an unformatted string value, which is not that useful to us:</p><p class="source-code">78594</p></li>
				<li>The easiest way to resolve this would be to look into how the theme developer has defined the currency formatting helper function throughout the theme. We can usually find it inside the theme <strong class="source-inline">master js</strong> file. In our case, this will be <strong class="source-inline">theme.js</strong>.<p>After identifying the keywords that we need, we simply need to apply the formatting to the value that we are looking to format:</p><p class="source-code">fetch('/cart.js')</p><p class="source-code">  .then(response =&gt; response.json())</p><p class="source-code">  .then(data =&gt; {</p><p class="source-code">    console.log(<strong class="bold">theme.Currency.formatMoney(</strong>        cart.total_price<strong class="bold">, theme.moneyFormat)</strong>);</p><p class="source-code">});</p></li>
			</ol>
			<p>Note that the <a id="_idIndexMarker689"/>formatting we have used in the previous <a id="_idIndexMarker690"/>example will work without any modifications in most cases. However, we might need to make some adjustments to specific themes – it all depends on how the theme developer defined the function.</p>
			<p>Previously, we learned how to retrieve information about the current cart session and any data about any product inside the cart. <em class="italic">However, what if we wanted to retrieve product information more directly?</em></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor162"/>The /products/{product-handle}.js endpoint</h2>
			<p>The <strong class="source-inline">/products/{product-handle}.js</strong> endpoint is a simple endpoint that we can use <a id="_idIndexMarker691"/>in combination with a GET <a id="_idIndexMarker692"/>request to retrieve information about any product in the store easily. Similarly, as with the <strong class="source-inline">/cart.js</strong> endpoint, <strong class="source-inline">/products/{product-handle}.js</strong> is relatively easy to use as it only requires us to include the handle of a product we are looking to retrieve data about:</p>
			<p class="source-code">const <strong class="bold">getProduct</strong> = (<strong class="bold">handle</strong>) =&gt; {</p>
			<p class="source-code">  fetch<strong class="bold">(`/products/${handle}.js`</strong>)</p>
			<p class="source-code">  .then(response =&gt; response.json())</p>
			<p class="source-code">  .then(product =&gt; {</p>
			<p class="source-code">    console.log(product.id);</p>
			<p class="source-code">  });</p>
			<p class="source-code">}</p>
			<p>The return <a id="_idIndexMarker693"/>value that we will receive from the preceding example will include the product ID, which we will be using in the following example.</p>
			<p>The most <a id="_idIndexMarker694"/>common use for this endpoint is when creating on-click functionalities, such as the quick view feature, where we need to load a lot of product information dynamically to avoid cluttering the DOM and slowing down the store.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor163"/>The /recommendations/products.json endpoint</h2>
			<p>The <strong class="source-inline">/recommendations/products.json</strong> endpoint allows us to retrieve a list of JSON <a id="_idIndexMarker695"/>objects regarding the <a id="_idIndexMarker696"/>recommended products for the selected product based on Shopify algorithms, which we can use to construct a dynamic recommended section.</p>
			<p>Through this endpoint, we can use three parameters, one of which is mandatory, while the other two are optional:</p>
			<ul>
				<li>The <strong class="source-inline">product_id</strong> parameter is a mandatory parameter whose value should be set <a id="_idIndexMarker697"/>to the ID of the product whose recommendation list we are looking to retrieve. Note that the product ID is not the same as the variant ID. They are two different attributes that we can retrieve through the <strong class="source-inline">product</strong> object.</li>
				<li>The <strong class="source-inline">limit</strong> parameter is an optional parameter that allows us to select the maximum <a id="_idIndexMarker698"/>number of recommended products we should receive per request. We cannot retrieve more than 10 recommended products per request due to Shopify limitations. This is the default value if we do not set the <strong class="source-inline">limit</strong> parameter.</li>
				<li>Last but not least is the <strong class="source-inline">section_id</strong> parameter, which, while optional, is quite an interesting parameter as it allows us to change the type of response that we <a id="_idIndexMarker699"/>will receive. By including the ID of a section as the <strong class="source-inline">section_id</strong> parameter value, we can select the parent element where we would like to render the recommended products. More importantly, we can also change the JSON response to an HTML string, which we can then use in combination with the <strong class="source-inline">recommendations</strong> object to output the recommended products dynamically.</li>
			</ul>
			<p>Now that <a id="_idIndexMarker700"/>we have familiarized <a id="_idIndexMarker701"/>ourselves with all the attributes that we can use with the <strong class="source-inline">/recommendations/products.json</strong> endpoint, it is time to see them in action.</p>
			<p>In the following example, we have used a <strong class="source-inline">fetch</strong> request, paired with the <strong class="source-inline">/recommendations/products.json</strong> endpoint, to generate a JSON object list and output them in the console log:</p>
			<p class="source-code">const productRecommendations = (productId, limit) =&gt; {</p>
			<p class="source-code">fetch(`/recommendations/products.json?product_id=  ${productId}&amp;limit=${limit}`)</p>
			<p class="source-code">  .then(response =&gt; response.json())</p>
			<p class="source-code">  .then(products =&gt; {</p>
			<p class="source-code">    console.log(products);</p>
			<p class="source-code">  });</p>
			<p class="source-code">}</p>
			<p>As we can see, retrieving a JSON object for the recommended products is quite simple, as the only thing that we need to do now is pass the product ID to the <strong class="source-inline">productId</strong> parameter. As you may recall, the <strong class="source-inline">limit</strong> parameter is optional and will default to the maximum value of <strong class="source-inline">10</strong> when not included. Now, let's look at how we can include <strong class="source-inline">section_id</strong> and learn how to retrieve HTML strings instead.</p>
			<p>Before we can modify the <strong class="source-inline">fetch</strong> request to accomplish this, we need to make specific preparations. The first thing we need to do is create a new section in the <strong class="source-inline">Sections</strong> directory. For our example, we will name it <strong class="source-inline">recommended-products</strong>.</p>
			<p>Since we already have a recommended products section on the product page template and are only creating a new section to learn how this works, let's include this new section at the bottom of the <strong class="source-inline">theme.liquid</strong> layout file, just above the <strong class="source-inline">&lt;/body&gt;</strong> tag. Now that we have created the section file and successfully included it, we must familiarize ourselves with the <strong class="source-inline">recommendations</strong> object.</p>
			<p>As its name suggests, the <strong class="source-inline">recommendations</strong> object allows us to retrieve products from the <a id="_idIndexMarker702"/>product recommendations <a id="_idIndexMarker703"/>list. However, this particular object only works in combination with the <strong class="source-inline">/recommendations/products</strong> endpoint.</p>
			<p>As we can see, the <strong class="source-inline">recommendations</strong> object is relatively simple to use as it only contains three attributes:</p>
			<ul>
				<li>The <strong class="source-inline">performed</strong> attribute returns a Boolean, depending on whether we have placed the <strong class="source-inline">recommendations</strong> object inside the section whose content we are rendering by combining the <strong class="source-inline">recommendations</strong> endpoint and the necessary parameters.</li>
				<li>The <strong class="source-inline">products_count</strong> attribute provides us with a number value for the number of products in the recommendation list.</li>
				<li>Last but not least, the <strong class="source-inline">products</strong> attribute allows us to retrieve an array of recommended product objects. We can combine the <strong class="source-inline">products</strong> attribute with the <strong class="source-inline">for</strong> tag to provide an output the same way as we did previously for the <strong class="source-inline">Custom collection</strong> project in <a href="B17606_05_Final_PD_ePub.xhtml#_idTextAnchor097"><em class="italic">Chapter 5</em></a>, <em class="italic">Diving into Liquid Core with Filters</em>.</li>
			</ul>
			<p>Let's return to the <strong class="source-inline">recommended-products</strong> section file we created and use the <strong class="source-inline">recommendations</strong> object to output the recommended products array:</p>
			<p class="source-code">&lt;div class="product-recommendations"&gt;</p>
			<p class="source-code">  <strong class="bold">{% if recommendations.performed %}</strong></p>
			<p class="source-code">    <strong class="bold">{% if recommendations.products_count &gt; 0 %}</strong></p>
			<p class="source-code">      <strong class="bold">{% for product in recommendations.products %}</strong></p>
			<p class="source-code">        &lt;div class="product"&gt;</p>
			<p class="source-code">          &lt;a href="{{ product.url }}"&gt;</p>
			<p class="source-code">            &lt;img class="product__img" src="{{             product.featured_image | img_url: '300x300' }}" </p>
			<p class="source-code">            alt="{{ product.featured_image.alt }}" /&gt;</p>
			<p class="source-code">            &lt;p class="product__title"&gt;{{ product.title }}&lt;/p&gt;</p>
			<p class="source-code">            &lt;p class="product__price"&gt;{{ product.price |                 money}}&lt;/p&gt;</p>
			<p class="source-code">          &lt;/a&gt;</p>
			<p class="source-code">        &lt;/div&gt;</p>
			<p class="source-code">      <strong class="bold">{% endfor %}</strong></p>
			<p class="source-code">    <strong class="bold">{% endif %}</strong></p>
			<p class="source-code">  <strong class="bold">{% endif %}</strong></p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>With that, we have created a proper layout for the future recommendations list. However, if we were to preview the results on the theme, we would notice that the section <a id="_idIndexMarker704"/>does not render anything inside the <strong class="source-inline">product-recommendations</strong> div. As we mentioned previously, the <strong class="source-inline">recommendations</strong> object only works in combination with the <strong class="source-inline">recommendations</strong> endpoint, so let's look at how to use the endpoint to generate the necessary HTML strings to output the recommended product list.</p>
			<p>To achieve this, we need to make a few adjustments to our previous <strong class="source-inline">fetch</strong> request:</p>
			<ol>
				<li value="1">The first thing that we need to do is include the additional parameters for the <strong class="source-inline">productRecommendations</strong> function that we will pass the section ID value to. Additionally, we will need to include the <strong class="source-inline">section_id</strong> parameter and its value to the fetch URL.</li>
				<li>The second and more important step is to remove <strong class="source-inline">.json</strong> from the fetch URL. Otherwise, we will not be able to retrieve the JSON HTML string.</li>
				<li>Last but not least, we will need to replace <strong class="source-inline">.json()</strong> with <strong class="source-inline">.text()</strong> inside the first <strong class="source-inline">then</strong> method.</li>
			</ol>
			<p>At this point, we have all the necessary elements to retrieve the JSON HTML string. Let's test it <a id="_idIndexMarker705"/>out by calling the products inside the console log:</p>
			<p class="source-code">const productRecommendations = (productId, limit<strong class="bold">,   sectionId</strong>) =&gt; {</p>
			<p class="source-code">fetch(`/recommendations/products?product_id=${productId}  &amp;limit=${limit}<strong class="bold">&amp;section_id=${sectionId}</strong>`)</p>
			<p class="source-code">  .then(response =&gt; response.<strong class="bold">text</strong>())</p>
			<p class="source-code">  .then(products =&gt; {</p>
			<p class="source-code">    <strong class="bold">if (products.length &gt; 0) {</strong></p>
			<p class="source-code">      <strong class="bold">console.log(products);</strong></p>
			<p class="source-code">    <strong class="bold">}</strong></p>
			<p class="source-code">  });</p>
			<p class="source-code">}</p>
			<p>However, before we can test this out, we need to pass the three values to our function:</p>
			<ul>
				<li>For <strong class="source-inline">productId</strong>, we can use the product ID value that we retrieved while learning about the <strong class="source-inline">/products/{product-handle}.js</strong> endpoint. Alternatively, we can use <strong class="source-inline">product.id</strong> inside any product template and copy the value that we receive.</li>
				<li>For <strong class="source-inline">limit</strong>, we can use any number value up to <strong class="source-inline">10</strong>, which is the maximum number of products we can receive as a response.</li>
				<li>For <strong class="source-inline">sectionId</strong>, we should include a string value equal to the name of the section we are looking to display the recommended products inside. In our case, the value is <strong class="source-inline">recommended-products</strong>.</li>
			</ul>
			<p>The following is an example of passing all three values to our function:</p>
			<p class="source-code">productRecommendations(6796616663194, 3, "recommended-  products");</p>
			<p>If we <a id="_idIndexMarker706"/>were to preview our duplicate theme and check the console log inside the previous <strong class="source-inline">fetch</strong> function, we would see that we have successfully retrieved the JSON HTML string values for the recommended products.</p>
			<p>Now that we have confirmed that everything works well, the only thing left to do is use the retrieved value and output the recommended products lists:</p>
			<p class="source-code">const productRecommendations = (productId, limit,   sectionId) =&gt; {</p>
			<p class="source-code">fetch(`/recommendations/products?product_id=${productId}  &amp;limit=${limit}&amp;section_id=${sectionId}`)</p>
			<p class="source-code">  .then(response =&gt; response.text())</p>
			<p class="source-code">  .then(products =&gt; {</p>
			<p class="source-code">    if (products.length &gt; 0) {</p>
			<p class="source-code">      <strong class="bold">document.querySelector(".product-</strong>          <strong class="bold">recommendations").innerHTML = products;</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">  });</p>
			<p class="source-code">}</p>
			<p>With that, we have successfully learned how to render a list of recommended products according to the layout that we previously defined inside the <strong class="source-inline">recommended-products</strong> section. Additionally, the product list will automatically update itself based on Shopify's algorithms.</p>
			<p>While <a id="_idIndexMarker707"/>having a recommended list of products is a great feature for finding similar products, we still have to navigate to a specific product, and even then, we can't be sure that we will receive the exact results we needed. To help us with this, we can use a predictive search feature.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor164"/>The /search/suggest.json endpoint</h2>
			<p>As its name suggests, the <strong class="source-inline">/search/suggest.json</strong> endpoint allows us to create a predictive <a id="_idIndexMarker708"/>search that will automatically provide us with a list of products that matches our query, either partially or completely.</p>
			<p>Besides <a id="_idIndexMarker709"/>allowing us to use predictive search on products, we can also search for collections, pages, and even articles, depending on the type of parameters that we include. <strong class="source-inline">/search/suggest.json</strong> allows us to use seven different types of parameters. However, to keep everything concise and to the point, we will only cover the most important ones that are needed to make the predictive search functionality work:</p>
			<ul>
				<li>The first parameter on our list is the <strong class="source-inline">q</strong> parameter, which is a mandatory string type parameter whose value should be equal to the search query.</li>
				<li>The <strong class="source-inline">type</strong> parameter allows us to specify the type of result we are looking to receive. We can include the following comma-separated values: <strong class="source-inline">product</strong>, <strong class="source-inline">page</strong>, <strong class="source-inline">article</strong>, and <strong class="source-inline">collection</strong>. The <strong class="source-inline">type</strong> parameter is also mandatory.</li>
				<li>The <strong class="source-inline">limit</strong> parameter is an optional integer parameter that allows us to set the number of results we should receive per request. Note that if we do not include the <strong class="source-inline">limit</strong> attribute, it defaults to <strong class="source-inline">10</strong>, which is the maximum number of results we can receive per request.</li>
				<li>The <strong class="source-inline">resources</strong> attribute is a mandatory hash type parameter that requests resource results for the query based on the <strong class="source-inline">type</strong> and <strong class="source-inline">limit</strong> fields.</li>
			</ul>
			<p>In the following example, we have used a <strong class="source-inline">fetch</strong> request, paired with the <strong class="source-inline">/search/suggest.json</strong> endpoint, to generate a JSON object list that matches our search <a id="_idIndexMarker710"/>query and outputs it in the console log:</p>
			<p class="source-code">const <strong class="bold">predictiveSearch</strong> = (<strong class="bold">query, limit, type</strong>) =&gt; {</p>
			<p class="source-code">fetch(`/search/suggest.json?q=<strong class="bold">${query}</strong>&amp;resources[type]=  <strong class="bold">${type}</strong>&amp;resources[limit]=<strong class="bold">${limit}</strong>`)</p>
			<p class="source-code">  .then(response =&gt; response.json())</p>
			<p class="source-code">  .then(suggestions =&gt; {</p>
			<p class="source-code">    const productSuggestions =         suggestions.resources.results.products;</p>
			<p class="source-code">    if (productSuggestions.length &gt; 0) {</p>
			<p class="source-code">      console.log(productSuggestions);</p>
			<p class="source-code">    }</p>
			<p class="source-code">  });</p>
			<p class="source-code">}</p>
			<p>As we <a id="_idIndexMarker711"/>can see, retrieving predictive search results based on the search query is relatively simple, since the only thing we need to do now is pass down the required values to our function:</p>
			<p class="source-code">const searchSelector = document.querySelectorAll     (".search-bar__input");</p>
			<p class="source-code">if (searchSelector.length) {</p>
			<p class="source-code">  for (let i = 0; i &lt; searchSelector.length; i++) {</p>
			<p class="source-code">    searchSelector[i].addEventListener('input',       function(e){</p>
			<p class="source-code">      e.preventDefault();</p>
			<p class="source-code">      predictiveSearch(<strong class="bold">this.value, 4, </strong>          <strong class="bold">"product,page,article,collection"</strong>);</p>
			<p class="source-code">    });</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>By typing a search query inside the search field, we will notice that we have successfully retrieved a combined list of up to four products, pages, articles, or collections of JSON objects that partially or fully match our search query inside the console log. The only thing left to do now is use the response values to generate the results inside the DOM.</p>
			<p>With the <strong class="source-inline">/products/{product-handle}.js</strong> endpoint, we had a parameter that allowed us to <a id="_idIndexMarker712"/>retrieve a JSON HTML string to <a id="_idIndexMarker713"/>output the results into the DOM easily. This is not the case with the <strong class="source-inline">/search/suggest.json</strong> endpoint, however; to render these results, we will need to use JavaScript to create the layout and functionality that we need. To keep everything concise and to the point, we will not be covering that in this book. However, we recommend finishing the project as it will be some excellent practice that will help you with everything you have learned so far.</p>
			<p>For additional <a id="_idIndexMarker714"/>information on predictive search parameters and their general requirements and limitations, please consult <a href="https://shopify.dev/api/ajax/reference/predictive-search">https://shopify.dev/api/ajax/reference/predictive-search</a>.</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor165"/>Summary</h1>
			<p>Throughout this final chapter, we have familiarized ourselves with the Shopify Ajax API and learned about different types of use cases. First, we learned how to upgrade the current purchase flow using the <strong class="source-inline">/cart/add.js</strong> endpoint, through which we can add any number of products, quantities, and line item customizations, whether they are public or private, directly to the current cart session.</p>
			<p>By learning how to handle the <strong class="source-inline">/cart/change.js</strong> endpoint, we gained the necessary knowledge to create a feature that includes a specific product and quantity, such as an automatic gift or upsells feature. Using <strong class="source-inline">/cart/update.js</strong> in combination with the <strong class="source-inline">/cart.js</strong> endpoint, we learned how to update the cart's content dynamically and retrieve it. We can then use this to create a cart drawer feature.</p>
			<p>Additionally, we learned how to use the <strong class="source-inline">/products/{product-handle}.js</strong> endpoint to retrieve an automatic list of recommended products and render their content into a section of our choice.</p>
			<p>Lastly, we learned about the <strong class="source-inline">/search/suggest.json</strong> endpoint, which allows us to create a predictive search functionality, one of the most requested features by store owners.</p>
			<p>From the very beginning of this book, we have worked together on pushing the limits of our knowledge and creating a solid flow of understanding that will help us on our path of becoming a Shopify expert. While we haven't gone over every piece of Liquid code, we have worked on some exciting projects where we have learned about something a lot more beneficial. Our goal was not to simply create a list of where we would list all the different methods and attributes, which we can always find by looking through the Shopify documentation, but also to learn how both Shopify and Liquid work.</p>
			<p>While it suffices to say that through the knowledge we've gained here, we should be ready to start working on the Shopify theme independently, note that our adventure is not ending – it is only just beginning.</p>
			<p>Shopify is a constantly evolving platform, and it will require us to stay up to date with all the latest announcements and approaches. Luckily, Shopify offers various communities to improve our knowledge further or get assistance from other Shopify experts on various topics. Last but not least, we have a Discord channel at our disposal, where we can talk with other developers and both get assistance when we need it or share our knowledge with other developers: <a href="https://discord.gg/shopifydevs">https://discord.gg/shopifydevs</a>.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor166"/>Further reading</h1>
			<ul>
				<li>Shopify official documentation: <a href="https://shopify.dev/">https://shopify.dev/</a></li>
				<li>Shopify cheat sheet: <a href="http://cheat.markdunkley.com/">http://cheat.markdunkley.com/</a></li>
				<li>Developer changelog: <a href="https://shopify.dev/changelog%20">https://shopify.dev/changelog</a></li>
				<li>Official community: <a href="https://community.shopify.com/%20">https://community.shopify.com/</a></li>
				<li>Twitter announcements: <a href="https://twitter.com/shopifydevs%20">https://twitter.com/shopifydevs</a></li>
				<li>Shopify Developer YouTube channel: <a href="https://www.youtube.com/channel/UCcYsEEKJtpxoO9T-keJZrEw%20">https://www.youtube.com/channel/UCcYsEEKJtpxoO9T-keJZrEw</a></li>
				<li>Shopify official blog for all the latest information about the world of Shopify: <a href="https://www.shopify.com/partners/blog">https://www.shopify.com/partners/blog</a></li>
			</ul>
		</div>
	</div></body></html>