- en: '*Chapter 5*: Exploring Objects and Classes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to see one of the main functionalities that Pimcore
    offers to us: the possibility of defining a personal and completely custom dataset
    for each project by creating classes and objects.'
  prefs: []
  type: TYPE_NORMAL
- en: The big advantage of using Pimcore is that you can do everything through the
    user interface, without the need of writing a single line of code or to define
    complex database structures, changing or adding new attributes whenever you want.
    Pimcore will do all the magic, and you can update your dataset with no worries
    of running risky migrations on the database. Besides, you can export and import
    all class definitions to share them between different projects without the need
    for reinventing the wheel every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sections, we will present class configuration, focusing on
    various field types that could be added to them, and how to concretely see these
    classes in action through data entry. If we''ve caught your curiosity, just go
    through this chapter to discover how simple it is to create and update your classes
    with Pimcore. The chapter structure is organized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a Class?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and Editing a class definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering Relevant Field Types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and Establishing relations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing Data Entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know how to create Pimcore classes and
    how to properly configure them to make the most of their potential.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you previously have done in [*Chapter 4*](B17073_04_ePub_RK.xhtml#_idTextAnchor083),
    *Creating Documents in Pimcore*, all you need to run the demo connected with this
    chapter is to navigate to the `5\. Object and Classes` folder on the official
    book repository and start a Docker environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, just follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run Docker with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, to restore all the settings on your local machine, just open a new shell
    and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Navigate to [http://localhost/admin](http://localhost/admin) and log in with
    your admin/pimcore credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can access the official book repository to get the source code through
    the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/5.%20Object%20and%20Classes](https://github.com/PacktPublishing/Modernizing-Enterprise-CMS-using-Pimcore/tree/main/5.%20Object%20and%20Classes)'
  prefs: []
  type: TYPE_NORMAL
- en: Now you are ready to navigate the demo to discover all the aspects related to
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Class?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn what a class is in Pimcore and how it is useful
    for managing any kind of data. In the context of Object-Oriented-Programming,
    a **class** consists of a set of variables (or properties) suitable to represent
    a concept, methods to affect values, and the behavior of objects that instantiate
    the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: Pimcore classes reflect this definition, but there is more. In the following
    sections, we will better understand how those classes work, and how they simplify
    our work on dataset development. In particular, we will see that despite the name,
    Pimcore is not limited to product information management; moreover, you will discover
    that no coding at all is needed to define classes.
  prefs: []
  type: TYPE_NORMAL
- en: Designing different concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we already know, one of Pimcore's main features is product information management,
    so we are led to believe that everything revolves around the definition of a `Product`
    class. This is often true, of course, but it must not be seen as a limitation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about a basic e-commerce structure: there will be the `Product` class,
    as we would expect, but maybe we want to categorize our products; we can think
    about creating a `Category` class to link to the product, instead of repeating
    the category''s attributes in each one. We can apply the same reasoning on product
    materials or other attributes, gradually increasing the complexity of our structure
    as needed. And what if we need to implement a store locator for our e-commerce
    site? All we would need to do is create a `Store` class!'
  prefs: []
  type: TYPE_NORMAL
- en: To be more generic, we can design every different kind of concept creating the
    respective class. That said, you can easily understand how simple it could be
    to design the dataset for your CMS. You just need to define classes for articles,
    authors, and so on and start to insert your data. Even better is the fact that
    you can do it without writing a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: No code required
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may think that defining these classes will require a lot of code development
    or database engineering, but you would be wrong. You just need to define your
    classes and their attributes, and Pimcore will do all the magic. To be more specific,
    we may say that every operation that we make on each of our classes affects a
    couple of PHP files that are needed to define the classes themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The `definition` file contains a complex structure of arrays that represent
    class fields, all information regarding visual aspects, such as width, height,
    or CSS rules, and the spatial organization of these fields. This file contains
    all class attribute definitions, so it can be used to restore the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: The `class` file, named after the class itself, contains all getters, setters,
    and other common methods that allow us to manipulate objects that will instantiate
    the class. This class can be referenced within the project and used to access
    class properties and create or update class instances.
  prefs: []
  type: TYPE_NORMAL
- en: Those come with flexible and dedicated database tables for each class and the
    relations between them. Once more, all this happens behind the scenes and so you
    will never have to worry about that; all you need to do is define the structure
    that reflects your needs.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discovered what a class is and how anybody can configure
    it without any knowledge of code development. In the next section, we'll see how
    to create and edit a class definition.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Editing a Class Definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know the basic definitions, in this section, we are ready to create
    our first class. To open up the class definition panel, go through **Settings**
    | **Data Objects** | **Classes**. Now, we can click on the **Add** button on the
    left side. In the following screenshot, we can see the class creation pop-up modal
    that appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Creating a new class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.01_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.1: Creating a new class'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the popup that appears, we must define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class name**: The name of our class. Pay attention to avoid whitespaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unique identifier**: A short string to identify the class uniquely. If we
    omit the identifier, the first available integer ID will be applied to the class.
    This identifier cannot be updated again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on **OK** and the class will be created.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to define the general settings for the class. We will list all these
    settings, explaining their meanings and how to properly configure them. Remember
    that all settings are optional, and some may not be useful for your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see these settings with plausible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: General settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.02_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.2: General settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now describe each property that we see in the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**: Just a description of your class. It has no other implications.
    It may be useful to transmit the purpose of the class in the case of remote collaboration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pimcore\Model\DataObject\Concrete` class, which contains common methods for
    all classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implements interface(s)**: A comma-separated list of interfaces that you
    want your class to implement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use (traits)**: In PHP, traits are mechanisms for code reuse, which allows
    reducing some limitations given by single inheritance. In Pimcore, we could use
    traits to implement methods of the previous interface(s).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pimcore\Model\DataObject\Listing\Concrete` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Listing Use (traits)**: As we just mentioned, traits are a PHP paradigm of
    code development used to implement interface methods. The same concept is valid
    for class listing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractProductLinkGenerator` class and implements the `LinkGeneratorInterface`
    interface. The link generator will receive the referenced object and additional
    data depending on the context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preview URL**: The preview URL is useful to generate a dynamic URL for the
    object directly on the class definition. You can use placeholders for each defined
    attribute of your class, in addition to common properties such as object ID or
    key. This feature became deprecated in the last version, and it is suggested to
    use **Link Provider Class**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Icon**: You can choose a custom icon for your class from the icon list. If
    you prefer, there is the possibility to link your icons, providing the path to
    the icon itself. It is recommended to use SVG files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group**: This property is necessary to group your classes into folders in
    the class definitions tree. Classes with the same prefix word are automatically
    grouped even if no group is explicitly provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Allow Inheritance**: If checked, this property enables the inheritance among
    objects in a tree-structured way. Child objects could be instances of the same
    class or objects of a different class. If child objects belong to the same class
    as the parent object, they automatically inherit all data values from the parent
    object and can override them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Allow Variants**: Object variants are a particular kind of inheritance. A
    variant''s class cannot be chosen; it''s forced to be the same as the parent object.
    We must note that, by default, variants are excluded from listing queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show variants in tree**: This property allows you to see the variants in
    the object tree. If not enabled, variants are only shown in the appropriate tab
    inside the object edit modal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Show App Logger Tab**: If enabled, the **Application Logger** tab is shown
    inside the object edit modal. In that tab, it''s possible to read eventually created
    log events related to the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable grid locking**: This allows you to block some columns in the object
    grid views.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encrypt Data**: This property enables the possibility to encrypt the object''s
    data in the tables created to store information for the class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visibility of system properties**: This allows you to choose which attributes
    are shown by default in the grid view and the search view. These attributes are
    **Id**, **Key**, **Path**, **Published**, **Creation Date**, and **Modification
    date**. These properties are useful for grid filtering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composite Indices**: Pimcore allows you to create custom indices in tables
    that store the information of your class objects. You can choose the index name
    and the class attributes involved in it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have filled in these class properties, you must click on the **Save**
    button to apply them.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to create Pimcore classes. Then, you discovered
    what the main settings for a class are, and how to properly fill in these properties
    concerning your specific needs. Moreover, you have seen how to enable class inheritance.
    In the next section, we will present all the different kinds of components that
    can be attached to the class.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering Relevant Field Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we created our first class. The created class is just
    like an empty box of which, let''s say, we have just established the shape and
    the dimensions. In this section, we will see how we can model our class, defining
    layout components and all different kinds of attributes. These concepts are crucial
    to properly configure your classes according to your needs. In particular, we
    will describe the two different kinds of attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: The Layout Components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Data Components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see both of these kinds of components in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Layout Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The layout components allow us to organize the class attributes through space.
    To better understand the usefulness of these components, let's think about a website
    structure. There are no rules that prevent putting all site information vertically
    on the page. All text, input fields, images, and related links, just listed one
    below the previous one. Sure, it's easy to create, but the reading experience
    for the user is quite a mess, don't you think?
  prefs: []
  type: TYPE_NORMAL
- en: Maybe it'd be better to group common information in different tabs or create
    a box with input fields that the user must fill in with the required information.
    Images can be grouped into a gallery, on the right-hand side, or we may want to
    expand or collapse certain information.
  prefs: []
  type: TYPE_NORMAL
- en: Well, class layout components are designed for just that purpose. You must add
    at least one layout component to the class to be allowed to add the class attributes;
    to add a layout component, just right-click on **General Settings** in your class
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the common characteristic of all kinds of components and the specific
    properties for each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: The component name will only be shown inside the class definition
    panel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Region**: Combined with a parent layout component, this can be used to locate
    the component in different positions, using **North**, **West**, **Center**, **East**,
    and **South**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Title**: The component title will be shown in object instances of the class.
    The position and style of the title depend on the specific component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Width**: The width of the component in the object edit modal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Height**: The height of the component in the object edit modal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collapsible**: If enabled, this makes the component collapsible by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collapsed**: If enabled, the component is collapsed by default on object
    opening.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CSS Style**: Consent to write custom CSS style rules for the component, such
    as a margin or floating position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Border**: Adds a border to the element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can now have a specific look at each kind of layout component. In the following
    screenshot, we can see all the different types of layout components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: Add Layout Component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.03_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.3: Add Layout Component'
  prefs: []
  type: TYPE_NORMAL
- en: Let's describe the properties of each component in the following sections as
    shown in the screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Tabpanel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This component allows you to group different panels inside. Each panel will
    act as a tab in the object edit modal. Besides the common properties, for Tabpanel,
    you can specify the **Tab Position** property. This lets you choose in which position
    you want to put your tabs; possible values are **top** (default), **left**, **right**,
    and **bottom**.
  prefs: []
  type: TYPE_NORMAL
- en: Panel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A simple component that lets you add attributes inside. This component can be
    nested inside other components, such as Tabpanel and Region, and located in different
    positions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this component, we can specify these additional properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Layout**: If the **Fit** option is selected, all fields inside the panel
    will fit the screen dimension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Label Width**: Sets the width of the panel label.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Icon**: Allows choosing a custom icon that will be shown at the left of the
    label.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accordion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to the Panel component, this component is designed to be collapsed and
    expanded as needed. This concept is often used for site development to let the
    user hide or show some extra information that may or may not be useful. For this
    component, there are no extra properties to add.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you will see the difference between panels and
    accordions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: Panels and accordions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.04_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.4: Panels and accordions'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshots, the panels are placed on top inside
    the **Tab Panel Component**. The accordion component contains other layout and
    data components and can be collapsed or expanded.
  prefs: []
  type: TYPE_NORMAL
- en: Region
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This component is designed to contain only other layout components. If you add
    panels inside a region, you can organize them in the five fixed positions mentioned
    previously. Note that you must specify a fixed region height, or your region will
    not be shown. As for the panel, you can choose a custom icon.
  prefs: []
  type: TYPE_NORMAL
- en: Fieldset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This component just lets you add some data components inside of it, grouping
    them with a small border with a label on top. You can use it to group a list of
    similar fields that make sense if shown together. The only specific property that
    can be set is the label width.
  prefs: []
  type: TYPE_NORMAL
- en: Field Container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The behavior of a Field Container is similar to a Fieldset. The main difference
    is just that you can choose whether you want to group your fields vertically or
    horizontally, by properly selecting the **Layout** property.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see the difference between **Fieldset**
    and **Field Container**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5: Fieldset and Field Container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.05_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.5: Fieldset and Field Container'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, the data components inside **Fieldset**
    are grouped inside a box vertically. **Field Container** does not have a designed
    border, and the inner components can be grouped horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: Button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Allows you to add a custom button inside the object edit modal. The handler
    of the button must be defined in the component definition.
  prefs: []
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This component is just a static text box that can be shown in the object edit
    modal. The HTML text inside the box can be directly defined in the class definition,
    or you can generate dynamic text specifying the class namespace in the **Custom
    Renderer Class** attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Preview/Iframe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This component simply lets us render a custom Iframe inside our object edit
    modal. The Iframe URL must be a relative URL of action inside a controller that
    extends the `Pimcore\Controller\FrontendController` class.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discovered all the options for the layout components, let's
    have a look at the data components.
  prefs: []
  type: TYPE_NORMAL
- en: Data Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Data components are the concrete attributes of classes. There are tons of available
    attributes,grouped into different main types, that allow you to model your class
    according to your needs. In the following screenshot, you can see a panoramic
    of all types of data components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: Add Data Component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.06_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.6: Add Data Component'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding screenshot, there are 10 main data component
    types, which contain a different number of components. Each component type and
    every attribute have their specific properties, but all data components have a
    set of common properties that we explain here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: The name of the attribute. It cannot have spaces or special characters,
    because this is the name that will be used in the database table column and the
    PHP class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Title**: The label of the attribute that will be shown in the object edit
    modal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tooltip**: Suggested text to explain the meaning of the attribute used to
    help the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mandatory Field**: If checked, makes the attribute mandatory. An object cannot
    be published if all mandatory fields are not filled in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Indexed**: If checked, creates an index for the field in the database tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unique**: If checked, creates the unique constraint in the database tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Not Editable**: If checked, the attribute becomes read-only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invisible**: If checked, the attribute is not visible in the object edit
    modal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visible in Grid View**: If checked, the attribute is shown in the class''
    predefined grid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visible in Search Result**: If checked, the attribute is visible and searchable
    in the dedicated search modal for the class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CSS Style**: As for layout components, consent to write custom CSS style
    rules for the component, such as margin or floating position.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Width**: The width of the component in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Height**: The height of the component in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default value**: A lot of field types give the possibility to define a default
    value. If any value is typed for the field, the default value is saved. If inheritance
    is enabled for the class, this value is persisted in the database for its children.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Pimcore\Model\DataObject\ClassDefinition\DefaultValueGeneratorInterface`
    class, and it is invoked once you open the object to perform the default value
    calculation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have learned about the common properties of all kinds of data components,
    we will focus on each specific group of components to describe their peculiarities.
  prefs: []
  type: TYPE_NORMAL
- en: Text Components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This kind of component contains basic text input fields. All these components
    are quite similar and share all the common properties we mentioned before, but
    there are some differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Input** component is the simplest text field. It's not possible to set
    the input height because it is meant to contain only one line. We can indeed show
    the character count and add a regular expression validation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Textarea** component is quite similar to the previous one but allows you
    to specify the height for your text. As the input component, it's possible to
    show the character count, bet we cannot add regular expressions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **WYSIWYG** component, as the famous acronym suggests, allows you to insert
    and edit HTML-formatted text. It's possible to customize the editor configuration
    by providing a CKEditor configuration in the component definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Password** component is an input text with hidden input characters. The
    column length cannot be chosen because contents are always hashed using the selected
    algorithm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Input Quantity Value** field is composed of value and measure units. We
    will look in depth into this concept in the following section regarding numeric
    fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number Components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section contains some simple numeric attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The **Number** component is the simplest numeric field. It's possible to define
    the decimal size for the database column and the decimal precision for input values.
    Values can be restricted to be only integers or only unsigned. We can also specify
    minimum and maximum values.
  prefs: []
  type: TYPE_NORMAL
- en: The **Slider** component stores a numeric value but it renders a sliding cursor
    to select the value. By specifying min-max values and incremental steps, it's
    possible to define this slider component.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned before, the **Quantity Value** component consents to attach measure
    units to numeric fields, giving the possibility to define concepts such as prices,
    weights, and so on. To define your units, just go through **Settings** | **Data
    Object** | **Quantity Value** and simply add the units that you need. Units can
    be added and deleted at any moment, and every operation is auto-saved in the database.
    In the following screenshot, you will see the **QuantityValue** definition panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: Quantity value units'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.07_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.7: Quantity value units'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the screenshot, different units can be related using a static
    conversion factor or by defining a converter service class; the second option
    could be useful for conversions that need a formula, such as temperature conversions.
  prefs: []
  type: TYPE_NORMAL
- en: Date Components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These components are designed to contain date and time values. Dates in the
    database can be stored as a timestamp or a date string.
  prefs: []
  type: TYPE_NORMAL
- en: Select Components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This kind of component lets you define different types of picklists. Some of
    them come with predefined options, such as **Country**, **Language**, and **User**.
    Instead, there are three types of custom picklists that we can define. For **Boolean
    Select**, we cannot define picklist values, but we can customize labels for the
    two states. **Select** is the most common component of this group. Picklist values
    can be added, removed, and ordered at any time. Values can be numbers or strings
    likewise. In the next screenshot, you will see how **Select** options are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: Select values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.08_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.8: Select values'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we can define both the value and display name. Alternatively,
    you may also define a custom class to provide dynamic options for your field.
    The behavior of the **Multiselection** component is the same as the previous one,
    with the difference that we can select multiple values in objects.
  prefs: []
  type: TYPE_NORMAL
- en: Media Components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This set of components permits us to show media files in our class objects.
    We can link internal assets or external images, create galleries, and show video
    previews.
  prefs: []
  type: TYPE_NORMAL
- en: We will look into this part in depth in [*Chapter 6*](B17073_06_ePub_RK.xhtml#_idTextAnchor112),
    *Using Digital Asset Management*.
  prefs: []
  type: TYPE_NORMAL
- en: Relation components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These components are used to establish relations between different classes or
    to link class objects to documents or assets. Note that for assets relations,
    the asset preview will not be shown in the object like the previously mentioned
    group of components. All kinds of relations may be many-to-one or many-to-many.
    For many-to-many object relations, we can choose which fields we want to show
    in the relation box. We may also use **Advanced relation components** to add custom
    metadata fields to the relationship.
  prefs: []
  type: TYPE_NORMAL
- en: We will have a look at relation details in the next section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Geographic Components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These particular kinds of fields allow us to search and put marks on a rendered
    map. You can add a simple geographic point or draw lines and polygons on the map.
    All points' latitude and longitude are stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: CRM Components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These components are designed to register customer information in Pimcore. We
    must pay attention that almost all these components, such as email, for example,
    have a fixed field name, so it's not possible to add this kind of component multiple
    times in the same class.
  prefs: []
  type: TYPE_NORMAL
- en: Other Components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section contains a batch of mixed components.
  prefs: []
  type: TYPE_NORMAL
- en: There are simple components such as **Checkbox** and **Color**, or **Link**
    to external websites. We can then cite the **Encrypted Field** component, which
    allows storing encrypted values in the database as long as a secret key has been
    generated and properly configured.
  prefs: []
  type: TYPE_NORMAL
- en: We have mentioned all components apart from `Pimcore\Model\DataObject\ClassDefinition\CalculatorClassInterface`
    interface, it's possible to dynamically calculate the value for the field, based
    on other object values. The calculated value is not stored in the database, but
    the calculation is made every time you open the object and every time the specific
    getter is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, throughout this section we described all different kinds of components.
    Firstly, we introduced all the common properties of all data components. We then
    listed different kinds of components, specifying eventual additional properties
    for each of them. In the next section, we describe a particular type of data component
    named structured components.
  prefs: []
  type: TYPE_NORMAL
- en: Structured Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These particular kinds of components are designed to extend the class definition,
    defining structures or patterns with groups of attributes that can be attached
    to class objects.
  prefs: []
  type: TYPE_NORMAL
- en: We will see some of these components in action in future chapters regarding
    Product Information Management and Master Data Management features. Throughout
    this section, we will describe these components and when they are designed to
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: Field-Collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most used component is **Field-Collection**. You can define your field collection
    in the same way that we explained for classes. Just go through **Settings** |
    **Data Objects** | **Field-Collection** and simply create a new one by adding
    layout and data components.
  prefs: []
  type: TYPE_NORMAL
- en: 'On your class definition, a **Field-Collection** component can allow one or
    more different **Field-Collection** types. In the class object instances, you
    can dynamically add multiple instances of the defined field collection to add
    the same group of attributes multiple times. This kind of component is useful
    when you have certain properties that can appear with different cardinality in
    various objects. In the following figure, you can see a schema that outlines how
    the **Field-Collection** works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9: Field-Collection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.09_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.9: Field-Collection'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding figure, we can add a **Field-Collection** component
    to the class definition. As we can do for the class definition, in the **Field-Collection**
    definition, we can add a set of layout and data components. In the class objects,
    you can add one or more instances of the same **Field-Collection**.
  prefs: []
  type: TYPE_NORMAL
- en: Objectbricks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With **Objectbricks**, unlike **Field-Collection**, objects can be extended
    without changing the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: Think about a fashion company that wants to store information about their products.
    We can easily imagine that shirts and shoes will have different attributes. Sure,
    we could create two different classes for shirts and shoes, but you would need
    to define redundant fields for properties that are not shared between the two
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: With **Objectbricks**, we just need to create little sets of attributes to describe
    specific fields and allow our class to dynamically add these bricks. As the name
    suggests, class objects can be composed of one or more bricks added to the common
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to classes and **Field-Collection**, just go through **Settings** |
    **Data Objects** | **Objectbricks** to define them. **Objectbricks** is inheritable
    between parent and child objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, you can see a schema that illustrates how **Objectbricks**
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: Objectbricks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.10_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.10: Objectbricks'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding figure, we can add an **Objectbricks** component
    to the class definition. In the class instances, we can attach one or more bricks
    to add specific sets of components to the object itself, to give a categorization
    to the object.
  prefs: []
  type: TYPE_NORMAL
- en: Localized fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We may also need to define attributes that should be translated into multiple
    languages within an object, such as titles and descriptions for a multilanguage
    site. Using the **Localized Fields** component, we just have to insert child components
    inside and configure languages in **System Settings**. In the following screenshot,
    we can see how the component is rendered on objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: Localized Fields'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.11_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.11: Localized Fields'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a specific tab is added in the component for each defined language.
  prefs: []
  type: TYPE_NORMAL
- en: Block
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Block** component acts as a simple container for other data components.
    Similar to **Field-Collection**, an unlimited number of block elements can be
    created. The block data just gets serialized into a single database column. As
    a consequence, this container type is not suitable if you are planning to query
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: Tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two other quite simple components are `TEXT` field, with column values separated
    by the pipe character. Structured tables respect the same principle, but rows
    and columns are always fixed and named.
  prefs: []
  type: TYPE_NORMAL
- en: Classification store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final and most complex component is **Classification Store**. This component
    allows you to define a hierarchical key-value pairs structure to dynamically add
    groups of attributes to class object instances. To define a **Classification Store**
    component, go through **Settings** | **Data Objects** | **Classification Store**.
    To properly create a classification store, we must define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Definitions**: Define keys for your classification store. All basic data
    components are available for that purpose. For each key, we can choose whether
    it should be mandatory or editable, and other standard properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Groups**: Select one or more keys to define groups. Within the group, you
    can define which keys are mandatory and define the order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group Collections**: Different groups can be grouped into collections. In
    the object edit modal, we can add one or more of the defined collections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have discovered all kinds of data components, in the next section,
    we will focus on relations, looking in depth into component definitions and providing
    a concrete example of relations.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and Establishing Relations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look in depth into how to relate objects with other
    entities in Pimcore. As we have seen in the previous section, the first step is
    to add the appropriate fields onto our class to configure relations between two
    classes, or relations between classes and other entities (such as documents or
    assets). Here, you will see all the different kinds of relation components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Relation components'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.12_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.12: Relation components'
  prefs: []
  type: TYPE_NORMAL
- en: As you may see, there are two main different types of relation fields, the generic
    relation fields that allow relating objects, documents, or assets, and specific
    relation fields for object classes. For each type, we can establish a many-to-one
    relation, many-to-many relation, or advanced many-to-many relation. The last one
    lets you define some additional metadata fields that can be attached to the relation
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sections, we will focus on the two main types of relation
    components, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generic Relations**: Relations between an object instance and other entities
    (this could include another object or instances of assets or documents).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object Relations**: Specific relations between object instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see the details of these different types of relations.
  prefs: []
  type: TYPE_NORMAL
- en: Generic Relations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Generic Relations** field allows relations between object instances and
    other previously created entities, which could be either other objects, documents,
    or assets. It's not possible to decide which properties of related entities we
    want to show on the object. For many-to-one relations, only the entity path is
    shown; for many-to-many relations, the ID and entity type are shown as additional
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides, we can provide some limitations to the relation attribute, in particular,
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: For documents, we can specify which types are allowed in the relation. If none
    are selected, all types are allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For assets, we can specify which types are allowed in the relation. If no specific
    one is selected, all types are allowed. There is also the possibility to define
    an upload path for assets that could be directly uploaded through the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For objects, we can specify which classes are allowed in the relation. If no
    specific one is selected, all classes are allowed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will focus on the other kind of relation components,
    the ones specifically used to relate objects.
  prefs: []
  type: TYPE_NORMAL
- en: Object Relations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This kind of relationship is strictly limited to relations between objects.
    As for the previous group, there is the possibility to limit the relations to
    one or more classes. The main difference is that we can select which fields we
    want to show in the relationship within the object element. But if more than one
    class is selected, only common fields between the involved classes can be selected.
  prefs: []
  type: TYPE_NORMAL
- en: For advanced relations, we can define specific metadata fields for each relation.
    These fields could be created as one of the basic data types (**Text**, **Number**,
    **Boolean**, or **Select**) and will be added after the original object fields.
    Another particular component is **Reverse Many-To-Many Object Relation**. This
    component could only work if **Many-To-Many Object Relation** was previously configured.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, through a concrete example, we will see how to practically
    use relation components to connect objects of different classes.
  prefs: []
  type: TYPE_NORMAL
- en: A Concrete Example of Relations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To provide a concrete example, think about products and categories. We can
    specify a direct relation between a `Product` class and a `Category` class, and
    specify a reverse relation in the `Category` class that is related to the direct
    one. Let''s first create a `Product` class. Follow the steps given here:'
  prefs: []
  type: TYPE_NORMAL
- en: For the first component, add a tabpanel called `Product Data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a panel named `General Information` as a child of the previously created
    tabpanel component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an input field for the product title and then save your class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `Category` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then create the `Product` class. Here, create a new panel and add the **code**
    and **name** fields, and then save the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, come back to the product class and add a many-to-many relation component
    to relate the `Product` and `Category` classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the relation, specify that you want to show **code** and **name** properties,
    and save the class again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can add a reverse relation component to the `Category` class. To add
    this component, we just need to define the class and field for the original relation.
    Set this component as not editable, to make the reverse relation completely automatic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: Reverse Many-To-Many Object Relation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.13_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.13: Reverse Many-To-Many Object Relation'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see how the configured components appear.
    On the left side, we can see the components that appear in the class configuration
    tree. On the right side, there are some specific settings of the defined components.
    On top of that, we can see the many-to-many relation component that relates the
    `Product` class with the `Category` class. On the bottom, the reverse relation
    is shown.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to relate classes with other entities. In the
    next section, we will see how these defined relations are reflected in object
    data entry.
  prefs: []
  type: TYPE_NORMAL
- en: Performing Data Entry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will check how class definitions are reflected in concrete
    object instances, discovering how to create Pimcore objects and perform data entry
    to fill their information. We will see how to easily create folders and objects,
    how to relate them, and how to create object variants. Then we will discover how
    easy and fast it is to add new attributes or edit some existing ones, paying attention
    to this last point to avoid the loss of data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Folders and Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Pimcore, unlike what you might think, folders are just instances of a common
    base class for which we are not able to add custom attributes. It''s not mandatory
    to create folders; think of it just as a helping feature to organize your objects
    semantically as you do on your PC desktop. Different folders can be nested in
    a tree structure. To create your first folder, follow the steps given here:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Data Objects** section on the main left panel, and right-click the
    **Home** element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Home` is a special folder object with `1`. This component cannot be
    deleted, and it will be the root element for the whole tree structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having said that, let's create a `Products` folder and a `Categories` folder.
    Once again, this naming is just needed to separate concepts, but it's not mandatory.
    You can create all objects within a unique folder, or as direct children of the
    `Home` component itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the created folders to add objects inside them, choosing the
    class and adding the object name. Note that these names are just keys that appear
    in the tree structure and must be unique within the same folder, but they are
    completely unrelated to any class data property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this information, let's create a `Product` object. As previously defined
    in the class definition, an input field for the product title can be filled. The
    relation with categories cannot be done yet, because we need to create categories
    first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replicate the previous actions to add a couple of category objects in the dedicated
    folder, and fill in the information for them. You will see that it will not be
    possible to select a related product since we have a reverse relation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch back to the product and click on the search button in the relation component
    to select the created categories, and save the product.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refresh the category objects, and see how the relation with the product appears.
    The result is shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.14: Object relations'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.14_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.14: Object relations'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we see clearly how objects are mutually related. As
    you may see in the direct relation component, the categories attribute that we
    required in the component configuration is shown in the relation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how inheritance work and how to add object
    variants.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Object Variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If enabled in the class definition, it's possible to add variants for the created
    objects. To create a variant, just right-click on the previously created object,
    select **Add Variant**, and type the variant name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variants inherit all values from parent properties. As you will see in
    the following screenshot, inherited values appear as read-only, but it''s possible
    to override the value on variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15: Object variants'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.15_B17073.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.15: Object variants'
  prefs: []
  type: TYPE_NORMAL
- en: Variants appear in the object tree structure like other objects, but for each
    object, it is possible to easily access variants by clicking on the opposite button
    in the object toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: Editing Classes and Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Creating and Editing a Class Definition* section, we saw how easy it
    is to create a class and add some data components. One big advantage of using
    Pimcore is that this can be done incrementally since we can add new components
    or edit existing ones at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Every operation on a class is reflected in the corresponding PHP class and,
    above all, in the database tables. For these reasons, editing data components
    could be dangerous and lead, in the worst scenario, to the loss of data. Obviously,
    if an input component is converted into a relation component, or if a checkbox
    becomes an image component, loss of data is expected. This is not our focus, but
    we will point our attention to apparently safe operations that are not safe at
    all because they could lead to irreversible loss of data. These are covered in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Text To Number
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Converting a numeric component into a text one will never lead to loss of data
    because it just alters the database column from decimal to text, and decimal values
    are valid input for a text column. The opposite flow is not valid at the same.
    In this scenario, we have three possible cases:'
  prefs: []
  type: TYPE_NORMAL
- en: If the field value is a valid number, the data will be safe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the field value is a mixed number with text, only the "numeric" part is left,
    removing all content after the first encountered letter or whitespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the field value is text, the converted value becomes `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now see what the risks of changing data types between different kinds
    of numeric fields are.
  prefs: []
  type: TYPE_NORMAL
- en: Number to QuantityValue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We may think that this operation has no risks because we are just attaching
    a unit of measure to our numeric value, but this is quite false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, in object tables, the original numeric column is dropped with the inevitable
    loss of data, and two new columns are created. In particular, given a certain
    "fieldname," we have the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fieldname__value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fieldname__unit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this reason, modifying numeric components to `QuantityValue` is discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: Moving a Component to LocalizedFields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we move a component into LocalizedFields, data of the component is lost.
    This happens because the database column is dropped from the main object table
    and created in the specific localized table for each defined language.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we described different aspects of data entry. Firstly, you
    learned how to create folders and objects on the object tree, and how to create
    object variants. Then, you discovered how to prevent data loss during class definition
    editing, avoiding risky operations on changing component types.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the concept of classes. In Pimcore, a class
    represents the definition of a concept, such as a product or a category. We can
    add both layout and data components to model our classes and integrate them at
    any time, along with adding or editing their properties.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that to define a class, it's not necessary to write any code or to
    create database tables, because Pimcore does all the magic updating the code and
    database every time you make a change on the class.
  prefs: []
  type: TYPE_NORMAL
- en: We know it's possible to create a custom PHP class that can be extended by one
    or more classes; this could be useful to add class methods to be used in development.
    With the same principle, it's possible to define rules to provide default values
    for class fields or calculate values for particular kinds of components.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how we can relate different classes, or link assets and documents
    to class objects using a particular kind of component, and how to define inheritance
    rules for classes. Then we learned about data entry and how it is made simple
    by the easy-to-use Pimcore interface; every change in the class definition is
    immediately reflected on the objects; you just need to refresh.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discover the DAM Pimcore feature, and how it helps
    us to manage multimedia contents and prepare them for distribution.
  prefs: []
  type: TYPE_NORMAL
