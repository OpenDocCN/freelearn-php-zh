- en: 6\. Using HTTP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 使用HTTP
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to explain the Request-Response
    Cycle of an application; explain the various HTTP methods; perform data sanitization
    and validation; track user session data; and build a web application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够解释应用程序的请求-响应周期；解释各种HTTP方法；执行数据清理和验证；跟踪用户会话数据；并构建一个Web应用程序。
- en: This chapter presents you with the necessary tools to use and implement HTTP
    requests in practical web applications. You will become familiar with request
    types and URL components and will learn about common vulnerabilities on the **World
    Wide Web** (**WWW**) as well as learn how to protect your applications against
    such attacks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为你提供了在实用Web应用程序中使用和实现HTTP请求的必要工具。你将熟悉请求类型和URL组件，并了解**万维网**（**WWW**）上的常见漏洞，以及如何保护你的应用程序免受此类攻击。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: So far, we have analyzed and learned about the PHP language itself – including
    data types, expressions, operators, and control statements – and how to use them
    in functions and classes. Before we jump into building a web application using
    what we have learned so far, it is crucial to understand client-server communication
    in a web application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经分析了PHP语言本身——包括数据类型、表达式、运算符和控制语句——以及如何在函数和类中使用它们。在我们利用所学知识构建一个网络应用程序之前，理解网络应用程序中的客户端-服务器通信至关重要。
- en: A web application (that is, a website) is designed to return a response for
    each request, which leads to a **Request-Response cycle**. In the web application
    world, this cycle is done through **Hypertext Transfer Protocol** (**HTTP**),
    which is a protocol that ensures both sides communicate with the same language
    or structure. HTTP requires data to be sent in two ways – from the client to the
    server (the request), and then the other way around; that is, from the server
    to the client (the response), closing the cycle. The Request-Response cycle doesn't
    necessarily mean a hit in application logic; it can be a request for a resource,
    such as a CSS file, an image, or even a PDF file. Essentially, most file downloads
    are the result of an HTTP request. All typical web applications require some HTTP
    requests to deliver on the WWW.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序（即网站）被设计为对每个请求返回一个响应，这导致了**请求-响应周期**。在Web应用程序的世界里，这个周期是通过**超文本传输协议**（**HTTP**）来完成的，这是一个确保双方使用相同的语言或结构的协议。HTTP要求以两种方式发送数据——从客户端到服务器（请求），然后反过来；也就是说，从服务器到客户端（响应），从而完成周期。请求-响应周期并不一定意味着在应用逻辑中发生冲突；它可能是一个对资源的请求，例如CSS文件、图片，甚至是PDF文件。本质上，大多数文件下载都是HTTP请求的结果。所有典型的Web应用程序都需要一些HTTP请求来在WWW上提供内容。
- en: In this chapter, we will perform HTTP requests using various HTTP methods. We
    will handle these HTTP requests in PHP by sanitizing and validating the input
    data, and we will learn how to protect against malicious requests. By the end
    of this chapter, you will have built your first web application using basic authentication,
    file upload, and temporary data storage features.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用各种HTTP方法执行HTTP请求。我们将通过清理和验证输入数据来在PHP中处理这些HTTP请求，并学习如何保护应用程序免受恶意请求的侵害。到本章结束时，你将使用基本身份验证、文件上传和临时数据存储功能构建你的第一个Web应用程序。
- en: The Request-Response Cycle of a Web Application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络应用程序的请求-响应周期
- en: To understand how an application loads in a browser, or how it gets data from
    a server, it is important to know about the Request-Response cycle. The Request-Response
    model is used extensively and it's not only applicable to web applications (such
    as using a browser). In fact, it's also used in the communication between machines;
    for example, for fetching data from a database, which involves the application
    system on one side and the database system on the other side. In this case, the
    application is the client for the database system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解应用程序如何在浏览器中加载，或者它是如何从服务器获取数据的，了解请求-响应周期非常重要。请求-响应模型被广泛使用，并且不仅适用于Web应用程序（如使用浏览器）。实际上，它也用于机器之间的通信；例如，从数据库获取数据，这涉及到应用系统的一侧和数据库系统的一侧。在这种情况下，应用程序是数据库系统的客户端。
- en: HTTP is the most commonly used protocol for web applications and, since it could
    take up a whole book itself, we'll cover only the most important part here, explaining
    how it works.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是Web应用程序中最常用的协议，由于它可能需要整本书来介绍，我们在这里只介绍最重要的部分，解释它是如何工作的。
- en: 'Each web application takes a request and prepares a response for it. Usually,
    the Request-Response cycle for a web application looks similar to this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Web应用都会接收一个请求并为它准备一个响应。通常，Web应用的请求-响应周期看起来类似于以下这样：
- en: The client makes a request; for example, `GET /path`.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发起一个请求；例如，`GET /path`。
- en: The server receives the request and looks for an existing or static file for
    the specified URI, which is returned to the client. If the static file is not
    there, then the request is treated as dynamic and it is sent to the application.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器接收请求并查找指定URI的现有或静态文件，并将其返回给客户端。如果静态文件不存在，则将请求视为动态请求，并将其发送到应用程序。
- en: The application prepares and sends a response back (that is, it processes the
    request) to the server layer.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序准备并发送响应回服务器层（即，它处理请求）。
- en: 'The server forwards the response from the application to the client:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器将应用程序的响应转发给客户端：
- en: '![Figure 6.1: The Request-Response Cycle for a web application'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1：Web应用的请求-响应周期'
- en: '](img/C14196_06_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_01.jpg)'
- en: 'Figure 6.1: The Request-Response Cycle for a web application'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：Web应用的请求-响应周期
- en: 'Let''s understand what''s going on here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这里发生了什么：
- en: The **CLIENT** of a web application is usually the browser, so I'll stick to
    using the browser as a client for the following. Each time a URL is accessed through
    a browser's address bar, a form is submitted or a background call is performed
    with AJAX, and a new request is made to that URL. Following the hostname (or website
    domain), which is an alias for a server's IP address, the request will hit a server.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Web应用的**客户端**通常是浏览器，所以以下内容我将坚持使用浏览器作为客户端。每次通过浏览器的地址栏访问URL、提交表单或执行AJAX的背景调用时，都会向该URL发出新的请求。在主机名（或网站域名）之后，它是服务器IP地址的别名，请求将击中服务器。
- en: The **SERVER** role is very important for a web application. In this case, it
    will try to route only dynamic requests to the PHP application. Therefore, one
    rule in the server's configuration could be to check for files inside the public
    web directory of the application, given the URI, and then return the file if that
    one exists; if the file is not there, treat the request as dynamic and forward
    it to the PHP application.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务器**在Web应用中扮演着非常重要的角色。在这种情况下，它将尝试仅将动态请求路由到PHP应用程序。因此，服务器配置中的一条规则可能是检查应用程序公共Web目录内的文件，根据URI返回文件；如果文件不存在，则将请求视为动态请求并将其转发到PHP应用程序。'
- en: The application receives the request and, based on it, it will perform certain
    actions such as fetching a list of heroes from the database and listing them in
    a specific order, and then the response will be prepared and sent back.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序接收请求并根据它执行某些操作，例如从数据库中检索英雄列表并按特定顺序列出它们，然后准备响应并发送回去。
- en: The server will simply forward that response to the open request.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器将简单地转发那个响应到开放的请求。
- en: Of course, this is a simplistic example of an application infrastructure setup
    and a basic example of the Request-Response cycle. Nowadays, especially when you
    design a web application while having scalability in mind, the diagram would look
    very different. However, the good thing is that you, as the developer, don't have
    to worry about this, or at least not yet.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个简化的应用程序基础设施设置和请求-响应周期的基础示例。如今，尤其是在考虑可扩展性的情况下设计Web应用时，图表看起来会非常不同。然而，好事是作为开发者的你不必担心这一点，或者至少目前不必。
- en: What is important to bear in mind here is that each web application is designed
    to respond to a request with a response, no matter where the request comes from
    – be it a `nginx` server or the built-in one – because all requests will look
    the same.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要记住的是，每个Web应用都是设计用来对请求做出响应的，无论请求来自何方——无论是`nginx`服务器还是内置服务器——因为所有请求看起来都是一样的。
- en: A Typical HTTP Request
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 典型的HTTP请求
- en: Each HTTP request is parsed by PHP automatically.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTP请求都会由PHP自动解析。
- en: 'Here is an example of an HTTP request, when accessing the [https://www.packtpub.com/tech](https://www.packtpub.com/tech)
    URL:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个HTTP请求的示例，当访问[https://www.packtpub.com/tech](https://www.packtpub.com/tech)
    URL时：
- en: '![Figure 6.2: A sample HTTP request'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2：一个示例HTTP请求'
- en: '](img/C14196_06_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_02.jpg)'
- en: 'Figure 6.2: A sample HTTP request'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：一个示例HTTP请求
- en: These headers are generated by the web browser in this case. From this request,
    the application can make use of a lot of information. First of all, this is a
    `GET` request for the `/tech` URI, using the `HTTP/1.1` protocol (line 1) and
    the called host is (line 2). The browser sets these parameters based on the URL
    in the address bar. The `Connection` header is set to a `keep-alive`, meaning
    the connection to the server is not closed and subsequent requests to that server
    can be made (line 3).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标头是由浏览器生成的。从这个请求中，应用程序可以利用大量信息。首先，这是一个针对 `/tech` URI 的 `GET` 请求，使用 `HTTP/1.1`
    协议（第 1 行），调用主机是（第 2 行）。浏览器根据地址栏中的 URL 设置这些参数。`Connection` 标头设置为 `keep-alive`，意味着与服务器的连接不会关闭，并且可以对该服务器发出后续请求（第
    3 行）。
- en: 'The `Upgrade-Insecure-Requests` header gives a hint to the server to let it
    know that the client prefers an encrypted and authenticated response (that is,
    it prefers HTTPS over HTTP). The `User-Agent` header contains the client information
    – in this case, it is the Chromium browser – providing useful information about
    the build. The `Accept` header gives us a hint about the content expected by the
    client, grouped by quality. The `q` here is called the factor weighting and it
    gives the quality of each value in this header entry, where a greater number is
    associated with greater quality. The default is `*/*`, meaning that any content
    type is expected. So, in our case, it appears with the lowest quality: `0.8`.
    `Accept-Encoding` details the content encoding of the response, which the client
    is able to understand. The `Accept-Language` header details which languages the
    client is able to understand and which locales are preferred; again, this is grouped
    by priority, using the same `q` weighting factor. The `Cookie` header is one of
    the most important headers and is one convenient way to send data from the client
    to the server. We will talk more about this later.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Upgrade-Insecure-Requests` 标头向服务器提供提示，让服务器知道客户端更喜欢加密和认证的响应（即，它更喜欢 HTTPS 而不是
    HTTP）。`User-Agent` 标头包含客户端信息——在这种情况下，它是 Chromium 浏览器——提供有关构建的有用信息。`Accept` 标头给我们提供了客户端期望的内容的提示，按质量分组。这里的
    `q` 被称为因子权重，它给出了此标头条目中每个值的品质，其中较大的数字与较高的品质相关联。默认值为 `*/*`，意味着期望任何内容类型。因此，在我们的情况下，它以最低的品质出现：`0.8`。`Accept-Encoding`
    详细说明了响应的内容编码，客户端能够理解。`Accept-Language` 标头详细说明了客户端能够理解的语言以及首选的区域设置；同样，这也是按优先级分组，使用相同的
    `q` 权重因子。`Cookie` 标头是最重要的标头之一，是从客户端向服务器发送数据的一种方便方式。我们将在稍后更多地讨论这一点。'
- en: A Typical HTTP Response
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 典型的 HTTP 响应
- en: 'For the previous request, we will get the following response headers:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前的请求，我们将得到以下响应标头：
- en: '![Figure 6.3 A sample HTTP response'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 一个示例 HTTP 响应'
- en: '](img/C14196_06_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 C14196_06_03.jpg](img/C14196_06_03.jpg)'
- en: Figure 6.3 A sample HTTP response
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 一个示例 HTTP 响应
- en: 'The most important information in a response is the response status, with **2xx**
    being associated with successful requests. A full list of statuses can be found
    at [https://packt.live/2owOHG2](https://packt.live/2owOHG2). In our case, we got
    **200 OK**, which means the request succeeded. Among the most well-known HTTP
    response statuses are the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 响应中最重要的信息是响应状态，其中 **2xx** 与成功请求相关联。状态的全列表可以在 [https://packt.live/2owOHG2](https://packt.live/2owOHG2)
    找到。在我们的情况下，我们得到了 **200 OK**，这意味着请求成功。在众多知名的 HTTP 响应状态中，以下是一些：
- en: '![Figure 6.4: HTTP response statuses'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.4：HTTP 响应状态'
- en: '](img/C14196_06_04.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 C14196_06_04.jpg](img/C14196_06_04.jpg)'
- en: 'Figure 6.4: HTTP response statuses'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：HTTP 响应状态
- en: 'Some of the most common headers include the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最常见的标头包括以下内容：
- en: '**Date**: This represents the date and time the HTTP response message was created.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Date**：这代表 HTTP 响应消息创建的日期和时间。'
- en: '**Content-Type**: This is used to indicate the media type (or **Multipurpose
    Internet Mail Extensions** (**MIME**) type) of the resource.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Content-Type**：这用于指示资源的媒体类型（或 **Multipurpose Internet Mail Extensions** （MIME）类型）。'
- en: 'Expires: This contains the date/time after which the response is considered
    outdated.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Expires：这包含响应被认为过时的日期/时间。
- en: '**Cache-Control**: This is used to specify directives for caching mechanisms.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cache-Control**：这用于指定缓存机制的指令。'
- en: '`gzip`, `deflate`, and the `br` header, showing that `gzip` is a known encoding
    mechanism that the browser uses. So, the server used it to compress the data using
    `gzip`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gzip`、`deflate` 和 `br` 标头，表明 `gzip` 是浏览器使用的已知编码机制。因此，服务器使用 `gzip` 对数据进行压缩。'
- en: 'Non-standard **X-** prefixed headers: Although this convention has been deprecated
    already, it is still used for custom proprietary headers.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非标准 **X-** 前缀的头部：尽管这个约定已经被弃用，但它仍然用于自定义专有头部。
- en: Request Methods
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求方法
- en: As we previously mentioned, the request has a `GET` token right at the beginning
    of the message, meaning that it is a request of the `GET` type. This is one of
    the most commonly used HTTP request types because it is a means of fetching data
    from a server, be it an HTML page, an image, a `PDF` document, or plaintext data.
    As you might guess, there are more types of HTTP requests, and these are `POST`,
    `OPTIONS`, `HEAD`, `PUT`, and `DELETE`, among others. We will not cover all of
    these here, except the essential ones.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，请求在消息的开头有一个 `GET` 令牌，这意味着它是一个 `GET` 类型的请求。这是最常用的 HTTP 请求类型之一，因为它是一种从服务器获取数据的方式，无论是
    HTML 页面、图像、`PDF` 文档还是纯文本数据。正如你可能猜到的，还有更多类型的 HTTP 请求，包括 `POST`、`OPTIONS`、`HEAD`、`PUT`
    和 `DELETE` 等。我们在这里不会涵盖所有这些，只介绍必要的。
- en: GET HTTP Requests
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GET HTTP 请求
- en: The `GET HTTP` request is the most commonly used for a web application. It provides
    the necessary information for the resource that is requested from the server.
    This resource information can be placed in the `query string`, the `path` of the
    URL, or both.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET HTTP` 请求是用于 Web 应用程序中最常用的。它提供了从服务器请求的资源所需的信息。这些资源信息可以放在 `query string`、URL
    的 `path` 或两者中。'
- en: 'Let''s inspect how the [https://www.packtpub.com/tech/PHP](https://www.packtpub.com/tech/PHP)
    URL is composed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 [https://www.packtpub.com/tech/PHP](https://www.packtpub.com/tech/PHP)
    URL 的组成：
- en: First, we have the protocol – `https` – meaning the secured HTTP protocol is
    used.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们有协议 – `https` – 这意味着使用了安全的 HTTP 协议。
- en: Then, it's the hostname, pointing to the location of the required resource.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，是主机名，指向所需资源的位置。
- en: And, finally, there is the path, pointing to the *resource identifier*.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，是路径，指向 *资源标识符*。
- en: 'So, we can say the URL describes *how* (`https`), *where* from ([www.packtpub.com](http://www.packtpub.com)),
    and *what* (`/tech/PHP`) is requested, especially when it''s about `GET` requests.
    This is visualized in the following figure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以这样说，URL 描述了 *如何* (`https`)，*从哪里* ([www.packtpub.com](http://www.packtpub.com))，以及
    *什么* (`/tech/PHP`) 被请求，尤其是在涉及到 `GET` 请求的情况下。这在下图中得到了可视化：
- en: '![Figure 6.5: An interpretation of the URL components'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.5：URL 组件的解释'
- en: '](img/C14196_06_05.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_05.jpg)'
- en: 'Figure 6.5: An interpretation of the URL components'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：URL 组件的解释
- en: 'Important: *For security reasons, do not use GET to send sensitive information,
    such as login credentials*. Since `GET` uses query strings to send data, and this
    data is part of the URL, which is visible to everyone. Therefore, it remains in
    the browser history – this means that your browser will essentially keep your
    login URL in its history. This can be observed in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：*出于安全原因，请不要使用 GET 发送敏感信息，例如登录凭据*。因为 `GET` 使用查询字符串发送数据，而这些数据是 URL 的一部分，对每个人都是可见的。因此，它将保留在浏览器历史记录中——这意味着您的浏览器实际上会将您的登录
    URL 保留在其历史记录中。这可以在下图中观察到：
- en: '![Figure 6.6 Sending login credentials via the GET HTTP method'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.6 通过 GET HTTP 方法发送登录凭据'
- en: '](img/C14196_06_06.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_06.jpg)'
- en: Figure 6.6 Sending login credentials via the GET HTTP method
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 通过 GET HTTP 方法发送登录凭据
- en: This is just one example of how this method is bad for sending sensitive information.
    A better approach is to use the `POST` method for sending data that you don't
    want to store in the browser's history; this data could include login credentials,
    updating your profile with personal (or any) details, file uploads, and questionnaires.
    On the contrary, sending HTML forms using the `GET` method would be appropriate
    in the case of a page with a list of items, where we need to do filtering and
    sorting. Therefore, it is appropriate for the filter and sort parameters to be
    present in the query string component of the URL, so that when we bookmark or
    share the URL, you can get the same filtered and sorted items when accessing the
    URL later or from another browser or location.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是说明这种方法在发送敏感信息时很糟糕的一个例子。更好的方法是使用 `POST` 方法发送您不希望存储在浏览器历史记录中的数据；这些数据可能包括登录凭据、更新您的个人（或任何）详细信息、文件上传和问卷调查。相反，在需要过滤和排序的页面列表中使用
    `GET` 方法是合适的。因此，将过滤和排序参数放在 URL 的查询字符串组件中是合适的，这样当我们标记或分享 URL 时，您可以在稍后或从另一个浏览器或位置访问
    URL 时获得相同的过滤和排序项。
- en: POST HTTP Requests
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POST HTTP 请求
- en: 'The `POST` requests are used to create, alter, and/or delete resources on a
    server. This is due to the fact that `POST` requests have a body and not only
    headers. So, you can `POST` to `/some/uri` and send data in the request body in
    two ways: by default, as URL-encoded parameters (`application/x-www-form-urlencoded
    enctype`); or as multipart form data (`multipart/form-data enctype`). The difference
    between these two methods is based on what kind of data is sent to the server.
    So, when you want to upload an image, a PDF document, or any other file, you would
    use multipart form data; otherwise, URL-encoded data is enough.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`请求用于在服务器上创建、修改和/或删除资源。这是因为`POST`请求有一个主体，而不仅仅是头部。因此，你可以向`/some/uri`发送`POST`请求并在请求主体中发送数据，有两种方式：默认情况下，作为URL编码的参数（`application/x-www-form-urlencoded
    enctype`）；或者作为多部分表单数据（`multipart/form-data enctype`）。这两种方法之间的区别基于发送到服务器的数据类型。因此，当你想要上传图片、PDF文档或其他文件时，你会使用多部分表单数据；否则，URL编码的数据就足够了。'
- en: 'Sending multipart form data from HTML is enough to add the `enctype` attribute
    to the `form` element, as shown in the following snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从HTML发送多部分表单数据时，只需将`enctype`属性添加到`form`元素中，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Additionally, the browser will set the appropriate `Content-Type` request header,
    which would look like the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，浏览器将设置适当的`Content-Type`请求头，如下所示：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The **boundary** term here is used to specify a sent content delimiter, preferably
    a random non-dictionary string, which is less likely to appear in the sent payload.
    In the case of using HTML forms in the browser, you don't have to care about this
    parameter, as its value is generated and set automatically by the browser.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用的**边界**术语用于指定发送内容分隔符，最好是一个随机非字典字符串，它不太可能出现在发送的有效载荷中。在使用浏览器中的HTML表单时，你不必关心这个参数，因为它的值是由浏览器自动生成和设置的。
- en: 'Instead, when you only want to send some mapped textual data, without an upload,
    you can use `application/x-www-form-urlencoded` for the `enctype` attribute, which
    is set as the default when the `enctype` attribute is missing, as shown in the
    following snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当你只想发送一些映射的文本数据，而不进行上传时，你可以使用`application/x-www-form-urlencoded`作为`enctype`属性，当`enctype`属性缺失时，它被设置为默认值，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The URL-encoded form is very easy to send with command-line tools, such as `curl`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: URL编码的表单使用命令行工具，如`curl`发送非常简单。
- en: 'A sample command for the preceding `form` element would look like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`form`元素的示例命令如下所示：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is assuming that `127.0.0.1:8080` is where our server is listening and
    `form-url-encoded.php` is the PHP file that will process the request.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设`127.0.0.1:8080`是我们服务器监听的位置，而`form-url-encoded.php`是处理请求的PHP文件。
- en: What method should be used in the case of sign-up, a newsletter subscription,
    and a content search form? Why?
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在注册、订阅通讯录和内容搜索表单的情况下，应该使用哪种方法？为什么？
- en: What are some other use cases for submitting the `form` with the `POST` and
    `GET` methods? (For example, posting comments, rating a product, pagination, and
    more.)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`POST`和`GET`方法提交`form`有哪些其他用例？（例如，发表评论、评分产品、分页等。）
- en: Some servers will limit the query string length to 1,024 characters; for example,
    in the case of `Internet Information Server` (`IIS`). This limit can be configured
    in any server, but with daily use, it is less likely that you would encounter
    such an issue. Unlike the `GET` method, with `POST`, you have *no limit* on the
    data you can send over an HTTP request. Currently, the default limit for the `POST`
    payload in PHP per request is 8 MB, which can be increased at will in the settings.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一些服务器将查询字符串长度限制为1,024个字符；例如，在`Internet Information Server`（`IIS`）的情况下。这个限制可以在任何服务器上配置，但在日常使用中，你不太可能遇到这样的问题。与`GET`方法不同，使用`POST`，你发送HTTP请求的数据没有限制。目前，PHP中每个请求的`POST`有效载荷默认限制为8
    MB，可以在设置中随意增加。
- en: Query Strings
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询字符串
- en: A query string is part of a URL, containing data described in key-value pairs.
    Each key-value pair is delimited by the ampersand character (`&`), while the delimiter
    of a URL path from its query string is a question mark (`?`).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串是URL的一部分，包含以键值对形式描述的数据。每个键值对由与符号（`&`）分隔，而URL路径与其查询字符串之间的分隔符是一个问号（`?`）。
- en: 'As an example, we''ll use the following fictive URL:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，我们将使用以下虚构的URL：
- en: '[https://www.bookstore.com/books/?category=Comics&page=2](https://www.bookstore.com/books/?category=Comics&page=2).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.bookstore.com/books/?category=Comics&page=2](https://www.bookstore.com/books/?category=Comics&page=2)。'
- en: Here, the query string is `category=Comics&page=2` and the parameters are `category`
    and `page` with `Comics` and `2` values, respectively. It is worth noting that
    the parameters that can hold data are then parsed as arrays of values. For example,
    given the `/filter?tags[]=comics&tags[]=recent` URI, the tags query string parameter
    will result in an array with two values – `comics` and `recent`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，查询字符串是`category=Comics&page=2`，参数是`category`和`page`，分别对应`Comics`和`2`的值。值得注意的是，可以存储数据的参数随后被解析为值的数组。例如，给定`/filter?tags[]=comics&tags[]=recent`
    URI，标签查询字符串参数将产生一个包含两个值——`comics`和`recent`的数组。
- en: Query strings are mostly used to access resources on the server, rather than
    as instructions to create, update, or delete. So, sharing a URL with a query string
    would list the same results in any browser, when no other contexts are interfering
    (such as logged-in user preferences, visitor location, or others). Take a look
    at what the URL looks like after you perform a search in your favorite search
    engine.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串主要用于访问服务器上的资源，而不是作为创建、更新或删除的指令。因此，当没有其他上下文干扰（如登录用户偏好、访客位置或其他）时，带有查询字符串的URL在任何浏览器中都会列出相同的结果。看看您在最喜欢的搜索引擎中进行搜索后URL看起来像什么。
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Learn more about HTTP at [https://developer.mozilla.org/en-US/docs/Glossary/HTTP](https://developer.mozilla.org/en-US/docs/Glossary/HTTP).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://developer.mozilla.org/en-US/docs/Glossary/HTTP](https://developer.mozilla.org/en-US/docs/Glossary/HTTP)了解更多关于HTTP的信息。
- en: Learn more about URLs at [https://packt.live/33p2o8y](https://packt.live/33p2o8y)
    or [https://packt.live/2BcUNxL](https://packt.live/2BcUNxL).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://packt.live/33p2o8y](https://packt.live/33p2o8y)或[https://packt.live/2BcUNxL](https://packt.live/2BcUNxL)了解更多关于URL的信息。
- en: Learn more about query strings at [https://packt.live/31fFtey](https://packt.live/31fFtey).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://packt.live/31fFtey](https://packt.live/31fFtey)了解更多关于查询字符串的信息。
- en: PHP Superglobals
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP超全局变量
- en: The PHP engine uses a list of built-in variables that are accessible anywhere
    in a PHP script, called **superglobals**. These superglobals contain data that
    is mostly related to requests, but they also contain some server information and
    running PHP script file information as well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: PHP引擎使用一组可在PHP脚本中的任何位置访问的内置变量，称为**超全局变量**。这些超全局变量包含的数据大多与请求相关，但也包含一些服务器信息和正在运行的PHP脚本文件信息。
- en: The most frequently used superglobals are the `$_SERVER`, `$_SESSION`, `$_GET`,
    `$_POST`, `$_COOKIE`, and `$_FILES` variables.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的超全局变量是`$_SERVER`、`$_SESSION`、`$_GET`、`$_POST`、`$_COOKIE`和`$_FILES`变量。
- en: A good practice is to not mess with superglobals across a project, meaning it
    would be better not to alter the existing data or to add more or remove data from
    these variables. Ideally, you would only access them once per request. `$_SESSION`
    is an exception in this matter, as its data is provided by the application and
    not by the PHP engine.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的实践是在整个项目中不要随意修改超全局变量，这意味着最好不要修改现有数据，也不要从这些变量中添加或删除数据。理想情况下，您应该只在每个请求中访问一次。`$_SESSION`是这方面的一个例外，因为其数据由应用程序提供，而不是由PHP引擎提供。
- en: You can always learn about superglobals in more depth by visiting the official
    PHP documentation page, at [http://php.net/manual/en/language.variables.superglobals.php](http://php.net/manual/en/language.variables.superglobals.php).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问官方PHP文档页面深入了解超全局变量，页面地址为[http://php.net/manual/en/language.variables.superglobals.php](http://php.net/manual/en/language.variables.superglobals.php)。
- en: $_SERVER
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $_SERVER
- en: The `$_SERVER` superglobal contains request headers, server information, paths,
    environment variables, and other data set by the web server. In short, request
    headers' names are converted to uppercase, the `-` (dash) is replaced by `_` (underscore),
    and `HTTP_` is prepended (the `User-Agent` header name becomes `HTTP_USER_AGENT`
    in `$_SERVER`). Requested information field names (such as URI and method) are
    prefixed with `REQUEST_`, and so on. Most of these names in the `$_SERVER` superglobal
    are accounted for in the `CGI/1.1 specification`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`$_SERVER` 超全局变量包含请求头、服务器信息、路径、环境变量以及由网络服务器设置的其他数据。简而言之，请求头的名称被转换为大写，`-`（破折号）被替换为`_`（下划线），并在前面添加`HTTP_`（例如，`User-Agent`头名称变为`HTTP_USER_AGENT`）。请求的信息字段名称（如URI和方法）前面加上`REQUEST_`前缀，等等。`$_SERVER`超全局变量中的大多数名称都在`CGI/1.1规范`中有说明。'
- en: 'Exercise 6.1: Dumping the $_SERVER Data'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.1：输出$_SERVER数据
- en: In the following exercise, we will dump the `$_SERVER` data in the browser for
    each HTTP request and will identify the key data used by the web application.
    Before we continue, please create a directory and use the Terminal to navigate
    into that new directory. All the created files will be saved into this directory;
    for example, let's assume the created directory is `/app`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将向浏览器中转储每个HTTP请求的`$_SERVER`数据，并识别Web应用程序使用的键数据。在我们继续之前，请创建一个目录并使用终端导航到该新目录。所有创建的文件都将保存在此目录中；例如，假设创建的目录是`/app`。
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In order to send an HTTP request to the PHP script (that is, to access the
    script through the browser), you need to start the built-in PHP development server.
    In order to do so, run the command that will start the development server in your
    `/app` working directory: `php -S 127.0.0.1`. Keep the server running for the
    next exercises as well.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向PHP脚本发送HTTP请求（即通过浏览器访问脚本），你需要启动内置的PHP开发服务器。为此，请在`/app`工作目录中运行启动开发服务器的命令：`php
    -S 127.0.0.1`。为了进行接下来的练习，请保持服务器运行。
- en: 'Create a PHP file called `super-server.php` and write the following code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`super-server.php`的PHP文件，并写入以下代码：
- en: '[PRE4]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Access the file through the built-in server, at `http://127.0.0.1:8080/super-server.php/my-path?my=query-string`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过内置服务器访问文件，在`http://127.0.0.1:8080/super-server.php/my-path?my=query-string`。
- en: 'The output should look like the following:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应该看起来像以下这样：
- en: '![Figure 6.7 The server data in the browser window'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.7 浏览器窗口中的服务器数据'
- en: '](img/C14196_06_07.jpg)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图C14196_06_07.jpg](img/C14196_06_07.jpg)'
- en: Figure 6.7 The server data in the browser window
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.7 浏览器窗口中的服务器数据
- en: 'Run the `super-server.php` file in the Terminal using the following:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在终端中运行`super-server.php`文件：
- en: '[PRE5]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output should look like the following:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应该看起来像以下这样：
- en: '![Figure 6.8 Server data in the Terminal'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8 终端中的服务器数据'
- en: '](img/C14196_06_08.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_08.jpg)'
- en: Figure 6.8 Server data in the Terminal
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 终端中的服务器数据
- en: Some often-used inputs in the case of scripts invoked by *WWW* (run due to the
    URL access) are `REQUEST_URI`; `REQUEST_METHOD`; `PATH_INFO`; `REMOTE_ADDR`, which
    is the network address of the client sending the request (or `HTTP_X_FORWARDED_FOR`
    when running your application behind a load balancer or a reverse proxy, for example);
    and `HTTP_USER_AGENT`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在由*WWW*（由于URL访问而运行）调用的脚本中，常用的输入有`REQUEST_URI`；`REQUEST_METHOD`；`PATH_INFO`；`REMOTE_ADDR`，这是发送请求的客户端的网络地址（或者在运行你的应用程序在负载均衡器或反向代理后面时，例如，使用`HTTP_X_FORWARDED_FOR`）；以及`HTTP_USER_AGENT`。
- en: In the preceding script, you will notice that the `/my-path` path is parsed
    in `PATH_INFO` and the query string in `QUERY_STRING`, while the entire URI is
    available in `REQUEST_URI`. These are the inputs used to route the requests to
    the appropriate PHP scripts in a web application so that the scripts can process
    them and produce the response.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的脚本中，你会注意到`/my-path`路径在`PATH_INFO`中解析，而查询字符串在`QUERY_STRING`中，整个URI在`REQUEST_URI`中可用。这些是用于将请求路由到Web应用程序中适当的PHP脚本，以便脚本可以处理它们并生成响应的输入。
- en: In the case of command-line scripts (run in Terminal or scheduled to run by
    the system at specific intervals), the most common `$_SERVER` inputs are `argv`
    and `argc`, as well as `REQUEST_TIME` and `REQUEST_TIME_FLOAT`, and `PWD`. `argv`
    is the list of argument values passed to the PHP executable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行脚本（在终端中运行或在系统特定间隔内计划运行）的情况下，最常用的`$_SERVER`输入是`argv`和`argc`，以及`REQUEST_TIME`和`REQUEST_TIME_FLOAT`，以及`PWD`。`argv`是传递给PHP可执行程序的参数值列表。
- en: The first argument (position zero) is the file being executed (or a static sentence,
    Standard input code, in the case of the running inline PHP code; for example,
    `php -r 'print_r($_SERVER);'`). Now, `argc` is the count of input arguments. `REQUEST_TIME`
    and `REQUEST_TIME_FLOAT` represent the time when the script started the execution,
    and are used for logging purposes or miscellaneous benchmarks. `PWD` is the current
    working directory and is useful in cases when the script should perform actions
    relative to the current location on disk, such as opening files or saving into
    files in the current directory.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数（位置零）是要执行的文件（或静态语句，标准输入代码，在运行内联PHP代码的情况下；例如，`php -r 'print_r($_SERVER);'`）。现在，`argc`是输入参数的计数。`REQUEST_TIME`和`REQUEST_TIME_FLOAT`代表脚本开始执行的时间，用于日志记录或各种基准测试。`PWD`是当前工作目录，在脚本应该相对于磁盘上的当前位置执行操作时很有用，例如打开文件或保存到当前目录中的文件。
- en: Unlike the request made from the browser, the `$_SERVER` variable has much less
    data when running in the command-line interface. There are no more `HTTP_*` entries
    and no more `SERVER_*` entries, since the request is not via HTTP anymore; `QUERY_STRING`
    and `REQUEST_METHOD` are also missing, among others.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与从浏览器发出的请求不同，在命令行界面运行时，`$_SERVER` 变量包含的数据要少得多。没有更多的 `HTTP_*` 条目和 `SERVER_*`
    条目，因为请求不再是通过 HTTP 进行；`QUERY_STRING` 和 `REQUEST_METHOD` 等其他内容也缺失。
- en: $_COOKIE
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $_COOKIE
- en: The `$_COOKIE` superglobal contains all the cookie data stored in the browser
    (when the browser is the HTTP client), stored by the same host, through the response
    headers or JavaScript. Since HTTP requests are stateless — meaning they are independent
    and unrelated to each other — using cookies is a great way to keep track of the
    user session in a web application, and also to offer a tailored experience for
    each visitor. Think of settings related to ad preferences, reference code to track
    conversions coming from several sources, and others. Cookies are *invisible* data;
    that is, they are not to be found in the URL and are not triggered by the submit
    button of an HTML form. They are set in the browser by the application, and the
    browser sends them with each HTTP request. Cookies are visible to browser users
    and, more than that, they can be removed by users — a fact an application is required
    to deal with.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`$_COOKIE` 超全局变量包含在浏览器中存储的所有cookie数据（当浏览器是HTTP客户端时），由同一主机通过响应头或JavaScript存储。由于HTTP请求是无状态的
    – 意味着它们是独立且相互无关的 – 使用cookie是跟踪Web应用程序中用户会话的绝佳方式，同时也为每位访客提供定制体验。想想与广告偏好设置相关的设置，跟踪来自多个来源的转换的参考代码，以及其他。Cookies是**不可见**的数据；也就是说，它们不会出现在URL中，也不会由HTML表单的提交按钮触发。它们由应用程序在浏览器中设置，并且浏览器会在每个HTTP请求中发送它们。Cookies对浏览器用户是可见的，更重要的是，用户可以删除它们
    – 这是一个应用程序必须处理的事实。'
- en: It is possible to store cookies using PHP's built-in function, `setcookie()`,
    and we can get those key-value pairs in the next HTTP requests from the `$_COOKIE`
    superglobal. To set a cookie, it's enough to call `setcookie("cookie_name", "cookie_value")`,
    and the value will be stored until the browser is closed. Alternatively, to make
    the cookie live longer than the browser session, you must specify the cookie's
    expiration time in the third argument of the function, as a Unix timestamp. For
    example, to allow a cookie to last for two days, you could call `setcookie("cookie_name",
    "cookie_value", time()+60*60*24*2)`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 PHP 内置函数 `setcookie()` 存储cookie，我们可以在后续的 HTTP 请求中从 `$_COOKIE` 超全局变量中获取这些键值对。要设置一个cookie，只需调用
    `setcookie("cookie_name", "cookie_value")`，其值将存储到浏览器关闭为止。或者，为了使cookie的寿命超过浏览器会话，必须在函数的第三个参数中指定cookie的过期时间，作为一个Unix时间戳。例如，要允许cookie持续两天，可以调用
    `setcookie("cookie_name", "cookie_value", time()+60*60*24*2)`。
- en: The `setcookie()` function accepts a cookie name as the first parameter, the
    cookie value as the second parameter, and the Unix time in seconds for the expiration
    as the third parameter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`setcookie()` 函数接受一个cookie名称作为第一个参数，cookie值作为第二个参数，Unix时间（以秒为单位）作为过期时间的第三个参数。'
- en: 'The syntax is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The parameters are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '**name**: The cookie name.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**name**：cookie的名称。'
- en: '**value**: The cookie value; this is optional.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**value**：cookie值；这是可选的。'
- en: '**expires**: The expiration time, as a timestamp – this is optional; if omitted,
    the cookie will be deleted after the browser closes.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**expires**：过期时间，作为一个时间戳 – 这是可选的；如果省略，cookie将在浏览器关闭后删除。'
- en: '`/tech` (this is optional).'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/tech`（这是可选的）。'
- en: '**domain**: The (sub)domain for which the cookie will be available. Cookies
    set in the current domain will become available for any subdomain of the current
    domain; this is an optional parameter.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**domain**：cookie可用的（子）域名。在当前域名中设置的cookie将可用于当前域的任何子域名；这是一个可选参数。'
- en: '**secure**: This indicates that the cookie is set and transmitted only through
    the HTTPS request (that is, a secured request); this is optional.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**secure**：这表示cookie仅通过HTTPS请求（即安全请求）设置和传输；这是可选的。'
- en: '**httponly**: This indicates that the cookie is only available for HTTP requests;
    this is not available to scripting languages such as JavaScript on the client
    side (that is, the browser). This is an optional parameter.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**httponly**：这表示cookie仅对HTTP请求可用；在客户端的脚本语言（如JavaScript）中不可用（即浏览器）。这是一个可选参数。'
- en: '`expires`, `path`, `domain`, `secure`, `httponly`, and `samesite` keys. The
    values have the same meaning as the parameters with the same name. The value of
    the `samesite` element should be either `Lax` or `Strict`. This parameter is optional.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expires`、`path`、`domain`、`secure`、`httponly`和`samesite`键。这些值的含义与同名的参数相同。`samesite`元素的值应该是`Lax`或`Strict`。此参数是可选的。'
- en: Note
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For the full API of `setcookie()`, please visit [https://packt.live/2MI81YC](https://packt.live/2MI81YC).
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于`setcookie()`函数的完整API，请访问[https://packt.live/2MI81YC](https://packt.live/2MI81YC)。
- en: 'Exercise 6.2: Setting and Reading a Cookie'
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.2：设置和读取cookie
- en: In the following exercise, you will set a cookie and then read it in a PHP script
    using an HTML form to send data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，你将设置一个cookie，然后使用HTML表单发送数据，在PHP脚本中读取它。
- en: 'Here are the steps to perform the exercise:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此练习的步骤如下：
- en: Create a file called `super-cookie.php`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`super-cookie.php`的文件。
- en: 'Store the referral code in cookies so that we can read from it later (for example,
    at sign-up, to know who referred this user to us). The code for this is as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将推荐代码存储在cookie中，以便我们可以在以后读取它（例如，在注册时，以了解谁将此用户推荐给我们）。此代码如下：
- en: '[PRE7]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, the cookie value to be stored will be read from the `refcode` query string
    parameter: `/?refcode=etc`. Therefore, for each request, we will have to check
    for this entry in the `$_GET` variable and, if found, save the cookie with a lifetime
    of 30 days; otherwise, just print `No referral code was set in query string.`
    The cookie name is user-defined and, here, we have called it `ref`.'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，要存储的cookie值将从`refcode`查询字符串参数中读取：`/?refcode=etc`。因此，对于每个请求，我们都需要在`$_GET`变量中检查此条目，如果找到，则保存具有30天生命期的cookie；否则，只需打印`查询字符串中没有设置推荐代码。`cookie名称是用户定义的，在这里我们将其命名为`ref`。
- en: Note
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We use the `time()` function to get the current Unix time, in seconds. Therefore,
    for the current time, we should add 60 (seconds) multiplied by 60 (minutes), multiplied
    by 24 (hours), multiplied by 30 (days), for the cookie to expire after 30 days.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`time()`函数获取当前的Unix时间，以秒为单位。因此，对于当前时间，我们应该加上60（秒）乘以60（分钟）乘以24（小时）乘以30（天），以便cookie在30天后过期。
- en: 'Additionally, when storing the cookie, we may want to know what code was saved
    and include a link to the same script, without the query string, to avoid storing
    the cookie on page refresh. Here is the code to do this:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在存储cookie时，我们可能还想知道保存了什么代码，并包括一个指向同一脚本的链接（不带查询字符串），以避免在页面刷新时存储cookie。执行此操作的代码如下：
- en: '[PRE8]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, write the code to print the cookie value, which is stored in the browser
    and sent to the script in the HTTP request. For this, we have to read the `$_COOKIE`
    variable. If no `ref` entry exists, then display `-NONE-`. The code to do this
    is as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编写代码以打印存储在浏览器中并通过HTTP请求发送到脚本的cookie值。为此，我们必须读取`$_COOKIE`变量。如果不存在`ref`条目，则显示`-NONE-`。执行此操作的代码如下：
- en: '[PRE9]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: From the request when the cookie gets saved for the first time, we will also
    get `-None-`, since the cookie gets saved after a Request-Response cycle is completed
    and, in this case, the request does not have the `ref` cookie (that is, it is
    not present in the browser yet), but has the `refcode` query string parameter,
    which makes the script set the `ref` cookie value in the response (and it will
    then be saved by the browser).
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当第一次保存cookie时，我们也会得到`-None-`，因为cookie是在请求-响应周期完成后保存的，在这种情况下，请求没有`ref`cookie（即它尚未在浏览器中），但有`refcode`查询字符串参数，这使得脚本在响应中设置`ref`cookie值（然后它将被浏览器保存）。
- en: 'Also, to make easy tests sending different referral codes, let''s use a form
    of type `GET`, using input with the `refcode` name (which will appear in `query
    string` in the form submit) and the `EVENT19` default value:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，为了便于发送不同的推荐代码进行测试，让我们使用类型为`GET`的表单，使用具有`refcode`名称的输入（它将在表单提交时出现在`查询字符串`中）和`EVENT19`默认值：
- en: '[PRE10]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: When no method is specified in the HTML `form` element, the default value is
    `GET`.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当在HTML `form`元素中没有指定方法时，默认值是`GET`。
- en: As seen in this example, to use PHP scripts and HTML in the same file, we require
    PHP scripts to be included between the `<?php` and `?>` tokens.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如此例所示，要在同一文件中使用PHP脚本和HTML，我们需要在`<?php`和`?>`标记之间包含PHP脚本。
- en: Note
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can refer the complete code at [https://packt.live/2IMViTs](https://packt.live/2IMViTs).
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.live/2IMViTs](https://packt.live/2IMViTs)找到完整的代码。
- en: Access the file through the built-in server, at `http://127.0.0.1:8080/super-cookie.php`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过内置服务器访问文件，地址为`http://127.0.0.1:8080/super-cookie.php`。
- en: 'The output should look like this:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '![Figure 6.9 The output of super-cookie.php when first accessed'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.9 首次访问super-cookie.php时的输出'
- en: '](img/C14196_06_09.jpg)'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_06_09.jpg)'
- en: Figure 6.9 The output of super-cookie.php when first accessed
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.9 首次访问super-cookie.php时的输出
- en: Click on the `Apply referral code` button, and notice the new page content,
    which should look like this:![](img/C14196_06_10.jpg)
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“应用推荐代码”按钮，注意新页面的内容，它应该看起来像这样:![](img/C14196_06_10.jpg)
- en: 'Figure 6.10: The output of super-cookie.php after submitting the form'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.10：提交表单后super-cookie.php的输出
- en: At this stage, by clicking on the `Apply referral code` button, the form data
    has been serialized to the URL query format (refer to the `refcode=EVENT19` part
    in the preceding diagram). Accessing the form target URL made the script read
    the data from the query string and set the cookie with the provided `EVENT19`
    value.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个阶段，通过点击“应用推荐代码”按钮，表单数据已经被序列化为URL查询格式（参考前面图表中的`refcode=EVENT19`部分）。访问表单目标URL使脚本从查询字符串中读取数据，并使用提供的`EVENT19`值设置cookie。
- en: 'Click on `Clear the query string` and see that the script is able to parse
    and display the cookie data. The output should now display the cookie value, which
    was set in the previous step:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“清除查询字符串”，你会看到脚本能够解析并显示cookie数据。现在输出应显示在上一步骤中设置的cookie值：
- en: '![Figure 6.11: The output of super-cookie.php on subsequent requests'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11：随后的请求中super-cookie.php的输出'
- en: '](img/C14196_06_11.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_11.jpg)'
- en: 'Figure 6.11: The output of super-cookie.php on subsequent requests'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：随后的请求中super-cookie.php的输出
- en: Displaying cookie value on a Chrome DevTools window.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome DevTools窗口中显示cookie值。
- en: '![Figure 6.12 The ref cookie value displayed in a Chrome DevTools window.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.12 在Chrome DevTools窗口中显示的ref cookie值。'
- en: '](img/C14196_06_12.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_12.jpg)'
- en: Figure 6.12 The ref cookie value displayed in a Chrome DevTools window.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 在Chrome DevTools窗口中显示的ref cookie值。
- en: Now the URL contains no query string, meaning that our script has nothing to
    process. The cookie data is sent through, since it was set on the previous request,
    and is displayed on the browser page for each HTTP request.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在URL中不包含查询字符串，这意味着我们的脚本没有要处理的内容。由于在之前的请求中设置了cookie数据，因此它将通过HTTP请求发送，并在浏览器页面上显示。
- en: $_SESSION
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $_SESSION
- en: '`$_SESSION` has nothing to do with the HTTP request, yet it is a very important
    variable, as it holds the `state data` of a user; that is, keeping certain data
    across subsequent requests. Compared to cookies, the session data is stored on
    the server; therefore, the data is not accessible by the client. Session data
    is used to store logged-in user data (at least the ID) and temporary data (such
    as flash messages, CSRF tokens, shopping cart items, and more).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`$_SESSION` 与HTTP请求无关，但它是一个非常重要的变量，因为它保存了用户的`状态数据`；也就是说，在随后的请求中保持某些数据。与cookies相比，会话数据存储在服务器上；因此，数据不能被客户端访问。会话数据用于存储已登录用户数据（至少是ID）和临时数据（如闪存消息、CSRF令牌、购物车项目等）。'
- en: 'To store an entry in a session, it is enough to add it to the `$_SESSION` superglobal
    associative array, like this: `$_SESSION[''user_id''] = 123;`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要在会话中存储一个条目，只需将其添加到`$_SESSION`超级全局关联数组中即可，如下所示：`$_SESSION['user_id'] = 123;`。
- en: By default, PHP will not start the session automatically, meaning it will not
    generate a session ID and will not set the cookie header with the session ID value.
    So, you have to call `session_start()` in order to initialize the session. PHP
    will then try to load the session ID stored in the `PHPSESSID` variable (which
    is the default name) from the **Cookie** request header and, if such an entry
    name does not exist, then a fresh session will be started and the session ID will
    be sent back to the client with the current response in the headers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，PHP不会自动启动会话，这意味着它不会生成会话ID，也不会设置包含会话ID值的cookie头。因此，你必须调用`session_start()`来初始化会话。然后PHP将尝试从**Cookie**请求头中加载存储在`PHPSESSID`变量（默认名称）中的会话ID，如果不存在这样的条目名称，则将启动一个新的会话，并将会话ID发送回客户端，作为当前响应头的一部分。
- en: 'Exercise 6.3: Writing and Reading Data from a Session'
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.3：从会话中写入和读取数据
- en: 'In this exercise, we will implement session initialization and write and read
    data from a session. If the session is opening for the first time, then we will
    save random data to check that the session is preserving saved data for subsequent
    requests. The random data will be saved in the `name` key of the `$_SESSION` variable.
    Here are the steps to perform the exercise:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现会话初始化，并从会话中写入和读取数据。如果会话是第一次打开，那么我们将保存随机数据以检查会话是否为后续请求保留保存的数据。随机数据将保存在`$_SESSION`变量的`name`键中。以下是执行练习的步骤：
- en: Create a file called `session.php`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`session.php`的文件。
- en: 'Write the code to start the session and display the `Cannot start the session`
    string if the `session_start()` function does not return `TRUE`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以启动会话，并在`session_start()`函数不返回`TRUE`时显示`Cannot start the session`字符串：
- en: '[PRE11]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To work with sessions in PHP, you are required to *start the session*. This
    will perform a series of operations, such as generating the session ID and creating
    a session file where the data will be stored or connecting to the data provider
    service, depending on the settings of the `ini` files. If the session cannot start,
    then there's no reason to continue, so we will display an error message and stop
    the script execution.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在PHP中使用会话，您需要*启动会话*。这将执行一系列操作，例如生成会话ID、创建用于存储数据的会话文件或连接到数据提供者服务，具体取决于`ini`文件的设置。如果会话无法启动，则没有继续的理由，因此我们将显示错误消息并停止脚本执行。
- en: If the session is started, we may want to grab the session name – this is the
    name under which the ID is saved in cookies. The default session name is `PHPSESSID`.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果会话已启动，我们可能希望获取会话名称——这是ID在cookie中保存的名称。默认会话名称是`PHPSESSID`。
- en: 'Write the code to grab the session name:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以获取会话名称：
- en: '[PRE12]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the session was not initialized (that is, there is no cookie with the `PHPSESSID`
    variable), we may want to inform the user about that using the following code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果会话尚未初始化（即没有包含`PHPSESSID`变量的cookie），我们可能希望使用以下代码通知用户：
- en: '[PRE13]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Additionally, print the fresh session ID that is saved under the `$sessionName`
    cookie entry using the following code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，使用以下代码打印出保存在`$sessionName`cookie条目下的新鲜会话ID：
- en: '[PRE14]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `session_id()` function returns the current session ID that belongs to the
    user that is accessing the page only. It is generated each time `session_start()`
    is invoked and, at the same time, no cookie with the session ID is found in the
    HTTP request.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`session_id()`函数返回属于访问页面的用户的当前会话ID。它在每次调用`session_start()`时生成，同时，在HTTP请求中找不到包含会话ID的cookie。'
- en: Note
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We don't need to use a function to set the cookie with the generated session
    ID. This is done automatically when invoking `session_start()`.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不需要使用函数来设置包含生成的会话ID的cookie。这会在调用`session_start()`时自动完成。
- en: Choosing a random value from an indexed array should be easy using the `rand()`
    function. `rand()` will return a randomly picked number between a given minimum
    and maximum as an argument. In our case, for three values in an array, we need
    an index between 0 and 2\.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`rand()`函数从索引数组中选择随机值应该很简单。`rand()`将返回一个介于给定最小值和最大值之间的随机数。在我们的例子中，对于数组中的三个值，我们需要一个介于0和2之间的索引。
- en: 'Store the random entry in a session under the `name` key using the following
    code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码在会话中存储随机条目，使用`name`键：
- en: '[PRE15]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Print a message letting us know about the saved value in the session and the
    headers that are sent to the browser (to see the `Set-Cookie` header that saves
    the session ID in the browser):'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印一条消息，让我们知道会话中保存的值和发送到浏览器的头信息（以查看保存会话ID的`Set-Cookie`头信息）：
- en: '[PRE16]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have seen what to do when the session is not initialized yet. Now, if the
    session is already initialized, we will print the session name and the session
    ID (the value from the request cookies), and we will also dump the session data:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经看到了当会话尚未初始化时应该做什么。现在，如果会话已经初始化，我们将打印会话名称和会话ID（来自请求cookie的值），并且我们还将转储会话数据：
- en: '[PRE17]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Once the session is initialized, this will display the same data for each subsequent
    request, and all the changes performed in the user session data will also be reflected
    in subsequent requests. The session data can be considered as a storage unit for
    a user, just like cookies, but on the server side – the link between the client
    and the server is made using the session ID.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦初始化会话，后续的每个请求都将显示相同的数据，并且用户会话数据中执行的所有更改也将反映在后续请求中。会话数据可以被视为用户的存储单元，就像cookies一样，但位于服务器端
    – 客户端和服务器之间的链接是通过会话ID实现的。
- en: The whole script file can be referred at [https://packt.live/31gZKAe](https://packt.live/31gZKAe).
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 整个脚本文件可以在[https://packt.live/31gZKAe](https://packt.live/31gZKAe)中查阅。
- en: Access the file through the built-in server at `http://127.0.0.1:8080/session.php`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过内置服务器访问文件`http://127.0.0.1:8080/session.php`。
- en: 'The first output will look like this:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首次输出将如下所示：
- en: '![Figure 6.13: First access of session.php – initializing the new session and
    cookie set'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.13：首次访问session.php – 初始化新的会话和设置cookie'
- en: '](img/C14196_06_13.jpg)'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_06_13.jpg)'
- en: 'Figure 6.13: First access of session.php – initializing the new session and
    cookie set'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.13：首次访问session.php – 初始化新的会话和设置cookie
- en: 'The cookie values look as follows:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cookie的值如下所示：
- en: '![Figure 6.14: Cookie values in Chrome DevTools after the /session.php page
    was accessed'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.14：在访问/session.php页面后Chrome DevTools中的cookie值'
- en: '](img/C14196_06_14.jpg)'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_06_14.jpg)'
- en: 'Figure 6.14: Cookie values in Chrome DevTools after the /session.php page was
    accessed'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.14：在访问/session.php页面后Chrome DevTools中的cookie值
- en: 'Refresh the page; the output should look like this:![Figure 6.15: Subsequent
    access of session.php – the session data restored with the ID from the cookie'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新页面；输出应该如下所示：![图6.15：后续访问session.php – 使用cookie中的ID恢复会话数据
- en: '](img/C14196_06_15.jpg)'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_06_15.jpg)'
- en: 'Figure 6.15: Subsequent access of session.php – the session data restored with
    the ID from the cookie'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.15：后续访问session.php – 使用cookie中的ID恢复会话数据
- en: Note
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Since the actual value in the `$names` array is picked randomly, the value seen
    might be one of the three possible
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于`$names`数组中的值是随机选择的，所以看到的值可能是三种可能值之一
- en: Clear the cookies for the current page and reload the page. Notice that a different
    session ID is generated and set when no `PHPSESSID` cookie is already set.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除当前页面的cookies并重新加载页面。请注意，如果没有已经设置的`PHPSESSID` cookie，将生成并设置一个新的会话ID。
- en: 'Here is the explanation of the script: first, the script will try to start
    the session, and it will look for the session ID in a cookie. Next, the script
    will check whether such a cookie exists, using the `session_name()` function to
    get the name the session uses, from which it will store and fetch the session
    ID. If a cookie with such a name is found, then its value will be printed and
    the session data will be printed as well. Otherwise, it will inform you about
    the session ID that was generated and is set to be stored in a cookie, and a random
    character name will be picked and stored in the current session. Additionally,
    a list of headers to be sent in the response is printed, to make sure the (session)
    set-cookie header is sent.'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是对脚本的解释：首先，脚本将尝试启动会话，并会在cookie中查找会话ID。接下来，脚本将检查是否存在这样的cookie，使用`session_name()`函数获取会话使用的名称，然后从中存储和检索会话ID。如果找到具有该名称的cookie，则其值将被打印，同时也会打印会话数据。否则，它将通知你生成的会话ID，并将其设置为存储在cookie中，并从当前会话中随机选择一个字符名称进行存储。此外，还会打印出要发送到响应中的头部列表，以确保发送了（会话）set-cookie头部。
- en: Note
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Learn more about session functions at [https://packt.live/31x8MJC](https://packt.live/31x8MJC).
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在[https://packt.live/31x8MJC](https://packt.live/31x8MJC)了解更多关于会话函数的信息。
- en: $_GET
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $_GET
- en: '`$_GET` carries the parsed query string of a request URI, no matter the request
    method. Therefore, a URI such as `/?page=2` would result in the following `$_GET`
    value: `["page" => 2]`. PHP can parse a query string into nested arrays as well,
    so a query string such as `tags[]=heroes&tags[]=2019` would lead to a value of
    `$_GET`, such as `[ "tags" => [ 0 => "heroes", 1 => "2019" ] ]`, parsing tags
    into a numerical array. You can use a query string to parse into an associative
    array as well; just put names between the square brackets. For example, `filter[category]=heroes&filter[year]=2019`
    would be parsed as `[ "filter" => [ "category"=> "heroes", "year"=> "2019" ] ]`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`$_GET` 包含请求 URI 的解析后的查询字符串，无论请求方法如何。因此，一个如 `/?page=2` 的 URI 将导致以下 `$_GET`
    值：`["page" => 2]`。PHP 可以将查询字符串解析为嵌套数组，因此一个如 `tags[]=heroes&tags[]=2019` 的查询字符串将导致
    `$_GET` 的值，例如 `[ "tags" => [ 0 => "heroes", 1 => "2019" ] ]`，将标签解析为数值数组。您可以使用查询字符串将其解析为关联数组；只需在方括号之间放置名称。例如，`filter[category]=heroes&filter[year]=2019`
    将被解析为 `[ "filter" => [ "category"=> "heroes", "year"=> "2019" ] ]`。'
- en: 'Exercise 6.4: Using Query Strings in Web Pages'
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.4：在网页中使用查询字符串
- en: In this exercise, we will build HTTP query strings, use them in web page links,
    and also use query string data. More precisely, you will use `$_GET` to select
    and display a specific data entry from a list.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将构建 HTTP 查询字符串，在网页链接中使用它们，并使用查询字符串数据。更确切地说，您将使用 `$_GET` 从列表中选择并显示特定的数据条目。
- en: 'Here are the steps to complete the exercise:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 完成练习的步骤如下：
- en: 'Create a file called `super-get-href.php` and define a list of values in an
    associative array where keys are the entry IDs, and with nested associative arrays
    as values, with the `id` and `name` keys:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `super-get-href.php` 的文件，并在关联数组中定义一系列值，其中键是条目 ID，值是嵌套的关联数组，包含 `id` 和
    `name` 键：
- en: '[PRE18]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will need the query string to point out which entry the script should pick,
    so let''s assume the value we are looking for in the query string is under the
    `hero` name. So, to get the character ID, the `$heroId = $_GET[''hero''];` name
    would do the trick. Then, picking the character entry from our `$heroes` list
    should look like this: `$selectedHero = $heroes[$heroId];`. Here, `$selectedHero`
    is the entry, like `["id" => 1009187, "name" => "Black Panther"]` in the case
    where `$heroId` is `black-panther`.'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要查询字符串来指出脚本应该选择哪个条目，所以让我们假设我们正在查询字符串中寻找的值位于 `hero` 名称下。因此，要获取角色 ID，`$heroId
    = $_GET['hero'];` 这个名称就能解决问题。然后，从我们的 `$heroes` 列表中选择角色条目应如下所示：`$selectedHero =
    $heroes[$heroId];`。在这里，`$selectedHero` 是条目，例如当 `$heroId` 是 `black-panther` 时，它类似于
    `["id" => 1009187, "name" => "Black Panther"]`。
- en: 'Add a `$selectedHero` variable initialization and check for the presence of
    the `hero` entry in `$_GET`; the code should look like this:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `$selectedHero` 变量的初始化并检查 `$_GET` 中是否存在 `hero` 条目；代码应如下所示：
- en: '[PRE19]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Before we display the character data, we will check whether the `$selectedHero`
    variable has values. If no values can be found in `$selectedHero`, it means no
    `hero` was specified in the query string parameter, or the value does not exist
    in the `$heroes` key list; therefore, we can display a plain `None`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们显示角色数据之前，我们将检查 `$selectedHero` 变量是否有值。如果 `$selectedHero` 中找不到值，这意味着查询字符串参数中没有指定
    `hero`，或者该值不在 `$heroes` 键列表中；因此，我们可以显示一个简单的 `None`：
- en: '[PRE20]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For debugging purposes, we might want to dump the `$_GET` value. We can use
    `var_export` for this:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了调试目的，我们可能想要转储 `$_GET` 值。我们可以使用 `var_export` 来做这件事：
- en: '[PRE21]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, it would be very useful to have some links on the page, one for each `$heroes`
    entry, to contain the `hero` query string parameter. We can add the code we need
    to build the link to a function, to avoid repeating the same logic over and over
    again in the same script. Let''s call that function `path()`, and allow it to
    accept an associative array that will be used to build the query string part of
    the URL. We will use the built-in `http_build_query()` function to generate the
    query string based on input data; for example, `[''name'' => ''john'']` will generate
    the `name=john` query string. This will be appended to the script filename (in
    our case, this is `super-get-href.php`):'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在页面上添加一些链接将非常有用，每个 `$heroes` 条目一个，以包含 `hero` 查询字符串参数。我们可以将构建链接所需的代码添加到一个函数中，以避免在同一个脚本中反复重复相同的逻辑。让我们称这个函数为
    `path()`，并允许它接受一个关联数组，该数组将用于构建 URL 的查询字符串部分。我们将使用内置的 `http_build_query()` 函数根据输入数据生成查询字符串；例如，`['name'
    => 'john']` 将生成 `name=john` 查询字符串。这将附加到脚本文件名（在我们的例子中，这是 `super-get-href.php`）：
- en: '[PRE22]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To create the HTML link, we will have to iterate the `$heroes` array and render
    an `<a>` element for each character, using the `path()` function to generate the
    `href` attribute value. Since we are looking into `$_GET[''hero'']` for the character
    ID, the argument for the `path()` function should be `[''hero'' => $heroId]`.
    All the links will be collected in the `$heroLinks` variable:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建HTML链接，我们需要遍历`$heroes`数组并为每个字符渲染一个`<a>`元素，使用`path()`函数生成`href`属性值。由于我们正在查找`$_GET['hero']`以获取角色ID，因此`path()`函数的参数应该是`['hero'
    => $heroId]`。所有链接都将收集在`$heroLinks`变量中：
- en: '[PRE23]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To print the link, using the double forward slash (`//`) separator, we can
    use the `implode()` array function to join all the entries using a separator:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打印链接，使用双斜杠（`//`）分隔符，我们可以使用`implode()`数组函数通过分隔符连接所有条目：
- en: '[PRE24]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We will group the PHP logic on top of the script file and the HTML markup under
    it. You can refer to the complete file at [https://packt.live/35xfmDd](https://packt.live/35xfmDd).
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在脚本文件顶部分组PHP逻辑，并在其下方放置HTML标记。你可以参考完整的文件[https://packt.live/35xfmDd](https://packt.live/35xfmDd)。
- en: Now access the file in your browser through the built-in server at `http://127.0.0.1:8080/super-get-href.php`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过内置服务器在`http://127.0.0.1:8080/super-get-href.php`中通过浏览器访问该文件。
- en: 'As the output, in the first line, you will have the links with character names,
    and below, you will find the value of the `$_GET` superglobal, which is an empty
    array:'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为输出，在第一行，您将看到带有角色名称的链接，下面将找到`$_GET`超全局变量的值，它是一个空数组：
- en: '![Figure 6.16: Accessing the super-get-href.php script without query string
    parameters'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.16：不使用查询字符串参数访问super-get-href.php脚本'
- en: '](img/C14196_06_16.jpg)'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_06_16.jpg)'
- en: 'Figure 6.16: Accessing the super-get-href.php script without query string parameters'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.16：不使用查询字符串参数访问super-get-href.php脚本
- en: 'Now feel free to click on the links and watch what happens to the URL and the
    value of the `$_GET` variable. For example, clicking on the `Black Panther` link,
    you will notice the `http://127.0.0.1:8080/super-get-href.php?hero=black-panther`
    URL, and the content will look like this:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您可以随意点击链接，并观察URL和`$_GET`变量的值发生了什么。例如，点击“黑豹”链接，您会注意到`http://127.0.0.1:8080/super-get-href.php?hero=black-panther`
    URL，内容看起来像这样：
- en: '![Figure 6.17: Displaying the page after clicking on the “Black Panther” link'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.17：点击“黑豹”链接后显示的页面'
- en: '](img/C14196_06_17.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_17.jpg)'
- en: 'Figure 6.17: Displaying the page after clicking on the "Black Panther" link'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17：点击“黑豹”链接后显示的页面
- en: $_POST
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $_POST
- en: '`$_POST` carries the `POST` request data (that is, the URL-encoded or multipart
    form data). It is the same as for the query string; for example, when `reset=all`
    is sent in the `POST` payload, the output of `echo $_POST[''reset'']` will be
    `all`.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`$_POST`携带`POST`请求数据（即URL编码或multipart表单数据）。它与查询字符串相同；例如，当`reset=all`在`POST`有效负载中发送时，`echo
    $_POST[''reset'']`的输出将是`all`。'
- en: The `POST` data is sent from the browser using HTML forms. The `POST` method
    is usually used to alter data in an application, either to create, to update,
    or to delete data; to move data; to trigger remote actions; or to change the session
    state, to name a few.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`数据是通过HTML表单从浏览器发送的。`POST`方法通常用于在应用程序中更改数据，无论是创建、更新还是删除数据；移动数据；触发远程操作；或者更改会话状态，仅举几例。'
- en: 'Exercise 6.5: Sending and Reading POST Data'
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.5：发送和读取POST数据
- en: In this exercise, you will send `POST` data using an HTML form and manage this
    data in a PHP script. Following the previous example, let's keep the same data
    in the `$heroes` variable; however, instead of using links, we will use a form
    to send the data using the `POST` method.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用HTML表单发送`POST`数据，并在PHP脚本中管理这些数据。遵循之前的示例，让我们保持`$heroes`变量中的相同数据；然而，我们不会使用链接，而是使用表单通过`POST`方法发送数据。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 完成练习的以下步骤：
- en: Create a file called `super-post-form.php` with the following content.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`super-post-form.php`的文件，并包含以下内容。
- en: 'Just like in the previous exercise, we''ll define an associative array with
    three entries, with URI-friendly IDs for characters as array keys, and character
    data (as associative arrays as well) as values. Add the following data to the
    `$heroes` variable:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像在之前的练习中一样，我们将定义一个包含三个条目的关联数组，字符的URI友好ID作为数组键，字符数据（也是关联数组）作为值。将以下数据添加到`$heroes`变量中：
- en: '[PRE25]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Selecting a character entry is done the same as in the previous example, with
    the difference that we are now looking at the `$_POST` superglobal instead of
    the `$_GET` method of the previous exercise:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择角色条目的方式与之前的示例相同，不同之处在于我们现在正在查看 `$_POST` 超全局变量，而不是之前练习中的 `$_GET` 方法：
- en: '[PRE26]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To display the selected character, we will keep the same format and logic from
    the previous exercise:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示选定的角色，我们将保持与之前练习相同的格式和逻辑：
- en: '[PRE27]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Also, for debugging purposes, we will dump the `$_POST` values:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，出于调试目的，我们将输出 `$_POST` 的值：
- en: '[PRE28]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To use the POST method to end data, we will use a `<form>` element with a `<select>`
    element. The `<select>` element will contain the `<option>` with the character
    ID as a value and the character name as a label:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 POST 方法结束数据，我们将使用一个包含 `<select>` 元素的 `<form>` 元素。`<select>` 元素将包含具有字符 ID
    作为值和字符名称作为标签的 `<option>`：
- en: '[PRE29]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Open the file in the browser at `http://127.0.0.1:8080/super-post-form.php`.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开文件 `http://127.0.0.1:8080/super-post-form.php`。
- en: 'The output should look like this:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 6.18: First access to the super-post-form.php script'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.18：首次访问 super-post-form.php 脚本'
- en: '](img/C14196_06_18.jpg)'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_06_18.jpg)'
- en: 'Figure 6.18: First access to the super-post-form.php script'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.18：首次访问 super-post-form.php 脚本
- en: Select the `Captain America` item in the `<select>` element and click on the
    `Show` button.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<select>` 元素中选择 `Captain America` 项目，然后点击 `Show` 按钮。
- en: 'The output is now as follows:'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出现在如下所示：
- en: '![Figure 6.19: Displaying the super-post-form.php script result after submitting
    the form'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.19：提交表单后显示 super-post-form.php 脚本的结果'
- en: '](img/C14196_06_19.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_19.jpg)'
- en: 'Figure 6.19: Displaying the super-post-form.php script result after submitting
    the form'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19：提交表单后显示 super-post-form.php 脚本的结果
- en: Notice the new content on the page, and also take a look at the URL – there
    is no longer a query string since the data is sent in the HTTP request body. As
    you might notice, this is the same as for the `$_GET` variable – it's just the
    input source that is different. In addition to this, notice that the `<select>`
    element displays the `A-Bomb (HAS)` value; this is because there is no `<option>`
    with the `selected` attribute set, and the `<select>` element defaults to the
    first option as the selected option.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意页面上的新内容，并查看 URL - 由于数据在 HTTP 请求体中发送，因此不再有查询字符串。正如你可能注意到的，这与 `$_GET` 变量相同 -
    它只是输入源不同。此外，请注意 `<select>` 元素显示的是 `A-Bomb (HAS)` 值；这是因为没有设置 `selected` 属性的 `<option>`，因此
    `<select>` 元素默认将第一个选项作为选中选项。
- en: $_FILES
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $_FILES
- en: 'The `$_FILES` superglobal contains data for upload attempts, meaning uploads
    are not considered successful if their related data is found in this variable.
    The reason for failed attempts varies, and a list of reasons (or upload statuses)
    can be found on the official PHP documentation page ([https://packt.live/32hXhH2](https://packt.live/32hXhH2)).
    All the uploaded files are stored in a temporary location until the application
    scripts move them to persistent storage. `$_FILES` is an associative array with
    the form of an input name as an entry key and the upload information as an entry
    value. The upload information is another associative array with the following
    fields: `name`, `tmp_name`, `type`, `size`, and `error`.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`$_FILES` 超全局变量包含上传尝试的数据，这意味着如果相关数据出现在此变量中，则上传不被视为成功。失败尝试的原因多种多样，可以在官方 PHP
    文档页面上找到原因列表（或上传状态）（[https://packt.live/32hXhH2](https://packt.live/32hXhH2)）。所有上传的文件都存储在临时位置，直到应用程序脚本将它们移动到持久存储。`$_FILES`
    是一个关联数组，其形式为输入名称作为条目键，上传信息作为条目值。上传信息是另一个关联数组，具有以下字段：`name`、`tmp_name`、`type`、`size`
    和 `error`。'
- en: The `name` field will have the file's base name sent with the request; `tmp_name`
    will have the temporary location of the uploaded file (so that your script can
    move it to the appropriate place); `type` will have the media type of the file
    (the MIME type) sent by the client in the same request; `size` will be the file
    size in bytes; and `error` will have information about the upload status. Note
    that the *specified media type in type* `key` *is not the file extension as it
    appears on the operating system's filesystem.*
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`name` 字段将包含与请求一起发送的文件的基名；`tmp_name` 将包含上传文件的临时位置（以便你的脚本将其移动到适当的位置）；`type`
    将包含客户端在相同请求中发送的文件媒体类型（MIME 类型）；`size` 将是字节数；`error` 将包含有关上传状态的信息。请注意，`type` 键中指定的媒体类型*不是文件扩展名，它在操作系统的文件系统中出现*。'
- en: Caution
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: As a good practice, it is recommended that you use built-in functions or other
    appropriate tools to detect the MIME type of a file; therefore, do not trust the
    user input – do always test it. By default, the uploaded file size limit is 2
    MB, and the POST payload limit is 8 MB (for the whole request).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种良好的实践，建议您使用内置函数或其他适当的工具来检测文件的 MIME 类型；因此，不要信任用户输入——始终进行测试。默认情况下，上传文件大小限制为
    2 MB，POST 负载限制为 8 MB（对于整个请求）。
- en: 'Exercise 6.6: Uploading a File and Validating its Type'
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.6：上传文件并验证其类型
- en: In this exercise, we will upload an image, validate the uploaded file by detecting
    its MIME type, and then display the successfully uploaded image in the browser.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将上传一个图像，通过检测其 MIME 类型来验证上传的文件，然后将在浏览器中显示成功上传的图像。
- en: 'Here are the steps to perform the exercise:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行练习的步骤：
- en: Create a file called `super-post-upload.php`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `super-post-upload.php` 的文件。
- en: Before we try uploading the file, we should define the upload location, the
    destination file path, and, to be able to display it in the browser, the file's
    relative path to the server document root directory (in our case, the document
    root is the directory where the script file is running).
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们尝试上传文件之前，我们应该定义上传位置、目标文件路径，以及为了能够在浏览器中显示它，文件的相对路径到服务器文档根目录（在我们的情况下，文档根是脚本文件运行所在的目录）。
- en: 'We will use a static filename for the upload target so that we can save and
    display a single image, not a list of them:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个静态文件名作为上传目标，这样我们就可以保存和显示单个图像，而不是它们的列表：
- en: '[PRE30]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `$relativeFilename` relative file path, unlike the target file path, is
    not the full file path on the disk; it is instead just the path relative to the
    current directory that is the server document root, where the script is run. In
    order to achieve this, we use the built-in `substr()` function to subtract the
    string from the target file path, starting with the string in the `strlen(__DIR__)`
    position, meaning the part from the target file path to the current directory
    will be cut.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$relativeFilename` 相对文件路径，与目标文件路径不同，不是磁盘上的完整文件路径；它只是相对于当前目录（即服务器文档根目录，脚本运行的位置）的路径。为了实现这一点，我们使用内置的
    `substr()` 函数从目标文件路径中减去字符串，从 `strlen(__DIR__)` 位置开始，意味着从目标文件路径到当前目录的部分将被剪切。'
- en: Make sure `$uploadsDir` is a valid path on the disk; create the `uploads` directory
    if it does not exist.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 `$uploadsDir` 是磁盘上的有效路径；如果不存在，则创建 `uploads` 目录。
- en: 'Since the uploaded files (or upload attempts) are stored in the `$_FILES` variable,
    we will check the watched entry in it. Let''s suppose we expect a file under the
    `uploadFile` input name; then, we can perform the check with `array_key_exists(''uploadFile'',
    $_FILES)`. Eventually, the `$_FILES[''uploadFile'']` value will be stored in the
    `$uploadInfo` variable to make it more convenient to work with the uploaded file
    information:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于上传的文件（或上传尝试）存储在 `$_FILES` 变量中，我们将检查其中的监视条目。假设我们期望在 `uploadFile` 输入名称下有一个文件；然后，我们可以使用
    `array_key_exists('uploadFile', $_FILES)` 来执行检查。最终，`$_FILES['uploadFile']` 的值将被存储在
    `$uploadInfo` 变量中，以便更方便地处理上传文件信息：
- en: '[PRE31]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we want to make sure the upload was completed successfully. The upload
    status is stored in the `error` entry, as stated before, so we may want to use
    a `switch` statement to jump to the status of the upload, using the `UPLOAD_ERR_*`
    constant for the `case` value. The beginning of the `switch` statement should
    look like this:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要确保上传已成功完成。上传状态存储在之前提到的 `error` 条目中，因此我们可能想要使用 `switch` 语句跳转到上传的状态，使用
    `UPLOAD_ERR_*` 常量作为 `case` 值。`switch` 语句的开始应该看起来像这样：
- en: '[PRE32]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the case of a successful upload, we should validate the input data. What
    we care about the most is the MIME type of the content the server got from the
    client and, to check whether it''s the expected one, we use the built-in `mime_content_type()`
    function. Let''s suppose that we only allow PNG images to be uploaded, as follows:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上传成功的情况下，我们应该验证输入数据。我们最关心的是服务器从客户端获取的内容的 MIME 类型，为了检查它是否是预期的类型，我们使用内置的 `mime_content_type()`
    函数。假设我们只允许上传 PNG 图像，如下所示：
- en: '[PRE33]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After the validation passes, we should move the file from the temporary location
    to the `$targetFilename` destination that we defined earlier, and we will use
    the `move_uploaded_file()` function for that. This function takes the temporary
    path of the uploaded file as the first argument and the target as the second argument.
    It returns `TRUE` if successful:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证通过后，我们应该将文件从临时位置移动到我们之前定义的 `$targetFilename` 目的地，我们将使用 `move_uploaded_file()`
    函数来完成这个操作。该函数将上传文件的临时路径作为第一个参数，目标作为第二个参数。如果成功，它将返回 `TRUE`：
- en: '[PRE34]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Caution
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 警告
- en: Avoid using the `rename()` filesystem function for this operation, due to security
    implications. `move_uploaded_file()` is much better to use in this context because
    it will only proceed if the file to be moved is an uploaded file in the current
    request.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于安全影响，避免使用 `rename()` 文件系统函数进行此操作。在此上下文中，`move_uploaded_file()` 要好得多，因为它只有在要移动的文件是当前请求中上传的文件时才会继续执行。
- en: 'We will add the case of the exceeding file size (`UPLOAD_ERR_INI_SIZE`) and
    the missing file for the upload operation (`UPLOAD_ERR_NO_FILE`), and print a
    custom error message for each:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加超出文件大小（`UPLOAD_ERR_INI_SIZE`）和缺少文件（`UPLOAD_ERR_NO_FILE`）进行上传操作的情况，并为每种情况打印自定义的错误信息：
- en: '[PRE35]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For other status types, let''s add a generic message displaying the error code:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于其他状态类型，让我们添加一个通用消息来显示错误代码：
- en: '[PRE36]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To upload a file from a web page, we have to add the upload form on that web
    page, including the `<input>` of type `file` and the `"uploadFile"` name (which
    we are watching in the script). The form requires the `enctype` attribute with
    the `"multipart/form-data"` value:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从网页上传文件，我们必须在该网页上添加上传表单，包括类型为 `file` 的 `<input>` 和 `"uploadFile"` 名称（我们在脚本中监视这个名称）。表单需要带有
    `"multipart/form-data"` 值的 `enctype` 属性：
- en: '[PRE37]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After handling the file upload, let''s display the image after it''s uploaded.
    First, we will have to check whether the file exists, and we do this by using
    the built-in filesystem function, `file_exists()`:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理文件上传后，让我们在上传后显示图像。首先，我们必须检查文件是否存在，我们可以通过使用内置的文件系统函数 `file_exists()` 来完成这个操作：
- en: '[PRE38]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To display the image in the browser, we should render an HTML `<img>` element
    with the relative path to the server document root in the `src` attribute:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在浏览器中显示图像，我们应该在 `src` 属性中使用指向服务器文档根的相对路径来渲染一个HTML `<img>` 元素：
- en: '[PRE39]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Open the file in your browser at `http://127.0.0.1:8080/super-post-upload.php`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开文件，访问 `http://127.0.0.1:8080/super-post-upload.php`。
- en: 'The output should be a file upload form only:'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应该只是一个文件上传表单：
- en: '![Figure 6.20: The file upload form'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.20：文件上传表单'
- en: '](img/C14196_06_20.jpg)'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_06_20.jpg)'
- en: 'Figure 6.20: The file upload form'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.20：文件上传表单
- en: 'Click on `Upload` without selecting a file. This time, an error message will
    be displayed before the form. The output should look like this:![Figure 6.21:
    File upload error when no file is submitted'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `Upload` 而不选择文件。这次，在表单之前将显示一个错误信息。输出应该看起来像这样：![图6.21：未提交文件时的文件上传错误
- en: '](img/C14196_06_21.jpg)'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_06_21.jpg)'
- en: 'Figure 6.21: File upload error when no file is submitted'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.21：未提交文件时的文件上传错误
- en: We got a `No file was uploaded.` error since `$uploadInfo['error']` had the
    value of `UPLOAD_ERR_NO_FILE` due to the missing file in the form upload input.
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于表单上传输入中缺少文件，`$uploadInfo['error']` 的值为 `UPLOAD_ERR_NO_FILE`，我们得到了 `No file
    was uploaded.` 错误。
- en: Select a big file (that is, bigger than 2 MB) and hit the `Upload` button. This
    time, another error message will warn you about the exceeded size limit for the
    uploaded file:![](img/C14196_06_22.jpg)
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个大于2 MB的大文件，然后点击 `Upload` 按钮。这次，另一个错误信息将警告您上传文件超过了大小限制：![图6.22：提交的文件过大时的文件上传错误
- en: 'Figure 6.22: File upload error when the submitted file is too big'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.22：提交的文件过大时的文件上传错误
- en: Similar to the previous step, we got an upload error. This time the upload error
    was `UPLOAD_ERR_INI_SIZE`.
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与上一步类似，我们遇到了上传错误。这次的上传错误是 `UPLOAD_ERR_INI_SIZE`。
- en: 'Select a file that is under 2 MB and non-PNG and hit the `Upload` button. Yet
    another error message will appear telling you that the file format is not the
    accepted format:![Figure 6.23: File upload error when the submitted file is not
    the accepted format'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个小于2 MB且非PNG格式的文件，然后点击 `Upload` 按钮。此时将出现另一个错误信息，告知您文件格式不是接受的格式：![图6.23：提交的文件格式不被接受时的文件上传错误
- en: '](img/C14196_06_23.jpg)'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_06_23.jpg)'
- en: 'Figure 6.23: File upload error when the submitted file is not the accepted
    format'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.23：提交的文件格式不被接受时的文件上传错误
- en: Unlike in previous steps, the upload error this time was `UPLOAD_ERR_OK`, which
    means no error occurred with the upload. The error message displayed on the page
    is caused by the file MIME type validation, which is required to be `image/png`.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与之前的步骤不同，这次的上传错误是`UPLOAD_ERR_OK`，这意味着上传没有发生错误。页面上显示的错误信息是由文件MIME类型验证引起的，它需要是`image/png`。
- en: 'Finally, select a PNG image file that is smaller than 2 MB and hit the `Upload`
    button. The page should display the successful upload message and render the uploaded
    picture:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，选择一个小于2 MB的PNG图像文件，然后点击`上传`按钮。页面应显示上传成功的消息并渲染上传的图片：
- en: '![Figure 6.24: File upload success when the submitted file meets the requirements'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.24：当提交的文件满足要求时文件上传成功'
- en: '](img/C14196_06_24.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_24.jpg)'
- en: 'Figure 6.24: File upload success when the submitted file meets the requirements'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24：当提交的文件满足要求时文件上传成功
- en: Since the upload happened without errors, and the MIME file type is the expected
    one, the file gets stored on the designated path on the server and is displayed
    on the browser page.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上传没有错误发生，并且MIME文件类型是预期的，文件被存储在服务器上的指定路径，并在浏览器页面上显示。
- en: Securing Input and Output Data
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护输入和输出数据
- en: In order to protect your website's users and the website itself, you should
    protect your web applications from malicious input and operations. Application
    security is one of the pillars of a reliable application. This should not be overlooked;
    on the contrary, you must have security in mind all the time while developing
    an app.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护你的网站用户和网站本身，你应该保护你的Web应用程序免受恶意输入和操作的侵害。应用程序安全是可靠应用程序的支柱之一。这不应被忽视；相反，在开发应用程序时，你必须始终考虑安全性。
- en: While most of the focus (if not all) is directed toward the user input, it would
    be much better if the data was validated no matter the source. This is especially
    needed when, on a project, there is a team involved and not one single person.
    This can lead to lots of unpredictable events, such as code changes that may look
    inoffensive, but could trigger unexpected behavior in your application's flow.
    Imagine a class method that has been designed and is used for some internal logic
    process, but then ends up being used for processing *external* data (from the
    database, user input, or elsewhere). While the class' self-data may have some
    degree of trust, at least when it comes to the data type (depending on the design),
    the external data is not to be trusted. In some cases, working on a product in
    a small team, it is tempting to ask the application administrators to insert data
    in a specific format here and there, leaving data validation and sanitization
    for *later*, while you eagerly try to deliver more and more features (perhaps
    to meet a deadline). Then, imagine your product turns out to be so successful
    that management decides to extend the business and offer it as a SaaS solution.
    In this case, the application administrators are no longer your small team, and
    all clients' data will be at risk if you don't deal with the input validation
    and sanitization. This time, it will be pretty difficult to solve all the issues
    in a timely manner – you will have to find these security holes across the whole
    application.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大部分的焦点（如果不是全部）都集中在用户输入上，但如果无论数据来源如何都能进行数据验证，那就好多了。这在项目中有团队参与而不是单一个人的情况下尤其必要。这可能导致许多不可预测的事件，例如看似无害的代码更改，但可能会在应用程序流程中触发意外的行为。想象一下，一个类方法被设计并用于某些内部逻辑过程，但最终却被用于处理*外部*数据（来自数据库、用户输入或其他地方）。虽然类的自数据可能有一定的信任度，至少在数据类型方面（取决于设计），但外部数据是不可信的。在某些情况下，在一个小团队中开发产品时，可能会诱使你要求应用程序管理员在这里和那里插入特定格式的数据，将数据验证和清理留到*以后*，同时你急切地试图交付更多和更多的功能（可能为了满足截止日期）。然后，想象一下你的产品变得如此成功，以至于管理层决定扩展业务，将其作为SaaS解决方案提供。在这种情况下，应用程序管理员不再是你的小团队，如果你不处理输入验证和清理，所有客户的数据都将处于风险之中。这次，及时解决所有问题将非常困难——你将不得不在整个应用程序中找到这些安全漏洞。
- en: In general, not taking care of data validation and sanitization will lead to
    a great technical debt in the future, as you will not only put your clients' data
    at risk, but application operations could return unpredictable results, which
    will require the developer to have to trace and debug the issues, which, again,
    takes time and money, while these bugs cause poor user experience.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，不关注数据验证和清理将导致未来的巨大技术债务，因为您不仅会使客户数据处于风险之中，而且应用程序操作可能会返回不可预测的结果，这将要求开发者追踪和调试问题，这又需要时间和金钱，而这些问题会导致糟糕的用户体验。
- en: Best Practices
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'Here are a few coding practices that will make your PHP code less prone to
    bugs and security issues:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些编码实践可以使您的PHP代码更不容易出现错误和安全问题：
- en: 'Use a single entry point for your web app: This is about a single PHP file
    that is responsible for taking every HTTP request and processing it. This file
    would bootstrap all the dependencies, load the configuration files, initialize
    the request handlers (such as `Dispatcher`, `HttpKernel`, and others — note that
    each framework uses its own name), and will then route the request to the proper
    PHP script for this to produce the response. In our examples, we have used several
    input files to provide some examples; this is not the way to go for real-world
    applications. Later, we will look at an example of a simple bootstrap for the
    examples run through in this topic, inside a single input file, keeping each example
    file on disk.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的Web应用使用单一入口点：这涉及到一个单一的PHP文件，该文件负责接收每个HTTP请求并处理它。此文件将引导所有依赖项，加载配置文件，初始化请求处理器（如`Dispatcher`、`HttpKernel`等——请注意，每个框架都有自己的名称），然后路由请求到适当的PHP脚本以生成响应。在我们的示例中，我们使用了多个输入文件来提供一些示例；这并不是真实世界应用的方法。稍后，我们将查看一个简单引导的示例，该示例在单个输入文件中运行此主题中的示例，同时保持每个示例文件在磁盘上。
- en: 'Separate the business logic from presentation logic: It is always better to
    keep responsibilities separate from each other. Modern frameworks bring their
    own templating engines to help developers keep most (if not all) of the business
    logic in PHP files, rather than in presentation files. This helps to focus on
    only one part; that is, either gathering and/or processing data or displaying
    data (that is, through visuals). Additionally, it is easier to read business logic
    if it is not scattered all over the presentation markup. We will cover this in
    more detail in the bootstrap example later.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将业务逻辑与表示逻辑分开：始终将责任分开是更好的做法。现代框架自带模板引擎，以帮助开发者将大部分（如果不是全部）业务逻辑保持在PHP文件中，而不是在表示文件中。这有助于只关注一个部分；即，收集和/或处理数据或显示数据（即，通过视觉）。此外，如果业务逻辑没有散布在表示标记中，则更容易阅读。我们将在稍后的引导示例中更详细地介绍这一点。
- en: 'Sanitize and validate your input early and escape it late: Input data refers
    to data outside the application, be it user input, database data, filesystem file
    data, or other data. By sanitizing the data, you make sure you get the cleanest
    possible data for a given input, while by validating it, you make sure you allow
    the script to work with the accepted values or range of values. On the other hand,
    escaping the data for the output makes the application avoid some other issues
    such as **cross-site scripting** (**XSS**).'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 早期清理和验证输入，晚期转义：输入数据指的是应用程序之外的数据，无论是用户输入、数据库数据、文件系统文件数据还是其他数据。通过清理数据，您确保为给定输入获得尽可能干净的数据，而通过验证，您确保允许脚本使用接受的值或值的范围。另一方面，对输出数据进行转义使应用程序避免一些其他问题，例如**跨站脚本攻击**（**XSS**）。
- en: We'll see how this can be done in PHP shortly.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将很快看到如何在PHP中实现这一点。
- en: 'Use type hinting whenever possible: Using type hinting, you can be sure of
    the input and output type of a function, so this feature prevents code execution
    when the input or output data of a function is not the expected type. For example,
    if your function expects an iterable, but a string was passed, then the engine
    will throw a `TypeError` exception (which stops the script execution if it is
    not caught).'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用类型提示：使用类型提示，您可以确保函数的输入和输出类型，因此此功能可以防止当函数的输入或输出数据不是预期类型时执行代码。例如，如果您的函数期望一个可迭代对象，但传递了一个字符串，那么引擎将抛出一个`TypeError`异常（如果未捕获，则停止脚本执行）。
- en: That's not all. By default, PHP will coerce the values of variables that do
    not match the expected type, when possible. This only applies to scalars. For
    example, if a function expects an integer but a numerical string is passed, then
    it will be converted to an integer. PHP features strict type checking as well,
    which I advise you to use in your application development. It can be added as
    per file use, and it's enough to add `declare(strict_types=1);` and only apply
    it to function calls from the file on which the strict types were enforced. This
    means that a function call from non-strict type checking to a function from a
    file with strong type checking enabled, the caller's preference of weak typing
    will be respected, and the values will be coerced. Using strict type checking
    makes your application even less prone to bugs, and that's simply because `'123abc'
    == 123`, which leads me to the next point.
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这还不是全部。默认情况下，PHP会在可能的情况下强制转换不匹配预期类型的变量的值。这仅适用于标量。例如，如果一个函数期望一个整数，但传递了一个数值字符串，那么它将被转换为整数。PHP还提供了严格类型检查的功能，我建议你在应用程序开发中使用它。它可以根据文件使用情况添加，只需添加`declare(strict_types=1);`并将它应用于强制执行严格类型的文件中的函数调用。这意味着从非严格类型检查的函数调用到启用了强类型检查的文件的函数，调用者的弱类型偏好将被尊重，并且值将被强制转换。使用严格类型检查可以使你的应用程序更不容易出现错误，这仅仅是因为`'123abc'
    == 123`，这让我想到了下一个点。
- en: 'Use strict comparison (`===`): PHP supports two types of comparisons: loose
    comparisons (`==`) and strict comparisons (`===`). In the case of loose comparisons,
    PHP tries to align both operands'' values to a common type, and then perform the
    comparison. That''s why `0 == FALSE` evaluates to `TRUE`. While this is considered
    a feature of PHP, praised for being friendly to starter developers, I strongly
    advise you to avoid such a construct from the beginning. On the other hand, a
    string comparison will not try to coerce the operands'' data, as it compares both
    values and types.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用严格比较（`===`）：PHP支持两种比较类型：松散比较（`==`）和严格比较（`===`）。在松散比较的情况下，PHP会尝试将两个操作数的值对齐到公共类型，然后进行比较。这就是为什么`0
    == FALSE`评估为`TRUE`的原因。虽然这被认为是PHP的一个特性，受到初学者开发者的赞扬，但我强烈建议你从一开始就避免使用这种结构。另一方面，字符串比较不会尝试强制转换操作数的数据，因为它比较的是值和类型。
- en: Generally speaking, you, as a developer looking at your code, should know what
    data you are dealing with in every line of your application.
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一般而言，作为查看你代码的开发者，你应该知道在应用程序的每一行中你正在处理什么数据。
- en: In other words, the more magic you allow to drive your app, the more your app
    will be prone to *magic* bugs!
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 换句话说，你允许你的应用程序运行越多魔法，你的应用程序就越容易出现*魔法*错误！
- en: 'Split your code into smaller pieces: Try to avoid writing big long functions
    and instead try to split the code into pieces that you will be able to actually
    test. So, what granularity should you use to split your code? Well, just ask what
    you are trying to do with the data, then it will come down to functions with names
    such as `decorateComment`, `splitCollection`, `shouldTrim`, and others. If you
    end up with something such as `getCommentsByGroupingAndDecoratingLongOnes`, you''ll
    probably find that function does too many operations, which could be split into
    shorter, more manageable and testable functions.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的代码拆分成更小的部分：尽量避免编写长函数，而是尝试将代码拆分成你可以实际测试的部分。那么，你应该使用什么粒度来拆分你的代码呢？好吧，问问你试图用数据做什么，然后它就会归结为具有`decorateComment`、`splitCollection`、`shouldTrim`等名称的函数。如果你最终得到的是`getCommentsByGroupingAndDecoratingLongOnes`这样的东西，你可能会发现这个函数做了太多的操作，这些操作可以被拆分成更短、更易于管理和测试的函数。
- en: 'Avoid using the error suppression operator, `@`: This operator is pretty slow,
    as the PHP will turn off error reporting, and after the operation, it will restore
    the error reporting to the original value. Additionally, do not turn off error
    reporting at all, not even in production; instead, use a custom error handler
    and log the error in a preferred manner, so you can see whether something goes
    wrong during the code execution.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用错误抑制操作符`@`：这个操作符相当慢，因为PHP会关闭错误报告，并在操作完成后将其恢复到原始值。此外，不要在生产环境中关闭错误报告；相反，使用自定义错误处理程序并以你偏好的方式记录错误，这样你就可以在代码执行过程中看到是否有错误发生。
- en: Sanitizing and Validating the User Input
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理和验证用户输入
- en: As soon as the data arrives in a script, it should be sanitized, and it must
    always be validated. You want to make sure you don't receive harmful data and,
    therefore, you want to clean the user input, which means removing potentially
    malicious content from the provided input, or casting the data to a specific type
    such as an integer or Boolean. Additionally, you want to make sure the input data
    is a valid number, or an email address where expected, and so on.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据到达脚本，就应该进行清理，并且必须始终进行验证。你想要确保你不会接收到有害的数据，因此你想要清理用户输入，这意味着从提供的输入中删除可能有害的内容，或者将数据转换为特定的类型，如整数或布尔值。此外，你想要确保输入数据是有效的数字，或者当期望时是一个电子邮件地址，等等。
- en: The built-in `filter_input()` function is used to process the data from the
    request and, if needed, will alter it to match the expected format.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `filter_input()` 函数用于处理请求中的数据，并在需要时将其更改为预期的格式。
- en: The syntax is `filter_input( int $type, string $variable_name, int $filter =
    FILTER_DEFAULT, mixed $options = null )`, so it takes as arguments the type of
    input to look into, the input parameter name to look for, the optional filter
    type, and any extra options if needed. What `FILTER_SANITIZE_*` filters do is
    remove data that is not expected for specific formats. For example, `FILTER_SANITIZE_NUMBER_INT`
    will remove everything except digits and plus and minus signs. A full list of
    sanitizing options can be found at [https://packt.live/31vww0M](https://packt.live/31vww0M).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是 `filter_input( int $type, string $variable_name, int $filter = FILTER_DEFAULT,
    mixed $options = null )`，因此它接受要查找的输入类型、要查找的输入参数名称、可选的过滤器类型以及如果需要的话任何额外的选项。`FILTER_SANITIZE_*`
    过滤器的作用是删除特定格式中不期望的数据。例如，`FILTER_SANITIZE_NUMBER_INT` 将删除除了数字和加减符号之外的所有内容。完整的清理选项列表可以在
    [https://packt.live/31vww0M](https://packt.live/31vww0M) 找到。
- en: 'Exercise 6.7: Sanitizing and Validating the User Input'
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.7：清理和验证用户输入
- en: In the following exercise, we will sanitize and validate the input data. Suppose
    that you have built an e-commerce web application and now you want to develop
    the feedback part. In the `POST` payload, you expect a message and a number of
    stars; that is, any number between one and five.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的练习中，我们将清理和验证输入数据。假设你已经构建了一个电子商务网络应用程序，现在你想开发反馈部分。在 `POST` 负载中，你期望收到一条消息和星级评分；也就是说，任何介于一到五之间的数字。
- en: 'Here are the steps to perform the exercise:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是执行练习的步骤：
- en: 'To sanitize the input, this is how you would use the `filter_input()` function,
    given that we look for the `stars` and `message` input fields:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要清理输入，你可以这样使用 `filter_input()` 函数，假设我们在查找 `stars` 和 `message` 输入字段：
- en: '[PRE40]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Of course, you should then check the `filter_input` return values. As the manual
    states, `NULL` will be returned when the input does not exist, `FALSE` if the
    filter fails, and a scalar otherwise. Next, we would like to validate the sanitized
    input data:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，你应该检查 `filter_input` 的返回值。正如手册所述，如果输入不存在，将返回 `NULL`，如果过滤器失败，则返回 `FALSE`，否则返回标量。接下来，我们想要验证清理后的输入数据：
- en: '[PRE41]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can also consider the following approach:'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以考虑以下方法：
- en: '[PRE42]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You will notice that, at some point, we have cast the `stars` input value to
    the `($stars = (int)$stars;)` integer. That's because, using `FILTER_SANITIZE_*`
    filter types, you will always get a string if the filter runs successfully. Additionally,
    you will notice that we have used the `filter_var` function, which, unlike `filter_input`,
    will accept a variable as the first argument and then the filter type and options.
    Of the two approaches I previously showed to validate an integer input, I prefer
    the first one, because it's less code and is likely to be faster than the second
    approach (anyway, unless you run a high-traffic web application, the performance
    difference between the two approaches is almost zero).
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到，在某个时刻，我们将 `stars` 输入值转换成了整数 `($stars = (int)$stars;)`。这是因为，使用 `FILTER_SANITIZE_*`
    过滤器类型时，如果过滤器运行成功，你总是会得到一个字符串。此外，你会注意到我们使用了 `filter_var` 函数，与 `filter_input` 不同，它将接受一个变量作为第一个参数，然后是过滤器类型和选项。在之前展示的两个验证整数输入的方法中，我更喜欢第一个，因为它代码更少，而且可能比第二个方法（无论如何，除非你运行的是高流量的网络应用程序，两种方法之间的性能差异几乎为零）更快。
- en: Note
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'Often, validating an integer input is done much more simply. Given the fact
    that the script may expect values higher than zero, or that when no value is specified
    zero would be the default value, the sanitization would look like this:'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，验证整数输入会做得更简单。考虑到脚本可能期望的值高于零，或者当没有指定值时，零将是默认值，清理将看起来像这样：
- en: '`$stars = (int)($_GET[''stars''] ?? 0); // using null coalescing operator`'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`$stars = (int)($_GET[''stars''] ?? 0); // 使用空合并运算符`'
- en: 'Validate the message input as well and print error messages if `$message` is
    `null` or `false` (that is, if the input was not found or the sanitization failed):'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证消息输入，如果`$message`是`null`或`false`（即输入未找到或清理失败），则打印错误消息：
- en: '[PRE43]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For debugging purposes, we may want to print the sanitized variable''s values:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了调试目的，我们可能想打印清理变量的值：
- en: '[PRE44]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now we''re missing the HTML part; that is, the form. It will require the two
    inputs with the `stars` and `message` names. We may consider using an input of
    type `text` for `stars` in this case in order to be able to enter invalid data,
    so that we can validate our sanitization and validation logic, and another input
    of type `textarea` for `message`:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们缺少HTML部分；也就是说，表单。它将需要两个带有`stars`和`message`名称的输入。在这种情况下，我们可能考虑使用类型为`text`的输入来`stars`，以便能够输入无效数据，这样我们就可以验证我们的清理和验证逻辑，并为`message`使用类型为`textarea`的另一个输入：
- en: '[PRE45]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Put the content in the `input-sanitize.php` file and open it in the browser
    at `http://127.0.0.1:8080/input-sanitize.php`. The output looks like this:![Figure
    6.25: The output of input-sanitize.php when first accessed'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将内容放入`input-sanitize.php`文件，并在浏览器中打开`http://127.0.0.1:8080/input-sanitize.php`。输出看起来像这样：![图6.25：首次访问input-sanitize.php时的输出
- en: '](img/C14196_06_25.jpg)'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_06_25.jpg)'
- en: 'Figure 6.25: The output of input-sanitize.php when first accessed'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.25：首次访问input-sanitize.php时的输出
- en: 'Enter `3a` for the `stars` rating, `Hello <script>alert(1)</script>` for the
    message, and then submit the form. You will get something like this as the output:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`stars`评分输入`3a`，为消息输入`Hello <script>alert(1)</script>`，然后提交表单。你将得到类似以下输出：
- en: '![Figure 6.26: A sample sanitization in the output of input-sanitize.php'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.26：input-sanitize.php输出中的示例清理'
- en: '](img/C14196_06_26.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_26.jpg)'
- en: 'Figure 6.26: A sample sanitization in the output of input-sanitize.php'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.26：input-sanitize.php输出中的示例清理
- en: 'In the following table, we have listed a series of inputs and the result for
    each submission. So, here is a list of sanitized values the script will render
    for their relative inputs:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的表中，我们列出了一系列输入及其每个提交的结果。因此，这里是一个脚本将为它们相对输入渲染的清理值列表：
- en: '![Figure 6.27: A list of sanitized values for various input messages'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.27：各种输入消息的清理值列表'
- en: '](img/C14196_06_27.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_27.jpg)'
- en: 'Figure 6.27: A list of sanitized values for various input messages'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.27：各种输入消息的清理值列表
- en: 'There are some more sanitization functions you should be aware of:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意一些其他的清理函数：
- en: '`strip_tags()`: This strips the HTML tags from a string; for example, `strip_tags(''Hello
    <script>alert(1)</script>!'');` will remove the `<script>` opening and closing
    tags, resulting in the following output: `"Hello alert(1)!"`. This removes the
    HTML tags where they are not expected and removes potentially dangerous scripts
    from being stored in the application, which may be output further in the browser
    causing malicious actions.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strip_tags()`: 这会从字符串中移除HTML标签；例如，`strip_tags(''Hello <script>alert(1)</script>!'');`
    将移除`<script>`的打开和关闭标签，结果如下输出：`"Hello alert(1)!"`。这会移除不期望的HTML标签，并从应用程序中移除可能危险的脚本，这些脚本可能会在浏览器中进一步输出，导致恶意行为。'
- en: '`trim()`: This strips whitespace characters by default, or other characters
    as specified, from the beginning and end of a string.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trim()`: 默认情况下，它会从字符串的开始和结束处移除空白字符，或者根据指定移除其他字符。'
- en: 'Here are some functions that you may want to use to validate your data:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可能想要使用的函数来验证你的数据：
- en: '`is_numeric()`: This tells us whether a variable is a number or a numeric string.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_numeric()`: 这告诉我们一个变量是否是数字或数字字符串。'
- en: '`preg_match()`: This performs a regular expression match.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preg_match()`: 这执行正则表达式匹配。'
- en: '`in_array()`: This checks whether the value exists in the list of values in
    the array that is given as an argument of the function.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in_array()`: 这检查给定的函数参数数组中的值是否存在于值列表中。'
- en: Escaping the Output
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出转义
- en: Now, let's talk about the data that is leaving the application. When sending
    data to a browser as HTML markup, you'll have to cover yet another security concern.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈离开应用程序的数据。当将数据作为HTML标记发送到浏览器时，你还得关注另一个安全问题。
- en: This time, you want to escape the data. Escaping means transforming potentially
    harmful data into unharmful data. Since the browser will render the page by parsing
    the HTML your script provides, you need to make sure the output is not creating
    unwanted side effects, breaking the page layout, or worse, putting the user session
    and data at risk.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你想要逃离数据。逃离意味着将可能有害的数据转换为无害的数据。由于浏览器将通过解析你提供的脚本中的HTML来渲染页面，你需要确保输出不会产生不期望的副作用，破坏页面布局，或者更糟糕的是，将用户会话和数据置于风险之中。
- en: Cross-Site Scripting (XSS)
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨站脚本攻击（XSS）
- en: The most common vulnerability on the web nowadays is **Cross-Site Scripting**
    (**XSS**). This vulnerability allows an attacker to inject arbitrary HTML tags
    and/or run arbitrary JavaScript code on the client side (in browsers).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现今网络中最常见的漏洞是**跨站脚本攻击**（**XSS**）。这种漏洞允许攻击者在客户端（在浏览器中）注入任意HTML标签和/或运行任意JavaScript代码。
- en: 'There are three types of XSS attacks:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: XSS攻击有三种类型：
- en: 'Stored XSS: Here, the malicious code is stored on the server or on the client
    browser.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储型XSS：在这里，恶意代码存储在服务器或客户端浏览器上。
- en: 'Reflected XSS: Here, the malicious code is returned immediately from the user
    input.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射型XSS：在这里，恶意代码立即从用户输入返回。
- en: 'DOM-based XSS: Here, the malicious code uses data stored in the DOM, to be
    sent to the attacker website.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于DOM的XSS：在这里，恶意代码使用存储在DOM中的数据发送到攻击者的网站。
- en: Although these are different types of XSS, they actually overlap. Often, they
    are referred to as Server XSS or Client XSS, pointing to the vulnerable side of
    a website.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些是不同类型的XSS，但它们实际上有重叠。通常，它们被称为服务器XSS或客户端XSS，指向网站的易受攻击的一侧。
- en: 'A common example of Reflected XSS is a search results page, where the user
    is shown the search input they submitted. A vulnerable script, in this case, should
    look like this:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 反射型XSS的一个常见例子是搜索结果页面，用户会看到他们提交的搜索输入。在这种情况下，一个有漏洞的脚本应该看起来像这样：
- en: '[PRE46]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Of course, accessing `/?s=hello` will result in `"Search terms: hello"`, which
    is what bad testing looks like. However, when `/?s=<script>alert(1)</script>`
    is tried, the output is `"Search terms: "` and a pop-up box displays the number
    1\. This is because the HTML will look like this:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '当然，访问`/?s=hello`将导致输出`"搜索词: hello"`，这是糟糕测试的样子。然而，当尝试`/?s=<script>alert(1)</script>`时，输出是`"搜索词:
    "`并且显示一个弹出框显示数字1。这是因为HTML将看起来是这样的：'
- en: '[PRE47]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: While this looks harmless, just think about the possibilities here. You can
    inject *any* HTML markup, including scripts, and be able to spy on user sessions,
    data, and actions, and even more – it is able to perform actions on the user's
    behalf.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来无害，但想想这里的可能性。你可以注入任何HTML标记，包括脚本，并且能够监视用户会话、数据和动作，甚至更多——它能够代表用户执行操作。
- en: 'Thankfully, there are methods to prevent such attacks, and while data validation
    and sanitization may also be used as well in this matter, one of the most commonly
    used methods is output escaping. PHP provides some built-in functions that provide
    such functionality: `htmlspecialchars()` and `htmlentities()`. What both of these
    functions do is translate certain sensitive characters into their associated HTML
    entity values, with the addition that `htmlentities()` translates all the characters
    that have an HTML-named entity associated with them. I encourage you to use `htmlentities($string,
    ENT_QUOTES)` so that all characters will be translated into entities; additionally,
    `ENT_QUOTES` ensures that both double and single quotes are escaped.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有方法可以防止此类攻击，虽然数据验证和清理也可以用于此，但最常用的方法之一是输出转义。PHP提供了一些内置函数，提供了这样的功能：`htmlspecialchars()`和`htmlentities()`。这两个函数所做的就是将某些敏感字符转换为它们相关的HTML实体值，另外，`htmlentities()`将所有与HTML命名的实体相关的字符都转换为实体。我鼓励你使用`htmlentities($string,
    ENT_QUOTES)`，这样所有字符都将转换为实体；此外，`ENT_QUOTES`确保双引号和单引号都被转义。
- en: 'Following the preceding example, the fix should look pretty simple:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的例子，修复应该看起来相当简单：
- en: '[PRE48]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now the browser will output `Search terms: <script>alert(1)</script>` since
    the HTML looks like this:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，浏览器将输出 `搜索词: <script>alert(1)</script>`，因为HTML看起来是这样的：'
- en: '[PRE49]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For convenience, I''ll print the list of special characters PHP will replace
    with `htmlspecialchars()`:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，我将打印PHP将用`htmlspecialchars()`替换的特殊字符列表：
- en: '![Figure 6.28: Special characters and their replacements'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.28：特殊字符及其替换](img/C14196_06_28.jpg)'
- en: '](img/C14196_06_28.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.28：特殊字符及其替换](img/C14196_06_28.jpg)'
- en: 'Figure 6.28: Special characters and their replacements'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.28：特殊字符及其替换
- en: Now, let's consider the example of a Stored XSS sample. As the name suggests,
    the Stored XSS is a piece of malware stored either on the server or on the browser.
    I'll discuss the one stored on the server, but in the case of the browser, it's
    similar (it's just not done with PHP).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个存储型XSS样本的例子。正如其名所示，存储型XSS是一段存储在服务器或浏览器上的恶意软件。我将讨论存储在服务器上的那种，但在浏览器的情况下，它类似（只是不是用PHP实现的）。
- en: 'Okay, so how can an XSS piece of malware be stored on a server? Well, it''s
    easy: that can be done with every user input that the application stores (which
    is in a database, usually). Think of the comments for a blog post, the reviews
    for products, an avatar''s URL, a user''s website URL, and other examples. In
    these cases, to render safe HTML, the answer is the same; that is, use `htmlentities()`.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么一个XSS恶意软件片段是如何存储在服务器上的呢？嗯，很简单：这可以通过应用存储的每个用户输入来完成（通常存储在数据库中）。想想博客帖子的评论、产品的评论、头像的URL、用户的网站URL以及其他例子。在这些情况下，为了渲染安全的HTML，答案是相同的；也就是说，使用`htmlentities()`。
- en: 'Let''s say there is a comment to a blog post in the database, with the following
    content:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 假设数据库中有一个博客帖子的评论，内容如下：
- en: '[PRE50]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this case, an attacker injects a script tag, which will execute a DOM write
    on the client side by adding a remote image (which is usually a pixel; you can't
    even spot it on the page). The remote image is hosted by the attacker's server,
    which, before serving the pixel image, will first collect all the data passed
    in the request query string – in this case, `document.cookie`. This means that
    the attacker will collect valid session IDs from all the visitors of the website;
    that is, anonymous visitors, logged-in users, and even admins.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，攻击者注入一个脚本标签，通过添加远程图片（通常是一个像素；你甚至无法在页面上看到它）在客户端执行DOM写入。远程图片由攻击者的服务器托管，在提供像素图片之前，它将首先收集请求查询字符串中传递的所有数据——在这个例子中，是`document.cookie`。这意味着攻击者将收集来自网站所有访问者的有效会话ID；也就是说，匿名访客、已登录用户，甚至是管理员。
- en: The preceding comment, if not escaped, will be rendered by the browser as `Great
    blog post!` without giving any hint that there might be some strange script executing.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不进行转义，前面的评论将被浏览器渲染为`Great blog post!`，没有任何提示表明可能有一些奇怪的脚本正在执行。
- en: 'The escaped version will be rendered as the original content of the comment
    because now the HTML will contain entities instead of the special characters:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 转义后的版本将作为评论的原始内容渲染，因为现在HTML将包含实体而不是特殊字符：
- en: '[PRE51]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about XSS at [https://packt.live/2MRX3jJ](https://packt.live/2MRX3jJ).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.live/2MRX3jJ](https://packt.live/2MRX3jJ)了解更多关于XSS的信息。
- en: 'Exercise 6.8: Securing against XSS'
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.8：防止XSS攻击
- en: In this exercise, you will build a script that is secured against user input.
    Let's say that you have to develop a search feature on an existing website. You
    are asked to print the searched value back to the page and to keep the current
    search term in the search input field. Of course, the script should be secured
    against user input.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将构建一个针对用户输入进行保护的脚本。假设你需要在现有的网站上开发一个搜索功能。你被要求将搜索值打印回页面，并保持当前搜索词在搜索输入字段中。当然，脚本应该对用户输入进行保护。
- en: 'Create a file called `output-escape-reflected.php`, with the following content:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`output-escape-reflected.php`的文件，内容如下：
- en: '[PRE52]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'First, we check whether we have the `s` entry in the `$_GET` variable and,
    if it''s there, we will print the escaped value to the browser using the `htmlentities()`
    function:'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们检查`$_GET`变量中是否有`s`条目，如果有，我们将使用`htmlentities()`函数将转义后的值打印到浏览器：
- en: '[PRE53]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Then, we print the search form, and in the search input field, we include the
    current searched term, escaping using the same `htmlentities()` function. Note
    that this time, we use `ENT_QUOTES` as the second argument, which will make the
    function escape both the single and double quotes; without this argument, only
    the double quotes are escaped. The reason we use this approach, even though the
    `value` attribute is assigned the value using double quotes, is that it allows
    the use of single quotes as well, so it's safer to escape both types of quotes.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们打印搜索表单，并在搜索输入字段中包含当前搜索词，使用相同的`htmlentities()`函数进行转义。请注意，这次我们使用`ENT_QUOTES`作为第二个参数，这将使函数转义单引号和双引号；如果没有这个参数，只有双引号会被转义。我们使用这种方法的原因，即使`value`属性使用双引号赋值，这也允许使用单引号，因此转义两种类型的引号更安全。
- en: Access the file at `http://127.0.0.1:8080/output-escape-reflected.php`.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问`http://127.0.0.1:8080/output-escape-reflected.php`文件。
- en: 'You should see something like this:'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该看到类似以下内容：
- en: '![Figure 6.29: The page output without the search term'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.29：未包含搜索词的页面输出'
- en: '](img/C14196_06_29.jpg)'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_06_29.jpg)'
- en: 'Figure 6.29: The page output without the search term'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.29：未包含搜索词的页面输出
- en: 'Enter `"Great blogpost!" <script>alert(''1'')</script>` as the search term
    and click on the `Search` button. You should see something like this:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `"Great blogpost!" <script>alert('1')</script>` 作为搜索词输入，并点击 `搜索` 按钮。你应该看到类似以下内容：
- en: '![Figure 6.30: The escaped output for the search term'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.30：搜索词的转义输出'
- en: '](img/C14196_06_30.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_30.jpg)'
- en: 'Figure 6.30: The escaped output for the search term'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.30：搜索词的转义输出
- en: As you can see from the preceding output, we have displayed the search term
    entered by the user and have also retained it in the search input field.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的输出中看到的那样，我们显示了用户输入的搜索词，并且也在搜索输入字段中保留了它。
- en: Cross-Site Request Forgery (CSRF)
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站请求伪造（CSRF）
- en: '**Cross-Site Request Forgery** (**CSRF**) is an attack that enables the user
    to execute unwanted actions on a web application in which they''re currently authenticated.
    This attack could succeed in the transfer of funds, changing an account email
    address, or making a purchase in the name of the user.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**（**CSRF**）是一种攻击，允许用户在当前已认证的Web应用程序上执行他们不希望执行的操作。这种攻击可能导致资金转移、更改账户电子邮件地址或以用户的名义进行购买。'
- en: This can happen when the attacker knows exactly what data is expected on the
    affected application for a certain action – changing an email address, let's say.
    So, the attacker crafts the HTML form on their server, filling it with their preferred
    data (that is, their own email address). Next, the attacker chooses the victim
    and uses social engineering to trick them into accessing the URL.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: This can happen when the attacker knows exactly what data is expected on the
    affected application for a certain action – changing an email address, let's say.
    So, the attacker crafts the HTML form on their server, filling it with their preferred
    data (that is, their own email address). Next, the attacker chooses the victim
    and uses social engineering to trick them into accessing the URL.
- en: The victim will then land on a malicious website and the browser will be instructed
    to submit the (invisible) form to the affected application, where the user is
    logged in. The email will be changed and when the victim realizes this, it may
    already be too late, as control of the account will have been taken by the attacker.
    It is worth mentioning that the victim would not even realize what caused this
    email change operation on the affected application since the form on the attacker's
    website could be submitted inside a pixel iFrame. So, the victim would think that
    they had accessed some type of cool viral video blog, without realizing the danger
    lurking behind the scenes.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 受害者随后会进入一个恶意网站，浏览器会被指示将（不可见的）表单提交给受影响的已登录应用程序。电子邮件地址会被更改，当受害者意识到这一点时，可能已经太晚了，因为账户的控制权已经被攻击者夺取。值得一提的是，受害者甚至可能不会意识到是什么导致了受影响应用程序上的电子邮件更改操作，因为攻击者网站上的表单可以在像素iFrame内部提交。因此，受害者可能会认为他们访问了一些类型的酷病毒视频博客，而没有意识到幕后隐藏的危险。
- en: Note
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Social engineering, in the context of information security, is performing a
    confidence trick for the purpose of information gathering, fraud, or system access,
    and refers to the psychological manipulation of people into performing actions
    or divulging confidential information.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在信息安全领域，社会工程学是指在信息收集、欺诈或系统访问的目的下进行信心骗局，它指的是对人们进行心理操纵以执行行动或泄露机密信息。
- en: To mitigate CSRF in your application, we suggest that you generate and use CSRF
    tokens. These are pieces of randomly generated strings of a variable length. These
    tokens are not part of the data that comes along with the form (such as cookies),
    but they are a part of the same form data. The token sent via the HTTP form is
    then compared to the value stored in the session data and, if there is a perfect
    match, the request is allowed.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻您应用程序中的CSRF攻击，我们建议您生成并使用CSRF令牌。这些是随机生成的可变长度的字符串片段。这些令牌不是随表单一起发送的数据的一部分（如cookies），但它们是表单数据的一部分。通过HTTP表单发送的令牌随后与会话数据中存储的值进行比较，如果完全匹配，则允许请求。
- en: Usually, you can generate one token per session, but one token can be generated
    per session form as well.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以为每个会话生成一个令牌，但也可以为每个会话表单生成一个令牌。
- en: The CSRF token method works to help prevent CSRF attacks, because the attacker
    doesn't know what your session's CSRF token is, and all the malicious operations
    that have worked before the implementation of the CSRF token will now fail early,
    at token validation.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF 令牌方法有助于防止 CSRF 攻击，因为攻击者不知道你的会话 CSRF 令牌是什么，并且所有在实现 CSRF 令牌之前成功进行的恶意操作现在将在令牌验证阶段失败。
- en: Note
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about CSRF at [https://packt.live/31aAFHb](https://packt.live/31aAFHb).
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.live/31aAFHb](https://packt.live/31aAFHb) 上了解更多关于 CSRF 的信息。
- en: 'Exercise 6.9: Securing against CSRF'
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.9：防范 CSRF 攻击
- en: In this exercise, you will set up a CSRF token to use for user action validation.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将设置一个 CSRF 令牌用于用户操作验证。
- en: 'Create a file called `form-csrf.php` and insert the following content:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `form-csrf.php` 的文件，并插入以下内容：
- en: 'First, the session should be started, then the script will look for the `csrf-token`
    entry in the session data and, if not found, one will be generated and stored
    in the session using two built-in functions. We will use `random_bytes()` to generate
    random bytes of a specified length, and `bin2hex()` to convert the binary data
    into hexadecimal representation; that is, a string containing digits ranging from
    0 to 9 and characters from `a` to `f`. The expression will generate a 64-character
    token:'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，应启动会话，然后脚本将在会话数据中查找 `csrf-token` 条目，如果未找到，则将生成一个并使用两个内置函数存储在会话中。我们将使用 `random_bytes()`
    生成指定长度的随机字节，并使用 `bin2hex()` 将二进制数据转换为十六进制表示；即，包含从 0 到 9 的数字和从 `a` 到 `f` 的字符的字符串。该表达式将生成一个
    64 位的令牌：
- en: '[PRE54]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, the script should check whether the request type is `POST` or not and,
    if positive, it will proceed with token validation. Here is the code to do this:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，脚本应检查请求类型是否为 `POST`，如果是，则进行令牌验证。以下是执行此操作的代码：
- en: '[PRE55]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'First, the CSRF token''s presence in the input data is checked: `array_key_exists(''csrf-token'',
    $_POST)`. The second check will compare the sent data with the data stored in
    the session data of the current user: `$_POST[''csrf-token''] === $_SESSION[''csrf-token'']`.
    If any of these two conditions fail, then appropriate error messages will be displayed.
    Otherwise, the success message will be printed.'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，检查输入数据中 CSRF 令牌的存在：`array_key_exists('csrf-token', $_POST)`。第二个检查将比较发送的数据与当前用户的会话数据中存储的数据：`$_POST['csrf-token']
    === $_SESSION['csrf-token']`。如果这两个条件中的任何一个失败，则将显示适当的错误消息。否则，将打印成功消息。
- en: 'In the end, the test form is printed. It should contain a dummy `email` input.
    We will add three submit buttons to the form. The first one will make the form
    submit only the email data. The second one will make the form send `"csrf-token"`
    with an empty value. Finally, the third one will make the form send `"csrf-token"`
    with the value stored in the *current* session. Here is the code to do this:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打印测试表单。它应包含一个虚拟的 `email` 输入。我们将在表单中添加三个提交按钮。第一个按钮将使表单仅提交电子邮件数据。第二个按钮将使表单发送空值的
    `"csrf-token"`。最后，第三个按钮将使表单发送存储在 *当前* 会话中的 `"csrf-token"` 的值。以下是执行此操作的代码：
- en: '[PRE56]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The final script can be referred at [https://packt.live/2B6Z7Pj](https://packt.live/2B6Z7Pj).
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终脚本可参考 [https://packt.live/2B6Z7Pj](https://packt.live/2B6Z7Pj)。
- en: Open the file at `http://127.0.0.1:8080/form-csrf.php`.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `http://127.0.0.1:8080/form-csrf.php` 上的文件。
- en: 'You should see something like this in your browser:'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该在浏览器中看到类似以下内容：
- en: '![Figure 6.31: Accessing form-csrf.php for the first time'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.31：首次访问 form-csrf.php'
- en: '](img/C14196_06_31.jpg)'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_06_31.jpg)'
- en: 'Figure 6.31: Accessing form-csrf.php for the first time'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.31：首次访问 form-csrf.php
- en: 'Click on the "`Submit without CSRF Token`" button. The output will be as follows:![Figure
    6.32: The token is not found'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“`不使用 CSRF 令牌提交`”按钮。输出将如下所示：![图 6.32：未找到令牌
- en: '](img/C14196_06_32.jpg)'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_06_32.jpg)'
- en: 'Figure 6.32: The token is not found'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.32：未找到令牌
- en: 'Click on the `Submit with empty/invalid CSRF Token` button. The output will
    be as follows:![Figure 6.33: The token is found, but is not valid'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“`使用空/无效 CSRF 令牌提交`”按钮。输出将如下所示：![图 6.33：找到令牌，但无效
- en: '](img/C14196_06_33.jpg)'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_06_33.jpg)'
- en: 'Figure 6.33: The token is found, but is not valid'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.33：找到了令牌，但无效
- en: 'Click on the `Submit with CSRF Token` button. The output will be as follows:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“`使用 CSRF 令牌提交`”按钮。输出将如下所示：
- en: '![Figure 6.34: The token is found and is valid'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.34：找到并验证了令牌'
- en: '](img/C14196_06_34.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_34.jpg)'
- en: 'Figure 6.34: The token is found and is valid'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.34：找到并验证了令牌
- en: As you can see from the preceding output, we have successfully generated and
    submitted a CSRF token, thereby protecting the application and user data against
    CSRF attacks.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述输出所示，我们已经成功生成并提交了一个CSRF令牌，从而保护应用程序和用户数据免受CSRF攻击。
- en: Building an Application (Bootstrapping the Examples)
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建应用程序（启动示例）
- en: As discussed previously, it is good practice to separate business logic from
    the presentation layer and other components of an application, to ease the development
    and maintenance of the application, and to make the application less prone to
    security issues.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，将业务逻辑与表示层和其他应用程序组件分离是一种良好的实践，这样做可以简化应用程序的开发和维护，并使应用程序更不容易出现安全问题。
- en: This chapter offers a very simple structure of an application, as a sample,
    just to demonstrate how you can achieve one entry point for your application,
    route requests and perform appropriate business logic, and also print a complete
    HTML page.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了一个非常简单的应用程序结构示例，仅为了展示您如何为应用程序实现一个入口点，路由请求并执行适当的业务逻辑，同时打印一个完整的HTML页面。
- en: 'We will be building an application using the best development practices in
    the upcoming exercise. However, before we do so, let''s review the basic directory
    structure that we will be using while building our web page. In the project root,
    there are two directories: `src/` and `web/`.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将使用最佳开发实践来构建一个应用程序。然而，在我们这样做之前，让我们回顾一下在构建我们的网页时将使用的基本目录结构。在项目根目录中，有两个目录：`src/`和`web/`。
- en: web/
  id: totrans-492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: web/
- en: 'This is the server document root containing the single entry point file for
    HTTP requests: `index.php`. Every file in this directory can be accessed through
    the server (unless a specific server configuration is used to prevent access to
    some locations inside this directory).'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含HTTP请求单入口点文件的服务器文档根目录：`index.php`。这个目录下的每个文件都可以通过服务器访问（除非使用了特定的服务器配置来阻止访问该目录内的某些位置）。
- en: Note
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The server will start in this directory and not in the parent directory (`/app`).
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将在这个目录中启动，而不是父目录（`/app`）。
- en: This approach is used to prevent random script files from accessing the WWW,
    which may lead to various consequences (such as data security and service availability),
    and to ease the maintenance of the application by reducing the entry points to
    a single one.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法用于防止随机脚本文件访问WWW，这可能导致各种后果（如数据安全和服务可用性），并通过减少入口点到一个来简化应用程序的维护。
- en: '`index.php`: This file is responsible for accepting all HTTP requests and producing
    and returning HTTP responses; it includes all the necessary script files of the
    application and runs specific tasks to achieve its purpose (for example, returning
    the HTTP response).'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.php`：这个文件负责接受所有HTTP请求并生成和返回HTTP响应；它包含应用程序的所有必要脚本文件，并执行特定任务以实现其目的（例如，返回HTTP响应）。'
- en: src/
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: src/
- en: This is the directory that contains the business logic and presentation files
    of the application; the script files are grouped by operation types (such as presentation,
    handlers, and higher-level components). This directory is not exposed to WWW;
    however, the scripts will run for each request, since they are included in `web/index.php`,
    which means that they are indirectly exposed to user input. Therefore, any type
    of input validation is a must.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含应用程序业务逻辑和表示文件的目录；脚本文件按操作类型分组（例如表示、处理程序和高级组件）。这个目录不对WWW公开；然而，由于它们包含在`web/index.php`中，因此每个请求都会运行这些脚本，这意味着它们间接地暴露给了用户输入。因此，任何类型的输入验证都是必不可少的。
- en: 'The `src/` directory contains three subfolders: `components/`, `handlers/`,
    and `templates/`. The details of these are as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/`目录包含三个子目录：`components/`、`handlers/`和`templates/`。这些目录的详细信息如下：'
- en: components/
  id: totrans-501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: components/
- en: '`Router.php`: The `Router` component is responsible for picking a handler (that
    is, a class name) to instantiate and returning it. Essentially, it will match
    a URI path to a handler class (for example, `/login` will result in returning
    the `\Handlers\Login` instance).'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '`Router.php`：`Router`组件负责选择一个处理程序（即类名）进行实例化并返回它。本质上，它将URI路径与处理程序类匹配（例如，`/login`将返回`\Handlers\Login`实例）。'
- en: '`Template.php`: The `Template` component is responsible for loading and rendering
    a template from the `templates` directory and returning the HTML content.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`Template.php`：`Template`组件负责从`templates`目录加载和渲染模板，并返回HTML内容。'
- en: handlers/
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: handlers/
- en: This directory contains the scripts with classes that will process the HTTP
    request and will generate response data. This directory has an abstract `Handler`
    class that implements some common functionality, which will be extended by actual
    handlers. The previously listed handlers are meant to cover the authentication
    (`Login.php`), secure the profile page, log out of any session (`Logout.php`),
    and protect the profile page display (`Profile.php`).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 此目录包含处理 HTTP 请求并生成响应数据的脚本，其中包含具有类的脚本。此目录有一个抽象的 `Handler` 类，它实现了一些常用功能，这些功能将由实际处理程序扩展。之前列出的处理程序旨在涵盖身份验证（`Login.php`）、保护个人资料页面、注销任何会话（`Logout.php`）以及保护个人资料页面显示（`Profile.php`）。
- en: templates/
  id: totrans-506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: templates/
- en: The `templates` directory, as the name suggests, holds the template files (or
    presentation files). These files contain mostly HTML and have little to no PHP
    logic.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`templates` 目录包含模板文件（或演示文件）。这些文件主要包含 HTML，并且几乎没有 PHP 逻辑。
- en: 'When building an application, we need to ensure that there is a single point
    of entry, as shown in the following figure:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序时，我们需要确保有一个单一的入口点，如下面的图所示：
- en: '![Figure 6.35: Exposing the web directory and accessing the scripts indirectly
    with HTTP requests'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.35：通过 HTTP 请求间接暴露 Web 目录和访问脚本]'
- en: '](img/C14196_06_35.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 C14196_06_35.jpg]'
- en: 'Figure 6.35: Exposing the web directory and accessing the scripts indirectly
    with HTTP requests'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.35：通过 HTTP 请求间接暴露 Web 目录和访问脚本]'
- en: This entry point is the only one that is exposed to the user's request. User
    requests are imported into web directory scripts so that no scripts can be directly
    accessed via the HTTP requests. This provides a security measure against malicious
    requests.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 此入口点是唯一一个暴露给用户请求的。用户请求被导入到 Web 目录脚本中，以便没有脚本可以通过 HTTP 请求直接访问。这提供了一种针对恶意请求的安全措施。
- en: In the preceding sections, we have described several best practices for building
    web applications. Let's put these into action to build an application in the following
    exercise.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们描述了构建 Web 应用程序的一些最佳实践。让我们将这些实践付诸行动，在接下来的练习中构建一个应用程序。
- en: 'Exercise 6.10: Building an Application: The Home Page'
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.10：构建应用程序：主页
- en: In this exercise, you will build an application that follows good development
    practices in PHP, by structuring the application into separate components that
    will deal with specific tasks. More specifically, we will build a website with
    a single page – that is, the home page, where we will use HTML to structure and
    render the contents on the browser page; CSS to "beautify" the page contents;
    and, of course, PHP to process all the incoming requests and send the appropriate
    responses to the browser.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将构建一个遵循 PHP 良好开发实践的应用程序，通过将应用程序结构化为处理特定任务的独立组件。更具体地说，我们将构建一个单页面的网站——即主页，我们将使用
    HTML 来结构化和在浏览器页面上渲染内容；CSS 来“美化”页面内容；当然，PHP 来处理所有传入的请求并向浏览器发送适当的响应。
- en: 'Please ensure the currently running server is stopped and create a new directory,
    which will be used to build your first application. Everything that follows will
    consider the working directory as the one that was just created. In my case, I''ll
    use the `/app` directory as the working directory, which you will notice later
    in the example. Here are the steps to perform the exercise:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保当前运行的服务器已停止，并创建一个新的目录，该目录将用于构建你的第一个应用程序。以下所有内容都将考虑刚刚创建的工作目录。在我的情况下，我将使用 `/app`
    目录作为工作目录，你将在后面的示例中注意到这一点。以下是执行练习的步骤：
- en: 'Create the following directory structure and files:![Figure 6.36: The directory
    structure of the application'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下目录结构和文件：![图 6.36：应用程序的目录结构]
- en: '](img/C14196_06_36.jpg)'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 C14196_06_36.jpg]'
- en: 'Figure 6.36: The directory structure of the application'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.36：应用程序的目录结构]'
- en: '**Where do we start?**'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**我们从哪里开始？**'
- en: Just as is the case when using any tool or framework, let's start with the minimum
    requirements so that we can incrementally add more after that. Since we are deploying
    a web application, let's set up the base view; that is, the template that repeats
    on every page.
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如使用任何工具或框架时的情况一样，让我们从最低要求开始，这样我们就可以在之后逐步添加更多内容。由于我们正在部署一个 Web 应用程序，让我们设置基本视图；也就是说，在每个页面上重复出现的模板。
- en: Create a `main.php` template file.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.php` 模板文件。
- en: In this file, we want to include the valid HTML template for a web page; therefore,
    we will include essential elements such as the `doctype` declaration; the HTML
    `root` tag; a `head` block with specific tags (for example, `title`), and a body
    block, in which we add a horizontal navigation bar with the website title (`Learning
    PHP`) and two links, `Home` (the `/` path) and `Profile` (the `/profile` path);
    and the main container where the output of other pages will be rendered. In this
    template file, we will look for the `$title` (`echo($title ?? '(no title)');`)
    and `$content` PHP variables and, if found, we will render them (`if (isset($content))
    echo $content;`). This template will include the CSS styles of the Bootstrap CSS
    framework, which makes the website look prettier without any effort. We have chosen
    Bootstrap v4 for page display stylization, but there are plenty of alternatives
    that you should check out and choose the one that you think best suits you. Alternatives
    such as Foundation, Jeet, Pure, and Skeleton do a similar job to Bootstrap. Often,
    lightweight libraries are preferred over the heaps of utilities of larger frameworks
    such as Bootstrap.
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个文件中，我们希望包含一个网页的有效HTML模板；因此，我们将包括一些基本元素，例如`doctype`声明；HTML的`root`标签；一个包含特定标签的`head`块（例如，`title`），以及一个`body`块，其中我们添加了一个带有网站标题（`Learning
    PHP`）和两个链接的水平导航栏，链接分别是`Home`（`/`路径）和`Profile`（`/profile`路径）；以及主容器，其他页面的输出将在这里渲染。在这个模板文件中，我们将查找`$title`（`echo($title
    ?? '(no title)');`）和`$content` PHP变量，如果找到，我们将渲染它们（`if (isset($content)) echo $content;`）。这个模板将包括Bootstrap
    CSS框架的CSS样式，这使得网站看起来更美观而无需任何努力。我们选择了Bootstrap v4用于页面显示风格化，但还有很多其他选择，你应该检查并选择你认为最适合你的一个。类似Foundation、Jeet、Pure和Skeleton这样的替代品与Bootstrap做类似的工作。通常，人们更倾向于使用轻量级的库，而不是像Bootstrap这样的大型框架的众多工具。
- en: 'Input the following code to include the previously mentioned information:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码以包含之前提到的信息：
- en: '[PRE57]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `main.php` template has the website HTML skeleton that will be rendered
    on every page.
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`main.php`模板包含将在每个页面上渲染的网站HTML骨架。'
- en: Now, to render this file accordingly, we need a component that will load the
    template file, create the expected variables (when provided), and then create
    the plain HTML input ready to display on the browser. We will use the `\Components\Template`
    class (that is, the `src/components/Template.php` file) for this purpose. A common
    feature for each template is the directory where they are stored, so we may want
    to save this parameter in a static variable.
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，为了相应地渲染这个文件，我们需要一个组件来加载模板文件，创建预期的变量（如果提供），然后创建准备在浏览器上显示的纯HTML输入。我们将使用`\Components\Template`类（即`src/components/Template.php`文件）来完成这个任务。每个模板的一个常见特性是它们存储的目录，因此我们可能希望将此参数保存在一个静态变量中。
- en: 'Save the directory in which the templates are stored in a static `$viewsPath`
    variable:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将存储模板的目录保存在静态的`$viewsPath`变量中：
- en: '[PRE58]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The complete path for a template file is unique to each template. Hence, we
    would like each template to contain its own required `path` property. Here is
    the code to do this:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板文件的完整路径对每个模板是唯一的。因此，我们希望每个模板都包含它自己的所需`path`属性。以下是实现这一点的代码：
- en: '[PRE59]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Since all the presentation files contain the `.php` extension, we will not include
    it in the name path; in this case, a `\Components\Template` with the name `main`
    will automatically append "`.php`" to the template name and will resolve the `src/templates/main.php`
    file.
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于所有表示文件都包含`.php`扩展名，我们不会在路径名称中包含它；在这种情况下，一个名为`\Components\Template`的文件将自动将"`.php`"添加到模板名称中，并解析`src/templates/main.php`文件。
- en: Render the template content using the provided associative array data.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供的关联数组数据渲染模板内容。
- en: 'We have the views path and the template name, and now we need a method (let''s
    call it `render()`) to render the file, importing the variables. We will use the
    built-in `extract()` function to import the variables into the current symbol
    table from the data array (`extract($data, EXTR_OVERWRITE);`). This means that
    if `$data = [''name'' => ''John''];`, the `extract()` function will import the
    `$name` variable that will have the value `John`. Then, we include the template
    file to render the content and, since we don''t want to output to the user just
    yet (we only want to render the template), we will catch the output using the
    `ob_start()` and `ob_get_clean()` output control functions to start the output
    buffering, get the contents, and clean the current buffer. The rendered content
    is then returned by the method:'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经有了视图路径和模板名称，现在我们需要一个方法（让我们称它为`render()`）来渲染文件，导入变量。我们将使用内置的`extract()`函数将变量从数据数组（`extract($data,
    EXTR_OVERWRITE);`）导入到当前符号表中。这意味着如果`$data = ['name' => 'John'];`，`extract()`函数将导入具有值`John`的`$name`变量。然后，我们包含模板文件以渲染内容，由于我们目前不想向用户输出（我们只想渲染模板），我们将使用`ob_start()`和`ob_get_clean()`输出控制函数来开始输出缓冲，获取内容，并清理当前缓冲区。然后，该方法将返回渲染的内容：
- en: '[PRE60]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The final script in `Template.php` can be referred here [https://packt.live/35D34t9](https://packt.live/35D34t9).
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Template.php`中的最终脚本可以在此处参考[https://packt.live/35D34t9](https://packt.live/35D34t9)。'
- en: 'Let''s see whether we can get an output in the browser now. Since `index.php`
    is the only file that is accessed through the web server, let''s open and add
    the requirements to print the first HTML page. First, we want to include the templates
    component and instantiate the `main` template:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看现在是否能在浏览器中获取输出。由于`index.php`是唯一通过Web服务器访问的文件，让我们打开并添加打印第一个HTML页面的需求。首先，我们想要包含模板组件并实例化`main`模板：
- en: '[PRE61]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We will put a website title in the `$templateData` associative array, and we
    will use this to invoke the `render()` method of the template instance, so that
    the `title` entry in the associative array will become the `$title` variable in
    the `main.php` file:'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在`$templateData`关联数组中放置一个网站标题，并使用它来调用模板实例的`render()`方法，这样关联数组中的`title`条目就会成为`main.php`文件中的`$title`变量：
- en: '[PRE62]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Start the PHP built-in web server in the `./web` directory, `php -S 127.0.0.1`,
    and access the home page at `http://127.0.0.1:8080/`.
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`./web`目录中启动PHP内置的Web服务器，`php -S 127.0.0.1`，并访问主页`http://127.0.0.1:8080/`。
- en: 'The output should look like this:'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '![Figure 6.37: The home page'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.37：主页'
- en: '](img/C14196_06_37.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_37.jpg)'
- en: 'Figure 6.37: The home page'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.37：主页
- en: Accessing the server document root without a specific filename will make the
    PHP built-in server automatically look for the `index.php` file (so accessing
    `http://127.0.0.1:8080/` is identical to `http://127.0.0.1:8080/index.php`). A
    similar configuration is done on production setups for different servers, such
    as NGINX and Apache. At this stage, clicking on any link will always make the
    main template be displayed.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有特定文件名的情况下访问服务器文档根，PHP内置服务器将自动查找`index.php`文件（因此访问`http://127.0.0.1:8080/`等同于`http://127.0.0.1:8080/index.php`）。在NGINX和Apache等不同服务器上的生产设置中也会进行类似的配置。在这个阶段，点击任何链接都会始终显示主模板。
- en: Note
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `/app` directory that can be seen in the preceding figure is the directory
    where I put the `src` and `web` directories.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图中可以看到的`/app`目录是我放置`src`和`web`目录的目录。
- en: Right now, clicking on the `Profile` button (that is, the `/profile` URI path)
    will make the same template render. Actually, any URI path would make the same
    `main` template render. Now, we may want to add some logic and print a different
    template for our Profile page. To do this, we should provide `content` data in
    the associative array we pass to the `\Components\Template::render()` method.
    As a recap, the `\Components\Template::render()` method will import the `content`
    array key and will make it available as a `$content` variable, which will be rendered
    in the `main` template (remember the `if (isset($content)) { echo $content; }`
    part in the `main` template).
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，点击`Profile`按钮（即`/profile` URI路径）将使相同的模板渲染。实际上，任何URI路径都会使相同的`main`模板渲染。现在，我们可能想添加一些逻辑并打印不同的模板用于我们的个人资料页面。为此，我们应该在传递给`\Components\Template::render()`方法的关联数组中提供`content`数据。作为一个回顾，`\Components\Template::render()`方法将导入`content`数组键，并将其作为`$content`变量提供，该变量将在`main`模板中渲染（记住`main`模板中的`if
    (isset($content)) { echo $content; }`部分）。
- en: It makes sense to return specific template content for each URI path (by checking
    the `$_SERVER['PATH_INFO']` value) and, since the pages returned often include
    dynamic or changing content, we need a *place* to process all the data we provide
    to the `\Components\Template::render()` method. For this purpose, we will use
    the request handlers; that is, the classes stored in the files of the `src/handlers/`
    directory. To recap, for each request, the script has to assign a handler class
    for a URI path, while the handler class is responsible for processing the request
    and returning content to the `main` template (you can do this by using the `Template`
    component or by just returning the string right away).
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个 URI 路径返回特定的模板内容（通过检查 `$_SERVER['PATH_INFO']` 的值）是有意义的，而且由于返回的页面通常包括动态或变化的内容，我们需要一个
    *地方* 来处理我们提供给 `\Components\Template::render()` 方法的所有数据。为此，我们将使用请求处理器；即存储在 `src/handlers/`
    目录中的类。为了回顾，对于每个请求，脚本必须为 URI 路径分配一个处理器类，而处理器类负责处理请求并将内容返回到 `main` 模板（你可以通过使用 `Template`
    组件或直接返回字符串来实现）。
- en: In the previous exercise, we built the home page of our application. Now we
    will continue building our application in the next exercise.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们构建了应用程序的主页。现在，我们将继续在下一个练习中构建我们的应用程序。
- en: 'Exercise 6.11: Building an Application: The Profile Page and the Login Form'
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.11：构建应用程序：个人资料页面和登录表单
- en: In this exercise, we will set up the handler's common functionality and create
    the abstract class, `\Handlers\Handler`, which will be extended by actual handlers.
    We declare it as abstract since we don't want it to be instantiated, but rather
    extended instead. Its purpose is to define some common functionality, such as
    returning the page title or setting a redirect request for an HTTP response, but
    also to require each handler class to implement the method responsible for request
    handling – we will simply call it `handle()`.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将设置处理器的一般功能并创建抽象类 `\Handlers\Handler`，它将由实际处理器扩展。我们将其声明为抽象的，因为我们不希望它被实例化，而是被扩展。它的目的是定义一些共同的功能，例如返回页面标题或为
    HTTP 响设置重定向请求，但也要求每个处理器类实现负责请求处理的方法——我们将简单地称它为 `handle()`。
- en: 'Save the `src/handlers/Handler.php` file content, which should look like this:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `src/handlers/Handler.php` 文件内容，它应该看起来像这样：
- en: '[PRE63]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To access the Profile page, we need an authenticated user; therefore, let''s
    build the login form and authentication logic. Add the following code to the `Login`
    handler:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问个人资料页面，我们需要一个经过认证的用户；因此，让我们构建登录表单和认证逻辑。将以下代码添加到 `Login` 处理器中：
- en: '[PRE64]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: What the `\Handlers\Login` handler does is implement the `handle()` method,
    which is a requirement since it extends the `Handlers\Handler` abstract class.
    In the `handle()` method, we return the rendered "l`ogin-form`" template.
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`\Handlers\Login` 处理器执行的操作是实现 `handle()` 方法，这是必须的，因为它扩展了 `\Handlers\Handler`
    抽象类。在 `handle()` 方法中，我们返回渲染的 "l`ogin-form`" 模板。'
- en: The "`login-form`" template, as the name suggests, will contain the HTML markup
    for the login form. What we want here is a form title, such as "`Authentication`",
    the "`username`" and "`password`" inputs and their labels, and the submit button.
    Since the credentials are not meant to appear in the address bar of the browser,
    the form method we choose is `POST`. If the form is submitted but data validation
    fails for some reason, the previously entered username will be displayed automatically
    in the `username` field `(<?= htmlentities($formUsername ?? '') ?>`). Additionally,
    when the authentication fails, the reason will be rendered under the specific
    field, inside a `div` element with the `invalid-feedback` CSS class.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如其名所示，"`login-form`" 模板将包含登录表单的 HTML 标记。我们在这里想要的是一个表单标题，例如 "`Authentication`"，以及
    "`username`" 和 "`password`" 输入框及其标签，还有提交按钮。由于凭证不应出现在浏览器的地址栏中，我们选择的表单方法是 `POST`。如果表单提交但数据验证因某些原因失败，之前输入的用户名将自动显示在
    `username` 字段中（`<?= htmlentities($formUsername ?? '') ?>`）。另外，当认证失败时，原因将在特定字段下方，在一个具有
    `invalid-feedback` CSS 类的 `div` 元素中显示。
- en: 'Let''s save the `login-form` template to the `src/templates/login-form.php`
    file:'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们将 `login-form` 模板保存到 `src/templates/login-form.php` 文件中：
- en: '[PRE65]'
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice that we use `htmlentities()` to escape the output from variables containing
    random, dynamic data, such as user input.
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用 `htmlentities()` 来转义包含随机、动态数据（如用户输入）的变量的输出。
- en: 'We have the `Login` handler and the `login-form` template already. What we
    need now is to run that handler for the `/login` path. Since we will have to add
    more rules like this (for example, running the `Profile` handler for the `/profile`
    path), it makes sense to group this functionality into a specific component. We
    will use the `\Components\Router` component for this purpose. What this `Router`
    component will do exactly is route the incoming requests to specific handlers
    based in the URI path (the `$_SERVER[''PATH_INFO'']` value). This can be simply
    achieved by using a `switch` statement. All this logic will be put in the only
    class method called `getHandler()`:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经有了`Login`处理程序和`login-form`模板。我们现在需要为`/login`路径运行该处理程序。由于我们还将添加更多类似规则（例如，为`/profile`路径运行`Profile`处理程序），将此功能组合到特定组件中是有意义的。我们将使用`\Components\Router`组件来完成此目的。这个`Router`组件将确切地执行根据URI路径（`$_SERVER['PATH_INFO']`值）将传入请求路由到特定处理程序的操作。这可以通过使用`switch`语句简单地实现。所有这些逻辑都将放入唯一的一个名为`getHandler()`的方法中：
- en: '[PRE66]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now we can use the router instance in the `index.php` file (the application
    entry point) to get a request handler or `null` for the current request. When
    a non-null value is returned, we can process the request with the `Handlers\Handler::handle()`
    method, check for the redirect request, get the page title, and set the appropriate
    data (that is, content and title) for the `main` template:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`index.php`文件（应用程序的入口点）中的路由器实例来获取当前请求的处理程序或`null`。当返回非空值时，我们可以使用`Handlers\Handler::handle()`方法处理请求，检查重定向请求，获取页面标题，并为`main`模板设置适当的数据（即内容和标题）：
- en: '[PRE67]'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, when someone enters a URI with a path that is not listed in the `switch`
    statement of the `\Components\Router::getHandler()` method (usually because of
    a typo), it will make the method return `null`, which will cause the `main` template
    to render with the default content (the `Hello world` block). We should not allow
    such behavior, since our website pages are indexed by search engines and are marked
    as duplicated content. We may want to display a `404 - Not found` error page,
    or redirect to an existing page, such as the home page. We will choose to redirect
    to the home page using the `/` path:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当有人输入一个URI路径，该路径不在`\Components\Router::getHandler()`方法的`switch`语句中列出（通常是因为拼写错误）时，它将使该方法返回`null`，这将导致`main`模板使用默认内容（`Hello
    world`块）进行渲染。我们不应允许这种行为，因为我们的网站页面被搜索引擎索引，并被标记为重复内容。我们可能希望显示一个`404 - Not found`错误页面，或者重定向到现有页面，例如主页。我们将选择使用`/`路径重定向到主页：
- en: '[PRE68]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'While `web/index.php` will become the following:'
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`web/index.php`将变为以下内容：
- en: '[PRE69]'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let''s take a look at what we have so far. Access the `http://127.0.0.1:8080/login`
    URL in your browser; the output should look like this:![Figure 6.38: Login page'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看到目前为止我们有什么。在浏览器中访问`http://127.0.0.1:8080/login` URL；输出应该看起来像这样：![图6.38：登录页面
- en: '](img/C14196_06_38.jpg)'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/C14196_06_38.jpg]'
- en: 'Figure 6.38: Login page'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.38：登录页面
- en: Here, we have a nice-looking login form, but so far without any functionality.
    Let's add some in the `\Handlers\Login` handler class.
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们有一个看起来很不错的登录表单，但到目前为止还没有任何功能。让我们在`\Handlers\Login`处理程序类中添加一些功能。
- en: 'First, we need to store a username and a password, and since we will learn
    about data persistence in the next chapter, let''s define these values directly
    in the PHP script:'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要存储用户名和密码，由于我们将在下一章学习数据持久性，让我们直接在PHP脚本中定义这些值：
- en: '[PRE70]'
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Note that we do not store the password in plain text for security reasons,
    and no one should ever do so. Additionally, a good approach is to avoid adding
    password hashes to `password_hash()`, which requires the password string as the
    first parameter and the hashing algorithm as the integer for the second parameter.
    The salt is generated automatically by the `password_hash()` function and is used
    to obtain the password hash using the `bcrypt` algorithm. Instantly obtaining
    a password hash with PHP is as simple as running a short inline code in Terminal:
    `php -r "echo password_hash(''admin'', PASSWORD_BCRYPT), PHP_EOL;"`.'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，出于安全原因，我们不存储明文密码，而且永远不应该这样做。此外，一个好的做法是避免将密码散列添加到`password_hash()`中，该函数需要密码字符串作为第一个参数，并将散列算法作为第二个参数的整数。盐由`password_hash()`函数自动生成，并用于使用`bcrypt`算法获取密码散列。使用PHP立即获取密码散列非常简单，只需在终端运行一段简短的内联代码：`php
    -r "echo password_hash('admin', PASSWORD_BCRYPT), PHP_EOL;"`。
- en: 'In the case of the `POST` request, we have to validate the login attempt; therefore,
    we should perform username and password matching. The errors, if there is a username
    or password mismatch, will be added to the `$formError` associative array under
    the `username` key (in the case of a username mismatch), and under the `password`
    key (in the case of password mismatch). To verify password matching, we will use
    the `password_verify()` built-in function, which requires the plain text password
    as the first argument, and the password hash as the second argument; it returns
    `TRUE` if there is a match, and `FALSE` otherwise:'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `POST` 请求的情况下，我们必须验证登录尝试；因此，我们应该执行用户名和密码匹配。如果有用户名或密码不匹配，错误将被添加到 `$formError`
    关联数组中的 `username` 键（在用户名不匹配的情况下），以及 `password` 键（在密码不匹配的情况下）。为了验证密码匹配，我们将使用 `password_verify()`
    内置函数，它需要明文密码作为第一个参数，密码哈希作为第二个参数；如果匹配，则返回 `TRUE`，否则返回 `FALSE`：
- en: '[PRE71]'
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The form errors and the form-submitted username will be sent to the template
    in the `render()` method:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表单错误和提交的表单用户名将在 `render()` 方法中发送到模板：
- en: '[PRE72]'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If the username and password matches, then add the username and login time
    in the session data, and then perform a redirect to the Profile page:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户名和密码匹配，则将用户名和登录时间添加到会话数据中，然后重定向到配置文件页面：
- en: '[PRE73]'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: In order to use the `$_SESSION` superglobal, the session must be started first,
    so we have to do it somewhere on a higher level, since we may need to use the
    session data in other places of the application, not only in the `Login` handler.
    We will add `session_start();` in the `web/index.php` file, after the `require_once`
    statements list.
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了使用 `$_SESSION` 超全局变量，必须首先启动会话，因此我们必须在较高层级的地方执行它，因为我们可能需要在应用程序的其他地方使用会话数据，而不仅仅是
    `Login` 处理器。我们将在 `web/index.php` 文件中 `require_once` 语句列表之后添加 `session_start();`。
- en: 'We may also check, at the very beginning of the `\Handlers\Login::handle()`
    method, whether the session username is already set (that is, whether an authentication
    was already performed) to prevent the login form displaying another login attempt
    taking place, and, if so, perform a redirect to the home page:'
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以在 `\Handlers\Login::handle()` 方法一开始就检查会话用户名是否已经设置（即，是否已经进行了认证）以防止登录表单显示另一个登录尝试正在进行，如果是这样，则将用户重定向到主页：
- en: '[PRE74]'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: At this point, we have completed the `Login` handler logic, and the content
    can be referred at [https://packt.live/2OJ9KzA](https://packt.live/2OJ9KzA).
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了 `Login` 处理器的逻辑，内容可以参考 [https://packt.live/2OJ9KzA](https://packt.live/2OJ9KzA)。
- en: 'We now have the login form and authentication functionality in place; let''s
    proceed by adding the protected Profile page. Since only the authenticated users
    are allowed to access this page, we will check for the `username` entry in the
    session data. When no user is authenticated, we will display the Login form (to
    perform this in the `\Handlers\Profile` handler):'
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经有了登录表单和认证功能；让我们通过添加受保护的配置文件页面来继续。由于只有经过认证的用户才能访问此页面，我们将检查会话数据中的 `username`
    条目。当没有用户认证时，我们将显示登录表单（在 `\Handlers\Profile` 处理器中执行此操作）：
- en: '[PRE75]'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In other words, the `/login` page will be rendered in the `/profile` page when
    the user is not authenticated.
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 换句话说，当用户未认证时，`/login` 页面将在 `/profile` 页面中渲染。
- en: Note
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Checking for the "`username`" entry in the session data, in this example, is
    our way of telling whether a user is logged in or not, which is not as secure
    and useful as it could be. Nowadays, using an open source solution to handle authentication
    is a much better alternative, since the session login data contains more information,
    such as login method, time, hashing algorithm, token, lifetime, and other potentially
    useful data that is used to validate the authentication.
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在会话数据中检查 "`username`" 条目，在这个例子中，是我们判断用户是否登录的一种方式，这并不像它本来的那样安全和有用。如今，使用开源解决方案来处理认证是一个更好的替代方案，因为会话登录数据包含更多信息，例如登录方法、时间、哈希算法、令牌、有效期以及其他可能有用的数据，这些数据用于验证认证。
- en: 'Otherwise, if we have an authenticated user, we will render and return the
    `profile` template, providing the username and session data to the template''s
    `render()` method:'
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果我们有一个经过认证的用户，我们将渲染并返回 `profile` 模板，将用户名和会话数据提供给模板的 `render()` 方法：
- en: '[PRE76]'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Additionally, let''s add the Profile page title by extending the `getTitle()`
    method from the parent class. The new title will include the word Profile prepended
    to the default title, which is provided by the parent class:'
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，让我们通过扩展父类中的 `getTitle()` 方法来添加 Profile 页面的标题。新标题将包括在父类提供的默认标题之前添加的单词 Profile：
- en: '[PRE77]'
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Save the `src/handlers/Profile.php` file; the full content should be as follows:'
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `src/handlers/Profile.php` 文件；完整内容应如下所示：
- en: '[PRE78]'
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `profile` template will only display the username and the session data
    that were provided as variables, plus the `/logout` value for the `href` attribute:'
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`profile` 模板将仅显示用户名和作为变量提供的会话数据，以及用于 `href` 属性的 `/logout` 值：'
- en: '[PRE79]'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `Logout` handler will regenerate the session ID and will destroy the current
    session''s data. Additionally, a redirect on the website home page will be requested:'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Logout` 处理器将重新生成会话 ID 并销毁当前会话的数据。此外，将在网站主页上请求重定向：'
- en: '[PRE80]'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We need to add the `Profile` and `Logout` handlers in the `Router` component:'
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在 `Router` 组件中添加 `Profile` 和 `Logout` 处理器：
- en: '[PRE81]'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Additionally, the `src/handlers/Logout.php` and `src/handlers/Profile.php`
    files should be required in `web/index.php`:'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，应在 `web/index.php` 中包含 `src/handlers/Logout.php` 和 `src/handlers/Profile.php`
    文件：
- en: '[PRE82]'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Note
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'Using a tool such as `composer` for the autoload feature, or any other implementation
    of "`PSR-4: Autoloader`", would make it much easier to deal with loading code.
    Using `composer` will be covered in *Chapter 9*, *Composer*.'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '使用 `composer` 这样的工具来实现自动加载功能，或者任何其他实现 "`PSR-4: Autoloader`" 的方法，将使处理代码的加载变得更加容易。`composer`
    的使用将在 *第 9 章*，*Composer* 中介绍。'
- en: 'Everything seems to be done; let''s take a look at how the website works. Click
    on the `Profile` link from the header. The output should look like this:![Figure
    6.39: The Profile page, displaying the login form for unauthenticated users'
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 似乎一切都已经完成；让我们看看网站是如何工作的。从页眉中点击 `Profile` 链接。输出应该如下所示：![图 6.39：Profile 页面，显示未认证用户的登录表单
- en: '](img/C14196_06_39.jpg)'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_06_39.jpg)'
- en: 'Figure 6.39: The Profile page, displaying the login form for unauthenticated
    users'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.39：Profile 页面，显示未认证用户的登录表单
- en: Enter `admin` for both the username and password and click on the `Login` button.
    You should now be able to access the Profile page:![](img/C14196_06_40.jpg)
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户名和密码都输入为 `admin`，然后点击 `Login` 按钮。你现在应该能够访问 Profile 页面了！![img/C14196_06_40.jpg](img/C14196_06_40.jpg)
- en: 'Figure 6.40: The Profile page, displaying the login information for the authenticated
    user'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.40：Profile 页面，显示认证用户的登录信息
- en: Click on `Home`, then back on `Profile`, and refresh the page. You will notice
    that the session is not lost between requests.
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击 `Home`，然后返回 `Profile`，刷新页面。你会注意到会话在请求之间没有丢失。
- en: Click on the `Logout` link from the Profile page. You should be redirected to
    the Home page. Accessing the Profile page again will result in the Login form
    display, as shown in *Figure 6.39*.
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Profile 页面点击 `Logout` 链接。你应该会被重定向到主页。再次访问 Profile 页面将导致显示登录表单，如图 *图 6.39*
    所示。
- en: Congratulations! You have just built your first website, and that's just the
    beginning. In this exercise, you have split the code according to its purpose,
    you have used security measures such as input validation and output escaping,
    and you have made the application respond appropriately to any HTTP request.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚构建了你的第一个网站，这只是开始。在这个练习中，你根据代码的目的进行了代码拆分，你使用了诸如输入验证和输出转义等安全措施，并且使应用程序能够适当地响应任何
    HTTP 请求。
- en: 'Activity 6.1: Creating a Support Contact Form'
  id: totrans-621
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 6.1：创建支持联系表单
- en: 'You are asked to implement a **Support Contact Form** on a new brand website.
    The form will be available for authenticated users only, on the Profile page,
    and the authentication part is in your charge as well. There will be two types
    of users: standard and VIP level. The standard users will be able to ask for support
    once per day, while the VIP users will have no limit. The form will contain the
    following fields: the name and the email where the replies should be sent to and
    the message. The form data should be sanitized and validated before it is registered.
    The rules are as follows: all required fields should be filled, use a valid email
    address, and the message should not be shorter than 40 characters.'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 你被要求在一个新的品牌网站上实现一个**支持联系表单**。该表单仅对认证用户可用，在个人资料页面上，认证部分也由你负责。将有两种类型的用户：标准和 VIP
    级别。标准用户每天只能请求一次支持，而 VIP 用户则没有限制。表单将包含以下字段：回复应发送到的姓名和电子邮件以及消息。在注册之前，应清理和验证表单数据。规则如下：所有必填字段都应填写，使用有效的电子邮件地址，并且消息长度不应少于
    40 个字符。
- en: 'The basic page layout should look like this:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 基本页面布局应如下所示：
- en: '![Figure 6.41: The expected page layout'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.41：预期的页面布局'
- en: '](img/C14196_06_41.jpg)'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14196_06_41.jpg]'
- en: 'Figure 6.41: The expected page layout'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.41：预期的页面布局
- en: Given this data, let's proceed. Since the functionality and some of the layout
    are very similar to the previous exercise, let's use that code as a starting point
    while adjusting and adding to it according to our specifications. You can copy
    the code from the previous exercise to another directory to keep a copy of the
    exercise solution and continue the work in the current directory, where the built-in
    server is already started. For the record, my current working directory is `/app`.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这些数据，我们继续进行。由于功能性和一些布局与之前的练习非常相似，我们可以使用那段代码作为起点，并根据我们的规格进行调整和添加。你可以将之前的练习中的代码复制到另一个目录中，以保留练习解决方案的副本，并在当前目录中继续工作，其中内置服务器已经启动。记录在案，我的当前工作目录是
    `/app`。
- en: Note
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before we start, make sure to log out of your current session by accessing the
    `http://127.0.0.1:8080/logout` URL in your browser.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保通过在浏览器中访问 `http://127.0.0.1:8080/logout` URL 来注销你的当前会话。
- en: 'Here are the steps to perform the activity:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此活动的步骤如下：
- en: Write the code to fetch the user data for the username that is logged in.
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以获取已登录用户的用户数据。
- en: Implement the `\Handlers\Login::handle()` method to validate the user credentials.
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `\Handlers\Login::handle()` 方法以验证用户凭证。
- en: Create a login form. You can use the code from the previous exercise; however,
    make sure you delete the hint for the credentials (such as the username and password
    for admin).
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个登录表单。你可以使用之前的练习中的代码；然而，确保你删除了凭证提示（例如管理员的用户名和密码）。
- en: Create the profile page. Here, you should build the `src/templates/profile.php`
    file from scratch. First, add the greetings and a logout button.
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建个人资料页面。在这里，你应该从头开始构建 `src/templates/profile.php` 文件。首先，添加问候语和注销按钮。
- en: Add a support area and divide it into two equal horizontal parts.
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个支持区域并将其分为两个相等的水平部分。
- en: 'Create a support contact form with the following specifications: two inputs
    of type `text`, for name and email, and a text area input for the message. Each
    of these will have an associated `<label>` element and, if there are errors, these
    will have to be printed under the input with erroneous data.'
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个符合以下规范的支撑联系表单：两个类型为 `text` 的输入框，用于姓名和电子邮件，以及一个用于消息的文本区域输入框。每个输入框都将有一个关联的
    `<label>` 元素，如果存在错误，这些错误将打印在包含错误数据的输入框下方。
- en: Note
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can refer to the Bootstrap framework documentation and use the `alerts`
    component.
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以参考 Bootstrap 框架文档并使用 `alerts` 组件。
- en: Write the code to prevent a standard-level user from sending more than one form
    a day. Again, you can use the `alerts` components from the Bootstrap framework.
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以防止标准级别用户每天发送超过一个表单。再次提醒，你可以使用 Bootstrap 框架的 `alerts` 组件。
- en: Secure the form by generating and using a CSRF token.
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过生成和使用 CSRF 令牌来保护表单。
- en: On the submit button, we may want to add more form data, so we can know for
    sure what form we have to process in the PHP scripts; this is very useful when
    many forms are added on a single HTML page, and each is sending data to the same
    URL.
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提交按钮上，我们可能还想添加更多表单数据，这样我们就可以确定在 PHP 脚本中必须处理哪个表单；当单个 HTML 页面上添加了许多表单，并且每个表单都向同一
    URL 发送数据时，这非常有用。
- en: Write the code to display the message list history. You may choose the `card`
    component and print all of the message details. Each stored history entry will
    contain the form data (that is, the `form` key) and the time when the form was
    sent (that is, the `timeAdded` key).
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以显示消息列表历史记录。你可以选择`card`组件并打印所有消息详情。每个存储的历史条目将包含表单数据（即`form`键）和表单发送的时间（即`timeAdded`键）。
- en: Write the code to validate the submitted form, and then write the code to refresh
    the page if the validation is successful.
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以验证提交的表单，然后编写代码以在验证成功时刷新页面。
- en: 'Input the code to send the following data to the template: the username (the
    greeting), the form errors if any, the form CSRF token, and the `sent` forms history.'
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入代码以将以下数据发送到模板：用户名（问候语）、如果有表单错误，表单CSRF令牌，以及`sent`表单历史记录。
- en: Add the form validation logic in a separate method.
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单独的方法中添加表单验证逻辑。
- en: Check for multiple submissions in the case of standard-level users.
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标准级用户的情况下检查多次提交。
- en: Write the code to display an error message if the user attempts to submit an
    empty name field.
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以在用户尝试提交空名称字段时显示错误消息。
- en: Implement email validation using the `filter_var()` function with `FILTER_VALIDATE_EMAIL
    validation`.
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`filter_var()`函数和`FILTER_VALIDATE_EMAIL验证`实现电子邮件验证。
- en: For the message field, write the code to ensure that the message is least 40
    characters long.
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于消息字段，编写代码以确保消息至少有40个字符长。
- en: Collect the sanitized form data and store it in the `$form` variable, which
    is then returned with the `$errors` variable.
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集清洗后的表单数据，并将其存储在`$form`变量中，然后与`$errors`变量一起返回。
- en: Now we can test our full implementation. You can begin by accessing the Profile
    page at `http://127.0.0.1:8080/profile` and continue testing for all fields across
    all pages.
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以测试我们的完整实现。你可以通过访问`http://127.0.0.1:8080/profile`页面开始测试，并继续对所有页面上的所有字段进行测试。
- en: Note
  id: totrans-652
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 520.
  id: totrans-653
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第520页找到。
- en: Summary
  id: totrans-654
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about an essential component of a web application
    – the Request-Response cycle of an application. You parsed the most commonly used
    HTTP methods and you are now able to tell the difference between them. You learned
    about best practices in terms of data security, code organization, and recommended
    approaches. You can perform data sanitization and validation as well, and you
    know how to upload files on a server, authenticate a user, and use a session,
    among other things. And, of course, you learned how to bootstrap all the examples
    into a practical piece – a web application.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了一个Web应用程序的基本组件——应用程序的请求-响应周期。你解析了最常用的HTTP方法，现在你能够区分它们。你了解了数据安全、代码组织和推荐方法方面的最佳实践。你还可以执行数据清洗和验证，你知道如何在服务器上上传文件、验证用户和使用会话，以及其他事情。当然，你还学习了如何将所有示例引导到一个实用的成果——一个Web应用程序。
- en: We are not done just yet. Data persistence was mentioned several times during
    this chapter and not in vain. Data persistence is used by every application and
    represents the essence of why applications exist – to collect, process, and store
    data. Although we have stored data in this chapter's exercises as well (for example,
    in sessions or cookies), in the next chapter, we will discuss data for the medium
    or long term; that is, data stored in files and databases.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成。数据持久性在本章中被提及多次，并非徒劳。每个应用程序都使用数据持久性，它代表了应用程序存在的本质原因——收集、处理和存储数据。尽管我们在本章的练习中也存储了数据（例如，在会话或cookie中），但在下一章中，我们将讨论中长期的数据；也就是说，存储在文件和数据库中的数据。
