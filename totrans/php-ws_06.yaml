- en: 6\. Using HTTP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 使用HTTP
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to explain the Request-Response
    Cycle of an application; explain the various HTTP methods; perform data sanitization
    and validation; track user session data; and build a web application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够解释应用程序的请求-响应周期；解释各种HTTP方法；执行数据清理和验证；跟踪用户会话数据；并构建一个Web应用程序。
- en: This chapter presents you with the necessary tools to use and implement HTTP
    requests in practical web applications. You will become familiar with request
    types and URL components and will learn about common vulnerabilities on the **World
    Wide Web** (**WWW**) as well as learn how to protect your applications against
    such attacks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为你提供了在实用Web应用程序中使用和实现HTTP请求的必要工具。你将熟悉请求类型和URL组件，并了解**万维网**（**WWW**）上的常见漏洞，以及如何保护你的应用程序免受此类攻击。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: So far, we have analyzed and learned about the PHP language itself – including
    data types, expressions, operators, and control statements – and how to use them
    in functions and classes. Before we jump into building a web application using
    what we have learned so far, it is crucial to understand client-server communication
    in a web application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经分析了PHP语言本身——包括数据类型、表达式、运算符和控制语句——以及如何在函数和类中使用它们。在我们利用所学知识构建一个网络应用程序之前，理解网络应用程序中的客户端-服务器通信至关重要。
- en: A web application (that is, a website) is designed to return a response for
    each request, which leads to a **Request-Response cycle**. In the web application
    world, this cycle is done through **Hypertext Transfer Protocol** (**HTTP**),
    which is a protocol that ensures both sides communicate with the same language
    or structure. HTTP requires data to be sent in two ways – from the client to the
    server (the request), and then the other way around; that is, from the server
    to the client (the response), closing the cycle. The Request-Response cycle doesn't
    necessarily mean a hit in application logic; it can be a request for a resource,
    such as a CSS file, an image, or even a PDF file. Essentially, most file downloads
    are the result of an HTTP request. All typical web applications require some HTTP
    requests to deliver on the WWW.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序（即网站）被设计为对每个请求返回一个响应，这导致了**请求-响应周期**。在Web应用程序的世界里，这个周期是通过**超文本传输协议**（**HTTP**）来完成的，这是一个确保双方使用相同的语言或结构的协议。HTTP要求以两种方式发送数据——从客户端到服务器（请求），然后反过来；也就是说，从服务器到客户端（响应），从而完成周期。请求-响应周期并不一定意味着在应用逻辑中发生冲突；它可能是一个对资源的请求，例如CSS文件、图片，甚至是PDF文件。本质上，大多数文件下载都是HTTP请求的结果。所有典型的Web应用程序都需要一些HTTP请求来在WWW上提供内容。
- en: In this chapter, we will perform HTTP requests using various HTTP methods. We
    will handle these HTTP requests in PHP by sanitizing and validating the input
    data, and we will learn how to protect against malicious requests. By the end
    of this chapter, you will have built your first web application using basic authentication,
    file upload, and temporary data storage features.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用各种HTTP方法执行HTTP请求。我们将通过清理和验证输入数据来在PHP中处理这些HTTP请求，并学习如何保护应用程序免受恶意请求的侵害。到本章结束时，你将使用基本身份验证、文件上传和临时数据存储功能构建你的第一个Web应用程序。
- en: The Request-Response Cycle of a Web Application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络应用程序的请求-响应周期
- en: To understand how an application loads in a browser, or how it gets data from
    a server, it is important to know about the Request-Response cycle. The Request-Response
    model is used extensively and it's not only applicable to web applications (such
    as using a browser). In fact, it's also used in the communication between machines;
    for example, for fetching data from a database, which involves the application
    system on one side and the database system on the other side. In this case, the
    application is the client for the database system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解应用程序如何在浏览器中加载，或者它是如何从服务器获取数据的，了解请求-响应周期非常重要。请求-响应模型被广泛使用，并且不仅适用于Web应用程序（如使用浏览器）。实际上，它也用于机器之间的通信；例如，从数据库获取数据，这涉及到应用系统的一侧和数据库系统的一侧。在这种情况下，应用程序是数据库系统的客户端。
- en: HTTP is the most commonly used protocol for web applications and, since it could
    take up a whole book itself, we'll cover only the most important part here, explaining
    how it works.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是Web应用程序中最常用的协议，由于它可能需要整本书来介绍，我们在这里只介绍最重要的部分，解释它是如何工作的。
- en: 'Each web application takes a request and prepares a response for it. Usually,
    the Request-Response cycle for a web application looks similar to this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Web应用都会接收一个请求并为它准备一个响应。通常，Web应用的请求-响应周期看起来类似于以下这样：
- en: The client makes a request; for example, `GET /path`.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发起一个请求；例如，`GET /path`。
- en: The server receives the request and looks for an existing or static file for
    the specified URI, which is returned to the client. If the static file is not
    there, then the request is treated as dynamic and it is sent to the application.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器接收请求并查找指定URI的现有或静态文件，并将其返回给客户端。如果静态文件不存在，则将请求视为动态请求，并将其发送到应用程序。
- en: The application prepares and sends a response back (that is, it processes the
    request) to the server layer.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序准备并发送响应回服务器层（即，它处理请求）。
- en: 'The server forwards the response from the application to the client:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器将应用程序的响应转发给客户端：
- en: '![Figure 6.1: The Request-Response Cycle for a web application'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1：Web应用的请求-响应周期'
- en: '](img/C14196_06_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_01.jpg)'
- en: 'Figure 6.1: The Request-Response Cycle for a web application'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：Web应用的请求-响应周期
- en: 'Let''s understand what''s going on here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这里发生了什么：
- en: The **CLIENT** of a web application is usually the browser, so I'll stick to
    using the browser as a client for the following. Each time a URL is accessed through
    a browser's address bar, a form is submitted or a background call is performed
    with AJAX, and a new request is made to that URL. Following the hostname (or website
    domain), which is an alias for a server's IP address, the request will hit a server.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Web应用的**客户端**通常是浏览器，所以以下内容我将坚持使用浏览器作为客户端。每次通过浏览器的地址栏访问URL、提交表单或执行AJAX的背景调用时，都会向该URL发出新的请求。在主机名（或网站域名）之后，它是服务器IP地址的别名，请求将击中服务器。
- en: The **SERVER** role is very important for a web application. In this case, it
    will try to route only dynamic requests to the PHP application. Therefore, one
    rule in the server's configuration could be to check for files inside the public
    web directory of the application, given the URI, and then return the file if that
    one exists; if the file is not there, treat the request as dynamic and forward
    it to the PHP application.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务器**在Web应用中扮演着非常重要的角色。在这种情况下，它将尝试仅将动态请求路由到PHP应用程序。因此，服务器配置中的一条规则可能是检查应用程序公共Web目录内的文件，根据URI返回文件；如果文件不存在，则将请求视为动态请求并将其转发到PHP应用程序。'
- en: The application receives the request and, based on it, it will perform certain
    actions such as fetching a list of heroes from the database and listing them in
    a specific order, and then the response will be prepared and sent back.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序接收请求并根据它执行某些操作，例如从数据库中检索英雄列表并按特定顺序列出它们，然后准备响应并发送回去。
- en: The server will simply forward that response to the open request.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器将简单地转发那个响应到开放的请求。
- en: Of course, this is a simplistic example of an application infrastructure setup
    and a basic example of the Request-Response cycle. Nowadays, especially when you
    design a web application while having scalability in mind, the diagram would look
    very different. However, the good thing is that you, as the developer, don't have
    to worry about this, or at least not yet.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个简化的应用程序基础设施设置和请求-响应周期的基础示例。如今，尤其是在考虑可扩展性的情况下设计Web应用时，图表看起来会非常不同。然而，好事是作为开发者的你不必担心这一点，或者至少目前不必。
- en: What is important to bear in mind here is that each web application is designed
    to respond to a request with a response, no matter where the request comes from
    – be it a `nginx` server or the built-in one – because all requests will look
    the same.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要记住的是，每个Web应用都是设计用来对请求做出响应的，无论请求来自何方——无论是`nginx`服务器还是内置服务器——因为所有请求看起来都是一样的。
- en: A Typical HTTP Request
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 典型的HTTP请求
- en: Each HTTP request is parsed by PHP automatically.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTP请求都会由PHP自动解析。
- en: 'Here is an example of an HTTP request, when accessing the [https://www.packtpub.com/tech](https://www.packtpub.com/tech)
    URL:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个HTTP请求的示例，当访问[https://www.packtpub.com/tech](https://www.packtpub.com/tech)
    URL时：
- en: '![Figure 6.2: A sample HTTP request'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2：一个示例HTTP请求'
- en: '](img/C14196_06_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_02.jpg)'
- en: 'Figure 6.2: A sample HTTP request'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：一个示例HTTP请求
- en: These headers are generated by the web browser in this case. From this request,
    the application can make use of a lot of information. First of all, this is a
    `GET` request for the `/tech` URI, using the `HTTP/1.1` protocol (line 1) and
    the called host is (line 2). The browser sets these parameters based on the URL
    in the address bar. The `Connection` header is set to a `keep-alive`, meaning
    the connection to the server is not closed and subsequent requests to that server
    can be made (line 3).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标头是由浏览器生成的。从这个请求中，应用程序可以利用大量信息。首先，这是一个针对 `/tech` URI 的 `GET` 请求，使用 `HTTP/1.1`
    协议（第 1 行），调用主机是（第 2 行）。浏览器根据地址栏中的 URL 设置这些参数。`Connection` 标头设置为 `keep-alive`，意味着与服务器的连接不会关闭，并且可以对该服务器发出后续请求（第
    3 行）。
- en: 'The `Upgrade-Insecure-Requests` header gives a hint to the server to let it
    know that the client prefers an encrypted and authenticated response (that is,
    it prefers HTTPS over HTTP). The `User-Agent` header contains the client information
    – in this case, it is the Chromium browser – providing useful information about
    the build. The `Accept` header gives us a hint about the content expected by the
    client, grouped by quality. The `q` here is called the factor weighting and it
    gives the quality of each value in this header entry, where a greater number is
    associated with greater quality. The default is `*/*`, meaning that any content
    type is expected. So, in our case, it appears with the lowest quality: `0.8`.
    `Accept-Encoding` details the content encoding of the response, which the client
    is able to understand. The `Accept-Language` header details which languages the
    client is able to understand and which locales are preferred; again, this is grouped
    by priority, using the same `q` weighting factor. The `Cookie` header is one of
    the most important headers and is one convenient way to send data from the client
    to the server. We will talk more about this later.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Upgrade-Insecure-Requests` 标头向服务器提供提示，让服务器知道客户端更喜欢加密和认证的响应（即，它更喜欢 HTTPS 而不是
    HTTP）。`User-Agent` 标头包含客户端信息——在这种情况下，它是 Chromium 浏览器——提供有关构建的有用信息。`Accept` 标头给我们提供了客户端期望的内容的提示，按质量分组。这里的
    `q` 被称为因子权重，它给出了此标头条目中每个值的品质，其中较大的数字与较高的品质相关联。默认值为 `*/*`，意味着期望任何内容类型。因此，在我们的情况下，它以最低的品质出现：`0.8`。`Accept-Encoding`
    详细说明了响应的内容编码，客户端能够理解。`Accept-Language` 标头详细说明了客户端能够理解的语言以及首选的区域设置；同样，这也是按优先级分组，使用相同的
    `q` 权重因子。`Cookie` 标头是最重要的标头之一，是从客户端向服务器发送数据的一种方便方式。我们将在稍后更多地讨论这一点。'
- en: A Typical HTTP Response
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 典型的 HTTP 响应
- en: 'For the previous request, we will get the following response headers:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前的请求，我们将得到以下响应标头：
- en: '![Figure 6.3 A sample HTTP response'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 一个示例 HTTP 响应'
- en: '](img/C14196_06_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 C14196_06_03.jpg](img/C14196_06_03.jpg)'
- en: Figure 6.3 A sample HTTP response
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 一个示例 HTTP 响应
- en: 'The most important information in a response is the response status, with **2xx**
    being associated with successful requests. A full list of statuses can be found
    at [https://packt.live/2owOHG2](https://packt.live/2owOHG2). In our case, we got
    **200 OK**, which means the request succeeded. Among the most well-known HTTP
    response statuses are the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 响应中最重要的信息是响应状态，其中 **2xx** 与成功请求相关联。状态的全列表可以在 [https://packt.live/2owOHG2](https://packt.live/2owOHG2)
    找到。在我们的情况下，我们得到了 **200 OK**，这意味着请求成功。在众多知名的 HTTP 响应状态中，以下是一些：
- en: '![Figure 6.4: HTTP response statuses'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.4：HTTP 响应状态'
- en: '](img/C14196_06_04.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 C14196_06_04.jpg](img/C14196_06_04.jpg)'
- en: 'Figure 6.4: HTTP response statuses'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4：HTTP 响应状态
- en: 'Some of the most common headers include the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最常见的标头包括以下内容：
- en: '**Date**: This represents the date and time the HTTP response message was created.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Date**：这代表 HTTP 响应消息创建的日期和时间。'
- en: '**Content-Type**: This is used to indicate the media type (or **Multipurpose
    Internet Mail Extensions** (**MIME**) type) of the resource.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Content-Type**：这用于指示资源的媒体类型（或 **Multipurpose Internet Mail Extensions** （MIME）类型）。'
- en: 'Expires: This contains the date/time after which the response is considered
    outdated.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Expires：这包含响应被认为过时的日期/时间。
- en: '**Cache-Control**: This is used to specify directives for caching mechanisms.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cache-Control**：这用于指定缓存机制的指令。'
- en: '`gzip`, `deflate`, and the `br` header, showing that `gzip` is a known encoding
    mechanism that the browser uses. So, the server used it to compress the data using
    `gzip`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gzip`、`deflate` 和 `br` 标头，表明 `gzip` 是浏览器使用的已知编码机制。因此，服务器使用 `gzip` 对数据进行压缩。'
- en: 'Non-standard **X-** prefixed headers: Although this convention has been deprecated
    already, it is still used for custom proprietary headers.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非标准 **X-** 前缀的头部：尽管这个约定已经被弃用，但它仍然用于自定义专有头部。
- en: Request Methods
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求方法
- en: As we previously mentioned, the request has a `GET` token right at the beginning
    of the message, meaning that it is a request of the `GET` type. This is one of
    the most commonly used HTTP request types because it is a means of fetching data
    from a server, be it an HTML page, an image, a `PDF` document, or plaintext data.
    As you might guess, there are more types of HTTP requests, and these are `POST`,
    `OPTIONS`, `HEAD`, `PUT`, and `DELETE`, among others. We will not cover all of
    these here, except the essential ones.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，请求在消息的开头有一个 `GET` 令牌，这意味着它是一个 `GET` 类型的请求。这是最常用的 HTTP 请求类型之一，因为它是一种从服务器获取数据的方式，无论是
    HTML 页面、图像、`PDF` 文档还是纯文本数据。正如你可能猜到的，还有更多类型的 HTTP 请求，包括 `POST`、`OPTIONS`、`HEAD`、`PUT`
    和 `DELETE` 等。我们在这里不会涵盖所有这些，只介绍必要的。
- en: GET HTTP Requests
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GET HTTP 请求
- en: The `GET HTTP` request is the most commonly used for a web application. It provides
    the necessary information for the resource that is requested from the server.
    This resource information can be placed in the `query string`, the `path` of the
    URL, or both.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET HTTP` 请求是用于 Web 应用程序中最常用的。它提供了从服务器请求的资源所需的信息。这些资源信息可以放在 `query string`、URL
    的 `path` 或两者中。'
- en: 'Let''s inspect how the [https://www.packtpub.com/tech/PHP](https://www.packtpub.com/tech/PHP)
    URL is composed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 [https://www.packtpub.com/tech/PHP](https://www.packtpub.com/tech/PHP)
    URL 的组成：
- en: First, we have the protocol – `https` – meaning the secured HTTP protocol is
    used.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们有协议 – `https` – 这意味着使用了安全的 HTTP 协议。
- en: Then, it's the hostname, pointing to the location of the required resource.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，是主机名，指向所需资源的位置。
- en: And, finally, there is the path, pointing to the *resource identifier*.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，是路径，指向 *资源标识符*。
- en: 'So, we can say the URL describes *how* (`https`), *where* from ([www.packtpub.com](http://www.packtpub.com)),
    and *what* (`/tech/PHP`) is requested, especially when it''s about `GET` requests.
    This is visualized in the following figure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以这样说，URL 描述了 *如何* (`https`)，*从哪里* ([www.packtpub.com](http://www.packtpub.com))，以及
    *什么* (`/tech/PHP`) 被请求，尤其是在涉及到 `GET` 请求的情况下。这在下图中得到了可视化：
- en: '![Figure 6.5: An interpretation of the URL components'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.5：URL 组件的解释'
- en: '](img/C14196_06_05.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_05.jpg)'
- en: 'Figure 6.5: An interpretation of the URL components'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：URL 组件的解释
- en: 'Important: *For security reasons, do not use GET to send sensitive information,
    such as login credentials*. Since `GET` uses query strings to send data, and this
    data is part of the URL, which is visible to everyone. Therefore, it remains in
    the browser history – this means that your browser will essentially keep your
    login URL in its history. This can be observed in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：*出于安全原因，请不要使用 GET 发送敏感信息，例如登录凭据*。因为 `GET` 使用查询字符串发送数据，而这些数据是 URL 的一部分，对每个人都是可见的。因此，它将保留在浏览器历史记录中——这意味着您的浏览器实际上会将您的登录
    URL 保留在其历史记录中。这可以在下图中观察到：
- en: '![Figure 6.6 Sending login credentials via the GET HTTP method'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.6 通过 GET HTTP 方法发送登录凭据'
- en: '](img/C14196_06_06.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_06.jpg)'
- en: Figure 6.6 Sending login credentials via the GET HTTP method
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 通过 GET HTTP 方法发送登录凭据
- en: This is just one example of how this method is bad for sending sensitive information.
    A better approach is to use the `POST` method for sending data that you don't
    want to store in the browser's history; this data could include login credentials,
    updating your profile with personal (or any) details, file uploads, and questionnaires.
    On the contrary, sending HTML forms using the `GET` method would be appropriate
    in the case of a page with a list of items, where we need to do filtering and
    sorting. Therefore, it is appropriate for the filter and sort parameters to be
    present in the query string component of the URL, so that when we bookmark or
    share the URL, you can get the same filtered and sorted items when accessing the
    URL later or from another browser or location.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是说明这种方法在发送敏感信息时很糟糕的一个例子。更好的方法是使用 `POST` 方法发送您不希望存储在浏览器历史记录中的数据；这些数据可能包括登录凭据、更新您的个人（或任何）详细信息、文件上传和问卷调查。相反，在需要过滤和排序的页面列表中使用
    `GET` 方法是合适的。因此，将过滤和排序参数放在 URL 的查询字符串组件中是合适的，这样当我们标记或分享 URL 时，您可以在稍后或从另一个浏览器或位置访问
    URL 时获得相同的过滤和排序项。
- en: POST HTTP Requests
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POST HTTP 请求
- en: 'The `POST` requests are used to create, alter, and/or delete resources on a
    server. This is due to the fact that `POST` requests have a body and not only
    headers. So, you can `POST` to `/some/uri` and send data in the request body in
    two ways: by default, as URL-encoded parameters (`application/x-www-form-urlencoded
    enctype`); or as multipart form data (`multipart/form-data enctype`). The difference
    between these two methods is based on what kind of data is sent to the server.
    So, when you want to upload an image, a PDF document, or any other file, you would
    use multipart form data; otherwise, URL-encoded data is enough.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`请求用于在服务器上创建、修改和/或删除资源。这是因为`POST`请求有一个主体，而不仅仅是头部。因此，你可以向`/some/uri`发送`POST`请求并在请求主体中发送数据，有两种方式：默认情况下，作为URL编码的参数（`application/x-www-form-urlencoded
    enctype`）；或者作为多部分表单数据（`multipart/form-data enctype`）。这两种方法之间的区别基于发送到服务器的数据类型。因此，当你想要上传图片、PDF文档或其他文件时，你会使用多部分表单数据；否则，URL编码的数据就足够了。'
- en: 'Sending multipart form data from HTML is enough to add the `enctype` attribute
    to the `form` element, as shown in the following snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从HTML发送多部分表单数据时，只需将`enctype`属性添加到`form`元素中，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Additionally, the browser will set the appropriate `Content-Type` request header,
    which would look like the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，浏览器将设置适当的`Content-Type`请求头，如下所示：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The **boundary** term here is used to specify a sent content delimiter, preferably
    a random non-dictionary string, which is less likely to appear in the sent payload.
    In the case of using HTML forms in the browser, you don't have to care about this
    parameter, as its value is generated and set automatically by the browser.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用的**边界**术语用于指定发送内容分隔符，最好是一个随机非字典字符串，它不太可能出现在发送的有效载荷中。在使用浏览器中的HTML表单时，你不必关心这个参数，因为它的值是由浏览器自动生成和设置的。
- en: 'Instead, when you only want to send some mapped textual data, without an upload,
    you can use `application/x-www-form-urlencoded` for the `enctype` attribute, which
    is set as the default when the `enctype` attribute is missing, as shown in the
    following snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当你只想发送一些映射的文本数据，而不进行上传时，你可以使用`application/x-www-form-urlencoded`作为`enctype`属性，当`enctype`属性缺失时，它被设置为默认值，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The URL-encoded form is very easy to send with command-line tools, such as `curl`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: URL编码的表单使用命令行工具，如`curl`发送非常简单。
- en: 'A sample command for the preceding `form` element would look like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`form`元素的示例命令如下所示：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is assuming that `127.0.0.1:8080` is where our server is listening and
    `form-url-encoded.php` is the PHP file that will process the request.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设`127.0.0.1:8080`是我们服务器监听的位置，而`form-url-encoded.php`是处理请求的PHP文件。
- en: What method should be used in the case of sign-up, a newsletter subscription,
    and a content search form? Why?
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在注册、订阅通讯录和内容搜索表单的情况下，应该使用哪种方法？为什么？
- en: What are some other use cases for submitting the `form` with the `POST` and
    `GET` methods? (For example, posting comments, rating a product, pagination, and
    more.)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`POST`和`GET`方法提交`form`有哪些其他用例？（例如，发表评论、评分产品、分页等。）
- en: Some servers will limit the query string length to 1,024 characters; for example,
    in the case of `Internet Information Server` (`IIS`). This limit can be configured
    in any server, but with daily use, it is less likely that you would encounter
    such an issue. Unlike the `GET` method, with `POST`, you have *no limit* on the
    data you can send over an HTTP request. Currently, the default limit for the `POST`
    payload in PHP per request is 8 MB, which can be increased at will in the settings.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一些服务器将查询字符串长度限制为1,024个字符；例如，在`Internet Information Server`（`IIS`）的情况下。这个限制可以在任何服务器上配置，但在日常使用中，你不太可能遇到这样的问题。与`GET`方法不同，使用`POST`，你发送HTTP请求的数据没有限制。目前，PHP中每个请求的`POST`有效载荷默认限制为8
    MB，可以在设置中随意增加。
- en: Query Strings
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询字符串
- en: A query string is part of a URL, containing data described in key-value pairs.
    Each key-value pair is delimited by the ampersand character (`&`), while the delimiter
    of a URL path from its query string is a question mark (`?`).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串是URL的一部分，包含以键值对形式描述的数据。每个键值对由与符号（`&`）分隔，而URL路径与其查询字符串之间的分隔符是一个问号（`?`）。
- en: 'As an example, we''ll use the following fictive URL:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，我们将使用以下虚构的URL：
- en: '[https://www.bookstore.com/books/?category=Comics&page=2](https://www.bookstore.com/books/?category=Comics&page=2).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.bookstore.com/books/?category=Comics&page=2](https://www.bookstore.com/books/?category=Comics&page=2)。'
- en: Here, the query string is `category=Comics&page=2` and the parameters are `category`
    and `page` with `Comics` and `2` values, respectively. It is worth noting that
    the parameters that can hold data are then parsed as arrays of values. For example,
    given the `/filter?tags[]=comics&tags[]=recent` URI, the tags query string parameter
    will result in an array with two values – `comics` and `recent`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Query strings are mostly used to access resources on the server, rather than
    as instructions to create, update, or delete. So, sharing a URL with a query string
    would list the same results in any browser, when no other contexts are interfering
    (such as logged-in user preferences, visitor location, or others). Take a look
    at what the URL looks like after you perform a search in your favorite search
    engine.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about HTTP at [https://developer.mozilla.org/en-US/docs/Glossary/HTTP](https://developer.mozilla.org/en-US/docs/Glossary/HTTP).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about URLs at [https://packt.live/33p2o8y](https://packt.live/33p2o8y)
    or [https://packt.live/2BcUNxL](https://packt.live/2BcUNxL).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about query strings at [https://packt.live/31fFtey](https://packt.live/31fFtey).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: PHP Superglobals
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PHP engine uses a list of built-in variables that are accessible anywhere
    in a PHP script, called **superglobals**. These superglobals contain data that
    is mostly related to requests, but they also contain some server information and
    running PHP script file information as well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The most frequently used superglobals are the `$_SERVER`, `$_SESSION`, `$_GET`,
    `$_POST`, `$_COOKIE`, and `$_FILES` variables.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: A good practice is to not mess with superglobals across a project, meaning it
    would be better not to alter the existing data or to add more or remove data from
    these variables. Ideally, you would only access them once per request. `$_SESSION`
    is an exception in this matter, as its data is provided by the application and
    not by the PHP engine.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: You can always learn about superglobals in more depth by visiting the official
    PHP documentation page, at [http://php.net/manual/en/language.variables.superglobals.php](http://php.net/manual/en/language.variables.superglobals.php).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: $_SERVER
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `$_SERVER` superglobal contains request headers, server information, paths,
    environment variables, and other data set by the web server. In short, request
    headers' names are converted to uppercase, the `-` (dash) is replaced by `_` (underscore),
    and `HTTP_` is prepended (the `User-Agent` header name becomes `HTTP_USER_AGENT`
    in `$_SERVER`). Requested information field names (such as URI and method) are
    prefixed with `REQUEST_`, and so on. Most of these names in the `$_SERVER` superglobal
    are accounted for in the `CGI/1.1 specification`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.1: Dumping the $_SERVER Data'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following exercise, we will dump the `$_SERVER` data in the browser for
    each HTTP request and will identify the key data used by the web application.
    Before we continue, please create a directory and use the Terminal to navigate
    into that new directory. All the created files will be saved into this directory;
    for example, let's assume the created directory is `/app`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将向浏览器中转储每个HTTP请求的`$_SERVER`数据，并识别Web应用程序使用的键数据。在我们继续之前，请创建一个目录并使用终端导航到该新目录。所有创建的文件都将保存在此目录中；例如，假设创建的目录是`/app`。
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In order to send an HTTP request to the PHP script (that is, to access the
    script through the browser), you need to start the built-in PHP development server.
    In order to do so, run the command that will start the development server in your
    `/app` working directory: `php -S 127.0.0.1`. Keep the server running for the
    next exercises as well.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向PHP脚本发送HTTP请求（即通过浏览器访问脚本），你需要启动内置的PHP开发服务器。为此，请在`/app`工作目录中运行启动开发服务器的命令：`php
    -S 127.0.0.1`。为了进行接下来的练习，请保持服务器运行。
- en: 'Create a PHP file called `super-server.php` and write the following code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`super-server.php`的PHP文件，并写入以下代码：
- en: '[PRE4]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Access the file through the built-in server, at `http://127.0.0.1:8080/super-server.php/my-path?my=query-string`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过内置服务器访问文件，在`http://127.0.0.1:8080/super-server.php/my-path?my=query-string`。
- en: 'The output should look like the following:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应该看起来像以下这样：
- en: '![Figure 6.7 The server data in the browser window'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.7 浏览器窗口中的服务器数据'
- en: '](img/C14196_06_07.jpg)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图C14196_06_07.jpg](img/C14196_06_07.jpg)'
- en: Figure 6.7 The server data in the browser window
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.7 浏览器窗口中的服务器数据
- en: 'Run the `super-server.php` file in the Terminal using the following:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在终端中运行`super-server.php`文件：
- en: '[PRE5]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output should look like the following:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应该看起来像以下这样：
- en: '![Figure 6.8 Server data in the Terminal'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8 终端中的服务器数据'
- en: '](img/C14196_06_08.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_08.jpg)'
- en: Figure 6.8 Server data in the Terminal
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 终端中的服务器数据
- en: Some often-used inputs in the case of scripts invoked by *WWW* (run due to the
    URL access) are `REQUEST_URI`; `REQUEST_METHOD`; `PATH_INFO`; `REMOTE_ADDR`, which
    is the network address of the client sending the request (or `HTTP_X_FORWARDED_FOR`
    when running your application behind a load balancer or a reverse proxy, for example);
    and `HTTP_USER_AGENT`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在由*WWW*（由于URL访问而运行）调用的脚本中，常用的输入有`REQUEST_URI`；`REQUEST_METHOD`；`PATH_INFO`；`REMOTE_ADDR`，这是发送请求的客户端的网络地址（或者在运行你的应用程序在负载均衡器或反向代理后面时，例如，使用`HTTP_X_FORWARDED_FOR`）；以及`HTTP_USER_AGENT`。
- en: In the preceding script, you will notice that the `/my-path` path is parsed
    in `PATH_INFO` and the query string in `QUERY_STRING`, while the entire URI is
    available in `REQUEST_URI`. These are the inputs used to route the requests to
    the appropriate PHP scripts in a web application so that the scripts can process
    them and produce the response.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的脚本中，你会注意到`/my-path`路径在`PATH_INFO`中解析，而查询字符串在`QUERY_STRING`中，整个URI在`REQUEST_URI`中可用。这些是用于将请求路由到Web应用程序中适当的PHP脚本，以便脚本可以处理它们并生成响应的输入。
- en: In the case of command-line scripts (run in Terminal or scheduled to run by
    the system at specific intervals), the most common `$_SERVER` inputs are `argv`
    and `argc`, as well as `REQUEST_TIME` and `REQUEST_TIME_FLOAT`, and `PWD`. `argv`
    is the list of argument values passed to the PHP executable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行脚本（在终端中运行或在系统特定间隔内计划运行）的情况下，最常用的`$_SERVER`输入是`argv`和`argc`，以及`REQUEST_TIME`和`REQUEST_TIME_FLOAT`，以及`PWD`。`argv`是传递给PHP可执行程序的参数值列表。
- en: The first argument (position zero) is the file being executed (or a static sentence,
    Standard input code, in the case of the running inline PHP code; for example,
    `php -r 'print_r($_SERVER);'`). Now, `argc` is the count of input arguments. `REQUEST_TIME`
    and `REQUEST_TIME_FLOAT` represent the time when the script started the execution,
    and are used for logging purposes or miscellaneous benchmarks. `PWD` is the current
    working directory and is useful in cases when the script should perform actions
    relative to the current location on disk, such as opening files or saving into
    files in the current directory.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数（位置零）是要执行的文件（或静态语句，标准输入代码，在运行内联PHP代码的情况下；例如，`php -r 'print_r($_SERVER);'`）。现在，`argc`是输入参数的计数。`REQUEST_TIME`和`REQUEST_TIME_FLOAT`代表脚本开始执行的时间，用于日志记录或各种基准测试。`PWD`是当前工作目录，在脚本应该相对于磁盘上的当前位置执行操作时很有用，例如打开文件或保存到当前目录中的文件。
- en: Unlike the request made from the browser, the `$_SERVER` variable has much less
    data when running in the command-line interface. There are no more `HTTP_*` entries
    and no more `SERVER_*` entries, since the request is not via HTTP anymore; `QUERY_STRING`
    and `REQUEST_METHOD` are also missing, among others.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与从浏览器发出的请求不同，在命令行界面运行时，`$_SERVER` 变量包含的数据要少得多。没有更多的 `HTTP_*` 条目和 `SERVER_*`
    条目，因为请求不再是通过 HTTP 进行；`QUERY_STRING` 和 `REQUEST_METHOD` 等其他内容也缺失。
- en: $_COOKIE
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $_COOKIE
- en: The `$_COOKIE` superglobal contains all the cookie data stored in the browser
    (when the browser is the HTTP client), stored by the same host, through the response
    headers or JavaScript. Since HTTP requests are stateless — meaning they are independent
    and unrelated to each other — using cookies is a great way to keep track of the
    user session in a web application, and also to offer a tailored experience for
    each visitor. Think of settings related to ad preferences, reference code to track
    conversions coming from several sources, and others. Cookies are *invisible* data;
    that is, they are not to be found in the URL and are not triggered by the submit
    button of an HTML form. They are set in the browser by the application, and the
    browser sends them with each HTTP request. Cookies are visible to browser users
    and, more than that, they can be removed by users — a fact an application is required
    to deal with.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`$_COOKIE` 超全局变量包含在浏览器中存储的所有cookie数据（当浏览器是HTTP客户端时），由同一主机通过响应头或JavaScript存储。由于HTTP请求是无状态的
    – 意味着它们是独立且相互无关的 – 使用cookie是跟踪Web应用程序中用户会话的绝佳方式，同时也为每位访客提供定制体验。想想与广告偏好设置相关的设置，跟踪来自多个来源的转换的参考代码，以及其他。Cookies是**不可见**的数据；也就是说，它们不会出现在URL中，也不会由HTML表单的提交按钮触发。它们由应用程序在浏览器中设置，并且浏览器会在每个HTTP请求中发送它们。Cookies对浏览器用户是可见的，更重要的是，用户可以删除它们
    – 这是一个应用程序必须处理的事实。'
- en: It is possible to store cookies using PHP's built-in function, `setcookie()`,
    and we can get those key-value pairs in the next HTTP requests from the `$_COOKIE`
    superglobal. To set a cookie, it's enough to call `setcookie("cookie_name", "cookie_value")`,
    and the value will be stored until the browser is closed. Alternatively, to make
    the cookie live longer than the browser session, you must specify the cookie's
    expiration time in the third argument of the function, as a Unix timestamp. For
    example, to allow a cookie to last for two days, you could call `setcookie("cookie_name",
    "cookie_value", time()+60*60*24*2)`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 PHP 内置函数 `setcookie()` 存储cookie，我们可以在后续的 HTTP 请求中从 `$_COOKIE` 超全局变量中获取这些键值对。要设置一个cookie，只需调用
    `setcookie("cookie_name", "cookie_value")`，其值将存储到浏览器关闭为止。或者，为了使cookie的寿命超过浏览器会话，必须在函数的第三个参数中指定cookie的过期时间，作为一个Unix时间戳。例如，要允许cookie持续两天，可以调用
    `setcookie("cookie_name", "cookie_value", time()+60*60*24*2)`。
- en: The `setcookie()` function accepts a cookie name as the first parameter, the
    cookie value as the second parameter, and the Unix time in seconds for the expiration
    as the third parameter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`setcookie()` 函数接受一个cookie名称作为第一个参数，cookie值作为第二个参数，Unix时间（以秒为单位）作为过期时间的第三个参数。'
- en: 'The syntax is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The parameters are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: '**name**: The cookie name.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**name**：cookie的名称。'
- en: '**value**: The cookie value; this is optional.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**value**：cookie值；这是可选的。'
- en: '**expires**: The expiration time, as a timestamp – this is optional; if omitted,
    the cookie will be deleted after the browser closes.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**expires**：过期时间，作为一个时间戳 – 这是可选的；如果省略，cookie将在浏览器关闭后删除。'
- en: '`/tech` (this is optional).'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/tech`（这是可选的）。'
- en: '**domain**: The (sub)domain for which the cookie will be available. Cookies
    set in the current domain will become available for any subdomain of the current
    domain; this is an optional parameter.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**domain**：cookie可用的（子）域名。在当前域名中设置的cookie将可用于当前域的任何子域名；这是一个可选参数。'
- en: '**secure**: This indicates that the cookie is set and transmitted only through
    the HTTPS request (that is, a secured request); this is optional.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**secure**：这表示cookie仅通过HTTPS请求（即安全请求）设置和传输；这是可选的。'
- en: '**httponly**: This indicates that the cookie is only available for HTTP requests;
    this is not available to scripting languages such as JavaScript on the client
    side (that is, the browser). This is an optional parameter.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**httponly**：这表示cookie仅对HTTP请求可用；在客户端的脚本语言（如JavaScript）中不可用（即浏览器）。这是一个可选参数。'
- en: '`expires`, `path`, `domain`, `secure`, `httponly`, and `samesite` keys. The
    values have the same meaning as the parameters with the same name. The value of
    the `samesite` element should be either `Lax` or `Strict`. This parameter is optional.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expires`、`path`、`domain`、`secure`、`httponly`和`samesite`键。这些值的含义与同名的参数相同。`samesite`元素的值应该是`Lax`或`Strict`。此参数是可选的。'
- en: Note
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For the full API of `setcookie()`, please visit [https://packt.live/2MI81YC](https://packt.live/2MI81YC).
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于`setcookie()`函数的完整API，请访问[https://packt.live/2MI81YC](https://packt.live/2MI81YC)。
- en: 'Exercise 6.2: Setting and Reading a Cookie'
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.2：设置和读取cookie
- en: In the following exercise, you will set a cookie and then read it in a PHP script
    using an HTML form to send data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，你将设置一个cookie，然后使用HTML表单发送数据，在PHP脚本中读取它。
- en: 'Here are the steps to perform the exercise:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此练习的步骤如下：
- en: Create a file called `super-cookie.php`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`super-cookie.php`的文件。
- en: 'Store the referral code in cookies so that we can read from it later (for example,
    at sign-up, to know who referred this user to us). The code for this is as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将推荐代码存储在cookie中，以便我们可以在以后读取它（例如，在注册时，以了解谁将此用户推荐给我们）。此代码如下：
- en: '[PRE7]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, the cookie value to be stored will be read from the `refcode` query string
    parameter: `/?refcode=etc`. Therefore, for each request, we will have to check
    for this entry in the `$_GET` variable and, if found, save the cookie with a lifetime
    of 30 days; otherwise, just print `No referral code was set in query string.`
    The cookie name is user-defined and, here, we have called it `ref`.'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，要存储的cookie值将从`refcode`查询字符串参数中读取：`/?refcode=etc`。因此，对于每个请求，我们都需要在`$_GET`变量中检查此条目，如果找到，则保存具有30天生命期的cookie；否则，只需打印`查询字符串中没有设置推荐代码。`cookie名称是用户定义的，在这里我们将其命名为`ref`。
- en: Note
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We use the `time()` function to get the current Unix time, in seconds. Therefore,
    for the current time, we should add 60 (seconds) multiplied by 60 (minutes), multiplied
    by 24 (hours), multiplied by 30 (days), for the cookie to expire after 30 days.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`time()`函数获取当前的Unix时间，以秒为单位。因此，对于当前时间，我们应该加上60（秒）乘以60（分钟）乘以24（小时）乘以30（天），以便cookie在30天后过期。
- en: 'Additionally, when storing the cookie, we may want to know what code was saved
    and include a link to the same script, without the query string, to avoid storing
    the cookie on page refresh. Here is the code to do this:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在存储cookie时，我们可能还想知道保存了什么代码，并包括一个指向同一脚本的链接（不带查询字符串），以避免在页面刷新时存储cookie。执行此操作的代码如下：
- en: '[PRE8]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, write the code to print the cookie value, which is stored in the browser
    and sent to the script in the HTTP request. For this, we have to read the `$_COOKIE`
    variable. If no `ref` entry exists, then display `-NONE-`. The code to do this
    is as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编写代码以打印存储在浏览器中并通过HTTP请求发送到脚本的cookie值。为此，我们必须读取`$_COOKIE`变量。如果不存在`ref`条目，则显示`-NONE-`。执行此操作的代码如下：
- en: '[PRE9]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: From the request when the cookie gets saved for the first time, we will also
    get `-None-`, since the cookie gets saved after a Request-Response cycle is completed
    and, in this case, the request does not have the `ref` cookie (that is, it is
    not present in the browser yet), but has the `refcode` query string parameter,
    which makes the script set the `ref` cookie value in the response (and it will
    then be saved by the browser).
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当第一次保存cookie时，我们也会得到`-None-`，因为cookie是在请求-响应周期完成后保存的，在这种情况下，请求没有`ref`cookie（即它尚未在浏览器中），但有`refcode`查询字符串参数，这使得脚本在响应中设置`ref`cookie值（然后它将被浏览器保存）。
- en: 'Also, to make easy tests sending different referral codes, let''s use a form
    of type `GET`, using input with the `refcode` name (which will appear in `query
    string` in the form submit) and the `EVENT19` default value:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，为了便于发送不同的推荐代码进行测试，让我们使用类型为`GET`的表单，使用具有`refcode`名称的输入（它将在表单提交时出现在`查询字符串`中）和`EVENT19`默认值：
- en: '[PRE10]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: When no method is specified in the HTML `form` element, the default value is
    `GET`.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当在HTML `form`元素中没有指定方法时，默认值是`GET`。
- en: As seen in this example, to use PHP scripts and HTML in the same file, we require
    PHP scripts to be included between the `<?php` and `?>` tokens.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如此例所示，要在同一文件中使用PHP脚本和HTML，我们需要在`<?php`和`?>`标记之间包含PHP脚本。
- en: Note
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can refer the complete code at [https://packt.live/2IMViTs](https://packt.live/2IMViTs).
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.live/2IMViTs](https://packt.live/2IMViTs)找到完整的代码。
- en: Access the file through the built-in server, at `http://127.0.0.1:8080/super-cookie.php`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过内置服务器访问文件，地址为`http://127.0.0.1:8080/super-cookie.php`。
- en: 'The output should look like this:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '![Figure 6.9 The output of super-cookie.php when first accessed'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.9 首次访问super-cookie.php时的输出'
- en: '](img/C14196_06_09.jpg)'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14196_06_09.jpg)'
- en: Figure 6.9 The output of super-cookie.php when first accessed
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.9 首次访问super-cookie.php时的输出
- en: Click on the `Apply referral code` button, and notice the new page content,
    which should look like this:![](img/C14196_06_10.jpg)
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“应用推荐代码”按钮，注意新页面的内容，它应该看起来像这样:![](img/C14196_06_10.jpg)
- en: 'Figure 6.10: The output of super-cookie.php after submitting the form'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.10：提交表单后super-cookie.php的输出
- en: At this stage, by clicking on the `Apply referral code` button, the form data
    has been serialized to the URL query format (refer to the `refcode=EVENT19` part
    in the preceding diagram). Accessing the form target URL made the script read
    the data from the query string and set the cookie with the provided `EVENT19`
    value.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个阶段，通过点击“应用推荐代码”按钮，表单数据已经被序列化为URL查询格式（参考前面图表中的`refcode=EVENT19`部分）。访问表单目标URL使脚本从查询字符串中读取数据，并使用提供的`EVENT19`值设置cookie。
- en: 'Click on `Clear the query string` and see that the script is able to parse
    and display the cookie data. The output should now display the cookie value, which
    was set in the previous step:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“清除查询字符串”，你会看到脚本能够解析并显示cookie数据。现在输出应显示在上一步骤中设置的cookie值：
- en: '![Figure 6.11: The output of super-cookie.php on subsequent requests'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11：随后的请求中super-cookie.php的输出'
- en: '](img/C14196_06_11.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_11.jpg)'
- en: 'Figure 6.11: The output of super-cookie.php on subsequent requests'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：随后的请求中super-cookie.php的输出
- en: Displaying cookie value on a Chrome DevTools window.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome DevTools窗口中显示cookie值。
- en: '![Figure 6.12 The ref cookie value displayed in a Chrome DevTools window.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.12 在Chrome DevTools窗口中显示的ref cookie值。'
- en: '](img/C14196_06_12.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14196_06_12.jpg)'
- en: Figure 6.12 The ref cookie value displayed in a Chrome DevTools window.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 在Chrome DevTools窗口中显示的ref cookie值。
- en: Now the URL contains no query string, meaning that our script has nothing to
    process. The cookie data is sent through, since it was set on the previous request,
    and is displayed on the browser page for each HTTP request.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在URL中不包含查询字符串，这意味着我们的脚本没有要处理的内容。由于在之前的请求中设置了cookie数据，因此它将通过HTTP请求发送，并在浏览器页面上显示。
- en: $_SESSION
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $_SESSION
- en: '`$_SESSION` has nothing to do with the HTTP request, yet it is a very important
    variable, as it holds the `state data` of a user; that is, keeping certain data
    across subsequent requests. Compared to cookies, the session data is stored on
    the server; therefore, the data is not accessible by the client. Session data
    is used to store logged-in user data (at least the ID) and temporary data (such
    as flash messages, CSRF tokens, shopping cart items, and more).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`$_SESSION` 与HTTP请求无关，但它是一个非常重要的变量，因为它保存了用户的`状态数据`；也就是说，在随后的请求中保持某些数据。与cookies相比，会话数据存储在服务器上；因此，数据不能被客户端访问。会话数据用于存储已登录用户数据（至少是ID）和临时数据（如闪存消息、CSRF令牌、购物车项目等）。'
- en: 'To store an entry in a session, it is enough to add it to the `$_SESSION` superglobal
    associative array, like this: `$_SESSION[''user_id''] = 123;`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要在会话中存储一个条目，只需将其添加到`$_SESSION`超级全局关联数组中即可，如下所示：`$_SESSION['user_id'] = 123;`。
- en: By default, PHP will not start the session automatically, meaning it will not
    generate a session ID and will not set the cookie header with the session ID value.
    So, you have to call `session_start()` in order to initialize the session. PHP
    will then try to load the session ID stored in the `PHPSESSID` variable (which
    is the default name) from the **Cookie** request header and, if such an entry
    name does not exist, then a fresh session will be started and the session ID will
    be sent back to the client with the current response in the headers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，PHP不会自动启动会话，这意味着它不会生成会话ID，也不会设置包含会话ID值的cookie头。因此，你必须调用`session_start()`来初始化会话。然后PHP将尝试从**Cookie**请求头中加载存储在`PHPSESSID`变量（默认名称）中的会话ID，如果不存在这样的条目名称，则将启动一个新的会话，并将会话ID发送回客户端，作为当前响应头的一部分。
- en: 'Exercise 6.3: Writing and Reading Data from a Session'
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.3：从会话中写入和读取数据
- en: 'In this exercise, we will implement session initialization and write and read
    data from a session. If the session is opening for the first time, then we will
    save random data to check that the session is preserving saved data for subsequent
    requests. The random data will be saved in the `name` key of the `$_SESSION` variable.
    Here are the steps to perform the exercise:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现会话初始化，并从会话中写入和读取数据。如果会话是第一次打开，那么我们将保存随机数据以检查会话是否为后续请求保留保存的数据。随机数据将保存在`$_SESSION`变量的`name`键中。以下是执行练习的步骤：
- en: Create a file called `session.php`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`session.php`的文件。
- en: 'Write the code to start the session and display the `Cannot start the session`
    string if the `session_start()` function does not return `TRUE`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以启动会话，并在`session_start()`函数不返回`TRUE`时显示`Cannot start the session`字符串：
- en: '[PRE11]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To work with sessions in PHP, you are required to *start the session*. This
    will perform a series of operations, such as generating the session ID and creating
    a session file where the data will be stored or connecting to the data provider
    service, depending on the settings of the `ini` files. If the session cannot start,
    then there's no reason to continue, so we will display an error message and stop
    the script execution.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在PHP中使用会话，您需要*启动会话*。这将执行一系列操作，例如生成会话ID、创建用于存储数据的会话文件或连接到数据提供者服务，具体取决于`ini`文件的设置。如果会话无法启动，则没有继续的理由，因此我们将显示错误消息并停止脚本执行。
- en: If the session is started, we may want to grab the session name – this is the
    name under which the ID is saved in cookies. The default session name is `PHPSESSID`.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果会话已启动，我们可能希望获取会话名称——这是ID在cookie中保存的名称。默认会话名称是`PHPSESSID`。
- en: 'Write the code to grab the session name:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以获取会话名称：
- en: '[PRE12]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the session was not initialized (that is, there is no cookie with the `PHPSESSID`
    variable), we may want to inform the user about that using the following code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果会话尚未初始化（即没有包含`PHPSESSID`变量的cookie），我们可能希望使用以下代码通知用户：
- en: '[PRE13]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Additionally, print the fresh session ID that is saved under the `$sessionName`
    cookie entry using the following code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，使用以下代码打印出保存在`$sessionName`cookie条目下的新鲜会话ID：
- en: '[PRE14]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `session_id()` function returns the current session ID that belongs to the
    user that is accessing the page only. It is generated each time `session_start()`
    is invoked and, at the same time, no cookie with the session ID is found in the
    HTTP request.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`session_id()`函数返回属于访问页面的用户的当前会话ID。它在每次调用`session_start()`时生成，同时，在HTTP请求中找不到包含会话ID的cookie。'
- en: Note
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We don't need to use a function to set the cookie with the generated session
    ID. This is done automatically when invoking `session_start()`.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不需要使用函数来设置包含生成的会话ID的cookie。这会在调用`session_start()`时自动完成。
- en: Choosing a random value from an indexed array should be easy using the `rand()`
    function. `rand()` will return a randomly picked number between a given minimum
    and maximum as an argument. In our case, for three values in an array, we need
    an index between 0 and 2\.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`rand()`函数从索引数组中选择随机值应该很简单。`rand()`将返回一个介于给定最小值和最大值之间的随机数。在我们的例子中，对于数组中的三个值，我们需要一个介于0和2之间的索引。
- en: 'Store the random entry in a session under the `name` key using the following
    code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码在会话中存储随机条目，使用`name`键：
- en: '[PRE15]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Print a message letting us know about the saved value in the session and the
    headers that are sent to the browser (to see the `Set-Cookie` header that saves
    the session ID in the browser):'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印一条消息，让我们知道会话中保存的值和发送到浏览器的头信息（以查看保存会话ID的`Set-Cookie`头信息）：
- en: '[PRE16]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have seen what to do when the session is not initialized yet. Now, if the
    session is already initialized, we will print the session name and the session
    ID (the value from the request cookies), and we will also dump the session data:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经看到了当会话尚未初始化时应该做什么。现在，如果会话已经初始化，我们将打印会话名称和会话ID（来自请求cookie的值），并且我们还将转储会话数据：
- en: '[PRE17]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Once the session is initialized, this will display the same data for each subsequent
    request, and all the changes performed in the user session data will also be reflected
    in subsequent requests. The session data can be considered as a storage unit for
    a user, just like cookies, but on the server side – the link between the client
    and the server is made using the session ID.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The whole script file can be referred at [https://packt.live/31gZKAe](https://packt.live/31gZKAe).
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Access the file through the built-in server at `http://127.0.0.1:8080/session.php`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first output will look like this:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.13: First access of session.php – initializing the new session and
    cookie set'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_06_13.jpg)'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.13: First access of session.php – initializing the new session and
    cookie set'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The cookie values look as follows:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.14: Cookie values in Chrome DevTools after the /session.php page
    was accessed'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_06_14.jpg)'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.14: Cookie values in Chrome DevTools after the /session.php page was
    accessed'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Refresh the page; the output should look like this:![Figure 6.15: Subsequent
    access of session.php – the session data restored with the ID from the cookie'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_06_15.jpg)'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.15: Subsequent access of session.php – the session data restored with
    the ID from the cookie'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since the actual value in the `$names` array is picked randomly, the value seen
    might be one of the three possible
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Clear the cookies for the current page and reload the page. Notice that a different
    session ID is generated and set when no `PHPSESSID` cookie is already set.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the explanation of the script: first, the script will try to start
    the session, and it will look for the session ID in a cookie. Next, the script
    will check whether such a cookie exists, using the `session_name()` function to
    get the name the session uses, from which it will store and fetch the session
    ID. If a cookie with such a name is found, then its value will be printed and
    the session data will be printed as well. Otherwise, it will inform you about
    the session ID that was generated and is set to be stored in a cookie, and a random
    character name will be picked and stored in the current session. Additionally,
    a list of headers to be sent in the response is printed, to make sure the (session)
    set-cookie header is sent.'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Learn more about session functions at [https://packt.live/31x8MJC](https://packt.live/31x8MJC).
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $_GET
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`$_GET` carries the parsed query string of a request URI, no matter the request
    method. Therefore, a URI such as `/?page=2` would result in the following `$_GET`
    value: `["page" => 2]`. PHP can parse a query string into nested arrays as well,
    so a query string such as `tags[]=heroes&tags[]=2019` would lead to a value of
    `$_GET`, such as `[ "tags" => [ 0 => "heroes", 1 => "2019" ] ]`, parsing tags
    into a numerical array. You can use a query string to parse into an associative
    array as well; just put names between the square brackets. For example, `filter[category]=heroes&filter[year]=2019`
    would be parsed as `[ "filter" => [ "category"=> "heroes", "year"=> "2019" ] ]`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.4: Using Query Strings in Web Pages'
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will build HTTP query strings, use them in web page links,
    and also use query string data. More precisely, you will use `$_GET` to select
    and display a specific data entry from a list.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to complete the exercise:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `super-get-href.php` and define a list of values in an
    associative array where keys are the entry IDs, and with nested associative arrays
    as values, with the `id` and `name` keys:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will need the query string to point out which entry the script should pick,
    so let''s assume the value we are looking for in the query string is under the
    `hero` name. So, to get the character ID, the `$heroId = $_GET[''hero''];` name
    would do the trick. Then, picking the character entry from our `$heroes` list
    should look like this: `$selectedHero = $heroes[$heroId];`. Here, `$selectedHero`
    is the entry, like `["id" => 1009187, "name" => "Black Panther"]` in the case
    where `$heroId` is `black-panther`.'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a `$selectedHero` variable initialization and check for the presence of
    the `hero` entry in `$_GET`; the code should look like this:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Before we display the character data, we will check whether the `$selectedHero`
    variable has values. If no values can be found in `$selectedHero`, it means no
    `hero` was specified in the query string parameter, or the value does not exist
    in the `$heroes` key list; therefore, we can display a plain `None`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For debugging purposes, we might want to dump the `$_GET` value. We can use
    `var_export` for this:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, it would be very useful to have some links on the page, one for each `$heroes`
    entry, to contain the `hero` query string parameter. We can add the code we need
    to build the link to a function, to avoid repeating the same logic over and over
    again in the same script. Let''s call that function `path()`, and allow it to
    accept an associative array that will be used to build the query string part of
    the URL. We will use the built-in `http_build_query()` function to generate the
    query string based on input data; for example, `[''name'' => ''john'']` will generate
    the `name=john` query string. This will be appended to the script filename (in
    our case, this is `super-get-href.php`):'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To create the HTML link, we will have to iterate the `$heroes` array and render
    an `<a>` element for each character, using the `path()` function to generate the
    `href` attribute value. Since we are looking into `$_GET[''hero'']` for the character
    ID, the argument for the `path()` function should be `[''hero'' => $heroId]`.
    All the links will be collected in the `$heroLinks` variable:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To print the link, using the double forward slash (`//`) separator, we can
    use the `implode()` array function to join all the entries using a separator:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will group the PHP logic on top of the script file and the HTML markup under
    it. You can refer to the complete file at [https://packt.live/35xfmDd](https://packt.live/35xfmDd).
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now access the file in your browser through the built-in server at `http://127.0.0.1:8080/super-get-href.php`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As the output, in the first line, you will have the links with character names,
    and below, you will find the value of the `$_GET` superglobal, which is an empty
    array:'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.16: Accessing the super-get-href.php script without query string
    parameters'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_06_16.jpg)'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.16: Accessing the super-get-href.php script without query string parameters'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now feel free to click on the links and watch what happens to the URL and the
    value of the `$_GET` variable. For example, clicking on the `Black Panther` link,
    you will notice the `http://127.0.0.1:8080/super-get-href.php?hero=black-panther`
    URL, and the content will look like this:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.17: Displaying the page after clicking on the “Black Panther” link'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_06_17.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.17: Displaying the page after clicking on the "Black Panther" link'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: $_POST
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`$_POST` carries the `POST` request data (that is, the URL-encoded or multipart
    form data). It is the same as for the query string; for example, when `reset=all`
    is sent in the `POST` payload, the output of `echo $_POST[''reset'']` will be
    `all`.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: The `POST` data is sent from the browser using HTML forms. The `POST` method
    is usually used to alter data in an application, either to create, to update,
    or to delete data; to move data; to trigger remote actions; or to change the session
    state, to name a few.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.5: Sending and Reading POST Data'
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will send `POST` data using an HTML form and manage this
    data in a PHP script. Following the previous example, let's keep the same data
    in the `$heroes` variable; however, instead of using links, we will use a form
    to send the data using the `POST` method.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `super-post-form.php` with the following content.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just like in the previous exercise, we''ll define an associative array with
    three entries, with URI-friendly IDs for characters as array keys, and character
    data (as associative arrays as well) as values. Add the following data to the
    `$heroes` variable:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Selecting a character entry is done the same as in the previous example, with
    the difference that we are now looking at the `$_POST` superglobal instead of
    the `$_GET` method of the previous exercise:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To display the selected character, we will keep the same format and logic from
    the previous exercise:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Also, for debugging purposes, we will dump the `$_POST` values:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To use the POST method to end data, we will use a `<form>` element with a `<select>`
    element. The `<select>` element will contain the `<option>` with the character
    ID as a value and the character name as a label:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Open the file in the browser at `http://127.0.0.1:8080/super-post-form.php`.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output should look like this:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.18: First access to the super-post-form.php script'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_06_18.jpg)'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.18: First access to the super-post-form.php script'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the `Captain America` item in the `<select>` element and click on the
    `Show` button.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output is now as follows:'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.19: Displaying the super-post-form.php script result after submitting
    the form'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_06_19.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.19: Displaying the super-post-form.php script result after submitting
    the form'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Notice the new content on the page, and also take a look at the URL – there
    is no longer a query string since the data is sent in the HTTP request body. As
    you might notice, this is the same as for the `$_GET` variable – it's just the
    input source that is different. In addition to this, notice that the `<select>`
    element displays the `A-Bomb (HAS)` value; this is because there is no `<option>`
    with the `selected` attribute set, and the `<select>` element defaults to the
    first option as the selected option.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: $_FILES
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `$_FILES` superglobal contains data for upload attempts, meaning uploads
    are not considered successful if their related data is found in this variable.
    The reason for failed attempts varies, and a list of reasons (or upload statuses)
    can be found on the official PHP documentation page ([https://packt.live/32hXhH2](https://packt.live/32hXhH2)).
    All the uploaded files are stored in a temporary location until the application
    scripts move them to persistent storage. `$_FILES` is an associative array with
    the form of an input name as an entry key and the upload information as an entry
    value. The upload information is another associative array with the following
    fields: `name`, `tmp_name`, `type`, `size`, and `error`.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: The `name` field will have the file's base name sent with the request; `tmp_name`
    will have the temporary location of the uploaded file (so that your script can
    move it to the appropriate place); `type` will have the media type of the file
    (the MIME type) sent by the client in the same request; `size` will be the file
    size in bytes; and `error` will have information about the upload status. Note
    that the *specified media type in type* `key` *is not the file extension as it
    appears on the operating system's filesystem.*
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Caution
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: As a good practice, it is recommended that you use built-in functions or other
    appropriate tools to detect the MIME type of a file; therefore, do not trust the
    user input – do always test it. By default, the uploaded file size limit is 2
    MB, and the POST payload limit is 8 MB (for the whole request).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.6: Uploading a File and Validating its Type'
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will upload an image, validate the uploaded file by detecting
    its MIME type, and then display the successfully uploaded image in the browser.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to perform the exercise:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `super-post-upload.php`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we try uploading the file, we should define the upload location, the
    destination file path, and, to be able to display it in the browser, the file's
    relative path to the server document root directory (in our case, the document
    root is the directory where the script file is running).
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will use a static filename for the upload target so that we can save and
    display a single image, not a list of them:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `$relativeFilename` relative file path, unlike the target file path, is
    not the full file path on the disk; it is instead just the path relative to the
    current directory that is the server document root, where the script is run. In
    order to achieve this, we use the built-in `substr()` function to subtract the
    string from the target file path, starting with the string in the `strlen(__DIR__)`
    position, meaning the part from the target file path to the current directory
    will be cut.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure `$uploadsDir` is a valid path on the disk; create the `uploads` directory
    if it does not exist.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since the uploaded files (or upload attempts) are stored in the `$_FILES` variable,
    we will check the watched entry in it. Let''s suppose we expect a file under the
    `uploadFile` input name; then, we can perform the check with `array_key_exists(''uploadFile'',
    $_FILES)`. Eventually, the `$_FILES[''uploadFile'']` value will be stored in the
    `$uploadInfo` variable to make it more convenient to work with the uploaded file
    information:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we want to make sure the upload was completed successfully. The upload
    status is stored in the `error` entry, as stated before, so we may want to use
    a `switch` statement to jump to the status of the upload, using the `UPLOAD_ERR_*`
    constant for the `case` value. The beginning of the `switch` statement should
    look like this:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the case of a successful upload, we should validate the input data. What
    we care about the most is the MIME type of the content the server got from the
    client and, to check whether it''s the expected one, we use the built-in `mime_content_type()`
    function. Let''s suppose that we only allow PNG images to be uploaded, as follows:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After the validation passes, we should move the file from the temporary location
    to the `$targetFilename` destination that we defined earlier, and we will use
    the `move_uploaded_file()` function for that. This function takes the temporary
    path of the uploaded file as the first argument and the target as the second argument.
    It returns `TRUE` if successful:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Caution
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Avoid using the `rename()` filesystem function for this operation, due to security
    implications. `move_uploaded_file()` is much better to use in this context because
    it will only proceed if the file to be moved is an uploaded file in the current
    request.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will add the case of the exceeding file size (`UPLOAD_ERR_INI_SIZE`) and
    the missing file for the upload operation (`UPLOAD_ERR_NO_FILE`), and print a
    custom error message for each:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For other status types, let''s add a generic message displaying the error code:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To upload a file from a web page, we have to add the upload form on that web
    page, including the `<input>` of type `file` and the `"uploadFile"` name (which
    we are watching in the script). The form requires the `enctype` attribute with
    the `"multipart/form-data"` value:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After handling the file upload, let''s display the image after it''s uploaded.
    First, we will have to check whether the file exists, and we do this by using
    the built-in filesystem function, `file_exists()`:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To display the image in the browser, we should render an HTML `<img>` element
    with the relative path to the server document root in the `src` attribute:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Open the file in your browser at `http://127.0.0.1:8080/super-post-upload.php`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output should be a file upload form only:'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.20: The file upload form'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_06_20.jpg)'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.20: The file upload form'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click on `Upload` without selecting a file. This time, an error message will
    be displayed before the form. The output should look like this:![Figure 6.21:
    File upload error when no file is submitted'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_06_21.jpg)'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.21: File upload error when no file is submitted'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We got a `No file was uploaded.` error since `$uploadInfo['error']` had the
    value of `UPLOAD_ERR_NO_FILE` due to the missing file in the form upload input.
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select a big file (that is, bigger than 2 MB) and hit the `Upload` button. This
    time, another error message will warn you about the exceeded size limit for the
    uploaded file:![](img/C14196_06_22.jpg)
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.22: File upload error when the submitted file is too big'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similar to the previous step, we got an upload error. This time the upload error
    was `UPLOAD_ERR_INI_SIZE`.
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Select a file that is under 2 MB and non-PNG and hit the `Upload` button. Yet
    another error message will appear telling you that the file format is not the
    accepted format:![Figure 6.23: File upload error when the submitted file is not
    the accepted format'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_06_23.jpg)'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.23: File upload error when the submitted file is not the accepted
    format'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unlike in previous steps, the upload error this time was `UPLOAD_ERR_OK`, which
    means no error occurred with the upload. The error message displayed on the page
    is caused by the file MIME type validation, which is required to be `image/png`.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, select a PNG image file that is smaller than 2 MB and hit the `Upload`
    button. The page should display the successful upload message and render the uploaded
    picture:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.24: File upload success when the submitted file meets the requirements'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_06_24.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.24: File upload success when the submitted file meets the requirements'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Since the upload happened without errors, and the MIME file type is the expected
    one, the file gets stored on the designated path on the server and is displayed
    on the browser page.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Securing Input and Output Data
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to protect your website's users and the website itself, you should
    protect your web applications from malicious input and operations. Application
    security is one of the pillars of a reliable application. This should not be overlooked;
    on the contrary, you must have security in mind all the time while developing
    an app.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: While most of the focus (if not all) is directed toward the user input, it would
    be much better if the data was validated no matter the source. This is especially
    needed when, on a project, there is a team involved and not one single person.
    This can lead to lots of unpredictable events, such as code changes that may look
    inoffensive, but could trigger unexpected behavior in your application's flow.
    Imagine a class method that has been designed and is used for some internal logic
    process, but then ends up being used for processing *external* data (from the
    database, user input, or elsewhere). While the class' self-data may have some
    degree of trust, at least when it comes to the data type (depending on the design),
    the external data is not to be trusted. In some cases, working on a product in
    a small team, it is tempting to ask the application administrators to insert data
    in a specific format here and there, leaving data validation and sanitization
    for *later*, while you eagerly try to deliver more and more features (perhaps
    to meet a deadline). Then, imagine your product turns out to be so successful
    that management decides to extend the business and offer it as a SaaS solution.
    In this case, the application administrators are no longer your small team, and
    all clients' data will be at risk if you don't deal with the input validation
    and sanitization. This time, it will be pretty difficult to solve all the issues
    in a timely manner – you will have to find these security holes across the whole
    application.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: In general, not taking care of data validation and sanitization will lead to
    a great technical debt in the future, as you will not only put your clients' data
    at risk, but application operations could return unpredictable results, which
    will require the developer to have to trace and debug the issues, which, again,
    takes time and money, while these bugs cause poor user experience.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Best Practices
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few coding practices that will make your PHP code less prone to
    bugs and security issues:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a single entry point for your web app: This is about a single PHP file
    that is responsible for taking every HTTP request and processing it. This file
    would bootstrap all the dependencies, load the configuration files, initialize
    the request handlers (such as `Dispatcher`, `HttpKernel`, and others — note that
    each framework uses its own name), and will then route the request to the proper
    PHP script for this to produce the response. In our examples, we have used several
    input files to provide some examples; this is not the way to go for real-world
    applications. Later, we will look at an example of a simple bootstrap for the
    examples run through in this topic, inside a single input file, keeping each example
    file on disk.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Separate the business logic from presentation logic: It is always better to
    keep responsibilities separate from each other. Modern frameworks bring their
    own templating engines to help developers keep most (if not all) of the business
    logic in PHP files, rather than in presentation files. This helps to focus on
    only one part; that is, either gathering and/or processing data or displaying
    data (that is, through visuals). Additionally, it is easier to read business logic
    if it is not scattered all over the presentation markup. We will cover this in
    more detail in the bootstrap example later.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sanitize and validate your input early and escape it late: Input data refers
    to data outside the application, be it user input, database data, filesystem file
    data, or other data. By sanitizing the data, you make sure you get the cleanest
    possible data for a given input, while by validating it, you make sure you allow
    the script to work with the accepted values or range of values. On the other hand,
    escaping the data for the output makes the application avoid some other issues
    such as **cross-site scripting** (**XSS**).'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll see how this can be done in PHP shortly.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use type hinting whenever possible: Using type hinting, you can be sure of
    the input and output type of a function, so this feature prevents code execution
    when the input or output data of a function is not the expected type. For example,
    if your function expects an iterable, but a string was passed, then the engine
    will throw a `TypeError` exception (which stops the script execution if it is
    not caught).'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's not all. By default, PHP will coerce the values of variables that do
    not match the expected type, when possible. This only applies to scalars. For
    example, if a function expects an integer but a numerical string is passed, then
    it will be converted to an integer. PHP features strict type checking as well,
    which I advise you to use in your application development. It can be added as
    per file use, and it's enough to add `declare(strict_types=1);` and only apply
    it to function calls from the file on which the strict types were enforced. This
    means that a function call from non-strict type checking to a function from a
    file with strong type checking enabled, the caller's preference of weak typing
    will be respected, and the values will be coerced. Using strict type checking
    makes your application even less prone to bugs, and that's simply because `'123abc'
    == 123`, which leads me to the next point.
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use strict comparison (`===`): PHP supports two types of comparisons: loose
    comparisons (`==`) and strict comparisons (`===`). In the case of loose comparisons,
    PHP tries to align both operands'' values to a common type, and then perform the
    comparison. That''s why `0 == FALSE` evaluates to `TRUE`. While this is considered
    a feature of PHP, praised for being friendly to starter developers, I strongly
    advise you to avoid such a construct from the beginning. On the other hand, a
    string comparison will not try to coerce the operands'' data, as it compares both
    values and types.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally speaking, you, as a developer looking at your code, should know what
    data you are dealing with in every line of your application.
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In other words, the more magic you allow to drive your app, the more your app
    will be prone to *magic* bugs!
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Split your code into smaller pieces: Try to avoid writing big long functions
    and instead try to split the code into pieces that you will be able to actually
    test. So, what granularity should you use to split your code? Well, just ask what
    you are trying to do with the data, then it will come down to functions with names
    such as `decorateComment`, `splitCollection`, `shouldTrim`, and others. If you
    end up with something such as `getCommentsByGroupingAndDecoratingLongOnes`, you''ll
    probably find that function does too many operations, which could be split into
    shorter, more manageable and testable functions.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avoid using the error suppression operator, `@`: This operator is pretty slow,
    as the PHP will turn off error reporting, and after the operation, it will restore
    the error reporting to the original value. Additionally, do not turn off error
    reporting at all, not even in production; instead, use a custom error handler
    and log the error in a preferred manner, so you can see whether something goes
    wrong during the code execution.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sanitizing and Validating the User Input
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As soon as the data arrives in a script, it should be sanitized, and it must
    always be validated. You want to make sure you don't receive harmful data and,
    therefore, you want to clean the user input, which means removing potentially
    malicious content from the provided input, or casting the data to a specific type
    such as an integer or Boolean. Additionally, you want to make sure the input data
    is a valid number, or an email address where expected, and so on.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: The built-in `filter_input()` function is used to process the data from the
    request and, if needed, will alter it to match the expected format.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `filter_input( int $type, string $variable_name, int $filter =
    FILTER_DEFAULT, mixed $options = null )`, so it takes as arguments the type of
    input to look into, the input parameter name to look for, the optional filter
    type, and any extra options if needed. What `FILTER_SANITIZE_*` filters do is
    remove data that is not expected for specific formats. For example, `FILTER_SANITIZE_NUMBER_INT`
    will remove everything except digits and plus and minus signs. A full list of
    sanitizing options can be found at [https://packt.live/31vww0M](https://packt.live/31vww0M).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.7: Sanitizing and Validating the User Input'
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following exercise, we will sanitize and validate the input data. Suppose
    that you have built an e-commerce web application and now you want to develop
    the feedback part. In the `POST` payload, you expect a message and a number of
    stars; that is, any number between one and five.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to perform the exercise:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'To sanitize the input, this is how you would use the `filter_input()` function,
    given that we look for the `stars` and `message` input fields:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Of course, you should then check the `filter_input` return values. As the manual
    states, `NULL` will be returned when the input does not exist, `FALSE` if the
    filter fails, and a scalar otherwise. Next, we would like to validate the sanitized
    input data:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can also consider the following approach:'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You will notice that, at some point, we have cast the `stars` input value to
    the `($stars = (int)$stars;)` integer. That's because, using `FILTER_SANITIZE_*`
    filter types, you will always get a string if the filter runs successfully. Additionally,
    you will notice that we have used the `filter_var` function, which, unlike `filter_input`,
    will accept a variable as the first argument and then the filter type and options.
    Of the two approaches I previously showed to validate an integer input, I prefer
    the first one, because it's less code and is likely to be faster than the second
    approach (anyway, unless you run a high-traffic web application, the performance
    difference between the two approaches is almost zero).
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Often, validating an integer input is done much more simply. Given the fact
    that the script may expect values higher than zero, or that when no value is specified
    zero would be the default value, the sanitization would look like this:'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$stars = (int)($_GET[''stars''] ?? 0); // using null coalescing operator`'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Validate the message input as well and print error messages if `$message` is
    `null` or `false` (that is, if the input was not found or the sanitization failed):'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For debugging purposes, we may want to print the sanitized variable''s values:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now we''re missing the HTML part; that is, the form. It will require the two
    inputs with the `stars` and `message` names. We may consider using an input of
    type `text` for `stars` in this case in order to be able to enter invalid data,
    so that we can validate our sanitization and validation logic, and another input
    of type `textarea` for `message`:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Put the content in the `input-sanitize.php` file and open it in the browser
    at `http://127.0.0.1:8080/input-sanitize.php`. The output looks like this:![Figure
    6.25: The output of input-sanitize.php when first accessed'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_06_25.jpg)'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.25: The output of input-sanitize.php when first accessed'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter `3a` for the `stars` rating, `Hello <script>alert(1)</script>` for the
    message, and then submit the form. You will get something like this as the output:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.26: A sample sanitization in the output of input-sanitize.php'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_06_26.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.26: A sample sanitization in the output of input-sanitize.php'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following table, we have listed a series of inputs and the result for
    each submission. So, here is a list of sanitized values the script will render
    for their relative inputs:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.27: A list of sanitized values for various input messages'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_06_27.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.27: A list of sanitized values for various input messages'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some more sanitization functions you should be aware of:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '`strip_tags()`: This strips the HTML tags from a string; for example, `strip_tags(''Hello
    <script>alert(1)</script>!'');` will remove the `<script>` opening and closing
    tags, resulting in the following output: `"Hello alert(1)!"`. This removes the
    HTML tags where they are not expected and removes potentially dangerous scripts
    from being stored in the application, which may be output further in the browser
    causing malicious actions.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trim()`: This strips whitespace characters by default, or other characters
    as specified, from the beginning and end of a string.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some functions that you may want to use to validate your data:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '`is_numeric()`: This tells us whether a variable is a number or a numeric string.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preg_match()`: This performs a regular expression match.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in_array()`: This checks whether the value exists in the list of values in
    the array that is given as an argument of the function.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Escaping the Output
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's talk about the data that is leaving the application. When sending
    data to a browser as HTML markup, you'll have to cover yet another security concern.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: This time, you want to escape the data. Escaping means transforming potentially
    harmful data into unharmful data. Since the browser will render the page by parsing
    the HTML your script provides, you need to make sure the output is not creating
    unwanted side effects, breaking the page layout, or worse, putting the user session
    and data at risk.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Scripting (XSS)
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common vulnerability on the web nowadays is **Cross-Site Scripting**
    (**XSS**). This vulnerability allows an attacker to inject arbitrary HTML tags
    and/or run arbitrary JavaScript code on the client side (in browsers).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of XSS attacks:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'Stored XSS: Here, the malicious code is stored on the server or on the client
    browser.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reflected XSS: Here, the malicious code is returned immediately from the user
    input.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DOM-based XSS: Here, the malicious code uses data stored in the DOM, to be
    sent to the attacker website.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although these are different types of XSS, they actually overlap. Often, they
    are referred to as Server XSS or Client XSS, pointing to the vulnerable side of
    a website.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'A common example of Reflected XSS is a search results page, where the user
    is shown the search input they submitted. A vulnerable script, in this case, should
    look like this:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Of course, accessing `/?s=hello` will result in `"Search terms: hello"`, which
    is what bad testing looks like. However, when `/?s=<script>alert(1)</script>`
    is tried, the output is `"Search terms: "` and a pop-up box displays the number
    1\. This is because the HTML will look like this:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: While this looks harmless, just think about the possibilities here. You can
    inject *any* HTML markup, including scripts, and be able to spy on user sessions,
    data, and actions, and even more – it is able to perform actions on the user's
    behalf.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, there are methods to prevent such attacks, and while data validation
    and sanitization may also be used as well in this matter, one of the most commonly
    used methods is output escaping. PHP provides some built-in functions that provide
    such functionality: `htmlspecialchars()` and `htmlentities()`. What both of these
    functions do is translate certain sensitive characters into their associated HTML
    entity values, with the addition that `htmlentities()` translates all the characters
    that have an HTML-named entity associated with them. I encourage you to use `htmlentities($string,
    ENT_QUOTES)` so that all characters will be translated into entities; additionally,
    `ENT_QUOTES` ensures that both double and single quotes are escaped.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the preceding example, the fix should look pretty simple:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now the browser will output `Search terms: <script>alert(1)</script>` since
    the HTML looks like this:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For convenience, I''ll print the list of special characters PHP will replace
    with `htmlspecialchars()`:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.28: Special characters and their replacements'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_06_28.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.28: Special characters and their replacements'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's consider the example of a Stored XSS sample. As the name suggests,
    the Stored XSS is a piece of malware stored either on the server or on the browser.
    I'll discuss the one stored on the server, but in the case of the browser, it's
    similar (it's just not done with PHP).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so how can an XSS piece of malware be stored on a server? Well, it''s
    easy: that can be done with every user input that the application stores (which
    is in a database, usually). Think of the comments for a blog post, the reviews
    for products, an avatar''s URL, a user''s website URL, and other examples. In
    these cases, to render safe HTML, the answer is the same; that is, use `htmlentities()`.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say there is a comment to a blog post in the database, with the following
    content:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this case, an attacker injects a script tag, which will execute a DOM write
    on the client side by adding a remote image (which is usually a pixel; you can't
    even spot it on the page). The remote image is hosted by the attacker's server,
    which, before serving the pixel image, will first collect all the data passed
    in the request query string – in this case, `document.cookie`. This means that
    the attacker will collect valid session IDs from all the visitors of the website;
    that is, anonymous visitors, logged-in users, and even admins.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: The preceding comment, if not escaped, will be rendered by the browser as `Great
    blog post!` without giving any hint that there might be some strange script executing.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'The escaped version will be rendered as the original content of the comment
    because now the HTML will contain entities instead of the special characters:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about XSS at [https://packt.live/2MRX3jJ](https://packt.live/2MRX3jJ).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.8: Securing against XSS'
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will build a script that is secured against user input.
    Let's say that you have to develop a search feature on an existing website. You
    are asked to print the searched value back to the page and to keep the current
    search term in the search input field. Of course, the script should be secured
    against user input.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `output-escape-reflected.php`, with the following content:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'First, we check whether we have the `s` entry in the `$_GET` variable and,
    if it''s there, we will print the escaped value to the browser using the `htmlentities()`
    function:'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Then, we print the search form, and in the search input field, we include the
    current searched term, escaping using the same `htmlentities()` function. Note
    that this time, we use `ENT_QUOTES` as the second argument, which will make the
    function escape both the single and double quotes; without this argument, only
    the double quotes are escaped. The reason we use this approach, even though the
    `value` attribute is assigned the value using double quotes, is that it allows
    the use of single quotes as well, so it's safer to escape both types of quotes.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access the file at `http://127.0.0.1:8080/output-escape-reflected.php`.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see something like this:'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.29: The page output without the search term'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_06_29.jpg)'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.29: The page output without the search term'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter `"Great blogpost!" <script>alert(''1'')</script>` as the search term
    and click on the `Search` button. You should see something like this:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.30: The escaped output for the search term'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_06_30.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.30: The escaped output for the search term'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding output, we have displayed the search term
    entered by the user and have also retained it in the search input field.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Request Forgery (CSRF)
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-Site Request Forgery** (**CSRF**) is an attack that enables the user
    to execute unwanted actions on a web application in which they''re currently authenticated.
    This attack could succeed in the transfer of funds, changing an account email
    address, or making a purchase in the name of the user.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: This can happen when the attacker knows exactly what data is expected on the
    affected application for a certain action – changing an email address, let's say.
    So, the attacker crafts the HTML form on their server, filling it with their preferred
    data (that is, their own email address). Next, the attacker chooses the victim
    and uses social engineering to trick them into accessing the URL.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: The victim will then land on a malicious website and the browser will be instructed
    to submit the (invisible) form to the affected application, where the user is
    logged in. The email will be changed and when the victim realizes this, it may
    already be too late, as control of the account will have been taken by the attacker.
    It is worth mentioning that the victim would not even realize what caused this
    email change operation on the affected application since the form on the attacker's
    website could be submitted inside a pixel iFrame. So, the victim would think that
    they had accessed some type of cool viral video blog, without realizing the danger
    lurking behind the scenes.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Social engineering, in the context of information security, is performing a
    confidence trick for the purpose of information gathering, fraud, or system access,
    and refers to the psychological manipulation of people into performing actions
    or divulging confidential information.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate CSRF in your application, we suggest that you generate and use CSRF
    tokens. These are pieces of randomly generated strings of a variable length. These
    tokens are not part of the data that comes along with the form (such as cookies),
    but they are a part of the same form data. The token sent via the HTTP form is
    then compared to the value stored in the session data and, if there is a perfect
    match, the request is allowed.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Usually, you can generate one token per session, but one token can be generated
    per session form as well.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: The CSRF token method works to help prevent CSRF attacks, because the attacker
    doesn't know what your session's CSRF token is, and all the malicious operations
    that have worked before the implementation of the CSRF token will now fail early,
    at token validation.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about CSRF at [https://packt.live/31aAFHb](https://packt.live/31aAFHb).
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.9: Securing against CSRF'
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will set up a CSRF token to use for user action validation.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `form-csrf.php` and insert the following content:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, the session should be started, then the script will look for the `csrf-token`
    entry in the session data and, if not found, one will be generated and stored
    in the session using two built-in functions. We will use `random_bytes()` to generate
    random bytes of a specified length, and `bin2hex()` to convert the binary data
    into hexadecimal representation; that is, a string containing digits ranging from
    0 to 9 and characters from `a` to `f`. The expression will generate a 64-character
    token:'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, the script should check whether the request type is `POST` or not and,
    if positive, it will proceed with token validation. Here is the code to do this:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'First, the CSRF token''s presence in the input data is checked: `array_key_exists(''csrf-token'',
    $_POST)`. The second check will compare the sent data with the data stored in
    the session data of the current user: `$_POST[''csrf-token''] === $_SESSION[''csrf-token'']`.
    If any of these two conditions fail, then appropriate error messages will be displayed.
    Otherwise, the success message will be printed.'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the end, the test form is printed. It should contain a dummy `email` input.
    We will add three submit buttons to the form. The first one will make the form
    submit only the email data. The second one will make the form send `"csrf-token"`
    with an empty value. Finally, the third one will make the form send `"csrf-token"`
    with the value stored in the *current* session. Here is the code to do this:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The final script can be referred at [https://packt.live/2B6Z7Pj](https://packt.live/2B6Z7Pj).
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the file at `http://127.0.0.1:8080/form-csrf.php`.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see something like this in your browser:'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.31: Accessing form-csrf.php for the first time'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14196_06_31.jpg)'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.31: Accessing form-csrf.php for the first time'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click on the "`Submit without CSRF Token`" button. The output will be as follows:![Figure
    6.32: The token is not found'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_06_32.jpg)'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.32: The token is not found'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click on the `Submit with empty/invalid CSRF Token` button. The output will
    be as follows:![Figure 6.33: The token is found, but is not valid'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_06_33.jpg)'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.33: The token is found, but is not valid'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click on the `Submit with CSRF Token` button. The output will be as follows:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.34: The token is found and is valid'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_06_34.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.34: The token is found and is valid'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding output, we have successfully generated and
    submitted a CSRF token, thereby protecting the application and user data against
    CSRF attacks.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Building an Application (Bootstrapping the Examples)
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed previously, it is good practice to separate business logic from
    the presentation layer and other components of an application, to ease the development
    and maintenance of the application, and to make the application less prone to
    security issues.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: This chapter offers a very simple structure of an application, as a sample,
    just to demonstrate how you can achieve one entry point for your application,
    route requests and perform appropriate business logic, and also print a complete
    HTML page.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be building an application using the best development practices in
    the upcoming exercise. However, before we do so, let''s review the basic directory
    structure that we will be using while building our web page. In the project root,
    there are two directories: `src/` and `web/`.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: web/
  id: totrans-492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the server document root containing the single entry point file for
    HTTP requests: `index.php`. Every file in this directory can be accessed through
    the server (unless a specific server configuration is used to prevent access to
    some locations inside this directory).'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: The server will start in this directory and not in the parent directory (`/app`).
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: This approach is used to prevent random script files from accessing the WWW,
    which may lead to various consequences (such as data security and service availability),
    and to ease the maintenance of the application by reducing the entry points to
    a single one.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '`index.php`: This file is responsible for accepting all HTTP requests and producing
    and returning HTTP responses; it includes all the necessary script files of the
    application and runs specific tasks to achieve its purpose (for example, returning
    the HTTP response).'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: src/
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the directory that contains the business logic and presentation files
    of the application; the script files are grouped by operation types (such as presentation,
    handlers, and higher-level components). This directory is not exposed to WWW;
    however, the scripts will run for each request, since they are included in `web/index.php`,
    which means that they are indirectly exposed to user input. Therefore, any type
    of input validation is a must.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 'The `src/` directory contains three subfolders: `components/`, `handlers/`,
    and `templates/`. The details of these are as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: components/
  id: totrans-501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Router.php`: The `Router` component is responsible for picking a handler (that
    is, a class name) to instantiate and returning it. Essentially, it will match
    a URI path to a handler class (for example, `/login` will result in returning
    the `\Handlers\Login` instance).'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '`Template.php`: The `Template` component is responsible for loading and rendering
    a template from the `templates` directory and returning the HTML content.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: handlers/
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This directory contains the scripts with classes that will process the HTTP
    request and will generate response data. This directory has an abstract `Handler`
    class that implements some common functionality, which will be extended by actual
    handlers. The previously listed handlers are meant to cover the authentication
    (`Login.php`), secure the profile page, log out of any session (`Logout.php`),
    and protect the profile page display (`Profile.php`).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: templates/
  id: totrans-506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `templates` directory, as the name suggests, holds the template files (or
    presentation files). These files contain mostly HTML and have little to no PHP
    logic.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: 'When building an application, we need to ensure that there is a single point
    of entry, as shown in the following figure:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.35: Exposing the web directory and accessing the scripts indirectly
    with HTTP requests'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_06_35.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.35: Exposing the web directory and accessing the scripts indirectly
    with HTTP requests'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: This entry point is the only one that is exposed to the user's request. User
    requests are imported into web directory scripts so that no scripts can be directly
    accessed via the HTTP requests. This provides a security measure against malicious
    requests.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding sections, we have described several best practices for building
    web applications. Let's put these into action to build an application in the following
    exercise.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.10: Building an Application: The Home Page'
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will build an application that follows good development
    practices in PHP, by structuring the application into separate components that
    will deal with specific tasks. More specifically, we will build a website with
    a single page – that is, the home page, where we will use HTML to structure and
    render the contents on the browser page; CSS to "beautify" the page contents;
    and, of course, PHP to process all the incoming requests and send the appropriate
    responses to the browser.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: 'Please ensure the currently running server is stopped and create a new directory,
    which will be used to build your first application. Everything that follows will
    consider the working directory as the one that was just created. In my case, I''ll
    use the `/app` directory as the working directory, which you will notice later
    in the example. Here are the steps to perform the exercise:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following directory structure and files:![Figure 6.36: The directory
    structure of the application'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_06_36.jpg)'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.36: The directory structure of the application'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Where do we start?**'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Just as is the case when using any tool or framework, let's start with the minimum
    requirements so that we can incrementally add more after that. Since we are deploying
    a web application, let's set up the base view; that is, the template that repeats
    on every page.
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a `main.php` template file.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this file, we want to include the valid HTML template for a web page; therefore,
    we will include essential elements such as the `doctype` declaration; the HTML
    `root` tag; a `head` block with specific tags (for example, `title`), and a body
    block, in which we add a horizontal navigation bar with the website title (`Learning
    PHP`) and two links, `Home` (the `/` path) and `Profile` (the `/profile` path);
    and the main container where the output of other pages will be rendered. In this
    template file, we will look for the `$title` (`echo($title ?? '(no title)');`)
    and `$content` PHP variables and, if found, we will render them (`if (isset($content))
    echo $content;`). This template will include the CSS styles of the Bootstrap CSS
    framework, which makes the website look prettier without any effort. We have chosen
    Bootstrap v4 for page display stylization, but there are plenty of alternatives
    that you should check out and choose the one that you think best suits you. Alternatives
    such as Foundation, Jeet, Pure, and Skeleton do a similar job to Bootstrap. Often,
    lightweight libraries are preferred over the heaps of utilities of larger frameworks
    such as Bootstrap.
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Input the following code to include the previously mentioned information:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `main.php` template has the website HTML skeleton that will be rendered
    on every page.
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, to render this file accordingly, we need a component that will load the
    template file, create the expected variables (when provided), and then create
    the plain HTML input ready to display on the browser. We will use the `\Components\Template`
    class (that is, the `src/components/Template.php` file) for this purpose. A common
    feature for each template is the directory where they are stored, so we may want
    to save this parameter in a static variable.
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Save the directory in which the templates are stored in a static `$viewsPath`
    variable:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The complete path for a template file is unique to each template. Hence, we
    would like each template to contain its own required `path` property. Here is
    the code to do this:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since all the presentation files contain the `.php` extension, we will not include
    it in the name path; in this case, a `\Components\Template` with the name `main`
    will automatically append "`.php`" to the template name and will resolve the `src/templates/main.php`
    file.
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Render the template content using the provided associative array data.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have the views path and the template name, and now we need a method (let''s
    call it `render()`) to render the file, importing the variables. We will use the
    built-in `extract()` function to import the variables into the current symbol
    table from the data array (`extract($data, EXTR_OVERWRITE);`). This means that
    if `$data = [''name'' => ''John''];`, the `extract()` function will import the
    `$name` variable that will have the value `John`. Then, we include the template
    file to render the content and, since we don''t want to output to the user just
    yet (we only want to render the template), we will catch the output using the
    `ob_start()` and `ob_get_clean()` output control functions to start the output
    buffering, get the contents, and clean the current buffer. The rendered content
    is then returned by the method:'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The final script in `Template.php` can be referred here [https://packt.live/35D34t9](https://packt.live/35D34t9).
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s see whether we can get an output in the browser now. Since `index.php`
    is the only file that is accessed through the web server, let''s open and add
    the requirements to print the first HTML page. First, we want to include the templates
    component and instantiate the `main` template:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We will put a website title in the `$templateData` associative array, and we
    will use this to invoke the `render()` method of the template instance, so that
    the `title` entry in the associative array will become the `$title` variable in
    the `main.php` file:'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Start the PHP built-in web server in the `./web` directory, `php -S 127.0.0.1`,
    and access the home page at `http://127.0.0.1:8080/`.
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output should look like this:'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.37: The home page'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_06_37.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.37: The home page'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the server document root without a specific filename will make the
    PHP built-in server automatically look for the `index.php` file (so accessing
    `http://127.0.0.1:8080/` is identical to `http://127.0.0.1:8080/index.php`). A
    similar configuration is done on production setups for different servers, such
    as NGINX and Apache. At this stage, clicking on any link will always make the
    main template be displayed.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: The `/app` directory that can be seen in the preceding figure is the directory
    where I put the `src` and `web` directories.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: Right now, clicking on the `Profile` button (that is, the `/profile` URI path)
    will make the same template render. Actually, any URI path would make the same
    `main` template render. Now, we may want to add some logic and print a different
    template for our Profile page. To do this, we should provide `content` data in
    the associative array we pass to the `\Components\Template::render()` method.
    As a recap, the `\Components\Template::render()` method will import the `content`
    array key and will make it available as a `$content` variable, which will be rendered
    in the `main` template (remember the `if (isset($content)) { echo $content; }`
    part in the `main` template).
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: It makes sense to return specific template content for each URI path (by checking
    the `$_SERVER['PATH_INFO']` value) and, since the pages returned often include
    dynamic or changing content, we need a *place* to process all the data we provide
    to the `\Components\Template::render()` method. For this purpose, we will use
    the request handlers; that is, the classes stored in the files of the `src/handlers/`
    directory. To recap, for each request, the script has to assign a handler class
    for a URI path, while the handler class is responsible for processing the request
    and returning content to the `main` template (you can do this by using the `Template`
    component or by just returning the string right away).
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: In the previous exercise, we built the home page of our application. Now we
    will continue building our application in the next exercise.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.11: Building an Application: The Profile Page and the Login Form'
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will set up the handler's common functionality and create
    the abstract class, `\Handlers\Handler`, which will be extended by actual handlers.
    We declare it as abstract since we don't want it to be instantiated, but rather
    extended instead. Its purpose is to define some common functionality, such as
    returning the page title or setting a redirect request for an HTTP response, but
    also to require each handler class to implement the method responsible for request
    handling – we will simply call it `handle()`.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the `src/handlers/Handler.php` file content, which should look like this:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To access the Profile page, we need an authenticated user; therefore, let''s
    build the login form and authentication logic. Add the following code to the `Login`
    handler:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: What the `\Handlers\Login` handler does is implement the `handle()` method,
    which is a requirement since it extends the `Handlers\Handler` abstract class.
    In the `handle()` method, we return the rendered "l`ogin-form`" template.
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The "`login-form`" template, as the name suggests, will contain the HTML markup
    for the login form. What we want here is a form title, such as "`Authentication`",
    the "`username`" and "`password`" inputs and their labels, and the submit button.
    Since the credentials are not meant to appear in the address bar of the browser,
    the form method we choose is `POST`. If the form is submitted but data validation
    fails for some reason, the previously entered username will be displayed automatically
    in the `username` field `(<?= htmlentities($formUsername ?? '') ?>`). Additionally,
    when the authentication fails, the reason will be rendered under the specific
    field, inside a `div` element with the `invalid-feedback` CSS class.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s save the `login-form` template to the `src/templates/login-form.php`
    file:'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice that we use `htmlentities()` to escape the output from variables containing
    random, dynamic data, such as user input.
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We have the `Login` handler and the `login-form` template already. What we
    need now is to run that handler for the `/login` path. Since we will have to add
    more rules like this (for example, running the `Profile` handler for the `/profile`
    path), it makes sense to group this functionality into a specific component. We
    will use the `\Components\Router` component for this purpose. What this `Router`
    component will do exactly is route the incoming requests to specific handlers
    based in the URI path (the `$_SERVER[''PATH_INFO'']` value). This can be simply
    achieved by using a `switch` statement. All this logic will be put in the only
    class method called `getHandler()`:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now we can use the router instance in the `index.php` file (the application
    entry point) to get a request handler or `null` for the current request. When
    a non-null value is returned, we can process the request with the `Handlers\Handler::handle()`
    method, check for the redirect request, get the page title, and set the appropriate
    data (that is, content and title) for the `main` template:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, when someone enters a URI with a path that is not listed in the `switch`
    statement of the `\Components\Router::getHandler()` method (usually because of
    a typo), it will make the method return `null`, which will cause the `main` template
    to render with the default content (the `Hello world` block). We should not allow
    such behavior, since our website pages are indexed by search engines and are marked
    as duplicated content. We may want to display a `404 - Not found` error page,
    or redirect to an existing page, such as the home page. We will choose to redirect
    to the home page using the `/` path:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'While `web/index.php` will become the following:'
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let''s take a look at what we have so far. Access the `http://127.0.0.1:8080/login`
    URL in your browser; the output should look like this:![Figure 6.38: Login page'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_06_38.jpg)'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.38: Login page'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we have a nice-looking login form, but so far without any functionality.
    Let's add some in the `\Handlers\Login` handler class.
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, we need to store a username and a password, and since we will learn
    about data persistence in the next chapter, let''s define these values directly
    in the PHP script:'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Note that we do not store the password in plain text for security reasons,
    and no one should ever do so. Additionally, a good approach is to avoid adding
    password hashes to `password_hash()`, which requires the password string as the
    first parameter and the hashing algorithm as the integer for the second parameter.
    The salt is generated automatically by the `password_hash()` function and is used
    to obtain the password hash using the `bcrypt` algorithm. Instantly obtaining
    a password hash with PHP is as simple as running a short inline code in Terminal:
    `php -r "echo password_hash(''admin'', PASSWORD_BCRYPT), PHP_EOL;"`.'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the case of the `POST` request, we have to validate the login attempt; therefore,
    we should perform username and password matching. The errors, if there is a username
    or password mismatch, will be added to the `$formError` associative array under
    the `username` key (in the case of a username mismatch), and under the `password`
    key (in the case of password mismatch). To verify password matching, we will use
    the `password_verify()` built-in function, which requires the plain text password
    as the first argument, and the password hash as the second argument; it returns
    `TRUE` if there is a match, and `FALSE` otherwise:'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The form errors and the form-submitted username will be sent to the template
    in the `render()` method:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If the username and password matches, then add the username and login time
    in the session data, and then perform a redirect to the Profile page:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to use the `$_SESSION` superglobal, the session must be started first,
    so we have to do it somewhere on a higher level, since we may need to use the
    session data in other places of the application, not only in the `Login` handler.
    We will add `session_start();` in the `web/index.php` file, after the `require_once`
    statements list.
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We may also check, at the very beginning of the `\Handlers\Login::handle()`
    method, whether the session username is already set (that is, whether an authentication
    was already performed) to prevent the login form displaying another login attempt
    taking place, and, if so, perform a redirect to the home page:'
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, we have completed the `Login` handler logic, and the content
    can be referred at [https://packt.live/2OJ9KzA](https://packt.live/2OJ9KzA).
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We now have the login form and authentication functionality in place; let''s
    proceed by adding the protected Profile page. Since only the authenticated users
    are allowed to access this page, we will check for the `username` entry in the
    session data. When no user is authenticated, we will display the Login form (to
    perform this in the `\Handlers\Profile` handler):'
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In other words, the `/login` page will be rendered in the `/profile` page when
    the user is not authenticated.
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Checking for the "`username`" entry in the session data, in this example, is
    our way of telling whether a user is logged in or not, which is not as secure
    and useful as it could be. Nowadays, using an open source solution to handle authentication
    is a much better alternative, since the session login data contains more information,
    such as login method, time, hashing algorithm, token, lifetime, and other potentially
    useful data that is used to validate the authentication.
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Otherwise, if we have an authenticated user, we will render and return the
    `profile` template, providing the username and session data to the template''s
    `render()` method:'
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Additionally, let''s add the Profile page title by extending the `getTitle()`
    method from the parent class. The new title will include the word Profile prepended
    to the default title, which is provided by the parent class:'
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Save the `src/handlers/Profile.php` file; the full content should be as follows:'
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `profile` template will only display the username and the session data
    that were provided as variables, plus the `/logout` value for the `href` attribute:'
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `Logout` handler will regenerate the session ID and will destroy the current
    session''s data. Additionally, a redirect on the website home page will be requested:'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We need to add the `Profile` and `Logout` handlers in the `Router` component:'
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Additionally, the `src/handlers/Logout.php` and `src/handlers/Profile.php`
    files should be required in `web/index.php`:'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Note
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using a tool such as `composer` for the autoload feature, or any other implementation
    of "`PSR-4: Autoloader`", would make it much easier to deal with loading code.
    Using `composer` will be covered in *Chapter 9*, *Composer*.'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Everything seems to be done; let''s take a look at how the website works. Click
    on the `Profile` link from the header. The output should look like this:![Figure
    6.39: The Profile page, displaying the login form for unauthenticated users'
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14196_06_39.jpg)'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 6.39: The Profile page, displaying the login form for unauthenticated
    users'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Enter `admin` for both the username and password and click on the `Login` button.
    You should now be able to access the Profile page:![](img/C14196_06_40.jpg)
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 6.40: The Profile page, displaying the login information for the authenticated
    user'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on `Home`, then back on `Profile`, and refresh the page. You will notice
    that the session is not lost between requests.
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the `Logout` link from the Profile page. You should be redirected to
    the Home page. Accessing the Profile page again will result in the Login form
    display, as shown in *Figure 6.39*.
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations! You have just built your first website, and that's just the
    beginning. In this exercise, you have split the code according to its purpose,
    you have used security measures such as input validation and output escaping,
    and you have made the application respond appropriately to any HTTP request.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.1: Creating a Support Contact Form'
  id: totrans-621
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You are asked to implement a **Support Contact Form** on a new brand website.
    The form will be available for authenticated users only, on the Profile page,
    and the authentication part is in your charge as well. There will be two types
    of users: standard and VIP level. The standard users will be able to ask for support
    once per day, while the VIP users will have no limit. The form will contain the
    following fields: the name and the email where the replies should be sent to and
    the message. The form data should be sanitized and validated before it is registered.
    The rules are as follows: all required fields should be filled, use a valid email
    address, and the message should not be shorter than 40 characters.'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic page layout should look like this:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.41: The expected page layout'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14196_06_41.jpg)'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.41: The expected page layout'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: Given this data, let's proceed. Since the functionality and some of the layout
    are very similar to the previous exercise, let's use that code as a starting point
    while adjusting and adding to it according to our specifications. You can copy
    the code from the previous exercise to another directory to keep a copy of the
    exercise solution and continue the work in the current directory, where the built-in
    server is already started. For the record, my current working directory is `/app`.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: Before we start, make sure to log out of your current session by accessing the
    `http://127.0.0.1:8080/logout` URL in your browser.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to perform the activity:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: Write the code to fetch the user data for the username that is logged in.
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `\Handlers\Login::handle()` method to validate the user credentials.
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a login form. You can use the code from the previous exercise; however,
    make sure you delete the hint for the credentials (such as the username and password
    for admin).
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the profile page. Here, you should build the `src/templates/profile.php`
    file from scratch. First, add the greetings and a logout button.
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a support area and divide it into two equal horizontal parts.
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a support contact form with the following specifications: two inputs
    of type `text`, for name and email, and a text area input for the message. Each
    of these will have an associated `<label>` element and, if there are errors, these
    will have to be printed under the input with erroneous data.'
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can refer to the Bootstrap framework documentation and use the `alerts`
    component.
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write the code to prevent a standard-level user from sending more than one form
    a day. Again, you can use the `alerts` components from the Bootstrap framework.
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Secure the form by generating and using a CSRF token.
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the submit button, we may want to add more form data, so we can know for
    sure what form we have to process in the PHP scripts; this is very useful when
    many forms are added on a single HTML page, and each is sending data to the same
    URL.
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the code to display the message list history. You may choose the `card`
    component and print all of the message details. Each stored history entry will
    contain the form data (that is, the `form` key) and the time when the form was
    sent (that is, the `timeAdded` key).
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the code to validate the submitted form, and then write the code to refresh
    the page if the validation is successful.
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Input the code to send the following data to the template: the username (the
    greeting), the form errors if any, the form CSRF token, and the `sent` forms history.'
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the form validation logic in a separate method.
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for multiple submissions in the case of standard-level users.
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the code to display an error message if the user attempts to submit an
    empty name field.
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement email validation using the `filter_var()` function with `FILTER_VALIDATE_EMAIL
    validation`.
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the message field, write the code to ensure that the message is least 40
    characters long.
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collect the sanitized form data and store it in the `$form` variable, which
    is then returned with the `$errors` variable.
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can test our full implementation. You can begin by accessing the Profile
    page at `http://127.0.0.1:8080/profile` and continue testing for all fields across
    all pages.
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-652
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 520.
  id: totrans-653
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  id: totrans-654
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about an essential component of a web application
    – the Request-Response cycle of an application. You parsed the most commonly used
    HTTP methods and you are now able to tell the difference between them. You learned
    about best practices in terms of data security, code organization, and recommended
    approaches. You can perform data sanitization and validation as well, and you
    know how to upload files on a server, authenticate a user, and use a session,
    among other things. And, of course, you learned how to bootstrap all the examples
    into a practical piece – a web application.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: We are not done just yet. Data persistence was mentioned several times during
    this chapter and not in vain. Data persistence is used by every application and
    represents the essence of why applications exist – to collect, process, and store
    data. Although we have stored data in this chapter's exercises as well (for example,
    in sessions or cookies), in the next chapter, we will discuss data for the medium
    or long term; that is, data stored in files and databases.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
