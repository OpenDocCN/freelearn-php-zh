<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Exploring the World of Relationships"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Exploring the World of Relationships</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em>United (and related) we stand, divided we fall.</em></span>
</p></blockquote></div><p>In a real-world context, everything is connected; for example, a car has an owner, a book has an author (or maybe more than one), or an e-commerce order is related to one or more products that a customer (another relation!) has ordered.</p><p>Everything, actually, is related!</p><p>There are no differences in the application development world; usually, you create software to solve a real-world problem. The real world is made from related things, so you will probably have to define many relationships between your entities.</p><p>However, let's be clear: I am not saying anything new. Just go to Wikipedia and search for <code class="literal">entity-relationship model</code>.</p><p>Usually, in your school books, you can find three fundamental types of relationships:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>One-to-one</strong></span>: This is <a id="id127" class="indexterm"/>used to<a id="id128" class="indexterm"/> relate a single entity with another single entity (for example, a person and an identity document)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>One-to-many</strong></span>: This<a id="id129" class="indexterm"/> is used to define a connection <a id="id130" class="indexterm"/>between an entity with more entities of the same type (for example, all the books of the same author)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Many-to-many</strong></span>: This is<a id="id131" class="indexterm"/> used to relate multiple entities <a id="id132" class="indexterm"/>with many other entities (for example, a book can be a part of more than one category, and one category can include more than one book)</li></ul></div><p>Of course, web development makes no exceptions. Eloquent makes no exceptions.</p><p>Following the <span class="emphasis"><em>convention</em></span> used in what you have seen until now, Eloquent has a great way to deal with relationships, the methods used to define them for your models, and the techniques you can adopt to work with them.</p><p>So, let's explore what we are going to do in this chapter.</p><p>First of all, we will deal with the basic relationship types we just saw. How does Eloquent handle them? You will discover the beauty of powerful methods such as <code class="literal">hasMany</code> or <code class="literal">belongsTo</code>. This time, there are no more snippets; we will follow the creation of our library management tool classes, defining every entity and every relationship.</p><p>After the basics, you will discover how to work with these relationships: how to query and use them in a comfortable and clean way. Also, we will see how to insert and delete related models in your database, or update the existing models.</p><p>Sometimes, working with many-to-many relationships will mean storing some data specific to that relationship. Eloquent has a very useful property named <span class="strong"><strong>pivot</strong></span> that you can use to query the desired pivot table.</p><p>So, many things to look at this time! However, it is not over yet! Eloquent offers two other <span class="emphasis"><em>relationships</em></span> that you can use: the <span class="emphasis"><em>has many through</em></span> and <span class="emphasis"><em>polymorphic many to many</em></span> relationships.</p><p>Alright, enough chit-chat! I am not going to spoil anything now. Follow the chapter, and you will fall in love with it.</p><p>Obviously, I will show you a real-world example for every concept. Come on, hero!</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The trinity: one to one, one to many, and many to many</li><li class="listitem" style="list-style-type: disc">Querying-related models</li><li class="listitem" style="list-style-type: disc">Eager loading (and the N + 1 problem)</li><li class="listitem" style="list-style-type: disc">Inserting and updating related models</li><li class="listitem" style="list-style-type: disc">Accessing <span class="emphasis"><em>distant</em></span> relationships</li><li class="listitem" style="list-style-type: disc">More power! Polymorphic relationships</li></ul></div><div class="section" title="The trinity – one to one, one to many, many to many"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>The trinity – one to one, one to many, many to many</h1></div></div></div><p>As I mentioned earlier, we will start from the basics. So, the first thing we will see is how you can define relationships between entities in Eloquent. This is really simple, and usually you will just have to add a single line of code for every relationship.</p><div class="section" title="One to one"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>One to one</h2></div></div></div><p>Our library is very<a id="id133" class="indexterm"/> concerned about tracking people who borrow books. For this reason, every new user has to give to the library some identity document data.</p><p>Now, every user has a single identity document, and every document is absolutely unique. If you think about it, this is a perfect one-to-one relationship. When you build your database, the most followed rule tells you that you have to add the necessary columns in the <span class="emphasis"><em>first</em></span> table. In this specific example, we would add columns to the user table.</p><p>However, someone could say "yes, but this is a completely different entity!"</p><p>Also, we could have to store many details about the identity document of every user: number, type, due date, city, and so on.</p><p>In this case, you would add four or five columns to an existing table. Many people don't like this solution, so imagine that you have the <code class="literal">User</code> and <code class="literal">IdentityDocument</code> models.</p><p>Here's our default <code class="literal">User</code> model:</p><div class="informalexample"><pre class="programlisting">  &lt;?php namespace App;

  use Illuminate\Auth\Authenticatable;
  use Illuminate\Database\Eloquent\Model;
  use Illuminate\Auth\Passwords\CanResetPassword;
  use Illuminate\Contracts\Auth\Authenticatable as AuthenticatableContract;
  use Illuminate\Contracts\Auth\CanResetPassword as CanResetPasswordContract;

  class User extends Model implements AuthenticatableContract, CanResetPasswordContract {

    use Authenticatable, CanResetPassword;

    /**
     * The database table used by the model.
     *
     * @var string
     */
    protected $table = 'users';

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = ['name', 'email', 'password'];

    /**
     * The attributes excluded from the model's JSON form.
     *
     * @var array
     */
    protected $hidden = ['password', 'remember_token'];

  }</pre></div><p>The following is our <code class="literal">IdentityDocument</code> model:</p><div class="informalexample"><pre class="programlisting">  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class IdentityDocument extends Model {

    //

  }</pre></div><p>Now, let's see how<a id="id134" class="indexterm"/> to define the connection between them. For one-to-one relationships, the methods used are <code class="literal">hasOne()</code> and <code class="literal">belongsTo()</code>. The <code class="literal">hasOne()</code> method is used in the following way:</p><div class="informalexample"><pre class="programlisting">  $this-&gt;hasOne('App\IdentityDocument');</pre></div><p>Also, the <code class="literal">belongsTo()</code> method is used as follows:</p><div class="informalexample"><pre class="programlisting">  $this-&gt;belongsTo('App\User');</pre></div><p>The syntax makes sense, right? A user has a document, and a document belongs to a certain user! I know what you are thinking: you can't just place this method call wherever you want in the class.</p><p>In fact, you must define a method that returns that method call like this:</p><div class="informalexample"><pre class="programlisting">  public function identityDocument()
  {
    return $this-&gt;hasOne('App\IdentityDocument');
  }</pre></div><p>Similarly, <code class="literal">belongsTo()</code> must be defined as follows:</p><div class="informalexample"><pre class="programlisting">  public function user()
  {
    return $this-&gt;belongsTo(' App\User');
  }</pre></div><p>So, the final<a id="id135" class="indexterm"/> model's code will be like this:</p><div class="informalexample"><pre class="programlisting">  &lt;?php namespace App;

  use Illuminate\Auth\Authenticatable;
  use Illuminate\Database\Eloquent\Model;
  use Illuminate\Auth\Passwords\CanResetPassword;
  use Illuminate\Contracts\Auth\Authenticatable as AuthenticatableContract;
  use Illuminate\Contracts\Auth\CanResetPassword as CanResetPasswordContract;

  class User extends Model implements AuthenticatableContract, CanResetPasswordContract {

    use Authenticatable, CanResetPassword;

    /**
     * The database table used by the model.
     *
     * @var string
     */
    protected $table = 'users';

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = ['name', 'email', 'password'];

    /**
     * The attributes excluded from the model's JSON form.
     *
     * @var array
     */
    protected $hidden = ['password', 'remember_token'];

    public function identityDocument()
    {
      return $this-&gt;hasOne(' App\IdentityDocument');
    }

  }</pre></div><p>The code for the <code class="literal">User</code> class will be:</p><div class="informalexample"><pre class="programlisting">  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class IdentityDocument extends Model {

    public function user()
    {
      return $this-&gt;belongsTo(' App\User');
    }

  }</pre></div><p>Et voilà!</p><div class="section" title="What exactly happened?"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec06"/>What exactly happened?</h3></div></div></div><p>At a <a id="id136" class="indexterm"/>database level, we created an <code class="literal">identitydocuments</code> table with some data columns and a <code class="literal">user_id</code> external key. This external key is important because it is used automatically by Eloquent to resolve the relationship.</p><p>If you want, you can specify a different foreign key as a second parameter in both methods:</p><div class="informalexample"><pre class="programlisting">  $this-&gt;hasOne('App\IdentityDocument', 'another_user_external_id');</pre></div><p>Otherwise, you can use this:</p><div class="informalexample"><pre class="programlisting">  $this-&gt;belongsTo(' App\User', 'another_user_external_id');</pre></div><p>The field we specify is the same. Of course, the <code class="literal">hasOne</code> method (the <code class="literal">User</code> model) will see it as an external key, and the <code class="literal">belongsTo</code> method (the <code class="literal">IdentityDocument</code> model) will see it as a local one.</p><p>There's also a third parameter that you can use in both methods. In <code class="literal">hasOne()</code>, it is used to specify the local key (the default is the <code class="literal">id</code> field). In the <code class="literal">belongsTo()</code> method, it is used to define the parent key on the parent table (again, the default is the <code class="literal">id</code> field).</p><p>Let's take another example with the same models. Imagine that we have our <code class="literal">IdentityDocuments</code> table with a primary key named <code class="literal">documentidentifier</code>. Also, we need to follow a certain standard, and we can't use <code class="literal">user_id</code> as the external foreign key name. We must use <code class="literal">documentowner_id</code>.</p><p>No problem. First, you will define your <code class="literal">hasOne</code> like this:</p><div class="informalexample"><pre class="programlisting">    $this-&gt;hasOne('App\IdentityDocument', 'owner_id');</pre></div><p>We don't need to define the third argument, as our <code class="literal">users</code> primary key is <code class="literal">id</code>.</p><p>Then, you define <code class="literal">belongsTo</code>:</p><div class="informalexample"><pre class="programlisting">    $this-&gt;belongsTo('App\IdentityDocument', 'documentidentifier', 'owner_id');</pre></div><p>Now you're done! Note <a id="id137" class="indexterm"/>that this concept is applied in the same way for other relationship methods that we will see.</p></div></div><div class="section" title="One to many"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/>One to many</h2></div></div></div><p>This<a id="id138" class="indexterm"/> time it's easier than before: every book has an author, right? Sometimes, a book may have more than one author, but let's assume a basic case. The second relationship type we will analyze here is one to many. Every author can have more than one book. Let's consider the involved models: <code class="literal">Author</code> and <code class="literal">Book</code>.</p><p>Here's the <code class="literal">Author</code> class:</p><div class="informalexample"><pre class="programlisting">  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Author extends Model {

    //

  }</pre></div><p>The <code class="literal">Book</code> class is as follows:</p><div class="informalexample"><pre class="programlisting">  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Book extends Model {

    //

  }</pre></div><p>These are nothing more than simple Eloquent models. Now, in order to define a one-to-many relationship, we must use the <code class="literal">hasMany()</code> method.</p><p>So, the <code class="literal">Author</code> class will look like this:</p><div class="informalexample"><pre class="programlisting">  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Author extends Model {

    public function books()
    {
      return $this-&gt;hasMany('App\Book');
    }

  }</pre></div><p>You can<a id="id139" class="indexterm"/> then use the <code class="literal">belongsTo()</code> method, as before, to define the <code class="literal">inverse</code> of this relationship:</p><div class="informalexample"><pre class="programlisting">  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Book extends Model {

    public function author()
    {
      return $this-&gt;belongsTo('App\Author');
    }

  }</pre></div><p>So, we are done! We used <code class="literal">belongsTo()</code> again as the concept of <span class="emphasis"><em>belonging</em></span> is exactly the same; no differences.</p><p>At a database structure level, I just added an external <code class="literal">author_id</code> key in the <code class="literal">books</code> table.</p><p>So yeah, finished! I mention it in a note before, but I will repeat: remember that you can change your foreign key just by specifying it as a second parameter in the <code class="literal">hasMany()</code> and <code class="literal">belongsTo()</code> methods.</p></div><div class="section" title="Many to many"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Many to many</h2></div></div></div><p>Let's<a id="id140" class="indexterm"/> imagine a good example for many-to-many relationships. Well, the books/categories relationship is perfect. In fact, imagine <span class="emphasis"><em>Twenty Thousand Leagues Under the Sea</em></span>, <span class="emphasis"><em>Jules Verne</em></span>.</p><p>It is not only an adventure novel but also a classic. So, you will need to classify it under two separate categories: <span class="emphasis"><em>Classics</em></span> and <span class="emphasis"><em>Adventure</em></span>. Our library could also contain <span class="emphasis"><em>Journey to the Center of the Earth</em></span>, another classic, but also an other adventure novel. Same thing!</p><p>As you can see, this time a many-to-many relationship is absolutely necessary. Let's discover how Eloquent handles many-to-many relationships and how you can define them on models.</p><p>Here's the code for our <code class="literal">Book</code> model:</p><div class="informalexample"><pre class="programlisting">  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Book extends Model {

    public function author()
    {
      return $this-&gt;belongsTo('App\Author');
    }

  }</pre></div><p>The code for<a id="id141" class="indexterm"/> <code class="literal">Category</code> model is:</p><div class="informalexample"><pre class="programlisting">  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Category extends Model {

    //

  }</pre></div><p>This time, we don't have any <span class="emphasis"><em>directions</em></span> or a possible <span class="emphasis"><em>inverse</em></span> of a relationship.</p><p>Specifically, there are many books for many categories. So, the only method you need to use in this case is <code class="literal">belongsToMany()</code>. Use the method like this:</p><div class="informalexample"><pre class="programlisting">  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Book extends Model {

    public function author()
    {
      return $this-&gt;belongsTo('App\Author');
    }

    public function categories()
    {
      return $this-&gt;belongsToMany('App\Category');
    }

  }</pre></div><p>The other method is used as follows:</p><div class="informalexample"><pre class="programlisting">  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Category extends Model {

    public function books()
    {
      return $this-&gt;belongsToMany('App\Book');
    }

  }</pre></div><p>Nothing else!</p><p>Let's see what <a id="id142" class="indexterm"/>we need at a database level to handle this relation. As you can easily imagine, you will have to work with a pivot table in this case.</p><p>So, you will need to specify an appropriate extra table in your migration file, using the <code class="literal">up()</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">  Schema::create('book_category', function(Blueprint $table)
  {
    $this-&gt;increments('id');

    $this-&gt;integer('book_id')-&gt;unsigned();
    $this-&gt;integer('category_id')-&gt;unsigned();

    $this-&gt;text('notes');

    $this-&gt;timestamps();
  });</pre></div><p>You also have some conventions to follow. These are given here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The table name is comprised of the name of the entities, which is singular, separated by an underscore</li><li class="listitem" style="list-style-type: disc">The table will contain two columns named after the interested entities (<code class="literal">author_id</code> and <code class="literal">book_id</code>)</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>When you specify a relation, remember to use <code class="literal">return</code> before the appropriate method call. I know that's a little obvious, but very often newbies forget it.</p><p>It's really, really important that you follow the defined conventions. Laravel and Eloquent can change your workflow timeline significantly, but to get the result, you must follow conventions. The sooner you do it, the better you will feel.</p></div></div></div><div class="section" title="A question of inverses"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec42"/>A question of inverses</h2></div></div></div><p>A little extra<a id="id143" class="indexterm"/> before we go forward. We just saw how to define a relationship and its inverse. However, what are the consequences you would stumble upon if you don't define an inverse? Or what if I define an inverse and not the <span class="emphasis"><em>inverse of the inverse</em></span>?</p><p>Nothing special, actually!</p><p>The best rule is to define the relationship you need. Let's imagine a situation like this: in your software, you will need to know the category of a book, but not all the books in a certain category.</p><p>It is a strange situation, but this happens. In this case, you can just define the <code class="literal">categories()</code> relationship in <code class="literal">Book</code> and nothing else.</p><p>Vice versa, if in your application you will just need to get a list of books from the category and nothing else, you will define only the <code class="literal">books()</code> relationship in the <code class="literal">Category</code> model. That's all.</p><p>Done! The three basic relationship types are covered! You don't have to do anything more; actually, Eloquent handles everything automatically, so all you have to do is to write your code, use models, and raise your queries.</p><p>Oh, about queries...</p></div></div></div>
<div class="section" title="Querying-related models"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Querying-related models</h1></div></div></div><p>Now that you have learned how <a id="id144" class="indexterm"/>to define your relationships, I think you are ready to learn how to query them. Let's start with a very basic example.</p><p>Let's suppose that we are searching for the document number of a specific user. We will use the <code class="literal">User</code> and <code class="literal">IdentityDocument</code> entities we just saw. For the purpose of this example, imagine that you have a table <code class="literal">identitydocuments</code> with the following columns:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Number</code>: This  indicates the document number</li><li class="listitem" style="list-style-type: disc"><code class="literal">Type</code>: This indicates the document type</li><li class="listitem" style="list-style-type: disc"><code class="literal">due_date</code>: This indicates the due date of the document</li><li class="listitem" style="list-style-type: disc"><code class="literal">City</code>: This indicates the city where the document was released</li></ul></div><p>Here's the code to get the document identity number, starting from a <code class="literal">User</code> instance:</p><div class="informalexample"><pre class="programlisting">  $user = \App\User::where('first_name', '=', 'Francesco')-&gt;where('last_name', '=', 'Malatesta')-&gt;first();

  $identityDocumentNumber = $user-&gt;identityDocument-&gt;number;</pre></div><p>If you echo <code class="literal">$identityDocumentNumber</code>, you will read the desired information. Nice, huh?</p><p>Well, this is<a id="id145" class="indexterm"/> the way Laravel and Eloquent deal with querying your relationships. Once you have defined it, all you have to do is to access it as a simple property or a method.</p><p>All the other queries will be executed automatically by Laravel. In fact, follow these simple instructions:</p><div class="informalexample"><pre class="programlisting">  $user = \App\User::where('first_name', '=', 'Francesco')-&gt;where('last_name', '=', 'Malatesta')-&gt;first();

  $identityDocumentNumber = $user-&gt;identityDocument-&gt;number;</pre></div><p>You just executed these queries:</p><div class="informalexample"><pre class="programlisting">  // the user Francesco Malatesta as an ID = 1...
  select * from users where first_name = 'Francesco' AND last_name = 'Malatesta';

  select * from identitydocuments where user_id = 1</pre></div><p>Now put the result in to the <code class="literal">$identityDocumentNumber</code>. It is quite obvious for a one-to-one relationship; however, the same applies for a one-to-many relationship.</p><p>Let's consider another example right now: good old Jules will be a perfect fit. Let's suppose that we want to get a list of every Jules Verne books we have, and the code is as follows:</p><div class="informalexample"><pre class="programlisting">  $author = \App\Author::where('first_name', '=', 'Jules')-&gt;where('last_name', '=', 'Verne')-&gt;first();

  foreach($author-&gt;books as $book)
  {
    echo $book-&gt;title . &lt;br/&gt;;
  }

  // outputs:
  //
  // Journey to the Center of the Earth
  // Twenty Thousand Leagues Under the Sea
  // Around the World in Eighty Days
  // Michel Strogoff</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>As I told you before, you can have access to your relationship using a simple attribute or a method call. What's the difference? Well, with the method call, you can do some filtering, and everything you saw before, in order to get the desired result. In fact, you can raise a query on a relationship.</p></div></div><p>Imagine that <a id="id146" class="indexterm"/>we want to get all the books with a <span class="emphasis"><em>the</em></span> in the title. Here's the code:</p><div class="informalexample"><pre class="programlisting">  $author = \App\Author::where('first_name', '=', 'Jules')-&gt;where('last_name', '=', 'Verne')-&gt;first();

  $theBooks = $author-&gt;books()-&gt;where('title', 'LIKE', '%the%')-&gt;get();

  foreach($theBooks as $book)
  {
    echo $book-&gt;title . &lt;br/&gt;;
  }

  // outputs:
  //
  // Journey to the Center of the Earth
  // Twenty Thousand Leagues Under the Sea
  // Around the World in Eighty Days</pre></div><p>Cool, right? It's not over yet, this is just scratching the surface!</p><div class="section" title="Accessing a pivot table"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Accessing a pivot table</h2></div></div></div><p>Working with <a id="id147" class="indexterm"/>many-to-many relationships, is not always about just defining a couple of external keys. You can choose to put extra data in to your pivot table in order to store some information for a specific connection between entities.</p><p>You already know how to create a pivot table, but how to access it? It's nothing complex: all you have to do is to use the <code class="literal">pivot</code> attribute of your relationship. Let's take an example using the previous books/categories relationship we created.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, you must define which attribute you want to take from the table, modifying the <code class="literal">belongsToMany()</code> call in your model:<div class="informalexample"><pre class="programlisting">  return $this-&gt;belongsToMany('App\Category')-&gt;withPivot('created_at', 'notes');</pre></div></li><li class="listitem">Then your code should be as follows:<div class="informalexample"><pre class="programlisting">  $book = App\Book::find(23);

  foreach($book-&gt;categories as $category)
  {
    echo 'Association Date: ' . $category-&gt;pivot-&gt;created_at;
    echo 'Association Notes: ' . $category-&gt;pivot-&gt;notes;
  } </pre></div></li></ol></div><p>In this little <a id="id148" class="indexterm"/>example, we just have printed all the dates that we <span class="emphasis"><em>attached</em></span> a specific category to the book with <code class="literal">id = 23</code>. As an extra, we also printed some extra notes. This means that on the pivot table, we have the <code class="literal">created_at</code> and <code class="literal">notes</code> fields.</p><p>As a shortcut, you can also use:</p><div class="informalexample"><pre class="programlisting">  return $this-&gt;belongsToMany('App\Category')-&gt;withTimestamps();</pre></div><p>This is used if you just want to import timestamps data from the pivot table.</p></div><div class="section" title="Querying a relationship"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Querying a relationship</h2></div></div></div><p>Eloquent<a id="id149" class="indexterm"/> allows you to query a relationship. In other words, you can get some results based on the existence of a certain relationship. Imagine that we want to get all the authors who have at least one book in the database.</p><p>With Eloquent, we can do something like this:</p><div class="informalexample"><pre class="programlisting">  $authorsWithABook = \App\Author::has('books')-&gt;get();</pre></div><p>In this case, you have to use the <code class="literal">has</code> method, specifying the name of the desired method for the relationship you want to check. The author will be added to <code class="literal">$authorsWithABook</code> only if at least one related book is be found.</p><p>If you don't like this <span class="emphasis"><em>Boolean</em></span> approach, don't worry; let's see how to find every author with at least five books in the database.</p><div class="informalexample"><pre class="programlisting">  $authorsWithAtLeastFiveBooks = \App\Author::has('books', '&gt;=', 5)-&gt;get();</pre></div><p>Yeah, you can specify the second and third arguments as operator and comparison term, respectively, for this <span class="emphasis"><em>count check</em></span>.</p><p>I know, I know, cool, but not enough. Alright, what about getting all the authors with at least one book dated 1864?</p><p>Here we go, this time with the <code class="literal">whereHas</code> method:</p><div class="informalexample"><pre class="programlisting">  $authorsWithABookFromThe1864 = \App\Author::whereHas('books', function($q)
  {
      $q-&gt;where('year', '=', 1864);

  })-&gt;get();</pre></div><p>As you can see, you can do it in a quite elegant way. The first parameter specified is the name of the<a id="id150" class="indexterm"/> relationship you want to query. The second argument is a closure that takes a <code class="literal">$q</code> query parameter, which you can use to define conditions.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>The same concept you just saw here for a one-to-many relationship is also used for a many-to-many relationship.</p></div></div></div></div>
<div class="section" title="Eager loading (and the N + 1 problem)"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Eager loading (and the N + 1 problem)</h1></div></div></div><p>Every<a id="id151" class="indexterm"/> powerful tool must be used wisely. Relationships in Eloquent are no exception to the rule. Actually, one of the most common problems in using Eloquent is the <span class="emphasis"><em>N + 1</em></span> problem. To explain it, I will use an example as usual.</p><p>Let's suppose that I am showing some data for the first 100 books. Starting with this data, I also want to print the author name for every single book.</p><p>Using what we've learned before now, here's the code:</p><div class="informalexample"><pre class="programlisting">  $books = \App\Book::take(100)-&gt;get();

  foreach($books as $book)
  {
    $author = $book-&gt;author;

    echo $author-&gt;first_name . ' ' . $author-&gt;last_name;
  }</pre></div><p>Even if the syntax is simple, under the hood, Eloquent is performing 101 queries! The first one is to get the list of the 100 books, then a query for every book to get the author. This is not exactly performance friendly, right?</p><p>Don't worry, there is a solution!</p><div class="section" title="Basic eager loading"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Basic eager loading</h2></div></div></div><p>Eager <a id="id152" class="indexterm"/>loading solves your problem. This time using the <code class="literal">with()</code> method of the <code class="literal">Book</code> model, like this:</p><div class="informalexample"><pre class="programlisting">  $books = \App\Book::with('author')-&gt;take(100)-&gt;get();

  foreach($books as $book)
  {
    $author = $book-&gt;author;

    echo $author-&gt;first_name . ' ' . $author-&gt;last_name;
  }</pre></div><p>Now, the <a id="id153" class="indexterm"/>number of executed queries will precipitate down to two, using a <code class="literal">where in</code>!</p><div class="informalexample"><pre class="programlisting">  select * from books;
  select * from authors where id in (1, 2, 3, ...);</pre></div><p>If you want, you can also include multiple relationships in your final result. Let's also include categories data for every book!</p><div class="informalexample"><pre class="programlisting">  $books = \App\Book::with('author', 'categories')-&gt;take(100)-&gt;get();

  foreach($books as $book)
  {
    $author = $book-&gt;author;

    echo 'Author: ' . $author-&gt;first_name . ' ' . $author-&gt;last_name;

    echo 'Categories:';

    foreach($book-&gt;categories as $category)
    {
      echo $category-&gt;name . ', ';
    }
  }</pre></div><p>As if it's not enough, you can also include data from <span class="emphasis"><em>nested relationships</em></span>.</p><p>Let's imagine that you are getting a list of categories in your application. Then, you want to include book data for every category, and for every related book you want to include the author's data.</p><p>All you have to do is this:</p><div class="informalexample"><pre class="programlisting">  $categories = \App\Categories::with('books.author')-&gt;get();

  foreach($categories as $category)
  {
    echo $category-&gt;name;

    foreach($category-&gt;books as $book)
    {
      echo 'Title: ' . $book-&gt;title;
      echo 'Author: ' . $book-&gt;author-&gt;first_name . ' ' . $book-&gt;author-&gt;last_name;
    }
  }</pre></div></div><div class="section" title="Advanced eager loading"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec46"/>Advanced eager loading</h2></div></div></div><p>If you<a id="id154" class="indexterm"/> want better control over your eager loading, you can define some constraints or conditions. Let's assume that you are getting a list of authors. From this list, you want to get every published book, from the oldest to the most recent.</p><p>You can do it like this:</p><div class="informalexample"><pre class="programlisting">  $authors = \App\Author::with(['books' =&gt; function($query)
  {
    $query-&gt;orderBy('year', 'asc');

  }])-&gt;get();</pre></div><p>All you have to do is to specify the desired eager-loaded relationships as elements of an associative array with this syntax:</p><div class="informalexample"><pre class="programlisting">  ['relationship' =&gt; function($query){

    // conditions here, using the $query object

  }]</pre></div></div><div class="section" title="Lazy eager loading"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Lazy eager loading</h2></div></div></div><p>Sometimes <a id="id155" class="indexterm"/>you will use eager loading, but not every time. Sometimes you will need it, sometimes not.</p><p>If you want, you can manually eager load a specific relationship in the next moment.</p><p>How? It can be done with the <code class="literal">load()</code> method:</p><div class="informalexample"><pre class="programlisting">  $books = Book::all();

  // some operations here...

  $books-&gt;load('author', 'categories');</pre></div><p>The syntax is really similar to what you saw before; all you have to do is to specify the desired relationships as arguments.</p><p>Of course, you can also define conditions with the following:</p><div class="informalexample"><pre class="programlisting">  $books-&gt;load(['categories' =&gt; function($query)
  {
      $query-&gt;orderBy('name', 'asc');

  }]);</pre></div><p>The same <a id="id156" class="indexterm"/>way, nothing less, nothing more!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>Remember that eager loading is a great solution to many performance issues. Especially in my initial experiments, it helped me a lot by letting me reach a lower number of queries. Just to make an example, on the Laravel-Italia forum, I showed a list of threads, with some replies, information, and thread author data, with just three queries.</p></div></div></div></div>
<div class="section" title="Inserting and updating related models"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Inserting and updating related models</h1></div></div></div><p>Until now, you have <a id="id157" class="indexterm"/>learned how to define relationships and query them, in order <a id="id158" class="indexterm"/>to get data from related models. However, you can also insert and update related models in an easy way.</p><p>Let's pick a really basic example to get started: imagine that we are adding a new book (<span class="emphasis"><em>Michael Strogoff</em></span>, <span class="emphasis"><em>Jules Verne</em></span>). We have to specify some details as follows:</p><div class="informalexample"><pre class="programlisting">  $book = new Book;

  $book-&gt;title = 'Michael Strogoff';
</pre></div><p>Then, we specify the correct author ID:</p><div class="informalexample"><pre class="programlisting">$author = Author::where('first_name', '=', 'Jules')-&gt;where('last_name', '=', 'Verne')-&gt;first();

  $book = new Book;

  $book-&gt;title = 'Michael Strogoff';
  // other data...

  $book-&gt;author_id = $author-&gt;id;

  // and finally...
  $book-&gt;save();</pre></div><div class="section" title="The save() and associate() methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec48"/>The save() and associate() methods</h2></div></div></div><p>Let's be clear; this works really well. However, it is not the best way you can do it. In fact, with Eloquent, you can work with related models using some other specific methods.</p><p>Let's rewrite this example using the method <code class="literal">save()</code> on a relationship. Also, we will use an associative array as a constructor argument in order to assign attributes.</p><div class="informalexample"><pre class="programlisting">  $author = Author::where('first_name', '=', 'Jules')-&gt;where('last_name', '=', 'Verne')-&gt;first();

  $author-&gt;books-&gt;save(new Book([
    'title' =&gt; 'Michael Strogoff',
    // other attributes...
  ]));</pre></div><p>Done! It only took a couple of instructions. The <code class="literal">save()</code> method<a id="id159" class="indexterm"/> will automatically set the <code class="literal">author_id</code> key for the book you just passed as a parameter.</p><p>However, this is not just a time-saving trick; if you read the code carefully, you will note that we are actually creating very readable code. Instead of setting external keys, treating the relationship in a more <span class="emphasis"><em>physical</em></span> way, we are saving the book as an element of the collection of books for a certain author. Quite different!</p><p>You can also do the same thing with arrays of objects, using the <code class="literal">saveMany()</code> method:</p><div class="informalexample"><pre class="programlisting">  $author = Author::where('first_name', '=', 'Jules')-&gt;where('last_name', '=', 'Verne')-&gt;first();

  $author-&gt;books-&gt;saveMany([
    new Book(['title' =&gt; 'Michael Strogoff']),
    new Book(['title' =&gt; 'The Mysterious Island']),
    new Book(['title' =&gt; 'Off on a Comet'])
  ]);</pre></div><p>As mentioned before, the <code class="literal">saveMany</code> method will set the external <code class="literal">author_id</code> key for every <code class="literal">Book</code> instance passed in the array. You can also update an existing relationship, changing its association with another model.</p><p>In this case, you must use the<a id="id160" class="indexterm"/> <code class="literal">associate()</code> method. Take a look at this example:</p><div class="informalexample"><pre class="programlisting">  $wrongAuthor = Author::where('first_name', '=', 'Jules')-&gt;where('last_name', '=', 'Verne')-&gt;first();

  $wrongAuthor-&gt;books-&gt;save(new Book([
    'title' =&gt; 'The Alchemist'
  ]));

  // oops! wrong author!

  $book = Book::where('title', '=', 'The Alchemist')-&gt;first();
  $rightAuthor = Author::where('first_name', '=', 'Paulo')-&gt;where('last_name', '=', 'Coelho')-&gt;first();

  // done!
  $rightAuthor-&gt;books-&gt;associate($book);</pre></div><p>What happened? In<a id="id161" class="indexterm"/> the first part of the example, I assigned <span class="emphasis"><em>The Alchemist</em></span> to Jules Verne. After one year of penitence in the desert, I came back to get the right author (by using the <code class="literal">$rightAuthor</code> variable), and then using the <code class="literal">associate()</code> method on the books relationship.</p><p>The first passed parameter is the model instance you want to work with.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>So, the rule is quite simple: use the <code class="literal">save()</code> method when inserting a new record or the <code class="literal">associate()</code> method in order to update an existing record.</p></div></div><p>Remember that <span class="emphasis"><em>The Alchemist</em></span> was not written by Jules Verne but by Paulo Coelho!</p></div><div class="section" title="What about many to many?"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec49"/>What about many to many?</h2></div></div></div><p>Everything<a id="id162" class="indexterm"/> we saw is great for one-to-one or one-to-many relationships. However, what about many-to-many relationships? The mechanism, this time, is a little bit different; not in terms of complexity, but in terms of syntax, more than anything else. However, let's use an example as we did before.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We have a few books: <span class="emphasis"><em>The Alchemist</em></span> and <span class="emphasis"><em>Journey to the Center of the Earth</em></span>.</li><li class="listitem" style="list-style-type: disc">We also have some categories: <span class="emphasis"><em>Science Fiction</em></span>, <span class="emphasis"><em>Adventure</em></span>, and <span class="emphasis"><em>Classic</em></span>.</li></ul></div><p>As I mentioned in the first part of this chapter, this is a many-to-many relationship. What can we do to register a relationship between <span class="emphasis"><em>The Alchemist</em></span> and <span class="emphasis"><em>Adventure</em></span>, or <span class="emphasis"><em>Journey to the Center of the Earth</em></span> and <span class="emphasis"><em>Classic</em></span>?</p><p>In order to access our data in separate pivot tables, we will need other dedicated methods. I know that it seems stupid and boring, but use your database management tool to see what happens in your database when you interact with your data. It's always a good idea to familiarize with the process.</p><p>However, the first method you will use is <code class="literal">attach()</code>:</p><div class="informalexample"><pre class="programlisting">  $book = new Book();

  $book-&gt;title = "The Alchemist";
  // other attributes...

  $book-&gt;save();

  // after save() call, an id is created.

  $category = new Category();

  $category-&gt;name = "Adventure";

  $category-&gt;save();

  // and now...

  $category-&gt;books-&gt;attach($book-&gt;id);</pre></div><p>As you can<a id="id163" class="indexterm"/> easily see, the <code class="literal">attach()</code> method is another one you can call on a relationship. Of course, only on a many-to-many one! It takes a single parameter in this case: the primary ID of the book I want to associate with the category.</p><p>You can also add an associative array as a second parameter if you are storing some extra data in your pivot table:</p><div class="informalexample"><pre class="programlisting">  $category = Category::where('name', '=', 'Opera')-&gt;first();

  $book = Book::where('title', '=', 'Journey to the Center of the Earth')-&gt;first();

  $category-&gt;books-&gt;attach(
    $book-&gt;id, 
    ['notes' =&gt; "Well, I'm not so sure about this..."]
  );</pre></div><p>The associative array follows the <code class="literal">attribute_name =&gt; attribute_value</code> format, as usual.</p><p>In the same way you <span class="emphasis"><em>attach</em></span>, you can <span class="emphasis"><em>detach</em></span>. If you want to remove a many-to-many relationship between two model instances, use the <code class="literal">detach()</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">  $category = Category::where('name', '=', 'Opera')-&gt;first();

  $book = Book::where('title', '=', 'Journey to the Center of the Earth')-&gt;first();

  // oh, come on...
  $category-&gt;books-&gt;detach($book-&gt;id);</pre></div><p>So, you are done!</p><p>Also, both <code class="literal">attach()</code> and <code class="literal">detach()</code> methods <a id="id164" class="indexterm"/>support an array as a parameter instead of a simple integer.</p><div class="informalexample"><pre class="programlisting">  $category-&gt;books-&gt;attach(
    [4, 8, 15, 17, 22, 42]
  );

  $category-&gt;books-&gt;detach([17, 22]);

  $category-&gt;books-&gt;attach([16, 23 =&gt; ['notes' =&gt; 'be careful next time...']]);</pre></div></div><div class="section" title="The sync() method"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec50"/>The sync() method</h2></div></div></div><p>This is a really<a id="id165" class="indexterm"/> cool way to deal with many-to-many relationships. However, attaching and detaching things could be a little boring sometimes. Let's try the <code class="literal">sync()</code> method:</p><div class="informalexample"><pre class="programlisting">  $category-&gt;books-&gt;sync(
    [4, 8, 15, 17, 22, 42]
  );

  $category-&gt;books-&gt;sync(
    [4, 8, 15, 16, 23, 42]
  );</pre></div><p>Confused? Let me explain everything. The <code class="literal">sync</code> method automatically <span class="emphasis"><em>synchronizes</em></span> relationship data, taking an array of IDs. Element after element, it checks if the relationship was previously created or not, and sets (or unsets) them when necessary. Let's imagine that the pivot  table <code class="literal">book_category</code> is empty; here's the first instruction:</p><div class="informalexample"><pre class="programlisting">  $category-&gt;books-&gt;sync(
    [4, 8, 15, 17, 22, 42]
  );</pre></div><p>This instruction will create a connection between the chosen category and the books with the IDs 4, 8, 15, 17, 22, and 42. However, here's the second method call:</p><div class="informalexample"><pre class="programlisting">  $category-&gt;books-&gt;sync(
    [4, 8, 15, 16, 23, 42]
  );</pre></div><p>It checks everything, and calculates a positive difference and a negative one. Books 17 and 22 are no longer in the array. The relationship will be automatically <span class="emphasis"><em>detached</em></span>. Instead, books 16 and 23 will be added with <span class="emphasis"><em>attach</em></span>, another really cool utility method that saves you a lot of time!</p><p>You can obviously add data to the pivot table with the same method used earlier:</p><div class="informalexample"><pre class="programlisting">  $category-&gt;books-&gt;sync(
    [4, 8, 15, 16, 23, 42 =&gt; ['notes' =&gt; 'We either live together.... or die alone.']]
  );</pre></div></div></div>
<div class="section" title="Accessing distant relationships"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Accessing distant relationships</h1></div></div></div><p>Another<a id="id166" class="indexterm"/> really interesting Eloquent feature is the possibility to define (and then access) a distant relation, using the <code class="literal">hasManyThrough()</code> method.</p><p>What? I see you are a little confused. No problem: let's take another example, which is a little different from our actual context.</p><p>Imagine that you are writing an application for some kind of research management for a research team. In this software, every user will be able to create a new research entity, and then add some sections to that research something like this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <code class="literal">User</code> entity that has a one-to-many relationship with a <code class="literal">Research</code> entity</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Research</code> entity has a one-to-many relationship with a <code class="literal">Section</code> entity</li></ul></div><p>Good. First of all, for models, you could write something like this:</p><div class="informalexample"><pre class="programlisting">  // file: app/User.php
  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class User extends Model {

    public function researches()
    {
      return $this-&gt;hasMany('App\Research');
    }

  }

  // file: app/Research.php
  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Research extends Model {

    public function user()
    {
      return $this-&gt;belongsTo('App\User');
    }

    public function sections()
    {
      return $this-&gt;hasMany('App\Section');
    }

  }

  // file: app/Section.php
  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Section extends Model {

    public function research()
    {
      return $this-&gt;belongsTo('App\Research');
    }

  }</pre></div><p>As a basic setup, it <a id="id167" class="indexterm"/>could work. Now, what if we want access to every section added by a certain user? Probably, you would use something like this:</p><div class="informalexample"><pre class="programlisting">  // getting $author with id = 1...
  $author = Author::find(1);

  // getting all $author researches...
  $researches = $author-&gt;researches;

  $allSections = [];

  // iterating to get all sections
  foreach($researches as $research)
  {
    $allSections[] = $research-&gt;sections;
  }</pre></div><p>The <code class="literal">$allSections</code> array would contain every section added by the user. With Eloquent, if you want, you can create a shortcut using the <code class="literal">hasManyThrough()</code> method I mentioned earlier.</p><p>All you have to do is to put it in the User model as follows:</p><div class="informalexample"><pre class="programlisting">  // file: app/User.php
  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class User extends Model {

    public function researches()
    {
      return $this-&gt;hasMany('App\Research');
    }

    public function sections()
    {
      return $this-&gt;hasManyThrough('App\Section', 'App\Research');
    }

  }</pre></div><p>If you want, you <a id="id168" class="indexterm"/>can specify external keys (for the current and <span class="emphasis"><em>middle</em></span> entities) as the third and fourth parameters:</p><div class="informalexample"><pre class="programlisting">  return $this-&gt;hasManyThrough('App\Section', 'App\Research', 'user_id', 'research_id');</pre></div><p>In some such specific cases, it is a very useful shortcut. Enjoy it!</p></div>
<div class="section" title="More power &#x2013; polymorphic relationships"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/>More power – polymorphic relationships</h1></div></div></div><p>Probably, you<a id="id169" class="indexterm"/> are thinking that Eloquent is cool and very powerful.</p><p>Well, yes, it is. However, sometimes, <code class="literal">hasMany()</code> or <code class="literal">belongsToMany()</code> isn't enough. In some situations during your development flow, you will have to deal with more complex relationships that could involve more than two entities.</p><p>So, as a last part of this chapter, I will talk about polymorphic relationships. As usual, even if they aren't complex to learn, I will cover them with many detailed examples, in order to let you fully understand the entire concept.</p><p>Let's start from the simple polymorphic relationship.</p><div class="section" title="A simple polymorphic relationship"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec51"/>A simple polymorphic relationship</h2></div></div></div><p>A <a id="id170" class="indexterm"/>simple polymorphic relationship can be used when you have an entity that can belong to either one entity or to another.</p><p>So, here's our first example. Imagine that you are creating an e-commerce application. You will be able to upload some photos: either for a product, a category, or a blog post.</p><p>This means that we will have, first of all, four separate entities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Photo</li><li class="listitem" style="list-style-type: disc">Product</li><li class="listitem" style="list-style-type: disc">Category</li><li class="listitem" style="list-style-type: disc">Post</li></ul></div><p>Now, let's prepare some code skeletons as follows:</p><div class="informalexample"><pre class="programlisting">  // file: app/Photo.php
  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Photo extends Model {

    //

  }

  // file: app/Product.php
  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Product extends Model {

    //

  }

  // file: app/Category.php
  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Category extends Model {

    //

  }

  // file: app/Post.php
  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Post extends Model {

    //

  }</pre></div><p>Now, you can <a id="id171" class="indexterm"/>define this polymorphic relationship using the <code class="literal">morphTo()</code> and <code class="literal">morphMany()</code> methods.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">morphTo()</code> method is used by the class that is related to all the other classes.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">morphMany()</code> method is called by the <code class="literal">owner</code> classes.</li></ul></div><p>So, let's edit our models like this:</p><div class="informalexample"><pre class="programlisting">  // file: app/Photo.php
  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Photo extends Model {

    public function imageable()
    {
      return $this-&gt;morphTo();
    }

  }

  // file: app/Product.php
  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Product extends Model {

    public function photos()
    {
      return $this-&gt;morphMany('Photo', 'imageable');
    }

  }

  // file: app/Category.php
  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Category extends Model {

    public function photos()
    {
      return $this-&gt;morphMany('Photo', 'imageable');
    }

  }

  // file: app/Post.php
  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Post extends Model {

    public function photos()
    {
      return $this-&gt;morphMany('Photo', 'imageable');
    }

  }</pre></div><p>Done! Wait, wait. What's<a id="id172" class="indexterm"/> that <code class="literal">imageable</code> that is used both as a name for the method and as a string parameter? It is a name you can choose for yourself: however, take a look at the table structure I have used, to understand.</p><div class="informalexample"><pre class="programlisting">  products
      id - integer
      name - string

  categories
      id - integer
      name - string

  posts
      id - integer
      name - string

  photos
      id - integer
      path - string
      imageable_id - integer
      imageable_type - string</pre></div><p>The photos<a id="id173" class="indexterm"/> table has two special fields: <code class="literal">imageable_id</code> and <code class="literal">imageable_type</code>. A simple external key, the only difference is that, for the elements in this photos table, you can count <span class="emphasis"><em>owners</em></span> of different types.</p><p>So, in <code class="literal">imageable_id</code>, you will put the owner ID and in <code class="literal">imageable_type</code>, the owner class name!</p><p>If a photo belongs to a product, you will see <code class="literal">Product</code> in the <code class="literal">imageable_type</code> column, then <code class="literal">Category</code> if the photo belongs to a category, and so on.</p><p>Obviously, working with this relationship is very simple. Here's an example:</p><div class="informalexample"><pre class="programlisting">  // getting a sample product...
  $product = App\Product::find(3);

  foreach($product-&gt;photos as $photo)
  {
    // working with photos here...
  }</pre></div><p>This applies for every other entity!</p><div class="informalexample"><pre class="programlisting">  // getting a sample category
  $category = App\Category::find(42);

  foreach($category-&gt;photos as $photo)
  {
    // working with category photos here...
  }</pre></div><p>Finally, you can also <span class="emphasis"><em>reverse</em></span> things. If you have a photo and want to know <span class="emphasis"><em>who</em></span> the owner is, all you have to do is:</p><div class="informalexample"><pre class="programlisting">  $photo = App\Photo::find(23);

  // getting the owner...
  var_dump($photo-&gt;imageable);</pre></div><p>No matter what <a id="id174" class="indexterm"/>the owner's class is, Eloquent will automatically resolve the instance and return it to you. If the <span class="emphasis"><em>owner</em></span> is a blog post, you'll get the blog post. Easy!</p></div><div class="section" title="A many-to-many polymorphic relationship"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec52"/>A many-to-many polymorphic relationship</h2></div></div></div><p>If a <a id="id175" class="indexterm"/>simple polymorphic relationship can be defined as a <span class="emphasis"><em>special</em></span> one to many, the many-to-many relationship finds equivalence in many-to-many polymorphic relationships.</p><p>As you saw in the earlier text, it works exactly like a many-to-many relationship. The only difference is that you can <span class="emphasis"><em>connect</em></span> a certain entity with more entities.</p><p>For our example, this time, let's return to our library management system. At the beginning of this chapter, you saw three main entities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Author</li><li class="listitem" style="list-style-type: disc">Book</li><li class="listitem" style="list-style-type: disc">Category</li></ul></div><p>Between books and categories, there is a many-to-many relationship. A book can belong to more than one category. Similarly, a category can include more than one book. Now, imagine that you want to <span class="emphasis"><em>extend</em></span> this concept to authors.</p><p>Let's pick good old Jules as a perfect example. He wrote adventure books, so he could be easily classified as an adventure author.</p><p>The many-to-many polymorphic relationship is the best way to deal with the situation. This time, you will have to use the <code class="literal">morphMany()</code> and <code class="literal">morphedByMany()</code> methods:</p><div class="informalexample"><pre class="programlisting">  // file: app/Author.php
  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Author extends Model {

    public function categories()
    {
      return $this-&gt;morphToMany('App\Category', 'categorizable');
    }

  }

  // file: app/Book.php
  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Book extends Model {

    public function categories()
    {
      return $this-&gt;morphToMany('App\Category', 'categorizable');
    }

  }

  // file: app/Category.php
  &lt;?php namespace App;

  use Illuminate\Database\Eloquent\Model;

  class Category extends Model {

    public function authors()
    {
      return $this-&gt;morphedByMany('App\Author', 'categorizable');
    }

    public function books()
    {
      return $this-&gt;morphedByMany('App\Book', 'categorizable');
    }

  }</pre></div><p>Of course, as <a id="id176" class="indexterm"/>for every many-to-many relationship, you will need a pivot table with a structure similar to the following:</p><div class="informalexample"><pre class="programlisting">  categorizables
      tag_id - integer
      categorizable_id - integer
      categorizable_type – string</pre></div><p>Pay maximum attention to names and conventions, as usual. The second parameter of <code class="literal">categorizable</code> for the <code class="literal">morphToMany()</code> and <code class="literal">morphedByMany()</code> methods is the same as you specify in the pivot table, for <code class="literal">categorizable_id</code> and <code class="literal">categorizable_type</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>Also, the table name used is the plural for the term (<code class="literal">categorizable</code> and <code class="literal">categorizables</code>).</p></div></div><p>After this setup, you <a id="id177" class="indexterm"/>are able to use the relationship in your code, as follows:</p><div class="informalexample"><pre class="programlisting">  // getting a sample author
  $author = App\Author::find(30);


  // accessing categories...
  var_dump($author-&gt;categories);

  // getting a sample book
  $book = App\Book::find(60);

  // accessing categories... in the same way!
  var_dump($book-&gt;categories);</pre></div><p>While creating tables, you will need to add the specific <code class="literal">_id</code> and <code class="literal">_type</code> columns, such as <code class="literal">categorizable_id</code> and <code class="literal">categorizable_type</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>In the Schema Builder, you can use the <code class="literal">$table-&gt;morphs('categorizable')</code>, if you want. It will automatically add the columns you need, just specify the <code class="literal">-able</code> name you desire.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Summary</h1></div></div></div><p>Alright, I think that's enough. Well, actually that's all; time to rest!</p><p>You have learned everything related to relationships in Eloquent, and now you can even build complex applications in no time. You know everything related to Eloquent basics, so my suggestion is: take your time to recap everything, do some tests, write good code, and enjoy models and relationships.</p><p>When ready, turn the page and dive into something more advanced!</p></div></body></html>