<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Using View"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Using View</h1></div></div></div><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Working with View</li><li class="listitem" style="list-style-type: disc">Using view helpers</li><li class="listitem" style="list-style-type: disc">Creating a global layout template</li><li class="listitem" style="list-style-type: disc">Creating reusable Views</li><li class="listitem" style="list-style-type: disc">Using view strategies/renderers</li><li class="listitem" style="list-style-type: disc">Using context switching for a different output</li><li class="listitem" style="list-style-type: disc">Writing a custom view strategy/renderer</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Introduction</h1></div></div></div><p>In this chapter we are going to talk about using View, something that we have briefly mentioned in a couple of places before. View was created for the benefit of the developer, to strictly separate everything frontend with everything backend. This way backend developers can focus on controllers and models, while frontend developers can work in Views. Another great benefit of View is that View decides how the data is being outputted, so in most cases this would be HTML, in other cases maybe JSON and so on.</p><p>We will show you in the last recipe of the chapter how to make our own customizations as well, so that we fully understand how everything works.</p></div></div>
<div class="section" title="Working with View"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Working with View</h1></div></div></div><p>View can be considered<a id="id259" class="indexterm"/> very important as it actually renders the content that is being outputted to the browser of the user. Therefore, we can assume that knowing how View works is very useful when creating web applications.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Getting ready</h2></div></div></div><p>For this recipe it is beneficial if we have the Zend Framework 2 skeleton set up and ready to work. We will do<a id="id260" class="indexterm"/> some basic things to get you started, so no additional extensions are necessary for this.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec45"/>How to do it…</h2></div></div></div><p>We are going to output content to the browser by using <code class="literal">PhpRenderer</code> which is the default view strategy used.</p><div class="section" title="Configure the ViewManager"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec93"/>Configure the ViewManager</h3></div></div></div><p>We make<a id="id261" class="indexterm"/> the <a id="id262" class="indexterm"/>following alterations to the <code class="literal">/module/Application/config/module.config.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php
return array(
  'view_manager' =&gt;array(
    // We want to show the user if the page is not found
    'display_not_found_reason' =&gt; true,

    // We want to display exceptions when the occur
    'display_exceptions' =&gt; true,

    // This defines the doctype we want to use in our 
    // output
    'doctype' =&gt; 'HTML5',

    // Here we define the error templates
    'not_found_template' =&gt; 'error/404',
    'exception_template' =&gt; 'error/index',

    // Create out template mapping 
    'template_map' =&gt;array(

      // This is where the global layout resides
      'layout/layout' =&gt; __DIR__ . '/../view/layout/layout.phtml',

      // This defines where we can find the templates 
      // for the error messages
      'error/404' =&gt; __DIR__ . '/../view/error/404.phtml',
      'error/index' =&gt; __DIR__ . '/../view/error/index.phtml',
    ),

    // The template path stack tells our view manager 
    // where our templates are stored
    'template_path_stack' =&gt;array(__DIR__ . '/../view',
    ),
  ),
);</pre></div></div><div class="section" title="Set variables in the ViewModel instance"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec94"/>Set variables in the ViewModel instance</h3></div></div></div><p>Now we<a id="id263" class="indexterm"/> have <a id="id264" class="indexterm"/>set up the view manager; we can go to our controller and add the following to the import section of our controller.</p><div class="informalexample"><pre class="programlisting">use Zend\View\Model\ViewModel;</pre></div><p>Now we can use the <code class="literal">ViewModel</code> instance for the <code class="literal">PhpRenderer</code> in our action controller. Let's do that now:</p><div class="informalexample"><pre class="programlisting">public function someAction()
{
  $view = new ViewModel();

  // One way of setting a variable in the view 
  $view-&gt;setVariable('example', 'Output this to user');

  return $view;
}</pre></div><p>It is as easy as that; simply return the <code class="literal">ViewModel</code> instance after we are done defining everything we want.</p></div><div class="section" title="Mark up the template file"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec95"/>Mark up the template file</h3></div></div></div><p>Now it is time<a id="id265" class="indexterm"/> for the last part before we are done, and that is to create a template file that needs to be rendered. We can do this by first creating a file (as an example) in the <code class="literal">view/index</code> folder called <code class="literal">some.phtml</code> (as our action in the previous example was called like that).</p><p>Now we will just do a simple bit where we output the variable we have just declared in the <code class="literal">ViewModel</code> instance.</p><div class="informalexample"><pre class="programlisting">&lt;h1&gt;&lt;?php echo $this-&gt;example ?&gt;&lt;/h1&gt;</pre></div><p>And that's it. We have now outputted our variable example that we declared in our <code class="literal">ViewModel</code> instance<a id="id266" class="indexterm"/> in the action. There are also more ways of setting variables to the view, for example by declaring the variables as the first argument of the <code class="literal">ViewModel</code> constructor.</p><div class="informalexample"><pre class="programlisting">$view = new ViewModel(array(
  'variable_one' =&gt; 'Some Variable',
  'variable_two' =&gt; 'Some other Variable',
));</pre></div><p>Or, if we want to set multiple variables at the same time, but not during the constructor execution time we can also perform the following:</p><div class="informalexample"><pre class="programlisting">// First we have the view instantiated
$view = new ViewModel();

// And now we assign a lot of variables at the same time
$view-&gt;setVariables(array(
  'variable_one' =&gt; 'Some Variable',
  'variable_two' =&gt; 'Some other Variable',
));</pre></div><p>Now, as we are experts in outputting variables to the View, I say it is time for some cake!</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec46"/>How it works…</h2></div></div></div><p>View works with a couple of different methods before the requested output is returned to the user.</p><div class="section" title="The configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec96"/>The configuration</h3></div></div></div><p>If we <a id="id267" class="indexterm"/>would use the Zend Framework 2 skeleton application, then this would already be in there by default, but let's assume we have nothing configured just yet and we are working blindly. The first thing we want to do is make sure that <code class="literal">ViewManager</code> is set up through the <span class="strong"><strong>Dependency Injection</strong></span> (<span class="strong"><strong>DI</strong></span>)<a id="id268" class="indexterm"/>. We can do this by opening the module configuration called <code class="literal">module.config.php</code> in the <code class="literal">config</code> folder (assuming that we are using the standard layout) and add the <code class="literal">ViewManager</code> configuration there.</p><p>One more thing before we move on is that <code class="literal">template_path_stack</code> works by searching for templates in the base directories that are defined in the array. Then it will descend further in those directories searching for the template using the format we described.</p><p>For example, <code class="literal">IndexController</code> with <code class="literal">aboutAction</code> would resolve, by default to, the path <code class="literal">view/index/about.phtml</code> in our case.</p></div><div class="section" title="The ViewModel instance"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec97"/>The ViewModel instance</h3></div></div></div><p>The <a id="id269" class="indexterm"/>
<code class="literal">ViewModel</code> instance<a id="id270" class="indexterm"/> is usually only used in the controller and is basically a container that holds all the information that needs to be outputted to the user. Although the <code class="literal">ViewModel</code> instance is technically possible to use anywhere else, it wouldn't be a good practice to do so, as the controller's main responsibility is handling the models and Views. If we go and change the nature of a controller, the application would become significantly harder to maintain.</p><p>The <code class="literal">ViewModel</code> instance itself has no other purpose than to keep track of all the variables we want to output to the user, and other options like the template we'd like to use, and if we want to render the main layout or not.</p><p>What happens next is that the <code class="literal">ViewModel</code> instance will be picked up by <code class="literal">ViewStrategy</code> and <code class="literal">ViewRenderer</code> to be used in the output.</p><p>Almost every <code class="literal">ViewStrategy</code> has its own type of <code class="literal">ViewModel</code> designed for that specific purpose. That way we can easily use another <code class="literal">ViewModel</code> instance and create a different kind of output to the user.</p></div><div class="section" title="The ViewStrategy class"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec98"/>The ViewStrategy class</h3></div></div></div><p>The<a id="id271" class="indexterm"/> <code class="literal">ViewStrategy</code> class<a id="id272" class="indexterm"/> is used to determine if and how we are going to output our content to the user. The way this works is that –usually- the <code class="literal">ViewStrategy</code> first determines if the <code class="literal">ViewModel</code> instance it receives is compatible with the model they expect it to be. It does this by attaching a <code class="literal">ViewEvent</code> to the <code class="literal">EVENT_RENDERER</code> event, which will be triggered when the framework is searching for a suitable renderer.</p><p>The <code class="literal">ViewStrategy</code> at that point checks if the model is compatible, and if it is it will return a suitable <code class="literal">ViewRenderer</code>, if not, it will return null. Then after the framework has done its thing and rendered the output (more about this in the The ViewRenderer helper section) it will trigger another <code class="literal">ViewEvent</code> named <code class="literal">EVENT_RESPONSE</code>.</p><p>This event is basically the end point that the <code class="literal">ViewStrategy</code> class can do before the output is send to the user. In this <code class="literal">ViewEvent</code> the <code class="literal">ViewStrategy</code> class can make the last amendments to the response if necessary. We should think about the content type, extra headers, or some other last minute stuff.</p><p>A simplified version of the process is displayed as follows:</p><div class="mediaobject"><img src="graphics/4841OS_04_01.jpg" alt="The ViewStrategy class"/></div></div><div class="section" title="The ViewRenderer helper"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec99"/>The ViewRenderer helper</h3></div></div></div><p>The <a id="id273" class="indexterm"/>renderer is <a id="id274" class="indexterm"/>used in between the two events mentioned in the <code class="literal">ViewStrategy</code> class before, and it does exactly like you expect it to be; it renders the output. It takes the data from the <code class="literal">ViewModel</code> instance and renders the output according to that. It usually requires a view script like the PHTML files that <code class="literal">PhpRenderer</code> uses, but sometimes it doesn't require any script at all and it will just render the output completely by itself (think about outputting in a JSON format for example). We will cover how to use different ViewStrategy and ViewRenderer later in this chapter.</p><div class="informalexample"><pre class="programlisting">Using view helpers</pre></div><p>The more we add complexity to View, the less we are able to maintain it properly. That is why we get the logic out, and put it in our View outside the view script itself, and place them in the so-called view helpers.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Getting ready</h2></div></div></div><p>For this recipe it is recommended that the Zend Framework 2 skeleton application is used. We won't require any out of the ordinary extensions for this recipe.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec48"/>How to do it…</h2></div></div></div><p>In Zend Framework 2 there are a bunch of default view helpers that comes with the framework. Let's look at a bunch of them to see what they do and how to use them.</p><div class="section" title="The BasePath view helper"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec100"/>The BasePath view helper</h3></div></div></div><p>The <a id="id275" class="indexterm"/>
<code class="literal">BasePath</code> view helper,<a id="id276" class="indexterm"/> is a very easy view helper to use, for example:</p><div class="informalexample"><pre class="programlisting">&lt;!-- 
  The following will prepend the URL with the base path
  which can be /website/public/js/script.js e or /js/script.js.
  The path is something for the basePath to decide.
--&gt;
&lt;script src="&lt;?php echo $this-&gt;basePath('js/script.js'); ?&gt;"&gt;
&lt;/script&gt;</pre></div></div><div class="section" title="The Doctype view helper"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec101"/>The Doctype view helper</h3></div></div></div><p>We make<a id="id277" class="indexterm"/> the following <a id="id278" class="indexterm"/>alterations to the <code class="literal">/module/Application/config/module.config.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php
// This is just a snippet of the code that needs to be
// there for doctype to be defined.
return array(
  'view_manager' =&gt; array(
    'doctype' =&gt; 'HTML5',
  ),
);</pre></div><p>Then in the view script, we can do the following to output the well-formed <code class="literal">doctype</code> helper:</p><div class="informalexample"><pre class="programlisting">&lt;?php echo $this-&gt;doctype(); ?&gt;</pre></div></div><div class="section" title="The URL view helper"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec102"/>The URL view helper</h3></div></div></div><p>The <a id="id279" class="indexterm"/>URL view helper<a id="id280" class="indexterm"/> is very handy to use if we want to generate a URL for a specific route, for example:</p><div class="informalexample"><pre class="programlisting">&lt;a href="&lt;?php echo $this-&gt;url(
    // This is the name we gave the route in our 
    //configuration file
    'route-name', 

    // Give the parameters for the URL, such as the 
    // controller, action or any parameters that should    
    // be added to the URL
    array(
      'controller' =&gt; 'someController',
      'action' =&gt; 'anotherAction', 
      'id' =&gt; 1234,
    )); ?&gt;"&gt;Go to this page!&lt;/a&gt;</pre></div></div><div class="section" title="The Partial view helper"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec103"/>The Partial view helper</h3></div></div></div><p>First of<a id="id281" class="indexterm"/> all it<a id="id282" class="indexterm"/> is important to make sure that we actually have a template (<code class="literal">/view/application/index/partial/partial.phtml</code>) that is used as partial content.</p><div class="informalexample"><pre class="programlisting">&lt;div&gt;&lt;?php echo $this-&gt;partial_variable; ?&gt;&lt;/div&gt;</pre></div><p>We then can go to our normal layout and use the <code class="literal">Partial</code> view helper to add our extra template (<code class="literal">/view/application/index/index.phtml</code>):</p><div class="informalexample"><pre class="programlisting">&lt;div&gt;Some Content.&lt;/div&gt;

&lt;div&gt;
  &lt;?php echo $this-&gt;partial(
    './partial/partial.phtml', 
    array(
      'partial_variable' =&gt; 'Partial content!',
    )
  ); ?&gt;
&lt;/div&gt;</pre></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec49"/>How it works…</h2></div></div></div><p>Once we get in to serious development, view helpers cannot be missed. They make sure our code doesn't turn into a spaghetti by keeping the logic as separate as possible (for example) from the HTML. View helpers only work in the view scripts (and if the current view strategy support it, but let's presume it does), so all the examples we give below are only relevant to <code class="literal">.phtml</code> files in the view directory.</p><p>If we have a view helper we can usually instantly use them in the view by calling:</p><div class="informalexample"><pre class="programlisting">$this-&gt;someViewHelper('some-parameter');</pre></div><p>This works because without first instantiating the view helper because the <code class="literal">someViewHelper</code> class has an <code class="literal">__invoke()</code> method defined. This means that it can be called without first needing to be instantiated.</p><p>However, sometimes we have view helpers that cannot be used through the invocation shown before; they actually need to be constructed first. This can then be done by performing the following:</p><div class="informalexample"><pre class="programlisting">$helper = $this-&gt;someViewHelper();
$helper-&gt;someMethod('some-parameter');</pre></div><p>A single view helper can also have multiple public methods available which is mostly used for grouping functionality together. For example a (non-existing in Zend Framework 2) view helper called <code class="literal">Person</code> might have <code class="literal">getAddress($person)</code> and <code class="literal">getName($person)</code> as public methods, which then could be called by using the invoke shown as follows:</p><div class="informalexample"><pre class="programlisting">echo $this-&gt;person()-&gt;getAddress($person);
echo $this-&gt;person()-&gt;getName($person);</pre></div><div class="section" title="Zend\View\Helper\AbstractHelper"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec104"/>Zend\View\Helper\AbstractHelper</h3></div></div></div><p>Technically <a id="id283" class="indexterm"/>
<code class="literal">Zend\View\Helper\AbstractHelper</code> is not a view helper, but we mention it anyway as this is the<a id="id284" class="indexterm"/> class we want to extend with if we would want to create our own view helper. It implements a couple of methods that are required for a view helper class to work correctly.</p></div><div class="section" title="The BasePath view helper explained"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec105"/>The BasePath view helper explained</h3></div></div></div><p>The <code class="literal">BasePath</code> view helper <a id="id285" class="indexterm"/>can be really helpful if we use a custom structure to our application and the public folder is not on the base of a website folder, that is, <code class="literal">/website/public</code>. We can then use <code class="literal">BasePath</code> to let it decide where we are. The <code class="literal">BasePath</code> view helper is usually used more often for static assets such as, images, style sheets, and scripts, which is great to make sure the application stays robust under the change or a root URL.</p></div><div class="section" title="The Doctype view helper explained"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec106"/>The Doctype view helper explained</h3></div></div></div><p>The <code class="literal">Doctype</code> is a very useful<a id="id286" class="indexterm"/> view helper as we tend to forget how those <code class="literal">Doctype</code> helpers were build up again. Instead of looking on the Internet to find out how to declare them again, we can now just use this little gem.</p><p>You can specify the <code class="literal">Doctype</code> helper whenever you like, but it would be wise to do this in the configuration of your view manager to make sure the rest of the application also knows what <code class="literal">Doctype</code> we are<a id="id287" class="indexterm"/> using (sometimes they just want to output different things then).</p><p>The valid <code class="literal">Doctype</code> view helpers we can use are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">XHTML11</li><li class="listitem" style="list-style-type: disc">XHTML1_STRICT</li><li class="listitem" style="list-style-type: disc">XHTML1_TRANSITIONAL</li><li class="listitem" style="list-style-type: disc">XHTML1_FRAMESET</li><li class="listitem" style="list-style-type: disc">XHTML1_RDFA</li><li class="listitem" style="list-style-type: disc">XHTML1_RDFA11</li><li class="listitem" style="list-style-type: disc">XHTML_BASIC1</li><li class="listitem" style="list-style-type: disc">XHTML5</li><li class="listitem" style="list-style-type: disc">HTML4_STRICT</li><li class="listitem" style="list-style-type: disc">HTML4_LOOSE</li><li class="listitem" style="list-style-type: disc">HTML4_FRAMESET</li><li class="listitem" style="list-style-type: disc">HTML5</li></ul></div><p>Setting the <code class="literal">Doctype</code> helper is essential for other view helpers because they (for example in the case of form elements) make rendering decisions based on the selected type. For example a <code class="literal">HTML4_* doctype</code> might render an input fields as <code class="literal">&lt;input type="text"&gt;&lt;/input&gt;</code> while an <code class="literal">XHTML1_STRICT</code> would render it as <code class="literal">&lt;input type="text" /&gt;</code>. The <code class="literal">Doctype</code> helper is more than essential if we want to use the validation service of the W3C.</p></div><div class="section" title="The URL view helper explained"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec107"/>The URL view helper explained</h3></div></div></div><p>A nifty little thing<a id="id288" class="indexterm"/> the URL view helper is, it builds up URL's depending on named route that we have defined in our configuration. This means that if we want to build up a correctly formed URL we can use this view helper to build it up for us.</p></div><div class="section" title="The Partial view helper explained"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec108"/>The Partial view helper explained</h3></div></div></div><p>The <code class="literal">Partial</code> view helper<a id="id289" class="indexterm"/> is particularly helpful when we want to divide our layout into different parts, something that is always useful if we want to make sure our templates are maintainable and in a condition to re-use them in multiple places.</p><p>The directory we store the partial views in is not strictly set, but it is recommended to place them in a location where we can find them whenever we require them.</p></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec50"/>There's more…</h2></div></div></div><p>We only discussed four view helpers which are default in Zend Framework 2, however there are tons more view helpers in the framework by default which are just as useful as well. Personally I would recommend looking through those as well and get to know them a bit as most of them are quite interesting even if you would never use them. Especially the <code class="literal">Cycle</code>, <code class="literal">Gravatar</code>, <code class="literal">HeadStyle</code>, and <code class="literal">HeadTitle</code> view helpers can come in handy when we are building a HTML page set up.</p><p>A complete list of the view helpers is always available in the official Zend Framework 2 documentation.</p></div></div>
<div class="section" title="Creating a global layout template"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Creating a global layout template</h1></div></div></div><p>The view<a id="id290" class="indexterm"/> scripts can be very dynamic but most of the time we need a global template that we want to wrap around the output from our <code class="literal">Action</code> view scripts. This recipe will explain exactly how to do that, and also tells us how that would work.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Getting ready</h2></div></div></div><p>For this recipe a working Zend Framework 2 skeleton application is needed as we will do some creating and editing of some files which are used in there.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec52"/>How to do it…</h2></div></div></div><p>The following is how we set about achieving this:</p><div class="section" title="Creating the main layout file"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec109"/>Creating the main layout file</h3></div></div></div><p>Let's now <a id="id291" class="indexterm"/>create the main file <code class="literal">/module/Application/view/layout/layout.phtml</code> we use to create our layout:</p><div class="informalexample"><pre class="programlisting">&lt;!-- first of all we want to output the doctype --&gt;
&lt;?php echo $this-&gt;doctype(); ?&gt;

&lt;!-- now we add the HTML tag --&gt;
&lt;html&gt;

&lt;!-- enter our head tag --&gt;
&lt;head&gt;
  &lt;!-- we want to output in UTF-8 --&gt;
  &lt;meta charset="utf-8"&gt;

  &lt;!-- let's use the headTitle View Helper to output our 
       website title --&gt;
  &lt;?php echo $this-&gt;headTitle('Awesome website!') ?&gt;

  &lt;!-- make sure mobile browsers get the best of it with 
       the use of the headMeta View Helper, and setting 
       the viewport --&gt;
  &lt;?php echo $this-&gt;headMeta()-&gt;appendName(
    'viewport', 
    'width=device-width, initial-scale=1.0'
  ) ?&gt;

  &lt;!-- add a favicon.ico file reference for older 
       versions of Internet Explorer, as that doesn't 
       pick it up by itself --&gt;
  &lt;?php echo $this-&gt;headLink(array(
    'rel' =&gt; 'shortcut icon', 
    'type' =&gt; 'image/vnd.microsoft.icon', 

    // Use the basePath to find our public folder
    'href' =&gt; $this-&gt;basePath('/images/favicon.ico')
  )) ?&gt;

  &lt;!-- add a style sheet to our template --&gt;
  &lt;?php echo $this-&gt;headStyle()-&gt;appendStyle(
    $this-&gt;basePath('/style.css')
  ); ?&gt;

  &lt;!-- now add a javascript that we need as well, which 
       is only used by Internet Explorer version less 
       than 9 --&gt;
  &lt;?php echo $this-&gt;headScript()-&gt;prependFile(
    $this-&gt;basePath('/script.js'),

    // Non HTML5 browsers need a type set for script 
    // tags
    'text/javascript',

    // Add the extra script conditions
    array(
      'conditional' =&gt; 'lt IE 9',
    )
  ); ?&gt;
&lt;/head&gt;</pre></div><p>We have now <a id="id292" class="indexterm"/>set up the head tag successfully, and used a lot of the view helpers available to make our lives a little bit easier when it comes to adding head-related tags.</p><p>Now let's set up a simple code body and see what we can do there:</p><div class="informalexample"><pre class="programlisting">&lt;!-- let's continue with our body tag now --&gt;
&lt;body&gt;
  &lt;!-- output our main content from our actions --&gt;
  &lt;?php echo $this-&gt;content ?&gt;

  &lt;!-- render any inline scripts that we have --&gt;
  &lt;?php echo $this-&gt;inlineScript(); ?&gt;
&lt;/body&gt;

&lt;!-- we are done here --&gt;
&lt;/html&gt;</pre></div><p>Well that was it, once we output the <code class="literal">content</code> variable, it basically renders the content generated from the controller/action output.</p></div><div class="section" title="Creating the error templates"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec110"/>Creating the error templates</h3></div></div></div><p>The error files are <a id="id293" class="indexterm"/>easily created as they only require a couple of things. Let's create the <code class="literal">/module/Application/view/error/404.phtml</code> file first as that one is fairly straight forward.</p><div class="informalexample"><pre class="programlisting">&lt;h1&gt;404: Page not found!&lt;/h1&gt;

&lt;p&gt;
  &lt;!-- show the message of the 404 error, generated by 
       the framework --&gt;
  &lt;?php echo $this-&gt;message; ?&gt;
&lt;/p&gt;

&lt;!-- there is usually also a separate reason attached, 
     which (if exists) we want to show as well --&gt;
&lt;?php
  if (isset($this-&gt;reason) &amp;&amp; $this-&gt;reason) {
    switch ($this-&gt;reason) {
      case 'error-controller-cannot-dispatch':
        $reason = 'Could not get dispatch controller.';
        break;
      case 'error-controller-invalid':
        $reason = 'Undispatchablecontroller.';
        break;
      case 'error-controller-not-found':
        $reason = 'Controller could not be found.';
        break;
      case 'error-router-no-match':
        $reason = 'URL could not be matched by router.';
        break;
      default:
        $reason = 'Unknown';
        break;
    }

    // Now show the reason to the user
    echo $reason;
  }</pre></div><p>There are more <a id="id294" class="indexterm"/>variables we can use to show the user what went wrong in the routing, and we can also see, for example, what they requested, but usually those are more for development only and not for a production server as we don't want to expose too much data.</p><p>Now let's create the file (<code class="literal">/module/Application/view/error/index.phtml</code>) that will be shown when we end up having an exception, one of the favorite things of a developer (not, obviously).</p><div class="informalexample"><pre class="programlisting">&lt;h1&gt;An error occurred!&lt;/h1&gt;

&lt;p&gt;
  &lt;!-- show the error message, that is the least we can 
       do --&gt;
  &lt;?php echo $this-&gt;message; ?&gt;
&lt;/p&gt;

&lt;!-- now show the exception, if we have turned this on 
     in the configuration --&gt;
&lt;?php
  if (isset($this-&gt;display_exceptions) &amp;&amp; $this-&gt;display_exceptions) :
    // Now let's see if we have an exception, and if it 
    // is the right instance as well
    if(isset($this-&gt;exception) &amp;&amp; $this-&gt;exception instanceof Exception) :
?&gt;

&lt;!-- Yup, it is an exception all right --&gt;
&lt;div&gt;
  Exception:

  &lt;!--Show which class threw the exception --&gt;
  &lt;?php echo get_class($this-&gt;exception); ?&gt;
&lt;/div&gt;

&lt;!-- Show the message thrown --&gt;
&lt;h2&gt;Exception message:&lt;/h2&gt;
&lt;div&gt;&lt;?php echo $this-&gt;exception-&gt;getMessage() ?&gt;&lt;/div&gt;

&lt;!-- And the *beautiful* stack trace as well --&gt;
&lt;h2&gt;Stack trace:&lt;/h2&gt;

&lt;div&gt;
  &lt;?php echo $this-&gt;exception-&gt;getTraceAsString() ?&gt;
&lt;/div&gt;

&lt;?phpendif; ?&gt;&lt;?phpendif; ?&gt;</pre></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec53"/>How it works…</h2></div></div></div><p>The <code class="literal">AbstractActionController</code>
<a id="id295" class="indexterm"/> shows the errors when they occur and also selects the right template (which is defined in the <code class="literal">view_manager</code> configuration) to use for the error messages. The only thing we have to do is to make sure the templates are there.</p><p>A global layout is <a id="id296" class="indexterm"/>an excellent idea if we would be using the MVC model of Zend Framework 2 and are expecting to use the same layout over and over again, which is what happens in most cases.</p><p>Creating a global layout will really make our lives easier, as it is a way of making our code more maintainable, and as a coder that is one of the most important tools in your toolset.</p><p>First of all we need to make sure the <code class="literal">view_manager</code> has been defined properly, this has been described in the <span class="emphasis"><em>Working with View</em></span> recipe, so we assume that we are using the same configuration at this point.</p><p>We used the <code class="literal">inlineScript</code> view helper to make sure the content can also output scripts that are not part of the head tag, but should still be used in the output.</p><p>We would like to use <code class="literal">inlineScript</code> to define any scripts instead of adding them to the template files as we want to separate the JavaScript with the normal HTML content as far as we can (we also want inline scripts to be reusable if we can, and it looks better maintenance wise).</p><p>The error template example is a very basic error document that is shown when an exception is happening. There are even more options we could do after this, for example if there were more exceptions, we could get them by doing <code class="literal">$this-&gt;exception-&gt;getPrevious()</code> and then parsing through them as an array.</p></div></div>
<div class="section" title="Creating reusable Views"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Creating reusable Views</h1></div></div></div><p>In this time of <a id="id297" class="indexterm"/>dynamic applications we have widgets or content that can be used more than once. Instead of getting everything at the same time we want to be able to dynamically load new objects in, or at least not have to do a lot to get functionality working.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Getting ready</h2></div></div></div><p>For this recipe we need nothing more than a working Zend Framework 2 skeleton application.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec55"/>How to do it…</h2></div></div></div><p>In this recipe we'll be <a id="id298" class="indexterm"/>discussing how to create reusable templates and the best way of using them in an application.</p><div class="section" title="Use the Action view helper to get the re-usable content"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec111"/>Use the Action view helper to get the re-usable content</h3></div></div></div><p>The <code class="literal">Action</code> view helper<a id="id299" class="indexterm"/> is a great way of <a id="id300" class="indexterm"/>calling different actions in our code to retrieve other parts of our application:</p><div class="informalexample"><pre class="programlisting">&lt;div class="left"&gt;Some content on the left!&lt;/div&gt;

&lt;div class="right"&gt;
  &lt;?php
    echo $this-&gt;action(
      // The action to call
      'sidebar',

      // The controller to call
      'templates',

      // The module to call
      'application',

      // Parameters to parse along
      array('show' =&gt; true)
    );
  ?&gt;
&lt;/div&gt;</pre></div></div><div class="section" title="Define a child to the ViewModel instance"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec112"/>Define a child to the ViewModel instance</h3></div></div></div><p>First of all<a id="id301" class="indexterm"/> we should create a simple view script (<code class="literal">/module/Application/view/application/template/sidebar.tpl</code>) to output:</p><div class="informalexample"><pre class="programlisting">Hello from the sidebar!</pre></div><p>After that we need to be in the controller (<code class="literal">/module/Application/src/Application/Controller/IndexController.php</code>).</p><div class="informalexample"><pre class="programlisting">public function indexAction() 
{
  // Instantiate our main view model
  $view = new ViewModel();

  // Now let's instantiate our child model
  $child = new ViewModel();

  // For the child we want to render a different 
  // template, namely our sidebar.tpl
  $child-&gt;setTemplate('template/sidebar.tpl');

  // Now add the child to our main view model
  $view-&gt;addChild($child, 'childModel');

  // Return our view model
  return $view;
}</pre></div><p>Now we <a id="id302" class="indexterm"/>have the controller set up, we would want to output the child as well in our view script. We will be using a similar HTML layout as the first method so that we can spot the differences.</p><div class="informalexample"><pre class="programlisting">&lt;div class="left"&gt;Some content on the left!&lt;/div&gt;

&lt;div class="right"&gt;
  &lt;?php echo $this-&gt;childModel; ?&gt;
&lt;/div&gt;</pre></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec56"/>How it works…</h2></div></div></div><p>When we are developing web applications, we find ourselves at a point where we need to re-use the content that we already made before, such as the build-up of a form or maybe the layout of a side bar that we want to use on multiple pages.</p><p>What we can do in that instance is two things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use the <code class="literal">Action</code> view helper to get the re-usable content</li><li class="listitem" style="list-style-type: disc">Define a child to the <code class="literal">ViewModel</code> instance</li></ul></div><p>Both of these methods can be used in different situations, let's explore the both options.</p><div class="section" title="The Action view helper explained"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec113"/>The Action view helper explained</h3></div></div></div><p>We primarily <a id="id303" class="indexterm"/>would want to use this <span class="emphasis"><em>if the re-usable content is outside the current module</em></span>, for example if the content is created by a module that provides page widgets then it can be used anywhere in the application. If we want to use a content that is inside our module, we better use the second option as that is less performance heavy because it doesn't go through the whole routing and dispatching process like the first option does.</p><p>What this view helper does is call an action within a view script, and post the results of that action call to the current view script.</p><p>If we look at the first example, it makes the call to the action and renders the output inside the current view script. The difference between this and the use of a partial view script is that this will go through the whole routing and dispatching process, while a partial simply displays the rendered output. If we, for example, need to get records from the database, a partial just wouldn't cut it.</p></div><div class="section" title="Defining a child to a ViewModel instance explained"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec114"/>Defining a child to a ViewModel instance explained</h3></div></div></div><p>This method <a id="id304" class="indexterm"/>of rendering re-usable content is primarily used <span class="emphasis"><em>when the re-usable content is inside the current module</em></span>, for example when we would like to use a specific overview table that relies on requires more intelligence than, for instance, a view helper would be able to provide. The content we are rendering would not require us to mess around in different modules, we'd rather stay away from relying on other modules from within our controller. We generally want to keep the modules as separate as possible so that we are able to run the application, even if one of the other modules is not available.</p><p>If we look at the example shown in <span class="emphasis"><em>How it works</em></span> now, we can see that it has slightly more work to do in this method instead of the view helper class, but the difference is that the view helper class needs to do more in the background to get it all to work.</p></div><div class="section" title="Pros and cons"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec115"/>Pros and cons</h3></div></div></div><p>Some might disagree<a id="id305" class="indexterm"/> when we say that we primarily should use the <code class="literal">Action</code> view helper<a id="id306" class="indexterm"/> outside the current module, and there are probably good reasons for why we should. One of the arguments against it is that it is simpler for the developer (or designer in most cases) to get the content from different locations without being bound by adding it as a <code class="literal">ViewModel</code> child in the controller. However, the view helper class does require the framework to find the action, controller and module first, render them, and then output them.</p><p>Although simpler in set up, it does strain the web application more if we use this option without good reason. Sometimes it is just better to code more and use the benefit of the speed of the application, then be lazy and let the application reduce its speed.</p><p>Sure everything has its pros and cons, so we should always consider the situation first to make sure we get the most maintainable and re-usable code possible.</p></div></div></div>
<div class="section" title="Using view strategies/renderers"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Using view strategies/renderers</h1></div></div></div><p>Normally we <a id="id307" class="indexterm"/>will use the View to output HTML, but sometimes we want a more diverse way of outputting for example JSON or XML. This recipe will provide us with enough information to accomplish this easily.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Getting ready</h2></div></div></div><p>We simply require the Zend Framework 2 skeleton application to get us going with this recipe. Nothing exotic is required.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec58"/>How to do it…</h2></div></div></div><p>Using different view strategies and renderers is a common practice in an application. In this recipe we'll explain how to do that.</p><div class="section" title="Adding a view strategy"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec116"/>Adding a view strategy</h3></div></div></div><p>We can <a id="id308" class="indexterm"/>easily <a id="id309" class="indexterm"/>add a view strategy to our application by simply appending the <code class="literal">view_manager</code> configuration in the module configuration file (<code class="literal">/module/Restful/config/module.config.php</code>) as shown as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php

return array(
  'view_manager' =&gt;array(
    'strategies' =&gt; array(
      // This could also be ViewFeedStrategy if we want 
      // to output as a feed
      'ViewJsonStrategy',
    ),
  ),
);</pre></div></div><div class="section" title="The JSON strategy"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec117"/>The JSON strategy</h3></div></div></div><p>If we <a id="id310" class="indexterm"/>receive output <a id="id311" class="indexterm"/>from the JSON strategy, it might look very much like the following:</p><div class="informalexample"><pre class="programlisting">{
  "hello": "My name is",
  "first": "Terrible Richard",
  "address: {
    "street": "12 Coronation Street",
    "postcode": "SE1 2PE",
    "city": "London"
  }
}</pre></div></div><div class="section" title="The Feed strategy"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec118"/>The Feed strategy</h3></div></div></div><p>Using the <a id="id312" class="indexterm"/>Feed strategy<a id="id313" class="indexterm"/> is quite similar to the other strategies, as we can see in the following example:</p><div class="informalexample"><pre class="programlisting">// Assume we have a controller set up wrapped around 
// this
public function indexAction()
{
  // Start a new feed
  $feed = new \Zend\Feed\Writer\Feed();

  // Set the feed name/title
  $feed-&gt;setTitle('My Awesome Feed!');

  // Set the link to where the feed can be found, and 
  // the format of the feed
  $feed-&gt;setFeedLink(
    'http://winter.example.com/rss', 
    'atom'
  );

  // Who is the author of our feed
  $feed-&gt;addAuthor(array(
     'name' =&gt; 'N. Stark',
     'email' =&gt; 'ned@winter.example.com',
     'uri' =&gt; 'http://winter.example.com',
  ));

  // Add some description to the feed
  $feed-&gt;setDescription('Loremipsum..');
  $feed-&gt;setLink('http://winter.example.com');
  $feed-&gt;setDateModified(time());</pre></div><p>We have now set up our main data, which will be needed to generate our feed. Now let's add some sample data to the output:</p><div class="informalexample"><pre class="programlisting">$data = array(
  array(
    'title' =&gt; 'Post 1', 
    'link' =&gt; 'http://winter.example.com/post/1',
    'description' =&gt; 'Loremipsum..',
    'date_created' =&gt; strtotime('2001-01-01 12:03:23'),
    'date_modified' =&gt; strtotime('2001-02-12 11:05:24'),
  ),

  // More entries here
);</pre></div><p>Now we <a id="id314" class="indexterm"/>need to parse through the data (I know, it's a bit weird as we just declared it, but in reality this would never happen) and put them in the feed as an entry:</p><div class="informalexample"><pre class="programlisting">foreach ($data as $row) {
  $feed-&gt;addEntry(
    $feed-&gt;createEntry()
         -&gt;setTitle($row['title'])
         -&gt;setLink($row['link'])
         -&gt;setDescription($row['description'])
         -&gt;setDateModified($row['date_modified'])
         -&gt;setDateCreated($row['date_created'])
  );
}</pre></div><p>Now all that is left to do is export the feed to a specific format and add it to the actual <code class="literal">FeedModel</code> class.</p><div class="informalexample"><pre class="programlisting">// Export our feed to RSS style
$feed-&gt;export('rss');

// Instantiate a new feed model
$feedModel = new FeedModel();

// Set the created feed in the feed model
$feedModel-&gt;setFeed($feed); 

// Action done, return the feed model
return $feedModel;</pre></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec59"/>How it works…</h2></div></div></div><div class="section" title="The view strategy class"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec119"/>The view strategy class</h3></div></div></div><p>The default <a id="id315" class="indexterm"/>view strategy <a id="id316" class="indexterm"/>used in the Zend Framework 2 skeleton application is the <code class="literal">PhpRenderer</code> class, which does nothing more than search for a <code class="literal">.phtml</code> file in a defined location; by default this would be <code class="literal">/module/ModuleName/view</code>. The <code class="literal">PhpRenderer</code> class is able to parse PHP inside the view scripts, which makes it handy (but also very familiar) to perform some last minute scripting for our layout, such as parsing through records to create a table or displaying a username, for example.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Although PHP is allowed in the <code class="literal">PhpRenderer</code> class, it should be mentioned that the developer should be wary of putting business logic in the view script. Logic should be placed in the model or at least the controller as it was never intended to reside in the view script.</p></div></div><p>This strategy will always be used whenever there is no other strategy available.</p></div><div class="section" title="The default view strategies"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec120"/>The default view strategies</h3></div></div></div><p>There are <a id="id317" class="indexterm"/>a small number <a id="id318" class="indexterm"/>of view strategies readily available in Zend Framework 2, they are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The PHP strategy (default)</li><li class="listitem" style="list-style-type: disc">The JSON strategy</li><li class="listitem" style="list-style-type: disc">The Feed strategy</li></ul></div></div><div class="section" title="The JSON strategy explained"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec121"/>The JSON strategy explained</h3></div></div></div><p>A JSON object <a id="id319" class="indexterm"/>is short for JavaScript Object Notation and is a text based, human-readable output format that is mainly used in modern web services around the world. It is derived from the JavaScript language and thus, resembles a lot of its features.</p><p>This is probably a nice example as we have put new lines in the output, while the actual JSON strategy will never contain that. But hey, if it is server-to-server talk only, why would we care?</p><p>The JSON strategy doesn't require a template or view script as it basically parses through the variables used in the view model, simple!</p></div><div class="section" title="The Feed strategy explained"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec122"/>The Feed strategy explained</h3></div></div></div><p>The Feed strategy <a id="id320" class="indexterm"/>outputs an XML news feed that can be used , for example, by users to subscribe on as an RSS or RSS2 formatted feed. Using the view model of the Feed strategy is a bit different though as directly setting the variables in the view model directly might be a tricky thing to do. Instead of that you can use a <code class="literal">Zend\Feed\Writer\Feed</code> object to determine the layout of your feed, and then feeding it to the <code class="literal">FeedModel</code> by passing it as a parameter to the <code class="literal">setFeed</code> method.</p></div><div class="section" title="More about view strategies"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec123"/>More about view strategies</h3></div></div></div><p>The nice thing <a id="id321" class="indexterm"/>about Zend Framework 2 is that it isn't really hard to change the output, as it comes with a technique called view strategies, and in effect view renderers.</p><p>A view strategy is a class that identifies a model and returns a view renderer, which on its turn renders the output of the content. The view strategy will determine which renderer to use and how to use it.</p><p>Most of the time view strategies come with their own view model as well, which is to make sure the content we want to output is compatible with the renderer. The view strategy will, upon receiving the model, determine if it can or cannot render a certain model.</p><p>For example, the JSON renderer in the framework only renders models of the type <code class="literal">JsonModel</code> and will, when receiving a <code class="literal">ViewModel</code>, do nothing as it is technically not compatible with the renderer.</p><p>Sometimes we just need to output content in a different way. If we are talking about REST services, RSS feeds, or just something custom, we should always be able to switch between different output formats without needing to do too much work.</p></div></div></div>
<div class="section" title="Using context switching for a different output"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Using context switching for a different output</h1></div></div></div><p>Not only do we want<a id="id322" class="indexterm"/> to be able to output the content through different view strategies, we sometimes also want to do this on demand, so that we can switch the output, for example, from HTML to JSON by simply changing the headers in our request.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Getting ready</h2></div></div></div><p>In some cases (for example, in the REST servers) it is necessary to switch the response output of the content depending on what the user asks for. The user can add an <code class="literal">Accept</code> header to let the server know which output formats it accepts, for example <code class="literal">application/json</code>, and <code class="literal">text/html</code>.</p><p>What we are going to do is create a simple website that will output a <code class="literal">text/html</code> format on default (which is normal), but it will also output a JSON string whenever we have <code class="literal">Accept: */json</code> in our header.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec61"/>How to do it…</h2></div></div></div><p>Sometimes we want to cater not just to the users that view our website, but to a lot of different audiences, for example, the Feed readers or other applications. Therefore we'll discuss how to switch contexts in this recipe.</p><div class="section" title="Define multiple strategies to output"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec124"/>Define multiple strategies to output</h3></div></div></div><p>First we <a id="id323" class="indexterm"/>want to make sure we have the JSON view strategy lined up so that we can easily switch between views. We can do this by adding <code class="literal">ViewJsonStrategy</code> in the <code class="literal">/module/Restful/config/module.config.php</code> as shown as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php

return array(
  // Add the JSON strategy to the view manager for our 
  // output
  'view_manager' =&gt;array(
    'strategies' =&gt; array(
      'ViewJsonStrategy',
    ),
  ),
);</pre></div></div><div class="section" title="Determine the view model based on the Accept header"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec125"/>Determine the view model based on the Accept header</h3></div></div></div><p>In the <a id="id324" class="indexterm"/>controller there is a nifty little controller plugin called <code class="literal">AcceptableViewModelSelector</code>, which can be used to return a view model that is based on the <code class="literal">Accept</code> header.</p><p>So to make things a bit clear, we first want to define which kind of models we want to support in our output. Let's create a property in our controller that regulates which view models we are supporting:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Restful\Controller;

use Zend\Mvc\Controller\AbstractActionController;

class IndexController extends AbstractActionController
{
  protected $acceptCriteria = array(
    'Zend\View\Model\ViewModel' =&gt;array(
      'text/html',
    ),
    'Zend\View\Model\JsonModel' =&gt;array(
      'application/json',
      'text/json',
    ),
  );
}</pre></div><p>As we can see here, we will support two models in order of priority. First of all we want the default view model to use the normal <code class="literal">PhpRenderer</code> class, so that users will get to see the normal HTML output. Second of all we want any <code class="literal">application/json</code> or <code class="literal">text/json</code> to be rendered by our <code class="literal">JsonRenderer</code> class.</p><p>Now let's create a simple <code class="literal">indexAction</code> method and make use of the view model's selecting abilities there:</p><div class="informalexample"><pre class="programlisting">public function indexAction()
{
  // Get the right view model that goes with the Accept-
  // header
  $viewModel = $this-&gt;acceptableViewModelSelector(
    $this-&gt;acceptCriteria
  );

  // Set the variables in the given view model
  $viewModel-&gt;setVariables(array('output' =&gt; array(
    'one' =&gt; 'Row, row, row your boat,',
    'two' =&gt; 'gently down the stream.',
    'three' =&gt; 'Merrily, merrily, merrily, merrily,',
    'four' =&gt; 'life is but a dream.',
  )));

  // output the view model
  return $viewModel;
}</pre></div><p>And that's<a id="id325" class="indexterm"/> how we do it folks! That was as simple as it can get as <code class="literal">AcceptableViewModelSelector</code> does all the work for us, and the only thing we have to do is make sure everything is declared in the model.</p><p>When we now add a view script for the normal <code class="literal">PhpRenderer</code> class, so that it renders our normal <code class="literal">text/html</code> output fine, we can say for sure that everything is done. Please make sure that this view script (<code class="literal">/module/Restful/view/restful/index/index.phtml</code>) resides in our new <code class="literal">Restful</code> module.</p><div class="informalexample"><pre class="programlisting">&lt;table&gt;
  &lt;tr&gt;
    &lt;!-- output our variables --&gt;
    &lt;?php foreach ($this-&gt;output as $col) : ?&gt;
    &lt;td&gt;&lt;?php echo $col ?&gt;&lt;/td&gt;
    &lt;?php endforeach; ?&gt;
  &lt;/tr&gt;
&lt;/table&gt;</pre></div><p>The output for a user with <code class="literal">Accept: application/json</code> header would look like the following, For this we need no view script as the renderer immediately outputs this.</p><div class="informalexample"><pre class="programlisting">{"output":{"one":"Row, row, row your boat,","two":"gently down the stream.","three":"Merrily, merrily, merrily, merrily,","four":"life is but a dream."}}</pre></div><p>The default <code class="literal">PhpRenderer</code> output will look like the following:</p><div class="informalexample"><pre class="programlisting">&lt;table&gt;
  &lt;tr&gt;
    &lt;!-- output our variables --&gt;
    &lt;td&gt;Row, row, row your boat,&lt;/td&gt;
    &lt;td&gt;gently down the stream. &lt;/td&gt;
    &lt;td&gt;Merrily, merrily, merrily, merrily, &lt;/td&gt;
    &lt;td&gt;life is but a dream.&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</pre></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec62"/>How it works…</h2></div></div></div><p>
<code class="literal">AcceptableViewModelSelector</code> looks at the header sent with the request to determine which view model <a id="id326" class="indexterm"/>to use. It determines the model by looking in the <code class="literal">array</code> we parse into it and looking at the different <code class="literal">Accept</code> headers we have defined that we support.</p><p>Next it will take the key of that specific <code class="literal">array</code> item, and that will be the view model that will be instantiated.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec63"/>There's more…</h2></div></div></div><p>To test out different headers, I like to use the Mozilla Firefox browser with the Header Tool add-on (<a class="ulink" href="https://addons.mozilla.org/en-us/firefox/addon/header-tool">https://addons.mozilla.org/en-us/firefox/addon/header-tool</a>) installed, or similar Chrome extensions, or if we are feeling particularly brave, just the command line cURL. There you can just type the header you would like to send along, and turn it either on or off. However, there are different ways of sending headers as well. It depends on how you prefer doing things.</p></div></div>
<div class="section" title="Writing a custom view strategy/renderer"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Writing a custom view strategy/renderer</h1></div></div></div><p>Nothing is more <a id="id327" class="indexterm"/>exciting in coding than developing your own bits of custom features that integrate with the framework. In this recipe we will be discussing how to create our own XML view strategy. We will show you how to simply create the basis for a new strategy without too much of a bother.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec64"/>How to do it…</h2></div></div></div><p>Sometimes the default strategies and renderers provided are not enough for a specific situation, so let's talk through on how to create our own view strategy/renderer.</p><div class="section" title="Creating the XmlOutput renderer"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec126"/>Creating the XmlOutput renderer</h3></div></div></div><p>Let us see first <a id="id328" class="indexterm"/>on how <a id="id329" class="indexterm"/>our renderer would look like, as that is possibly one of the laziest classes we will ever code. We will do this in a new class located in <code class="literal">/module/XmlOutput/src/XmlOutput/View/Renderer/XmlRenderer.php</code>.</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace XmlOutput\View\Renderer;

use Zend\View\Renderer\PhpRenderer;

/**
 * This is the XML Renderer, which is as you can see 
 * empty as we don't really need
 * to do anything to get this one going, the PhpRenderer
 * basically does everything
 * we need. 
 */
class XmlRenderer extends PhpRenderer {}</pre></div><p>The <a id="id330" class="indexterm"/>code <a id="id331" class="indexterm"/>for this model is very straightforward as we don't really need to do a lot of coding to get it working, we'll do this in the <code class="literal">/module/XmlOutput/src/XmlOutput/View/Model/XmlModel.php</code> file.</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace XmlOutput\View\Model;

use Zend\View\Model\ViewModel;

/**
* This is the XML View Model
*/
class XmlModel extends ViewModel
{
  
  /**
   * XML probably won't need to be captured into a
   * a parent container by default.
   *
   * @var string
   */
  protected $captureTo = null;
  
  /**
   * XML is usually terminal
   *
   * @var bool
   */
  protected $terminate = true;
  
  /**
   * UTF-8 Default Encoding
   * @var string
   */
  protected $encoding = 'utf-8';
  
  /**
   * Content Type Header
   * @var string
   */
  protected $contentType = 'application/xml';
  
  /**
   * Set the encoding
   *
   * @param string $encoding
   * @return XmlModel
   */
  public function setEncoding($encoding) 
  {
    $this-&gt;encoding = $encoding;
    return $this;
  }
  
  /**
   * Get the encoding
   *
   * @return string
   */
  public function getEncoding()
  {
    return $this-&gt;encoding;
  }</pre></div><p>In the previous code snippet we have a simple getter and setter for the encoding which will usually be UTF-8, as<a id="id332" class="indexterm"/> it is also declared as the default value in the property.</p><div class="informalexample"><pre class="programlisting">  /**
   * Set the content type
   *
   * @param string $contentType
   * @return XmlModel
   */
  public function setContentType($contentType) 
  {
    $this-&gt;encoding = $contentType;
    return $this;
  }

  /**
   * Get the content type
   *
   * @return string
   */
  public function getContentType() 
  {
    return $this-&gt;contentType;
  }	
}</pre></div><p>Now we need <a id="id333" class="indexterm"/>to create the more exciting part, the <code class="literal">XmlStrategy</code> (located in <code class="literal">/module/XmlOutput/src/XmlOutput/View/Strategy/XmlStrategy.php</code>), which is the part that will actually tell the framework if, what, and how to render the content by handling the two View events (which is required).</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace XmlOutput\View\Strategy;

use XmlOutput\View\Model\XmlModel;
use XmlOutput\View\Renderer\XmlRenderer;
use Zend\EventManager\EventManagerInterface;
use Zend\EventManager\ListenerAggregateInterface;
use Zend\View\ViewEvent;

/**
 * This is the XML View Strategy
 */
class XmlStrategy implements ListenerAggregateInterface
{
  /**
   * @var \Zend\Stdlib\CallbackHandler[]
   */
  protected $listeners = array();

  /**
   * @var XmlRenderer
   */
  protected $renderer;</pre></div><p>Once again <a id="id334" class="indexterm"/>we defined all <a id="id335" class="indexterm"/>of the properties which we needed. The first one <code class="literal">$listeners</code> will contain an array of <code class="literal">CallbackHandler</code> which we will use to attach and detach events to the <code class="literal">EventManager</code> instance.</p><p>The second member variable <code class="literal">$renderer</code> will store our <code class="literal">XmlRenderer</code> which we just created.</p><div class="informalexample"><pre class="programlisting">  /**
   * Constructor
   *
   * @param XmlRenderer $renderer
   */
  public function __construct(XmlRenderer $renderer) 
  {
    $this-&gt;renderer = $renderer;
  }</pre></div><p>Now we have defined our simple constructor, which basically assigns the given <code class="literal">XmlRenderer</code> class to our local property for safekeeping, which is the typical behavior of a rendering strategy. Next, we'll continue to implement the event handler.</p><div class="informalexample"><pre class="programlisting">  /**
   * Make sure we only use our renderer when we are also 
   * using our XmlModel.
   *
   * @param ViewEvent $e
   * @return null|XmlRenderer
   */
  public function selectRenderer(ViewEvent $e) 
  {
    if (!$e-&gt;getModel() instanceof XmlModel) {
      // This is not our type of model, can't do 
      // anything
      return;
    }

    return $this-&gt;renderer;
  }

  /**
   * We can inject the response now with the XML content 
   * and the appropriate Content-Type header
   *
   * @param ViewEvent $e
   * @return void
   */
  public function injectResponse(ViewEvent $e) 
  {
    if ($e-&gt;getRenderer() !== $this-&gt;renderer) {
      // The renderer we got is not ours, returning
      return;
    }

    $result = $e-&gt;getResult();

    if (is_string($result)) {
      // String is empty, we cannot output anything
      return;
    }

    $model = $e-&gt;getModel();
    $response = $e-&gt;getResponse();
    $response-&gt;setContent($result);
    $headers = $response-&gt;getHeaders();
    $charset = '; charset='. $model-&gt;getEncoding(). ';';

    $headers-&gt;addHeaderLine(
      'content-type', 'application/xml'. $charset
    );
  }</pre></div><p>The last bit we need to do for the strategy is to attach and detach our events. The events methods in this <a id="id336" class="indexterm"/>case being <code class="literal">selectRenderer</code> and <code class="literal">injectResponse</code>, which will be triggered at different points in the code. The first one <a id="id337" class="indexterm"/>will be triggered when the event <code class="literal">ViewEvent::EVENT_RENDERER</code> happens and the second one will be triggered on <code class="literal">ViewEvent::EVENT_RESPONSE</code>. Once the framework has used everything it needs, it will call the <code class="literal">detach</code> method, and we then need to make sure all our events will be detached.</p><div class="informalexample"><pre class="programlisting">  /**
   * Let's attach the aggregate to the specified event 
   * manager
   *
   * @param EventManagerInterface $events
   * @param int $priority
   * @return void
   */
  public function attach(EventManagerInterface $events, $priority = 1) 
  {
    $this-&gt;listeners[] = $events-&gt;attach(
          ViewEvent::EVENT_RENDERER, 
          array($this, 'selectRenderer'), 
          $priority
    );
 
    $this-&gt;listeners[] = $events-&gt;attach(
          ViewEvent::EVENT_RESPONSE, 
          array($this, 'injectResponse'),
          $priority
    );
  }

  /**
   * We can detach the aggregate listeners from the 
   * specified event manager
   *
   * @param EventManagerInterface $events
   * @return void
   */
  public function detach(EventManagerInterface $events) 
  {
    foreach($this-&gt;listeners as $index =&gt; $listener) {
      if ($events-&gt;detach($listener)) {
        unset($this-&gt;listeners[$index]);
      }
    }
  }
}</pre></div><p>Next up is something we didn't use before, which is the <code class="literal">ViewXmlStrategyFactory</code> class. The <a id="id338" class="indexterm"/>factory <a id="id339" class="indexterm"/>basically instantiates the <code class="literal">XmlStrategy</code> class (in this case) and makes sure everything is instantiated correctly. We'll create our new file here: <code class="literal">/module/XmlOutput/src/XmlOutput/Service/ViewXmlStrategyFactory.php</code>
</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace XmlOutput\Service;

use Zend\ServiceManager\FactoryInterface;
use Zend\ServiceManager\ServiceLocatorInterface;
use XmlOutput\View\Strategy\XmlStrategy;

/**
 * Creates the service for the Xml Strategy.
 */
class ViewXmlStrategyFactory implements FactoryInterface
{
  /**
   * Creates and returns the XML view strategy
   *
   * @param ServiceLocatorInterface $serviceLocator
   * @return XmlStrategy
   */
  public function createService(ServiceLocatorInterface $serviceLocator) 
  {
    return new XmlStrategy($serviceLocator-&gt;get('ViewXmlRenderer'));
  }
}</pre></div><p>That's it, as we can see it is not a lot, and only the <code class="literal">createService</code> method is being defined in the <a id="id340" class="indexterm"/>class. In that method the only thing<a id="id341" class="indexterm"/> we do is get the <code class="literal">ViewXmlRenderer</code> parameter and make sure the <code class="literal">XmlStrategy</code> class is constructed with that renderer as a parameter.</p><p>Now let's take a look at <code class="literal">ViewXmlRendererFactory</code>(located in <code class="literal">/module/XmlOutput/src/XmlOutput/Service/ViewXmlRendererFactory.php</code>), which is also a factory but now for the renderer.</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace XmlOutput\Service;

use XmlOutput\View\Renderer\XmlRenderer;
use Zend\ServiceManager\FactoryInterface;
use Zend\ServiceManager\ServiceLocatorInterface;

/**
 * Creates the service for the Xml Renderer.
 */
class ViewXmlRendererFactory implements FactoryInterface
{
  /**
   * Creates and returns the XML view renderer
   *
   * @param ServiceLocatorInterface $serviceLocator
   * @return XmlRenderer
   */
  public function createService(ServiceLocatorInterface $serviceLocator) 
  {
    $renderer = new XmlRenderer();

    // Set the View resolvers and helper managers.
    $renderer-&gt;setResolver(
      $serviceLocator-&gt;get('ViewResolver')
    );

    $renderer-&gt;setHelperPluginManager(
      $serviceLocator-&gt;get('ViewHelperManager')
    );

    return $renderer;
  }
}</pre></div><p>Although this <code class="literal">createService</code> method was more work than the one before, it is still a very light method. <a id="id342" class="indexterm"/>The only thing <a id="id343" class="indexterm"/>that really happens here is that the <code class="literal">XmlRenderer</code> class is instantiated, and it made sure <code class="literal">ViewResolver</code> and <code class="literal">ViewHelperManager</code> are set.</p><p>Now we have set up our basic functionality, let's tie it all together so that we can start using it!</p><p>First of all we need to create the <code class="literal">/module/XmlOutput/config/module.config.php</code> file to make sure our services are instantiated properly, and our view manager knows the new strategy we offer.</p><div class="informalexample"><pre class="programlisting">&lt;?php
  return array(
    // Set our factories, so our service manager can find 
    // them
    'service_manager' =&gt;array(
      'factories' =&gt; array( 
        'ViewXmlStrategy' =&gt; 'XmlOutput\Service\ViewXmlStrategyFactory', 
        'ViewXmlRenderer' =&gt; 'XmlOutput\Service\ViewXmlRendererFactory'
    ), 
  ), 

  // Add our strategy to the view manager for our output
  'view_manager' =&gt;array(
    'strategies' =&gt; array(
      'ViewXmlStrategy',
    ),
  ),
);</pre></div><p>That was rather painless, as we can simply tell <code class="literal">serviceManager</code> where everything is located and it will work immediately.</p><p>The last thing we need to create in our new <code class="literal">XmlOutput</code> module is the <code class="literal">Module.php</code> file, which is basically the same as the default <code class="literal">Module.php</code> that comes with the Application module. We can simply <a id="id344" class="indexterm"/>copy that one over, change the namespace in the file and we are done. The file should be located in <code class="literal">/module/XmlOutput/Module.php</code>.</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace XmlOutput;

use Zend\Mvc\ModuleRouteListener;
use Zend\Mvc\MvcEvent;

class Module
{
  public function onBootstrap(MvcEvent $e)
  {
    $eventManager= $e-&gt;getApplication()-&gt;getEventManager();

    $moduleRouteListener = new ModuleRouteListener();
    $moduleRouteListener-&gt;attach($eventManager);
  }

  public function getConfig()
  {
       return include __DIR__. '/config/module.config.php';
  }

  public function getAutoloaderConfig()
  {
    return array(
      'Zend\Loader\StandardAutoloader' =&gt;array(
        'namespaces' =&gt; array(
          __NAMESPACE__ =&gt; __DIR__ . '/src/' .__NAMESPACE__,
        ),
      ),
    );
  }
}</pre></div><p>Now the <code class="literal">/config/application.config.php</code> file needs to have our new module added, so that the <a id="id345" class="indexterm"/>framework will try to<a id="id346" class="indexterm"/> instantiate that module as well. We can just add <code class="literal">XmlOutput</code> to the modules array and we are done, nothing else needs changing in there.</p><div class="informalexample"><pre class="programlisting">return array(
  // This should be an array of module namespaces used 
  // in the application.
  'modules' =&gt; array(
    'Application',

    // Add our module to this array
    'XmlOutput',
  ),

  // After this comes the rest of the file, but that is 
  // irrelevant at the moment.
);</pre></div><p>Everything is ready and set up for use, so now it is time to actually get the ball rolling and output something to XML. First up is using <code class="literal">XmlModel</code> in our <code class="literal">indexAction</code> of the <code class="literal">IndexController</code> (located in <code class="literal">/module/Application/src/Application/Controller/IndexController.php</code>). We will just assign some variables to <code class="literal">XmlModel</code> and return this immediately, no need for anything fancy now.</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use XmlOutput\View\Model\XmlModel;

class IndexController extends AbstractActionController
{
  public function indexAction()
  {
    return new XmlModel(array(
      "some_variable" =&gt; "Awesome!",
      "why_not_another_one" =&gt; "While we are here?"
    ));
  }
}</pre></div><p>Once we have done that, we can build up our view script (located in <code class="literal">/module/Application/view/application/index/index.phtml</code>) with the necessary XML.</p><div class="informalexample"><pre class="programlisting">&lt;nodes&gt;
  &lt;variable_1&gt;&lt;?php
    echo $this-&gt;some_variable;
  ?&gt;&lt;/variable_1&gt;
  &lt;variable_2&gt;&lt;?php
    echo $this-&gt;why_not_another_one; 
  ?&gt;&lt;/variable_2&gt;
&lt;/nodes&gt;</pre></div><p>And that is it! Once <a id="id347" class="indexterm"/>we run it, we <a id="id348" class="indexterm"/>can now see that our HTTP headers are set to <code class="literal">application/xml</code> and that the output is the XML we have just put in. Obviously this is nothing fancy, but it is to show how easy it is to just create our own view strategy.</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec65"/>How it works…</h2></div></div></div><p>Because we added our factories to the <code class="literal">ServiceManager</code>, we can easily get them to use by their aliases <code class="literal">ViewXmlStrategy</code> and <code class="literal">ViewXmlRenderer</code>. And because we told the <code class="literal">ViewManager</code> that our new strategy <code class="literal">ViewXmlStrategy</code> exists, we can get the ball rolling.</p><p>As we would use the <code class="literal">XmlModel</code> in our controller, the framework will iterate through all the view strategies to determine the proper strategy to use. Once it has found the strategy it needs, it will trigger the <code class="literal">EVENT_RENDERER</code> and <code class="literal">EVENT_RESPONSE</code> events, which in turn will trigger our strategy methods. These methods will determine the output of our content.</p><p>Our renderer makes sure the content is rendered properly. In our case we took the lazy way out and let <code class="literal">PhpRenderer</code> basically do all the work, this can however vary per renderer.</p><p>We are creating this new view strategy as a separate module, with separate namespaces so that we can easily transfer this to another application if we ever need to. And of course it comes with greater maintainability when we separate pieces of functionality as well.</p><p>When we are done we can easily extend the classes further as we wish, but for now let's keep it basic.</p><p>There are five files that need to be created before we can have at least the most basic form of a custom view strategy; the files need to be of the following forms:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Renderer</li><li class="listitem" style="list-style-type: disc">Model</li><li class="listitem" style="list-style-type: disc">Strategy</li><li class="listitem" style="list-style-type: disc">Strategy Factory</li><li class="listitem" style="list-style-type: disc">Renderer Factory</li></ul></div><p>The first three we already know as we've discussed in this chapter, the last two Factory ones', however, are new to us.</p><div class="section" title="The XmlRenderer and XmlModel"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec127"/>The XmlRenderer and XmlModel</h3></div></div></div><p>Because we just want<a id="id349" class="indexterm"/> to output XML as a string, we will be using the <code class="literal">PhpRenderer</code> as that does the exact same thing as we want it to do.</p><p>Next up is coding the model. As described earlier, the model will be used in the controller to store variables which we can then use in the View. We will be creating the XmlModel so that when we use this model in our controller our framework knows we want to output with our <code class="literal">XmlStrategy</code>.</p><p>As we can see we made all the properties in the <code class="literal">XmlModel</code> protected, because these properties are protected in the class we are trying to extend (<code class="literal">ViewModel</code>) as well. It is necessary while extending a property to give it the same access level or lower. In this case it is protected, which means the lower option would be public. Private, however, would result in a fatal error shown as follows:</p><div class="informalexample"><pre class="programlisting">PHP Fatal error:  Access level to XmlOutput\View\Model\XmlModel::$captureTo must be protected (as in class Zend\View\Model\ViewModel) or weaker in /var/www/module/XmlOutput/src/XmlOutput/View/Model/XmlModel.php on line 0</pre></div><p>The last bit we need to do in the<a id="id350" class="indexterm"/> <code class="literal">XmlModel</code> is create the getter and setter for the content type, which in our case would become <code class="literal">application/xml</code>, because we want to output XML, not plain text.</p></div><div class="section" title="The XmlStrategy"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec128"/>The XmlStrategy</h3></div></div></div><p>In<a id="id351" class="indexterm"/> <code class="literal">selectRenderer</code> we want to make sure that the model we have is also the model we expect it to be. If this is not the case we cannot return a renderer, meaning that the framework needs to search for a different kind of renderer. For example, the use of a <code class="literal">ViewModel</code> instance would result in <code class="literal">selectRenderer</code> returning null, which would tell the framework to search for another suitable strategy. In this case it might be the <code class="literal">PhpStrategy</code>, which in this case would accept <code class="literal">ViewModel</code> as a valid model, and that is how the view strategy communicates to the framework to tell it if he can use the model or not.</p><p>The <code class="literal">injectResponse</code> is a method that will ready the content for output, and makes sure that the content type is set in the headers as well. The <code class="literal">ViewEvent</code> given as a parameter that contains all the collected information we need, such as the <code class="literal">XmlModel</code>, and also its Response. The next bit of code will tie the last two methods we just created together and use them as handlers for the respective <code class="literal">ViewEvent::EVENT_RENDERER</code> and <code class="literal">ViewEvent::EVENT_RESPONSE</code> events.</p></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec66"/>There's more…</h2></div></div></div><p>We said before we were a bit lazy with the renderer, basically putting off any of the work by putting all of the work in the hands of the <code class="literal">PhpRenderer</code>, which in turn basically rendered the view script containing the XML. Naturally one would desire a renderer which makes the use of view scripts obsolete, and just creates the XML from an array in the <code class="literal">XmlModel</code>.</p><p>So yes, there is a lot more that can be said, but the real fun starts if we start exploring the different ways of rendering content.</p></div></div></body></html>