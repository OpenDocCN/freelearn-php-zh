- en: Chapter 4. Using View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using view helpers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a global layout template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating reusable Views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using view strategies/renderers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using context switching for a different output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a custom view strategy/renderer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we are going to talk about using View, something that we have
    briefly mentioned in a couple of places before. View was created for the benefit
    of the developer, to strictly separate everything frontend with everything backend.
    This way backend developers can focus on controllers and models, while frontend
    developers can work in Views. Another great benefit of View is that View decides
    how the data is being outputted, so in most cases this would be HTML, in other
    cases maybe JSON and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We will show you in the last recipe of the chapter how to make our own customizations
    as well, so that we fully understand how everything works.
  prefs: []
  type: TYPE_NORMAL
- en: Working with View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: View can be considered very important as it actually renders the content that
    is being outputted to the browser of the user. Therefore, we can assume that knowing
    how View works is very useful when creating web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe it is beneficial if we have the Zend Framework 2 skeleton set
    up and ready to work. We will do some basic things to get you started, so no additional
    extensions are necessary for this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to output content to the browser by using `PhpRenderer` which is
    the default view strategy used.
  prefs: []
  type: TYPE_NORMAL
- en: Configure the ViewManager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We make the following alterations to the `/module/Application/config/module.config.php`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Set variables in the ViewModel instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we have set up the view manager; we can go to our controller and add the
    following to the import section of our controller.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use the `ViewModel` instance for the `PhpRenderer` in our action
    controller. Let''s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is as easy as that; simply return the `ViewModel` instance after we are done
    defining everything we want.
  prefs: []
  type: TYPE_NORMAL
- en: Mark up the template file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now it is time for the last part before we are done, and that is to create a
    template file that needs to be rendered. We can do this by first creating a file
    (as an example) in the `view/index` folder called `some.phtml` (as our action
    in the previous example was called like that).
  prefs: []
  type: TYPE_NORMAL
- en: Now we will just do a simple bit where we output the variable we have just declared
    in the `ViewModel` instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: And that's it. We have now outputted our variable example that we declared in
    our `ViewModel` instance in the action. There are also more ways of setting variables
    to the view, for example by declaring the variables as the first argument of the
    `ViewModel` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if we want to set multiple variables at the same time, but not during the
    constructor execution time we can also perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, as we are experts in outputting variables to the View, I say it is time
    for some cake!
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: View works with a couple of different methods before the requested output is
    returned to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we would use the Zend Framework 2 skeleton application, then this would already
    be in there by default, but let's assume we have nothing configured just yet and
    we are working blindly. The first thing we want to do is make sure that `ViewManager`
    is set up through the **Dependency Injection** (**DI**). We can do this by opening
    the module configuration called `module.config.php` in the `config` folder (assuming
    that we are using the standard layout) and add the `ViewManager` configuration
    there.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing before we move on is that `template_path_stack` works by searching
    for templates in the base directories that are defined in the array. Then it will
    descend further in those directories searching for the template using the format
    we described.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `IndexController` with `aboutAction` would resolve, by default
    to, the path `view/index/about.phtml` in our case.
  prefs: []
  type: TYPE_NORMAL
- en: The ViewModel instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ViewModel` instance is usually only used in the controller and is basically
    a container that holds all the information that needs to be outputted to the user.
    Although the `ViewModel` instance is technically possible to use anywhere else,
    it wouldn't be a good practice to do so, as the controller's main responsibility
    is handling the models and Views. If we go and change the nature of a controller,
    the application would become significantly harder to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: The `ViewModel` instance itself has no other purpose than to keep track of all
    the variables we want to output to the user, and other options like the template
    we'd like to use, and if we want to render the main layout or not.
  prefs: []
  type: TYPE_NORMAL
- en: What happens next is that the `ViewModel` instance will be picked up by `ViewStrategy`
    and `ViewRenderer` to be used in the output.
  prefs: []
  type: TYPE_NORMAL
- en: Almost every `ViewStrategy` has its own type of `ViewModel` designed for that
    specific purpose. That way we can easily use another `ViewModel` instance and
    create a different kind of output to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The ViewStrategy class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ViewStrategy` class is used to determine if and how we are going to output
    our content to the user. The way this works is that –usually- the `ViewStrategy`
    first determines if the `ViewModel` instance it receives is compatible with the
    model they expect it to be. It does this by attaching a `ViewEvent` to the `EVENT_RENDERER`
    event, which will be triggered when the framework is searching for a suitable
    renderer.
  prefs: []
  type: TYPE_NORMAL
- en: The `ViewStrategy` at that point checks if the model is compatible, and if it
    is it will return a suitable `ViewRenderer`, if not, it will return null. Then
    after the framework has done its thing and rendered the output (more about this
    in the The ViewRenderer helper section) it will trigger another `ViewEvent` named
    `EVENT_RESPONSE`.
  prefs: []
  type: TYPE_NORMAL
- en: This event is basically the end point that the `ViewStrategy` class can do before
    the output is send to the user. In this `ViewEvent` the `ViewStrategy` class can
    make the last amendments to the response if necessary. We should think about the
    content type, extra headers, or some other last minute stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simplified version of the process is displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The ViewStrategy class](img/4841OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ViewRenderer helper
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The renderer is used in between the two events mentioned in the `ViewStrategy`
    class before, and it does exactly like you expect it to be; it renders the output.
    It takes the data from the `ViewModel` instance and renders the output according
    to that. It usually requires a view script like the PHTML files that `PhpRenderer`
    uses, but sometimes it doesn't require any script at all and it will just render
    the output completely by itself (think about outputting in a JSON format for example).
    We will cover how to use different ViewStrategy and ViewRenderer later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The more we add complexity to View, the less we are able to maintain it properly.
    That is why we get the logic out, and put it in our View outside the view script
    itself, and place them in the so-called view helpers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe it is recommended that the Zend Framework 2 skeleton application
    is used. We won't require any out of the ordinary extensions for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Zend Framework 2 there are a bunch of default view helpers that comes with
    the framework. Let's look at a bunch of them to see what they do and how to use
    them.
  prefs: []
  type: TYPE_NORMAL
- en: The BasePath view helper
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `BasePath` view helper, is a very easy view helper to use, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Doctype view helper
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We make the following alterations to the `/module/Application/config/module.config.php`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in the view script, we can do the following to output the well-formed
    `doctype` helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The URL view helper
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The URL view helper is very handy to use if we want to generate a URL for a
    specific route, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The Partial view helper
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First of all it is important to make sure that we actually have a template (`/view/application/index/partial/partial.phtml`)
    that is used as partial content.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We then can go to our normal layout and use the `Partial` view helper to add
    our extra template (`/view/application/index/index.phtml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we get in to serious development, view helpers cannot be missed. They make
    sure our code doesn't turn into a spaghetti by keeping the logic as separate as
    possible (for example) from the HTML. View helpers only work in the view scripts
    (and if the current view strategy support it, but let's presume it does), so all
    the examples we give below are only relevant to `.phtml` files in the view directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a view helper we can usually instantly use them in the view by calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This works because without first instantiating the view helper because the `someViewHelper`
    class has an `__invoke()` method defined. This means that it can be called without
    first needing to be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, sometimes we have view helpers that cannot be used through the invocation
    shown before; they actually need to be constructed first. This can then be done
    by performing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A single view helper can also have multiple public methods available which
    is mostly used for grouping functionality together. For example a (non-existing
    in Zend Framework 2) view helper called `Person` might have `getAddress($person)`
    and `getName($person)` as public methods, which then could be called by using
    the invoke shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Zend\View\Helper\AbstractHelper
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Technically `Zend\View\Helper\AbstractHelper` is not a view helper, but we mention
    it anyway as this is the class we want to extend with if we would want to create
    our own view helper. It implements a couple of methods that are required for a
    view helper class to work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The BasePath view helper explained
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `BasePath` view helper can be really helpful if we use a custom structure
    to our application and the public folder is not on the base of a website folder,
    that is, `/website/public`. We can then use `BasePath` to let it decide where
    we are. The `BasePath` view helper is usually used more often for static assets
    such as, images, style sheets, and scripts, which is great to make sure the application
    stays robust under the change or a root URL.
  prefs: []
  type: TYPE_NORMAL
- en: The Doctype view helper explained
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Doctype` is a very useful view helper as we tend to forget how those `Doctype`
    helpers were build up again. Instead of looking on the Internet to find out how
    to declare them again, we can now just use this little gem.
  prefs: []
  type: TYPE_NORMAL
- en: You can specify the `Doctype` helper whenever you like, but it would be wise
    to do this in the configuration of your view manager to make sure the rest of
    the application also knows what `Doctype` we are using (sometimes they just want
    to output different things then).
  prefs: []
  type: TYPE_NORMAL
- en: 'The valid `Doctype` view helpers we can use are:'
  prefs: []
  type: TYPE_NORMAL
- en: XHTML11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XHTML1_STRICT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XHTML1_TRANSITIONAL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XHTML1_FRAMESET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XHTML1_RDFA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XHTML1_RDFA11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XHTML_BASIC1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XHTML5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML4_STRICT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML4_LOOSE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML4_FRAMESET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the `Doctype` helper is essential for other view helpers because they
    (for example in the case of form elements) make rendering decisions based on the
    selected type. For example a `HTML4_* doctype` might render an input fields as
    `<input type="text"></input>` while an `XHTML1_STRICT` would render it as `<input
    type="text" />`. The `Doctype` helper is more than essential if we want to use
    the validation service of the W3C.
  prefs: []
  type: TYPE_NORMAL
- en: The URL view helper explained
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A nifty little thing the URL view helper is, it builds up URL's depending on
    named route that we have defined in our configuration. This means that if we want
    to build up a correctly formed URL we can use this view helper to build it up
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: The Partial view helper explained
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Partial` view helper is particularly helpful when we want to divide our
    layout into different parts, something that is always useful if we want to make
    sure our templates are maintainable and in a condition to re-use them in multiple
    places.
  prefs: []
  type: TYPE_NORMAL
- en: The directory we store the partial views in is not strictly set, but it is recommended
    to place them in a location where we can find them whenever we require them.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We only discussed four view helpers which are default in Zend Framework 2, however
    there are tons more view helpers in the framework by default which are just as
    useful as well. Personally I would recommend looking through those as well and
    get to know them a bit as most of them are quite interesting even if you would
    never use them. Especially the `Cycle`, `Gravatar`, `HeadStyle`, and `HeadTitle`
    view helpers can come in handy when we are building a HTML page set up.
  prefs: []
  type: TYPE_NORMAL
- en: A complete list of the view helpers is always available in the official Zend
    Framework 2 documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a global layout template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The view scripts can be very dynamic but most of the time we need a global template
    that we want to wrap around the output from our `Action` view scripts. This recipe
    will explain exactly how to do that, and also tells us how that would work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe a working Zend Framework 2 skeleton application is needed as
    we will do some creating and editing of some files which are used in there.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is how we set about achieving this:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the main layout file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s now create the main file `/module/Application/view/layout/layout.phtml`
    we use to create our layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We have now set up the head tag successfully, and used a lot of the view helpers
    available to make our lives a little bit easier when it comes to adding head-related
    tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s set up a simple code body and see what we can do there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Well that was it, once we output the `content` variable, it basically renders
    the content generated from the controller/action output.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the error templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The error files are easily created as they only require a couple of things.
    Let's create the `/module/Application/view/error/404.phtml` file first as that
    one is fairly straight forward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There are more variables we can use to show the user what went wrong in the
    routing, and we can also see, for example, what they requested, but usually those
    are more for development only and not for a production server as we don't want
    to expose too much data.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's create the file (`/module/Application/view/error/index.phtml`) that
    will be shown when we end up having an exception, one of the favorite things of
    a developer (not, obviously).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AbstractActionController` shows the errors when they occur and also selects
    the right template (which is defined in the `view_manager` configuration) to use
    for the error messages. The only thing we have to do is to make sure the templates
    are there.
  prefs: []
  type: TYPE_NORMAL
- en: A global layout is an excellent idea if we would be using the MVC model of Zend
    Framework 2 and are expecting to use the same layout over and over again, which
    is what happens in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a global layout will really make our lives easier, as it is a way of
    making our code more maintainable, and as a coder that is one of the most important
    tools in your toolset.
  prefs: []
  type: TYPE_NORMAL
- en: First of all we need to make sure the `view_manager` has been defined properly,
    this has been described in the *Working with View* recipe, so we assume that we
    are using the same configuration at this point.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `inlineScript` view helper to make sure the content can also output
    scripts that are not part of the head tag, but should still be used in the output.
  prefs: []
  type: TYPE_NORMAL
- en: We would like to use `inlineScript` to define any scripts instead of adding
    them to the template files as we want to separate the JavaScript with the normal
    HTML content as far as we can (we also want inline scripts to be reusable if we
    can, and it looks better maintenance wise).
  prefs: []
  type: TYPE_NORMAL
- en: The error template example is a very basic error document that is shown when
    an exception is happening. There are even more options we could do after this,
    for example if there were more exceptions, we could get them by doing `$this->exception->getPrevious()`
    and then parsing through them as an array.
  prefs: []
  type: TYPE_NORMAL
- en: Creating reusable Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this time of dynamic applications we have widgets or content that can be
    used more than once. Instead of getting everything at the same time we want to
    be able to dynamically load new objects in, or at least not have to do a lot to
    get functionality working.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe we need nothing more than a working Zend Framework 2 skeleton
    application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we'll be discussing how to create reusable templates and the
    best way of using them in an application.
  prefs: []
  type: TYPE_NORMAL
- en: Use the Action view helper to get the re-usable content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Action` view helper is a great way of calling different actions in our
    code to retrieve other parts of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Define a child to the ViewModel instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First of all we should create a simple view script (`/module/Application/view/application/template/sidebar.tpl`)
    to output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After that we need to be in the controller (`/module/Application/src/Application/Controller/IndexController.php`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the controller set up, we would want to output the child as well
    in our view script. We will be using a similar HTML layout as the first method
    so that we can spot the differences.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we are developing web applications, we find ourselves at a point where
    we need to re-use the content that we already made before, such as the build-up
    of a form or maybe the layout of a side bar that we want to use on multiple pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we can do in that instance is two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `Action` view helper to get the re-usable content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a child to the `ViewModel` instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these methods can be used in different situations, let's explore the
    both options.
  prefs: []
  type: TYPE_NORMAL
- en: The Action view helper explained
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We primarily would want to use this *if the re-usable content is outside the
    current module*, for example if the content is created by a module that provides
    page widgets then it can be used anywhere in the application. If we want to use
    a content that is inside our module, we better use the second option as that is
    less performance heavy because it doesn't go through the whole routing and dispatching
    process like the first option does.
  prefs: []
  type: TYPE_NORMAL
- en: What this view helper does is call an action within a view script, and post
    the results of that action call to the current view script.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the first example, it makes the call to the action and renders
    the output inside the current view script. The difference between this and the
    use of a partial view script is that this will go through the whole routing and
    dispatching process, while a partial simply displays the rendered output. If we,
    for example, need to get records from the database, a partial just wouldn't cut
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a child to a ViewModel instance explained
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method of rendering re-usable content is primarily used *when the re-usable
    content is inside the current module*, for example when we would like to use a
    specific overview table that relies on requires more intelligence than, for instance,
    a view helper would be able to provide. The content we are rendering would not
    require us to mess around in different modules, we'd rather stay away from relying
    on other modules from within our controller. We generally want to keep the modules
    as separate as possible so that we are able to run the application, even if one
    of the other modules is not available.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the example shown in *How it works* now, we can see that it has
    slightly more work to do in this method instead of the view helper class, but
    the difference is that the view helper class needs to do more in the background
    to get it all to work.
  prefs: []
  type: TYPE_NORMAL
- en: Pros and cons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some might disagree when we say that we primarily should use the `Action` view
    helper outside the current module, and there are probably good reasons for why
    we should. One of the arguments against it is that it is simpler for the developer
    (or designer in most cases) to get the content from different locations without
    being bound by adding it as a `ViewModel` child in the controller. However, the
    view helper class does require the framework to find the action, controller and
    module first, render them, and then output them.
  prefs: []
  type: TYPE_NORMAL
- en: Although simpler in set up, it does strain the web application more if we use
    this option without good reason. Sometimes it is just better to code more and
    use the benefit of the speed of the application, then be lazy and let the application
    reduce its speed.
  prefs: []
  type: TYPE_NORMAL
- en: Sure everything has its pros and cons, so we should always consider the situation
    first to make sure we get the most maintainable and re-usable code possible.
  prefs: []
  type: TYPE_NORMAL
- en: Using view strategies/renderers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally we will use the View to output HTML, but sometimes we want a more diverse
    way of outputting for example JSON or XML. This recipe will provide us with enough
    information to accomplish this easily.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We simply require the Zend Framework 2 skeleton application to get us going
    with this recipe. Nothing exotic is required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using different view strategies and renderers is a common practice in an application.
    In this recipe we'll explain how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a view strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can easily add a view strategy to our application by simply appending the
    `view_manager` configuration in the module configuration file (`/module/Restful/config/module.config.php`)
    as shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The JSON strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we receive output from the JSON strategy, it might look very much like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The Feed strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the Feed strategy is quite similar to the other strategies, as we can
    see in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now set up our main data, which will be needed to generate our feed.
    Now let''s add some sample data to the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to parse through the data (I know, it''s a bit weird as we just
    declared it, but in reality this would never happen) and put them in the feed
    as an entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now all that is left to do is export the feed to a specific format and add it
    to the actual `FeedModel` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The view strategy class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default view strategy used in the Zend Framework 2 skeleton application
    is the `PhpRenderer` class, which does nothing more than search for a `.phtml`
    file in a defined location; by default this would be `/module/ModuleName/view`.
    The `PhpRenderer` class is able to parse PHP inside the view scripts, which makes
    it handy (but also very familiar) to perform some last minute scripting for our
    layout, such as parsing through records to create a table or displaying a username,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although PHP is allowed in the `PhpRenderer` class, it should be mentioned that
    the developer should be wary of putting business logic in the view script. Logic
    should be placed in the model or at least the controller as it was never intended
    to reside in the view script.
  prefs: []
  type: TYPE_NORMAL
- en: This strategy will always be used whenever there is no other strategy available.
  prefs: []
  type: TYPE_NORMAL
- en: The default view strategies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a small number of view strategies readily available in Zend Framework
    2, they are:'
  prefs: []
  type: TYPE_NORMAL
- en: The PHP strategy (default)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JSON strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Feed strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JSON strategy explained
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A JSON object is short for JavaScript Object Notation and is a text based, human-readable
    output format that is mainly used in modern web services around the world. It
    is derived from the JavaScript language and thus, resembles a lot of its features.
  prefs: []
  type: TYPE_NORMAL
- en: This is probably a nice example as we have put new lines in the output, while
    the actual JSON strategy will never contain that. But hey, if it is server-to-server
    talk only, why would we care?
  prefs: []
  type: TYPE_NORMAL
- en: The JSON strategy doesn't require a template or view script as it basically
    parses through the variables used in the view model, simple!
  prefs: []
  type: TYPE_NORMAL
- en: The Feed strategy explained
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Feed strategy outputs an XML news feed that can be used , for example, by
    users to subscribe on as an RSS or RSS2 formatted feed. Using the view model of
    the Feed strategy is a bit different though as directly setting the variables
    in the view model directly might be a tricky thing to do. Instead of that you
    can use a `Zend\Feed\Writer\Feed` object to determine the layout of your feed,
    and then feeding it to the `FeedModel` by passing it as a parameter to the `setFeed`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: More about view strategies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The nice thing about Zend Framework 2 is that it isn't really hard to change
    the output, as it comes with a technique called view strategies, and in effect
    view renderers.
  prefs: []
  type: TYPE_NORMAL
- en: A view strategy is a class that identifies a model and returns a view renderer,
    which on its turn renders the output of the content. The view strategy will determine
    which renderer to use and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time view strategies come with their own view model as well, which
    is to make sure the content we want to output is compatible with the renderer.
    The view strategy will, upon receiving the model, determine if it can or cannot
    render a certain model.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the JSON renderer in the framework only renders models of the type
    `JsonModel` and will, when receiving a `ViewModel`, do nothing as it is technically
    not compatible with the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we just need to output content in a different way. If we are talking
    about REST services, RSS feeds, or just something custom, we should always be
    able to switch between different output formats without needing to do too much
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Using context switching for a different output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not only do we want to be able to output the content through different view
    strategies, we sometimes also want to do this on demand, so that we can switch
    the output, for example, from HTML to JSON by simply changing the headers in our
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases (for example, in the REST servers) it is necessary to switch the
    response output of the content depending on what the user asks for. The user can
    add an `Accept` header to let the server know which output formats it accepts,
    for example `application/json`, and `text/html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we are going to do is create a simple website that will output a `text/html`
    format on default (which is normal), but it will also output a JSON string whenever
    we have `Accept: */json` in our header.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes we want to cater not just to the users that view our website, but
    to a lot of different audiences, for example, the Feed readers or other applications.
    Therefore we'll discuss how to switch contexts in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Define multiple strategies to output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First we want to make sure we have the JSON view strategy lined up so that
    we can easily switch between views. We can do this by adding `ViewJsonStrategy`
    in the `/module/Restful/config/module.config.php` as shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Determine the view model based on the Accept header
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the controller there is a nifty little controller plugin called `AcceptableViewModelSelector`,
    which can be used to return a view model that is based on the `Accept` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'So to make things a bit clear, we first want to define which kind of models
    we want to support in our output. Let''s create a property in our controller that
    regulates which view models we are supporting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As we can see here, we will support two models in order of priority. First of
    all we want the default view model to use the normal `PhpRenderer` class, so that
    users will get to see the normal HTML output. Second of all we want any `application/json`
    or `text/json` to be rendered by our `JsonRenderer` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create a simple `indexAction` method and make use of the view model''s
    selecting abilities there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: And that's how we do it folks! That was as simple as it can get as `AcceptableViewModelSelector`
    does all the work for us, and the only thing we have to do is make sure everything
    is declared in the model.
  prefs: []
  type: TYPE_NORMAL
- en: When we now add a view script for the normal `PhpRenderer` class, so that it
    renders our normal `text/html` output fine, we can say for sure that everything
    is done. Please make sure that this view script (`/module/Restful/view/restful/index/index.phtml`)
    resides in our new `Restful` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for a user with `Accept: application/json` header would look like
    the following, For this we need no view script as the renderer immediately outputs
    this.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The default `PhpRenderer` output will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`AcceptableViewModelSelector` looks at the header sent with the request to
    determine which view model to use. It determines the model by looking in the `array`
    we parse into it and looking at the different `Accept` headers we have defined
    that we support.'
  prefs: []
  type: TYPE_NORMAL
- en: Next it will take the key of that specific `array` item, and that will be the
    view model that will be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test out different headers, I like to use the Mozilla Firefox browser with
    the Header Tool add-on ([https://addons.mozilla.org/en-us/firefox/addon/header-tool](https://addons.mozilla.org/en-us/firefox/addon/header-tool))
    installed, or similar Chrome extensions, or if we are feeling particularly brave,
    just the command line cURL. There you can just type the header you would like
    to send along, and turn it either on or off. However, there are different ways
    of sending headers as well. It depends on how you prefer doing things.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom view strategy/renderer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nothing is more exciting in coding than developing your own bits of custom features
    that integrate with the framework. In this recipe we will be discussing how to
    create our own XML view strategy. We will show you how to simply create the basis
    for a new strategy without too much of a bother.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes the default strategies and renderers provided are not enough for a
    specific situation, so let's talk through on how to create our own view strategy/renderer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the XmlOutput renderer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us see first on how our renderer would look like, as that is possibly one
    of the laziest classes we will ever code. We will do this in a new class located
    in `/module/XmlOutput/src/XmlOutput/View/Renderer/XmlRenderer.php`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The code for this model is very straightforward as we don't really need to do
    a lot of coding to get it working, we'll do this in the `/module/XmlOutput/src/XmlOutput/View/Model/XmlModel.php`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet we have a simple getter and setter for the encoding
    which will usually be UTF-8, as it is also declared as the default value in the
    property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to create the more exciting part, the `XmlStrategy` (located in
    `/module/XmlOutput/src/XmlOutput/View/Strategy/XmlStrategy.php`), which is the
    part that will actually tell the framework if, what, and how to render the content
    by handling the two View events (which is required).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Once again we defined all of the properties which we needed. The first one `$listeners`
    will contain an array of `CallbackHandler` which we will use to attach and detach
    events to the `EventManager` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The second member variable `$renderer` will store our `XmlRenderer` which we
    just created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now we have defined our simple constructor, which basically assigns the given
    `XmlRenderer` class to our local property for safekeeping, which is the typical
    behavior of a rendering strategy. Next, we'll continue to implement the event
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The last bit we need to do for the strategy is to attach and detach our events.
    The events methods in this case being `selectRenderer` and `injectResponse`, which
    will be triggered at different points in the code. The first one will be triggered
    when the event `ViewEvent::EVENT_RENDERER` happens and the second one will be
    triggered on `ViewEvent::EVENT_RESPONSE`. Once the framework has used everything
    it needs, it will call the `detach` method, and we then need to make sure all
    our events will be detached.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is something we didn''t use before, which is the `ViewXmlStrategyFactory`
    class. The factory basically instantiates the `XmlStrategy` class (in this case)
    and makes sure everything is instantiated correctly. We''ll create our new file
    here: `/module/XmlOutput/src/XmlOutput/Service/ViewXmlStrategyFactory.php`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: That's it, as we can see it is not a lot, and only the `createService` method
    is being defined in the class. In that method the only thing we do is get the
    `ViewXmlRenderer` parameter and make sure the `XmlStrategy` class is constructed
    with that renderer as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's take a look at `ViewXmlRendererFactory`(located in `/module/XmlOutput/src/XmlOutput/Service/ViewXmlRendererFactory.php`),
    which is also a factory but now for the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Although this `createService` method was more work than the one before, it is
    still a very light method. The only thing that really happens here is that the
    `XmlRenderer` class is instantiated, and it made sure `ViewResolver` and `ViewHelperManager`
    are set.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have set up our basic functionality, let's tie it all together so that
    we can start using it!
  prefs: []
  type: TYPE_NORMAL
- en: First of all we need to create the `/module/XmlOutput/config/module.config.php`
    file to make sure our services are instantiated properly, and our view manager
    knows the new strategy we offer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: That was rather painless, as we can simply tell `serviceManager` where everything
    is located and it will work immediately.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to create in our new `XmlOutput` module is the `Module.php`
    file, which is basically the same as the default `Module.php` that comes with
    the Application module. We can simply copy that one over, change the namespace
    in the file and we are done. The file should be located in `/module/XmlOutput/Module.php`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now the `/config/application.config.php` file needs to have our new module added,
    so that the framework will try to instantiate that module as well. We can just
    add `XmlOutput` to the modules array and we are done, nothing else needs changing
    in there.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Everything is ready and set up for use, so now it is time to actually get the
    ball rolling and output something to XML. First up is using `XmlModel` in our
    `indexAction` of the `IndexController` (located in `/module/Application/src/Application/Controller/IndexController.php`).
    We will just assign some variables to `XmlModel` and return this immediately,
    no need for anything fancy now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Once we have done that, we can build up our view script (located in `/module/Application/view/application/index/index.phtml`)
    with the necessary XML.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: And that is it! Once we run it, we can now see that our HTTP headers are set
    to `application/xml` and that the output is the XML we have just put in. Obviously
    this is nothing fancy, but it is to show how easy it is to just create our own
    view strategy.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because we added our factories to the `ServiceManager`, we can easily get them
    to use by their aliases `ViewXmlStrategy` and `ViewXmlRenderer`. And because we
    told the `ViewManager` that our new strategy `ViewXmlStrategy` exists, we can
    get the ball rolling.
  prefs: []
  type: TYPE_NORMAL
- en: As we would use the `XmlModel` in our controller, the framework will iterate
    through all the view strategies to determine the proper strategy to use. Once
    it has found the strategy it needs, it will trigger the `EVENT_RENDERER` and `EVENT_RESPONSE`
    events, which in turn will trigger our strategy methods. These methods will determine
    the output of our content.
  prefs: []
  type: TYPE_NORMAL
- en: Our renderer makes sure the content is rendered properly. In our case we took
    the lazy way out and let `PhpRenderer` basically do all the work, this can however
    vary per renderer.
  prefs: []
  type: TYPE_NORMAL
- en: We are creating this new view strategy as a separate module, with separate namespaces
    so that we can easily transfer this to another application if we ever need to.
    And of course it comes with greater maintainability when we separate pieces of
    functionality as well.
  prefs: []
  type: TYPE_NORMAL
- en: When we are done we can easily extend the classes further as we wish, but for
    now let's keep it basic.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five files that need to be created before we can have at least the
    most basic form of a custom view strategy; the files need to be of the following
    forms:'
  prefs: []
  type: TYPE_NORMAL
- en: Renderer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategy Factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renderer Factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first three we already know as we've discussed in this chapter, the last
    two Factory ones', however, are new to us.
  prefs: []
  type: TYPE_NORMAL
- en: The XmlRenderer and XmlModel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because we just want to output XML as a string, we will be using the `PhpRenderer`
    as that does the exact same thing as we want it to do.
  prefs: []
  type: TYPE_NORMAL
- en: Next up is coding the model. As described earlier, the model will be used in
    the controller to store variables which we can then use in the View. We will be
    creating the XmlModel so that when we use this model in our controller our framework
    knows we want to output with our `XmlStrategy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see we made all the properties in the `XmlModel` protected, because
    these properties are protected in the class we are trying to extend (`ViewModel`)
    as well. It is necessary while extending a property to give it the same access
    level or lower. In this case it is protected, which means the lower option would
    be public. Private, however, would result in a fatal error shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The last bit we need to do in the `XmlModel` is create the getter and setter
    for the content type, which in our case would become `application/xml`, because
    we want to output XML, not plain text.
  prefs: []
  type: TYPE_NORMAL
- en: The XmlStrategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In `selectRenderer` we want to make sure that the model we have is also the
    model we expect it to be. If this is not the case we cannot return a renderer,
    meaning that the framework needs to search for a different kind of renderer. For
    example, the use of a `ViewModel` instance would result in `selectRenderer` returning
    null, which would tell the framework to search for another suitable strategy.
    In this case it might be the `PhpStrategy`, which in this case would accept `ViewModel`
    as a valid model, and that is how the view strategy communicates to the framework
    to tell it if he can use the model or not.
  prefs: []
  type: TYPE_NORMAL
- en: The `injectResponse` is a method that will ready the content for output, and
    makes sure that the content type is set in the headers as well. The `ViewEvent`
    given as a parameter that contains all the collected information we need, such
    as the `XmlModel`, and also its Response. The next bit of code will tie the last
    two methods we just created together and use them as handlers for the respective
    `ViewEvent::EVENT_RENDERER` and `ViewEvent::EVENT_RESPONSE` events.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We said before we were a bit lazy with the renderer, basically putting off any
    of the work by putting all of the work in the hands of the `PhpRenderer`, which
    in turn basically rendered the view script containing the XML. Naturally one would
    desire a renderer which makes the use of view scripts obsolete, and just creates
    the XML from an array in the `XmlModel`.
  prefs: []
  type: TYPE_NORMAL
- en: So yes, there is a lot more that can be said, but the real fun starts if we
    start exploring the different ways of rendering content.
  prefs: []
  type: TYPE_NORMAL
