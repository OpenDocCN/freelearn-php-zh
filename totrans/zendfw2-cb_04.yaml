- en: Chapter 4. Using View
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 使用视图
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Working with View
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与视图一起工作
- en: Using view helpers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视图助手
- en: Creating a global layout template
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建全局布局模板
- en: Creating reusable Views
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重用的视图
- en: Using view strategies/renderers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视图策略/渲染器
- en: Using context switching for a different output
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文切换以实现不同的输出
- en: Writing a custom view strategy/renderer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义视图策略/渲染器
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter we are going to talk about using View, something that we have
    briefly mentioned in a couple of places before. View was created for the benefit
    of the developer, to strictly separate everything frontend with everything backend.
    This way backend developers can focus on controllers and models, while frontend
    developers can work in Views. Another great benefit of View is that View decides
    how the data is being outputted, so in most cases this would be HTML, in other
    cases maybe JSON and so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论使用视图，这是我们之前在几个地方简要提到过的。视图是为了开发者的利益而创建的，以严格区分前端和后端的一切。这样，后端开发者可以专注于控制器和模型，而前端开发者可以在视图中工作。视图的另一个巨大好处是视图决定了数据是如何输出的，所以在大多数情况下这将是HTML，在其他情况下可能是JSON等等。
- en: We will show you in the last recipe of the chapter how to make our own customizations
    as well, so that we fully understand how everything works.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的最后一个小节中向您展示如何进行自定义，这样我们就可以完全理解一切是如何工作的。
- en: Working with View
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与视图一起工作
- en: View can be considered very important as it actually renders the content that
    is being outputted to the browser of the user. Therefore, we can assume that knowing
    how View works is very useful when creating web applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 视图可以被认为非常重要，因为它实际上渲染了输出到用户浏览器的内容。因此，我们可以假设了解视图的工作原理在创建Web应用程序时非常有用。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe it is beneficial if we have the Zend Framework 2 skeleton set
    up and ready to work. We will do some basic things to get you started, so no additional
    extensions are necessary for this.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方来说，如果我们已经设置了Zend Framework 2骨架并准备好工作，那就很有好处。我们将做一些基本的事情来帮助你开始，所以不需要额外的扩展。
- en: How to do it…
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We are going to output content to the browser by using `PhpRenderer` which is
    the default view strategy used.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用默认的视图策略`PhpRenderer`来输出内容到浏览器。
- en: Configure the ViewManager
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置视图管理器
- en: 'We make the following alterations to the `/module/Application/config/module.config.php`
    file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`/module/Application/config/module.config.php`文件进行以下修改：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Set variables in the ViewModel instance
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在ViewModel实例中设置变量
- en: Now we have set up the view manager; we can go to our controller and add the
    following to the import section of our controller.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了视图管理器；我们可以去我们的控制器，并在我们的控制器导入部分添加以下内容。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we can use the `ViewModel` instance for the `PhpRenderer` in our action
    controller. Let''s do that now:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`ViewModel`实例来为我们的动作控制器中的`PhpRenderer`服务。让我们现在就来做这件事：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is as easy as that; simply return the `ViewModel` instance after we are done
    defining everything we want.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单；在我们定义完所有想要的东西之后，简单地返回`ViewModel`实例。
- en: Mark up the template file
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标记模板文件
- en: Now it is time for the last part before we are done, and that is to create a
    template file that needs to be rendered. We can do this by first creating a file
    (as an example) in the `view/index` folder called `some.phtml` (as our action
    in the previous example was called like that).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们完成之前最后一步的时候了，那就是创建一个需要渲染的模板文件。我们可以通过首先在`view/index`文件夹中创建一个文件（例如）来做到这一点，命名为`some.phtml`（正如我们之前的例子中所叫的那样）。
- en: Now we will just do a simple bit where we output the variable we have just declared
    in the `ViewModel` instance.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将只做一件简单的事情，那就是输出我们在`ViewModel`实例中刚刚声明的变量。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: And that's it. We have now outputted our variable example that we declared in
    our `ViewModel` instance in the action. There are also more ways of setting variables
    to the view, for example by declaring the variables as the first argument of the
    `ViewModel` constructor.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们现在已经在动作中输出了我们在`ViewModel`实例中声明的变量示例。还有其他方法可以将变量设置到视图中，例如通过将变量声明为`ViewModel`构造函数的第一个参数。
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or, if we want to set multiple variables at the same time, but not during the
    constructor execution time we can also perform the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们想同时设置多个变量，但不是在构造函数执行时间，我们也可以执行以下操作：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, as we are experts in outputting variables to the View, I say it is time
    for some cake!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们是输出变量到视图的专家，我认为是时候来点蛋糕了！
- en: How it works…
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: View works with a couple of different methods before the requested output is
    returned to the user.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 视图在向用户返回请求的输出之前会使用几种不同的方法。
- en: The configuration
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置
- en: If we would use the Zend Framework 2 skeleton application, then this would already
    be in there by default, but let's assume we have nothing configured just yet and
    we are working blindly. The first thing we want to do is make sure that `ViewManager`
    is set up through the **Dependency Injection** (**DI**). We can do this by opening
    the module configuration called `module.config.php` in the `config` folder (assuming
    that we are using the standard layout) and add the `ViewManager` configuration
    there.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要使用 Zend Framework 2 的骨架应用程序，那么默认情况下这已经设置好了，但让我们假设我们还没有进行任何配置，我们正在盲目地工作。我们首先想要做的是确保通过**依赖注入**（**DI**）设置了
    `ViewManager`。我们可以通过在 `config` 文件夹中打开名为 `module.config.php` 的模块配置文件（假设我们使用的是标准布局）并在那里添加
    `ViewManager` 配置来实现这一点。
- en: One more thing before we move on is that `template_path_stack` works by searching
    for templates in the base directories that are defined in the array. Then it will
    descend further in those directories searching for the template using the format
    we described.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，还有一点需要注意，那就是 `template_path_stack` 通过在数组中定义的基本目录中搜索模板来工作。然后它将在这些目录中进一步搜索使用我们描述的格式的模板。
- en: For example, `IndexController` with `aboutAction` would resolve, by default
    to, the path `view/index/about.phtml` in our case.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的情况下，带有 `aboutAction` 的 `IndexController` 默认解析为 `view/index/about.phtml`
    路径。
- en: The ViewModel instance
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ViewModel` 实例'
- en: The `ViewModel` instance is usually only used in the controller and is basically
    a container that holds all the information that needs to be outputted to the user.
    Although the `ViewModel` instance is technically possible to use anywhere else,
    it wouldn't be a good practice to do so, as the controller's main responsibility
    is handling the models and Views. If we go and change the nature of a controller,
    the application would become significantly harder to maintain.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel` 实例通常只在控制器中使用，基本上是一个容器，它包含所有需要输出给用户的信息。尽管 `ViewModel` 实例在技术上可以在任何地方使用，但这并不是一个好的实践，因为控制器的主要责任是处理模型和视图。如果我们改变控制器本质，应用程序将变得难以维护。'
- en: The `ViewModel` instance itself has no other purpose than to keep track of all
    the variables we want to output to the user, and other options like the template
    we'd like to use, and if we want to render the main layout or not.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel` 实例本身没有其他目的，只是跟踪我们想要输出给用户的所有变量，以及其他选项，比如我们想要使用的模板，以及我们是否想要渲染主布局。'
- en: What happens next is that the `ViewModel` instance will be picked up by `ViewStrategy`
    and `ViewRenderer` to be used in the output.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来发生的事情是，`ViewModel` 实例将被 `ViewStrategy` 和 `ViewRenderer` 拿来用于输出。
- en: Almost every `ViewStrategy` has its own type of `ViewModel` designed for that
    specific purpose. That way we can easily use another `ViewModel` instance and
    create a different kind of output to the user.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个 `ViewStrategy` 都有其自己类型的 `ViewModel`，专为该特定目的设计。这样我们就可以轻松地使用另一个 `ViewModel`
    实例，并为用户创建不同类型的输出。
- en: The ViewStrategy class
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ViewStrategy` 类'
- en: The `ViewStrategy` class is used to determine if and how we are going to output
    our content to the user. The way this works is that –usually- the `ViewStrategy`
    first determines if the `ViewModel` instance it receives is compatible with the
    model they expect it to be. It does this by attaching a `ViewEvent` to the `EVENT_RENDERER`
    event, which will be triggered when the framework is searching for a suitable
    renderer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewStrategy` 类用于确定我们将如何以及是否向用户输出内容。其工作方式通常是，首先 `ViewStrategy` 确定它接收到的 `ViewModel`
    实例是否与它们期望的模型兼容。它是通过将一个 `ViewEvent`附加到 `EVENT_RENDERER` 事件上实现的，该事件将在框架搜索合适的渲染器时触发。'
- en: The `ViewStrategy` at that point checks if the model is compatible, and if it
    is it will return a suitable `ViewRenderer`, if not, it will return null. Then
    after the framework has done its thing and rendered the output (more about this
    in the The ViewRenderer helper section) it will trigger another `ViewEvent` named
    `EVENT_RESPONSE`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个时刻，`ViewStrategy` 会检查模型是否兼容，如果是，它将返回一个合适的 `ViewRenderer`，如果不是，它将返回 null。然后框架完成其工作并渲染输出（更多关于这一点在
    The ViewRenderer helper 部分）之后，它将触发另一个名为 `EVENT_RESPONSE` 的 `ViewEvent`。
- en: This event is basically the end point that the `ViewStrategy` class can do before
    the output is send to the user. In this `ViewEvent` the `ViewStrategy` class can
    make the last amendments to the response if necessary. We should think about the
    content type, extra headers, or some other last minute stuff.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事件基本上是`ViewStrategy`类在输出发送给用户之前可以做的最后一个端点。在这个`ViewEvent`中，`ViewStrategy`类如果需要的话可以对响应进行最后的修改。我们应该考虑内容类型、额外头信息或是一些其他最后一刻的事情。
- en: 'A simplified version of the process is displayed as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的简化版过程如下所示：
- en: '![The ViewStrategy class](img/4841OS_04_01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![ViewStrategy类](img/4841OS_04_01.jpg)'
- en: The ViewRenderer helper
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图渲染器辅助器
- en: The renderer is used in between the two events mentioned in the `ViewStrategy`
    class before, and it does exactly like you expect it to be; it renders the output.
    It takes the data from the `ViewModel` instance and renders the output according
    to that. It usually requires a view script like the PHTML files that `PhpRenderer`
    uses, but sometimes it doesn't require any script at all and it will just render
    the output completely by itself (think about outputting in a JSON format for example).
    We will cover how to use different ViewStrategy and ViewRenderer later in this
    chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器在`ViewStrategy`类之前提到的两个事件之间使用，它确实像你预期的那样工作；它渲染输出。它从`ViewModel`实例中获取数据，并根据这些数据渲染输出。它通常需要一个视图脚本，例如`PhpRenderer`使用的PHTML文件，但有时它根本不需要任何脚本，并且可以完全自行渲染输出（例如，考虑以JSON格式输出）。我们将在本章后面介绍如何使用不同的ViewStrategy和ViewRenderer。
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The more we add complexity to View, the less we are able to maintain it properly.
    That is why we get the logic out, and put it in our View outside the view script
    itself, and place them in the so-called view helpers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在View中添加的复杂性越多，就越难以正确维护它。这就是为什么我们将逻辑提取出来，并将其放置在视图脚本之外的View中，并将它们放在所谓的视图辅助器中。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe it is recommended that the Zend Framework 2 skeleton application
    is used. We won't require any out of the ordinary extensions for this recipe.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，建议使用Zend Framework 2骨架应用程序。我们不会需要任何非同寻常的扩展来使用这个配方。
- en: How to do it…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In Zend Framework 2 there are a bunch of default view helpers that comes with
    the framework. Let's look at a bunch of them to see what they do and how to use
    them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在Zend Framework 2中，有一系列默认的视图辅助器与框架一起提供。让我们看看其中的一些，看看它们的作用以及如何使用它们。
- en: The BasePath view helper
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BasePath视图辅助器
- en: 'The `BasePath` view helper, is a very easy view helper to use, for example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`BasePath`视图辅助器是一个非常容易使用的视图辅助器，例如：'
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Doctype view helper
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Doctype视图辅助器
- en: 'We make the following alterations to the `/module/Application/config/module.config.php`
    file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`/module/Application/config/module.config.php`文件进行了以下修改：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then in the view script, we can do the following to output the well-formed
    `doctype` helper:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在视图脚本中，我们可以执行以下操作来输出格式良好的`doctype`辅助器：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The URL view helper
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: URL视图辅助器
- en: 'The URL view helper is very handy to use if we want to generate a URL for a
    specific route, for example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为特定的路由生成URL，URL视图辅助器非常方便使用，例如：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Partial view helper
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分视图辅助器
- en: First of all it is important to make sure that we actually have a template (`/view/application/index/partial/partial.phtml`)
    that is used as partial content.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保我们实际上有一个模板（`/view/application/index/partial/partial.phtml`）被用作部分内容。
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then can go to our normal layout and use the `Partial` view helper to add
    our extra template (`/view/application/index/index.phtml`):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以进入我们的正常布局，并使用`Partial`视图辅助器添加我们的额外模板（`/view/application/index/index.phtml`）：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once we get in to serious development, view helpers cannot be missed. They make
    sure our code doesn't turn into a spaghetti by keeping the logic as separate as
    possible (for example) from the HTML. View helpers only work in the view scripts
    (and if the current view strategy support it, but let's presume it does), so all
    the examples we give below are only relevant to `.phtml` files in the view directory.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们进入严肃的开发，视图辅助器是不可或缺的。它们通过尽可能地将逻辑与HTML分离来确保我们的代码不会变成意大利面（例如）。视图辅助器仅在视图脚本中工作（如果当前视图策略支持的话，但让我们假设它支持），所以下面给出的所有示例都只与视图目录中的`.phtml`文件相关。
- en: 'If we have a view helper we can usually instantly use them in the view by calling:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个视图辅助器，我们通常可以立即在视图中通过调用它们来使用：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This works because without first instantiating the view helper because the `someViewHelper`
    class has an `__invoke()` method defined. This means that it can be called without
    first needing to be instantiated.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为在首先实例化视图助手之前，`someViewHelper` 类已经定义了一个 `__invoke()` 方法。这意味着可以在不需要先实例化的情况下调用它。
- en: 'However, sometimes we have view helpers that cannot be used through the invocation
    shown before; they actually need to be constructed first. This can then be done
    by performing the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们有一些视图助手不能通过之前显示的调用方式使用；实际上，它们需要首先被构建。这可以通过执行以下操作来完成：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A single view helper can also have multiple public methods available which
    is mostly used for grouping functionality together. For example a (non-existing
    in Zend Framework 2) view helper called `Person` might have `getAddress($person)`
    and `getName($person)` as public methods, which then could be called by using
    the invoke shown as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个视图助手也可以有多个公共方法可用，这通常用于将功能分组在一起。例如，一个（在 Zend Framework 2 中不存在的）名为 `Person`
    的视图助手可能有 `getAddress($person)` 和 `getName($person)` 作为公共方法，然后可以通过以下方式使用 invoke
    来调用：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Zend\View\Helper\AbstractHelper
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Zend\View\Helper\AbstractHelper
- en: Technically `Zend\View\Helper\AbstractHelper` is not a view helper, but we mention
    it anyway as this is the class we want to extend with if we would want to create
    our own view helper. It implements a couple of methods that are required for a
    view helper class to work correctly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上 `Zend\View\Helper\AbstractHelper` 不是一个视图助手，但我们仍然提到它，因为这是我们想要扩展以创建自己的视图助手的类。它实现了一些对于视图助手类正确工作所必需的方法。
- en: The BasePath view helper explained
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`BasePath` 视图助手的解释'
- en: The `BasePath` view helper can be really helpful if we use a custom structure
    to our application and the public folder is not on the base of a website folder,
    that is, `/website/public`. We can then use `BasePath` to let it decide where
    we are. The `BasePath` view helper is usually used more often for static assets
    such as, images, style sheets, and scripts, which is great to make sure the application
    stays robust under the change or a root URL.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用自定义结构来构建应用程序，并且公共文件夹不在网站文件夹的底部，即 `/website/public`，那么 `BasePath` 视图助手可以非常有帮助。然后我们可以使用
    `BasePath` 来让它决定我们的位置。`BasePath` 视图助手通常用于更频繁地处理静态资源，例如图像、样式表和脚本，这对于确保应用程序在更改或根
    URL 下保持稳健性非常有用。
- en: The Doctype view helper explained
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Doctype` 视图助手的解释'
- en: The `Doctype` is a very useful view helper as we tend to forget how those `Doctype`
    helpers were build up again. Instead of looking on the Internet to find out how
    to declare them again, we can now just use this little gem.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Doctype` 是一个非常有用的视图助手，因为我们往往会忘记那些 `Doctype` 助手是如何构建的。与其在互联网上查找如何再次声明它们，我们现在可以只使用这个小巧的宝石。'
- en: You can specify the `Doctype` helper whenever you like, but it would be wise
    to do this in the configuration of your view manager to make sure the rest of
    the application also knows what `Doctype` we are using (sometimes they just want
    to output different things then).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以随时指定 `Doctype` 助手，但最好在视图管理器的配置中这样做，以确保应用程序的其他部分也知道我们正在使用哪个 `Doctype`（有时它们可能只想输出不同的事物）。
- en: 'The valid `Doctype` view helpers we can use are:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的有效 `Doctype` 视图助手有：
- en: XHTML11
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XHTML11
- en: XHTML1_STRICT
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XHTML1_STRICT
- en: XHTML1_TRANSITIONAL
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XHTML1_TRANSITIONAL
- en: XHTML1_FRAMESET
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XHTML1_FRAMESET
- en: XHTML1_RDFA
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XHTML1_RDFA
- en: XHTML1_RDFA11
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XHTML1_RDFA11
- en: XHTML_BASIC1
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XHTML_BASIC1
- en: XHTML5
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XHTML5
- en: HTML4_STRICT
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML4_STRICT
- en: HTML4_LOOSE
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML4_LOOSE
- en: HTML4_FRAMESET
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML4_FRAMESET
- en: HTML5
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML5
- en: Setting the `Doctype` helper is essential for other view helpers because they
    (for example in the case of form elements) make rendering decisions based on the
    selected type. For example a `HTML4_* doctype` might render an input fields as
    `<input type="text"></input>` while an `XHTML1_STRICT` would render it as `<input
    type="text" />`. The `Doctype` helper is more than essential if we want to use
    the validation service of the W3C.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `Doctype` 助手对于其他视图助手是至关重要的，因为它们（例如在表单元素的情况下）基于所选类型做出渲染决策。例如，一个 `HTML4_* doctype`
    可能会将输入字段渲染为 `<input type="text"></input>`，而 `XHTML1_STRICT` 会将其渲染为 `<input type="text"
    />`。如果我们想使用 W3C 的验证服务，`Doctype` 助手不仅仅是至关重要的。
- en: The URL view helper explained
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: URL 视图助手的解释
- en: A nifty little thing the URL view helper is, it builds up URL's depending on
    named route that we have defined in our configuration. This means that if we want
    to build up a correctly formed URL we can use this view helper to build it up
    for us.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: URL 视图助手是个小巧实用的工具，它会根据我们在配置中定义的命名路由构建 URL。这意味着如果我们想构建一个正确格式的 URL，可以使用这个视图助手来帮我们构建。
- en: The Partial view helper explained
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释部分视图助手
- en: The `Partial` view helper is particularly helpful when we want to divide our
    layout into different parts, something that is always useful if we want to make
    sure our templates are maintainable and in a condition to re-use them in multiple
    places.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Partial`视图助手在我们想要将布局分成不同的部分时特别有用，如果我们想确保我们的模板可维护并且可以在多个地方重用，这总是很有用的。'
- en: The directory we store the partial views in is not strictly set, but it is recommended
    to place them in a location where we can find them whenever we require them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们存储部分视图的目录不是严格规定的，但建议将它们放置在一个我们可以随时找到它们的位置。
- en: There's more…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: We only discussed four view helpers which are default in Zend Framework 2, however
    there are tons more view helpers in the framework by default which are just as
    useful as well. Personally I would recommend looking through those as well and
    get to know them a bit as most of them are quite interesting even if you would
    never use them. Especially the `Cycle`, `Gravatar`, `HeadStyle`, and `HeadTitle`
    view helpers can come in handy when we are building a HTML page set up.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只讨论了四个默认在Zend Framework 2中的视图助手，然而框架中默认还有大量的视图助手同样有用。我个人会建议也浏览一下那些，并稍微了解一下它们，因为即使你永远不会使用它们，它们中的大多数也非常有趣。特别是`Cycle`、`Gravatar`、`HeadStyle`和`HeadTitle`视图助手，在我们构建HTML页面设置时可能会很有用。
- en: A complete list of the view helpers is always available in the official Zend
    Framework 2 documentation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 视图助手的完整列表始终可在官方Zend Framework 2文档中找到。
- en: Creating a global layout template
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建全局布局模板
- en: The view scripts can be very dynamic but most of the time we need a global template
    that we want to wrap around the output from our `Action` view scripts. This recipe
    will explain exactly how to do that, and also tells us how that would work.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 视图脚本可以非常动态，但大多数时候我们需要一个全局模板，我们希望将其包裹在来自我们的`Action`视图脚本输出的内容周围。这个配方将详细解释如何做到这一点，并告诉我们它是如何工作的。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe a working Zend Framework 2 skeleton application is needed as
    we will do some creating and editing of some files which are used in there.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，需要一个工作的Zend Framework 2骨架应用程序，因为我们将创建和编辑一些文件，这些文件在其中使用。
- en: How to do it…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The following is how we set about achieving this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何着手实现这一目标的：
- en: Creating the main layout file
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建主布局文件
- en: 'Let''s now create the main file `/module/Application/view/layout/layout.phtml`
    we use to create our layout:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建主文件`/module/Application/view/layout/layout.phtml`，我们用它来创建我们的布局：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have now set up the head tag successfully, and used a lot of the view helpers
    available to make our lives a little bit easier when it comes to adding head-related
    tags.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功设置了head标签，并使用了大量的视图助手来使我们在添加与head相关的标签时生活变得更加轻松。
- en: 'Now let''s set up a simple code body and see what we can do there:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们设置一个简单的代码主体，看看我们能在那里做什么：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Well that was it, once we output the `content` variable, it basically renders
    the content generated from the controller/action output.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，就是这样，一旦我们输出了`content`变量，它基本上就会渲染从控制器/操作输出生成的内容。
- en: Creating the error templates
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建错误模板
- en: The error files are easily created as they only require a couple of things.
    Let's create the `/module/Application/view/error/404.phtml` file first as that
    one is fairly straight forward.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 错误文件很容易创建，因为它们只需要几样东西。让我们首先创建`/module/Application/view/error/404.phtml`文件，因为它相当直接。
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are more variables we can use to show the user what went wrong in the
    routing, and we can also see, for example, what they requested, but usually those
    are more for development only and not for a production server as we don't want
    to expose too much data.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用更多的变量来向用户显示在路由中出了什么问题，我们也可以查看，例如，他们请求了什么，但通常这些更多是用于开发而不是用于生产服务器，因为我们不想暴露太多数据。
- en: Now let's create the file (`/module/Application/view/error/index.phtml`) that
    will be shown when we end up having an exception, one of the favorite things of
    a developer (not, obviously).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个文件（`/module/Application/view/error/index.phtml`），当出现异常时，它将被显示出来，这是开发者最喜欢的事情之一（显然不是）。
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `AbstractActionController` shows the errors when they occur and also selects
    the right template (which is defined in the `view_manager` configuration) to use
    for the error messages. The only thing we have to do is to make sure the templates
    are there.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractActionController`在错误发生时显示错误，并选择正确的模板（在`view_manager`配置中定义）用于错误消息。我们唯一要做的就是确保模板存在。'
- en: A global layout is an excellent idea if we would be using the MVC model of Zend
    Framework 2 and are expecting to use the same layout over and over again, which
    is what happens in most cases.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要使用Zend Framework 2的MVC模型并且预期会反复使用相同的布局，那么全局布局是一个很好的主意，这在大多数情况下都会发生。
- en: Creating a global layout will really make our lives easier, as it is a way of
    making our code more maintainable, and as a coder that is one of the most important
    tools in your toolset.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个全局布局将真正使我们的生活变得更简单，因为这是一种使我们的代码更易于维护的方法，作为一个程序员，这是你工具箱中最重要工具之一。
- en: First of all we need to make sure the `view_manager` has been defined properly,
    this has been described in the *Working with View* recipe, so we assume that we
    are using the same configuration at this point.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保`view_manager`已经被正确定义，这在*使用视图*菜谱中已经描述过，所以我们假设在这个点上我们使用的是相同的配置。
- en: We used the `inlineScript` view helper to make sure the content can also output
    scripts that are not part of the head tag, but should still be used in the output.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`inlineScript`视图助手来确保内容也可以输出不是head标签部分的脚本，但仍然应该用于输出。
- en: We would like to use `inlineScript` to define any scripts instead of adding
    them to the template files as we want to separate the JavaScript with the normal
    HTML content as far as we can (we also want inline scripts to be reusable if we
    can, and it looks better maintenance wise).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用`inlineScript`来定义任何脚本，而不是将它们添加到模板文件中，因为我们希望尽可能地将JavaScript与正常的HTML内容分开（我们还想尽可能使内联脚本可重用，从维护的角度来看，这看起来更好）。
- en: The error template example is a very basic error document that is shown when
    an exception is happening. There are even more options we could do after this,
    for example if there were more exceptions, we could get them by doing `$this->exception->getPrevious()`
    and then parsing through them as an array.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 错误模板示例是一个非常基本的错误文档，当发生异常时显示。我们还可以做更多的事情，例如，如果有更多的异常，我们可以通过`$this->exception->getPrevious()`来获取它们，然后作为数组解析它们。
- en: Creating reusable Views
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可重用视图
- en: In this time of dynamic applications we have widgets or content that can be
    used more than once. Instead of getting everything at the same time we want to
    be able to dynamically load new objects in, or at least not have to do a lot to
    get functionality working.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个动态应用程序的时代，我们有可以多次使用的部件或内容。我们不想一次性获取所有内容，而是希望能够动态地加载新的对象，或者至少不需要做很多工作就能让功能正常工作。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe we need nothing more than a working Zend Framework 2 skeleton
    application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们需要的只是一个工作的Zend Framework 2骨架应用程序。
- en: How to do it…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In this recipe we'll be discussing how to create reusable templates and the
    best way of using them in an application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论如何创建可重用模板以及最佳的使用方法。
- en: Use the Action view helper to get the re-usable content
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Action视图助手获取可重用内容
- en: 'The `Action` view helper is a great way of calling different actions in our
    code to retrieve other parts of our application:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action`视图助手是调用我们代码中的不同动作以检索应用程序其他部分的一个很好的方法：'
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Define a child to the ViewModel instance
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将子对象定义为ViewModel实例
- en: 'First of all we should create a simple view script (`/module/Application/view/application/template/sidebar.tpl`)
    to output:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该创建一个简单的视图脚本（`/module/Application/view/application/template/sidebar.tpl`）来输出：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After that we need to be in the controller (`/module/Application/src/Application/Controller/IndexController.php`).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要在控制器中（`/module/Application/src/Application/Controller/IndexController.php`）。
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now we have the controller set up, we would want to output the child as well
    in our view script. We will be using a similar HTML layout as the first method
    so that we can spot the differences.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了控制器，我们希望在视图脚本中也输出子对象。我们将使用与第一种方法相似的HTML布局，这样我们就可以发现它们之间的差异。
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When we are developing web applications, we find ourselves at a point where
    we need to re-use the content that we already made before, such as the build-up
    of a form or maybe the layout of a side bar that we want to use on multiple pages.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在开发Web应用程序时，我们会发现自己需要重复使用之前已经制作的内容，比如表单的构建或我们想在多个页面上使用的侧边栏布局。
- en: 'What we can do in that instance is two things:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，我们可以做两件事：
- en: Use the `Action` view helper to get the re-usable content
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Action视图助手获取可重用内容
- en: Define a child to the `ViewModel` instance
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将子对象定义为`ViewModel`实例
- en: Both of these methods can be used in different situations, let's explore the
    both options.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都可以在不同的场景中使用，让我们来探讨这两种选项。
- en: The Action view helper explained
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动作视图助手的解释
- en: We primarily would want to use this *if the re-usable content is outside the
    current module*, for example if the content is created by a module that provides
    page widgets then it can be used anywhere in the application. If we want to use
    a content that is inside our module, we better use the second option as that is
    less performance heavy because it doesn't go through the whole routing and dispatching
    process like the first option does.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要想使用这个（如果可重用内容在当前模块之外），例如，如果内容是由提供页面小部件的模块创建的，那么它可以在应用的任何地方使用。如果我们想在模块内部使用内容，我们最好使用第二个选项，因为它比第一个选项轻量级，因为它不需要经历整个路由和分发过程。
- en: What this view helper does is call an action within a view script, and post
    the results of that action call to the current view script.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图助手所做的就是在视图脚本内部调用一个动作，并将该动作调用的结果发送到当前视图脚本。
- en: If we look at the first example, it makes the call to the action and renders
    the output inside the current view script. The difference between this and the
    use of a partial view script is that this will go through the whole routing and
    dispatching process, while a partial simply displays the rendered output. If we,
    for example, need to get records from the database, a partial just wouldn't cut
    it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看第一个例子，它会在当前视图脚本内部调用动作并渲染输出。与使用部分视图脚本相比，区别在于这个过程会经历整个路由和分发过程，而部分视图只是简单地显示渲染后的输出。如果我们，例如，需要从数据库中获取记录，部分视图就不够用了。
- en: Defining a child to a ViewModel instance explained
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义ViewModel实例的子项解释
- en: This method of rendering re-usable content is primarily used *when the re-usable
    content is inside the current module*, for example when we would like to use a
    specific overview table that relies on requires more intelligence than, for instance,
    a view helper would be able to provide. The content we are rendering would not
    require us to mess around in different modules, we'd rather stay away from relying
    on other modules from within our controller. We generally want to keep the modules
    as separate as possible so that we are able to run the application, even if one
    of the other modules is not available.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种渲染可重用内容的方法主要用于（当可重用内容在当前模块内部时），例如，当我们想使用一个特定的概述表，它需要比视图助手能提供的更多智能时。我们渲染的内容不需要我们在不同的模块中捣鼓，我们更愿意远离在控制器内部依赖其他模块。我们通常希望尽可能保持模块的独立性，这样我们才能运行应用，即使其他模块中有一个不可用。
- en: If we look at the example shown in *How it works* now, we can see that it has
    slightly more work to do in this method instead of the view helper class, but
    the difference is that the view helper class needs to do more in the background
    to get it all to work.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看看*如何工作*中展示的例子，我们可以看到在这个方法中比视图助手类有更多的工作要做，但区别在于视图助手类需要在后台做更多的工作来使一切工作。
- en: Pros and cons
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优缺点
- en: Some might disagree when we say that we primarily should use the `Action` view
    helper outside the current module, and there are probably good reasons for why
    we should. One of the arguments against it is that it is simpler for the developer
    (or designer in most cases) to get the content from different locations without
    being bound by adding it as a `ViewModel` child in the controller. However, the
    view helper class does require the framework to find the action, controller and
    module first, render them, and then output them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说我们主要应该在当前模块之外使用`Action`视图助手时，有些人可能会不同意，可能也有很好的理由。反对意见之一是，对于开发者（或大多数情况下的设计师）来说，从不同位置获取内容更简单，而不必受限于在控制器中添加作为`ViewModel`子项。然而，视图助手类确实需要框架首先找到动作、控制器和模块，然后渲染它们，最后输出它们。
- en: Although simpler in set up, it does strain the web application more if we use
    this option without good reason. Sometimes it is just better to code more and
    use the benefit of the speed of the application, then be lazy and let the application
    reduce its speed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然设置起来更简单，但如果我们没有充分的理由使用这个选项，它会对网络应用造成更大的压力。有时，编写更多的代码并利用应用速度的优势，然后变得懒惰，让应用降低速度，可能更好。
- en: Sure everything has its pros and cons, so we should always consider the situation
    first to make sure we get the most maintainable and re-usable code possible.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每件事都有其利弊，所以我们应该首先考虑情况，以确保我们得到尽可能可维护和可重用的代码。
- en: Using view strategies/renderers
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视图策略/渲染器
- en: Normally we will use the View to output HTML, but sometimes we want a more diverse
    way of outputting for example JSON or XML. This recipe will provide us with enough
    information to accomplish this easily.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将使用视图来输出 HTML，但有时我们想要以更多样化的方式输出，例如 JSON 或 XML。这个配方将为我们提供足够的信息来轻松完成这项任务。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We simply require the Zend Framework 2 skeleton application to get us going
    with this recipe. Nothing exotic is required.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要使用 Zend Framework 2 的骨架应用来开始这个配方。不需要任何特别的东西。
- en: How to do it…
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Using different view strategies and renderers is a common practice in an application.
    In this recipe we'll explain how to do that.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中使用不同的视图策略和渲染器是一种常见的做法。在这个配方中，我们将解释如何做到这一点。
- en: Adding a view strategy
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加视图策略
- en: 'We can easily add a view strategy to our application by simply appending the
    `view_manager` configuration in the module configuration file (`/module/Restful/config/module.config.php`)
    as shown as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地追加模块配置文件中的 `view_manager` 配置来轻松地为我们的应用程序添加视图策略（`/module/Restful/config/module.config.php`），如下所示：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The JSON strategy
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON 策略
- en: 'If we receive output from the JSON strategy, it might look very much like the
    following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从 JSON 策略中收到输出，它可能看起来非常像以下内容：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The Feed strategy
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源数据策略
- en: 'Using the Feed strategy is quite similar to the other strategies, as we can
    see in the following example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用源数据策略与其他策略非常相似，正如以下示例所示：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have now set up our main data, which will be needed to generate our feed.
    Now let''s add some sample data to the output:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经设置了主数据，这些数据将用于生成我们的源数据。现在让我们添加一些示例数据到输出中：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we need to parse through the data (I know, it''s a bit weird as we just
    declared it, but in reality this would never happen) and put them in the feed
    as an entry:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要解析数据（我知道，这有点奇怪，因为我们刚刚声明了它，但在现实中这种情况永远不会发生），并将它们作为条目放入源数据中：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now all that is left to do is export the feed to a specific format and add it
    to the actual `FeedModel` class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的工作就是将源数据导出为特定的格式，并将其添加到实际的 `FeedModel` 类中。
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The view strategy class
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图策略类
- en: The default view strategy used in the Zend Framework 2 skeleton application
    is the `PhpRenderer` class, which does nothing more than search for a `.phtml`
    file in a defined location; by default this would be `/module/ModuleName/view`.
    The `PhpRenderer` class is able to parse PHP inside the view scripts, which makes
    it handy (but also very familiar) to perform some last minute scripting for our
    layout, such as parsing through records to create a table or displaying a username,
    for example.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Zend Framework 2 框架应用的骨架中使用的默认视图策略是 `PhpRenderer` 类，它所做的只是在一个定义的位置搜索 `.phtml`
    文件；默认情况下，这将是 `/module/ModuleName/view`。`PhpRenderer` 类能够解析视图脚本中的 PHP 代码，这使得它对于执行一些最后的脚本操作非常方便（但也非常熟悉），例如解析记录以创建表格或显示用户名等。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although PHP is allowed in the `PhpRenderer` class, it should be mentioned that
    the developer should be wary of putting business logic in the view script. Logic
    should be placed in the model or at least the controller as it was never intended
    to reside in the view script.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 `PhpRenderer` 类中允许使用 PHP，但应该指出，开发者应该小心不要在视图脚本中放置业务逻辑。逻辑应该放在模型或至少控制器中，因为它们从未打算驻留在视图脚本中。
- en: This strategy will always be used whenever there is no other strategy available.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个策略将在没有其他策略可用时始终被使用。
- en: The default view strategies
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认视图策略
- en: 'There are a small number of view strategies readily available in Zend Framework
    2, they are:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Zend Framework 2 中，现成可用的视图策略数量很少，它们是：
- en: The PHP strategy (default)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP 策略（默认）
- en: The JSON strategy
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 策略
- en: The Feed strategy
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源数据策略
- en: The JSON strategy explained
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON 策略的解释
- en: A JSON object is short for JavaScript Object Notation and is a text based, human-readable
    output format that is mainly used in modern web services around the world. It
    is derived from the JavaScript language and thus, resembles a lot of its features.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 对象是 JavaScript 对象表示法的简称，它是一种基于文本、可读的输出格式，主要在全世界现代网络服务中使用。它是从 JavaScript
    语言派生出来的，因此，它具有很多类似的特点。
- en: This is probably a nice example as we have put new lines in the output, while
    the actual JSON strategy will never contain that. But hey, if it is server-to-server
    talk only, why would we care?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个很好的例子，因为我们已经在输出中添加了新行，而实际的 JSON 策略永远不会包含这些。但是，嘿，如果只是服务器之间的通信，我们为什么要关心呢？
- en: The JSON strategy doesn't require a template or view script as it basically
    parses through the variables used in the view model, simple!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 策略不需要模板或视图脚本，因为它基本上解析视图模型中使用的变量，简单！
- en: The Feed strategy explained
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Feed 策略解释
- en: The Feed strategy outputs an XML news feed that can be used , for example, by
    users to subscribe on as an RSS or RSS2 formatted feed. Using the view model of
    the Feed strategy is a bit different though as directly setting the variables
    in the view model directly might be a tricky thing to do. Instead of that you
    can use a `Zend\Feed\Writer\Feed` object to determine the layout of your feed,
    and then feeding it to the `FeedModel` by passing it as a parameter to the `setFeed`
    method.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Feed 策略输出一个 XML 新闻源，可以被用户订阅，例如，作为 RSS 或 RSS2 格式的源。不过，使用 Feed 策略的视图模型会有点不同，因为直接在视图模型中设置变量可能是一个棘手的问题。相反，你可以使用一个
    `Zend\Feed\Writer\Feed` 对象来确定源布局，然后通过将对象作为参数传递给 `setFeed` 方法来将其传递给 `FeedModel`。
- en: More about view strategies
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多关于视图策略
- en: The nice thing about Zend Framework 2 is that it isn't really hard to change
    the output, as it comes with a technique called view strategies, and in effect
    view renderers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Zend Framework 2 的优点在于，更改输出并不是特别困难，因为它自带了一种称为视图策略的技术，实际上就是视图渲染器。
- en: A view strategy is a class that identifies a model and returns a view renderer,
    which on its turn renders the output of the content. The view strategy will determine
    which renderer to use and how to use it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 视图策略是一个类，它识别一个模型并返回一个视图渲染器，该渲染器随后渲染内容的输出。视图策略将确定使用哪个渲染器以及如何使用它。
- en: Most of the time view strategies come with their own view model as well, which
    is to make sure the content we want to output is compatible with the renderer.
    The view strategy will, upon receiving the model, determine if it can or cannot
    render a certain model.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，视图策略都会附带自己的视图模型，这是为了确保我们想要输出的内容与渲染器兼容。视图策略在接收到模型后，将确定是否可以或不能渲染某个模型。
- en: For example, the JSON renderer in the framework only renders models of the type
    `JsonModel` and will, when receiving a `ViewModel`, do nothing as it is technically
    not compatible with the renderer.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，框架中的 JSON 渲染器只渲染 `JsonModel` 类型的模型，当接收到 `ViewModel` 时，它将不执行任何操作，因为它在技术上与渲染器不兼容。
- en: Sometimes we just need to output content in a different way. If we are talking
    about REST services, RSS feeds, or just something custom, we should always be
    able to switch between different output formats without needing to do too much
    work.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们只需要以不同的方式输出内容。如果我们谈论 REST 服务、RSS 源或自定义内容，我们总是应该能够在不做太多工作的情况下在不同的输出格式之间切换。
- en: Using context switching for a different output
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文切换实现不同的输出
- en: Not only do we want to be able to output the content through different view
    strategies, we sometimes also want to do this on demand, so that we can switch
    the output, for example, from HTML to JSON by simply changing the headers in our
    request.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅想要能够通过不同的视图策略输出内容，有时还希望按需这样做，这样我们就可以通过简单地更改请求中的头部来切换输出，例如，从 HTML 切换到 JSON。
- en: Getting ready
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In some cases (for example, in the REST servers) it is necessary to switch the
    response output of the content depending on what the user asks for. The user can
    add an `Accept` header to let the server know which output formats it accepts,
    for example `application/json`, and `text/html`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下（例如，在 REST 服务器中），根据用户的要求切换内容的响应输出是必要的。用户可以添加一个 `Accept` 头部来让服务器知道它接受哪些输出格式，例如
    `application/json` 和 `text/html`。
- en: 'What we are going to do is create a simple website that will output a `text/html`
    format on default (which is normal), but it will also output a JSON string whenever
    we have `Accept: */json` in our header.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将要创建一个简单的网站，默认情况下输出 `text/html` 格式（这是正常的），但每当我们的头部有 `Accept: */json` 时，它也会输出
    JSON 字符串。'
- en: How to do it…
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Sometimes we want to cater not just to the users that view our website, but
    to a lot of different audiences, for example, the Feed readers or other applications.
    Therefore we'll discuss how to switch contexts in this recipe.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们不仅想要满足查看我们网站的用户，还想要满足许多不同的受众，例如，源阅读器或其他应用程序。因此，我们将讨论如何在配方中切换上下文。
- en: Define multiple strategies to output
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义多个策略以输出
- en: 'First we want to make sure we have the JSON view strategy lined up so that
    we can easily switch between views. We can do this by adding `ViewJsonStrategy`
    in the `/module/Restful/config/module.config.php` as shown as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要确保我们有了JSON视图策略就绪，这样我们就可以轻松地在视图之间切换。我们可以通过在 `/module/Restful/config/module.config.php`
    中添加 `ViewJsonStrategy` 来实现，如下所示：
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Determine the view model based on the Accept header
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据Accept头确定视图模型
- en: In the controller there is a nifty little controller plugin called `AcceptableViewModelSelector`,
    which can be used to return a view model that is based on the `Accept` header.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器中，有一个叫做 `AcceptableViewModelSelector` 的小巧控制器插件，它可以用来返回基于 `Accept` 头部的视图模型。
- en: 'So to make things a bit clear, we first want to define which kind of models
    we want to support in our output. Let''s create a property in our controller that
    regulates which view models we are supporting:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让事情更清晰，我们首先想要定义我们希望在输出中支持哪种类型的模型。让我们在我们的控制器中创建一个属性来调节我们支持哪些视图模型：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As we can see here, we will support two models in order of priority. First of
    all we want the default view model to use the normal `PhpRenderer` class, so that
    users will get to see the normal HTML output. Second of all we want any `application/json`
    or `text/json` to be rendered by our `JsonRenderer` class.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们将按照优先级支持两种模型。首先，我们希望默认视图模型使用正常的 `PhpRenderer` 类，这样用户将看到正常的HTML输出。其次，我们希望任何
    `application/json` 或 `text/json` 都由我们的 `JsonRenderer` 类渲染。
- en: 'Now let''s create a simple `indexAction` method and make use of the view model''s
    selecting abilities there:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个简单的 `indexAction` 方法，并利用视图模型的选择能力：
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: And that's how we do it folks! That was as simple as it can get as `AcceptableViewModelSelector`
    does all the work for us, and the only thing we have to do is make sure everything
    is declared in the model.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，朋友们！这已经是最简单的方法了，因为 `AcceptableViewModelSelector` 为我们做了所有的工作，我们唯一需要做的就是确保模型中声明了一切。
- en: When we now add a view script for the normal `PhpRenderer` class, so that it
    renders our normal `text/html` output fine, we can say for sure that everything
    is done. Please make sure that this view script (`/module/Restful/view/restful/index/index.phtml`)
    resides in our new `Restful` module.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在为正常的 `PhpRenderer` 类添加视图脚本，以便它能够良好地渲染我们的正常 `text/html` 输出时，我们可以肯定一切都已经完成。请确保这个视图脚本（`/module/Restful/view/restful/index/index.phtml`）位于我们的新
    `Restful` 模块中。
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output for a user with `Accept: application/json` header would look like
    the following, For this we need no view script as the renderer immediately outputs
    this.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '对于具有 `Accept: application/json` 头部的用户，输出将如下所示，为此我们不需要视图脚本，因为渲染器会立即输出这个。'
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The default `PhpRenderer` output will look like the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 `PhpRenderer` 输出将如下所示：
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works…
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`AcceptableViewModelSelector` looks at the header sent with the request to
    determine which view model to use. It determines the model by looking in the `array`
    we parse into it and looking at the different `Accept` headers we have defined
    that we support.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`AcceptableViewModelSelector` 通过查看请求中发送的头部来决定使用哪个视图模型。它通过查看我们解析到其中的 `array`
    和查看我们定义并支持的不同 `Accept` 头部来决定模型。'
- en: Next it will take the key of that specific `array` item, and that will be the
    view model that will be instantiated.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它将取那个特定 `array` 项的键，那将是将被实例化的视图模型。
- en: There's more…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To test out different headers, I like to use the Mozilla Firefox browser with
    the Header Tool add-on ([https://addons.mozilla.org/en-us/firefox/addon/header-tool](https://addons.mozilla.org/en-us/firefox/addon/header-tool))
    installed, or similar Chrome extensions, or if we are feeling particularly brave,
    just the command line cURL. There you can just type the header you would like
    to send along, and turn it either on or off. However, there are different ways
    of sending headers as well. It depends on how you prefer doing things.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试不同的头部，我喜欢使用安装了Header Tool插件的Mozilla Firefox浏览器（[https://addons.mozilla.org/en-us/firefox/addon/header-tool](https://addons.mozilla.org/en-us/firefox/addon/header-tool)），或者类似的Chrome扩展，或者如果我们特别勇敢，可以直接使用命令行cURL。在那里，你可以输入你想要发送的头部，并打开或关闭它。然而，发送头部的方式也有不同。这取决于你更喜欢如何做事。
- en: Writing a custom view strategy/renderer
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义视图策略/渲染器
- en: Nothing is more exciting in coding than developing your own bits of custom features
    that integrate with the framework. In this recipe we will be discussing how to
    create our own XML view strategy. We will show you how to simply create the basis
    for a new strategy without too much of a bother.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码中，没有什么比开发自己的自定义功能并与框架集成更令人兴奋的了。在这个菜谱中，我们将讨论如何创建自己的 XML 视图策略。我们将向您展示如何简单地创建新策略的基础，而不会太麻烦。
- en: How to do it…
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Sometimes the default strategies and renderers provided are not enough for a
    specific situation, so let's talk through on how to create our own view strategy/renderer.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，默认的策略和渲染器提供的并不足以满足特定情况，所以让我们讨论一下如何创建我们自己的视图策略/渲染器。
- en: Creating the XmlOutput renderer
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 XmlOutput 渲染器
- en: Let us see first on how our renderer would look like, as that is possibly one
    of the laziest classes we will ever code. We will do this in a new class located
    in `/module/XmlOutput/src/XmlOutput/View/Renderer/XmlRenderer.php`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们的渲染器会是什么样子，因为这可能是我们编写的最懒惰的类之一。我们将在这个新类中完成这个任务，该类位于 `/module/XmlOutput/src/XmlOutput/View/Renderer/XmlRenderer.php`。
- en: '[PRE36]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The code for this model is very straightforward as we don't really need to do
    a lot of coding to get it working, we'll do this in the `/module/XmlOutput/src/XmlOutput/View/Model/XmlModel.php`
    file.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型的代码非常简单，因为我们实际上不需要编写很多代码就能让它工作，我们将在 `/module/XmlOutput/src/XmlOutput/View/Model/XmlModel.php`
    文件中完成这个任务。
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the previous code snippet we have a simple getter and setter for the encoding
    which will usually be UTF-8, as it is also declared as the default value in the
    property.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们有一个简单的编码获取器和设置器，它通常将是 UTF-8，因为它也被声明为属性的默认值。
- en: '[PRE38]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now we need to create the more exciting part, the `XmlStrategy` (located in
    `/module/XmlOutput/src/XmlOutput/View/Strategy/XmlStrategy.php`), which is the
    part that will actually tell the framework if, what, and how to render the content
    by handling the two View events (which is required).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建更令人兴奋的部分，即 `XmlStrategy`（位于 `/module/XmlOutput/src/XmlOutput/View/Strategy/XmlStrategy.php`），这是实际告诉框架如何、什么以及如何通过处理两个视图事件（这是必需的）来渲染内容的部分。
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Once again we defined all of the properties which we needed. The first one `$listeners`
    will contain an array of `CallbackHandler` which we will use to attach and detach
    events to the `EventManager` instance.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 再次定义了我们需要的所有属性。第一个 `$listeners` 将包含一个 `CallbackHandler` 数组，我们将使用它将事件附加和分离到 `EventManager`
    实例。
- en: The second member variable `$renderer` will store our `XmlRenderer` which we
    just created.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个成员变量 `$renderer` 将存储我们刚刚创建的 `XmlRenderer`。
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now we have defined our simple constructor, which basically assigns the given
    `XmlRenderer` class to our local property for safekeeping, which is the typical
    behavior of a rendering strategy. Next, we'll continue to implement the event
    handler.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了简单的构造函数，它基本上将给定的 `XmlRenderer` 类分配给我们的本地属性以进行安全存储，这是渲染策略的典型行为。接下来，我们将继续实现事件处理器。
- en: '[PRE41]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The last bit we need to do for the strategy is to attach and detach our events.
    The events methods in this case being `selectRenderer` and `injectResponse`, which
    will be triggered at different points in the code. The first one will be triggered
    when the event `ViewEvent::EVENT_RENDERER` happens and the second one will be
    triggered on `ViewEvent::EVENT_RESPONSE`. Once the framework has used everything
    it needs, it will call the `detach` method, and we then need to make sure all
    our events will be detached.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个策略，我们需要做的最后一件事是附加和分离我们的事件。在这种情况下的事件方法是 `selectRenderer` 和 `injectResponse`，它们将在代码的不同点被触发。第一个将在事件
    `ViewEvent::EVENT_RENDERER` 发生时被触发，第二个将在 `ViewEvent::EVENT_RESPONSE` 上被触发。一旦框架使用完它所需的一切，它将调用
    `detach` 方法，然后我们需要确保所有的事件都将被分离。
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next up is something we didn''t use before, which is the `ViewXmlStrategyFactory`
    class. The factory basically instantiates the `XmlStrategy` class (in this case)
    and makes sure everything is instantiated correctly. We''ll create our new file
    here: `/module/XmlOutput/src/XmlOutput/Service/ViewXmlStrategyFactory.php`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是之前我们没有使用过的东西，那就是 `ViewXmlStrategyFactory` 类。工厂基本上实例化了 `XmlStrategy` 类（在这种情况下）并确保一切都被正确实例化。我们将在以下位置创建我们的新文件：`/module/XmlOutput/src/XmlOutput/Service/ViewXmlStrategyFactory.php`
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: That's it, as we can see it is not a lot, and only the `createService` method
    is being defined in the class. In that method the only thing we do is get the
    `ViewXmlRenderer` parameter and make sure the `XmlStrategy` class is constructed
    with that renderer as a parameter.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，正如我们所看到的，这并不复杂，只是在类中定义了`createService`方法。在这个方法中，我们唯一做的事情是获取`ViewXmlRenderer`参数，并确保`XmlStrategy`类使用该渲染器作为参数被构造。
- en: Now let's take a look at `ViewXmlRendererFactory`(located in `/module/XmlOutput/src/XmlOutput/Service/ViewXmlRendererFactory.php`),
    which is also a factory but now for the renderer.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`ViewXmlRendererFactory`（位于`/module/XmlOutput/src/XmlOutput/Service/ViewXmlRendererFactory.php`），它也是一个工厂，但现在是为渲染器。
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Although this `createService` method was more work than the one before, it is
    still a very light method. The only thing that really happens here is that the
    `XmlRenderer` class is instantiated, and it made sure `ViewResolver` and `ViewHelperManager`
    are set.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个`createService`方法比之前的要复杂一些，但它仍然是一个非常轻量级的方法。这里真正发生的事情只是实例化了`XmlRenderer`类，并确保`ViewResolver`和`ViewHelperManager`被设置。
- en: Now we have set up our basic functionality, let's tie it all together so that
    we can start using it!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了基本功能，让我们将其全部整合起来，以便我们可以开始使用它！
- en: First of all we need to create the `/module/XmlOutput/config/module.config.php`
    file to make sure our services are instantiated properly, and our view manager
    knows the new strategy we offer.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建`/module/XmlOutput/config/module.config.php`文件，以确保我们的服务被正确实例化，并且我们的视图管理器知道我们提供的新策略。
- en: '[PRE45]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: That was rather painless, as we can simply tell `serviceManager` where everything
    is located and it will work immediately.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，因为我们只需告诉`serviceManager`一切的位置，它就会立即工作。
- en: The last thing we need to create in our new `XmlOutput` module is the `Module.php`
    file, which is basically the same as the default `Module.php` that comes with
    the Application module. We can simply copy that one over, change the namespace
    in the file and we are done. The file should be located in `/module/XmlOutput/Module.php`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新`XmlOutput`模块中，我们需要创建的最后一件事情是`Module.php`文件，这基本上与Application模块中提供的默认`Module.php`相同。我们可以简单地复制那个文件，更改文件中的命名空间，然后就可以完成。该文件应位于`/module/XmlOutput/Module.php`。
- en: '[PRE46]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now the `/config/application.config.php` file needs to have our new module added,
    so that the framework will try to instantiate that module as well. We can just
    add `XmlOutput` to the modules array and we are done, nothing else needs changing
    in there.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要将我们的新模块添加到`/config/application.config.php`文件中，这样框架就会尝试实例化该模块。我们只需将`XmlOutput`添加到模块数组中，然后就可以完成，那里不需要做任何其他更改。
- en: '[PRE47]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Everything is ready and set up for use, so now it is time to actually get the
    ball rolling and output something to XML. First up is using `XmlModel` in our
    `indexAction` of the `IndexController` (located in `/module/Application/src/Application/Controller/IndexController.php`).
    We will just assign some variables to `XmlModel` and return this immediately,
    no need for anything fancy now.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都已准备就绪并设置好，现在是时候真正开始行动，将内容输出为XML。首先，我们将在`IndexController`的`indexAction`（位于`/module/Application/src/Application/Controller/IndexController.php`）中使用`XmlModel`。我们只需将一些变量分配给`XmlModel`并立即返回，现在不需要任何花哨的东西。
- en: '[PRE48]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Once we have done that, we can build up our view script (located in `/module/Application/view/application/index/index.phtml`)
    with the necessary XML.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这些，我们就可以构建我们的视图脚本（位于`/module/Application/view/application/index/index.phtml`），并添加必要的XML。
- en: '[PRE49]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: And that is it! Once we run it, we can now see that our HTTP headers are set
    to `application/xml` and that the output is the XML we have just put in. Obviously
    this is nothing fancy, but it is to show how easy it is to just create our own
    view strategy.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！一旦运行，我们现在可以看到我们的HTTP头设置为`application/xml`，输出的是我们刚刚放入的XML。显然，这并不复杂，但它展示了创建我们自己的视图策略是多么容易。
- en: How it works…
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Because we added our factories to the `ServiceManager`, we can easily get them
    to use by their aliases `ViewXmlStrategy` and `ViewXmlRenderer`. And because we
    told the `ViewManager` that our new strategy `ViewXmlStrategy` exists, we can
    get the ball rolling.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将我们的工厂添加到了`ServiceManager`中，我们可以很容易地通过它们的别名`ViewXmlStrategy`和`ViewXmlRenderer`来使用它们。并且因为我们已经告诉`ViewManager`我们的新策略`ViewXmlStrategy`存在，我们可以开始行动。
- en: As we would use the `XmlModel` in our controller, the framework will iterate
    through all the view strategies to determine the proper strategy to use. Once
    it has found the strategy it needs, it will trigger the `EVENT_RENDERER` and `EVENT_RESPONSE`
    events, which in turn will trigger our strategy methods. These methods will determine
    the output of our content.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在控制器中使用`XmlModel`，框架将遍历所有视图策略以确定要使用的正确策略。一旦它找到了所需的策略，它将触发`EVENT_RENDERER`和`EVENT_RESPONSE`事件，这些事件反过来将触发我们的策略方法。这些方法将确定内容的输出。
- en: Our renderer makes sure the content is rendered properly. In our case we took
    the lazy way out and let `PhpRenderer` basically do all the work, this can however
    vary per renderer.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的渲染器确保内容被正确渲染。在我们的例子中，我们采取了偷懒的方式，让`PhpRenderer`基本上完成所有工作，但这可能因渲染器而异。
- en: We are creating this new view strategy as a separate module, with separate namespaces
    so that we can easily transfer this to another application if we ever need to.
    And of course it comes with greater maintainability when we separate pieces of
    functionality as well.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建这个新的视图策略作为一个独立的模块，具有独立的命名空间，这样我们就可以轻松地将它转移到另一个应用程序中。当然，当我们将功能组件分开时，这也带来了更高的可维护性。
- en: When we are done we can easily extend the classes further as we wish, but for
    now let's keep it basic.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成时，我们可以很容易地根据需要进一步扩展类，但现在是保持基本。
- en: 'There are five files that need to be created before we can have at least the
    most basic form of a custom view strategy; the files need to be of the following
    forms:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以至少拥有自定义视图策略的最基本形式之前，需要创建五个文件；这些文件需要以下形式：
- en: Renderer
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染器
- en: Model
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型
- en: Strategy
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略
- en: Strategy Factory
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略工厂
- en: Renderer Factory
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染器工厂
- en: The first three we already know as we've discussed in this chapter, the last
    two Factory ones', however, are new to us.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个我们已经知道了，因为我们已经在本章中讨论过，但最后两个工厂的却是新的。
- en: The XmlRenderer and XmlModel
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XmlRenderer 和 XmlModel
- en: Because we just want to output XML as a string, we will be using the `PhpRenderer`
    as that does the exact same thing as we want it to do.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们只想将XML作为字符串输出，所以我们将使用`PhpRenderer`，因为它确实做了我们想要它做的确切的事情。
- en: Next up is coding the model. As described earlier, the model will be used in
    the controller to store variables which we can then use in the View. We will be
    creating the XmlModel so that when we use this model in our controller our framework
    knows we want to output with our `XmlStrategy`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是编码模型。如前所述，该模型将在控制器中使用以存储变量，然后我们可以在视图中使用这些变量。我们将创建XmlModel，以便当我们在这个控制器中使用这个模型时，我们的框架知道我们想要使用我们的`XmlStrategy`输出。
- en: 'As we can see we made all the properties in the `XmlModel` protected, because
    these properties are protected in the class we are trying to extend (`ViewModel`)
    as well. It is necessary while extending a property to give it the same access
    level or lower. In this case it is protected, which means the lower option would
    be public. Private, however, would result in a fatal error shown as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们在`XmlModel`中把所有属性都设置为受保护的，因为这些属性在我们试图扩展的类（`ViewModel`）中也是受保护的。在扩展属性时，有必要给它相同的访问级别或更低的级别。在这种情况下，它是受保护的，这意味着较低的选项是公共的。然而，私有会导致如下所示的致命错误：
- en: '[PRE50]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The last bit we need to do in the `XmlModel` is create the getter and setter
    for the content type, which in our case would become `application/xml`, because
    we want to output XML, not plain text.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在`XmlModel`中我们需要做的最后一件事是为内容类型创建getter和setter，在我们的例子中这将变成`application/xml`，因为我们想要输出XML，而不是纯文本。
- en: The XmlStrategy
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XmlStrategy
- en: In `selectRenderer` we want to make sure that the model we have is also the
    model we expect it to be. If this is not the case we cannot return a renderer,
    meaning that the framework needs to search for a different kind of renderer. For
    example, the use of a `ViewModel` instance would result in `selectRenderer` returning
    null, which would tell the framework to search for another suitable strategy.
    In this case it might be the `PhpStrategy`, which in this case would accept `ViewModel`
    as a valid model, and that is how the view strategy communicates to the framework
    to tell it if he can use the model or not.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在`selectRenderer`中，我们想要确保我们拥有的模型也是我们期望的模型。如果不是这样，我们无法返回一个渲染器，这意味着框架需要寻找另一种类型的渲染器。例如，使用`ViewModel`实例会导致`selectRenderer`返回null，这将告诉框架寻找另一种合适的策略。在这种情况下，可能是`PhpStrategy`，在这种情况下，它将接受`ViewModel`作为有效的模型，这就是视图策略如何与框架通信，告诉它是否可以使用该模型。
- en: The `injectResponse` is a method that will ready the content for output, and
    makes sure that the content type is set in the headers as well. The `ViewEvent`
    given as a parameter that contains all the collected information we need, such
    as the `XmlModel`, and also its Response. The next bit of code will tie the last
    two methods we just created together and use them as handlers for the respective
    `ViewEvent::EVENT_RENDERER` and `ViewEvent::EVENT_RESPONSE` events.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`injectResponse` 是一个方法，它将准备输出内容，并确保内容类型已设置在头部。作为参数提供的 `ViewEvent` 包含我们所需的所有收集到的信息，例如
    `XmlModel`，以及其响应。接下来的代码将把刚刚创建的最后两个方法结合起来，并将它们用作相应 `ViewEvent::EVENT_RENDERER`
    和 `ViewEvent::EVENT_RESPONSE` 事件的处理器。'
- en: There's more…
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We said before we were a bit lazy with the renderer, basically putting off any
    of the work by putting all of the work in the hands of the `PhpRenderer`, which
    in turn basically rendered the view script containing the XML. Naturally one would
    desire a renderer which makes the use of view scripts obsolete, and just creates
    the XML from an array in the `XmlModel`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到我们对渲染器有点懒，基本上是把所有的工作都推给了 `PhpRenderer`，它反过来又基本上渲染了包含 XML 的视图脚本。自然地，人们会希望有一个使视图脚本变得过时的渲染器，它只需从
    `XmlModel` 中的数组创建 XML。
- en: So yes, there is a lot more that can be said, but the real fun starts if we
    start exploring the different ways of rendering content.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 所以是的，还有很多可以说的，但如果我们开始探索渲染内容的不同方式，真正的乐趣就开始了。
