- en: Chapter 5. Summoning the Test Doubles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 调用测试替身
- en: In this chapter, we are going to take a close look at test doubles in order
    to control our tests with more accuracy and avoid having to rely on interfaces
    we don't know anything about.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将仔细研究测试替身，以便更精确地控制我们的测试，并避免依赖于我们一无所知的接口。
- en: We're going to complete the work we started in the previous chapter and understand
    how to deal with external dependencies, particularly the difference between stubs
    and mocks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将完成上一章开始的工作，并了解如何处理外部依赖，特别是存根和模拟之间的区别。
- en: We will then spend the rest of the chapter on understanding how to organize
    our tests to improve legibility and maintainability, using some BDD-oriented tools
    we've introduced earlier in the book, such as **Specify** and **Verify**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将花费本章的剩余时间来了解如何组织我们的测试，以提高可读性和可维护性，使用我们在书中早期介绍的一些面向BDD的工具，例如**Specify**和**Verify**。
- en: 'On a high level, these are the topics that we will cover in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，这些是我们将在本章中涉及的主题：
- en: Dealing with external dependencies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理外部依赖
- en: Isolating components with stubs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用存根隔离组件
- en: Listening for calls with an observer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用观察者监听调用
- en: Writing maintainable unit tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可维护的单元测试
- en: Dealing with external dependencies
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理外部依赖
- en: We left our suite of unit tests at an almost complete status. What we had left
    to cover with tests was the `validatePassword()` method from our `User` model
    class.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的单元测试套件留在了几乎完成的状态。我们剩下要测试的是来自我们的`User`模型类的`validatePassword()`方法。
- en: The problem that this method is giving us is that we are planning to use our
    beloved security component, kindly provided by Yii, to encrypt and decrypt the
    password and verify its correctness. This component is available throughout the
    life of the application via `Yii::$app->getSecurity()`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法给我们带来的问题是，我们计划使用我们喜爱的由Yii提供的、友好提供的安全组件来加密和解密密码，并验证其正确性。该组件在整个应用程序的生命周期中通过`Yii::$app->getSecurity()`可用。
- en: The `yii\base\Security` class exposes a series of methods to help you strengthen
    your application. The use we will make of it is quite limited, but I would recommend
    reading a bit more about it on the official documentation available at [http://www.yiiframework.com/doc-2.0/guide-security-authentication.html](http://www.yiiframework.com/doc-2.0/guide-security-authentication.html)
    and the following sections that will cover all aspects of authentication, encryption,
    and so forth.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`yii\base\Security`类公开了一系列方法来帮助您加强您的应用程序。我们将对其的使用相当有限，但我建议您阅读一下官方文档，该文档可在[http://www.yiiframework.com/doc-2.0/guide-security-authentication.html](http://www.yiiframework.com/doc-2.0/guide-security-authentication.html)找到，并阅读以下部分，这些部分将涵盖所有关于身份验证、加密等方面的内容。'
- en: 'Let''s then define how we think our implementation should work for this method.
    The documented use for validating the password is the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义我们认为这个方法应该如何工作的实现方式。验证密码的文档化用途如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This means that we will need to create the password hash first by using the
    aforementioned helper class, set it in the user, and then can use the `$user->validatePassword()`
    method to check whether the actual cleartext password that is passed matches the
    internal one. Some sort of encryption/decryption should happen behind the curtains,
    ideally by using `Security::validatePassword()` from the security component.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们首先需要使用前面提到的辅助类来创建密码散列，然后在用户中设置它，然后可以使用`$user->validatePassword()`方法来检查实际传入的明文密码是否与内部密码匹配。幕后应该发生某种加密/解密操作，理想情况下是通过使用安全组件中的`Security::validatePassword()`。
- en: 'A possible implementation of `User::validatePassword()` in the user model can
    be the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 用户模型中`User::validatePassword()`的一个可能实现可以是以下内容：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we try to run the tests, this specific method will pass without problems.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行测试，这个特定的方法将无问题通过。
- en: This might be a good solution, but we need to be extremely conscious that this
    is not a true unit test; it's more of an integration test, as we still have the
    dependency on the security component.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个不错的解决方案，但我们需要非常清楚，这并不是一个真正的单元测试；它更像是一个集成测试，因为我们仍然依赖于安全组件。
- en: Isolating components with stubs
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用存根隔离组件
- en: The problem we are facing right now is that we don't really want to use the
    actual security component, as it's not part of the test itself. Keep in mind that
    we're working in a black box environment, and we don't know what other dependencies
    the security component might have in the future. We just need to ensure that our
    implemented method will behave correctly, given the interface of the (fake) object
    works as expected. We can later add an integration method to ensure that the security
    component actually works, but that's a completely different matter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前面临的问题是我们真的不想使用实际的安全组件，因为它不是测试本身的一部分。记住，我们正在一个黑盒环境中工作，我们不知道安全组件未来可能有什么其他依赖。我们只需要确保我们的实现方法在（假的）对象接口按预期工作的情况下将表现正确。我们可以在以后添加一个集成方法来确保安全组件实际上可以工作，但这完全是另一回事。
- en: In order to do that, PHPUnit provides an interesting system for stubbing and
    mocking classes and injecting them into your application to provide a more controlled
    environment. Generically, these are normally called **test doubles** and the method
    used to create them is through the Mock Builder.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，PHPUnit提供了一个有趣的系统来模拟和存根类，并将它们注入到你的应用程序中以提供一个更受控的环境。一般来说，这些通常被称为**测试替身**，创建它们的方法是通过Mock
    Builder。
- en: The latest versions of PHPUnit (4.x or above) suggest the use of the Mock Builder
    in order to configure the stub and behavior. Previously, this was done through
    a lengthy series of arguments to be passed to it. I won't indulge in saying that
    if you're working with PHPUnit 3.x or earlier versions, it might be time to upgrade!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit的最新版本（4.x或更高版本）建议使用Mock Builder来配置存根和行为。以前，这是通过传递给它的一系列长参数来完成的。我不会沉迷于说如果你正在使用PHPUnit
    3.x或更早版本，可能到了升级的时候了！
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that the `final`, `private`, and `static` methods *cannot* be stubbed
    or mocked as a PHPUnit test double functionality does not support this.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`final`、`private`和`static`方法*不能*被存根或模拟，因为PHPUnit测试替身功能不支持这一点。
- en: '**Stubbing** in particular refers to the practice of replacing an object with
    a test double that might return configured values.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是**存根**指的是用可能返回配置值的测试替身替换对象的实践。
- en: 'So, how are we doing this? I''ve decided to take the approach of using a separate
    private function to delegate the stubbing logic to a reusable piece of code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们是如何做到这一点的呢？我决定采用使用一个单独的私有函数来将存根逻辑委托给可重用代码块的方法：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We start by creating the stub of our security class by using `getMockBuilder()`.
    By default, the Mock Builder will replace all the class methods with test doubles
    that return `null`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过使用`getMockBuilder()`创建我们的安全类的存根。默认情况下，Mock Builder将用返回`null`的测试替身替换所有类方法。
- en: 'We can also decide selectively which ones are to be replaced by specifying
    them in an array and then passing it to `setMethods()`; for example: `setMethods([''validatePassword'',
    ''generatePasswordHash''])`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以选择性地指定要替换哪些方法，通过在数组中指定它们，然后传递给`setMethods()`；例如：`setMethods(['validatePassword',
    'generatePasswordHash'])`。
- en: We can also pass `null` to it; we can avoid any method from having a test double,
    but without it, we won't be able to set any expectation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以传递`null`给它；我们可以避免任何方法有测试替身，但没有它，我们无法设置任何期望。
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If the class you''re mocking performs unneeded initializations in the `__constructor()`
    method, you can disable it by using `disableOriginalConstructor()` or passing
    custom arguments with `setConstructorArguments()`. There are more methods that
    can be applied to modify the behavior of the Mock Builder; refer to the following
    documentation: [https://phpunit.de/manual/current/en/test-doubles.html#test-doubles.stubs](https://phpunit.de/manual/current/en/test-doubles.html#test-doubles.stubs).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在模拟的类在`__constructor()`方法中执行了不必要的初始化，你可以通过使用`disableOriginalConstructor()`或传递自定义参数使用`setConstructorArguments()`来禁用它。还有更多方法可以应用于修改Mock
    Builder的行为；请参阅以下文档：[https://phpunit.de/manual/current/en/test-doubles.html#test-doubles.stubs](https://phpunit.de/manual/current/en/test-doubles.html#test-doubles.stubs)。
- en: 'Any method that is a test double can be configured and be monitored with the
    use of `expects()`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 任何是测试替身的方法都可以使用`expects()`进行配置和监控：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This seems to be pretty much straightforward to read: any (`any()`) time the
    method (`method()`) ''`validatePassword`'' is invoked with (`with()`) the `$expectedPassword`,
    it will return (`willReturn()`) true.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当容易阅读：任何（`any()`）时候方法（`method()`）`'validatePassword'`被调用（`with()`）带有`$expectedPassword`，它将返回（`willReturn()`）true。
- en: 'There are a number of ways you can configure your replaced functions: having
    them return only once a certain value, or different values in consecutive calls,
    or throw exceptions, when invoked.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以多种方式配置你的替换函数：让它们在连续调用中返回特定的值，或者不同的值，或者当被调用时抛出异常。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Much more is available and documented in the official PHPUnit documentation
    available at [https://phpunit.de/manual/current/en/test-doubles.html](https://phpunit.de/manual/current/en/test-doubles.html).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息和文档可以在官方PHPUnit文档中找到，该文档位于[https://phpunit.de/manual/current/en/test-doubles.html](https://phpunit.de/manual/current/en/test-doubles.html)。
- en: 'We can then implement the negative test to cover a wrong password passed to
    `validatePassword()` with the logic we wanted:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以实现负测试（negative test）来覆盖传递给`validatePassword()`方法的错误密码，使用我们想要的逻辑：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For this to happen, we will need to slightly refactor the private method we
    just implemented:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要稍微重构我们刚刚实现的私有方法：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we can finally see how to configure our replaced method to throw the exception
    using `willThrowException()`. With it, we can ensure an exception is being thrown
    by a method; for this reason, tests that check for exceptions are to be separated
    from the others.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们终于可以看到如何配置我们替换的方法，使用`willThrowException()`抛出异常。有了它，我们可以确保方法抛出了异常；因此，检查异常的测试应该与其他测试分开。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The official documentation provides a more detailed explanation of the use of
    the Mock Builder API and it is available at [https://phpunit.de/manual/current/en/test-doubles.html](https://phpunit.de/manual/current/en/test-doubles.html).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档提供了对Mock Builder API使用的更详细解释，并且可以在[https://phpunit.de/manual/current/en/test-doubles.html](https://phpunit.de/manual/current/en/test-doubles.html)找到。
- en: Listening for calls with an observer
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用观察者监听调用
- en: As `User::validatePassword()` is now using `Security::validatePassword()` in
    its implementation in a transparent way, we don't want to expose any of this when
    setting the password to whoever is going to use the User model.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`User::validatePassword()`现在以透明的方式在其实现中使用了`Security::validatePassword()`，我们不想在设置密码时向使用User模型的人暴露任何这些内容。
- en: So, we'd like to think that when setting the password, our implementation will
    use `Security::generatePasswordHash()` in some way, so that when calling `User::validatePassword()`,
    we close the circle and everything should work without having to worry too much
    about encryption schemes and what not.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们希望认为在设置密码时，我们的实现将以某种方式使用`Security::generatePasswordHash()`，这样当调用`User::validatePassword()`时，我们就能闭合这个循环，并且一切应该都能正常工作，无需过多担心加密方案等问题。
- en: 'An immediate, somewhat logical, but quite abused way to implement a test that
    could cover this bit is the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个可以覆盖这部分内容的测试的一个直接、逻辑上合理但相当滥用的方法是以下内容：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s stop one second and understand what we''re doing here: ideally we want
    to set a password and read it back encrypted, doing the related and needed assertions.
    This means that we are both testing the setter and the getter of the password
    in the same test, which, once again, defies the basic principle of doing unit
    testing.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们停下来片刻，理解我们在做什么：理想情况下，我们想要设置一个密码，并加密后读取它，进行相关的和必要的断言。这意味着我们在同一个测试中同时测试密码的设置器和获取器，这再次违反了单元测试的基本原则。
- en: As a side note, however we implement the stubbing of the security component,
    our logic won't look much different from the initial implementation we had at
    the beginning of this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，无论我们如何实现安全组件的存根（stubbing），我们的逻辑都不会与本章开头时的初始实现有很大不同。
- en: Introducing mocking
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入模拟
- en: Mocking refers to the act of replacing an object with a test double that verifies
    the expectations, for instance ensuring that a method has been called. This seems
    to meet our needs exactly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟（Mocking）指的是用一个测试替身（test double）替换对象，以验证预期行为，例如确保某个方法已被调用。这似乎正好符合我们的需求。
- en: In a proper black box scenario, we won't know what `setPassword()` does and
    we would need to rely on the code coverage purely to understand if we've covered
    any possible branch of the programming flow, as previously said in [Chapter 4](ch04.html
    "Chapter 4. Isolated Component Testing with PHPUnit"), *Isolated Component Testing
    with PHPUnit*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个合适的黑盒场景中，我们不知道`setPassword()`做什么，我们需要完全依赖代码覆盖率来理解我们是否覆盖了编程流程的任何可能分支，正如在[第4章](ch04.html
    "第4章。使用PHPUnit进行隔离组件测试")中所述，*使用PHPUnit进行隔离组件测试*。
- en: Purely as an example for our purposes, we want to make sure that when calling
    `setPassword()`, we call `Security::generatePasswordHash()` at least once and
    that the argument is passed over to the method without any modification.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 仅作为我们目的的示例，我们想确保在调用`setPassword()`时，至少调用一次`Security::generatePasswordHash()`，并且将参数无修改地传递给该方法。
- en: 'Let''s try the following approach to test this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以下方法来测试这个：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you might have noticed, we don't have any specific assertion in this test.
    Our mocked class will just mark the test as passed once its method has been called
    with the specified value.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，这个测试中没有任何特定的断言。我们的模拟类将在其方法被调用并传入指定值后，简单地标记测试为通过。
- en: Getting to know the Yii virtual attributes
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解Yii虚拟属性
- en: In the example we just discussed, it would have been great if we could have
    hidden the functionality of transforming the cleartext password into an hash from
    the user.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚才讨论的例子中，如果我们能从用户那里隐藏将明文密码转换为哈希的功能，那将是非常棒的。
- en: There are multiple reasons why this isn't happening, but the most important
    of them is that Yii already provides a quite interesting and well-done system
    for virtual attributes. This system is in place since Yii 1, and once you get
    used to it, you can achieve satisfying results.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有发生的原因有很多，但其中最重要的原因是Yii已经提供了一个非常有趣且做得很好的虚拟属性系统。这个系统自Yii 1以来就存在了，一旦你习惯了它，你就可以取得令人满意的结果。
- en: By implementing a model that inherits from `yii\base\Component`, such as `ActiveRecord`
    or `Model`, you will also inherit the already implemented magic functions `__get()`
    and `__set()` that help you deal with virtual attributes. This ends up being particularly
    useful when you are in need of creating additional attributes without any effort.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现一个继承自`yii\base\Component`的模型，例如`ActiveRecord`或`Model`，你也将继承已经实现的魔法函数`__get()`和`__set()`，这些函数可以帮助你处理虚拟属性。当你需要不费吹灰之力创建额外属性时，这尤其有用。
- en: Let's see a more practical example.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更实际的例子。
- en: 'Let''s assume that our User model had a first name and a last name field in
    the database, but we would need to create the full name attribute without adding
    a new column in the user table:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的用户模型在数据库中有一个名字字段和一个姓氏字段，但我们需要创建全名属性，而不在用户表中添加新列：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So, we can access the field as if it was a normal attribute of the class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以像访问类的正常属性一样访问字段：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Plain and simple public attributes work as you would expect them to. In the
    following snippets of code, I''m introducing a new class `Dog`, purely for example
    purposes, which extends from `Model`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 简单明了的公共属性按预期工作。在下面的代码片段中，我引入了一个新的类`Dog`，仅用于示例目的，它继承自`Model`：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Therefore, our tests would pass without problems:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的测试将毫无问题地通过：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This shouldn''t be a surprise to you at all, but let''s see what happens if
    we have both:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点对你来说应该毫不奇怪，但让我们看看如果我们同时有：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we are expecting `setAge()` to be triggered on assignment, while reading
    directly the value of the public attribute:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们期待在赋值时触发`setAge()`，而直接读取公共属性的值：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, running this test will only reveal the sad truth:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，运行这个测试只会揭示一个令人沮丧的事实：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Yes, the test is exactly the same.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，测试确实是相同的。
- en: 'Having getters and setters automatically handled by our classes comes at an
    expense. The sequence of checks that are performed by the magic setter can be
    summarized with the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们的类自动处理getter和setter是有代价的。魔法setter执行的检查顺序可以用以下内容来概括：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you have implemented a model extending from `yii\base\ActiveRecord`, its
    base class will first check if the attribute is already available as a table column;
    otherwise, it will pass the call over to `Component::__set()`. This method is
    available not only for models extending from `yii\base\Model`, but also for any
    other that implicitly inherits from `yii\base\Component`, such as behaviors and
    events.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实现了一个继承自`yii\base\ActiveRecord`的模型，其基类将首先检查该属性是否已经作为表列存在；如果没有，它将调用`Component::__set()`。这个方法不仅适用于继承自`yii\base\Model`的模型，也适用于任何隐式继承自`yii\base\Component`的其他类，例如行为和事件。
- en: Following this, we can see that the setter will ensure that the `'set'.$name`
    method is available in our class, and if there's only a getter, then it will raise
    an exception.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们可以看到setter将确保我们的类中存在`'set'.$name`方法，如果只有getter，则将引发异常。
- en: 'In our initial definition of the `firstname` getter, we could have had the
    following additional test:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最初定义的 `firstname` 获取器中，我们可以有以下的附加测试：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are a couple or more things regarding events and behaviors done in the
    setter, but we won't touch them as of now.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在设置器中执行的事件和行为，有一些事情需要注意，但我们现在不会触及它们。
- en: So, going back to our `setPassword()` conundrum, we need to be aware that if
    we were to trigger the magic method by using `$user->password` for the left assignment,
    this won't trigger our method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到我们的 `setPassword()` 困境，我们需要意识到，如果我们通过使用 `$user->password` 进行左侧赋值来触发魔法方法，这将不会触发我们的方法。
- en: So, the best solution would ideally have been to call the stored password in
    a more declarative way, such as `password_hash`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，理想的最佳解决方案可能是以更声明性的方式调用存储的密码，例如 `password_hash`。
- en: Writing maintainable unit tests
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写可维护的单元测试
- en: As the last part, before leaving the unit tests behind, I wanted to show some
    additional features provided by Codeception that have been already introduced
    in [Chapter 1](ch01.html "Chapter 1. The Testing Mindset"), *The Testing Mindset*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开单元测试之前，作为最后一部分，我想展示一些 Codeception 提供的附加功能，这些功能已经在 [第 1 章](ch01.html "第 1
    章。测试心态") 中介绍过，*测试心态*。
- en: Codeception has been created with modularity and flexibility in mind, so anything
    else is your responsibility. In particular, you might have already noticed that
    our `UserTest` class has grown quite a bit.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Codeception 是以模块化和灵活性为设计理念创建的，因此其他任何事情都是你的责任。特别是，你可能已经注意到我们的 `UserTest` 类已经增长了很多。
- en: So, what would happen if a change in the interface or in the way our model works
    breaks our tests?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果接口或我们的模型工作方式的变化破坏了我们的测试，会发生什么呢？
- en: It's quite clear, especially if you're working in a team or even more if your
    code gets handed over to other people to maintain, that you need clear rules so
    that everybody agrees on how to write the code, as a starter, and tests.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常清楚，特别是如果你在一个团队中工作，或者如果你的代码被其他人接手维护，那么你需要明确的规则，以便每个人都同意如何编写代码，作为一个起点，以及测试。
- en: I've already highlighted in [Chapter 4](ch04.html "Chapter 4. Isolated Component
    Testing with PHPUnit"), *Isolated Component Testing with PHPUnit*, that one of
    the very basic things I've started doing with the teams I've worked with and with
    my own code, is to define precise and simple rules, which aim at the clarity and
    readability of the code. I've seen way too many "developer rockstars" that show
    off how good they are at writing compressed code, nesting variables, and hiding
    multiple assignments. Writing code that ends up being obfuscated might be fun
    if that code is a throwaway.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在 [第 4 章](ch04.html "第 4 章。使用 PHPUnit 进行隔离组件测试") 中突出显示过，*使用 PHPUnit 进行隔离组件测试*，我与我合作过的团队以及我自己的代码开始做的非常基本的事情之一，就是定义精确且简单的规则，这些规则旨在提高代码的清晰度和可读性。我见过太多的“开发者摇滚明星”炫耀他们如何擅长编写压缩代码、嵌套变量和隐藏多个赋值。如果代码是废弃的，编写最终变得难以理解的代码可能很有趣。
- en: Code legibility ends up being one of the ways I've seen companies select candidates,
    and a very quick test is to have someone read your code and be able to get what
    it does without asking.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可读性最终成为我看到公司选择候选人的方式之一，一个非常快速的测试就是让某人阅读你的代码，并能够理解它做什么，而无需询问。
- en: 'Tests shouldn''t be treated with less care than your application code: if done
    properly, tests represent a way of documenting how things are supposed to be working
    and how they should be used. As soon as your class provides more and more functionality,
    your test classes will start to grow and you need to be prepared to face a refactor
    and introduce regression testing when a change in the application happens or a
    bug is introduced.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不应该比你的应用程序代码得到更少的关注：如果做得恰当，测试代表了一种记录事物应该如何工作以及应该如何使用的方法。一旦你的类提供了更多和更多的功能，你的测试类将开始增长，你需要准备好面对重构并在应用程序发生变化或引入错误时引入回归测试。
- en: Using BDD specification testing
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 BDD 规范测试
- en: Codeception provides a nice and compact tool called **Specify**, which we have
    already introduced previously.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Codeception 提供了一个叫做 **Specify** 的好用的紧凑工具，我们之前已经介绍过。
- en: 'With PHPUnit alone, we only have methods to split our tests; using Specify,
    we have another layer of organization: The method becomes our *story* and our
    specification blocks our *scenarios*.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用 PHPUnit，我们只有方法来分割我们的测试；使用 Specify，我们有了另一层组织：方法成为我们的 *故事*，我们的规范块成为我们的 *场景*。
- en: Just for documentation purposes, it should be noted that PHPUnit has its own
    BDD-compatible syntactic sugar with the `given()`, `when()` and `then()` methods,
    as explained at [https://phpunit.de/manual/3.7/en/behaviour-driven-development.html](https://phpunit.de/manual/3.7/en/behaviour-driven-development.html).
    You can still use this syntax, if you are more used to it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 仅出于文档目的，应指出PHPUnit具有自己的BDD兼容的语法糖，即`given()`、`when()`和`then()`方法，如[https://phpunit.de/manual/3.7/en/behaviour-driven-development.html](https://phpunit.de/manual/3.7/en/behaviour-driven-development.html)中所述。如果您更习惯于这种语法，您仍然可以使用它。
- en: 'As a clearer example, we can group all validation rules within the same test
    and split the definition of what we''re doing by using Specify blocks, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 作为更清晰的例子，我们可以在同一个测试中分组所有验证规则，并通过使用Specify块来分割我们正在执行的定义，如下所示：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, we are now aggregating two of our previous tests within a single
    method and grouping them within two blocks of `specify()` calls.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们现在正在将两个先前的测试聚合到一个单独的方法中，并将它们分组在两个`specify()`调用块内。
- en: 'Specify is defined as a trait; this is the reason why you need to both use
    the namespace in the outermost global scope and load it within the test class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Specify被定义为一种特质；这就是为什么您需要在最外层的全局作用域中使用命名空间，并在测试类中加载它的原因：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see `specify()` requires only two arguments: a simple description
    of the scenario that we are about to define, and an anonymous function that contains
    the assertions we want to do.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`specify()`只需要两个参数：即将定义的场景的简单描述，以及包含我们想要执行的断言的匿名函数。
- en: At this point, we can either use the PHPUnit classic assertions we've used until
    now or try to empower BDD style assertions. **Verify**, a small and nifty package,
    will provide you this capability, allowing you to use methods such as `verify()`,
    `verify_that()`, and `verify_not()`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以继续使用我们一直使用的PHPUnit经典断言，或者尝试启用BDD风格的断言。**Verify**是一个小巧而实用的包，它将提供这种能力，让您可以使用`verify()`、`verify_that()`和`verify_not()`等方法。
- en: 'From the earlier specified scenarios, consider the following line of code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前提到的场景中，考虑以下代码行：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is exactly the same as using the PHPUnit assertion:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这与使用PHPUnit断言完全相同：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In order to perform more elaborate assertions, we can instead use `verify()`
    in the following way:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行更复杂的断言，我们可以使用以下方式使用`verify()`：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There are plenty of other assertions that can be used and can be found at the
    project homepage at [https://github.com/Codeception/Verify](https://github.com/Codeception/Verify).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目主页[https://github.com/Codeception/Verify](https://github.com/Codeception/Verify)上，还有许多其他断言可以使用，并且可以找到。
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've covered the long-awaited mocks and stubs that will allow
    you to perform proper component tests. In the final part, we've taken a better
    look at code organization for your tests and a BDD-like way of writing them by
    using Specify and Verify.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了备受期待的模拟和存根，这将允许您执行适当的组件测试。在最后一部分，我们更好地探讨了测试的代码组织，以及通过使用Specify和Verify来编写类似BDD的方式。
- en: In the following chapter, we're going to take a look at the next step of implementing
    the functional tests that should define the REST interface for our user.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨实现功能测试的下一步，这些测试应该定义我们用户的REST接口。
