<html><head></head><body>
		<div id="_idContainer026">
			<h1 id="_idParaDest-84" class="chapter-number"><a id="_idTextAnchor084"/>7</h1>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor085"/>Code Quality Tools</h1>
			<p>In the previous parts of this book, we learned the basics of clean code. Now, it is time to apply that knowledge to our everyday work. There are literally dozens of tools available for the PHP ecosystem that can help us detect flaws and potential bugs, apply the correct code styling, and generally inform us about quality issues.</p>
			<p>To ensure a quick and easy start within the world of code quality tools, this section will introduce you to the most commonly used ones. For each, you will learn how to install, configure, and use it directly on your code. You will also learn about some useful extra features they provide.</p>
			<p>We will look at the following groups of tools:</p>
			<ul>
				<li>Syntax checking and code styling</li>
				<li>Static code analysis</li>
				<li>IDE extensions</li>
			</ul>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor086"/>Technical requirements</h1>
			<p>For this chapter, you only need a bare minimum of tools to already be set up. The chances are high that you already have them installed if you have ever worked with PHP code before:</p>
			<ul>
				<li>A local installation of a recent PHP version (PHP 8.0 or higher is recommended).</li>
				<li>A code editor – often called an <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>).</li>
				<li>Composer, either installed as binary or globally. Please check <a href="https://getcomposer.org/">https://getcomposer.org/</a> if you are not familiar with Composer yet.</li>
			</ul>
			<p>Please note that for the rest of this book, all examples are based on a Linux environment such as Ubuntu or macOS. If you are using Windows for development, you will most likely need to make some adjustments, as described here: https://www.php.net/manual/en/install.windows.commandline.php.</p>
			<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Clean-Code-in-PHP">https://github.com/PacktPublishing/Clean-Code-in-PHP</a></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor087"/>Syntax checking and code styling</h1>
			<p>The first group of tools we want to discuss helps us keep our code syntactically correct (i.e., it can be executed correctly by PHP) and formatted in a structured way. It seems to be obvious that the code needs to be written without errors, but it is always good to double-check, as some tools can actively change your code. Having a simple and fast way to ensure this will be essential when we automate the whole code quality process later in this book.</p>
			<p>Having your code formatted following a common style guide reduces the effort required to read and understand your code, as well as the code of others. Especially when you are working in a team, an accepted style guide saves you hours of discussions about how to correctly format the code.</p>
			<p>We will learn about the following tools:</p>
			<ul>
				<li>A PHP built-in linter</li>
				<li>The PHP CS Fixer tool</li>
			</ul>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor088"/>The PHP built-in linter</h2>
			<p>The<a id="_idIndexMarker163"/> first tool we want to look at is actually not a code quality tool of its own but rather an option built into the PHP binary itself: the Linter. It checks any code for syntax errors without executing it. This is particularly useful to ensure that the code works after refactoring sessions or when your code has been changed by an external tool.</p>
			<h3>Installation and usage</h3>
			<p>Since the<a id="_idIndexMarker164"/> Linter is already part of your PHP installation, we can immediately <a id="_idIndexMarker165"/>start using it by looking at an example. If you look closely, you will probably notice the error the author made in the following class example:</p>
			<pre class="source-code">
&lt;?php
class Example 
{
    public function doSomething() bool
    {
        return true;
    }
}</pre>
			<p>Do not worry if you do not spot the error immediately – that is precisely what the Linter is there for! Simply pass the full name and path of the file to be checked to the PHP binary, using the <strong class="source-inline">-l</strong> option. By adding the <strong class="source-inline">-f</strong> option, PHP will also check for fatal errors, which is something we want. Both options can be combined into <strong class="source-inline">-lf</strong>.</p>
			<p>Let us assume the preceding class can be found in the <strong class="source-inline">example.php</strong> file in the current folder – then, all we need to type is the following:</p>
			<p class="source-code">$ php -lf example.php</p>
			<p>We will get the following output:</p>
			<pre class="source-code">
PHP Parse error: syntax error, unexpected identifier
  "bool", expecting ";" or "{" in example.php on line 5
Errors parsing example.php</pre>
			<p>You can tell the <a id="_idIndexMarker166"/>linter to <a id="_idIndexMarker167"/>check a complete directory as well:</p>
			<p class="source-code">$ php -lf <strong class="bold">src/*</strong></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The built-in PHP linter stops on the first error – as in, it will not give you a full list of all the detected errors. So, you better make sure to run the command again after resolving the issue.</p>
			<h3>A recap of the PHP built-in Linter </h3>
			<p>The built-in PHP linter<a id="_idIndexMarker168"/> is a handy tool for quick code checks but cannot do much more than that. There <a id="_idIndexMarker169"/>are other more sophisticated linters such as <a href="https://github.com/overtrue/phplint">https://github.com/overtrue/phplint</a>. Not only will this one return a full list of errors but it can also run multiple processes in parallel, which will be noticeably faster on large code bases. However, other code quality tools already include a linter, such as the tool that we will check in the next section. </p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor089"/>PHP CS Fixer: a code sniffer</h2>
			<p>Another <a id="_idIndexMarker170"/>essential tool is a code sniffer. It scans PHP code for coding <a id="_idIndexMarker171"/>standard violations and other bad practices. <em class="italic">PHP CS Fixer</em> (<a href="https://github.com/FriendsOfPHP/PHP-CS-Fixer">https://github.com/FriendsOfPHP/PHP-CS-Fixer</a>) is a viable choice to start with, since, as the name already implies, it not only reports the findings but also fixes them right away. </p>
			<p class="callout-heading">Other code sniffers</p>
			<p class="callout"><em class="italic">PHP CS Fixer</em> is not the only available code sniffer. Another <a id="_idIndexMarker172"/>well-known one is the <em class="italic">PHP_CodeSniffer</em> (<a href="https://github.com/squizlabs/PHP_CodeSniffer">https://github.com/squizlabs/PHP_CodeSniffer</a>), which we can fully recommend using as well.</p>
			<h3>Installation and usage</h3>
			<p>Using <a id="_idIndexMarker173"/>Composer, the<a id="_idIndexMarker174"/> installation is straightforward:</p>
			<p class="source-code">$ composer require friendsofphp/php-cs-fixer --dev</p>
			<p class="callout-heading">Alternatives to Composer</p>
			<p class="callout">There are multiple ways to install the tools we will introduce in this book. We will also check more options out later in this book. </p>
			<p>The typical use case for code sniffers is to take care of the placement of brackets and the number of indentations, whether they’re whitespaces or tabs. Let’s check out the following PHP file with its ugly format:</p>
			<pre class="source-code">
&lt;?php
class Example
{
  public function doSomething(): bool { return true; }
}</pre>
			<p>If we run the code sniffer with its default settings, the command is nice and short:</p>
			<p class="source-code">$ vendor/bin/php-cs-fixer fix <strong class="bold">example.php</strong></p>
			<p>This will<a id="_idIndexMarker175"/> scan and<a id="_idIndexMarker176"/> fix the <strong class="source-inline">example.php</strong> file all in one go, leaving our code neat and shiny:</p>
			<pre class="source-code">
&lt;?php
class Example
{
    public function doSomething(): bool
    {
        return true;
    }
}</pre>
			<p>If you do not want to fix the file immediately, you can use the <strong class="source-inline">--dry-run</strong> option to just scan for issues. Add the <strong class="source-inline">-v</strong> option as well, to display the findings:</p>
			<p class="source-code">$ vendor/bin/php-cs-fixer fix example.php <strong class="bold">--dry-run -v</strong></p>
			<p>As with<a id="_idIndexMarker177"/> all code <a id="_idIndexMarker178"/>quality tools, you can also run it on all the files in a folder. The following command will scan the <strong class="source-inline">src</strong> folder recursively, so all subfolders are scanned as well:</p>
			<p class="source-code">$ vendor/bin/php-cs-fixer fix <strong class="bold">src</strong></p>
			<h3>Rules and rulesets</h3>
			<p>So far, we used <em class="italic">PHP CS Fixer</em> with<a id="_idIndexMarker179"/> its default settings. Before we can change these defaults, let us have a closer look at how it knows what to check and fix. </p>
			<p>A common pattern within code quality tools is the organization of rules within rulesets. A rule<a id="_idIndexMarker180"/> is a simple instruction that tells <em class="italic">PHP CS Fixer</em> how our code should be formatted regarding a certain aspect. For example, if we want to make use of strict types in PHP, every PHP file should contain the <strong class="source-inline">declare(strict_types=1);</strong> instruction.</p>
			<p>There is a rule<a id="_idIndexMarker181"/> in <em class="italic">PHP CS Fixer</em> that can be used to force this:</p>
			<p class="source-code">$ vendor/bin/php-cs-fixer fix src </p>
			<p class="source-code">  -<strong class="bold">-rules=declare_strict_types</strong></p>
			<p>This command will check each file in <strong class="source-inline">src</strong> and add <strong class="source-inline">declare(strict_types=1);</strong> after the opening PHP tag.</p>
			<p>Since a coding standard<a id="_idIndexMarker182"/> such as PSR-12 (<a href="https://www.php-fig.org/psr/psr-12/">https://www.php-fig.org/psr/psr-12/</a>) includes many instructions on how the code should be formatted, it would be cumbersome to add all these rules to the preceding command. That is why rulesets have been introduced, which are simply a combination of rules, and even other rulesets.</p>
			<p>If we want to format code following PSR-12 explicitly, we can just run this:</p>
			<p class="source-code">$ vendor/bin/php-cs-fixer fix src --rules=<strong class="bold">@PSR12</strong></p>
			<p>As you can see, a ruleset is indicated by the <strong class="source-inline">@</strong> symbol.</p>
			<p class="callout-heading">Rules and ruleset documentation</p>
			<p class="callout">It is impossible to<a id="_idIndexMarker183"/> discuss every rule and ruleset for <em class="italic">PHP CS Fixer</em> within the scope of this book. If you are curious about what else it has to offer, please check out the official GitHub repository: <a href="https://github.com/FriendsOfPHP/PHP-CS-Fixer/tree/master/doc">https://github.com/FriendsOfPHP/PHP-CS-Fixer/tree/master/doc</a></p>
			<h3>Configuration</h3>
			<p>Executing <a id="_idIndexMarker184"/>commands manually is fine to start with, but at some point, we will not want to remember all the options every time. That is where configuration files come into play: most PHP code quality tools allow us to store the desired configuration in one or more files and in various formats, such as YAML, XML, or plain PHP.</p>
			<p>For <em class="italic">PHP CS Fixer</em>, all the relevant settings can be controlled via the <strong class="source-inline">.php-cs-fixer.dist.php</strong> configuration file. Here, you will find an example:</p>
			<pre class="source-code">
&lt;?php
$finder = PhpCsFixer\Finder::create()
    -&gt;in(__DIR__)
    -&gt;exclude('templates');
$config = new PhpCsFixer\Config();
return $config-&gt;setRules([
    '@PSR12' =&gt; true,
    'declare_strict_types' =&gt; true,
    'array_syntax' =&gt; ['syntax' =&gt; 'short'],
])
-&gt;setFinder($finder);</pre>
			<p>Numerous things are happening here. Firstly, an instance of <strong class="source-inline">PhpCsFixer\Finder</strong> is created, which is configured to use the same directory to look for PHP files where this configuration file is located. As the <strong class="source-inline">root</strong> folder of the application is usually located here, we may want to exclude certain subdirectories (such as <strong class="source-inline">templates</strong> in this example) from being scanned.</p>
			<p>Secondly, an instance of <strong class="source-inline">PhpCsFixer\Config</strong> is created. Here, we tell <em class="italic">PHP CS Fixer</em> which rules and rulesets to apply. We already discussed the <strong class="source-inline">@PSR-12</strong> ruleset, as well as the <strong class="source-inline">declare_strict_types</strong> rule. The <strong class="source-inline">array_syntax</strong> rule forces the usage of the short array syntax.</p>
			<p>You may have noticed that the name of the configuration file, <strong class="source-inline">.php-cs-fixer.dist.php</strong>, contains the abbreviation <strong class="source-inline">dist</strong>. This stands for distribution and usually indicates that this file is the one the project gets distributed with. In other words, this is the file that gets added to the Git repository and is immediately available after checkout.</p>
			<p>If you want to use your <a id="_idIndexMarker185"/>own configuration on your local system, you can create a copy of it and rename it <strong class="source-inline">.php-cs-fixer.php</strong>. If this file exists, <em class="italic">PHP CS Fixer</em> will use it instead of <strong class="source-inline">dist-file</strong>. It is good practice to let Git ignore this file. Otherwise, you might accidentally add your local settings to the repository.</p>
			<h3>Advanced usage</h3>
			<p>The ability of <em class="italic">PHP CS Fixer</em> does <a id="_idIndexMarker186"/>not stop at automatically fixing coding standard violations. It can also be used to apply small refactoring tasks. One great use case, for example, is the automated migration to a higher PHP version: <em class="italic">PHP CS Fixer</em> ships with migration rulesets, which can introduce some new language features to your code base. </p>
			<p>For example, with PHP 8.0, it is possible to use the <strong class="source-inline">class</strong> keyword instead of the <strong class="source-inline">get_class()</strong> function. <em class="italic">PHP CS Fixer</em> can scan your code and replace certain lines – for example, see the following:</p>
			<pre class="source-code">
$class = get_class($someClass);</pre>
			<p>It can replace the preceding line with this:</p>
			<pre class="source-code">
$class = $someClass::class;</pre>
			<p>The migration rulesets are separated into non-risky and risky ones. Risky rulesets can potentially cause side effects, while non-risky ones usually do not cause any problems. A good example of a risky change is the <strong class="source-inline">declare_strict_types</strong> rule we discussed previously. Be sure to test your application thoroughly after applying them.</p>
			<p>The capabilities of these migrations are limited – your code will not suddenly include all new PHP version features. </p>
			<p>Code fixers cannot fix syntax errors for us. For example, the <strong class="source-inline">Example</strong> class that we checked with PHP’s built-in linter in the previous section would still require the developer to manually fix it first. </p>
			<p class="callout-heading">Linting</p>
			<p class="callout"><em class="italic">PHP CS Fixer</em> checks the files that you want to have sniffed for syntax errors as the very first step and will not apply any changes in case it finds syntax errors. This means that you do not have to run the PHP built-in linter as an additional step.</p>
			<h3>A recap of PHP CS Fixer </h3>
			<p>A code sniffer<a id="_idIndexMarker187"/> such as <em class="italic">PHP CS Fixer</em> should be part of every serious PHP project. The ability to fix rule violations automatically will save you many hours of work. If you chose not to apply any risky fixes, it will hardly cause any problems at all.</p>
			<p>We have now learned how to ensure that our code is well-formatted and syntactically correct. While this is the foundation of any high-quality code, it does not help us to avoid bugs or maintainability issues. At this point, Static code analysis tools come into play.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor090"/>Static Code Analysis</h1>
			<p>Static Code Analysis<a id="_idIndexMarker188"/> means that the only source of information is the code itself. Just by scanning the source code, these tools will find issues and problems that even the most senior developer in your team would miss during a code review. </p>
			<p>These are the tools we would like to introduce you to in the next sections:</p>
			<ul>
				<li>phpcpd</li>
				<li>PHPMD</li>
				<li>PHPStan</li>
				<li>Psalm</li>
			</ul>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor091"/>phpcpd – the copy and paste detector</h2>
			<p>Copy and paste <a id="_idIndexMarker189"/>programming can be anything from simply annoying to a real threat to your projects. Bugs, security issues, and bad practices will get copied around and thus become harder to fix. Think of it as though it were a plague spreading through your code.</p>
			<p>This form of <a id="_idIndexMarker190"/>programming is quite common, especially among less experienced developers, or in projects where the deadlines are very tight. Luckily, our clean code toolkit offers a remedy – the <strong class="bold">PHP copy and paste detector</strong> (<strong class="bold">phpcpd</strong>).</p>
			<h3>Installation and usage</h3>
			<p>This tool can only be<a id="_idIndexMarker191"/> downloaded as <em class="italic">a self-containing PHP archive</em> (<strong class="source-inline">phar</strong>), so we <a id="_idIndexMarker192"/>will not use Composer to install it this time:</p>
			<p class="source-code">$ wget https://phar.phpunit.de/phpcpd.phar</p>
			<p class="callout-heading">Handling phar files</p>
			<p class="callout">In <a href="B19050_09.xhtml#_idTextAnchor115"><em class="italic">Chapter 9</em></a>, <em class="italic">Organizing PHP Quality Tools</em>, we will learn how to keep <strong class="source-inline">phar</strong> files organized. For now, it’s enough to just download it.</p>
			<p>Once downloaded, <em class="italic">phpcpd</em> can be used immediately without further configuration. It just requires the path of the target directory as a parameter. The following example shows how to scan the <strong class="source-inline">src</strong> directory for so-called “clones” (i.e., code that has been copied multiple times). Let’s execute it with the default settings first:</p>
			<pre class="source-code">
$ php phpcpd.phar src
phpcpd 6.0.3 by Sebastian Bergmann.
No clones found.
Time: 00:00, Memory: 2.00 MB</pre>
			<p>If <em class="italic">phpcpd</em> does not detect any clones, it is worth checking the two options, <strong class="source-inline">min-lines</strong> and <strong class="source-inline">min-tokens</strong>, that control its “pickiness”:</p>
			<pre class="source-code">
$ php phpcpd.phar <strong class="bold">--min-lines 4 --min-tokens 20</strong> src
phpcpd 6.0.3 by Sebastian Bergmann.
Found 1 clones with 22 duplicated lines in 2 files:
- /src/example.php:12-23 (11 lines)
  /src/example.php:28-39
  /src/example3.php:7-18
32.35% duplicated lines out of 68 total lines of code.
Average size of duplication is 22 lines, largest clone has
  11 of lines
Time: 00:00.001, Memory: 2.00 MB</pre>
			<p>The <strong class="source-inline">min-lines</strong> option allows us to set the minimum number of lines a piece of code needs to have until it is considered a clone. </p>
			<p>To understand the usage of <strong class="source-inline">min-tokens</strong>, we must clarify the meaning of a token in this context first: when you execute a script, PHP will internally use a so-called “tokenizer” to split the source code up into single tokens. A token is an independent component of your PHP program, such as a keyword, an operator, a constant, or a string. Think of them as words in human language. The <strong class="source-inline">min-tokens</strong> option therefore controls the number of instructions a piece of code contains before it is considered a clone.</p>
			<p>You may want to<a id="_idIndexMarker193"/> play around with both parameters to find a good balance of “pickiness” for your code base. A certain amount of redundancy in your code is not automatically a problem and <a id="_idIndexMarker194"/>you also do not want to bother your fellow developers too much. Using the defaults to start with, therefore, is a good choice.</p>
			<h3>Further options</h3>
			<p>There are two more options<a id="_idIndexMarker195"/> you should be aware of:</p>
			<ul>
				<li><strong class="source-inline">--exclude &lt;path&gt;</strong>: Excludes a path from the analysis. For example, unit tests often contain a lot of copy-and-paste code, so you want to exclude the <strong class="source-inline">tests</strong> folder. If you need to exclude multiple paths, the options can be given multiple times.</li>
				<li><strong class="source-inline">--fuzzy</strong>: With this especially useful option, <em class="italic">phpcpd</em> will obfuscate the variable names when performing its check. This way, clones will be detected even if the variable names <a id="_idIndexMarker196"/>have been changed by a smart but lazy colleague.</li>
			</ul>
			<h3>Recap of phpcpd</h3>
			<p>Although <em class="italic">phpcpd</em> is easy<a id="_idIndexMarker197"/> to use, it is a significant help against the slow spread of copy and paste code in your projects. That is why we recommend adding it to your clean coder toolkit.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor092"/>PHPMD: the PHP mess detector</h2>
			<p>A mess detector will scan<a id="_idIndexMarker198"/> code for potential issues, also known as “code smells” – parts of code that can introduce bugs, unexpected behavior, or are, in general, harder to maintain. As with the code style, there are certain rules that should be followed to avoid problems. The mess detector applies those rules to our code. The standard tool in the PHP ecosystem for this is <em class="italic">PHPMD</em>, which we will show you in this section.</p>
			<h3>Installation and usage</h3>
			<p>Before we take a closer look <a id="_idIndexMarker199"/>at what this tool has to offer for us, let us install it first using<a id="_idIndexMarker200"/> Composer:</p>
			<p class="source-code">$ composer require phpmd/phpmd --dev</p>
			<p>After the installation is complete, we can run <em class="italic">PHPMD</em> already on the command line. It requires three arguments:</p>
			<ul>
				<li>The filename or path to scan (e.g., <strong class="source-inline">src</strong>). Multiple locations can be comma-separated.</li>
				<li>One of the following formats in which the report should be generated: <strong class="source-inline">html</strong>, <strong class="source-inline">json</strong>, <strong class="source-inline">text</strong>, or <strong class="source-inline">xml</strong>.</li>
				<li>One or more built-in rulesets or ruleset XML files (comma-separated).</li>
			</ul>
			<p>For a quick start, let’s scan the <strong class="source-inline">src</strong> folder, create the output as text, and use the built-in <strong class="source-inline">cleancode</strong> and <strong class="source-inline">codesize</strong> rulesets. We can do this by running the following command:</p>
			<p class="source-code">$ vendor/bin/phpmd src text cleancode,codesize</p>
			<p><em class="italic">PHPMD</em> writes all <a id="_idIndexMarker201"/>output to the standard output (<strong class="source-inline">stdout</strong>), which is on the command<a id="_idIndexMarker202"/> line. However, all output formats except <strong class="source-inline">text</strong> are not meant to be read there. If you want to get a first overview, you may want to use the <strong class="source-inline">html</strong> output, as it generates a nicely formatted and interactive report. To store the output in a file, we will redirect it to a file using the <strong class="source-inline">&gt;</strong> operator as follows:</p>
			<p class="source-code">$ vendor/bin/phpmd src html cleancode,codesize <strong class="bold">&gt; phpmd_report.html</strong></p>
			<p>Simply open the HTML file on your browser and you will see a report similar to the one shown in <em class="italic">Figure 7.1</em>:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_7.01_B19050.jpg" alt="Figure 7.1: A PHPMD HTML report in a browser"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1: A PHPMD HTML report in a browser</p>
			<p>The report is <a id="_idIndexMarker203"/>interactive, so make sure to click on buttons such as <strong class="bold">Show details</strong> or <strong class="bold">Show code</strong> to display all the information there is.</p>
			<h3>Rules and rulesets</h3>
			<p>In the preceding <a id="_idIndexMarker204"/>example, we used the built-in <strong class="source-inline">cleancode</strong> and <strong class="source-inline">codesize</strong> rulesets. Firstly, the rulesets are named according to the problem domain the rules check – as in, for the <strong class="source-inline">cleancode</strong> rule, you will only find rules that help to keep the code base clean. However, you can still end up with huge classes with many complex functions. To avoid this, adding the <strong class="source-inline">codesize</strong> ruleset is necessary.</p>
			<p>The following table shows the available rulesets and their usage:</p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Ruleset</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Short name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Clean code rules</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">cleancode</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Enforces clean code in general</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Code size rules</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">codesize</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Checks for long or complex code blocks</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Controversial rules</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">controversial</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Checks for best and bad practices where there are controversial opinions about them</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Design rules</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">design</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Helps find software design-related issues</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Naming rules</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">naming</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Avoids names that are too long or short</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Unused code rules</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">unused</strong></p>
						</td>
						<td class="No-Table-Style">
							<p>Detects unused code that can be deleted</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 7.1: PHPMD rulesets</p>
			<p>These built-in rules can simply be used by giving the aforementioned short names as arguments to the function call, as seen in the previous example.</p>
			<p>If you are<a id="_idIndexMarker205"/> lucky enough to start a project on the green (i.e., from scratch), you can and should enforce as many rules from the beginning as you can. This will keep your code base clean right from the beginning. For existing projects, the effort is a bit greater, as we will see in the next section.</p>
			<h3>Using PHPMD in legacy projects</h3>
			<p>Often enough, you <a id="_idIndexMarker206"/>want to use <em class="italic">PHPMD</em> for an existing project, though. In this case, you will most likely be overwhelmed by the countless warnings that it will throw upon the first run. Do not give up – there are some options to help you!</p>
			<h4>Adjusting rulesets</h4>
			<p>If you plan to add <em class="italic">PHPMD</em> to an existing project, going all-in with the rulesets will surely lead to<a id="_idIndexMarker207"/> frustration because of how many issues are reported. You may want to concentrate on one or two rulesets at a time instead.</p>
			<p>It is also highly likely that you will end up with rules that you find annoying or counter-productive at first – for example, the <strong class="source-inline">ElseExpression</strong> rule, which forbids the usage of <strong class="source-inline">else</strong> in an <strong class="source-inline">if</strong> expression. Leaving the discussion about the usefulness of this rule aside, the effort of rewriting countless statements that are working fine is not worth it. So, if you don’t want to use that rule in your project, you need to create your own ruleset. </p>
			<p>Rulesets are configured via XML files, which specify the rules that belong in them. Each rule is basically a PHP class that contains the rule logic. The following XML file defines a custom ruleset that just includes the <strong class="source-inline">cleancode</strong> and <strong class="source-inline">codesize</strong> rulesets:</p>
			<pre class="source-code">
&lt;?xml version="1.0"?&gt;
&lt;ruleset name="Custom PHPMD rule set"
    xmlns=http://pmd.sf.net/ruleset/1.0.0
    xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance
    xsi:schemaLocation=http://pmd.sf.net/ruleset/1.0.0  http://pmd.sf.net/ruleset_xml_schema.xsd
xsi:noNamespaceSchemaLocation=
  "http://pmd.sf.net/ruleset_xml_schema.xsd"&gt;
    &lt;description&gt;
        Rule set which contains all codesize and cleancode
        rules
    &lt;/description&gt;
    &lt;rule ref="rulesets/codesize.xml" /&gt;
    &lt;rule ref="rulesets/cleancode.xml" /&gt;
&lt;/ruleset&gt;</pre>
			<p>XML seems to be a bit out of fashion nowadays, but it still serves its purpose well. You usually do not need to worry about all the attributes of the <strong class="source-inline">&lt;ruleset&gt;</strong> tag – just make sure that they are present. The <strong class="source-inline">&lt;description&gt;</strong> tag can contain any text that you deem to be a good description for the ruleset.</p>
			<p>The <strong class="source-inline">&lt;rule&gt;</strong> tag is important for us. In the preceding example, we referenced both the <strong class="source-inline">codesize</strong> and <strong class="source-inline">cleancode</strong> rules. </p>
			<p class="callout-heading">Tip</p>
			<p class="callout">At this point, it is a good idea to dig through the built-in rule sets in the GitHub repository https://github<a href="https://github.com/phpmd/phpmd/tree/master/src/main/resources/rulesets">.com/phpmd/phpmd/tree/master/src/main/resources/rulesets</a>. Thanks to XML being a quite verbose file format, you will get familiar with it very quickly. </p>
			<p>Imagine we <a id="_idIndexMarker208"/>want to remove the mentioned <strong class="source-inline">ElseExpression</strong> rule from our checks. To achieve this, you just need to add an <strong class="source-inline">&lt;exclude&gt;</strong> tag within the according <strong class="source-inline">&lt;rule&gt;</strong> tag as follows:</p>
			<pre class="source-code">
&lt;rule ref="rulesets/cleancode.xml"&gt;
    &lt;exclude name="ElseExpression" /&gt;
&lt;/rule&gt;</pre>
			<p>This way, you can exclude as many rules from a ruleset as necessary. If you just want to pick certain rules from different rulesets, you can also go the other way round and reference the desired rules directly. If you want your custom ruleset to only include the <strong class="source-inline">StaticAccess</strong> and <strong class="source-inline">UndefinedVariable</strong> rules, your XML file should contain the following two tags:</p>
			<pre class="source-code">
&lt;rule ref="rulesets/cleancode.xml/StaticAccess" /&gt;
&lt;rule ref="rulesets/cleancode.xml/UndefinedVariable" /&gt;</pre>
			<p>One last important thing to know about the XML configuration files is how to change the individual properties of a rule. Again, a good way to figure out all the properties is to check out the actual ruleset file. Alternatively, you can check out the actual PHP classes of each rule at <a href="https://github.com/phpmd/phpmd/tree/master/src/main/php/PHPMD/Rule">https://github.com/phpmd/phpmd/tree/master/src/main/php/PHPMD/Rule</a>.</p>
			<p>A typical example is to define exceptions for the <strong class="source-inline">StaticAccess</strong> rule. It is usually good practice to avoid static access, but often enough, you can’t avoid it. Let us say your team agreed on allowing static access for the <strong class="source-inline">DateTime</strong> and <strong class="source-inline">DateTimezone</strong> objects – you can <a id="_idIndexMarker209"/>simply configure this as follows:</p>
			<pre class="source-code">
&lt;rule ref="rulesets/cleancode.xml/StaticAccess"&gt;
    &lt;properties&gt;
        &lt;property name="exceptions"&gt;
            &lt;value&gt;
                \DateTime,
                \DateTimezone
            &lt;/value&gt;
        &lt;/property&gt;
    &lt;/properties&gt;
&lt;/rule&gt;</pre>
			<p>To use this custom ruleset in the future, simply save the preceding XML in a file (usually called <strong class="source-inline">phpmd.xml</strong>) and pass it over to <em class="italic">PHPMD</em> upon the next run:</p>
			<p class="source-code">$ vendor/bin/phpmd src text <strong class="bold">phpmd.xml</strong></p>
			<p class="callout-heading">Location of the configuration file</p>
			<p class="callout">It is a common practice to place <strong class="source-inline">phpmd.xml</strong> with the rulesets you want to use in the <strong class="source-inline">root</strong> folder of your project and use it as the single source of configuration. If there are any modifications in the future, you only have to adjust one central file. </p>
			<h4>Suppressing warnings</h4>
			<p>Another<a id="_idIndexMarker210"/> useful tool for dealing with legacy code is the <strong class="source-inline">@SuppressWarnings</strong> DocBlock annotation. Let us assume one class in your project makes use of a static method call and that cannot be changed right now. By default, any static access will throw a warning. Since you do not want to use static access anywhere else in your code, but just in this class, removing the <strong class="source-inline">StaticAccess</strong> rule would be counterproductive. </p>
			<p>In these cases, you can make use of the <strong class="source-inline">@SuppressWarnings</strong> annotation:</p>
			<pre class="source-code">
/**
* <strong class="bold">@SuppressWarnings(PHPMD.StaticAccess)</strong>
*/
class ExampleClass {
    public function getUser(int $id): User {
        return User::find($id);
    }
}</pre>
			<p>You can use multiple annotations in one DocBlock if required. Finally, if you want to suppress any warnings on a class, just use the <strong class="source-inline">@SuppressWarnings(PHPMD)</strong> annotation.</p>
			<p>Be aware that using the <strong class="source-inline">Suppress</strong> annotations should be your last resort. It is very tempting to just add it everywhere. However, it will silence the output, but it will not solve the problems.</p>
			<h4>Accepting violations</h4>
			<p>Instead of <a id="_idIndexMarker211"/>suppressing warnings at the file level or excluding rules from rulesets, you can also decide to acknowledge existing violations. For example, when you want to use <em class="italic">PHPMD</em> on a legacy project, you can decide to ignore all violations that are already in the code for now. However, if new violations are introduced by a new class, they will be reported. </p>
			<p>Luckily, <em class="italic">PHPMD</em> makes this task quite easy by providing a so-called baseline file, which it will generate for you automatically by running the following:</p>
			<p class="source-code">$ vendor/bin/phpmd src text phpmd.xml <strong class="bold">--generate-baseline</strong></p>
			<p>In the preceding command, we expect that a <strong class="source-inline">phpmd.xml</strong> file already exists in the project <strong class="source-inline">root</strong> folder. Using the preceding command, <em class="italic">PHPMD</em> will now create a file called <strong class="source-inline">phpmd.baseline.xml</strong>.</p>
			<p>Now, you may run the following:</p>
			<p class="source-code">$ vendor/bin/phpmd src text phpmd.xml</p>
			<p>The next time, <em class="italic">PHPMD</em> will automatically detect the previously generated baseline file and use it to suppress all warnings accordingly. However, if a new rule violation is introduced in a new location, it will still be detected and reported as a violation.</p>
			<p>A word of warning: as with the <strong class="source-inline">@SuppressWarning</strong> annotation, the baseline feature is not a tool that can be used once and safely ignored in the future. The problematic code blocks are still part of your project as technical debt with all the negative effects. That is why if you decide to go with the baseline feature, you should make sure you don’t forget about addressing these hidden problems in the future. </p>
			<p>We will discuss how to deal with these problems later in the book. For now, it is only important for you how to update the baseline file from time to time. Again, <em class="italic">PHPMD</em> makes this an <a id="_idIndexMarker212"/>easy task. Simply run the following:</p>
			<p class="source-code">$ vendor/bin/phpmd src text phpmd.xml --update-baseline</p>
			<p>All violations that no longer exist in your code will be removed from the baseline file.</p>
			<h3>A recap on PHPMD </h3>
			<p>Unless <a id="_idIndexMarker213"/>you are starting a project on the green, the configuration of <em class="italic">PHPMD</em> will require a bit more time. Especially if you are working within a team, you will spend more time arguing about which rules to use and which to exclude. Once this is done, though, you have a powerful tool at your disposal that will help developers write high-quality, maintainable code.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor093"/>PHPStan – a static analyzer for PHP</h2>
			<p>You might have noticed <a id="_idIndexMarker214"/>that <em class="italic">PHPMD</em>, which we looked at in the previous section, was not very PHP-specific but generally took care of the best coding practices. While this is, of course, very important, we want to use <em class="italic">PHPStan</em> to analyze our code with bad PHP practices in mind now.</p>
			<p>As with every static analysis tool, <em class="italic">PHPStan</em> can only work with the information it can get out of the code. Therefore, it works better with modern object-oriented code. If, for example, the code makes strong use of strict typing, the analyzer has additional information to process, and will therefore return more results. But for older projects, it will be of immense help as well, as we will see in the following section.</p>
			<h3>Installation and usage</h3>
			<p>Installing <em class="italic">PHPStan</em> with <a id="_idIndexMarker215"/>Composer is just a one-liner again:</p>
			<p class="source-code">$ composer require phpstan/phpstan --dev</p>
			<p>As with most code<a id="_idIndexMarker216"/> quality tools, <em class="italic">PHPStan</em> can be installed using PHAR. However, only when using Composer can you also install extensions. We will have a look at those a bit later in this section.</p>
			<p>Let us use the following simplified example and store it inside the <strong class="source-inline">src</strong> folder:</p>
			<pre class="source-code">
&lt;?php
class Vat
{
    private float $vat = 0.19;
    
    public function getVat(): int
    {
        return $this-&gt;vat;
    }
}
class OrderPosition
{
    public function getGrossPrice(float $netPrice): float
    {
        $vatModel = new Vat();
        $vat = $vatModel-&gt;getVat();
        return $netPrice * (1 + $vat);
    }
}
$orderPosition = new OrderPosition();
echo $orderPosition-&gt;getGrossPrice(100);</pre>
			<p>To execute a scan, you <a id="_idIndexMarker217"/>need to specify the <strong class="source-inline">analyse</strong> keyword, together with the path to scan, which is <strong class="source-inline">src</strong> in our case:</p>
			<p class="source-code">$ vendor/bin/phpstan analyse src</p>
			<p><em class="italic">Figure 7.2</em> shows the output produced by <em class="italic">PHPStan</em>:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/Figure_7.02_B19050.jpg" alt="Figure 7.2: An example output of PHPStan &#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2: An example output of PHPStan </p>
			<p>When we execute the PHP script, it will output <strong class="source-inline">100</strong>. Unfortunately, this is not correct because adding 19% of taxes to the net price should return 119, and not 100. So, there must be a bug <a id="_idIndexMarker218"/>somewhere. Let us see how <em class="italic">PHPStan</em> can help us here.</p>
			<h3>Rule levels</h3>
			<p>Unlike <em class="italic">PHPMD</em>, where you configure<a id="_idIndexMarker219"/> in detail which rules to apply, we will use different reporting levels here. These levels have been defined by the developers of <em class="italic">PHPStan</em>, starting from level 0 (just performing basic checks) to level 9 (being very strict on issues). To not overwhelm users with errors at first, <em class="italic">PHPStan</em> by default will use level 0, which only executes very few checks.</p>
			<p>You can specify the level using the <strong class="source-inline">level</strong> (<strong class="source-inline">-l|--level</strong>) option. Let us try the next highest level:</p>
			<p class="source-code">$ vendor/bin/phpstan analyse <strong class="bold">--level 1</strong> src</p>
			<p>Using the level approach, you can effortlessly increase the quality of your code step by step, as we will demonstrate using the following, made-up example. Levels 1 and 2 will not return any errors either, though. As we eventually reach level 3, however, we will finally find a problem:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/Figure_7.03_B19050.jpg" alt="Figure 7.3: PHPStan reports one error with level 3&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3: PHPStan reports one error with level 3</p>
			<p>Checking our code again, we can spot the problem quickly: the <strong class="source-inline">getVat()</strong> method returns a float number (0.19) but using the <strong class="source-inline">int</strong> return type casts it to 0. </p>
			<p class="callout-heading">Strict typing</p>
			<p class="callout">If we had used strict mode by adding the <strong class="source-inline">declare(strict_types=1);</strong> statement at the top of the example code, PHP would have thrown an error instead of silently casting the return value to <strong class="source-inline">int</strong>.</p>
			<p>This demonstrates the<a id="_idIndexMarker220"/> beauty and power of Static Code Analysis: fixing this little bug will make our code work as expected and it takes us just a couple of seconds to do since we are still in our development environment. However, if this bug had reached the production environment, it would have taken us much longer to fix and left some angry customers behind.</p>
			<h3>Configuration</h3>
			<p>You can use <a id="_idIndexMarker221"/>configuration files to make sure that the same level and the same folders <a id="_idIndexMarker222"/>are always checked. The configuration is written in NEON (https://ne<a href="https://ne-on.org/">-on.org/</a>), a file format that is very similar to YAML; if you can read and write YAML, it will work out just fine.</p>
			<p>The basic configuration only contains the level and the folders to be scanned:</p>
			<p class="source-code">parameters:</p>
			<p class="source-code">    level: 4</p>
			<p class="source-code">    paths:</p>
			<p class="source-code">        - src</p>
			<p>It is a good practice to save this configuration in a file named <strong class="source-inline">phpstan.neon</strong> in the <strong class="source-inline">root</strong> folder of your project. That is the location where <em class="italic">PHPStan</em> expects it to be by default. If you follow this convention, the next time you want to run it, you only need to specify the desired action:</p>
			<p class="source-code">$ vendor/bin/phpstan analyse</p>
			<p>If you used the above example configuration, <em class="italic">PHPStan</em> will now scan the <strong class="source-inline">src</strong> folder, using all rules from level 0 to level 4.</p>
			<p>That is not everything you can configure here. In the next section, we will learn about some additional parameters.</p>
			<h3>Using PHPStan in legacy projects</h3>
			<p>If you <a id="_idIndexMarker223"/>want to use <em class="italic">PHPStan</em> in existing projects of a certain age, you will most likely end up with hundreds if not thousands of errors, depending on the chosen level. Of course, you can decide to keep using a lower level; but that also means that the analyzer will miss more bugs, not only existing ones but also in new or modified code.</p>
			<p>In an ideal world, you would start with level 0, solve all errors, then continue with level 1, solve all new errors, and so on. This requires a lot of time, though, and, if no automated tests are available, a complete manual test run at the end would be necessary. You probably won’t have that much time, so let us see what other options we have.</p>
			<p>There are two ways that <em class="italic">PHPStan</em> can be told to ignore errors: firstly, using <em class="italic">PHPDocs</em> annotations, and secondly, using a special parameter in the configuration file. </p>
			<h4>Using PHPDocs annotations</h4>
			<p>To ignore a line of <a id="_idIndexMarker224"/>code, simply add a comment before or on the affected line, using the special <strong class="source-inline">@phpstan-ignore-next-line</strong> and <strong class="source-inline">@phpstan-ignore-line</strong> <em class="italic">PHPDocs</em> annotations:</p>
			<pre class="source-code">
<strong class="bold">// @phpstan-ignore-next-line</strong>
$exampleClass-&gt;foo();
$exampleClass-&gt;bar(); <strong class="bold">// @phpstan-ignore-line</strong></pre>
			<p>Both lines of code will not be scanned for errors anymore. It is up to you to choose the way you prefer. It is not possible to ignore bigger code blocks or even entire functions or classes, though (unless you want to add a comment to every line, that is).</p>
			<h4>Using ignoreErrors parameters</h4>
			<p>The <em class="italic">PHPDocs</em> annotations are<a id="_idIndexMarker225"/> perfect for quick fixes in only a few locations, but you will need to touch many files if you wish to ignore numerous errors. Using the <strong class="source-inline">ignoreErrors</strong> parameter in the configuration file is not very comfortable, though, as you have to write a regular expression for every error you would like to ignore. </p>
			<p>The following example will explain how it works. Let’s assume we keep getting an error as follows:</p>
			<p class="source-code">Method OrderPosition::getGrossPrice() has no return type specified.</p>
			<p>Although theoretically, this would be easy to fix, the team decides against adding a type hint so as not to risk any side effects. The <strong class="source-inline">OrderPosition</strong> class is awfully written and not covered with tests, yet still works as expected. Since it will be replaced soon anyway, we are not willing to take the risk and touch it.</p>
			<p>To ignore this error, we need to add the <strong class="source-inline">ignoreErrors</strong> parameter to our <strong class="source-inline">phpstan.neon</strong> configuration file:</p>
			<pre class="source-code">
parameters:
    level: 6
    paths:
        - src
    ignoreErrors:
        - '#^Method OrderPosition\:\:getGrossPrice\(\) has no return type specified\.$#'</pre>
			<p>Instead of defining a rule or ruleset to ignore, we need to provide a regular expression here that matches the message of the error that should be ignored.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Writing regular expressions can be challenging. Luckily, the <em class="italic">PHPStan</em> website offers a very useful little tool to generate the necessary <strong class="source-inline">phpstan.neon</strong> part from the error message: <a href="https://phpstan.org/user-guide/ignoring-errors#generate-an-ignoreerrors-entry">https://phpstan.org/user-guide/ignoring-errors#generate-an-ignoreerrors-entry</a>.</p>
			<p>Upon the<a id="_idIndexMarker226"/> next run, the error will no longer be displayed regardless of where it occurs, as it matches the regular expression here.</p>
			<p><em class="italic">PHPStan</em> does not inform you about the fact that errors are ignored. Do not forget to fix them at some point! However, if you improve your code further over time, <em class="italic">PHPStan</em> will let you know when errors that are set to be ignored are no longer matched. You can safely remove them from the list then. </p>
			<p>If you want to ignore certain errors completely, but just in one or more files or paths, you can do so by using a slightly different notation:</p>
			<pre class="source-code">
ignoreErrors:
    -
        message: '#^Method
          OrderPosition\:\:getGrossPrice\(\) has no return
          type specified\.$#'
        path: src/OrderPosition.php</pre>
			<p>The path <a id="_idIndexMarker227"/>needs to be relative to the location of the <strong class="source-inline">phpstan.neon</strong> configuration file. When given, the error will only be ignored if it occurs in <strong class="source-inline">OrderPosition.php</strong>.</p>
			<h4>Baseline</h4>
			<p>As we just saw in the previous<a id="_idIndexMarker228"/> section, adding errors you want to be ignored manually to your configuration file is a cumbersome task. But there is an easier way: similar to <em class="italic">PHPMD</em>, it is possible to automatically add all the current errors to the list of ignored errors at once by executing the following command with the <strong class="source-inline">--generate-baseline</strong> option:</p>
			<p class="source-code">$ vendor/bin/phpstan analyse <strong class="bold">--generate-baseline</strong></p>
			<p>The newly generated file, <strong class="source-inline">phpstan-baseline.neon</strong>, is in the same directory as the configuration file. PHPStan will not make use of it automatically, though. You have to include it manually in the <strong class="source-inline">phpstan.neon</strong> file as follows: </p>
			<pre class="source-code">
includes:
    - phpstan-baseline.neon
parameters:
    …</pre>
			<p>The next time you run PHPStan now, any previously reported errors should not be reported anymore.</p>
			<p>Internally, the <a id="_idIndexMarker229"/>baseline file is nothing more than an automatically created list of the <strong class="source-inline">ignoreErrors</strong> parameters. Feel free to modify it to your needs. You can always regenerate it by executing <strong class="source-inline">phpstan</strong> using the <strong class="source-inline">--generate-baseline</strong> option again.</p>
			<h3>Extensions</h3>
			<p>It is possible to extend <a id="_idIndexMarker230"/>the functionality of <em class="italic">PHPStan</em>. The vivid community has already created a respectable number of useful extensions. For example, frameworks such as Symfony, Laminas, or Laravel often make use of magic methods (such as <strong class="source-inline">__get()</strong> and <strong class="source-inline">__set()</strong>), which cannot be analyzed automatically. There are extensions for these frameworks that provide the necessary information to <em class="italic">PHPStan</em>.</p>
			<p>While we cannot cover these extensions in this book, we encourage you to check out the extension library: <a href="https://phpstan.org/user-guide/extension-library">https://phpstan.org/user-guide/extension-library</a>. There are also extensions for PHPUnit, phpspec, and WordPress.</p>
			<h3>A recap of PHPStan </h3>
			<p><em class="italic">PHPStan</em> is a <a id="_idIndexMarker231"/>powerful tool. We cannot cover all its functionality in just a few pages but we have given you a good idea of how to start using it. Once you are familiar with its basic usage, check <a id="_idIndexMarker232"/>out <a href="https://phpstan.org">https://phpstan.org</a> to learn more!</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor094"/>Psalm: A PHP static analysis linting machine</h2>
			<p>The next and last static<a id="_idIndexMarker233"/> code analyzer we want to introduce is <em class="italic">Psalm</em>. It will check our code base for so-called issues and report any violations. Furthermore, it can resolve some of these issues automatically. So, let us have a closer look.</p>
			<h3>Installation and usage</h3>
			<p>Once again, installing <em class="italic">Psalm</em> with<a id="_idIndexMarker234"/> Composer is just a matter of a few keystrokes:</p>
			<p class="source-code">$ composer require --dev vimeo/psalm</p>
			<p>It is available as a <strong class="source-inline">phar</strong> file as well. </p>
			<p>After installation, we cannot<a id="_idIndexMarker235"/> just start, though – rather, we need to set up a configuration file for the current project first. We can use the comfortable <strong class="source-inline">--init</strong> option to create it:</p>
			<p class="source-code">$ vendor/bin/psalm --init</p>
			<p>This command will write a configuration file called <strong class="source-inline">psalm.xml</strong> in the current directory, which should be the project root. During its creation, <em class="italic">Psalm</em> checks whether it can find any PHP code and decides which error level is suitable, to begin with. Running <em class="italic">Psalm</em> doesn’t require any more options:</p>
			<p class="source-code">$ vendor/bin/psalm</p>
			<h3>Configuration</h3>
			<p>The configuration<a id="_idIndexMarker236"/> file was already created during the installation process and could, for example, look similar to this:</p>
			<p class="source-code">&lt;?xml version="1.0"?&gt;</p>
			<p class="source-code">&lt;psalm</p>
			<p class="source-code">    <strong class="bold">errorLevel="7"</strong></p>
			<p class="source-code">    <strong class="bold">resolveFromConfigFile="true"</strong></p>
			<p class="source-code">    xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance</p>
			<p class="source-code">    xmlns=https://getpsalm.org/schema/config</p>
			<p class="source-code">    xsi:schemaLocation=https://getpsalm.org/schema/config vendor/vimeo/psalm/config.xsd</p>
			<p class="source-code">&gt;</p>
			<p class="source-code">    &lt;projectFiles&gt;</p>
			<p class="source-code">        &lt;directory name="src" /&gt;</p>
			<p class="source-code">        &lt;ignoreFiles&gt;</p>
			<p class="source-code">            &lt;directory name="vendor" /&gt;</p>
			<p class="source-code">        &lt;/ignoreFiles&gt;</p>
			<p class="source-code">    &lt;/projectFiles&gt;</p>
			<p class="source-code">&lt;/psalm&gt;</p>
			<p>Let us have a look at the attributes of the <strong class="source-inline">&lt;psalm&gt;</strong> node. You do not need to worry about the schema- and namespace-related information, only about the following two things:</p>
			<ul>
				<li><strong class="source-inline">errorLevel</strong>: The levels go from 8 (basic checks) to 1 (very strict). In other words, the lower the level, the more rules will be applied.</li>
				<li><strong class="source-inline">resolveFromConfigFile</strong>: Setting this to <strong class="source-inline">true</strong> lets <em class="italic">Psalm</em> resolve all relative paths (such as <strong class="source-inline">src</strong> and <strong class="source-inline">vendor</strong>) from the location of the configuration file – so usually, from the project root.</li>
			</ul>
			<p class="callout-heading">Psalm documentation</p>
			<p class="callout">Psalm<a id="_idIndexMarker237"/> offers many more configuration options that we cannot cover in this book. As always, we recommend checking the documentation (https://psalm.dev/docs) to learn more about this tool.</p>
			<p>Inside the <strong class="source-inline">&lt;psalm&gt;</strong> node, you will<a id="_idIndexMarker238"/> find more settings. In the previous example, <em class="italic">Psalm</em> is told to only scan the <strong class="source-inline">src</strong> folder and ignore all the files in the <strong class="source-inline">vendor</strong> folder. Ignoring the <strong class="source-inline">vendor</strong> folder is important, as we don’t want to scan any third-party code.</p>
			<h3>Using Psalm in legacy projects</h3>
			<p>We will now have a look <a id="_idIndexMarker239"/>at how we can adjust <em class="italic">Psalm</em> to deal with existing projects better. As with the previous tools, there are basically two ways to ignore issues: using the configuration file or docblock annotations.</p>
			<p>There are three code issue levels: <strong class="source-inline">info</strong>, <strong class="source-inline">error</strong>, and <strong class="source-inline">suppress</strong>. While <strong class="source-inline">info</strong> will just print info messages if minor issues have been found, issues that are at the level of an <strong class="source-inline">error</strong> type, on the other hand, require you to get active. An issue of the <strong class="source-inline">suppress</strong> type will not be shown at all. </p>
			<p class="callout-heading">Continuous Integration</p>
			<p class="callout">The difference between <strong class="source-inline">info</strong> and <strong class="source-inline">error</strong> becomes more important when building a Continuous Integration pipeline. <strong class="source-inline">info</strong> issues would let the build pass, while <strong class="source-inline">error</strong> issues would break it. We will have a closer look at this topic later. </p>
			<h4>Docblock suppression</h4>
			<p>The <strong class="source-inline">@psalm-suppress</strong> annotation <a id="_idIndexMarker240"/>can be used either in a function docblock or a comment for the next line. The <strong class="source-inline">Vat</strong> class from the previous examples could look as follows:</p>
			<pre class="source-code">
class Vat
{
    private float $vat = 0.19;
    /**
     * <strong class="bold">@psalm-suppress InvalidReturnType</strong>
     */
    public function getVat(): int
    {
        /**
         * <strong class="bold">@psalm-suppress InvalidReturnStatement</strong>
         */
        return $this-&gt;vat;
    }
}</pre>
			<h4>Configuration file suppression</h4>
			<p>If we want to suppress issues, we need to <a id="_idIndexMarker241"/>configure <strong class="source-inline">issueHandler</strong> for them, where we can set the type to suppress manually. This is done in the configuration file by adding an <strong class="source-inline">&lt;issueHandler&gt;</strong> node inside the <strong class="source-inline">&lt;psalm&gt;</strong> node:</p>
			<p class="source-code">&lt;issueHandlers&gt;</p>
			<p class="source-code">    &lt;InvalidReturnType errorLevel="suppress" /&gt;</p>
			<p class="source-code">    &lt;InvalidReturnStatement errorLevel="suppress" /&gt;</p>
			<p class="source-code">&lt;/issueHandlers&gt;</p>
			<p>The preceding configuration would suppress all the <strong class="source-inline">InvalidReturnType</strong> and <strong class="source-inline">InvalidReturnStatement</strong> issues in the whole project. We can make this a bit more specific, though:</p>
			<p class="source-code">&lt;issueHandlers&gt;</p>
			<p class="source-code">    &lt;InvalidReturnType&gt;</p>
			<p class="source-code">        &lt;errorLevel type="suppress"&gt;</p>
			<p class="source-code">            <strong class="bold">&lt;file name="Vat.php" /&gt;</strong></p>
			<p class="source-code">        &lt;/errorLevel&gt;</p>
			<p class="source-code">    &lt;/InvalidReturnType&gt;</p>
			<p class="source-code">    &lt;InvalidReturnStatement&gt;</p>
			<p class="source-code">        &lt;errorLevel type="suppress"&gt;</p>
			<p class="source-code">            <strong class="bold">&lt;dir name="src/Vat" /&gt;</strong></p>
			<p class="source-code">        &lt;/errorLevel&gt;</p>
			<p class="source-code">    &lt;/InvalidReturnStatement&gt;</p>
			<p class="source-code">&lt;/issueHandlers&gt;</p>
			<p>In the documentation (<a href="https://psalm.dev/docs/running_psalm/dealing_with_code_issues/">https://psalm.dev/docs/running_psalm/dealing_with_code_issues/</a>), you will find even more ways to suppress issues – for example, by the variable name.</p>
			<h4>Baseline</h4>
			<p>As with the previous static code <a id="_idIndexMarker242"/>analyzers we discussed, <em class="italic">Psalm</em> also provides a feature to generate a baseline file, which will include all the current errors so that they will be ignored during the next run. Please note that the baseline feature only works for <strong class="source-inline">error</strong> issues, but not <strong class="source-inline">info</strong> issues. Let us create the file first:</p>
			<p class="source-code">$ vendor/bin/psalm --set-baseline=psalm-baseline.xml</p>
			<p><em class="italic">Psalm</em> has no default name for this file, so you need to pass it as an option to the command:</p>
			<p class="source-code">$ vendor/bin/psalm <strong class="bold">--use-baseline</strong>=psalm-baseline.xml</p>
			<p>You can also add it as an additional attribute to the <strong class="source-inline">&lt;psalm&gt;</strong> node in the configuration file:</p>
			<p class="source-code">&lt;psalm</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    <strong class="bold">errorBaseline</strong>="./psalm-baseline.xml"</p>
			<p class="source-code">&gt;</p>
			<p>Finally, you can update the baseline file – for example, after you have made some improvements to the code:</p>
			<p class="source-code">$ vendor/bin/psalm <strong class="bold">--update-baseline</strong></p>
			<h3>Fixing issues automatically</h3>
			<p><em class="italic">Psalm</em> will not <a id="_idIndexMarker243"/>only find the issue but it can also fix many of them automatically. It will let you know when this is the case and you can use the <strong class="source-inline">--alter</strong> option:</p>
			<p class="source-code">Psalm can automatically fix 1 issues.</p>
			<p class="source-code">Run Psalm again with</p>
			<p class="source-code">--alter --issues=InvalidReturnType --dry-run</p>
			<p class="source-code">to see what it can fix.</p>
			<p>Let’s execute the command as <em class="italic">Psalm</em> suggests:</p>
			<p class="source-code">$ vendor/bin/psalm --alter --issues=InvalidReturnType --dry-run</p>
			<p>The <strong class="source-inline">--dry-run</strong> option tells <em class="italic">Psalm</em> to only show you what it would change as <strong class="source-inline">diff</strong>, but not to apply the changes. This way, you can check whether the change is correct:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/Figure_7.04_B19050.jpg" alt="Fig 7.4: Psalm showing proposed changes&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Fig 7.4: Psalm showing proposed changes</p>
			<p>If you <a id="_idIndexMarker244"/>remove the <strong class="source-inline">--dry-run</strong> option, the changes will be applied.</p>
			<h3>A recap on  Psalm </h3>
			<p><em class="italic">Psalm</em> is a <a id="_idIndexMarker245"/>standard tool in the clean coder’s toolkit for good reason. It is fast, easy to use, and powerful. Additionally, the code manipulation feature will save you a lot of time. Of course, there are numerous similarities with <em class="italic">PHPStan</em>, but often enough, you will find both tools working together on the same code base without problems. At least, you should consider giving it a try.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor095"/>IDE extensions</h1>
			<p>The tools <a id="_idIndexMarker246"/>we looked at so far share something in common: they need to be applied to our code after we have written it. Of course, this is much better than nothing, but wouldn’t it be great if the tools gave us their feedback immediately at the time that we wrote the code?</p>
			<p>That is what many other developers thought as well, so they created extensions for the most popular IDEs, which are currently <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>) and <strong class="bold">PhpStorm</strong>:</p>
			<ul>
				<li><em class="italic">PhpStorm</em> is an<a id="_idIndexMarker247"/> established, commercial IDE from JetBrains with several PHP-specific tools, checks, and built-in integrations for many of the code quality tools we discussed in this chapter. There are many useful extensions available for it as well. You can try it out for 30 days for free.</li>
				<li><em class="italic">VS Code</em> is <a id="_idIndexMarker248"/>a highly flexible code editor from Microsoft with tons of third-party (partly commercial) extensions that can turn these tools into an IDE for virtually every relevant programming language today. Because the code editor itself is free, is it becoming more and more popular.</li>
			</ul>
			<p class="callout-heading">Alternative PHP IDEs</p>
			<p class="callout"><em class="italic">PhpStorm</em> and <em class="italic">VS Code</em> are not <a id="_idIndexMarker249"/>the only IDEs<a id="_idIndexMarker250"/> that exist for PHP. Other alternatives are <em class="italic">NetBeans</em> (<a href="https://netbeans.apache.org">https://netbeans.apache.org</a>), <em class="italic">Eclipse PDT</em> (https://www.eclipse.org), or <em class="italic">CodeLobster</em> (<a href="https://www.codelobster.com">https://www.codelobster.com</a>). </p>
			<p>In this section, we will introduce you to three extensions for these two IDEs:</p>
			<ul>
				<li><strong class="bold">PHP Inspections</strong> (EA Extended) for PhpStorm</li>
				<li><strong class="bold">Intelephense</strong> for VS Code</li>
			</ul>
			<p class="callout-heading">Code quality tool integration in PhpStorm</p>
			<p class="callout">PhpStorm offers <a id="_idIndexMarker251"/>seamless integration for the following tools that we have discussed: <em class="italic">PHP CS Fixer</em>, PHPMD, PHPStan, and Psalm. More information can be found here: <a href="https://www.jetbrains.com/help/phpstorm/php-code-quality-tools.html">https://www.jetbrains.com/help/phpstorm/php-code-quality-tools.html</a>.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor096"/>PHP Inspections (EA Extended)</h2>
			<p>This plugin (https://github.com/kalessil/phpinspectionsea) is for PhpStorm. It will add even more types of <a id="_idIndexMarker252"/>inspections to the pool of already existing <a id="_idIndexMarker253"/>ones, covering topics such as code<a id="_idIndexMarker254"/> style, architecture, or possible bugs.</p>
			<p class="callout-heading">IDE Inspections</p>
			<p class="callout">Modern IDEs are already equipped with a lot of useful code checks. In PHPStorm, they are called <em class="italic">Inspections</em>. Some are <a id="_idIndexMarker255"/>already enabled by default – more can be activated manually (https://www.jetbrains.com/help/phpstorm/code-inspection.html#access-inspections-and-settings). For VS Code, you need to install an extension first. Check out the documentation (https://code.visualstudio.com/docs/languages/php) for more information.</p>
			<h3>Installation</h3>
			<p>As with every PhpStorm<a id="_idIndexMarker256"/> plugin, the installation is done via the <strong class="screen-inline">File -&gt; Settings -&gt; Plugins</strong> dialog. You will find detailed information on how to install a plugin on the vendor’s website (<a href="https://www.jetbrains.com/help/phpstorm/managing-plugins.html">https://www.jetbrains.com/help/phpstorm/managing-plugins.html</a>). Simply search for <strong class="source-inline">EA Extended</strong>. Please note that there is a second version of this plugin, EA Ultimate, which you have to pay for. We will not cover it in this book.</p>
			<p>After installation, not all the inspections are immediately active. Let us have a look at the PhpStorm inspections configuration, as shown in <em class="italic">Figure 7.4</em>:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_7.05_B19050.jpg" alt="Figure 7.5: The Inspections configuration dialog in PhpStorm&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5: The Inspections configuration dialog in PhpStorm</p>
			<p>All the inspections of this <a id="_idIndexMarker257"/>plugin can be found in the <strong class="bold">Php Inspections (EA Extended)</strong> section. The inspections that are not active by default can easily be activated by checking the checkbox next to them. We recommend reading the documentation (https://github.com/kalessil/phpinspectionsea/tree/master/docs) before activating any further inspections – otherwise, you might end up with too many rules. You can revisit them later.</p>
			<h3>Usage </h3>
			<p><strong class="bold">PHP Inspections (EA Extended)</strong> not only <a id="_idIndexMarker258"/>warns you about problems but often also offers so-called Quick-Fixes, which let the IDE do the work for you. Here, you will find an example. Note the highlighted <strong class="source-inline">if</strong> clause on line 7:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_7.06_B19050.jpg" alt="Figure 7.6: Example code with an issue found by PHP Inspections (EA Extended)&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6: Example code with an issue found by PHP Inspections (EA Extended)</p>
			<p>When you<a id="_idIndexMarker259"/> hover your mouse pointer over the highlighted area, PhpStorm will show a pop-up window with further instructions about the suggested improvement:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/Figure_7.07_B19050.jpg" alt="Figure 7.7: PHP Inspections (EA Extended) suggesting a code improvement &#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7: PHP Inspections (EA Extended) suggesting a code improvement </p>
			<p>You can choose to fix the issue directly by pressing <em class="italic">Alt + Shift + Enter</em> at the same time, or you can click on the highlighted area to show the Quick-Fix bubble. If you click on the bubble, you will see a menu with some more options. You can also invoke the following dialog by pressing <em class="italic">Alt + Enter</em>:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_7.08_B19050.jpg" alt="Figure 7.8: The Quick-Fix options menu&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8: The Quick-Fix options menu</p>
			<p>PhpStorm offers <a id="_idIndexMarker260"/>you several fixes now. The first one, marked with <strong class="source-inline">[EA]</strong>, is a suggestion by the plugin. Another click will apply the fix:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/Figure_7.09_B19050.jpg" alt="Figure 7.9: The code after applying a Quick-Fix&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9: The code after applying a Quick-Fix</p>
			<p>That’s it! Within just a few seconds, you made your code shorter and easier to read. <strong class="bold">PHP Inspections (EA Extended)</strong> is a great addition to PhpStorm, as it offers sensible inspections and integrates them seamlessly. If you are using this IDE, you should not hesitate to install it.</p>
			<p class="callout-heading">Inspections when working in a team</p>
			<p class="callout">These inspections are a great way to improve your code and educate yourself on best practices. However, there is a huge drawback: how do you ensure that every developer working on your project has the same inspections activated? We will cover this topic in <em class="italic">Working in a Team</em>.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor097"/>Intelephense</h2>
			<p>The second extension we want <a id="_idIndexMarker261"/>to introduce is <em class="italic">Intelephense</em> for VS Code. It is<a id="_idIndexMarker262"/> the most frequently downloaded PHP extension for this editor and provides a lot of functionality (such as code completion and formatting), which turns VS Code into a fully capable PHP IDE. There is also a commercial, premium version of this extension that offers even more functionality. To install it, please follow the instructions on the Marketplace website for this plugin (https://marketplace.visualstudio.com/items?itemName=bmewburn.vscode-intelephense-client).</p>
			<p><em class="italic">Intelephense</em> does not have the range of functionality that a full-grown, commercial IDE would offer by any means, yet for a free service, it is a perfect choice. It offers so-called Diagnostics (which are similar to Inspections in PhpStorm) that can be configured in the plugin settings screen, as shown in <em class="italic">Figure 7.9</em>:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/Figure_7.10_B19050.jpg" alt="Figure 7.10: The Intelephense settings screen&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10: The Intelephense settings screen</p>
			<h3>Usage</h3>
			<p>The following figure shows<a id="_idIndexMarker263"/> Diagnostics in Intelephense in action:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_7.11_B19050.jpg" alt="Figure 7.11: A sample class showing how Intelephense highlights issues&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11: A sample class showing how Intelephense highlights issues</p>
			<p>Two things can be seen here. Firstly, and more obviously, is the red line underneath <strong class="source-inline">TestClass</strong>. Hovering the mouse pointer over <strong class="source-inline">TestClass</strong> will show a pop-up window with an explanation: <strong class="bold">Undefined type TestClass</strong>. This makes sense since this class does not exist.</p>
			<p>Secondly, and more subtly, you <a id="_idIndexMarker264"/>will notice that <strong class="source-inline">$ununsedAttribute</strong> and <strong class="source-inline">$testInstance</strong> have a slightly darker color than the other variables. This indicates another issue, which can be revealed by hovering the mouse over one of the variables:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_7.12_B19050.jpg" alt="Figure 7.12: An info popup in Intelephense&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12: An info popup in Intelephense</p>
			<p>The popup tells us that <strong class="source-inline">$unsuserAttribute</strong> is not used elsewhere in the code. The same applies to <strong class="source-inline">$testInstance</strong> as well.</p>
			<p>Although it provides some <a id="_idIndexMarker265"/>basic issue detection rules and code formatting, it clearly can be said that, at the time of writing, the focus of this plugin is not on clean code. However, given the fact that VS Code and this plugin are freely available, you already have a decent PHP IDE on hand to start coding.</p>
			<p class="callout-heading">Code quality tool integration in VS Code</p>
			<p class="callout">As in PhpStorm, it is <a id="_idIndexMarker266"/>possible to integrate some common code quality tools into VS Code using plugins, such as for PHPStan (<a href="https://marketplace.visualstudio.com/items?itemName=calsmurf2904.vscode-phpstan">https://marketplace.visualstudio.com/items?itemName=calsmurf2904.vscode-phpstan</a>), <em class="italic">PHP CS Fixer </em>(<a href="https://marketplace.visualstudio.com/items?itemName=junstyle.php-cs-fixer">https://marketplace.visualstudio.com/items?itemName=junstyle.php-cs-fixer</a>), and PHPMD (<a href="https://marketplace.visualstudio.com/items?itemName=ecodes.vscode-phpmd">https://marketplace.visualstudio.com/items?itemName=ecodes.vscode-phpmd</a>). So, if you want to code with VS Code, be sure to check Marketplace for new plugins every now and then.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/>Summary</h1>
			<p>In this chapter, we learned about state-of-the-art tools to assist you in creating high-quality PHP code. They will help you spot issues early in the <strong class="bold">Software Development Life Cycle</strong> (<strong class="bold">SDLC</strong>), which saves you vast amounts of time. The PHP community is still vivid and very productive, and we were not able to cover all the fantastic software that exists out there in this book. However, with the tools we introduced in this chapter, you are now well equipped for your journey towards clean code. </p>
			<p>In the next chapter, you will learn about how to evaluate code quality by using the established metrics and, of course, the necessary tools to gather them. See you there! </p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor099"/>Further reading</h1>
			<p>If you want to try out even more code quality tools, consider the following projects:</p>
			<ul>
				<li><em class="italic">Exakat</em> (https://www.exakat.io) – A tool that also covers security issues and performance, for example. It can fix issues automatically, too.</li>
				<li><em class="italic">Phan</em> (https://github.com/phan/phan) – A static code analyzer that you can try out immediately in your browser</li>
				<li><em class="italic">PHP Insights</em> (https://phpinsights.com/) – Another analyzer, yet with easy-to-use metrics in terms of the code, architecture, complexity, and style</li>
			</ul>
		</div>
	</body></html>