- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimizing Your Time and Separating Responsibilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s time for a little practice after all that theory! We’ve already seen a
    lot together: advanced principles on clean code, how to choose the right external
    libraries for your applications, and how to take advantage of the latest patches
    of these libraries while not risking making your project explode in mid-air. But
    we should not forget that there is the word “code” in “clean code” (obviously).
    In this chapter, we will therefore concentrate a little more on the source code
    of your application and see the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions and organization of files and folders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is it important to separate responsibilities to respect the “S” of the SOLID
    principles? What does it bring to you?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll discover an elegant way to manage responsibility separation with an event
    system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And we’ll finish with some polymorphism—namely, abstract classes and interfaces:
    why, how, and when to use them?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming and organizational conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We must add a disclaimer before anything else. The naming conventions and organizational
    ideas given in this chapter are not an absolute truth. As we have seen before,
    the most important thing is to respect the conventions already in place in your
    project and to be consistent with your team. If you feel it is necessary, it is
    possible to adapt these rules to your needs. Again, the important thing is to
    use common sense and logic and to be as clear as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first talk about the naming of source files. Obviously, the naming conventions
    differ from one technology to another (depending on whether you use a certain
    framework or another, the good practices may change, for example). Nevertheless,
    we can note some conventions that can be found almost everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Class files and interface files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Foo` class should be defined in a `Foo.php` file. More than a convention,
    this naming technique has a real technical interest. Indeed, the autoloading mechanisms
    of PHP will assume that your file defines a class with the same name. Autoloading
    allows PHP to automatically discover the classes defined in your application,
    and in particular thanks to namespaces (we’ll come back to this in a few moments,
    as these are directly linked to the organization of files in your project). If
    you name your files and the classes they define differently, autoloading is likely
    to fail and throw an error. The most common naming style across the various languages
    and the global developer community for naming classes is `MySuperServiceClass`
    if we used PascalCase. There are other naming styles—we will see some of them
    and in which cases they apply.'
  prefs: []
  type: TYPE_NORMAL
- en: Executables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PHP files, being executable command-line scripts, have a strong tendency to
    be named in lowercase. The `apt-get`, `docker-compose`, and `git cherry-pick`
    are perfect ambassadors. Nothing prevents you from naming your executable file
    in another way, and everything will work fine. However, by naming your command-line
    applications written in PHP this way, you provide a uniform **command-line interface**
    (**CLI**) experience with the vast majority of commands. This is exactly what
    we want when we develop a command-line application in PHP: for it to blend in
    with more *traditional* system commands.'
  prefs: []
  type: TYPE_NORMAL
- en: Web assets and resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is another case where the kebab-case style is used, which is mainly for
    public web resources, particularly JavaScript, `/contact-us`, compared to something
    such as `/contactus` or `/ContactUs`. This can be particularly important if you
    must work on frontend files.
  prefs: []
  type: TYPE_NORMAL
- en: Naming classes, interfaces, and methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen in the previous chapters, abbreviations should be banned from
    your code. `Abstract` (for example, `AbstractMailer`) and your interfaces should
    end with the suffix `Interface` (for example, `MailerInterface`). This makes the
    name very slightly longer, but there is no confusion in their use. Their purpose
    is clear, defined, and visible immediately. Don’t be afraid to give your classes
    long names if it is necessary for their understanding. `AbstractWebDeveloperConsoleStreamWrapperExtension`
    may seem extremely long for a class name, but it is immediately clear what it
    is for in a project context, without having to ask too many questions. Again,
    with the autocomplete feature of your IDE, you will be able to use it within seconds
    by typing the first few letters. The same goes for your attribute and method names.
    Be explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Talking about attribute and method naming, we tend to prefer the `myGreatMethod`).
    Some languages use PascalCase for naming methods such as C#. Let’s be honest—there
    is no real justification or argument for this, and both naming styles are actually
    equal. For once, it is really a convention—a language-specific habit.
  prefs: []
  type: TYPE_NORMAL
- en: Naming folders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The naming conventions for folders are similar to those for files. PascalCase
    is mostly used for folders. Other naming styles can also be used for publicly
    exposed folders, such as web resources. You should not hesitate to create a large
    tree structure and give it meaning. Therefore, folders named simply `Manager`,
    `Service`, or `Wrapper` are to be avoided. These terms are too generic and do
    not allow an easy understanding of what they define. We prefer more explicit variants,
    such as `Mail` and its subfolders `Provider`, `Logger`, and so on. These subfolders
    can have more generic names, being contained in a folder whose name defines a
    context: a domain. A clever way to find your way around is to use folders to separate
    your source code into different domains. Your application will be better sliced
    and your architecture clear. What concerns the same theme will be in the same
    place. You will be much more efficient as this habit becomes natural. Many open
    source projects and libraries use this way of slicing their sources. So, you will
    be able to browse not only your own code but also the code of others. It is sometimes
    extremely complicated and time-consuming to find the right name for an element,
    whether it is a class, a file, a variable, or anything else. This step is, however,
    particularly important and should not be neglected. Be careful not to say to yourself:
    “I put a name that is not necessarily very clear, but I will change it later.”
    Chances are that you will forget it, and technical debt will be brought in without
    you even realizing it.'
  prefs: []
  type: TYPE_NORMAL
- en: Separating responsibilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s see what the separation of responsibilities in the code consists of,
    to make it cleaner, understandable, maintainable, and extensible. This is the
    first point of the SOLID principles. In the second chapter, this is how we defined
    the principle of single responsibility: “*It means that a class in your code must
    respond to only one task.*”'
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, SOLID is a set of known clean-code rules that, when applied together,
    will make your code much clearer and more accurate. Rather than trying to follow
    the five principles described by each of the SOLID caps to the letter, it is more
    important to have a global idea of all this in mind when you code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step to respect this is, in fact... naming, as we just saw! Indeed,
    by naming a class properly, clearly, and, above all, precisely, you are already
    making sure that it doesn’t become a mess where you put a little bit of everything
    that you can think of. And it is for this very reason that it is necessary not
    to name your methods with too generic terms such as `Manager` and `Service`. This
    leads to a big problem: if we end up with a class named `EmailManager`, we will
    obviously all have as a first thought to add all our next methods that deal with
    managing emails. And that’s how the chaos begins. That’s why we will prefer to
    create classes such as `EmailFactory`, `AbstractEmailSender`, and so on in order
    to absolutely avoid having classes with hundreds of different methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start to understand better this principle of single responsibility. Let’s
    repeat: the goal is not to create classes with a single method in them. It doesn’t
    make sense. You must split it up intelligently. There is no general rule for splitting
    classes. The right way to split a class will come naturally with experience and
    it will come by itself. If it helps you, you can see folders as domains, and the
    files as subdomains. Using the next examples, we have a domain (or folder) that
    would be named `Email`, and subdomains dedicated to specific tasks: creating an
    email, defining a base class to send an email with a specific email provider,
    and so on. We can go even further in this separation of responsibilities. Indeed,
    tools exist to help us solve this problem in an effortless way. We are going to
    discover (or rediscover!) event dispatching.'
  prefs: []
  type: TYPE_NORMAL
- en: Event dispatching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Event dispatching is usually implemented thanks to the Observer and Mediator
    design patterns, as is the case in Symfony’s `EventDispatcher` component. This
    information is just for general knowledge. Indeed, design patterns can seem obscure,
    even scary at first. Moreover, explaining them deserves a book of its own. So,
    we’re going to vulgarize all this without talking about design patterns. Moreover,
    we are not going to implement an event dispatcher: it is about understanding how
    it can help us.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Very simply, the principle of event dispatching is to notify all parties interested
    in the change of state of a particular entity when it happens. The parties will
    notify a central mediator by saying: “I’m interested in knowing when this particular
    event occurs; notify me when it does because I have things to do if it happens.”
    The mediator will then retain this information. When said event occurs, the mediator
    will then go through the list of parties interested in it and say: “The event
    just happened; do what you have to do.” Taking this a step further, it is even
    possible that the interested parties will declare a priority to go before everyone
    else if necessary. Be careful—we are talking about synchronous events, which is
    to say that the parties interested in the event will execute one by one, following
    the others, and not in parallel. Asynchronous event management is a whole other
    story.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Event dispatching is as simple as that. But then, how will it help us reinforce
    our principle of single responsibility? Let’s look at a concrete example: a user
    deletes their account from your application. You then need to do two tasks, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the account from the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send a last email to the user to say a sad goodbye
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we will naturally create a service such as `UserRemover`, which will perform
    these two tasks in a row. It works very well. `UserRemover` is an explicit name
    that defines a very precise task. No problem so far. Then, one day, your application
    gains popularity. You want to send an email to the administrators to notify them
    that the user has left. Our `UserRemover` class ends up deleting data and sending
    two emails, both with very specific content and recipients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later on, you want to give the user the possibility to delete their account
    to respect the `UserRemover` service that actually removes nothing, sends emails,
    and maybe many other tasks. We have a real problem: the class doesn’t do what
    it is supposed to do, and it is likely that it is now thousands of lines long
    and has dozens of methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Things would have been hugely different if you had used event dispatching from
    the beginning. Here is an example of a resolution. When a user wants to leave
    your application, you will dispatch an event named `UserRemovalRequestEvent`.
    Then, as your application grows, you will create parties interested in this event:
    event listeners. We will have one per task, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A listener to remove data from the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A listener for the goodbye mail to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A listener for the mail to the administrators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What about anonymization? Nothing simpler: we will create a listener for this
    task too, and we will “unplug” the listener for deleting data. So, we have one
    class per task. Each class has its own unique responsibility (send an email to
    the administrators, anonymize data, and so on). If in the future you need to add
    a task, you will create a new class (or listener) with a specific task, without
    ever touching the other classes. The code is then clean and extremely extensible.
    The classes remain well-named and concise. If a task is obsolete, you can simply
    remove it from the list of parties interested in the event in question. The principle
    of single responsibility is respected.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use a ready-to-use event dispatcher, we recommend using the `symfony/event-dispatcher`
    package. This is exactly the component that is used in the framework for its operation.
    It is very robust and efficient and has been proven for several years.
  prefs: []
  type: TYPE_NORMAL
- en: Demystifying polymorphism – interfaces and abstract classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As far as the separation of responsibilities is concerned, event dispatching
    is a concept that is already advanced. You can consider that your level in the
    world of clean code has increased considerably if you know this mechanism, understand
    it, and have the chance to use it. All this obviously requires a bit of setup.
    Either you implement this system by yourself or you use an external library. In
    the second case, there is obviously a whole learning phase to be included. Either
    way, this is obviously not the only way to improve the separation of your responsibilities.
    There is a way that is native to PHP to improve this separation, sometimes not
    used enough, sometimes misunderstood, and often underestimated. We are talking
    here about polymorphism, or vulgarly: abstract classes and interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: First, why the word *polymorphism*? *Poly* comes from the Greek meaning *many*,
    and *morphism* means *form*/*shape*. Abstract classes and interfaces are just
    one way to implement polymorphism in code and **object-oriented programming**
    (**OOP**). To simplify things, let’s take only the case of interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Interfaces define a common form/shape for classes that implement them later.
    They determine the methods that each implementation should define for its case.
    An implementation must necessarily define all the methods of its interface(s).
    This is often the reason why we hear the following statement: “an interface is
    a contract”. We can see it this way: if you implement an interface, you commit
    to implementing the methods it defines. You have no other alternative.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the full power of polymorphism takes place. In your code, you
    can tell PHP that a so-and-so argument of a method will necessarily be an instance
    of an object implementing a precise interface. You can manipulate the different
    methods of this interface and call them. You don’t have to worry about how it
    will be implemented when it is used: we are not interested in that. As an example,
    is worth a thousand words, let’s take our mail system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have `MailerInterface` that defines only one method: a method to send a
    mail. We could name it `sendEmail`. As before, when a user is deleted in your
    application, the event listener for sending a goodbye mail is called. In this
    case, what you are interested in is that the mail is simply sent, not the internal
    workings of the sending. By the way, couldn’t these internal workings be different
    depending on certain conditions? You don’t have to look far for an example: your
    main email provider could be down, but you absolutely need to send your message.
    You then must use another email provider, with a different **application programming
    interface** (**API**), different options, and so on. Without polymorphism, things
    could get extremely complicated very quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to create two implementations of `MailerInterface`, each defining
    the `sendEmail` method, depending on the email provider used. But the result is
    the same: the mail is sent. When a user deletes their account, you perform a check
    to make sure that your main email provider is up and instantiate its implementation.
    If it is down, you instantiate the backup email provider implementation. On the
    other hand, in the email sending event listener, you just keep calling the `sendEmail`
    method defined in `MailerInterface`, without worrying about the rest. The code
    is clean, clear; responsibilities are separated; you save time. And on top of
    that, it has become resilient to failure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could do this with 10, 15, or 20 email providers if you wanted to. The
    advantage is that if the API of one of the providers changes or you find a bug
    in your implementation, you only have to touch the one implementation that is
    problematic. All the others don’t move, as is the case with the calls that are
    made to the interface. You considerably reduce the risk of bugs, and your code
    is much more testable: you can write tests specifically for each implementation.
    This is much more robust than generalized, endless tests that try to evaluate
    every possible case! The time saved is exceptional and priceless.'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'And how do abstract classes fit in all this? We can see these as an intermediate
    layer between an interface and its implementations. Although it is obviously not
    mandatory that an abstract class implements an interface, it is often a clever
    idea to create an interface on top of an abstract class. Indeed, the latter are
    more permissive than interfaces: you can partially define the methods that are
    declared, declare attributes, and decide on the visibility of the methods and
    attributes of the class (where interfaces only allow `public` visibility and not
    `private` or `protected`). With an interface, you have a clean contract, without
    any information that would be here “just in case” and with only the bare essentials
    if you respect the “I” of the SOLID principles—the interfaces’ segregation. As
    a reminder and simply put, this principle indicates that an interface should not
    contain methods that are declared “just in case” and that each one should help
    to meet the principle of single responsibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes allow us to define common behaviors to the classes that extend
    them and that wish to take advantage of the power of polymorphism. In particular,
    this avoids code redundancy, sources of bugs, and endless copy-pasting. Indeed,
    in our previous example, it is highly likely that the different implementations
    of `MailerInterface` have common behaviors, such as the creation of the HTTP client
    that communicates with the API of the email provider or the creation of a `Message`
    common object used in the internal workings of the implementations.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we would declare `AbstractMailer` implementing `MailerInterface`
    and define common behaviors of the different implementations. Then, the different
    implementations would extend `AbstractMailer` in order to enjoy the common behavior
    you just defined.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful—this does not mean that it is necessary to create interfaces and
    abstract classes everywhere, all the time, and in all cases. We should not neglect
    the impact that this has on the complexity of the code compared to a single class.
    Also, just because you haven’t created an interface for a case doesn’t mean that
    it is immutable and set in stone. Very often, we find ourselves refactoring our
    code and creating interfaces and abstract classes and adapting existing classes
    to implement and extend them. As we have seen, we need to keep the code simple
    at first (respecting the *YAGNI* and *KISS* principles). We cannot predict the
    future, business constraints evolve.
  prefs: []
  type: TYPE_NORMAL
- en: If at the time of creating a class, there is nothing to suggest that different
    implementations will be needed, this is not a concern. This is a job that will
    be done later. On the other hand, if during development you find yourself copying
    code from one side to the other and perceive a strong redundancy, it will be an
    excellent reflex to think about polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just covered the most advanced part of the theoretical section of this
    book. We are now armed with the knowledge to cut our code cleanly while keeping
    it maintainable and extensible for future developers. It will also be ready for
    the future by being strongly open to extension and closed to modification (as
    described in one of the *SOLID* principles).
  prefs: []
  type: TYPE_NORMAL
- en: We have reviewed many of the cases that you may encounter regarding the naming
    of files, classes, and methods when developing a PHP application. In addition,
    we have seen that folders must have specific names and can be used to divide your
    application into different domains.
  prefs: []
  type: TYPE_NORMAL
- en: The separation of responsibilities was also a big topic. It is particularly
    important to understand why this separation is useful, even vital, in a project.
    It is the real key to a well-architected project that is easy to navigate. Event
    dispatching is an excellent way to achieve this, as we have seen. Event dispatching
    is one of the cornerstones of some critical web projects such as the Symfony framework,
    to name but one. This one relies heavily on this mechanism, making it a tool known
    for its robustness, its efficiency, and—especially—its flexibility. This is also
    due to the polymorphism and the different interfaces declared within it. You can
    redeclare pretty much any part of the framework thanks to this and adapt everything
    to your most advanced needs.
  prefs: []
  type: TYPE_NORMAL
- en: It is not always easy to understand when to create an interface or an abstract
    class. This comes with practice and experience. Soon, it will seem natural. When
    in doubt, talk to one of your peers!
  prefs: []
  type: TYPE_NORMAL
- en: We will finish the theoretical part of this book with a lighter part in the
    next chapter, dealing with the new features of PHP. These make us more rigorous
    and better developers, especially in the last few years.
  prefs: []
  type: TYPE_NORMAL
