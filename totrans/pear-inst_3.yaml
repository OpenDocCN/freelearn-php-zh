- en: Chapter 3. Leveraging Full Application Support with the PEAR Installer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter we learned a great deal about the internals of `package.xml`.
    In this chapter, we are stepping up the intensity a notch, and exploring the exciting
    new features that enable us to easily distribute PHP applications and manage their
    installation and post-installation customization.
  prefs: []
  type: TYPE_NORMAL
- en: If you've ever wanted to make it easy to customize an installation of your PHP
    application across multiple platforms, PHP versions, and user setups, then this
    is the chapter for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'package.xml Version 2.0: Your Sexy New Friend'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The title of this section says it all. `package.xml 2.0` is a major improvement
    over `package.xml 1.0`. The implementations of several important new features
    in the PEAR installer such as custom file roles/tasks, enterprise-level dependencies,
    and channels are reflected by new tags in `package.xml 2.0`. In addition, the
    structure is designed to be easily validated using other tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'PEAR Channels: A Revolution in PHP Installation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The smallest addition to `package.xml 2.0` is the`<channel>` tag. Don''t be
    fooled though, channels are the most significant new feature implemented in the
    PEAR installer. Channels are to PEAR what dependencies are to team development.
    By opening up the ease of the PEAR installer to sites other than [pear.php.net](http://pear.php.net),
    a number of free choices have been made available to PHP users. For the first
    time, it is possible to design an application that depends upon packages from
    `pear.php.net`, `pear.example.com`, and any number of sites, and all of them can
    be automatically downloaded, installed, and easily upgraded on the end-user''s
    computer with a single command. Although [Chapter 5](ch05.html "Chapter 5. Releasing
    to the World: PEAR Channels") discusses the minutiae of channels and the `channel.xml`
    channel definition file, it is good to have a basic understanding of how channels
    work when designing your packages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two problems that channels effectively solve:'
  prefs: []
  type: TYPE_NORMAL
- en: Distributing application development across multiple development teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing conflicting packages from overwriting each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A user''s PEAR installer can have knowledge of a channel, in this example,
    [channelserver.example.com](http://channelserver.example.com) via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the user''s PEAR installer has this knowledge, packages from [channelserver.example.com](http://channelserver.example.com),
    like a hypothetical package named [Packagename](http://Packagename) can be simply
    installed with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Users can also install packages that depend on `channelserver.example.com/Packagename`.
    This was impossible before the advent of PEAR channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a user simply types the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'as they would with PEAR version 1.3.6 and older, the installer uses the `default_channel`
    configuration variable, which is usually `pear.php.net` or `pecl.php.net` (for
    the `pecl` command), and then acts as if the user had instead typed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, every existing PEAR package Foo has now become `pear.php.net/Foo`,
    effectively acting as a namespace differentiating it from `channelserver.example.com/Foo`.
    This is the mechanism that channels use to prevent conflicting packages from overwriting
    each other. Since `pear.php.net/Foo` is not the same package as `channelserver.example.com/Foo`,
    it is not possible to *upgrade* from `pear.php.net/Foo` to `channelserver.example.com/Foo`.
    For this reason, it is time for an important concept:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though *channel names* are *server names*, they also function as a classification
    naming scheme to differentiate packages from different sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this, we need to study some of the history behind channels. In
    the original draft proposal describing channels, the name of a channel (as used
    in both installation and dependencies) and the server used to access the channel
    were different. For instance, the [pear.php.net](http://pear.php.net) channel
    was originally named the PEAR channel, so that users would type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After a few development releases of PEAR, it became clear that this was a bad
    idea for several reasons, one of them being the fact that if you didn't know where
    to locate a channel, it simply couldn't be located. So, by the first alpha version
    of PEAR, 1.4.0a1, the name of the channel became the same as the server name.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**So Do We Always Have to Type pear.php.net/Package?**'
  prefs: []
  type: TYPE_NORMAL
- en: No, in fact the innovation that made it reasonable to use the server name as
    a channel's name was the idea of a channel alias. From the command line, we can
    type the following and PEAR would install [pear.php.net/Package](http://pear.php.net/Package).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, if we wish, we can change this alias to anything we want by using
    the `channel-alias` command as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, in `package.xml's <channel>` and other tags, the full channel server
    name always must be used, aliases are never allowed.
  prefs: []
  type: TYPE_NORMAL
- en: The switch to using the server name as the channel name has another desirable
    consequence. Originally, it was possible to change the server associated with
    the channel transparently. This is a bad idea on many levels! Firstly, this meant
    that a malicious coder could quite easily override the conflict protections in
    the PEAR channel simply by changing the server that the PEAR channel uses to get
    package information. Secondly, by supplying identically-named packages to the
    ones available at [pear.php.net](http://pear.php.net) with malevolent code hidden
    inside, it would even be possible to fool the user into using malicious code without
    their knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: By using the server name as the channel name, this is no longer possible without
    an old-fashioned hacking attack against the original channel server, something
    that is bound to be noticed pretty quickly.
  prefs: []
  type: TYPE_NORMAL
- en: In short, the strength of channels lies not just in their ease of use for the
    end user and flexibility for the developer, but in the extensive security considerations
    that have gone into their design. As evidenced by recent security flaws in major
    PHP packages such as XML_RPC and phpBB, one cannot be too careful. At PEAR, security
    is deadly serious, and the developers have gone to great lengths to ensure that
    PEAR is hack-proof.
  prefs: []
  type: TYPE_NORMAL
- en: Application Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have learned that the PEAR installer was designed to support libraries
    first, and then application support was added in PEAR version 1.4.0\. Let''s take
    a closer look at what that specifically means by examining four exciting new features:
    custom file roles, custom file tasks, post-installation scripts, and the ability
    to bundle several packages into a single archive.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore the details of these features by creating a
    new custom file role `chiaramdb2schema`, a custom file task `chiara-managedb`,
    a post-install script to populate needed data, and a sample application. We'll
    then distribute the role and task in a single archive.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we begin, you need to examine one vital point:'
  prefs: []
  type: TYPE_NORMAL
- en: What problem are you solving? Should you use a custom file role, custom file
    task, post-install script, or something else?
  prefs: []
  type: TYPE_NORMAL
- en: Custom file roles are designed to group related file classes together. If, for
    instance, you wish to install all web-based image files in a different way from
    web-based JavaScript files, custom file roles are the best way to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Custom file tasks are designed to manipulate the contents of individual files
    prior to installation or prior to packaging. If you need to convert a generic
    template into a machine-specific file (such as a generic database creation SQL
    file into a MySQL-specific or Oracle-specific SQL file), custom tasks are a very
    good choice.
  prefs: []
  type: TYPE_NORMAL
- en: Post-installation scripts are designed to allow any other advanced configuration
    that the user must perform before the package will be ready for use.
  prefs: []
  type: TYPE_NORMAL
- en: Our sample file role and task are designed for a single-user situation. On a
    shared host, this must be done with a post-installation script, and so we will
    provide one to allow systems administrators to maintain multiple database installs
    of a package.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Naming Conventions for Custom File Roles/Tasks**'
  prefs: []
  type: TYPE_NORMAL
- en: It is a very good idea to use a custom prefix for all functionality that extends
    the PEAR Installer. In our examples, if we were to name the role `sql` instead
    of `chiara_sql` and the task `updatedb` instead of `chiara_updatedb`, there is
    a risk of conflicting with an official custom role or task distributed from [pear.php.net](http://pear.php.net).
    In particular, should any role or task be deemed useful enough to be implemented
    as a default part of the PEAR installer, users of your custom role/task would
    be unable to upgrade their PEAR installations unless they uninstalled the role
    and every package that depends on it.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Custom File Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: File roles are used to group related files together to handle installation.
    The standard file roles are `php, data, doc, test, script, src`, and `ext`. Each
    of these roles is handled differently by the installer. A file specified by a
    tag such as this one in a package named `My_Package` will be installed in `My/Package/foo.php`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, the same tag with a role of `data` prompts the installer to act very
    differently. Instead of being installed in `My/Package/foo.php`, this file will
    be installed in `My_Package/foo.php`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `baseinstalldir` attribute is ignored by the `data, doc`, and `test` roles,
    which are instead installed into`<package name>/path/to/file` as defined by the
    relative path in `package.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, each role determines where to install files from a different `config`
    variable. The `role: configuration` variable mapping is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`php: php_dir`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data: data_dir`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doc: doc_dir`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test: test_dir`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`script: bin_dir`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ext: ext_dir`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src: <none>` (not installed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Generally speaking, configuration variables are the same as the file role with
    `_dir` appended, with the exception of `role="script"`, which is to be appended
    with `bin_dir`. In addition, note that files with `role="src"` are not actually
    installed. Instead, these files are extracted and then compiled to create extension
    binaries, and then discarded. Each of these roles has a set of characteristics
    that differentiate it from other roles:'
  prefs: []
  type: TYPE_NORMAL
- en: Some are valid for PHP packages, others for extension packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some are installed, others are not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installable roles have a configuration variable that determines where they should
    be installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some honor the `baseinstalldir` attribute, others don't
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some install into`<packagename>/path` and others don't
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some represent PHP scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some represent executable files (like scripts)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some represent PHP extension binaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These characteristics are all that is needed to define customized file roles.
    In fact, the existing file roles are defined using these traits and special objects.
    For instance, the code to define the PHP role is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For most roles, this is the only code that needs to be defined! In addition
    to this PHP code, however, an XML file should be installed that documents the
    properties of a role. The XML file for the PHP role is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The various tags are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<releasetypes>:` This tag works like an array, whose contents define which
    release types are allowed to contain this role. The list of possible release types
    is `php, extsrc, extbin`, or `bundle`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<installable>:` This Boolean value determines whether a role is installed
    to disk or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<locationconfig>:` For installable roles, this string value determines which
    configuration variable to use for installing the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<honorsbaseinstall>:` This Boolean value (represented as 1 or an empty tag)
    determines whether `baseinstalldir` is used in calculating the final installation
    location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<unusualbaseinstall>:` This Boolean value (represented as 1 or an empty tag)
    determines whether the package name is prepended to the installation path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<phpfile>:` This Boolean value (represented as 1 or an empty tag) determines
    whether a file is treated as a PHP file (analyzed at packaging time for valid
    PHP/class names/function names).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<executable>:` This Boolean value (represented as 1 or an empty tag) determines
    whether a file is installed with the executable attribute on UNIX-based systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<phpextension>:` This Boolean value (represented as 1 or an empty tag) determines
    whether the installer will display a helpful error message if overwriting an existing
    extension binary fails due to file locking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating PEAR_Installer_Role_Chiaramdb2schema Custom Role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, it is important to understand how this role is used in `package.xml`.
    In order to implement a custom role, `package.xml` validation should be able to
    tell a user where to download and install it, as dependency validation occurs
    only after the `package.xml` file has been validated from a basic structural standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As such, in addition to a package dependency `package.xml` should also contain
    the`<usesrole>` tag describing the name of a custom file role that is used, and
    the remote location of the package containing this role. For our example this
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This tag will prompt the installer to first check if the `pear.chiaraquartet.net/Role_Chiaramdb2schemaql`
    package is installed. If not, the installer will issue a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Why Use <usesrole>/<usestask> in Addition to a Dependency?**'
  prefs: []
  type: TYPE_NORMAL
- en: The PEAR installer cannot successfully configure roles or tasks once installation
    has begun. They must be installed and configured prior to any attempt to install
    a package that uses them. For this reason, installation of custom roles or tasks
    must be performed in a separate process from the packages that use them.
  prefs: []
  type: TYPE_NORMAL
- en: To use a custom role inside the`<file>` tag is no different from any regular
    role.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: All custom file roles are implemented in a single PHP file that is installed
    into the `PEAR/Installer/Role/` directory. So, for instance, the `data` role is
    located in `PEAR/Installer/Role/Data.php`. Unlike custom tasks, custom file roles
    cannot be in subdirectories, so prefixing should be done without underscores to
    match the PEAR naming conventions. In addition, every custom role must extend
    the `PEAR_Installer_Role_Common` class, which is found in `PEAR/Installer/Role/Common.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our custom file role uses the `data_dir` configuration variable to determine
    installation location, and so in terms of installation it acts exactly like the
    `data` role. However, it does a magical thing through this XML in the `Chiaramdb2schema.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: By defining the`<config_vars>` tag in this way, three entirely new configuration
    variables will be added to the PEAR configuration. They are manipulated in the
    same manner as any other configuration variable, and provide the information that
    will make our `chiaramdb2schema` role something special.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our role takes advantage of the fact that MDB2-based schema files are a special
    sub-class of data files by directly extending the `PEAR_Installer_Role_Data` class.
    Here is the complete source code for our example role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `Chiaramdb2schema.xml` file that accompanies this role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Now that we've seen how to implement a simple role, let's examine
    the range of possibility built into the design of custom file roles.
  prefs: []
  type: TYPE_NORMAL
- en: Full Range of Possible Custom File Roles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most custom file roles will only need to specify configuration variables and
    attributes as described in previous sections. However, sometimes this is not enough,
    and some unusual setup is required. The protected `setup()` method of the base
    class `PEAR_Installer_Role_Common` is provided specifically to allow file roles
    to perform any unusual setup functionality needed. The method signature is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters are pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PEAR_Installer $installer:` This allows any specialized installation tasks
    to be done through the public API of the `PEAR_Installer` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PEAR_PackageFile_v2 $pkg:` This allows retrieval of any information from the
    `package.xml` that may be useful to the custom role. Note that the `PEAR_PackageFile_v2`
    class''s public API is read-only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array $atts:` This is the file attribute as parsed from `package.xml`, in
    a format similar to the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`string $file:` This is the file name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the `setup()` method is called for every role just prior to any installation
    location calculations. In addition, the current `PEAR_Config` configuration object
    is available via the `$this->config` member.
  prefs: []
  type: TYPE_NORMAL
- en: Also important to explore is the manner in which custom file roles's configuration
    variables are defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The`<config_vars>` tag defines configuration variables. Each configuration
    variable is declared using a tag with its name. If you wish to create a simple
    configuration variable named `foo`, you would use this XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Legal configuration types are `string, directory, file, set`, and `password`.
    If you wish to limit possible input to specified values, you also need to define
    the set of valid values using the`<valid_set>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Take a look in the `PEAR/Config.php` file for examples of existing configuration
    variable groups. This variable is for informational purposes, and can be anything
    you wish it to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'The`<default>` tag, on the other hand, has a large range of possibilities.
    There are three kinds of values that can be accessed to set the default value
    of a configuration variable:'
  prefs: []
  type: TYPE_NORMAL
- en: Default values of existing configuration variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to retrieve the default value of the `php_dir` configuration variable,
    you would use this tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Only built-in configuration variables may be accessed for their default values.
    To access a PHP constant like the `PHP_OS` constant, use this tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that any constant defined in `PEAR/Common.php` or `PEAR/Config.php` will
    also be available for use as a default value. Finally, straight text may be used
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to combine several of these, simply use them in the desired sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to use multiple constants or multiple texts, append a number to
    the end of the tag name like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Introduction to Custom File Tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three custom file tasks bundled with PEAR and one script task (post-install
    scripts are discussed in the next section). The tasks are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<tasks:replace/>:` Performs a basic `str_replace` on installed or packaged
    files. Possible replacement values are information from `package.xml`, information
    from PEAR''s configuration such as the value of `php_dir`, or PHP constants like
    `PHP_OS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<tasks:windowseol/>:` This converts all line endings to Windows`"\r\n"` line
    endings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<tasks:unixeol/>:` This converts all line endings to UNIX`"\n"` line endings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will examine how these tasks are defined inside the PEAR
    code, and how to create your own custom file tasks.
  prefs: []
  type: TYPE_NORMAL
- en: File tasks are generally used to manipulate the contents of files prior to installation.
    However, this is only limited by your imagination. In our example, we will use
    a task to create and update a database's structure on upgrade using the `chiaramdb2schema`
    file role that we created earlier. This task is a very advanced task, performing
    sophisticated processing, and as such shows the versatility of such a system.
  prefs: []
  type: TYPE_NORMAL
- en: The only constraint on the XML content of custom tasks is that the task's namespace
    (normally `tasks)` must prefix each tag. Validation is controlled with the PHP
    code for each task. A custom file task must extend `PEAR_Task_Common`, and must
    reside in the `PEAR/Task/` subdirectory of PEAR. Unlike custom file roles, custom
    file tasks can support subdirectories directly by using underscores. In our example
    file task, `chiara-managedb`, the class name is `PEAR_Task_Chiara_Managedb`, and
    this is found in file `PEAR/Task/Chiara/Managedb.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three kinds of custom file tasks: single, **multiple, and script.
    Single tasks** perform their operations on a single file, and are executed just
    prior to installation of the file. Multiple tasks operate on every file containing
    the task, and are executed after installation is completed. Script tasks are executed
    after installation using the `run-scripts` command, and are covered in detail
    in the next section on post-installation scripts. In addition, the order in which
    tasks appear in a file tag is important. The following possible but illogical
    task ordering will result in occurrences of `@blah@` within `foo.php` being replaced
    with the contents of the `data_dir` configuration variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: However, the opposite ordering will result in occurrences of `@blah@` within
    `foo.php` being replaced with the contents of the`<version>` tag from `package.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, single tasks can be executed when packaging. In other words, some
    tasks do not depend on the state of the client machine in order to execute. An
    example is the `replace` task. The `package-info` replacement only depends on
    the contents of the `package.xml` file, which is known at the time of `pear package`.
    The time at which a task is executed is referred to as the install phase of the
    task. Currently recognized install phases are install and package. A custom task
    can control its install phase with the `$phase` property. There are three constants
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PEAR_TASK_INSTALL:` Installation phase'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PEAR_TASK_PACKAGE:` Packaging phase'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PEAR_TASK_PACKAGEANDINSTALL:` Both installation and packaging phase'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, for instance, the phase declaration for the `windowseol` task is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The actual installation phase is set by the constructor of `PEAR_Task_Common`,
    and can be accessed through the `$installphase` property. The only legal values
    are `PEAR_TASK_INSTALL` and `PEAR_TASK_PACKAGE`. This member is used, for instance,
    to determine which replacements should occur. For instance, if `$this->installphase`
    is `PEAR_TASK_PACKAGE`, then `pear-config` and `php-const` replacements are not
    performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the best introduction to custom file tasks is with some of the simpler
    tasks distributed in the PEAR package itself. The simplest tasks are the`<tasks:windowseol/>`
    and`<tasks:unixeol/>` tasks. These will process the contents of their file and
    convert line endings to Windows format, or to UNIX format. Here is the complete
    source code for the `windowseol` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the primary operation performed is in the `startSession()` method.
    For most tasks, this is sufficient. Next, let's create our own custom file task!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the PEAR_Task_Chiara_Managedb Custom Task
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step in creating our task is to determine the desired purpose of the
    task. In our case, we can sum up the desired purpose with a problem that needs
    to be solved.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: THE PROBLEM:Installing and updating a database used by the package is a tedious
    process that should be automated.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, we need a solution that can perform these tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a database from scratch on a fresh installation of the package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update an existing database structure to reflect any changes in a new version
    of the package upon upgrading the package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operate with a large variety of databases, and easily manage migration to a
    different database at a future date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operate on different databases for different packages, as controlled by the
    user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to satisfy these constraints, we will be taking advantage of the MDB2_Schema
    package, available at [http://pear.php.net/MDB2_Schema](http://pear.php.net/MDB2_Schema).
    This package provides a number of distinct advantages over any custom solution
    we could design from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: MDB2 supports a wide variety of database drivers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The XML schema format used to describe a database structure is database-independent,
    allowing users of any database MDB2 supports to use a package that uses this task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a wide user base and several active maintainers helping to ensure that
    the package performs as advertised.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MDB2_Schema::updateDatabase()` method is capable of performing a sophisticated
    update of a database by comparing two schema files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, we will rely upon a less-than-optimal solution to satisfy the
    need for different databases per package: we will use a required format for the
    configuration variables provided by the `chiaramdb2schema` role.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to determine whether the task needs a unique database for the package,
    we will add an optional attribute named `unique` to the XML. As such, the three
    legal possibilities for our task in `package.xml` will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**PEAR 1.5.0a1 or Newer Is Needed to Run this Task**'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, a serious bug in PEAR versions prior to 1.5.0a1 prevents proper
    usage of this task, so if you want to try it, make sure you have the latest version
    of PEAR installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, as we require the `chiaramdb2schema` role in order to be sure
    that our configuration variables are installed and ready to use, we will require
    that the task is contained with a file of role `chiaramdb2schema` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the XML validation method for our task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When running the task, we will use the value of the `unique` attribute to control
    the database DSN (Data Source Name) used to connect to the database. As such,
    here is our initialization method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So far, this is pretty simple, isn't it? The next step is to determine which
    database to use, and how to connect. To do this, we will be using a combination
    of the `chiaramdb2schema_driver` configuration variable, the `chiaramdb2schema_dsn`
    variable, and the `chiara_mdb2schema_password` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will define a method to construct the data source name (DSN)
    from these configuration variables. Before analyzing the source, let''s see it
    in all of its glory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'First, the configuration variables are retrieved using the `$config` member,
    which is set in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In order to make things simpler on the user's end, we will also attempt to retrieve
    configuration data for the package's channel, and then default to the [pear.php.net](http://pear.php.net)
    channel configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will split the `DSN` variable on its separator ";" and the `Passwords`
    variable on its separator ":". By iterating over the `DSN` variable, we can then
    insert the appropriate password for each DSN. For instance, for a DSN "user:pass@localhost/databasename",
    the DSN will be stored as "user@localhost/databasename", so we will need to insert
    ":pass" right before the "@". In addition, the first DSN is the default DSN to
    be used if a non-package-specific DSN is found, so there is a special case for
    this DSN (which is found via `$allDSN[0]`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will determine whether the package requires a specific database
    connection string for the package using `$this->_unique`, which as you recall,
    was set in the `init()` method. Package-specific DSNs are prefixed with the package
    name as in "Packagename::user:password@localhost/databasename" or with a specific
    file within a package like "Packagename#file::user:password@localhost/databasename",
    so we will search through the parsed DSNs until we either find one or fail.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after determining which DSN to use, we need to prepend the kind of
    database that should be connected to. For instance, this could be MySQL, MySQLi,
    OCI, Firebird, pgSQL, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you find your eyes glazing over, don't fear. What is important is to realize
    that at the end of the experience, the method will either return a `PEAR_Error`
    with a detailed error message, or a string like **"mysqli://user:pass@localhost/databasename"**.
  prefs: []
  type: TYPE_NORMAL
- en: The final portion of our custom task is the `startSession()` method, which actually
    performs the task, as this is a task of type single.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`MDB2_Schema::updateDatabase()` requires two schema files in order to upgrade
    a database. While upgrading the database, we will use the final installation destination
    `$dest` to determine whether we are replacing an existing schema file. If so,
    then this is passed to `updateDatabase()`. Otherwise, we will simply call `updateDatabase()`
    to create the new database structure.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that at this point, the contents of the file have *not* been written to
    disk yet, as the tasks are to operate on a file prior to installation. As such,
    we will write out the schema file to a temporary location created using the `System`
    class, which is bundled with the PEAR package.
  prefs: []
  type: TYPE_NORMAL
- en: The bulk of the task's work is performed by the `MDB2_Schema` class. After completing
    the task, the user's database is automatically configured on installation and
    upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: The Full Range of Possible Custom File Tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The methods that are available to a custom task are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`true|array validXml($pkg, $xml, &$config, $fileXml):` Validates task `XML`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void init($xml, $fileAttributes, $lastVersion):` Initializes a task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`true|PEAR_Error startSession($pkg, $contents, $dest):` Starts (and generally
    finishes) task handling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`true|PEAR_Error run($tasks):` For tasks of type "multiple" only, processes
    all tasks and performs the needed actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: validXml($pkg, $xml, &$config, $fileXml)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method is called for all three types of task during `package.xml` validation
    to validate the XML of a specific task. `$pkg` is a `PEAR_PackageFile_v2` object
    representing the `package.xml` containing the task. This is read-only, and should
    simply be used to retrieve information. `$xml` is the parsed contents of the file
    task, `$config` is a `PEAR_Config` object representing the current configuration,
    and `$fileXml` is the parsed contents of the file tag from `package.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple mapping of some sample task XML and the contents of the `$xml`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '| XML | Parsed Contents |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `<tasks:something/>` | `''''` |'
  prefs: []
  type: TYPE_TB
- en: '| `<tasks:something att="blah"/>` | `array(''attribs'' => array(''att'' =>
    ''blah''))` |'
  prefs: []
  type: TYPE_TB
- en: '| `<tasks:something>blah</tasks:something>` | `''blah''` |'
  prefs: []
  type: TYPE_TB
- en: '| `<tasks:something att="blah">blah2</tasks:something>` | `array(''attribs''
    => array(''att'' => ''blah''), ''_content'' => ''blah2'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `<tasks:something> <tasks:subtag>hi</tasks:subtag> </tasks:something>` |
    `array(''tasks:subtag'' => ''hi'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `<tasks:something> <tasks:subtag>hi</tasks:subtag> <tasks:subtag att="blah">again</tasks:subtag>
    </tasks:something>` | `array(''tasks:subtag'' => array(0 => ''hi'', 1 => array(''attribs''
    => array(''att'' => ''blah''), ''_content'' => ''again''))))` |'
  prefs: []
  type: TYPE_TB
- en: The `$fileXml` parameter will consist of an array of this format containing
    all of the attributes defined in the`<file>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Error should be returned as an array. The first index must be one of the following
    error codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PEAR_TASK_ERROR_NOATTRIBS:` The array should be returned as: `array(PEAR_TASK_ERROR_NOATTRIBS)`;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PEAR_TASK_ERROR_MISSING_ATTRIB:` The array should be returned as: `array(PEAR_TASK_ERROR_MISSING_ATTRIB,
    ''attributename'')`;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PEAR_TASK_ERROR_WRONG_ATTRIB_VALUE:` The array should be returned as: `array(PEAR_TASK_ERROR_WRONG_ATTRIB_VALUE,
    ''attributename'', ''actualvalue'', [''expectedvalue''|array(''expectedvalue1'',
    ''expectedvalue2'',...)])`;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PEAR_TASK_ERROR_INVALID:` The array should be returned as: `array(PEAR_TASK_ERROR_INVALID,
    ''unusual error message'')`;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: init($xml, $fileAttributes, $lastVersion)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `init()` method is called to initialize all non-script tasks, and can be
    used for any purpose. The three parameters are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mixed $xml:` An array representing the task''s XML from `package.xml`. This
    is the same format as the `$xml` parameter passed to `validXml()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array $fileAttributes:` An array representing the file attributes. This is
    in the same format as the `$fileXml` parameter to `validXml()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string|NULL $lastVersion:` The last installed version of the package if the
    package is being upgraded, or `NULL` if this package is being installed for the
    first time. This can be used for tasks that rely upon previously installed configuration
    to operate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any return value from `init()` is discarded.
  prefs: []
  type: TYPE_NORMAL
- en: startSession($pkg, $contents, $dest)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `startSession()` method is called to execute a task, and is called after
    the `init()` method. It is important to note that this method is expected to return
    the exact contents of the file, as it should be installed to disk. No modification
    of files on disk should be performed. If there is any error running the task,
    a `PEAR_Error` object should be returned with a clear error message describing
    the problem, and containing information on the file that contains the task.
  prefs: []
  type: TYPE_NORMAL
- en: If the task determines that this file should not be installed, returning `FALSE`
    will prompt the installer to skip installation of this file. Note that only the
    literal `FALSE` will cause skipping of installation; an empty string, the number
    0, and any other literal that can be used as a false condition will not affect
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: After successful performance of a task, the complete file contents *must* be
    returned. The return value is used to write out the file contents to disk. For
    instance, the `windowseol` task returns the value of `$contents` after converting
    all new lines into `\r\n`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters passed to `startSession()` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PEAR_PackageFile_v2 $pkg:` The packagefile object representing the complete
    `package.xml` containing this task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string $contents:` The complete contents of the file, which can be operated
    on and must be returned upon successful completion of the task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string $dest:` The full path of the final installation location of the file.
    This is for informational use only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: run($tasks)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This method is only called for tasks of type multiple. The `$tasks` parameter
    is an array of each of the multiple tasks in `package.xml`. For instance, if `package.xml`
    contains tasks of type multiple`<tasks:foo/>` and`<tasks:bar/>`, the `run()` method
    will be called for all `foo` tasks and the `$tasks` parameter will contain an
    array of each `foo` task. Then, the same procedure will be repeated for the `bar`
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The `run()` method is called after installation has been successfully completed,
    and as such, can manipulate the installed contents of a package.
  prefs: []
  type: TYPE_NORMAL
- en: Upon error, the `run()` method should return a `PEAR_Error` object with an error
    message containing detailed information on the cause of task failure. All other
    return values are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Post-Installation Scripts for Ultimate Customization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The third and final task type is post-installation scripts. These are the most
    powerful and customizable tasks, and can quite literally be used to perform any
    needed customization of an installation. The PEAR installer implements post-installation
    scripts by defining sets of questions to ask the user in the `package.xml` file,
    and by passing the answers a user gives to a special PHP file. Here is a simple
    set of questions and a post-install script to match:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the XML from `package.xml:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the post-installation script (contents of `rolesetup.php` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Post-installation scripts interact intimately with the different front ends
    that PEAR provides. There are many possibilities available to a script. In addition
    to using data provided by the user, a post-installation script can interactively
    modify prompts based on the user's previous answers, and can dynamically skip
    entire`<tasks:paramgroup>` sections. These capabilities allow significant customization
    of the actual script.
  prefs: []
  type: TYPE_NORMAL
- en: Components of a Post-Install Script
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every post-installation script must define two methods, `init()` and `run()`.
    The `init()` method should be defined somewhat like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the use of `$this->_ui = &PEAR_Frontend::singleton():` This line of code
    opens up a huge array of possibilities. In addition to exposing the entire public
    API available to display text, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Void outputData(string $text):` Displays information to the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string bold(string $text):` Takes the text and returns a bold-face-transformed
    version of that text, which can then be passed to `outputData()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: this makes available the `skipParamGroup(string $id)` method. The `$id` parameter
    should be the ID of a paramgroup yet to be executed (contents of a`<tasks:id>`
    tag from a`<tasks:paramgroup>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Modifying the prompt or default value of a parameter is accomplished through
    the creation of a method named `postProcessPrompts()`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `$prompts` parameter will be the parsed contents of a`<tasks:paramgroup>`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'For this `paramgroup` the `$prompts` variable would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `postProcessPrompts()` method should return the `$prompts` array with modifications
    only to the prompt and default fields. If anything else is modified, it will cause
    the post-install script to simply fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, after determining that the user is using the pgSQL driver, the
    return value from `postProcessPrompts()` could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, the entire prompt can be replaced. This could be a simple way
    to handle internationalization as well. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `run()` method should accept two kinds of parameters. In normal operation,
    the first parameter will be an array containing the user''s answers, and the second
    parameter will be the ID of the paramgroup. For this`<tasks:paramgroup>`, sample
    values might be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: And the ID would be (as you might imagine)`'databaseSetup'`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these features designed for success, sometimes, it is necessary
    to abort a post-installation script on error. In these cases, the `run()` method
    is also called with two parameters, but the second is`'_undoOnError'`, and the
    first is an array of completed paramgroup IDs in reverse order, to facilitate
    iteration for rolling back changes made by the post-install script.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**_undoOnError is the Error Header and not Another Paramgroup ID?**'
  prefs: []
  type: TYPE_NORMAL
- en: A Paramgroup ID cannot begin with an underscore, it may only contain alphanumeric
    characters. Hence, `_undoOnError` is the error header and not another paramgroup
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: Bundling Several Packages into a Single Archive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, it is a desired feature to bundle a package and its dependencies into
    a single installable archive. There are two ways of doing this. The simplest way
    is to use a `package.xml` file similar to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple `package.xml` can then be packaged into `PEAR_all-1.4.2.tgz`, and
    distributed as a single archive that users can use to upgrade all packages from
    a non-internet location via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The other way of distributing dependencies is a clever mixture of the old bundle-all-dependencies
    approach and the PEAR way of distributing dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Backwards Compatibility: Using package.xml 1.0 and 2.0'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important new features of PEAR version 1.4.0 and newer that
    comes with the advent of `package.xml 2.0` is the ability to make a package installable
    by older PEAR versions. The package command, invoked with the following historically
    takes a `package.xml` and spits out a GZIP-compressed tar (`.tgz`) file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If the package name is `Foo`, and the version is `1.0.0`, the `.tgz` file will
    be named `Foo-1.0.0.tgz`. New in version 1.4.0, if there is a second `package.xml`
    named `package2.xml`, the package command will attempt to include it in the archive.
    When PEAR downloads a package for installation, it first looks for a `package2.xml`
    file, which is always in version 2.0 format, and then falls back to `package.xml`.
    In this way, older versions of PEAR are supported, because they always look for
    `package.xml` first.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this to work, PEAR does a very strict comparison of the contents of the
    `package.xml` files. `package.xml` version 1.0 and `package.xml` version 2.0,
    must satisfy the following list of constraints to be considered equivalent, otherwise
    validation will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: Same package name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Same package summary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Same package description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Same package version (release version)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Same package stability (release stability/state)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Same license
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Same release notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Same maintainers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All files in `package.xml 1.0` must be present in `package.xml 2.0 <contents>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that because `package.xml 2.0` allows files to be present but ignored during
    installation using the`<ignore>` tag, `package.xml 2.0` can be used to provide
    an archive that is both PEAR-installable as well as unzip-and-go.
  prefs: []
  type: TYPE_NORMAL
- en: Why Support Old and Crusty package.xml 1.0?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a common debate in the PHP world. Why support backwards compatibility?
    These are old, buggy versions of PEAR, right? Yes, they are old and buggy versions
    and anyone using them is asking for trouble, but people may not find a compelling
    reason to upgrade their PEAR installer just so that they can use your package
    because what they have already "works for them". It is (or should be) your goal
    as a package distributor to make the process of upgrading as painless as possible.
    You should only drop `package.xml` version 1.0 support if you are in fact using
    new features of PEAR itself in the PHP code, or your package is a new one without
    an installed userbase.
  prefs: []
  type: TYPE_NORMAL
- en: PEAR development has progressed at a rapid pace, but the adoption of the new
    installer will not happen overnight. Large software projects like Linux distributions
    need time to evaluate the new features and make sure that everything works properly
    prior to adopting a new version. As PEAR developers, we must honor this need.
  prefs: []
  type: TYPE_NORMAL
- en: Once the installed userbase is no longer using the old and buggy versions of
    PEAR, upgrading the installer dependency is an option that should be taken up
    as soon as possible, for the sake of the users themselves. Having said this, PEAR
    users need to upgrade as soon as possible to avoid security holes discovered in
    older versions of the PEAR installer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Security Issues in PEAR 1.4.3 and Older**'
  prefs: []
  type: TYPE_NORMAL
- en: A few months before writing this chapter, two major security holes were discovered
    in PEAR. Basically, if you're using PEAR 1.4.3 or older, you need to upgrade as
    soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Details are available at: [http://pear.php.net/advisory-20051104.txt](http://pear.php.net/advisory-20051104.txt)
    and [http://pear.php.net/advisory-20060108.txt](http://pear.php.net/advisory-20060108.txt).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Case Study: The PEAR Package'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PEAR is a perfect example of a package that will always need to support `package.xml
    1.0`. We will always have users who are upgrading from an earlier version to the
    latest one and PEAR 1.3.6 and older simply doesn't know anything about `package.xml
    2.0`. If we don't make it possible to upgrade PEAR, there isn't much point in
    making the code available.
  prefs: []
  type: TYPE_NORMAL
- en: However, at the same time, the new dependency features and tasks of `package.xml
    2.0` are very important for the PEAR package, and so both `package.xml 1.0` and
    `package.xml 2.0` are needed. For instance, the `pear` command itself is a shell
    script on UNIX (with UNIX `\n` line endings) and a batch file on Windows (with
    Windows `\r\n` line endings). Before `package.xml 2.0`, it was necessary to add
    these scripts as binary files to CVS, so that the line endings are not replaced
    with the packager's system line endings. Now, through the use of the`<tasks:windowseol/>`
    and`<tasks:unixeol/>` tasks, this is no longer necessary, as the correct line
    endings are set at package time. In addition, because of incompatibilities between
    PEAR 1.4.0 and earlier versions of PEAR_Frontend_Web and the older PEAR_Frontend_Gtk
    (superseded by PEAR_Frontend_Gtk2), it is necessary to check for the presence
    of these versions, and to silently succeed if the versions are OK. `package.xml
    2.0` provides this functionality through the use of the`<conflicts/>` tag in a
    package dependency.
  prefs: []
  type: TYPE_NORMAL
- en: PEAR_PackageFileManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the commands `convert` and `pickle` can be used in limited situations
    to manage both a `package.xml` version 1.0 and version 2.0, these commands can
    also be dangerous. A far safer way to maintain two versions of `package.xml` from
    a single location is through the use of the PEAR package PEAR_PackageFileManager.
    This package provides a simple interface from which to import an existing `package.xml`
    file and update with current information, or to create a new `package.xml` file
    from scratch. In addition, it is very simple to take an existing `package.xml
    2.0`, no matter how complicated it is, and easily create an equivalent `package.xml
    1.0` with absolute control over the contents of each `package.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining PEAR_PackageFileManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PEAR_PackageFileManager can be easily obtained by using the PEAR installer.
    As of the writing of this book, version 1.6.0b1 is available. To install it, you
    must set the `preferred_state` configuration variable to `beta` via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Of course, it is always good practice to determine the latest version at [http://pear.php.net/package/PEAR_PackageFileManager](http://pear.php.net/package/PEAR_PackageFileManager)
    and to install that version.
  prefs: []
  type: TYPE_NORMAL
- en: PEAR_PackageFileManager Script and the package.xml Files it Generates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our sample `PEAR_PackageFileManager` script, we will be generating a `package.xml`
    for the `Chiara_Managedb` task. Before writing the `package.xml` script, let's
    make sure we understand the components we wish to have for our `package.xml`.
    In our case, we will have three files to package up, the `Managedb.php` file containing
    the actual code for the task, the `rw.php` file containing the read/writable `PEAR_Task_Chiara_Managedb_rw`
    class for adding the task to `package.xml` through the `PEAR_PackageFile_v2_rw`
    API, and `rolesetup.php`, the post-installation script for initializing the `chiaramdb2schema`
    configuration variables.
  prefs: []
  type: TYPE_NORMAL
- en: There are several important details to note before diving into the source. First
    of all, this script generates a `package.xml` file from scratch. Most scripts
    will not need this kind of detail when using the `importOptions()` method. In
    addition, it is important to note that the `PEAR_PackageFileManager2` class extends
    the `PEAR_PackageFile_v2_rw` class provided with PEAR itself. This allows use
    of utility methods such as
  prefs: []
  type: TYPE_NORMAL
- en: '`setPackage()` and others to tweak the contents of the `package.xml`. Let''s
    take a look at how to generate a somewhat complicated `package.xml 2.0` with a
    post-installation script.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `package.xml` it generates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How PEAR_PackageFileManager Makes a Hard Life Easy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Astute readers may have noticed that the `package.xml` generation script is
    quite extensive and long. The good news is that in many cases, this will be unnecessary.
    In fact, the initial generation of `package.xml` is generally not the most important
    feat accomplished by PEAR_PackageFileManager. Far more significant is the management
    of release data. Maintaining a `package.xml` file, and in many instances `package.xml`
    and `package2.xml` is a serious problem. Although the PEAR installer makes it
    a bit easier by doing a careful equivalency comparison between package files,
    this process is not perfect.
  prefs: []
  type: TYPE_NORMAL
- en: PEAR_PackageFileManager takes the same data and uses explicit logic to generate
    the metadata that is `package.xml` guaranteeing that equivalent `package.xml`
    files will be created. In addition, the centralization of data means that you
    need to modify only the script when updating release notes. In addition, it is
    impossible to generate an invalid `package.xml`, as PEAR's built-in `package.xml`
    validation is used to validate generated `package.xml` files — the same validation
    used on packaging and on installation.
  prefs: []
  type: TYPE_NORMAL
- en: Globbing Files for package.xml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The single most important function that PEAR_PackageFileManager performs is
    the creation of the file list. Our simple package only has a few files in it,
    but for large, complex packages like PhpDocumentor ( [http://pear.php.net/PhpDocumentor](http://pear.php.net/PhpDocumentor)),
    it becomes an increasingly difficult task to manage `package.xml`. PhpDocumentor
    not only has several hundred files in it, but they also tend to change dramatically
    from release to release because of the use of Smarty templates.
  prefs: []
  type: TYPE_NORMAL
- en: By turning off the `simpleoutput` option, it is possible to easily detect modified
    files and monitor this from release to release without having to rely upon external
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Why was PEAR_PackageFileManager Conceived?**'
  prefs: []
  type: TYPE_NORMAL
- en: Originally, PEAR_PackageFileManager was a single script for generating PhpDocumentor's
    `package.xml`. Over time, as more requests for the script came in, it improved
    and eventually it became clear that it should be a standalone project.
  prefs: []
  type: TYPE_NORMAL
- en: At first, PEAR_PackageFileManager simply globbed all of the files in the current
    file list, using an`'ignore'` option with shell wildcards to exclude files. For
    instance, we can ignore all files containing "test" in their name with this wildcard:`"*test*"`.
    In addition, entire directories and all contents including subdirectories can
    be ignored by appending a "/" to the pattern as in`"CVS/"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example highlights one of the problems with this approach: In
    a CVS-based package, there may be files that are not part of the project inside
    the package and would not be exported with the `cvs export` command. As such,
    PEAR_PackageFileManager has several file-globbing drivers, or file list generators.
    The choice of which file list generator driver to use is controlled by the`''filelistgenerator''`
    option in the `setOptions()/importOptions()` family of methods. The simplest is
    the `file` generator.'
  prefs: []
  type: TYPE_NORMAL
- en: Other drivers are`'cvs', 'svn'`, and`'perforce'`. Each of these drivers is identical
    to the`'file'` driver except that instead of simply globbing every file in a directory
    and all subdirectories, it limits the list of files to those in a local checkout
    of a remote revision source control repository. Concurrent Versioning System (CVS),
    Subversion, and Perforce are all revision source control repository systems. If
    you don't know what they are, it would be a good idea to investigate Subversion
    and CVS, as both are free, open-source solutions. Subversion is much more full-featured
    than CVS, and is newer, whereas CVS is a tried-and-true warhorse.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Changelog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PEAR_PackageFileManager automatically generates a changelog for the current
    release, by default from oldest to newest. There are a few options for controlling
    this. First, the`'changelogoldtonew'` option, if set to false, will re-order the
    changelog so that newer entries are closer to the top of the file. In addition,
    if a different set of notes is to be used for the changelog than the release notes,
    use the`'changelognotes'` option to control this.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing package.xml Version 1.0 and package.xml Version 2.0
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some cases, it might be necessary to generate an equivalent `package.xml`
    version 1.0\. For instance, we may wish to allow PEAR 1.3.x users to gracefully
    fail with a "requires PEAR 1.4.3 or newer" error message. Doing this with PEAR_PackageFileManager
    is a piece of cake. Change the `importOptions` line from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change the last few lines of the script to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The script will then output both `package.xml` and `package2.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Package for Installation with the PEAR Installer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final step in the process is creating a package. Once you have a `package.xml`
    file that has been generated, you can use it to create a file containing the contents
    of the package. To do this, you should use the `package` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This command should be executed from the directory containing the `package.xml`
    file. This will create a `.tgz` file like `Package-version.tgz` where `Package`
    is the package name, and `version` is the release version. If your package is
    named `Foo` and is version `1.2.3` the package command will create a file named
    `Foo-1.2.3.tgz`. This file can be installed with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Or can also be uploaded to a channel server for public release (discussed in
    [Chapter 5](ch05.html "Chapter 5. Releasing to the World: PEAR Channels")).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The package command can also be used to create an uncompressed `.tar` file
    with the `--uncompress` or `-Z` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, you may have renamed a package file. In this case, it is necessary
    to explicitly specify a `package.xml` to be used for packaging as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This is the actual command line used to create the PEAR package for release.
    Note that it does not matter which `package.xml` (version 1.0 or version 2.0)
    is passed in, the following command-line sequence is identical.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: However, if both `package.xml` are the same version, the packaging will fail.
    In addition, there is a strict comparison made between the two `package.xml` files.
    If there is even the slightest difference between the texts of the`<description>`
    tag,`<summary>` tag, or`<notes>` tag, validation will fail. In fact, every file
    within the `package.xml 1.0` must be contained with the `package.xml 2.0`. The
    number of maintainers and their roles must be identical.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are a few differences that are allowed. For instance, the dependencies
    of `package.xml 1.0` need not match those of `package.xml 2.0` whatsoever, due
    to the fact that `package.xml 2.0` simply represents a far greater set of possible
    dependencies than `package.xml 1.0`. In addition, the introduction of the`<ignore>`
    tag in `package.xml 2.0` makes it possible to distribute files that are ignored
    by the PEAR installer. In this way, an application that will run out-of-the-box
    can also be easily installed with PEAR by distributing files needed for the out-of-the-box
    run and asking the PEAR installer to ignore them. These files will not be present
    in the `package.xml 1.0` because PEAR 1.3.x did not have this capability.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage, we've explored the inner workings of the PEAR installer and of
    `package.xml` to the highest level — it is safe to say that you are now a `package.xml`
    expert.
  prefs: []
  type: TYPE_NORMAL
