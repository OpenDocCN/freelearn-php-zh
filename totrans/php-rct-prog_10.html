<html><head></head><body>
<div class="book" title="Chapter&#xA0;10.&#xA0;Using Advanced Operators and Techniques in RxPHP" id="22O7C1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. Using Advanced Operators and Techniques in RxPHP</h1></div></div></div><p class="calibre8">This is the last chapter dedicated to explaining new RxPHP operators. There are few topics that didn't fit into any of the preceding chapters, so we'll cover them now. A couple of times we'll revisit Observable multicasting from <a class="calibre1" title="Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension" href="part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d">
Chapter 8
</a>, <span class="strong"><em class="calibre18">Multicasting in RxPHP and PHP7 pthreads Extension</em></span>, in practical examples and also four new operators, <code class="literal">zip()</code>, <code class="literal">window()</code>, <code class="literal">materialize()</code>, and <code class="literal">dematerialize()</code>, which are more advanced techniques for modifying Observable chains.</p><p class="calibre8">In particular, in this chapter we'll cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="literal">zip()</code> and <code class="literal">window()</code> operators that work with higher-order Observables</li><li class="listitem">The <code class="literal">materialize()</code> and <code class="literal">dematerialize()</code> operators</li><li class="listitem">Error propagation in Observable chains and how to properly catch exceptions from user-defined callbacks</li><li class="listitem">Theory around creating hot/cold Observables and the difference in unsubscribing and completing Observable chains</li><li class="listitem">Creating anonymous operators</li><li class="listitem">Writing a recursive <code class="literal">DirectoryIteratorObservable</code> that emits all files in a directory and all its subdirectories</li><li class="listitem">Writing a variant of <code class="literal">DirectoryIteratorObservable</code> based on multicasting</li><li class="listitem">Writing an FTP client based on RxPHP</li><li class="listitem">Using RxPHP in blocking and synchronous applications</li></ul></div><p class="calibre8">We've seen so many RxPHP operators throughout this entire book. All of them worked with values in some way or another.</p><p class="calibre8">However, there are also operators that are, in principle, similar to those used by hot Observables or cold Observables when testing the RxPHP code that we saw in <a class="calibre1" title="Chapter 5. Testing RxPHP Code" href="part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d">
Chapter 5
</a>, <span class="strong"><em class="calibre18">Testing RxPHP Code</em></span>.</p></div>

<div class="book" title="Chapter&#xA0;10.&#xA0;Using Advanced Operators and Techniques in RxPHP" id="22O7C1-bd355a22cf10407cb10df27e65585b8d">
<div class="book" title="The zip() operator"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec62" class="calibre1"/>The zip() operator</h1></div></div></div><p class="calibre8">The <code class="literal">zip()</code> operator is similar to the <code class="literal">ForkJoinObservable</code> that we implemented ourselves in <a class="calibre1" title="Chapter 5. Testing RxPHP Code" href="part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d">Chapter 5</a>, <span class="strong"><em class="calibre18">Testing RxPHP Code</em></span>. The main difference is that it internally stores all emissions for each source Observable in a separate queue and then re-emits their values when all sources have a value at a specific index.</p><p class="calibre8">This will be understood better by looking at the following example:</p><pre class="programlisting">// zip_01.php 
$obs1 = Observable::range(1, 7); 
$obs2 = Observable::fromArray(['a', 'b']); 
$obs3 = Observable::range(42, 5); 
 
$obs1-&gt;zip([$obs2, $obs3]) 
  -&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">We have three source Observables where each of them emits a different number of items. Then the <code class="literal">zip()</code> operator emits an array of values only when all the sources have emissions at the same index. So we know that <code class="literal">DebugSubject</code> will receive only two items because the <code class="literal">$obs2</code> Observable emits only two items.</p><p class="calibre8">In other words, the <code class="literal">zip()</code> operator can't make the third emission because it doesn't have a third value for the second <code class="literal">$obs2</code> Observable.</p><p class="calibre8">The output from this example is as follows:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php zip_01.php</strong></span>
<span class="strong"><strong class="calibre17">07:26:16 [] onNext: [1,"a",42] (array)</strong></span>
<span class="strong"><strong class="calibre17">07:26:16 [] onNext: [2,"b",43] (array)</strong></span>
<span class="strong"><strong class="calibre17">07:26:16 [] onCompleted</strong></span>
</pre><p class="calibre8">Notice that it contains only the first two values for each source Observable.</p><p class="calibre8">We can have a look at another and more complicated example that simulates asynchronous emission from multiple source Observables:</p><pre class="programlisting">// zip_02.php 
$loop = new StreamSelectLoop(); 
$scheduler = new EventLoopScheduler($loop); 
 
$obs1 = Observable::interval(1000, $scheduler) 
  -&gt;map(function($i) { return chr(65 + $i); }); 
 
$obs2 = Observable::interval(500, $scheduler) 
  -&gt;map(function($i) { return $i + 42; }); 
 
Observable::interval(200, $scheduler) 
  -&gt;zip([$obs1, $obs2]) 
  -&gt;subscribe(new DebugSubject()); 
 
$loop-&gt;run(); 
</pre><p class="calibre8">Since each source Observable emits with a different interval, the <code class="literal">zip()</code> operator will have to emit according to the slowest one, which emits every 1000ms. Values for the rest of the Observables are then stacked internally in queues.</p><p class="calibre8">This example will print the following output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php zip_02.php</strong></span>
<span class="strong"><strong class="calibre17">08:48:47 [] onNext: [0,"A",42] (array)</strong></span>
<span class="strong"><strong class="calibre17">08:48:48 [] onNext: [1,"B",43] (array)</strong></span>
<span class="strong"><strong class="calibre17">08:48:49 [] onNext: [2,"C",44] (array)</strong></span>
<span class="strong"><strong class="calibre17">08:48:50 [] onNext: [3,"D",45] (array)</strong></span>
<span class="strong"><strong class="calibre17">...</strong></span>
</pre><p class="calibre8">Notice that we're actually not losing values. All values that weren't re-emitted yet are kept inside the <code class="literal">zip()</code> operator.</p></div></div>
<div class="book" title="The window() operator" id="23MNU1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec63" class="calibre1"/>The window() operator</h1></div></div></div><p class="calibre8">The <code class="literal">window()</code> operator belongs among the more advanced higher-order Observables. We've seen the <code class="literal">switchLatest()</code> operator in <a class="calibre1" title="Chapter 6. PHP Streams API and Higher-Order Observables" href="part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d">Chapter 6</a>, <span class="strong"><em class="calibre18">PHP Streams API and Higher-Order Observables</em></span>, and we know that it automatically subscribes to the latest Observable emitted from its source Observable.</p><p class="calibre8">The exact opposite is the <code class="literal">window()</code> operator that takes a so called "window boundary" Observable as an argument and splits the source emissions into separate Observables based on emission from the "window boundary" Observable.</p><p class="calibre8">An example will definitely make this more obvious:</p><pre class="programlisting">// window_01.php 
$source = Observable::range(1, 10)-&gt;publish(); 
$windowBoundary = $source-&gt;bufferWithCount(3); 
 
$source-&gt;window($windowBoundary) 
  -&gt;doOnNext(function() { 
    echo "emitting new window Observable\n"; 
  }) 
  -&gt;switchLatest() 
  -&gt;subscribe(new CallbackObserver(function($value) { 
    echo "$value\n"; 
  })); 
 
$source-&gt;connect(); 
</pre><p class="calibre8">We have a source Observable emitting 10 items in total. The <code class="literal">window()</code> operator splits them into chunks of three items because of the Observable in the <code class="literal">$windowBoundary</code> variable that we pass as an argument to <code class="literal">window()</code>. This means that we'll make four Observables in total where the first three emit three items (and then complete) and the last one just a single item (and then it completes as well).</p><p class="calibre8">To make this even more obvious, we added the <code class="literal">doOnNext()</code> operator to print a log every time we create a new Observable.</p><p class="calibre8">The <code class="literal">switchLatest()</code> operator is then used to always subscribe only to the latest Observable emitted by <code class="literal">window()</code>.</p><p class="calibre8">So in the console it'll look like we split the source into chunks of three items. In other words, we split the source into windows of three times:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php window_01.php</strong></span>
<span class="strong"><strong class="calibre17">emitting new window Observable</strong></span>
<span class="strong"><strong class="calibre17">1</strong></span>
<span class="strong"><strong class="calibre17">2</strong></span>
<span class="strong"><strong class="calibre17">3</strong></span>
<span class="strong"><strong class="calibre17">emitting new window Observable</strong></span>
<span class="strong"><strong class="calibre17">4</strong></span>
<span class="strong"><strong class="calibre17">5</strong></span>
<span class="strong"><strong class="calibre17">6</strong></span>
<span class="strong"><strong class="calibre17">emitting new window Observable</strong></span>
<span class="strong"><strong class="calibre17">7</strong></span>
<span class="strong"><strong class="calibre17">8</strong></span>
<span class="strong"><strong class="calibre17">9</strong></span>
<span class="strong"><strong class="calibre17">emitting new window Observable</strong></span>
<span class="strong"><strong class="calibre17">10</strong></span>
</pre><p class="calibre8">You're probably wondering what's this all good for. The <code class="literal">window()</code> operator, optionally takes a selector function. This function receives as an argument the current window before pushing it to its observers. For us this means that we can further chain operators to it before it's passed further, which can be very useful.</p><p class="calibre8">Imagine we're in a situation where we're receiving messages of many different types, but we want to be able to guarantee that we pass through only one message of each type every 100 messages.</p><p class="calibre8">We can simulate such a situation by creating a source Observable with 500 items where we repeat only three different characters. Then split it into windows with 100 items each and use the selector function to chain the new window Observables with the <code class="literal">distinct()</code> operator:</p><pre class="programlisting">// window_02.php 
$chars = []; 
for ($i = 0; $i &lt; 500; $i++) { 
  $chars[] = chr(rand(65, 67)); 
} 
echo 'Source length: ' . count($chars) . "\n"; 
 
$source = Observable::fromArray($chars)-&gt;publish(); 
$windowBoundary = $source-&gt;bufferWithCount(100); 
 
$source-&gt;window($windowBoundary, function($observable) { 
    return $observable-&gt;distinct(); 
  }) 
  -&gt;doOnNext(function() { 
    echo "emitting new window Observable\n"; 
  }) 
  -&gt;switchLatest() 
  -&gt;subscribe(new CallbackObserver(function($value) { 
    echo "$value\n"; 
  })); 
 
$source-&gt;connect(); 
</pre><p class="calibre8">Every Observable emitted by the <code class="literal">window()</code> operator has its own instance of the <code class="literal">distinct()</code> operator, so after every 100 items we start comparing distinct items all over again.</p><p class="calibre8">This example prints the following output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php window_02.php</strong></span>
<span class="strong"><strong class="calibre17">Source length: 500</strong></span>
<span class="strong"><strong class="calibre17">emitting new window Observable</strong></span>
<span class="strong"><strong class="calibre17">A</strong></span>
<span class="strong"><strong class="calibre17">C</strong></span>
<span class="strong"><strong class="calibre17">B</strong></span>
<span class="strong"><strong class="calibre17">emitting new window Observable</strong></span>
<span class="strong"><strong class="calibre17">C</strong></span>
<span class="strong"><strong class="calibre17">A</strong></span>
<span class="strong"><strong class="calibre17">B</strong></span>
<span class="strong"><strong class="calibre17">emitting new window Observable</strong></span>
<span class="strong"><strong class="calibre17">B</strong></span>
<span class="strong"><strong class="calibre17">C</strong></span>
<span class="strong"><strong class="calibre17">A</strong></span>
<span class="strong"><strong class="calibre17">emitting new window Observable</strong></span>
<span class="strong"><strong class="calibre17">C</strong></span>
<span class="strong"><strong class="calibre17">B</strong></span>
<span class="strong"><strong class="calibre17">A</strong></span>
<span class="strong"><strong class="calibre17">emitting new window Observable</strong></span>
<span class="strong"><strong class="calibre17">B</strong></span>
<span class="strong"><strong class="calibre17">C</strong></span>
<span class="strong"><strong class="calibre17">A</strong></span>
<span class="strong"><strong class="calibre17">emitting new window Observable</strong></span>
</pre><p class="calibre8">Note that the order of characters is always going to be different because the source is generated randomly.</p><p class="calibre8">We can see that even though each window contains 100 items, these are always filtered by the <code class="literal">distinct()</code> operator that we chained to the window Observable in the selector function.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note46" class="calibre1"/>Note</h3><p class="calibre8">The <code class="literal">window()</code> operator definitely falls into the group of more advanced and not so common operators in practice. In RxJS 5 there're even more variants of this operator for more specific use cases.</p></div></div>

<div class="book" title="The materialize() and dematerialize() operators" id="24L8G1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec64" class="calibre1"/>The materialize() and dematerialize() operators</h1></div></div></div><p class="calibre8">In <a class="calibre1" title="Chapter 5. Testing RxPHP Code" href="part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d">
Chapter 5
</a>, <span class="strong"><em class="calibre18">Testing RxPHP Code</em></span>, when we talked about testing in RxPHP, we weren't using real values, and instead were passing some special recorded objects that wrapped the actual value with <code class="literal">OnNextNotification</code> (or its <code class="literal">error</code> or <code class="literal">complete</code> variants). We did this because of the <code class="literal">TestScheduler</code> class and because we had to be able to uniquely identify each value in order to compare object references and not just their values. Comparing just values wouldn't guarantee that they are identical because primitive types such as strings or integers aren't passed by reference by default.</p><p class="calibre8">There are two operators that use a similar principle. These are <code class="literal">materialize()</code> and <code class="literal">dematerialize()</code>.</p><p class="calibre8">The first one takes each value, wraps it with a notification object, and re-emits it as a typical <code class="literal">onNext</code> signal. This includes <code class="literal">error</code> and <code class="literal">complete</code> signals as well. These are wrapped and re-emitted like any other value, and after that a complete signal is sent.</p><p class="calibre8">This means we can completely ignore error signals or handle them as regular values. Before we talk more about what we can do with all this, let's consider the following example where we'll see what the <code class="literal">materialize()</code> operator actually does:</p><pre class="programlisting">// materialize_01.php  
Observable::range(1, 3) 
    -&gt;materialize() 
    -&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">This is just a <code class="literal">RangeObservable</code> that emits three values and then sends complete signals. The <code class="literal">materialize()</code> operator converts each signal into an object, so this example will print the following output to the console:</p><pre class="programlisting">$ php materialize_01.php  
20:15:48 [] onNext: OnNext(1) (Rx\Notification\OnNextNotification) 
20:15:48 [] onNext: OnNext(2) (Rx\Notification\OnNextNotification) 
20:15:48 [] onNext: OnNext(3) (Rx\Notification\OnNextNotification) 
20:15:48 [] onNext: OnCompleted() (...\OnCompletedNotification) 
20:15:48 [] onCompleted 
</pre><p class="calibre8">We can see that <code class="literal">DebugSubject</code> received five signals in total. The first three are just numbers emitted by the source <code class="literal">RangeObservable</code>. Then follows the complete signal from the source, wrapped as well, and after that another complete signal, but this time emitted by the <code class="literal">materialize()</code> operator itself.</p><p class="calibre8">Now let's have a look at another example where we emit an error:</p><pre class="programlisting">// materialize_02.php 
Observable::create(function(\Rx\ObserverInterface $observer) { 
        $observer-&gt;onNext(1); 
        $observer-&gt;onNext(2); 
        $observer-&gt;onError(new \Exception("It's broken")); 
        $observer-&gt;onNext(4); 
    }) 
    -&gt;materialize() 
    -&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">This is very similar to the previous example, but this time we're forcing one error signal among normal emissions. As we said, the <code class="literal">materialize()</code> operator wraps the error and then calls <code class="literal">complete</code>.</p><p class="calibre8">When we run this example, we'll see that the wrapped value <code class="literal">4</code> never arrived to <code class="literal">DebugSubject</code> since it has already unsubscribed because of the <code class="literal">complete</code> signal:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php materialize_02.php </strong></span>
<span class="strong"><strong class="calibre17">20:25:59 [] onNext: OnNext(1) (Rx\Notification\OnNextNotification)</strong></span>
<span class="strong"><strong class="calibre17">20:25:59 [] onNext: OnNext(2) (Rx\Notification\OnNextNotification)</strong></span>
<span class="strong"><strong class="calibre17">20:25:59 [] onNext: OnError(Exception) (...\OnErrorNotification)</strong></span>
<span class="strong"><strong class="calibre17">20:25:59 [] onCompleted</strong></span>
</pre><p class="calibre8">So what's all this actually good for when we can't, in fact, skip either the <code class="literal">error</code> or the <code class="literal">complete</code> signals?</p><p class="calibre8">While <code class="literal">materialize()</code> wraps signals with a notification object, there's also the exact opposite operator called <code class="literal">dematerialize()</code>. And, of course, we can use these two operators independently of each other.</p></div>

<div class="book" title="The materialize() and dematerialize() operators" id="24L8G1-bd355a22cf10407cb10df27e65585b8d">
<div class="book" title="Customizing error bubbling with dematerialize()"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch10lvl2sec92" class="calibre1"/>Customizing error bubbling with dematerialize()</h2></div></div></div><p class="calibre8">Imagine that we have an Observable chain that needs to emit multiple errors, but it can't decide which of these are severe and need to be propagated further down the chain and which can be safely ignored. In a normal Observable chain, the first error would cause immediate unsubscription.</p><p class="calibre8">With clever usage of notification objects and the <code class="literal">dematerialize()</code> operator, we can let the error pop up when we want.</p><p class="calibre8">In the following example, we generate a series of nine numbers. Every third number is then converted into an error notification. The errors aren't important and can be safely ignored. But the sixth number is different, and when it appears we always want to signal an error.</p><p class="calibre8">Consider the following example that generates multiple error signals and wraps them with notifications:</p><pre class="programlisting">// materialize_03.php  
Observable::range(1, 9) 
  -&gt;materialize() 
  -&gt;map(function(Notification $notification) { 
    $val = null; 
    $notification-&gt;accept(function($next) use (&amp;$val) { 
      $val = $next; 
    }, function() {}, function() use (&amp;$val) { $val = -1; }); 
 
    if ($val % 3 == 0) { 
      $msg = "It's really broken"; 
      $e = $val==6 ? new LogicException($msg) : new Exception(); 
      return new OnErrorNotification($e); 
    } else { 
      return $notification; 
    } 
  }) 
  -&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">This example uses <code class="literal">materialize()</code> at the beginning to convert all values to notifications. Then, inside the <code class="literal">map()</code> operator, we unwrap all notifications with their <code class="literal">accept()</code> method that propagates their value to the appropriate callable (it's like calling <code class="literal">subscribe()</code> on an Observable). This way we can see its value and just return it as it is or eventually return <code class="literal">OnErrorNotification</code> instead.</p><p class="calibre8">When we run this example, we'll get the following output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php materialize_03.php </strong></span>
<span class="strong"><strong class="calibre17">21:05:42 [] onNext: OnNext(1) (Rx\Notification\OnNextNotification)</strong></span>
<span class="strong"><strong class="calibre17">21:05:42 [] onNext: OnNext(2) (Rx\Notification\OnNextNotification)</strong></span>
<span class="strong"><strong class="calibre17">21:05:42 [] onNext: OnError(Exception) (...\OnErrorNotification)</strong></span>
<span class="strong"><strong class="calibre17">21:05:42 [] onNext: OnNext(4) (Rx\Notification\OnNextNotification)</strong></span>
<span class="strong"><strong class="calibre17">21:05:42 [] onNext: OnNext(5) (Rx\Notification\OnNextNotification)</strong></span>
<span class="strong"><strong class="calibre17">21:05:42 [] onNext: OnError(LogicException) 
    (...\OnErrorNotification)</strong></span>
<span class="strong"><strong class="calibre17">21:05:42 [] onNext: OnNext(7) (Rx\Notification\OnNextNotification)</strong></span>
<span class="strong"><strong class="calibre17">21:05:42 [] onNext: OnNext(8) (Rx\Notification\OnNextNotification)</strong></span>
<span class="strong"><strong class="calibre17">21:05:42 [] onNext: OnError(Exception) (...\OnErrorNotification)</strong></span>
<span class="strong"><strong class="calibre17">21:05:42 [] onNext: OnCompleted() (...\OnCompletedNotification)</strong></span>
<span class="strong"><strong class="calibre17">21:05:42 [] onCompleted</strong></span>
</pre><p class="calibre8">This is what we wanted to get. None of the errors actually did anything, and they were all emitted as a normal <code class="literal">onNext</code> signal. Note that instead of number six we have a <code class="literal">LogicException</code>. Now the last thing is to filter out all errors that are unimportant for us. This means all errors except the single <code class="literal">LogicException</code>.</p><p class="calibre8">We'll prepend the <code class="literal">filter()</code> and <code class="literal">dematerialize()</code> operators before the <code class="literal">subscribe()</code> call. We have to use <code class="literal">dematerialize()</code> to turn notifications to their respective signals. So the preceding example will look like the following:</p><pre class="programlisting">// materialize_04.php 
// the preceding chain from materialize_03.php 
-&gt;filter(function(Notification $notification) { 
  if ($notification instanceof OnErrorNotification) { 
    $e2 = new OnErrorNotification(new LogicException()); 
    return (string)$notification == (string)$e2; 
  } else { 
    return true; 
  } 
}) 
-&gt;dematerialize() 
-&gt;subscribe(new DebugSubject()) 
</pre><p class="calibre8">If we rerun this finalized example, we'll get the following output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php materialize_04.php </strong></span>
<span class="strong"><strong class="calibre17">21:09:33 [] onNext: 1 (integer)</strong></span>
<span class="strong"><strong class="calibre17">21:09:33 [] onNext: 2 (integer)</strong></span>
<span class="strong"><strong class="calibre17">21:09:33 [] onNext: 4 (integer)</strong></span>
<span class="strong"><strong class="calibre17">21:09:33 [] onNext: 5 (integer)</strong></span>
<span class="strong"><strong class="calibre17">21:09:33 [] onError (LogicException): It's really broken</strong></span>
</pre><p class="calibre8">All the other errors were ignored by the <code class="literal">filter()</code> operator and the only one that was preserved and unwrapped with <code class="literal">dematerialize()</code> is the <code class="literal">LogicException</code>.</p><p class="calibre8">This method of handling errors is obviously a hack that we typically don't want to do, but it's good to know that even this is possible with RxPHP out of the box, without creating custom observers or Observables.</p></div></div>

<div class="book" title="Error handling in RxPHP operator chains" id="25JP21-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec65" class="calibre1"/>Error handling in RxPHP operator chains</h1></div></div></div><p class="calibre8">You may be wondering why we can't just emit multiple errors from an Observable and then use <code class="literal">materialize()</code> to wrap them.</p><p class="calibre8">Consider the following example with <code class="literal">Observable::create</code> that emits two errors:</p><pre class="programlisting">// materialize_05.php  
Observable::create(function($observer) { 
    $observer-&gt;onNext(1); 
    $observer-&gt;onNext(2); 
    $observer-&gt;onError(new Exception()); 
    $observer-&gt;onNext(4); 
    $observer-&gt;onError(new Exception()); 
    $observer-&gt;onNext(6); 
  }) 
  -&gt;materialize() 
  -&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">It might look like this example should wrap all the values and errors into notifications because we put the <code class="literal">materialize()</code> operator right after the <code class="literal">Observable::create</code>. Let's see what happens when we run this:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php materialize_05.php </strong></span>
<span class="strong"><strong class="calibre17">21:14:53 [] onNext: OnNext(1) (Rx\Notification\OnNextNotification)</strong></span>
<span class="strong"><strong class="calibre17">21:14:53 [] onNext: OnNext(2) (Rx\Notification\OnNextNotification)</strong></span>
<span class="strong"><strong class="calibre17">21:14:53 [] onNext: OnError(Exception) (...\OnErrorNotification)</strong></span>
<span class="strong"><strong class="calibre17">21:14:53 [] onCompleted</strong></span>
</pre><p class="calibre8">So why can we only see the emissions up to the first error even though we used <code class="literal">materialize()</code>?</p><p class="calibre8">Every time we use <code class="literal">lift()</code>, we're actually creating a new instance of <code class="literal">AnonymousObservable</code>. This Observable creates an instance of <code class="literal">AutoDetachObserver</code> internally on subscription, and after that, it calls its subscription callable. This <code class="literal">AutoDetachObserver</code> class automatically calls <code class="literal">dispose()</code> on its internal disposable object (which unsubscribes from the source) when it receives the <code class="literal">error</code> or <code class="literal">complete</code> signal.</p><p class="calibre8">Since almost all operators internally use <code class="literal">lift()</code>, they are also using <code class="literal">AutoDetachObserver</code>.</p><p class="calibre8">This includes <code class="literal">Observable::create()</code>, which is just a static method that creates a new <code class="literal">AnonymousObservable</code>.</p><p class="calibre8">So this is why an Observable can never emit more than one <code class="literal">error</code> or <code class="literal">complete</code> signal. They will always be ignored because the <code class="literal">AutoDetachObserver</code> class has already unsubscribed when it received the first one.</p></div>

<div class="book" title="Error handling in RxPHP operator chains" id="25JP21-bd355a22cf10407cb10df27e65585b8d">
<div class="book" title="The default error handler"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch10lvl2sec93" class="calibre1"/>The default error handler</h2></div></div></div><p class="calibre8">We know that each observer can take as an optional parameter an error handler that is called on error notification. Although the default behavior is different than we might expect. If we do specify the error callable, we can handle the error however we want to.</p><p class="calibre8">For example, consider the following example where we specify only the error handler:</p><pre class="programlisting">// error_01.php 
Observable::range(1, 5) 
  -&gt;filter(function($val) { 
    if ($val === 3) { 
      throw new \Exception("It's broken"); 
    } 
  }) 
  -&gt;subscribe(new CallbackObserver( 
    null, 
    function(\Exception $e){ 
      $msg = $e-&gt;getMessage(); 
      echo "Error: ${msg}\n"; 
    }) 
  ); 
</pre><p class="calibre8">When we run this example we'll see that the handler is called properly:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php error_01.php</strong></span>
<span class="strong"><strong class="calibre17">Error: It's broken</strong></span>
</pre><p class="calibre8">Now what happens if don't set any error handler at all? We can see this situation in the following example:</p><pre class="programlisting">// error_02.php 
Observable::range(1, 5) 
  -&gt;filter(function($val) { 
    if ($val === 3) { 
      throw new \Exception("It's broken"); 
    } 
  }) 
  -&gt;subscribe(new CallbackObserver()); 
</pre><p class="calibre8">We're using the <code class="literal">CallbackObserver</code> without any parameter, so the following output is what we'll get:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php error_02.php</strong></span>
<span class="strong"><strong class="calibre17">PHP Fatal error:  Uncaught Exception: It's broken in /.../Chapter 10/error_02.php:12</strong></span>
<span class="strong"><strong class="calibre17">Stack trace:</strong></span>
<span class="strong"><strong class="calibre17">#0 [internal function]: {closure}(3)</strong></span>
<span class="strong"><strong class="calibre17">#1 /.../reactivex/rxphp/lib/Rx/Operator/FilterOperator.php(40): call_user_func(Object(Closure), 3)</strong></span>
<span class="strong"><strong class="calibre17">#2 [internal function]: Rx\Operator\FilterOperator-&gt;Rx\Operator\{closure}(3)</strong></span>
<span class="strong"><strong class="calibre17">...</strong></span>
</pre><p class="calibre8">The exception was simply rethrown. We didn't set any error callable, so this is probably something we didn't expect to happen. It's good to be aware of this behavior because it means that if we don't handle error notifications they might cause unexpected script termination.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note47" class="calibre1"/>Note</h3><p class="calibre8">The default error handling is the same in RxJS 5; however, there's an ongoing discussion whether this is the correct way Rx should behave. It's likely that in the future versions of RxJS this behavior will change.</p></div></div></div>

<div class="book" title="Error handling in RxPHP operator chains" id="25JP21-bd355a22cf10407cb10df27e65585b8d">
<div class="book" title="Catching exceptions inside operators"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch10lvl2sec94" class="calibre1"/>Catching exceptions inside operators</h2></div></div></div><p class="calibre8">A similar principle applies also when calling any user defined functions inside an Observable or an operator. For example, when using the <code class="literal">map()</code> operator the callable is wrapped with a try-catch block. Any exception thrown inside our callable is then sent as an error notification.</p><p class="calibre8">This means that neither Observables nor operators are supposed to throw exceptions unless something unexpected occurs that shouldn't happen under normal circumstances. Throwing an exception inside a user defined callable is a valid use case.</p><p class="calibre8">We can test the difference on these two examples. First we'll throw an exception inside the selector function to the <code class="literal">zip()</code> operator from the same example we saw previously:</p><pre class="programlisting">// error_03.php 
$obs1 = Observable::range(1, 7); 
$obs2 = Observable::fromArray(['a', 'b']); 
$obs3 = Observable::range(42, 5); 
 
$obs1-&gt;zip([$obs2, $obs3], function($values) { 
    throw new \Exception("It's broken"); 
  }) 
  -&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">The exception will be caught and sent as an error notification:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php error_03.php</strong></span>
<span class="strong"><strong class="calibre17">09:41:05 [] onError (Exception): It's broken</strong></span>
</pre><p class="calibre8">In this example, we will see what happens when we try to use a regular object instead of a source Observable:</p><pre class="programlisting">// error_04.php 
$obs1 = Observable::range(1, 7); 
$obs2 = Observable::fromArray(['a', 'b']); 
$object = new stdClass(); 
 
$obs1-&gt;zip([$obs2, $object]) 
    -&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">Note that this type of error is catchable in PHP7:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php error_04.php</strong></span>
<span class="strong"><strong class="calibre17">PHP Fatal error:  Uncaught Error: Call to undefined method 
    stdClass::subscribe() in /.../lib/Rx/Operator/ZipOperator.php:110</strong></span>
<span class="strong"><strong class="calibre17">...</strong></span>
</pre><p class="calibre8">The exception was left to terminate the script execution because this is a situation that shouldn't happen. It probably means that we have a bug in our code where we unintentionally wanted to use an <code class="literal">stdClass</code> instance instead of an Observable.</p></div></div>

<div class="book" title="The Observable::create() method versus the Subject class" id="26I9K1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec66" class="calibre1"/>The Observable::create() method versus the Subject class</h1></div></div></div><p class="calibre8">Apart from creating custom Observables, we know that we can use the <code class="literal">Observable::create()</code> static method or an instance of the <code class="literal">Subject</code> class to emit items by ourselves, but so far we haven't talked about which one we should choose over the other and why.</p><p class="calibre8">As a rule of thumb it's usually better to use <code class="literal">Observable::create()</code>. It's not always possible, but it has its advantages.</p><p class="calibre8">For the next couple of examples, let's consider that we want to work with an API that implements the following interface. This could be any Facebook/Twitter/WebSocket or system API:</p><pre class="programlisting">interface RemoteAPI { 
    public function connect($connectionDetails); 
    public function fetch($path, $callback); 
    public function close(); 
} 
</pre></div>

<div class="book" title="The Observable::create() method versus the Subject class" id="26I9K1-bd355a22cf10407cb10df27e65585b8d">
<div class="book" title="Hot/cold Observables and Observable::create()"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch10lvl2sec95" class="calibre1"/>Hot/cold Observables and Observable::create()</h2></div></div></div><p class="calibre8">In the most general sense an Observable is just a function that connects an observer with the producer of values. By producer we understand any source of values that is unrelated to RxPHP. For example, this can be any class implementing our <code class="literal">RemoteAPI</code> interface.</p><p class="calibre8">We'll see that this works well with our definitions of hot/cold Observables from <a class="calibre1" title="Chapter 2. Reactive Programming with RxPHP" href="part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d">Chapter 2</a>, <span class="strong"><em class="calibre18">Reactive Programming with RxPHP</em></span>. A cold Observable creates its producer (in our case, connects to the remote API) on subscription. This means that we don't want to make any remote calls to the API until we have at least one observer.</p><p class="calibre8">So a cold Observable internally using the RemoteAPI interface could look like the following:</p><pre class="programlisting">// observable_create_01.php 
class RemoteServiceAPI implements RemoteAPI { 
  ... 
} 
 
Observable::create(function(ObserverInterface $observer) { 
  $producer = new RemoteServiceAPI(); 
  $producer-&gt;connect('...'); 
 
  $producer-&gt;fetch('whatever', function($result) use ($observer){ 
    $observer-&gt;onNext($result); 
  }); 
 
  return new CallbackDisposable(function() use ($producer) { 
    $producer-&gt;close(); 
  }); 
}); 
</pre><p class="calibre8">This fulfills our expectations from a cold Observable. The producer doesn't exist until we subscribe and it automatically also closes the connection when unsubscribing because we returned the <code class="literal">CallbackDisposable</code> instance from the callback to the <code class="literal">Observable::create()</code> method.</p><p class="calibre8">If we wanted to create a hot Observable with the <code class="literal">Observable::create()</code> method it would be similar, but this time the Observable is not responsible for neither creating nor closing the producer:</p><pre class="programlisting">// observable_create_02.php 
$producer = new RemoteServiceAPI(); 
$producer-&gt;connect('...'); 
 
Observable::create(function($observer) use ($producer) { 
  $producer-&gt;fetch('whatever', function($result) use ($observer){ 
    $observer-&gt;onNext($result); 
  }); 
}); 
 
// somewhere later... 
$producer-&gt;close(); 
</pre><p class="calibre8">The producer is created independently on the hot Observable and subscribing/unsubscribing to it has no effect on the producer.</p><p class="calibre8">You might be wondering how is this all related to comparing <code class="literal">Observable::create()</code> and the <code class="literal">Subject</code> class?</p><p class="calibre8">The point is that we can't simply do the same with Subjects. We could of course use a Subject in this scenario, but than we'd have to handle all subscription and unsubscription logic ourselves (including creating/closing the producer). Nonetheless, in <a class="calibre1" title="Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension" href="part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d">Chapter 8</a>, <span class="strong"><em class="calibre18">Multicasting in RxPHP and PHP7 pthreads Extension</em></span>, we talked about the internal states in Subjects, which is also very relevant here.</p><p class="calibre8">As a rule of thumb, every time you end up using a Subject think whether you could achieve the same with <code class="literal">Observable::create()</code> instead.</p></div></div>
<div class="book" title="Call stack length and EventLoopScheduler"><div class="book" id="27GQ62-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec67" class="calibre1"/>Call stack length and EventLoopScheduler</h1></div></div></div><p class="calibre8">When developing PHP applications, it's handy to enable the Xdebug extension that we can use to debug our code. However this comes with the cost of reduced performance, higher memory usage, and a limited number of possible nested function calls.</p><p class="calibre8">The last issue is relevant to us in particular. For example, in RxPHP when we make a long operator chain and use the <code class="literal">ImmediateScheduler</code> method. Consider the following very long chain of operators:</p><pre class="programlisting">// stack_length_01.php 
Observable::range(1, 10) 
  -&gt;doOnNext(function($val) { /* do whatever */ }) 
  -&gt;startWithArray([12, 15, 17]) 
  -&gt;skip(1) 
  -&gt;map(function($val) { 
    return $val * 2; 
  }) 
  -&gt;filter(function($val) { 
    return $val % 3 === 0; 
  }) 
  -&gt;doOnNext(function($val) { /* do whatever */ }) 
  -&gt;takeLast(3) 
  -&gt;sum() 
  -&gt;doOnNext(function($val) { /* do whatever */ }) 
  -&gt;subscribe(new CallbackObserver(function() { 
    $backtrace = debug_backtrace(); 
    $len = count($backtrace); 
 
    foreach ($backtrace as $item) { 
      $args = count($item['args']); 
      $func = $item['function']; 
      if (isset($item['file'])) { 
        $file = substr($item['file'], 
            strrpos($item['file'], '/') + 1); 
        echo "${file}#${item['line']} ${func} ${args} arg/s\n"; 
      } else { 
        echo "${func} ${args} arg/s\n"; 
      } 
    } 
    echo "============\n"; 
    echo "Stack length: ${len}\n"; 
  })); 
</pre><p class="calibre8">This example chains nine operators and then in the observer prints the entire call stack. We know that the call stack will start at the subscriber's <code class="literal">onNext</code> handler and traverse upwards via <code class="literal">onNext()</code> calls to the <code class="literal">RangeObservable</code> where it starts emitting values. Then the stack goes back to the bottom via <code class="literal">subscribe()</code> calls.</p><p class="calibre8">The shortened output looks as follows:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php stack_length_01.php </strong></span>
<span class="strong"><strong class="calibre17">{closure} 1 arg/s</strong></span>
<span class="strong"><strong class="calibre17">CallbackObserver.php#45 call_user_func_array 2 arg/s</strong></span>
<span class="strong"><strong class="calibre17">AbstractObserver.php#38 next 1 arg/s</strong></span>
<span class="strong"><strong class="calibre17">AutoDetachObserver.php#53 onNext 1 arg/s</strong></span>
<span class="strong"><strong class="calibre17">AbstractObserver.php#38 next 1 arg/s</strong></span>
<span class="strong"><strong class="calibre17">DoOnEachOperator.php#34 onNext 1 arg/s</strong></span>
<span class="strong"><strong class="calibre17">...</strong></span>
<span class="strong"><strong class="calibre17">DoOnEachOperator.php#51 onCompleted 0 arg/s</strong></span>
<span class="strong"><strong class="calibre17">Rx\Operator\{closure} 0 arg/s</strong></span>
<span class="strong"><strong class="calibre17">CallbackObserver.php#35 call_user_func 1 arg/s</strong></span>
<span class="strong"><strong class="calibre17">AbstractObserver.php#19 completed 0 arg/s</strong></span>
<span class="strong"><strong class="calibre17">RangeObservable.php#59 onCompleted 0 arg/s</strong></span>
<span class="strong"><strong class="calibre17">ImmediateScheduler.php#39 Rx\Observable\{closure} 1 arg/s</strong></span>
<span class="strong"><strong class="calibre17">...</strong></span>
<span class="strong"><strong class="calibre17">TakeLastOperator.php#55 subscribe 2 arg/s</strong></span>
<span class="strong"><strong class="calibre17">Observable.php#740 __invoke 3 arg/s</strong></span>
<span class="strong"><strong class="calibre17">AnonymousObservable.php#33 Rx\{closure} 2 arg/s</strong></span>
<span class="strong"><strong class="calibre17">ReduceOperator.php#73 subscribe 2 arg/s</strong></span>
<span class="strong"><strong class="calibre17">Observable.php#740 __invoke 3 arg/s</strong></span>
<span class="strong"><strong class="calibre17">AnonymousObservable.php#33 Rx\{closure} 2 arg/s</strong></span>
<span class="strong"><strong class="calibre17">DoOnEachOperator.php#55 subscribe 2 arg/s</strong></span>
<span class="strong"><strong class="calibre17">Observable.php#740 __invoke 3 arg/s</strong></span>
<span class="strong"><strong class="calibre17">AnonymousObservable.php#33 Rx\{closure} 2 arg/s</strong></span>
<span class="strong"><strong class="calibre17">stack_length_01.php#39 subscribe 1 arg/s</strong></span>
<span class="strong"><strong class="calibre17">============</strong></span>
<span class="strong"><strong class="calibre17">Stack length: 103</strong></span>
</pre><p class="calibre8">We can see that this call stack contains 103 nested function calls. This would be obviously hard to debug, so we can reduce its length by using <code class="literal">EventLoopScheduler</code> instead of <code class="literal">defaultImmediateScheduler</code>. This will make every callback to the <code class="literal">schedule()</code> method run as a separate event by <code class="literal">EventLoopScheduler</code>.</p><p class="calibre8">We'll set the Scheduler right in the <code class="literal">Observable::range()</code> call as follows:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">// stack_length_02.php</strong></span>
<span class="strong"><strong class="calibre17">$loop = new StreamSelectLoop();</strong></span>
<span class="strong"><strong class="calibre17">$scheduler = new EventLoopScheduler($loop);</strong></span>
<span class="strong"><strong class="calibre17">Observable::range(1, 10, $scheduler)</strong></span>
<span class="strong"><strong class="calibre17">  ...</strong></span>
<span class="strong"><strong class="calibre17">  -&gt;subscribe(new CallbackObserver(function() {</strong></span>
<span class="strong"><strong class="calibre17">    ...</strong></span>
<span class="strong"><strong class="calibre17">  }));</strong></span>
<span class="strong"><strong class="calibre17">$loop-&gt;run();</strong></span>
</pre><p class="calibre8">Now when we run this example the call stack will contain only 65 nested calls:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php stack_length_02.php </strong></span>
<span class="strong"><strong class="calibre17">{closure} 1 arg/s</strong></span>
<span class="strong"><strong class="calibre17">CallbackObserver.php#45 call_user_func_array 2 arg/s</strong></span>
<span class="strong"><strong class="calibre17">AbstractObserver.php#38 next 1 arg/s</strong></span>
<span class="strong"><strong class="calibre17">...</strong></span>
<span class="strong"><strong class="calibre17">Timers.php#90 call_user_func 2 arg/s</strong></span>
<span class="strong"><strong class="calibre17">StreamSelectLoop.php#177 tick 0 arg/s</strong></span>
<span class="strong"><strong class="calibre17">stack_length_02.php#45 run 0 arg/s</strong></span>
<span class="strong"><strong class="calibre17">============</strong></span>
<span class="strong"><strong class="calibre17">Stack length: 65</strong></span>
</pre><p class="calibre8">This obviously comes with a cost, so using the <code class="literal">EventLoopScheduler</code> class is always going to be slower than using the default <code class="literal">ImmediateScheduler</code>. Also the emissions that are wrapped with <code class="literal">schedule()</code> are called from the event loop and not from the place the <code class="literal">schedule()</code> method was invoked.</p><p class="calibre8">This can make debugging even harder, but the <code class="literal">EventLoopScheduler</code> class is especially useful when we don't want to block the execution thread and also want to let other code be executed (thanks to its event loop). In <a class="calibre1" title="Chapter 6. PHP Streams API and Higher-Order Observables" href="part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d">Chapter 6</a>, <span class="strong"><em class="calibre18">PHP Streams API and Higher-Order Observables</em></span>, we talked about even loops in great detail and how it's important not to block the execution thread. In such cases, using <code class="literal">EventLoopScheduler</code> is a very good choice.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note48" class="calibre1"/>Note</h3><p class="calibre8">Using an asynchronous Scheduler is also relevant to RxJS because in a JavaScript environment the call stack length is limited.</p></div></div>
<div class="book" title="Unsubscribing versus completing an Observable" id="28FAO1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec68" class="calibre1"/>Unsubscribing versus completing an Observable</h1></div></div></div><p class="calibre8">We know that when we have an observer we'll stop receiving items when the source Observable completes or when we manually unsubscribe. However, we haven't talked about why we might choose one over the other.</p><p class="calibre8">There're basically two ways to stop receiving items:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Unsubscribe from the source Observable</li><li class="listitem">Using an operator that completes the chain (such as the <code class="literal">takeUntil()</code> operator)</li></ul></div><p class="calibre8">By unsubscribing we usually mean that we don't want to be receiving items any more. This obviously doesn't mean that the source Observable stopped sending items or sent the complete notification. We're just no longer interested in the items coming from the source.</p><p class="calibre8">As an important consequence to manually unsubscribing, the complete handler is never called. Consider the following example where we unsubscribe after receiving a few items:</p><pre class="programlisting">// unsubscribe_01.php 
$loop = new StreamSelectLoop(); 
$scheduler = new EventLoopScheduler($loop); 
 
$subscription = Observable::range(1, 10, $scheduler) 
  -&gt;subscribe(new CallbackObserver( 
    function($val) use (&amp;$subscription) { 
      echo "$val\n"; 
      if ($val === 3) { 
        $subscription-&gt;dispose(); 
      } 
    }, 
    null, // no error handler 
    function() { 
      echo "completed!\n"; 
    }) 
  ); 
 
$loop-&gt;run(); 
</pre><p class="calibre8">Note that we had to use the <code class="literal">EventLoopScheduler</code> class instead of the default one because we need to run the observer callables as separate events in the loop. If we used the <code class="literal">ImmediateScheduler</code> class then the <code class="literal">$subscription</code> variable would always be null because all the callables would be called within the <code class="literal">subscribe()</code> call. In other words, the <code class="literal">$subscription</code> variable would be unassigned.</p><p class="calibre8">When we run this demo we can see that it prints the first three items and then ends and no complete handler was called:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php unsubscribe_01.php</strong></span>
<span class="strong"><strong class="calibre17">1</strong></span>
<span class="strong"><strong class="calibre17">2</strong></span>
<span class="strong"><strong class="calibre17">3</strong></span>
</pre><p class="calibre8">But what if we're in a situation where the complete handler is important and we always want to call it when we unsubscribe? In such cases we can use any operator that sends a complete notification, for example, <code class="literal">takeUntil()</code> and an instance of the <code class="literal">Subject</code> class:</p><pre class="programlisting">// unsubscribe_02.php 
$subject = new Subject(); 
 
$subscription = Observable::range(1, 10) 
  -&gt;takeUntil($subject) 
  -&gt;subscribe(new CallbackObserver( 
    function($val) use ($subject) { 
      echo "$val\n"; 
      if ($val === 3) { 
        $subject-&gt;onNext(null); 
      } 
    }, 
    null, // no error handler 
    function() { 
      echo "completed!\n"; 
    }) 
  ); 
</pre><p class="calibre8">We're using the <code class="literal">$subject</code> variable to notify the <code class="literal">takeUntil()</code> operator that we want to complete and then manually call the <code class="literal">onNext()</code> method inside a callable passed to the <code class="literal">CallbackObserver</code> class.</p><p class="calibre8">This way we ensured that apart from just unsubscribing the observer, we'll also call the complete handler, as we can see from the console output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php unsubscribe_02.php</strong></span>
<span class="strong"><strong class="calibre17">1</strong></span>
<span class="strong"><strong class="calibre17">2</strong></span>
<span class="strong"><strong class="calibre17">3</strong></span>
<span class="strong"><strong class="calibre17">completed!</strong></span>
</pre><p class="calibre8">Whether we want to simply unsubscribe or send the complete notification is up to us. A big advantage of using a <code class="literal">Subject</code> class and the <code class="literal">takeUntil()</code> operator is that we can easily complete multiple chains by using a single <code class="literal">onNext()</code> call.</p><p class="calibre8">If we wanted to just unsubscribe multiple chains, then we'd have to collect and keep all their disposables and then call <code class="literal">dispose()</code> on all of them manually.</p></div>
<div class="book" title="Anonymous operators" id="29DRA1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec69" class="calibre1"/>Anonymous operators</h1></div></div></div><p class="calibre8">We've been using the <code class="literal">lift()</code> method to use custom operators in Observable chains a lot. In RxPHP v1, it's also the only way to implement custom operators. This method takes as a parameter the so called <span class="strong"><strong class="calibre17">operator factory</strong></span>, which is a callable that returns an instance of the operator we want to use. This method is called every time we subscribe, so it might be called just once in total.</p><p class="calibre8">When using operators, we're making use of PHP's magic <code class="literal">__invoke()</code> method that allows us to use any object just as if it were a function.</p><p class="calibre8">Let's consider this simple example that shows the <code class="literal">__invoke()</code> method:</p><pre class="programlisting">// func_01.php 
class MyClass { 
    public function __invoke($a, $b) { 
        return $a * $b; 
    } 
} 
$obj = new MyClass(); 
var_dump($obj(3, 4)); 
</pre><p class="calibre8">We make an instance of <code class="literal">MyClass</code> that we used as if it was a regular function with <code class="literal">$obj(3,4)</code>. If we run this example, we'll get the correct result:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php func_01.php </strong></span>
<span class="strong"><strong class="calibre17">int(12)</strong></span>
</pre><p class="calibre8">Operators in RxPHP use the same principle. In fact the <code class="literal">lift()</code> method is deep inside the <code class="literal">Observable</code> class, defined as the following:</p><pre class="programlisting">public function lift(callable $operatorFactory) { 
  return new AnonymousObservable( 
      function($observer, $schedule) use ($operatorFactory) { 
 
    $operator = $operatorFactory(); 
    return $operator($this, $observer, $schedule); 
  }); 
} 
</pre><p class="calibre8">The callable <code class="literal">$operatorFactory</code> doesn't need to return an operator object at all. It can just return another callable that'll take three arguments and do whatever it wants to. This is useful when we want to do a one-time operation where it doesn't make sense to make it reusable and write a custom operator for it.</p><p class="calibre8">For example, we can make the same operations on the source Observable and the observer just like in any other operator class:</p><pre class="programlisting">// anonymous_02.php 
Observable::range(1, 5) 
  -&gt;map(function($val) { 
    return $val * 2; 
  }) 
  -&gt;lift(function() { 
    return function($observable, $observer, $scheduler) { 
      $prevValue = 0; 
      $onNext = function($value) use ($observer, &amp;$prevValue) { 
        $observer-&gt;onNext($value * $prevValue); 
        $prevValue = $value; 
      }; 
      $innerObs = new CallbackObserver( 
        $onNext, 
        [$observer, 'onError'], 
        [$observer, 'onCompleted'] 
      ); 
 
      return $observable-&gt;subscribe($innerObs); 
    }; 
  }) 
  -&gt;subscribe(new DebugSubject()); 
</pre><p class="calibre8">Note that we have a <code class="literal">$prevValue</code> variable that is kept in this context, and we can use it among all invocations of the <code class="literal">onNext</code> signals.</p></div>

<div class="book" title="Writing a custom DirectoryIteratorObservable" id="2ACBS1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec70" class="calibre1"/>Writing a custom DirectoryIteratorObservable</h1></div></div></div><p class="calibre8">In the previous chapter, we used a couple of <code class="literal">DirectoryIterators</code> to recursively get all files in a directory and all its subdirectories. When iterating files, we might want to filter not only by filenames, but also by file size or access restrictions. Ideally, we could have a custom Observable that just checks the files names to match a certain pattern and then emits <code class="literal">SplFileInfo</code> objects so we can implement our filtering logic ourselves.</p><p class="calibre8">For this purpose, we'll write our own <code class="literal">DirectoryIteratorObservable</code> that does all this and has some extra options on top of that. We can split the implementation into two smaller chunks:</p><pre class="programlisting">// DirectoryIteratorObservable.php 
class DirectoryIteratorObservable extends Observable { 
  private $iter; 
  private $scheduler; 
  private $selector; 
  private $pattern; 
 
  public function __construct($dir, $pattern = null, 
      $selector = null, $recursive = true, $scheduler = null) { 
 
    $this-&gt;scheduler = $scheduler; 
    $this-&gt;pattern = $pattern; 
    if ($recursive) { 
      $dirIter = new RecursiveDirectoryIterator($dir); 
      $iter = new RecursiveIteratorIterator($dirIter); 
    } else { 
      $iter = new DirectoryIterator($dir); 
    } 
    $this-&gt;iter = $iter; 
 
    if ($selector) { 
         $this-&gt;selector = $selector; 
    } else { 
      $this-&gt;selector = function(SplFileInfo $file) { 
        return $file; 
      }; 
    } 
  } 
  // ... 
} 
</pre><p class="calibre8">We're still using <code class="literal">RecursiveIteratorIterator</code> internally; however, we have full control over it and won't let other developers fiddle with it. Somebody could, for instance, use <code class="literal">rewind()</code> or <code class="literal">seek()</code> methods and unintentionally move the inner pointer, not to mention that using three different iterators to traverse a directory structure is a little too much and not easily reusable.</p><p class="calibre8">That's why our Observable hides all this from the user and has just a couple of input parameters. We definitely want to be able to set a pattern to filter files right away. Sometimes we might want to traverse several directories recursively and other times just a single directory, so we'll have a separate parameter for this. The last behavior we want to be able to modify is what this operator is going to emit. By default, it's the <code class="literal">SplFileInfo</code> object, but if we set a custom selector function we can emit, for example, just the file names.</p><p class="calibre8">The main logic is in the <code class="literal">subscribe()</code> method, which is built around a <code class="literal">scheduleRecursive()</code> method from the <code class="literal">Scheduler</code> class:</p><pre class="programlisting">// DirectoryIteratorObservable.php 
class DirectoryIteratorObservable extends Observable { 
  // ... 
  public function subscribe($observer, $scheduler = null) { 
    if ($this-&gt;scheduler !== null) { 
      $scheduler = $this-&gt;scheduler; 
    } 
    if ($scheduler === null) { 
      $scheduler = new ImmediateScheduler(); 
    } 
    $this-&gt;iter-&gt;rewind(); 
 
    return $scheduler-&gt;scheduleRecursive( 
        function($reschedule) use ($observer) { 
      /** @var SplFileInfo $current */ 
      $current = $this-&gt;iter-&gt;current(); 
      $this-&gt;iter-&gt;next(); 
      if (!$this-&gt;pattern || preg_match($this-&gt;pattern,$current)){  
        try { 
          $processed = call_user_func($this-&gt;selector, $current); 
          $observer-&gt;onNext($processed); 
        } catch (\Exception $e) { 
          $observer-&gt;onError($e); 
        } 
      } 
 
      if ($this-&gt;iter-&gt;valid()) { 
        $reschedule(); 
      } else { 
        $observer-&gt;onCompleted(); 
      } 
    }); 
  } 
} 
</pre><div class="informaltable" title="Note"><h3 class="title1"><a id="note49" class="calibre1"/>Note</h3><p class="calibre8">Note that in RxPHP v2 the <code class="literal">subscribe()</code> method doesn't take the <code class="literal">Scheduler</code> as a parameter. This means that we'd access the <code class="literal">Scheduler</code> class directly with the <code class="literal">Scheduler::getImmediate()</code> static method instead.</p></div><p class="calibre8">We're looping over all values produced by the iterator and emitting them until we reach the end, where we emit just the complete signal. Note that we're wrapping the call to the selector function, so if it throws an exception we'll emit it as an <code class="literal">error</code> signal.</p><p class="calibre8">We can test this Observable on the same directory structure from the Symfony3 template, as we did in the previous chapter:</p><pre class="programlisting">// directory_iterator_01.php 
$dir = __DIR__ . '/../symfony_template'; 
(new DirectoryIteratorObservable($dir, '/.+\.php$/')) 
  -&gt;subscribeCallback(function(SplFileInfo $file) { 
    echo "$file\n"; 
  }); 
</pre><p class="calibre8">This will print a very long list of file names (when <code class="literal">SplFileInfo</code> objects are type-casted to strings they return only filenames).</p><p class="calibre8">Note that, internally, this Observable works similarly to, for example, <code class="literal">RangeObservable</code>. In fact, it doesn't keep an array of observers and instead immediately emits all values to the observer that subscribed (we also move the iterator's inner pointer to the start with <code class="literal">rewind()</code>). The consequences are obvious.</p><p class="calibre8">If we subscribe twice to this Observable, it'll loop the entire iterable twice as well.</p></div>

<div class="book" title="Writing a custom DirectoryIteratorObservable" id="2ACBS1-bd355a22cf10407cb10df27e65585b8d">
<div class="book" title="DirectoryIteratorSharedObservable"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch10lvl2sec96" class="calibre1"/>DirectoryIteratorSharedObservable</h2></div></div></div><p class="calibre8">So this looks like a good use-case for multicasting. Of course, we could append the <code class="literal">publish()</code> operator every time we use <code class="literal">DirectoryIteratorObservable</code>, but this would be error prone as we could easily forget to use it. Instead, we can make another Observable that wraps <code class="literal">DirectoryIteratorObservable</code>, and appends the <code class="literal">publish()</code> operator to it every time:</p><pre class="programlisting">// DirectoryIteratorSharedObservable.php 
class DirectoryIteratorSharedObservable extends Observable { 
    private $inner; 
    public function __construct() { 
        $args = func_get_args(); 
        // PHP7 array unpacking with "..." 
        $this-&gt;inner = (new DirectoryIteratorObservable(...$args)) 
            -&gt;publish(); 
    } 
    public function subscribe($observer, $scheduler = null) { 
        $this-&gt;inner-&gt;subscribe($observer, $scheduler); 
    } 
    public function connect() { 
        return $this-&gt;inner-&gt;connect(); 
    } 
    public function refCount() { 
        return $this-&gt;inner-&gt;refCount(); 
    } 
} 
</pre><p class="calibre8">This Observable is just a wrapper around the original <code class="literal">DirectoryIteratorObservable</code>, which is internally instantiated and then chained with <code class="literal">publish()</code>. We're purposely using <code class="literal">publish()</code> and not <code class="literal">share()</code>. The <code class="literal">share()</code>operator also appends the <code class="literal">refCount()</code> operator, which automatically subscribes/unsubscribes based on the number of observers.</p><p class="calibre8">This is useful with Observables that need to perform some asynchronous operation, such as downloading data (our <code class="literal">CURLObservable</code>) or running code in parallel (our <code class="literal">ThreadPoolOperator</code>). With Observables that emit all their values immediately on subscription, such as <code class="literal">RangeObservable</code> or our fresh <code class="literal">DirectoryIteratorObservable</code>, it wouldn't work as we expect. All values would be emitted to the first observer because of the immediate call to the <code class="literal">connect()</code> method inside the <code class="literal">refCount()</code> operator.</p><p class="calibre8">Now we can test this operator by subscribing multiple observers and then calling the <code class="literal">connect()</code> method:</p><pre class="programlisting">// directory_iterator_shared_01.php 
$src = new DirectoryIteratorSharedObservable('.', '/.+\.php$/'); 
$src-&gt;subscribe(new DebugSubject('1')); 
$src-&gt;subscribe(new DebugSubject('2')); 
$src-&gt;subscribe(new DebugSubject('3')); 
$src-&gt;connect(); 
</pre><p class="calibre8">The output for this demo will be a list of file names where each of the observers will receive a single item at a time from the current directory:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php7 directory_iterator_shared_01.php </strong></span>
<span class="strong"><strong class="calibre17">09:52:55 [1] onNext: ./materialize_01.php (SplFileInfo)</strong></span>
<span class="strong"><strong class="calibre17">09:52:55 [2] onNext: ./materialize_01.php (SplFileInfo)</strong></span>
<span class="strong"><strong class="calibre17">09:52:55 [3] onNext: ./materialize_01.php (SplFileInfo)</strong></span>
<span class="strong"><strong class="calibre17">09:52:55 [1] onNext: ./materialize_02.php (SplFileInfo)</strong></span>
<span class="strong"><strong class="calibre17">09:52:55 [2] onNext: ./materialize_02.php (SplFileInfo)</strong></span>
<span class="strong"><strong class="calibre17">09:52:55 [3] onNext: ./materialize_02.php (SplFileInfo)</strong></span>
<span class="strong"><strong class="calibre17">...</strong></span>
</pre><p class="calibre8">We avoided reemitting the same directory structure for each observer and multicasted items from the source with the <code class="literal">public()</code> operator and manually called the 
<code class="literal">
connect()
</code>
 method.</p></div></div>
<div class="book" title="FTP client with RxPHP"><div class="book" id="2BASE2-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec71" class="calibre1"/>FTP client with RxPHP</h1></div></div></div><p class="calibre8">For this example, let's imagine that we're running an FTP server where we want to perform a couple of operations. PHP has built-in support for FTP connections, so we don't need to install any extra libraries.</p><p class="calibre8">Our goal is to be able to do some basic operations with an FTP connection while utilizing what we know from RxPHP. When working with Observables, most of the time we've been using them in operator chains, but Observables can be used as asynchronous inputs or outputs as well. When returning a value from an asynchronous function, we'd usually use a Promise, but the same principles work with Observables too, and we can also benefit from chaining them.</p><p class="calibre8">Note that all FTP calls in PHP are blocking. Some functions have their non-blocking variants, such as functions to upload or download files, but others, such as functions that change or list a directory, are always blocking. For this reason, we'll stay only with their blocking variants. This way we can handle their correct and error states with Observables. This is also going to be a nice example where we can use multicasting.</p><p class="calibre8">So this is going to be an example of how to use RxPHP in a synchronous and blocking application.</p><p class="calibre8">We'll split our first <code class="literal">FTPClient</code> class into two smaller chunks and see how we can implement RxPHP in this use-case:</p><pre class="programlisting">// FTPClient.php 
class FTPClient { 
  private $conn; 
  private $cwd = '/'; 
 
  public function __construct($host, $username, $pass, $port=21) { 
    $this-&gt;conn = ftp_connect($host, $port); 
    if (!$this-&gt;conn) { 
      throw new \Exception('Unable to connect to ' . $host); 
    } 
    if (!ftp_login($this-&gt;conn, $username, $pass)) { 
      throw new \Exception('Unable to login'); 
    } 
  } 
 
  public function chdir($dir) { 
    $this-&gt;cwd = '/' . $dir; 
    if (!ftp_chdir($this-&gt;conn, $dir)) { 
      throw new \Exception('Unable to change current directory'); 
    } 
  } 
 
  public function listDir() { 
    return Observable::defer(function() { 
      $files = ftp_nlist($this-&gt;conn, $this-&gt;cwd); 
      return Observable::fromArray($files) 
        -&gt;shareReplay(PHP_INT_MAX); 
    }); 
  } 
 
  public function close() { 
    ftp_close($this-&gt;conn); 
  } 
  // ... 
} 
</pre><p class="calibre8">These are the most basic methods we need. Many FTP functions in PHP return just true or false based on whether they succeeded or not. We used this in the constructor to throw exceptions if any of these cases fail.</p><p class="calibre8">Then there's the first method that returns an Observable. When we want to get a list of all the files and directories in a directory, we'll call the <code class="literal">listFiles()</code> method. This method returns an Observable from the array of files it received. As we said, FTP functions in PHP are blocking, so we're not calling <code class="literal">ftp_nlist()</code> asynchronously and need to wait until it finishes. The fact that we're returning an Observable means that we can feed this Observable into another method in this <code class="literal">FTPClient</code> class that takes an Observable as an argument.</p><p class="calibre8">We're purposely using <code class="literal">Observable::defer</code> in order to postpone the actual network request until we subscribe to it. We'll see why this is important when we start writing a test application for <code class="literal">FTPClient</code>.</p><p class="calibre8">We can now have a look at three more methods that'll get the file size, download files from the FTP server, or upload files to the server:</p><pre class="programlisting">class FTPClient { 
  // ... 
  public function size(Observable $files) { 
    return Observable::create(function($obs) use ($files) { 
      $files-&gt;subscribeCallback(function($filename) use ($obs) { 
        $size = ftp_size($this-&gt;conn, $filename); 
        $obs-&gt;onNext(['filename' =&gt; $filename, 'size' =&gt; $size]); 
      }); 
    }); 
  } 
 
  public function upload(Observable $files, $m = FTP_ASCII) { 
    $subject = new Subject(); 
    $files-&gt;subscribeCallback(function($file) use ($subject, $m) { 
      $fp = fopen($file, 'r'); 
      $filename = basename($file); 
 
      if (ftp_fput($this-&gt;conn, $filename, $fp, $m)) { 
        $subject-&gt;onNext($filename); 
      } else { 
        $e = new Exception('Unable to upload ' . $filename); 
        $subject-&gt;onError($e); 
      } 
    }); 
    return $subject-&gt;asObservable(); 
  } 
 
  public function download(Observable $files, $dir, $m=FTP_ASCII){ 
    $subject = new Subject(); 
    $files-&gt;subscribeCallback( 
        function($file) use ($subject, $m, $dir) { 
 
      $dest = $dir . DIRECTORY_SEPARATOR . $filename; 
      if (ftp_get($this-&gt;conn, $dest, $filename, $mode)) { 
        $subject-&gt;onNext($filename); 
      } else { 
        $e = new Exception('Unable to download ' . $filename); 
        $subject-&gt;onError($e); 
      } 
    }); 
    return $subject-&gt;asObservable(); 
  } 
} 
</pre><p class="calibre8">The last two methods are very similar in principle. They both take an Observable as an argument and subscribe to it. Then they create an internal Subject that is used to emit successful uploads/downloads and errors. The same Subject is then turned into an Observable with an <code class="literal">asObservable()</code> operator and returned.</p><p class="calibre8">What's interesting with this approach is that we don't need to know which files we want to download/upload in advance. In other words, we can call these methods with instances of Subject and just carry on executing our code. Then, sometime later, we can start pushing items to these Subjects, which will cause the files to be downloaded/uploaded. We'll see this in a moment.</p><p class="calibre8">We also implemented the <code class="literal">size()</code> method that takes as an argument an Observable and subscribes to it. This method is internally implemented with <code class="literal">Observable::create()</code> for the same reason as <code class="literal">listDir()</code>. We want to defer emitting any values until there's at least one subscription.</p><p class="calibre8">Now we can start using this class in a simple demo application that'll first just connect to an FTP server, list all files and directories, and then try to change the current directory to the last one in the list:</p><pre class="programlisting">// ftp_01.php 
$ftp = new FTPClient('...', 'user', 'password'); 
echo "List content...\n"; 
$ftp-&gt;listDir() 
    -&gt;takeLast(1) 
    -&gt;subscribeCallback(function($dir) use ($ftp) { 
        echo "Changing directory to "$dir"...\n"; 
        $ftp-&gt;chdir($dir); 
    }); 
</pre><p class="calibre8">We're using <code class="literal">listDir()</code> to get the content of the current directory, which is the root directory for this user. Then we take just the last item and try to go inside that directory. We used the <code class="literal">ftp_nlist()</code> function internally in <code class="literal">listDir()</code> where it returns all files and directories together, so how do we know that the last item in the list is really a directory and not a file?</p><p class="calibre8">If it was a file, then the call to <code class="literal">chdir()</code> would throw an exception. A simple way to distinguish files from directories is by checking their size. Directories always have a size of <code class="literal">-1</code>, while ordinary files have a real size that is always greater or equal to <code class="literal">0</code>:</p><pre class="programlisting">// ftp_01.php 
// ... 
echo "File sizes...\n"; 
$getFileSizesSubject = new Subject(); 
 
$fileSizes = $ftp 
  -&gt;size($getFileSizesSubject-&gt;asObservable()) 
  -&gt;doOnNext(function($file) { 
    echo "Size of ".$file['filename']." is ".$file['size']."\n"; 
  }) 
  -&gt;filter(function($file) { 
    return $file['size'] != -1; 
  }) 
  -&gt;subscribe(new DebugSubject()); 
 
$ftp-&gt;listDir()-&gt;subscribe($getFileSizesSubject);  
</pre><p class="calibre8">This demonstrates very well what we talked about. We have a Subject that we pass as an argument to the <code class="literal">size()</code> method. This method is not going to subscribe to it until its own chain has an observer, which happens on the last line with <code class="literal">DebugSubject</code>.</p><p class="calibre8">We're still not calling any <code class="literal">ftp_size()</code> because the <code class="literal">Subject</code> class in the <code class="literal">$getFileSizesSubject</code> variable hasn't emitted any items yet. This happens when we call <code class="literal">listDir()</code>, which itself first calls <code class="literal">ftp_nlist()</code> to get a list of all files and directories and then starts emitting items to the <code class="literal">Subject</code> class, which then simply takes the item and re-emits it to its own observer, which is the callable inside the <code class="literal">size()</code> method.</p><p class="calibre8">Since <code class="literal">size()</code> is based on <code class="literal">Observable::create()</code> and <code class="literal">subscribe()</code> methods, it doesn't make any network calls until we start sending it items. This might happen any time after we called it.</p><p class="calibre8">This all might look a little confusing, but all we're doing is just passing items between a couple of Observables.</p><p class="calibre8">Another obvious use-case could be listing only files in a directory and then downloading all of them. We have two methods that require an Observable as a source of files. With <code class="literal">size()</code> they will be checked for their file size (to see whether they're files at all) and for <code class="literal">download()</code> to download them. Of course, we don't want to make two separate calls for each of these methods, so we'll use the output from the Observable with only files (that is, the <code class="literal">$fileSizes</code> variable) as the source Observable for the <code class="literal">download()</code> method.</p><p class="calibre8">In order to make this example a little more complicated, we'll assume that we want to use the list of files once more and, for example, just print the file names and their sizes:</p><pre class="programlisting">// ftp_01.php 
// ... 
$fileSizes = $ftp 
  -&gt;size($getFileSizesSubject-&gt;asObservable()) 
  -&gt;doOnNext(function($file) { 
    echo "Size of ".$file['filename']." is ".$file['size']."\n"; 
  }) 
  -&gt;filter(function($file) { 
    return $file['size'] != -1; 
  }) 
  -&gt;publish(); 
 
$destDir = './_download'; 
@mkdir($destDir); 
 
echo "Downloading files ...\n"; 
$filesToDownload = $fileSizes 
  -&gt;map(function($file) { 
    return $file['filename']; 
  }); 
 
$ftp-&gt;download($filesToDownload, $destDir) 
  -&gt;subscribeCallback(function($file) use ($destDir) { 
    echo "$file downloaded"; 
    $fileDest = $destDir . DIRECTORY_SEPARATOR . $file; 
    if (file_exists($fileDest)) { 
      echo " - OK\n"; 
    } else { 
      echo " - failed\n"; 
    } 
  }); 
 
$fileSizes-&gt;subscribeCallback(function($file) { 
  echo $file['filename'] . ' - ' . $file['size'] . "B\n"; 
}); 
 
$fileSizes-&gt;connect(); 
$ftp-&gt;listDir()-&gt;subscribe($getFileSizesSubject); 
echo "Done\n"; 
</pre><p class="calibre8">In the <code class="literal">$filesToDownload</code> variable, we're storing a predefined chain of operators that emits only file names coming from <code class="literal">$fileSizes</code>.</p><p class="calibre8">If we run this demo application, we'll get the following output (depending on the FTP server we are connected to):</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php ftp_01.php</strong></span>
<span class="strong"><strong class="calibre17">List content...</strong></span>
<span class="strong"><strong class="calibre17">Changing directory to "web"...</strong></span>
<span class="strong"><strong class="calibre17">File sizes...</strong></span>
<span class="strong"><strong class="calibre17">Downloading files ...</strong></span>
<span class="strong"><strong class="calibre17">Size of . is -1</strong></span>
<span class="strong"><strong class="calibre17">Size of .. is -1</strong></span>
<span class="strong"><strong class="calibre17">Size of app is -1</strong></span>
<span class="strong"><strong class="calibre17">Size of blog is -1</strong></span>
<span class="strong"><strong class="calibre17">Size of cache is -1</strong></span>
<span class="strong"><strong class="calibre17">Size of composer.json is 522</strong></span>
<span class="strong"><strong class="calibre17">composer.json downloaded - OK</strong></span>
<span class="strong"><strong class="calibre17">composer.json - 522B</strong></span>
<span class="strong"><strong class="calibre17">Size of composer.lock is 23690</strong></span>
<span class="strong"><strong class="calibre17">composer.lock downloaded - OK</strong></span>
<span class="strong"><strong class="calibre17">composer.lock - 23690B</strong></span>
<span class="strong"><strong class="calibre17">Size of log is -1</strong></span>
<span class="strong"><strong class="calibre17">Size of src is -1</strong></span>
<span class="strong"><strong class="calibre17">Size of stats is -1</strong></span>
<span class="strong"><strong class="calibre17">Size of vendor is -1</strong></span>
<span class="strong"><strong class="calibre17">Size of www is -1</strong></span>
<span class="strong"><strong class="calibre17">Done</strong></span>
</pre><p class="calibre8">We can see that both Observables based on emissions from <code class="literal">$fileSizes</code> are sharing the same connection (the <code class="literal">doOnNext()</code> operator is called just once for each item).</p><p class="calibre8">We could also create methods listing only files or only directories. This could look like the following:</p><pre class="programlisting">class FTPClient { 
  // ... 
  public function listFiles() { 
    return $this-&gt;size($this-&gt;listDir()) 
      -&gt;filter(function($file) { 
        return $file['size'] != -1; 
      }); 
  } 
 
  public function listDirectories() { 
    return $this-&gt;size($this-&gt;listDir()) 
      -&gt;filter(function($dir) { 
        return $dir['size'] == -1 
            &amp;&amp; $dir['filename'] != '.' 
            &amp;&amp; $dir['filename'] != '..'; 
      }) 
      -&gt;map(function($dir) { 
        return $dir['filename']; 
      }); 
  } 
} 
</pre><p class="calibre8">These both use the same principle as postponing subscriptions, as we explained previously.</p></div>
<div class="book" title="Summary" id="2C9D01-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec72" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">This chapter covered a couple of slightly unusual examples that are possible with RxPHP, and which didn't fit into any of the previous chapters. These aren't things that we use on a daily basis, but it's good to know that features such as these are possible.</p><p class="calibre8">In particular, we went through the operators <code class="literal">zip()</code>, <code class="literal">window()</code>, <code class="literal">materialize()</code>, and <code class="literal">dematerialize()</code>. We saw how to propagate and handle errors in Observable chains and what role <code class="literal">AutoDetachObserver</code> has. Also, we compared the <code class="literal">Observable::create()</code> static method and the <code class="literal">Subject</code> class and when unsubscribing and completing an Observable chain. Apart from this, we created anonymous operators and wrote the <code class="literal">DirectoryIteratorObservable</code> class that recursively iterates a directory structure. Finally, we used RxPHP to make a simple FTP client that uses Observables for inputs and outputs.</p><p class="calibre8">In the last chapter, we're going to talk about implementations of Reactive Extension in languages other than PHP. Most notably, we'll have a look at RxJS-what it is, how it's related to RxPHP, and what differences we can encounter in a JavaScript environment from PHP.</p></div>

<div class="book" title="Chapter&#xA0;Appendix.&#xA0; Reusing RxPHP Techniques in RxJS"><div class="book" id="2D7TI2-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="appA" class="calibre1"/>Chapter Appendix.  Reusing RxPHP Techniques in RxJS </h1></div></div></div><p class="calibre8">Throughout this entire book, we've mentioned very often that certain functionality (such as operators or certain Observables) work differently in RxPHP and RxJS. Some operators from RxJS aren't even available in RxPHP yet. There're also features of RxJS that aren't even possible to make in RxPHP because of the nature of PHP interpreter.</p><p class="calibre8">We've referred to RxJS a lot even though Reactive Extensions were first developed for .NET as Rx.NET.</p><p class="calibre8">In this chapter, we're going to focus on the differences between current RxPHP and RxJS. Also, the knowledge of RxJS is very useful today because its popularity is still rising thanks to JavaScript frameworks such as Angular 2 that heavily rely on RxJS.</p><p class="calibre8">Topics covered in this chapter are going to be a little unusual because these will combine PHP and JavaScript (ECMAScript 6 - ES6, in particular):</p><div class="book"><ul class="itemizedlist"><li class="listitem">We'll see what RxJS is, and we'll talk about where it stands in today's world of JavaScript</li><li class="listitem">We'll write a few very simple demos of RxJS, introducing us to synchronous and asynchronous code in JavaScript</li><li class="listitem">We'll talk about asynchronous events in JavaScript and how we can benefit from them in RxJS</li><li class="listitem">We'll see how and why higher order Observables behave differently in RxJS and RxPHP</li><li class="listitem">We'll talk about operators that aren't available in RxPHP right now but are fully functional in RxJS</li></ul></div><p class="calibre8">We expect you to know at least the basics of JavaScript and ideally the new ES6 standard (aka ES2015) as well. This isn't required of course since RxJS can be used with plain old JavaScript (ES5.1 to be precise), but it's very relevant to RxJS and its development process.</p><p class="calibre8">Also, ES6 is already very well supported by Node.js, so we don't have any reason not to use it.</p><p class="calibre8">Don't worry if you can't get your head around the new ES6 syntax that we'll use in this chapter. If you want to know more about ES6, you can have a look at a quick summary of the new functionalities it provides at <a class="calibre1" href="https://github.com/lukehoban/es6features">
https://github.com/lukehoban/es6features
</a>.</p><p class="calibre8">We're going to run all examples in this chapter by Node.js runtime (<a class="calibre1" href="https://nodejs.org">
https://nodejs.org
</a>). If you're not familiar with Node.js, it's basically an environment that uses Chrome's V8 JavaScript engine and lets us run JavaScript code from a console.</p></div>

<div class="book" title="Chapter&#xA0;Appendix.&#xA0; Reusing RxPHP Techniques in RxJS">
<div class="book" title="What is RxJS?"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch11lvl1sec73" class="calibre1"/>What is RxJS?</h1></div></div></div><p class="calibre8">Very simply, RxJS is an implementation of Reactive Extensions in JavaScript.</p><p class="calibre8">Now, get ready to get super confused.</p><p class="calibre8">Until December 2016, there were two major implementations of RxJS:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre17">RxJS 4</strong></span>: This is the older implementation most people are familiar with. Its source code is available at <a class="calibre1" href="https://github.com/Reactive-Extensions/RxJS">
https://github.com/Reactive-Extensions/RxJS
</a>, and it's written in JavaScript (ES5). As we said at the beginning of this chapter, RxPHP refers at this moment mostly to this older RxJS 4 version that'll become obsolete in the near future.</li><li class="listitem"><span class="strong"><strong class="calibre17">RxJS 5</strong></span>: The newer and completely rewritten RxJS that will replace the older RxJS 4. Its source code is available at <a class="calibre1" href="https://github.com/ReactiveX/rxjs">
https://github.com/ReactiveX/rxjs
</a>, and it's completely written in TypeScript 2.0.</li></ul></div><p class="calibre8">Because we've mentioned yet another programming language called TypeScript, we should quickly look at what JavaScript versions are actually out there and where (and also if) we can use them:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre17">ES5.1</strong></span>: The good old JavaScript that probably everybody has encountered at some point.</li><li class="listitem"><span class="strong"><strong class="calibre17">ES6</strong></span> (also named <span class="strong"><strong class="calibre17">ES2015</strong></span>): This is the newer standard of JavaScript. It's backward compatible with ES5.1, and it brings features such as classes, generators, arrow functions, and the <code class="literal">let</code> keyword to create block scoped variables.</li><li class="listitem"><span class="strong"><strong class="calibre17">ES7</strong></span> (<span class="strong"><strong class="calibre17">ES2016</strong></span>): This is the even newer standard of JavaScript that brings in yet more features such as the <code class="literal">async</code>/<code class="literal">await</code> keyword to avoid creating callback hells.</li><li class="listitem"><span class="strong"><strong class="calibre17">TypeScript</strong></span>: This is a superset of ES6 specification supplemented with type checking and is in the latest versions, also with features from ES7 such as the <code class="literal">async</code>/<code class="literal">await</code> keyword.</li></ul></div><p class="calibre8">So TypeScript was the language of choice for RxJS 5 because of its compatibility with ES6 and type checking that helps prevent a lot of bugs in compile time.</p><p class="calibre8">Well, while speaking of compiling, we should probably mention where we can actually run any of these new and fancy languages:</p><div class="book"><ul class="itemizedlist"><li class="listitem">ES5.1 is supported by every current browser including mobile browsers and Node.js.</li><li class="listitem">ES6 can already be used with the two major JavaScript engines: Chrome's V8 and SpiderMonkey (used by FireFox). Although current compatibility with ES6 is pretty good (as we can see at<a class="calibre1" href="http://kangax.github.io/compat-table/es6/">
 http://kangax.github.io/compat-table/es6/
</a>), it's still not possible to rely only on ES6 for browser-based applications. We obviously need to also support older browsers and mobile devices. For this reason, any code written in ES6 needs to be compiled to ES5 using a compiler such as babel (<a class="calibre1" href="https://babeljs.io/">
https://babeljs.io/
</a>) or traceur (<a class="calibre1" href="https://github.com/google/traceur-compiler">
https://github.com/google/traceur-compiler
</a>). This doesn't apply to Node.js where we can freely use ES6 since Node.js v4 is already pretty old, and the penetration of different Node.js versions isn't such a problem like those we're used to from web browsers (there's one important exception with ES6 module imports that we'll mention later).</li><li class="listitem">ES7 brings some features that are already implemented natively in JavaScript engines (see <a class="calibre1" href="http://kangax.github.io/compat-table/es2016plus/">
http://kangax.github.io/compat-table/es2016plus/
</a>); however, this is still music of the future. We're not going to use ES7 features in Node.js in this chapter, to avoid compiling our code from ES7 to ES6.</li><li class="listitem">TypeScript is a relatively new language made by Microsoft and the community around it. It's not going to be natively supported by any JavaScript engines. It uses different syntax and new keywords that aren't compatible with either ES6 or ES7. This means that TypeScript code always needs to be compiled to ES6 or more commonly to ES5.</li></ul></div><p class="calibre8">On the other hand, it's important to note that TypeScript is a superset of ES6. This means that any ES5 or ES6 code is also a valid TypeScript code that makes reusing already existing JavaScript very easy.</p><p class="calibre8">This is in contrast to other languages that can be compiled to ES5, such as Dart made by Google. Dart isn't compatible with JavaScript at all, and basically, all code needs to be rewritten to Dart. This might be one of the reasons why TypeScript is so popular today despite the fact that it came later than Dart.</p><p class="calibre8">So for this chapter, we're going to use Node.js (ideally, v6.9+, but basically, any v4+ should be fine) and ES6.</p></div></div>

<div class="book" title="Chapter&#xA0;Appendix.&#xA0; Reusing RxPHP Techniques in RxJS">
<div class="book" title="What is RxJS?">
<div class="book" title="JavaScript module systems"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch11lvl2sec97" class="calibre1"/>JavaScript module systems</h2></div></div></div><p class="calibre8">To add to the confusion when talking about current JavaScript standards, we should also mention different module systems used today to define dependencies between JavaScript files.</p><p class="calibre8">Working with JavaScript was always tedious because there was never any unified way to split code into multiple files and load it on demand or even to bundle it.</p><p class="calibre8">So now we have nice ES6 syntax for ES6 modules available, let's consider the following code:</p><pre class="programlisting">import * as lib from 'lib'; 
console.log(lib.square(42)); 
</pre><p class="calibre8">Can you tell in what environment we can run this code natively today?</p><p class="calibre8">This was a trick question. We can't run it anywhere because no JavaScript engine supports ES6 modules yet, not even Node.js.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note50" class="calibre1"/>Note</h3><p class="calibre8">If you want to know more about why implementing ES6 modules into Node.js is so complicated, read this article by one of the Node.js developers at <a class="calibre1" href="https://hackernoon.com/node-js-tc-39-and-modules-a1118aecf95e">
https://hackernoon.com/node-js-tc-39-and-modules-a1118aecf95e
</a>.</p></div><p class="calibre8">Node.js at this moment supports only using the <code class="literal">require()</code> function to load modules in the CommonJS format (in fact, it's not exactly the CommonJS format; it's just very close to it). The <code class="literal">require()</code> function is natively available only in Node.js. If we wanted to use <code class="literal">require()</code> also in the browser, we'd need a polyfill or a bundler to merge multiple JavaScript files linked via <code class="literal">require()</code> calls into a single bundle.</p><p class="calibre8">If we really wanted to use ES6 module definitions right now, this would be another reason we'd have to compile our code. Note that we could actually compile ES6 code into another ES6 code, only to transform ES6 imports to one of the current module formats, such as UMD, CommonJS, AMD, SystemJS, or globals.</p><p class="calibre8">This has been resolved by various bundling tools, such as Browserify, webpack, SystemJS-Builder, or rollup.js. However, this just added yet another layer of complexity. Moreover, these tools just bundle multiple files into a single bundle. If we have a more complicated application where we need to load third-party libraries (that can be bundled in any format, which includes even the most basic Angular2 or React applications) we need to also care about module loaders.</p><p class="calibre8">Module loaders are, for example, SystemJS, require.js, require1k, curl.js, and probably dozens more.</p><p class="calibre8">This all means that when we start working on a JavaScript project today, we need to plan ahead the following four different things:</p><div class="book"><ul class="itemizedlist"><li class="listitem">What language I'm going to use? this has an effect on the features available and also on the compiler you have to use</li><li class="listitem">To what module format am I going to compile my source code?</li><li class="listitem">What bundling tool I'm going to use?</li><li class="listitem">How I am going to require my bundled project (by just including it via the <code class="literal">&lt;script&gt;</code> tag or do I need a module loader)?</li></ul></div><p class="calibre8">So, RxJS 4 avoided almost all of this because it's written in ES5. The only necessary task is bundling it into a single file that can be loaded as easily as just using the <code class="literal">&lt;script&gt;</code> tag.</p><p class="calibre8">With RxJS 5, it gets more complicated.</p></div></div></div>

<div class="book" title="Chapter&#xA0;Appendix.&#xA0; Reusing RxPHP Techniques in RxJS">
<div class="book" title="What is RxJS?">
<div class="book" title="The deployment process of RxJS 5"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_3"><a id="ch11lvl2sec98" class="calibre1"/>The deployment process of RxJS 5</h2></div></div></div><p class="calibre8">The entire RxJS 5 project is written in TypeScript. This means that it needs to be compiled to ES5, so we can use it in a browser or in Node.js.</p><p class="calibre8">The process goes as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The entire source code is first compiled to ES6 using the TypeScript compiler with the ES6 module resolution.</li><li class="listitem">The ES6 code is then compiled again using <code class="literal">closure-compiler-js</code> made by Google, which generates ES5 code.</li><li class="listitem">This ES5 code is bundled using rollup.js (before rollup.js, they were using Browserify) to create a single UMD bundle.</li><li class="listitem">This bundled file together with ES5 versions of each file along with their source maps and <code class="literal">.d.ts</code> files (TypeScript declaration file) are then uploaded to an npm repository. When we use RxJS 5 in, for example, Node.js, we will usually require only this single UMD bundle. When using RxJS 5 in a browser, we can just include it via the <code class="literal">&lt;script&gt;</code> tag thanks to the UMD module format.</li></ul></div><div class="informaltable" title="Note"><h3 class="title1"><a id="note51" class="calibre1"/>Note</h3><p class="calibre8">
<span class="strong"><strong class="calibre17">Universal Module Definition</strong></span> (<span class="strong"><strong class="calibre17">UMD</strong></span>) is a universal module format that acts as AMD, CommonJS, SystemJS, or global depending on the environment loading it.</p></div><p class="calibre8">As we can see, developing applications in today's JavaScript is no joke. We'll see that it also has some benefits. In particular, prototypical-based inheritance can ease extending the existing Observables, which isn't possible in PHP for instance.</p><p class="calibre8">But before that, let's see how we can use RxJS 5 in Node.js.</p></div></div></div>

<div class="book" title="A quick introduction to RxJS 5 in Node.js"><div class="book" id="2E6E42-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec74" class="calibre1"/>A quick introduction to RxJS 5 in Node.js</h1></div></div></div><p class="calibre8">We're already pretty experienced reactive developers, so none of these examples should surprise us.</p><p class="calibre8">We'll start by installing RxJS 5 via <code class="literal">npm</code> (basically, a dependency management tool similar to Composer in PHP):</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ npm install rxjs</strong></span>
</pre><p class="calibre8">As we said earlier, we're going to use ES6 syntax, but we want to avoid recompiling our code because of ES6 imports. That's why we'll always use the <code class="literal">require()</code> function to load dependencies. This example should be very simple:</p><pre class="programlisting">// rxjs_01.js 
const Rx = require('rxjs/Rx'); 
 
Rx.Observable.range(1, 8) 
    .filter(val =&gt; val % 2 == 0) 
    .subscribe(val =&gt; console.log('Next:', val)); 
</pre><p class="calibre8">We loaded RxJS 5 with <code class="literal">rxjs/Rx</code> under the Rx constant. Node.js knows where to find the <code class="literal">rxjs</code> package (it automatically looks for packages into the <code class="literal">node_modules</code> directory). The full name <code class="literal">rxjs/Rx</code> means that it'll load file from <code class="literal">./node_modules/rxjs/Rx.js</code>. It is like the entry point of this library. It contains a lot of <code class="literal">require()</code> calls and then it exports all the classes we as developers are allowed to use. All these classes are then accessible with the <code class="literal">Rx</code> prefix (for example, <code class="literal">Rx.Subject</code> or <code class="literal">Rx.TestScheduler</code>).</p><p class="calibre8">The arrow syntax <code class="literal">val =&gt; val % 2 == 0</code> we're using is just a shortcut to declare an anonymous function with a return statement:</p><pre class="programlisting">function(val) { 
    return val % 2 == 0; 
} 
</pre><p class="calibre8">The arrow <code class="literal">=&gt;</code> also makes the inner closure take the <code class="literal">this</code> context from its parent, but we're not going make use of this a lot here.</p><p class="calibre8">To run this demo, we'll just need Node.js runtime:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ node rxjs_01.js </strong></span>
<span class="strong"><strong class="calibre17">Next: 2</strong></span>
<span class="strong"><strong class="calibre17">Next: 4</strong></span>
<span class="strong"><strong class="calibre17">Next: 6</strong></span>
<span class="strong"><strong class="calibre17">Next: 8</strong></span>
</pre><p class="calibre8">Even with this very primitive example, we can already see how different it is from PHP. When using Composer, we don't need to worry about where our dependencies come from because they're always loaded by the SPL autoloader usually generated by Composer.</p></div>

<div class="book" title="A quick introduction to RxJS 5 in Node.js">
<div class="book" title="Asynchronous calls in RxJS"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch11lvl2sec99" class="calibre1"/>Asynchronous calls in RxJS</h2></div></div></div><p class="calibre8">Every time we wanted to make code in PHP asynchronous, we had to stick to event loops: in particular, <code class="literal">StreamSelectLoop</code> and <code class="literal">EventLoopScheduler</code>, and there was no way around it. Every <code class="literal">IntervalObservable</code> had to take as an argument a Scheduler (however, in RxPHP 2 this is done automatically for us so we usually don't need to worry about it).</p><p class="calibre8">This is in RxJS, and in general, any JavaScript environment completely different from PHP.</p><p class="calibre8">Consider the following example:</p><pre class="programlisting">// interval_01.js 
const Rx = require('rxjs/Rx'); 
const Observable = Rx.Observable; 
 
Observable.interval(1000) 
    .subscribe(val =&gt; console.log('#1 Next:', val)); 
Observable.interval(60) 
    .subscribe(val =&gt; console.log('#2 Next:', val)); 
</pre><p class="calibre8">Note that we're using no loops and no Schedulers. In fact in RxJS 5, it's not that common for operators to take a Scheduler as an argument. The majority of operators don't because they don't need to schedule anything (such as the <code class="literal">map()</code> or <code class="literal">filter()</code> operators) and usually only those that need to work with timers do (basically, all operators containing work "time").</p><p class="calibre8">This also implies that we don't need to worry about the different parts of our application is using different even loops. We discussed this topic in <a class="calibre1" title="Chapter 6. PHP Streams API and Higher-Order Observables" href="part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d">
Chapter 06
</a>, <span class="strong"><em class="calibre18">PHP Streams API and Higher-Order Observables</em></span>, and <a class="calibre1" title="Chapter 7. Implementing Socket IPC and WebSocket Server/Client" href="part0054_split_000.html#1JFUC2-bd355a22cf10407cb10df27e65585b8d">
Chapter 07
</a>, <span class="strong"><em class="calibre18">Implementing Socket IPC and WebSocket Server/Client</em></span>, where we saw that this, left unattended, may cause deadlocks.</p><p class="calibre8">We can run this demo and see ever-increasing counters triggering:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ node interval_01.js </strong></span>
<span class="strong"><strong class="calibre17">#2 Next: 0</strong></span>
<span class="strong"><strong class="calibre17">#1 Next: 0</strong></span>
<span class="strong"><strong class="calibre17">#2 Next: 1</strong></span>
<span class="strong"><strong class="calibre17">#2 Next: 2</strong></span>
<span class="strong"><strong class="calibre17">#1 Next: 1</strong></span>
<span class="strong"><strong class="calibre17">#2 Next: 3</strong></span>
</pre><p class="calibre8">A good question is why is it so simple in JavaScript and yet needs to be so complicated in PHP?</p></div></div>

<div class="book" title="A quick introduction to RxJS 5 in Node.js">
<div class="book" title="Node.js and asynchronous events"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch11lvl2sec100" class="calibre1"/>Node.js and asynchronous events</h2></div></div></div><p class="calibre8">Node.js is in fact one large event loop based on the libuv library (<a class="calibre1" href="http://docs.libuv.org/">
http://docs.libuv.org/
</a>).</p><p class="calibre8">Let's consider the following example that demonstrates adding a new callback to the event loop:</p><pre class="programlisting">// node_01.js  
console.log('Starting application...'); 
var num = 5; 
console.log('num =', num); 
 
setTimeout(() =&gt; { 
    console.log('Inside setTimeout'); 
    num += 1; 
    console.log('num =', num); 
}); 
 
console.log('After scheduling another callback'); 
console.log('num =', num); 
</pre><p class="calibre8">When we run an application in Node.js, it takes our code as a single callback and starts executing it. Somewhere in our code, we're calling the <code class="literal">setTimeout()</code> function that takes as argument another callback that will be executed after some period of time. However, we called <code class="literal">setTimeout()</code> without providing any timeout.</p><p class="calibre8">This in fact doesn't matter because <code class="literal">setTimeout()</code> adds the callback to the event loop to be run as the last one after all other callbacks are executed. Using callbacks, we can easily make Node.js run our code asynchronously. It's also typical for Node.js that all system calls are asynchronous and take callbacks as parameters in order to be non-blocking.</p><p class="calibre8">The output in the console is as follows:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ node node_01.js </strong></span>
<span class="strong"><strong class="calibre17">Starting application...</strong></span>
<span class="strong"><strong class="calibre17">num = 5</strong></span>
<span class="strong"><strong class="calibre17">After scheduling another callback</strong></span>
<span class="strong"><strong class="calibre17">num = 5</strong></span>
<span class="strong"><strong class="calibre17">Inside setTimeout</strong></span>
<span class="strong"><strong class="calibre17">num = 6</strong></span>
</pre><p class="calibre8">We can see that the callback was really called after the outer callback got finished. When there're no more callbacks in the event loop and no callbacks are pending, then Node.js terminates.</p><p class="calibre8">Deep inside libuv, there's actually a thread pool that runs in parallel and handles system calls that can be run concurrently. Nonetheless, this has no effect on our code because Node.js will always execute callbacks one after another. This is a huge difference to PHP where none of this exists and the only way to schedule asynchronous calls is using custom event loops just like we did with <code class="literal">StreamSelectLoop</code>.</p><p class="calibre8">Keep in mind that from our point of view, Node.js is always single threaded and strictly sequential. This means that just like in PHP if we write code that is blocking, it's going to block the execution thread as well. Node.js never executes callbacks in parallel. This of course applies to browser JavaScript environments as well.</p><p class="calibre8">If we wanted to run code in parallel, we could spawn subprocesses just like we did for example in <a class="calibre1" title="Chapter 6. PHP Streams API and Higher-Order Observables" href="part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d">
Chapter 06
</a>, <span class="strong"><em class="calibre18">PHP Streams API and Higher-Order Observables</em></span>.</p></div></div>

<div class="book" title="A quick introduction to RxJS 5 in Node.js">
<div class="book" title="Lossy backpressure with the debounceTime() operator"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_3"><a id="ch11lvl2sec101" class="calibre1"/>Lossy backpressure with the debounceTime() operator</h2></div></div></div><p class="calibre8">We know what backpressure is already from <a class="calibre1" title="Chapter 7. Implementing Socket IPC and WebSocket Server/Client" href="part0054_split_000.html#1JFUC2-bd355a22cf10407cb10df27e65585b8d">
Chapter 07
</a>, <span class="strong"><em class="calibre18">Implementing Socket IPC and WebSocket Server/Client</em></span>. A typical use case in RxJS is <code class="literal">debounceTime()</code> that takes a value and then waits until the specified timeout expires before re-emitting it further. This is very useful, for example, when creating an autocomplete feature where we want to postpone sending AJAX requests when the user is still typing into an input field (as we saw in <a class="calibre1" title="Chapter 1. Introduction to Reactive Programming" href="part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d">
Chapter 1
</a>, <span class="strong"><em class="calibre18">Introduction to Reactive Programming</em></span>).</p><p class="calibre8">Let's have a look at its marble diagram:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00034.jpeg" alt="Lossy backpressure with the debounceTime() operator" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">In order to illustrate a practical example of <code class="literal">debounceTime()</code>, consider the following example:</p><pre class="programlisting">// debounce_time_01.js  
Observable.interval(100) 
    .concatMap(val =&gt; { 
        let obs = Observable.of(val); 
        return val % 5 == 0 ? obs.delay(250) : obs; 
    }) 
    .debounceTime(200) 
    .subscribe(val =&gt; console.log(val)); 
</pre><p class="calibre8">This example emits a value every 100 ms and every fifth value is delayed by 250 ms. That's why most of the values are ignored by <code class="literal">debounceTime()</code> because this operator requires an at least 200 ms long period without any emission from the source.</p><p class="calibre8">The output is as follows:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ node debounce_time_01.js </strong></span>
<span class="strong"><strong class="calibre17">4</strong></span>
<span class="strong"><strong class="calibre17">9</strong></span>
<span class="strong"><strong class="calibre17">14</strong></span>
</pre><p class="calibre8">There's one very nice practical example for <code class="literal">debounceTime()</code> that makes use of JavaScript's asynchronous callbacks.</p><p class="calibre8">In the first chapter, when talking about reactive programming, we mentioned that a common application that we consider "reactive" is Excel. We have multiple cells with equations that define their relations and every change to any cell is propagated to the entire spreadsheet.</p><p class="calibre8">Let's consider the following spreadsheet with three input values <code class="literal">A</code>, <code class="literal">B</code>, and <code class="literal">C</code> and the following equations we made on them:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00035.jpeg" alt="Lossy backpressure with the debounceTime() operator" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">Now, how can we create something similar in RxJS? We can represent each cell as <code class="literal">BehaviorSubject</code> with a default value (we need to use Subjects in order to be able to change cell values later). Then, each equation (for example, <code class="literal">A + B</code>) will be held by <code class="literal">combineLatest()</code>.</p><p class="calibre8">The preceding spreadsheet could look like this in RxJS:</p><pre class="programlisting">// excel_01.js 
const Rx = require('rxjs/Rx'); 
const Observable = Rx.Observable; 
const BehaviorSubject = Rx.BehaviorSubject; 
 
let A = new BehaviorSubject(1); 
let B = new BehaviorSubject(2); 
let C = new BehaviorSubject(3); 
 
let AB = Observable.combineLatest(A, B, (a, b) =&gt; a + b) 
    .do(x =&gt; console.log('A + B = ' + x)); 
 
let BC = Observable.combineLatest(B, C, (b, c) =&gt; b + c) 
    .do(x =&gt; console.log('B + C = ' + x)); 
 
let ABBC = Observable.combineLatest(AB, BC, (ab, bc) =&gt; ab + bc) 
    .do(x =&gt; console.log('AB + BC = ' + x)); 
 
ABBC.subscribe(); 
</pre><p class="calibre8">We're using <code class="literal">combineLatest()</code> to get notified when any of the source Observables for each equation change. We also have multiple <code class="literal">do()</code> operators to log what's going on in our Observable chains.</p><p class="calibre8">When we run this demo, we'll see the following output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ node excel_01.js </strong></span>
<span class="strong"><strong class="calibre17">A + B = 3</strong></span>
<span class="strong"><strong class="calibre17">B + C = 5</strong></span>
<span class="strong"><strong class="calibre17">AB + BC = 8</strong></span>
</pre><p class="calibre8">This is obviously correct. Each equation was called exactly once.</p><p class="calibre8">Now, let's imagine that we change the <code class="literal">B</code> cell value to <code class="literal">4</code> after the default values were propagated. This means that it'll need to recalculate <code class="literal">AB</code>, <code class="literal">BC</code>, and <code class="literal">ABBC</code>. The desired state after updating the <code class="literal">B</code> cell should look like the following screenshot:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00036.jpeg" alt="Lossy backpressure with the debounceTime() operator" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">Append these two lines to the source file:</p><pre class="programlisting">... 
console.log("Updating B = 4 ..."); 
B.next(4); 
</pre><p class="calibre8">Then, rerun the example and pay attention to what equations were evaluated:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ node excel_01.js </strong></span>
<span class="strong"><strong class="calibre17">A + B = 3</strong></span>
<span class="strong"><strong class="calibre17">B + C = 5</strong></span>
<span class="strong"><strong class="calibre17">AB + BC = 8</strong></span>
<span class="strong"><strong class="calibre17">Updating B = 4 ...</strong></span>
<span class="strong"><strong class="calibre17">A + B = 5</strong></span>
<span class="strong"><strong class="calibre17">AB + BC = 10</strong></span>
<span class="strong"><strong class="calibre17">B + C = 7</strong></span>
<span class="strong"><strong class="calibre17">AB + BC = 12</strong></span>
</pre><p class="calibre8">The first three are alright. Then, we set <code class="literal">B = 4</code>, which triggers the recalculation of <code class="literal">A + B,</code> and right after that, <code class="literal">AB + BC</code> equals <code class="literal">10</code>. Well, this is not correct because we haven't updated also <code class="literal">B + C</code>, which comes next. Then, after updating <code class="literal">BC</code>, the <code class="literal">AB + BC</code> is recalculated again and the correct value is set to <code class="literal">ABBC</code>.</p><p class="calibre8">We could just ignore this because the result is correct at the end. However, if the number of cells and the number of equations grew, then each redundant update would still cause an update to the page's DOM. As a result, this could make the page laggy and the user might notice the cells blinking.</p><p class="calibre8">So how can we avoid this?</p><p class="calibre8">We said that when <code class="literal">debounceTime()</code> receives a value, it stores it internally and starts a timeout. Then it doesn't re-emit any value until the timeout's callback is evaluated, which re-emits only the last value <code class="literal">debounceTime()</code> received. We can use this to our advantage by knowing that we can set <code class="literal">0</code> timeout, which won't delay the callback but just puts in at the end of Node.js's event loop.</p><p class="calibre8">In other words, when we use <code class="literal">debounceTime(0)</code>, we'll ignore all values that <code class="literal">debounceTime()</code> receives until the end of this callback. So, we can use this to calculate <code class="literal">AB + BC</code>:</p><pre class="programlisting">let ABBC = Observable.combineLatest(AB, BC, (ab, bc) =&gt; ab + bc) 
    .debounceTime(0) 
    .do(x =&gt; console.log('AB + BC = ' + x)); 
</pre><p class="calibre8">Now if we run the code again, we'll see the output we wanted:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ node excel_01.js </strong></span>
<span class="strong"><strong class="calibre17">A + B = 3</strong></span>
<span class="strong"><strong class="calibre17">B + C = 5</strong></span>
<span class="strong"><strong class="calibre17">Updating B = 4 ...</strong></span>
<span class="strong"><strong class="calibre17">A + B = 5</strong></span>
<span class="strong"><strong class="calibre17">B + C = 7</strong></span>
<span class="strong"><strong class="calibre17">AB + BC = 12</strong></span>
</pre><p class="calibre8">This is definitely an advanced use case that we won't encounter on a daily basis, but it's nice to see that we can use JavaScript internals to our advantage.</p><p class="calibre8">Note that this is something very difficult to do in RxPHP without using an event loop and custom operators, yet relatively simple in JavaScript.</p></div></div>
<div class="book" title="Higher-order Observables in RxJS 5 and RxPHP" id="2F4UM1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec75" class="calibre1"/>Higher-order Observables in RxJS 5 and RxPHP</h1></div></div></div><p class="calibre8">When developing browser applications, we very often need to make AJAX calls to fetch data asynchronously. For example, in Angular2, this is very common, and in fact, any AJAX request made using Angular2's HTTP service returns an Observable where we typically chain the <code class="literal">map()</code> operator to decode JSON and then use <code class="literal">subscribe()</code> to be notified when the response is ready.</p><p class="calibre8">We can simulate such a situation with the following code:</p><pre class="programlisting">// http_mock_01.js 
const Rx = require('rxjs/Rx'); 
let data = '[{"name": "John"},{"name": "Bob"},{"name": "Dan"}]'; 
 
Rx.Observable.of(data) 
    .map(response =&gt; JSON.parse(response)) 
    .subscribe(value =&gt; console.log('Next:', value)); 
</pre><p class="calibre8">Variable data contains a JSON-serialized array of objects that we decode and pass to the observer. The output looks like the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ node http_mock_01.js </strong></span>
<span class="strong"><strong class="calibre17">Next: [ { name: 'John' }, { name: 'Bob' }, { name: 'Dan' } ]</strong></span>
</pre><p class="calibre8">Well, it works, but what if we wanted to receive only objects with the <code class="literal">name</code> property starting with the letter <code class="literal">B</code>? Right now, we received the entire array of objects as a single emission.</p><p class="calibre8">So, the question is how can we unpack the array and emit every single object separately?</p><p class="calibre8">One option that can be used in RxJS and RxPHP in exactly the same way is using <code class="literal">concatMap()</code> (<code class="literal">mergeMap()</code> would work as well) and return a new Observable created from an iterable object. In RxJS, this could be as follows:</p><pre class="programlisting">// http_mock_02.js 
... 
Observable.of(data) 
    .map(response =&gt; JSON.parse(response)) 
    .concatMap(array =&gt; Observable.from(array)) 
    .filter(object =&gt; object.name[0].toLowerCase() == "b") 
    .subscribe(value =&gt; console.log('Next:', value)); 
</pre><p class="calibre8">In RxJS 5, <code class="literal">Observable.from()</code> takes as a parameter any array-like object and emits all its items. In RxPHP, we'd use <code class="literal">Observable::fromArray()</code> instead.</p><p class="calibre8">Now the output is a single item because the rest was skipped thanks to the <code class="literal">filter()</code> operator:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ node http_mock_02.js</strong></span>
<span class="strong"><strong class="calibre17">Next: { name: 'Bob' }</strong></span>
</pre><p class="calibre8">In RxJS 5, there's also another and quite clever way to achieve the same result.</p><p class="calibre8">We've talked about operators that work with higher-order Observables, such as <code class="literal">mergeAll()</code> or <code class="literal">concatAll()</code>. These subscribe to an Observable that emits Observables. Due to RxJS 5 inner implementation, we can use a little trick and use operators that normally work with only higher-order Observables to work with arrays as well.</p><p class="calibre8">Let's see how <code class="literal">concatAll()</code> can be used to achieve the same result as <code class="literal">concatMap()</code> in the preceding example:</p><pre class="programlisting">Observable.of(data) 
    .map(data =&gt; JSON.parse(data)) 
    .concatAll() 
    .filter(object =&gt; object.name[0].toLowerCase() == "b") 
    .subscribe(value =&gt; console.log('Next:', value)); 
</pre><p class="calibre8">So, this obviously shouldn't work. How can <code class="literal">concatAll()</code> subscribe to an array?</p><p class="calibre8">The answer lies in the way <code class="literal">concatAll()</code>, and basically, all operators working with higher-order Observables internally subscribe to items emitted by the source Observable. In PHP, we'd expect that all of them have to be other Observables, but this is not the case for RxJS 5.</p><p class="calibre8">Some operators in RxJS 5 subscribe to inner Observables via a function named <code class="literal">subscribeToResult()</code> (it's defined in <code class="literal">src/util/subscribeToResult.ts</code>). This function has multiple handlers for different types of items. There's of course a handler for Observables, but apart from that, it also knows how to work with Promises as well as JavaScript arrays.</p><p class="calibre8">When we used <code class="literal">concatAll()</code> earlier, the <code class="literal">subscribeToResult()</code> function just iterated the array and re-emitted all its values. Note that it just iterated the array internally. It didn't create another Observable from it.</p><p class="calibre8">So, these were just two, but useful, differences we can encounter when switching from RxPHP to RxJS 5.</p></div>

<div class="book" title="Operators specific for RxJS 5"><div class="book" id="2G3F82-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec76" class="calibre1"/>Operators specific for RxJS 5</h1></div></div></div><p class="calibre8">As we said, there are extra operators in RxJS 5 that aren't available in RxPHP right now. There are in fact, quite of few of them, but many are very similar in principle. We mentioned some of them in <a class="calibre1" title="Chapter 7. Implementing Socket IPC and WebSocket Server/Client" href="part0054_split_000.html#1JFUC2-bd355a22cf10407cb10df27e65585b8d">
Chapter 07
</a>, <span class="strong"><em class="calibre18">Implementing Socket IPC and WebSocket Server/Client</em></span>, such as <code class="literal">audit()</code> or <code class="literal">throttle(),</code> including all their variations that use timeouts or other Observables to create time windows. Also, all operators derived from <code class="literal">buffer()</code> aren't so interesting for us.</p><p class="calibre8">We'll have a look at the three of them that serve some other interesting purposes.</p></div>

<div class="book" title="Operators specific for RxJS 5">
<div class="book" title="The expand() operator"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch11lvl2sec102" class="calibre1"/>The expand() operator</h2></div></div></div><p class="calibre8">The interesting thing about the <code class="literal">expand()</code> operator is that it works recursively. It takes as a parameter a callback that needs to return another Observable. The callback is then applied to all values emitted by the returned Observable. This goes on as long as the returned Observables emit values.</p><p class="calibre8">Consider the following example where we use <code class="literal">expand()</code> to recursively multiply a value by two as long as the result is less than 32:</p><pre class="programlisting">// expand_01.js 
const Rx = require('rxjs/Rx'); 
const Observable = Rx.Observable; 
 
Observable.of(1) 
    .expand(val =&gt; { 
        if (val &gt; 32) { 
            return Observable.empty(); 
        } else { 
            return Observable.of(val * 2); 
        } 
    }) 
    .subscribe(val =&gt; console.log(val)); 
</pre><p class="calibre8">We stop the recursion by not emitting any value and returning just <code class="literal">Observable.empty()</code> (which emits just a complete signal).</p><p class="calibre8">All intermediate values produced by all the recursive calls are re-emitted by <code class="literal">expand()</code>, so the output from this example will look as follows:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ node expand_01.js </strong></span>
<span class="strong"><strong class="calibre17">1</strong></span>
<span class="strong"><strong class="calibre17">2</strong></span>
<span class="strong"><strong class="calibre17">4</strong></span>
<span class="strong"><strong class="calibre17">8</strong></span>
<span class="strong"><strong class="calibre17">16</strong></span>
<span class="strong"><strong class="calibre17">32</strong></span>
<span class="strong"><strong class="calibre17">64</strong></span>
</pre></div></div>

<div class="book" title="Operators specific for RxJS 5">
<div class="book" title="The finally() operator"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch11lvl2sec103" class="calibre1"/>The finally() operator</h2></div></div></div><p class="calibre8">As the name suggests, this operator executes its callback on both the <code class="literal">error</code> and <code class="literal">complete</code> signals. It's important to see the difference between <code class="literal">finally()</code> and just subscribing and using the same callbacks for error and complete signals.</p><p class="calibre8">The <code class="literal">finally()</code> operator doesn't turn cold Observables to hot. So, it's more similar to the <code class="literal">do()</code> operator than to the <code class="literal">subscribe()</code> method:</p><pre class="programlisting">// finally_01.js 
const Rx = require('rxjs/Rx'); 
let source = Rx.Observable.create(observer =&gt; { 
        observer.next(1); 
        observer.error('error message'); 
        observer.next(3); 
        observer.complete(); 
    }); 
 
source 
    .finally(() =&gt; console.log('#1 Finally callback')) 
    .subscribe( 
        value =&gt; console.log('#1 Next:', value), 
        error =&gt; console.log('#1 Error:', error), 
        () =&gt; console.log('#1 Complete') 
    ); 
 
source 
    .onErrorResumeNext() 
    .finally(() =&gt; console.log('#2 Finally callback')) 
    .subscribe( 
        value =&gt; console.log('#2 Next:', value), 
        error =&gt; console.log('#2 Error:', error), 
        () =&gt; console.log('#2 Complete') 
    ); 
</pre><p class="calibre8">The first subscription will receive only the first value and then the <code class="literal">error</code> signal. Note the order in which we used the <code class="literal">finally()</code> operator and the <code class="literal">subscribe()</code> call. Operator <code class="literal">finally()</code> comes first so it also receives the error signal first.</p><p class="calibre8">The second subscription is analogous. Also, this one uses <code class="literal">onErrorResumeNext()</code> to ignore the error signal (even though it won't receive the last value because it has already unsubscribed). It'll receive just the complete signal. Again, note where the <code class="literal">finally()</code> operator is used.</p><p class="calibre8">When we run this example, we'll get the following output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ node finally_01.js </strong></span>
<span class="strong"><strong class="calibre17">#1 Next: 1</strong></span>
<span class="strong"><strong class="calibre17">#1 Error: error message</strong></span>
<span class="strong"><strong class="calibre17">#1 Finally callback</strong></span>
<span class="strong"><strong class="calibre17">#2 Next: 1</strong></span>
<span class="strong"><strong class="calibre17">#2 Complete</strong></span>
<span class="strong"><strong class="calibre17">#2 Finally callback</strong></span>
</pre><p class="calibre8">Even though both <code class="literal">finally()</code> operators are used before <code class="literal">subscribe()</code> (which is obvious because these are operators that need to be somewhere in the chain), their callbacks were executed after the error or complete callbacks from <code class="literal">subscribe()</code>.</p><p class="calibre8">This is the fundamental difference of the <code class="literal">do()</code> operator and also the reason why <code class="literal">finally()</code> might come in handy in certain situations.</p></div></div>

<div class="book" title="Operators specific for RxJS 5">
<div class="book" title="The withLatestFrom() operator"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_3"><a id="ch11lvl2sec104" class="calibre1"/>The withLatestFrom() operator</h2></div></div></div><p class="calibre8">In <a class="calibre1" title="Chapter 7. Implementing Socket IPC and WebSocket Server/Client" href="part0054_split_000.html#1JFUC2-bd355a22cf10407cb10df27e65585b8d">
Chapter 07
</a>, <span class="strong"><em class="calibre18">Implementing Socket IPC and WebSocket Server/Client</em></span>, and <a class="calibre1" title="Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension" href="part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d">
Chapter 8
</a>, <span class="strong"><em class="calibre18">Multicasting in RxPHP and PHP7 pthreads Extension</em></span>, we used the <code class="literal">combineLatest()</code> operator, and we mentioned that in RxJS 5, there's also a slightly modified variant.</p><p class="calibre8">The <code class="literal">combineLatest()</code> operator takes multiple source Observables and emits their most recent values as an array when any of them emit a value. Then, there's the <code class="literal">withLatestFrom()</code> operator that takes multiple sources as well, but this operator emits a value only when its direct predecessor in the chain emits a value (its source Observable).</p><p class="calibre8">Consider the following example with multiple timers:</p><pre class="programlisting">// with_latest_from_01.js  
const Rx = require('rxjs/Rx'); 
const Observable = Rx.Observable; 
 
let source1 = Observable.interval(150); 
let source2 = Observable.interval(250); 
 
Observable.interval(1000) 
    .withLatestFrom(source1, source2) 
    .subscribe(response =&gt; console.log(response)); 
</pre><p class="calibre8">Both <code class="literal">source1</code> and <code class="literal">source2</code> emit multiple values every second. However, <code class="literal">withLatestFrom()</code> re-emits their values only when <code class="literal">Observable.interval(1000)</code> emits a value.</p><p class="calibre8">The output from this demo is as follows:</p><pre class="programlisting">$ node with_latest_from_01.js  
[ 0, 5, 2 ] 
[ 1, 12, 6 ] 
[ 2, 19, 10 ] 
[ 3, 25, 14 ] 
[ 4, 31, 18 ] 
[ 5, 38, 22 ] 
[ 6, 45, 26 ] 
[ 7, 51, 30 ] 
</pre><p class="calibre8">Use cases for this operator are very similar to those for <code class="literal">combineLatest()</code>. We just have a better control of the re-emission, which could be useful, for example, to implement caching mechanisms where the 1-second interval could control when we want to refresh the cache.</p><p class="calibre8">While speaking of caching, we will have a look at the last and very nice example in this book.</p></div></div>

<div class="book" title="Operators specific for RxJS 5">
<div class="book" title="Caching HTTP requests with publishReplay() and take()"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_4"><a id="ch11lvl2sec105" class="calibre1"/>Caching HTTP requests with publishReplay() and take()</h2></div></div></div><p class="calibre8">This example is my favorite. I show this demo to people who want to start with RxJS and they're overwhelmed by the complexity and don't see the practical advantage.</p><p class="calibre8">A very common use case in frontend development is that we need to cache results from AJAX calls. For example, we might have a server that we want to query once a minute at most. All subsequent calls under one minute won't spawn another AJAX call but receive only the cached data.</p><p class="calibre8">This can all be done by leveraging the <code class="literal">publishReplay()</code> and <code class="literal">take()</code> operators:</p><pre class="programlisting">// cache_01.js 
const Rx = require('rxjs/Rx'); 
const Observable = Rx.Observable; 
 
var counter = 1; 
var updateTrigger = Observable.defer(() =&gt; mockDataFetch()) 
    .publishReplay(1, 1000) 
    .refCount(); 
 
function mockDataFetch() { 
    return Observable.of(counter++).delay(100); 
} 
 
function mockHttpCache() { 
    return updateTrigger.take(1); 
} 
</pre><p class="calibre8">We're creating mock requests with the <code class="literal">mockDataFetch()</code> function that increments the counter every time it's called (this is to make sure that we're not making more calls to the server than we think). Then, we delay this Observable to pretend it takes some time.</p><p class="calibre8">Every time we want to get current data from a cache or from a fresh AJAX request, we use the <code class="literal">mockHttpCache()</code> function that returns an Observable.</p><p class="calibre8">Let's have a look at how we schedule a couple of calls and then make sure that this really works as we expect from the console output. After this, we can explain why this works:</p><pre class="programlisting">mockHttpCache().toPromise() 
    .then(val =&gt; console.log("Response from 0:", val)); 
 
setTimeout(() =&gt; mockHttpCache().toPromise() 
    .then(val =&gt; console.log("Response from 200:", val)) 
, 200); 
 
setTimeout(() =&gt; mockHttpCache().toPromise() 
    .then(val =&gt; console.log("Response from 1200:", val)) 
, 1200); 
 
setTimeout(() =&gt; mockHttpCache().toPromise() 
    .then(val =&gt; console.log("Response from 1500:", val)) 
, 1500); 
 
setTimeout(() =&gt; mockHttpCache().toPromise() 
    .then(val =&gt; console.log("Response from 3500:", val)) 
, 3500); 
</pre><p class="calibre8">We're making five requests in total. The first two should receive the same response. The next two will receive another response, and the last one will have the third response. For illustrational purposes, we're caching responses only for 1 second.</p><p class="calibre8">Now, let's see the console output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ node cache_01.js </strong></span>
<span class="strong"><strong class="calibre17">Response from 0: 1</strong></span>
<span class="strong"><strong class="calibre17">Response from 200: 1</strong></span>
<span class="strong"><strong class="calibre17">Response from 1200: 2</strong></span>
<span class="strong"><strong class="calibre17">Response from 1500: 2</strong></span>
<span class="strong"><strong class="calibre17">Response from 3500: 3</strong></span>
</pre><p class="calibre8">So, it really works as we want; but how?</p><p class="calibre8">The <code class="literal">publishReplay(1, 1000)</code> operator multicasts responses for 1 second via <code class="literal">ReplaySubject</code> (see <a class="calibre1" title="Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension" href="part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d">
Chapter 8
</a>, <span class="strong"><em class="calibre18">Multicasting in RxPHP and PHP7 pthreads Extension</em></span>, for more info on multicasting). After 1 second, it discards the stored result.</p><p class="calibre8">When we call <code class="literal">mockHttpCache()</code>, one of these situations occur:</p><div class="book"><ul class="itemizedlist"><li class="listitem">We subscribe to <code class="literal">ReplaySubject</code> that already has a cached response. In that case, on subscription, it immediately calls <code class="literal">next()</code> and sends this value to its new subscriber. Since there's <code class="literal">take(1)</code> operator, it passes the value and the chain completes. The <code class="literal">ReplaySubject</code> then checks whether the subscriber has stopped after passing it the cached value. Thanks to <code class="literal">take(1)</code> it does stop, so <code class="literal">ReplaySubject</code> won't subscribe to the deferred Observable.</li><li class="listitem">We subscribe to <code class="literal">ReplaySubject</code>, but it doesn't have any valid response cached and/or it also needs to subscribe to the deferred Observable that triggers a new AJAX request. When the request is ready, it's passed down the chain where <code class="literal">take(1)</code> re-emits it and completes.</li></ul></div><p class="calibre8">So this was a pretty short and clever way to make already sophisticated functionality that would normally require using at least one <code class="literal">setTimeout()</code> and at a minimum two state variables to keep the cached response and the time it was created.</p></div></div>
<div class="book" title="Summary" id="2H1VQ1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec77" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">This final chapter was dedicated to RxJS 5 to show that while most principles are the same, there are a couple of differences that we can take advantage of.</p><p class="calibre8">After reading this chapter, you should know the differences between RxJS 4 and RxJS 5, what technologies are used to develop and deploy RxJS 5, how Node.js handles asynchronous code, and what operators are present in RxJS 5 already but aren't implemented in RxPHP yet.</p><p class="calibre8">Hopefully, you'll take the best out of RxJS and RxPHP and use it to write faster and more readable code yourself.</p></div></body></html>