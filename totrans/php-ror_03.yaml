- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Comparing Basic Ruby Syntax to PHP
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将基本 Ruby 语法与 PHP 比较
- en: Running scripts in PHP and Ruby is similar, though each language has its peculiarities.
    Similarly, both Ruby’s and PHP’s syntax can be strangely similar at times, as
    we saw in [*Chapter 1*](B19230_01.xhtml#_idTextAnchor015). However, if we are
    serious about becoming Ruby programmers, we will need to learn both the differences
    and the enhancements that Ruby brings to the table.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 和 Ruby 中运行脚本相似，尽管每种语言都有其独特之处。同样，Ruby 和 PHP 的语法有时也会出奇地相似，正如我们在[*第一章*](B19230_01.xhtml#_idTextAnchor015)中看到的。然而，如果我们认真想要成为
    Ruby 程序员，我们就需要学习 Ruby 带来的差异和增强。
- en: Let’s embark on this journey and start creating, executing, and debugging our
    own Ruby scripts with the resources that we already have from knowing PHP, and
    see Ruby’s language improvements over other languages. We’ll not only think in
    Ruby but program in “the Ruby way” too.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始这段旅程，利用我们从知道 PHP 获得的资源来创建、执行和调试我们自己的 Ruby 脚本，并看看 Ruby 语言相对于其他语言的改进。我们不仅会以
    Ruby 的思维方式思考，还会以“Ruby 方式”编程。
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Running Ruby code from the command line
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行运行 Ruby 代码
- en: Exploring types of variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索变量类型
- en: Using conditional statements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件语句
- en: Repeating code with loops
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用循环重复代码
- en: Using Ruby language enhancements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ruby 语言增强功能
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with this chapter, we will need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，我们需要以下内容：
- en: Any IDE to view/edit code (for example, SublimeText, Visual Studio Code, Notepad++
    Vim, Emacs, and so on)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何 IDE 来查看/编辑代码（例如，SublimeText，Visual Studio Code，Notepad++ Vim，Emacs 等）
- en: For macOS users, you will also need to have Xcode Command Line Tools installed
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 macOS 用户，您还需要安装 Xcode 命令行工具
- en: Ruby version 2.6 or later will need to be installed and ready to use
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby 版本 2.6 或更高版本需要安装并准备好使用
- en: The code presented in this chapter is available at [https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的代码可在[https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/)找到。
- en: Running Ruby code from the command line
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从命令行运行 Ruby 代码
- en: One of the first things we need to learn about when picking up Ruby is how to
    run our code and view the output directly on our screen. There are different ways
    to achieve this, but we will be doing so in the simplest of ways. While there
    are various ways to load code from the command line, we’ll start with one single
    file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习 Ruby 时，我们需要了解的第一件事之一是如何在我们的屏幕上直接运行我们的代码并查看输出。有不同方法可以实现这一点，但我们将以最简单的方式来做。虽然从命令行加载代码有多种方式，但我们将从一个文件开始。
- en: Running a simple code file
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行一个简单的代码文件
- en: As I mentioned in the introduction, running scripts in Ruby is simple and easy.
    Similar to running scripts in PHP, we can create a file, add Ruby code to it,
    and execute it with Ruby. Running or executing code simply means that we will
    have Ruby read (also referred to as parse) through our source code, and then translate
    it into a language that the computer can understand and process.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在引言中提到的，在 Ruby 中运行脚本简单且容易。与在 PHP 中运行脚本类似，我们可以创建一个文件，向其中添加 Ruby 代码，然后用 Ruby
    执行它。运行或执行代码简单来说就是 Ruby 将读取（也称为解析）我们的源代码，然后将其翻译成计算机可以理解和处理的语言。
- en: Let’s start with a simple example by creating a folder called `ruby_syntax`
    on our desktop. In that folder, create our source code file, which is called `running_ruby.rb`,
    with your IDE of choice.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 `ruby_syntax` 的文件夹开始，这个文件夹位于我们的桌面上。在那个文件夹中，创建我们的源代码文件，命名为 `running_ruby.rb`，使用您选择的
    IDE。
- en: 'Now, let’s add some code to our file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向我们的文件中添加一些代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let’s open a shell and go to the same folder we just created:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开一个 shell 并转到我们刚刚创建的相同文件夹：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once we are in this folder in our shell, we can run the script we just created
    with Ruby:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在 shell 中的这个文件夹里，我们可以用 Ruby 运行我们刚刚创建的脚本：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This should output the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会输出以下内容：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As I mentioned in [*Chapter 1*](B19230_01.xhtml#_idTextAnchor015), this syntax
    is strangely familiar to the PHP one. If we compared the two, we would have the
    following PHP equivalent:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[*第一章*](B19230_01.xhtml#_idTextAnchor015)中提到的，这种语法与 PHP 的语法非常相似。如果我们比较两者，我们会得到以下
    PHP 等价代码：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We would then run the example in the same way as the Ruby one, but with the
    PHP executable instead, like so:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照与 Ruby 一样的方式运行示例，但使用 PHP 可执行文件，如下所示：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The outcome would be the same as the Ruby one but with the string for PHP.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将与 Ruby 一样，但字符串为 PHP。
- en: 'Back to the Ruby example, and just like we did to the examples in [*Chapter
    1*](B19230_01.xhtml#_idTextAnchor015), let’s modify our Ruby code so that it’s
    slightly more readable:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 Ruby 的例子，就像我们在 [*第 1 章*](B19230_01.xhtml#_idTextAnchor015) 中的例子一样，让我们修改我们的
    Ruby 代码，使其稍微易于阅读：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Even though the syntax is slightly similar, the outcome is the same, with the
    advantage that it reads more naturally. While `print` is available in Ruby for
    outputting text for the user, you may also use `puts` or simply `p`. You’ll see
    this very often in Ruby.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管语法略有相似，但结果相同，而且它的优点是读起来更自然。虽然 Ruby 中有 `print` 用于向用户输出文本，但你也可以使用 `puts` 或简单地
    `p`。你会在 Ruby 中经常看到这一点。
- en: Loading a source code file with the load method
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `load` 方法加载源代码文件
- en: At this point, you know how to execute Ruby code in a single file. However,
    as our source code grows, it will become impractical to have a single source code
    file. That is why Ruby allows us to load source code from other source files.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经知道了如何在单个文件中执行 Ruby 代码。然而，随着源代码的增长，拥有一个单独的源代码文件将变得不切实际。这就是为什么 Ruby 允许我们从其他源文件加载源代码。
- en: 'Let’s see how to do this. First, we must create a file to be loaded – in this
    example, the file is called `my_library.rb` and contains some simple content:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何做到这一点。首先，我们必须创建一个要加载的文件——在这个例子中，文件名为 `my_library.rb`，并包含一些简单的内容：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'While we now have runnable Ruby code, we are not going to run `my_library.rb`
    directly, but rather let another script load its code. This is where the `load`
    method comes in. The `load` method takes a filename and its code and includes
    it in our execution. So, let’s create another file called `load_library.rb` with
    this content:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在有了可运行的 Ruby 代码，但我们不会直接运行 `my_library.rb`，而是让另一个脚本加载其代码。这就是 `load` 方法的作用。`load`
    方法接受一个文件名及其代码，并将其包含在我们的执行中。所以，让我们创建一个名为 `load_library.rb` 的文件，并包含以下内容：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, run the code with the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令运行代码：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of the script should be as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的输出应该是这样的：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `load_library.rb` file injects (or as its name implies, *loads*) the code
    from the `my_library.rb` file and executes it. This way, we can easily separate
    large chunks of code into smaller, more readable ones.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_library.rb` 文件注入（或者正如其名称所暗示的，*加载*）了 `my_library.rb` 文件中的代码并执行了它。这样，我们可以轻松地将大块代码分成更小、更易读的部分。'
- en: 'Now, what happens if we call the `load` method more than once in Ruby? Well,
    let’s try it out:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们多次在 Ruby 中调用 `load` 方法会发生什么？让我们试试看：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After running the command again, the output is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行命令后，输出如下：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From this behavior, we can infer that every time we load a file, its code will
    be executed, which is very useful when our files change multiple times during
    their execution – in these cases, the code is said to be dynamically changing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从这种行为中，我们可以推断出每次我们加载一个文件，其代码都会被执行，这在我们的文件在执行期间多次更改时非常有用——在这些情况下，代码被认为是动态更改的。
- en: As an example of dynamically changing code, let’s say we needed a script to
    include new parts of the code, but could not be stopped for doing so. In a case
    such as this, we would need the code to be constantly refreshed, and this is where
    the `load` method comes in. The `load` method refreshes the code every single
    time it comes across the file that’s changing – that is, it renews our code every
    time the Ruby engine detects a change. Otherwise, we would have to stop the execution
    every time we needed a new change in our code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 作为动态更改代码的例子，假设我们需要一个脚本来包含代码的新部分，但又不能因此停止。在这种情况下，我们需要代码不断刷新，这就是 `load` 方法的作用。每次
    `load` 方法遇到正在更改的文件时，它都会刷新代码——也就是说，每次 Ruby 引擎检测到更改时，它都会更新我们的代码。否则，每次我们需要代码中的新更改时，我们都需要停止执行。
- en: Ruby’s `load` method is similar to PHP’s `include` and `require` functions.
    However, Ruby’s `require` method is slightly different than the one in PHP, as
    we’ll see next.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 的 `load` 方法类似于 PHP 的 `include` 和 `require` 函数。然而，Ruby 的 `require` 方法与 PHP
    中的略有不同，正如我们接下来将要看到的。
- en: Loading a source code file with the require method
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `require` 方法加载源代码文件
- en: In contrast to the `load` method, sometimes, we just need the code to be executed
    only once, and for that, we can use the `require` method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `load` 方法相反，有时我们只需要代码执行一次，为此我们可以使用 `require` 方法。
- en: 'Let’s see it in action by creating another file called `require_library.rb`
    with the following content:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个名为 `require_library.rb` 的文件并包含以下内容来实际看看：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let’s run it in the same way that we ran the `load_library.rb` script:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以与运行 `load_library.rb` 脚本相同的方式运行它：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Initially, the output will be the same as when we ran the `load_library.rb`
    script:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 初始输出将与我们运行`load_library.rb`脚本时的输出相同：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However, notice that in this example, we included the dot slash prefix (`./`)
    before the filename. The `require` function needs either the absolute path or
    the relative path of the file – because the `my_library.rb` example is within
    the same folder, we use the relative path to the current folder, which would be
    `./`. In simple terms, the source code for `require_library.rb` would read as
    “inject the code that is in the `my_library.rb` file, which is in the same folder.”
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，在这个例子中，我们在文件名前包含了点斜杠前缀（`./`）。`require`函数需要文件的绝对路径或相对路径——因为`my_library.rb`示例位于同一文件夹中，我们使用当前文件夹的相对路径，即`./`。简单来说，`require_library.rb`的源代码将读取为“注入位于同一文件夹中的`my_library.rb`文件中的代码。”
- en: 'Now, let’s try calling the `require` method more than once:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试多次调用`require`方法：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s run it again with the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次用以下代码运行它：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To an experienced PHP developer, it should not be a surprise that the output
    is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于经验丰富的 PHP 开发者来说，输出如下应该不会令人惊讶：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Ruby’s `require` method works pretty much the same way as `include_once` and
    `require_once` from PHP. The Ruby interpreter only loads the code once, and whenever
    you try to load it again, the engine notices that you already loaded that code,
    so it doesn’t load it again, saving memory and resources.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 的 `require` 方法几乎与 PHP 中的 `include_once` 和 `require_once` 一样工作。Ruby 解释器只加载代码一次，无论你何时尝试再次加载它，引擎都会注意到你已经加载了那段代码，因此不会再次加载，节省内存和资源。
- en: 'One last thing we may wish to consider while using the `require` method is
    that it is not compulsory to include the file extension, so this will also work:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`require`方法时，我们可能还想考虑的一件事是，不强制包含文件扩展名，所以这也适用：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'By not using the file extension, our code looks slightly cleaner. Now, how
    is the `require` method useful, you may ask? Well, whenever you’re writing libraries
    that will be used in several parts of your code, you don’t have to worry about
    loading your library multiple times as the `require` method will only load it
    once, thus saving memory resources. We’ll keep it simple for now, but if you are
    interested in more options for importing code, there is also the `require_relative`
    method: [https://apidock.com/ruby/Kernel/require_relative](https://apidock.com/ruby/Kernel/require_relative).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不使用文件扩展名，我们的代码看起来稍微干净一些。现在，你可能想知道`require`方法有什么用？好吧，无论何时你正在编写将在代码的多个部分中使用的库，你不必担心多次加载你的库，因为`require`方法只会加载一次，从而节省内存资源。我们现在保持简单，但如果你对导入代码的更多选项感兴趣，还有`require_relative`方法：[https://apidock.com/ruby/Kernel/require_relative](https://apidock.com/ruby/Kernel/require_relative)。
- en: Ruby classes and modules
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ruby 类和模块
- en: In Ruby, modules are a way to group code so that it can be reused. Specifically,
    modules are collections of methods and constants that can be injected into classes.
    By themselves, modules aren’t useful as you can’t use them in an isolated manner.
    We use modules to add functionality to a class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，模块是一种将代码分组以便重用的方式。具体来说，模块是方法集合和常量的集合，可以注入到类中。模块本身并没有什么用，因为不能以独立的方式使用它们。我们使用模块向类添加功能。
- en: A class, as you probably know, is a blueprint of an abstraction from the real
    world taken to the programming world. A class can have different methods to represent
    actions and attributes to represent values. A class can be enhanced by including
    additional methods and constants from a module. So, in simple terms, a class can
    attach methods and constants from a module – and that’s what the `include` method
    does.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 类，正如你可能知道的，是从现实世界抽象到编程世界的蓝图。一个类可以有不同的方法来表示动作，以及属性来表示值。一个类可以通过包含来自模块的额外方法和常量来增强。所以，简单来说，一个类可以附加来自模块的方法和常量——这正是`include`方法所做的事情。
- en: 'Let’s look at this in a simplified example. Create a file called `include_module.rb`
    with the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简化的例子来看看。创建一个名为`include_module.rb`的文件，并包含以下代码：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we’re creating a simple empty class called `MyClass` with no methods.
    Now, let’s create an instance of this class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们创建了一个简单的空类`MyClass`，没有方法。现在，让我们创建这个类的实例：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can’t do much with this class as it is empty, so let’s add a `Utilities`
    module to it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个类是空的，我们无法用它做很多事情，所以让我们向它添加一个`Utilities`模块：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And just like the previous class (`MyClass`), this is just an empty module.
    Let’s add a method called `debug` to our module so that both our class and module
    end up looking like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的类（`MyClass`）一样，这只是一个空模块。让我们给我们的模块添加一个名为`debug`的方法，这样我们的类和模块最终看起来就像这样：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With this code, we’ve declared a method named `debug` that prints the text “We
    are debugging.” Can we add this method to `MyClass`? Well, this is where the `include`
    method comes in.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们声明了一个名为`debug`的方法，它会打印文本“我们正在调试。”我们能将这个方法添加到`MyClass`中吗？嗯，这就是`include`方法发挥作用的地方。
- en: The include method
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含方法
- en: 'At this point, we should incorporate this newly built debug method with the
    `include` method because, as it stands now, the `debug` method is not currently
    being used. It’s merely defined. With the `include` method, we can now “attach”
    the `debug` method to our class by adding this to the end of the file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该将这个新构建的调试方法与`include`方法结合起来，因为现在，`debug`方法尚未被使用。它仅仅是被定义了。通过`include`方法，我们现在可以通过在文件末尾添加以下内容来“附加”`debug`方法到我们的类中：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This simply means that the `debug` method is now available to `my_class_instance`.
    Let’s call our newly included `debug` method from our class instance. Your final
    code should look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅意味着`debug`方法现在对`my_class_instance`可用。让我们从我们的类实例中调用新添加的`debug`方法。您的最终代码应该看起来像这样：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, for the moment of truth – let’s run it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，到了关键时刻——让我们运行它：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will output the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This means that we have successfully attached the debug method to our empty
    class. This comes in handy whenever we need modules that are reused throughout
    our code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们已经成功地将调试方法附加到我们的空类中。每当我们需要在整个代码中重复使用的模块时，这会非常有用。
- en: The equivalent to Ruby’s `include` method in PHP is a resource called `traits`.
    If you’re interested in this topic, check out [https://www.php.net/manual/en/language.oop5.traits.php](https://www.php.net/manual/en/language.oop5.traits.php).
    This might be a little complicated to grasp at first since we haven’t looked at
    object-oriented programming in Ruby so far, but don’t worry if you don’t fully
    understand it at this point – we will get there.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中与Ruby的`include`方法等效的资源称为`traits`。如果您对这个主题感兴趣，请查看[https://www.php.net/manual/en/language.oop5.traits.php](https://www.php.net/manual/en/language.oop5.traits.php)。由于我们迄今为止还没有在Ruby中查看面向对象编程，这可能会一开始有点难以理解，但请不要担心您现在还没有完全理解它——我们将会达到那个水平。
- en: Interactive Ruby Shell (IRB)
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互式Ruby Shell (IRB)
- en: 'Sometimes, you may want to quickly test a very small piece of code and it may
    seem like a hassle to create a file, add the code, and then run it. Maybe we just
    want to test the syntax of a single line of code. Well, we don’t have to create
    a file to just test a line of code. Just like in other languages, such as Python
    or even PHP, we have a tool just for that in Ruby: it’s the **Interactive Ruby
    Shell**, better known as **IRB**. Let’s take a look at it.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您可能想快速测试一小段代码，并且创建文件、添加代码然后运行它可能看起来很麻烦。也许我们只想测试一行代码的语法。好吧，我们不需要创建一个文件来测试一行代码。就像在其他语言中一样，例如Python或PHP，Ruby中有一个专门为此的工具：它就是**交互式Ruby
    Shell**，也被称为**IRB**。让我们看看它。
- en: 'Within a shell, run the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell中运行以下命令：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will make your shell look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使您的shell看起来像这样：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This shell works as a real-time Ruby interpreter – that is, after the `>` symbol,
    we can start typing Ruby commands that will be interpreted and executed right
    away. As a simple example, let’s add 1 and 1:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个shell作为一个实时Ruby解释器工作——也就是说，在`>`符号之后，我们可以开始输入Ruby命令，这些命令将被立即解释和执行。作为一个简单的例子，让我们加1和1：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will return the following result:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下结果：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This comes in quite handy when you quickly want to test syntax and operations,
    or even view the content of a class. It works in the same way as the Ruby binary
    we’ve been using in previous examples.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想快速测试语法和操作，或者甚至查看类的内容时，这非常有用。它的工作方式与我们在前面的例子中使用过的Ruby二进制文件相同。
- en: 'So, as a final example, let’s load the `include_module` file we created, but
    now with this interactive shell:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，作为一个最后的例子，让我们加载我们创建的`include_module`文件，但现在使用这个交互式shell：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that we’ve included the code in our shell with the `require` method, we
    can use this loaded code in our `irb` session. Since we have the `MyClass` definition
    available, we can use it as a blueprint to create an instance of `MyClass`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用`require`方法将代码包含到我们的shell中，我们可以在`irb`会话中使用这个加载的代码。由于我们有`MyClass`的定义可用，我们可以将其用作蓝图来创建`MyClass`的一个实例：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This returns a unique identifier that Ruby uses internally to know where the
    instance resides in the computer’s memory:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个Ruby内部使用的唯一标识符，以确定实例在计算机内存中的位置：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note that we can call the `debug` method on our newly created instance too:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们也可以在我们的新创建的实例上调用`debug`方法：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And just like before, we get the same output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们得到了相同的输出：
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To exit this interactive shell, simply type `exit` to make your shell go back
    to normal. In case you were wondering, there is a similar shell in PHP called
    interactive shell. Be sure to check out this page if you’re interested in this
    topic: [https://www.php.net/manual/en/features.commandline.interactive.php](https://www.php.net/manual/en/features.commandline.interactive.php).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出这个交互式shell，只需输入`exit`，使你的shell恢复正常。如果你想知道，PHP中也有一个类似的shell，称为交互式shell。如果你对这个主题感兴趣，请务必查看这个页面：[https://www.php.net/manual/en/features.commandline.interactive.php](https://www.php.net/manual/en/features.commandline.interactive.php)。
- en: 'At this point, we can proudly say that we now know how to run Ruby code in
    a couple of different ways. We also know how to use a single source code file,
    or load code from a separate source code file. Either way, whether you’re running
    your code with the Ruby binary or with the interactive shell, you’re going to
    need a way to store and use values, which brings us to our next topic: variables.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以自豪地说，我们现在知道如何以几种不同的方式运行Ruby代码。我们还知道如何使用单个源代码文件，或者从单独的源代码文件中加载代码。无论哪种方式，无论是使用Ruby二进制文件还是使用交互式shell运行你的代码，你都需要一种方式来存储和使用值，这把我们带到了下一个主题：变量。
- en: Exploring types of variables
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索变量类型
- en: 'Variables in Ruby have the same utility as in other programming languages:
    they are mutable containers for values. Simply put, variables are used to save
    values for later usage. These values may change over time, or even change the
    type of data they contain.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby中的变量与其他编程语言中的变量具有相同的效用：它们是用于存储值的可变容器。简单来说，变量用于保存值以供以后使用。这些值可能会随时间变化，甚至改变它们包含的数据类型。
- en: Just like with PHP, Ruby is dynamically typed (or duck typing), which means
    that the interpreter infers what type of data we are handling at runtime. We don’t
    need to tell Ruby or PHP that a variable is either a string, a number, or a Boolean.
    One difference with PHP, however, is that in later versions of PHP, you *can*
    specify what type of data to use, especially in object-oriented PHP. However,
    even with this “enhancement,” the majority of the language remains duck-typed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 就像PHP一样，Ruby是动态类型的（或称为鸭子类型），这意味着解释器在运行时会推断我们正在处理的数据类型。我们不需要告诉Ruby或PHP一个变量是字符串、数字还是布尔值。然而，与PHP的一个区别是，在PHP的后续版本中，你可以指定要使用的数据类型，尤其是在面向对象的PHP中。然而，即使有这种“增强”，语言的大部分仍然是鸭子类型。
- en: 'How does this affect us as developers? Well, let’s take a look at a simple
    example. First, open an IRS. Type the following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们作为开发者有何影响？好吧，让我们看看一个简单的例子。首先，打开一个IRS。输入以下命令：
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As we saw previously, once we type this command, the shell will look like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，一旦我们输入这个命令，shell将看起来像这样：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, type the following declarations:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入以下声明：
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Note that though the information in the previous code block is what you should
    type, it will look like this in the prompt:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管前一个代码块中的信息是你应该输入的内容，但在提示符中它看起来是这样的：
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: One of the core features of the Ruby language is that with every line of code,
    Ruby will attempt to return a value. If you declare a variable, Ruby will return
    the assigned value. So, when we added the `name` variable, Ruby returned the value
    of the variable – that is, `"Oscar"`. This comes in handy when we use this behavior
    to obtain the type of data a variable is holding. Ruby “knows” what type of data
    this `name` variable contains.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby语言的一个核心特性是，每行代码，Ruby都会尝试返回一个值。如果你声明一个变量，Ruby将返回分配的值。所以，当我们添加`name`变量时，Ruby返回了变量的值——即`"Oscar"`。当我们使用这种行为来获取变量所持有的数据类型时，这很有用。Ruby“知道”这个`name`变量包含的数据类型。
- en: 'To do this, we can make use of the internal `class` method. Just type `name.class`;
    `irb` should return something similar to this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以使用内部的`class`方法。只需输入`name.class`；`irb`应该返回类似以下的内容：
- en: '[PRE41]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The Ruby interpreter determined that the `name` variable is a string, or in
    simple terms, text. The same can be done to the other variables we just declared,
    such as the `age` variable:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby解释器确定`name`变量是一个字符串，或者简单地说，是文本。同样的方法也可以用于我们刚刚声明的其他变量，例如`age`变量：
- en: '[PRE42]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And in that same manner, the `is_married` variable is a Boolean variable. We
    can confirm this by getting the class of that variable:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，`is_married`变量是一个布尔变量。我们可以通过获取该变量的类来确认这一点：
- en: '[PRE43]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This means that the `is_married` variable has a Boolean value of `true`. We
    can do the same with the `books_read_this_week` variable:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`is_married`变量有一个布尔值`true`。我们可以用同样的方法处理`books_read_this_week`变量：
- en: '[PRE44]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We did not explicitly tell Ruby what type of variables we were going to use,
    yet Ruby “knew” this automagically. This means that we don’t have to worry about
    telling Ruby the type of data we are going to use. This is pragmatic for the most
    part, but I must admit I’ve been in scenarios where it would have helped to have
    known the type of data before runtime.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有明确告诉Ruby我们将使用什么类型的变量，但Ruby“自动”知道了这一点。这意味着我们不必担心在运行时告诉Ruby我们将使用的数据类型。这在大多数情况下是实用的，但我必须承认，我确实遇到过在运行前知道数据类型会很有帮助的情况。
- en: 'So far, in our previous examples, we’ve looked at four different types of variables
    in Ruby: strings, integers, Booleans (true or false), and float values. However,
    there are three more types of variables that we should look at in depth: arrays,
    hashes, and symbols. We’ll go through each of them now.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的前几个例子中，我们已经查看了Ruby中的四种不同类型的变量：字符串、整数、布尔值（true或false）和浮点值。然而，还有三种其他类型的变量我们应该深入了解：数组、哈希和符号。我们现在将逐一介绍它们。
- en: Arrays
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: Arrays are a way of grouping common variables. Coming from a PHP background,
    arrays can be very simple to understand both conceptually and syntactically. Conceptually,
    we put together similar or related values. An example could be grouping a person’s
    phone numbers in a single variable. Another example could be storing a physical
    address by saving the street, number, city, zip code, and more all in the same
    variable. As we will see next, the Ruby syntax is very similar to the PHP one.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一种将常见变量分组的方法。从PHP背景来看，数组在概念和语法上都可以很容易理解。从概念上讲，我们将相似或相关的值组合在一起。一个例子可能是将一个人的电话号码组合在一个变量中。另一个例子可能是通过保存街道、门牌号、城市、邮编等来存储物理地址，所有这些都在同一个变量中。正如我们接下来将要看到的，Ruby的语法与PHP非常相似。
- en: 'Arrays let us take related values and save them in a single variable. As an
    example, let’s say we wanted to save my siblings’ ages. We could create an array
    of integers that represented my siblings’ ages. Let’s do just that in PHP and
    Ruby and compare both syntaxes. This would be the PHP syntax:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 数组允许我们将相关的值保存在一个单独的变量中。例如，假设我们想要保存我兄弟姐妹的年龄。我们可以创建一个表示我兄弟姐妹年龄的整数数组。让我们在PHP和Ruby中这样做，并比较两种语法。这将PHP语法：
- en: '[PRE45]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And this would be the Ruby syntax:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 而这将Ruby语法：
- en: '[PRE46]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Except for `$` and `;`,, both pieces of code are the same; this goes to show
    that understanding the concepts of Ruby arrays should not be difficult if you’re
    from a PHP background. While there are other ways to declare arrays, we’ll keep
    the syntax simple for now.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`$`和`;`之外，两段代码是相同的；这表明，如果你有PHP背景，理解Ruby数组的概念不应该很难。虽然还有其他声明数组的方法，但我们现在将保持语法简单。
- en: Now that we understand how to declare arrays, let’s look at some practical uses
    for them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何声明数组，让我们看看它们的实际用途。
- en: 'Arrays can have other types of values in Ruby (not just numbers). Let’s say
    I wanted to list the instruments someone knows how to play. We could make a list
    of strings and name it `instruments_played`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby中的数组可以包含其他类型的值（不仅仅是数字）。假设我想列出某人会演奏的乐器。我们可以创建一个字符串列表并命名为`instruments_played`：
- en: '[PRE47]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, we have grouped related values (in this case instruments) in
    a single variable. We’ve created a list ready to be used within our code. This
    type of array, as it was declared, has an internal counter to reference each value.
    This internal counter starts with 0, so the first value (`guitar`) would be contained
    in `instruments_played[0]`, the second value (`drums`) would be contained in `instruments_played[1]`,
    and so on.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将相关的值（在这种情况下是乐器）组合在一个单独的变量中。我们创建了一个列表，可以在我们的代码中使用。这种类型的数组，正如它所声明的，有一个内部计数器来引用每个值。这个内部计数器从0开始，所以第一个值（`guitar`）将包含在`instruments_played[0]`中，第二个值（`drums`）将包含在`instruments_played[1]`中，以此类推。
- en: 'Should we want to print out all of the instruments on the screen, we could
    print each instrument one by one:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在屏幕上打印出所有的乐器，我们可以逐个打印每个乐器：
- en: '[PRE48]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'However, this is tedious and impractical, and as you may have guessed, we have
    a better programming way of doing this. Instead of counting one by one, we can
    iterate through all values of the array using the `do` statement:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做既繁琐又不实用，正如你可能已经猜到的，我们有一个更好的编程方式来做这件事。我们不是逐个计数，而是可以使用 `do` 语句遍历数组的所有值：
- en: '[PRE49]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The three-dot notation (`…`) might be new and even weird to someone coming
    from PHP, but if you just read through the code, it almost makes sense. This notation
    is called range and you’ll see it used often in Ruby. The notation creates a counter
    that goes from 0 to a value less than 4 (3, in this case), then increments the
    counter by 1\. This counter is then assigned to the `i` variable. The example
    would read something like, “For the `i` variable, create a cycle that starts with
    0, ends in 3, increases by 1, and prints each value of the array one by one.”
    The output would look something like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 三点符号 (`…`) 可能对来自 PHP 的人来说既新又奇怪，但如果你只是阅读代码，它几乎是有道理的。这种符号被称为范围，你会在 Ruby 中经常看到它的使用。这个符号创建了一个计数器，从
    0 开始，到小于 4 的值（在这个例子中是 3），然后每次增加 1。然后这个计数器被分配给 `i` 变量。这个例子可以读作，“对于 `i` 变量，创建一个从
    0 开始，到 3 结束，每次增加 1，并逐个打印数组值的循环。” 输出将看起来像这样：
- en: '[PRE50]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Did you notice that the `…` notation excludes the number 4, equivalent to [0,4]
    in mathematical notation? Well, what if we wanted the range to be inclusive –
    for example, [0,3] – which would include the last number? Ruby also has a two-dot
    notation (`..`) that *does* include the last number in its range. So, we could
    rewrite the example as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到 `…` 符号排除了数字 4，相当于数学符号中的 [0,4] 吗？那么，如果我们想使范围包含最后一个数字——例如，[0,3]——会发生什么呢？Ruby
    也有一个两点符号 (`..`)，它确实包含其范围内的最后一个数字。因此，我们可以将示例重写如下：
- en: '[PRE51]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output would be the same as the previous example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将与上一个例子相同：
- en: '[PRE52]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You may use the three-dot or the two-dot notation as you see fit. If you are
    more interested in the topic of ranges, I suggest that you look at the documentation
    regarding this topic: [https://ruby-doc.org/core-2.5.1/Range.html](https://ruby-doc.org/core-2.5.1/Range.html).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要使用三点或两点符号。如果你对范围的主题更感兴趣，我建议你查看有关此主题的文档：[https://ruby-doc.org/core-2.5.1/Range.html](https://ruby-doc.org/core-2.5.1/Range.html)。
- en: 'Now, let’s get back to arrays. Just like PHP, Ruby has some internal methods
    to work with arrays. As an example of this parallel design, PHP has a function
    to tell us the size of an array. The function is called `count()` and has a Ruby
    equivalent called `size()`. Just remember that everything in Ruby is an object,
    so you would not use `size(instruments_played)` as you would in PHP. Instead,
    to print the number of elements of our array, we would call the `size()` method
    as a method of the `instruments_played` array:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到数组。就像 PHP 一样，Ruby 也有一些内部方法来处理数组。作为一个并行设计的例子，PHP 有一个函数可以告诉我们数组的大小。这个函数叫做
    `count()`，在 Ruby 中有一个等效的函数叫做 `size()`。只需记住，Ruby 中的所有东西都是对象，所以你不会像在 PHP 中那样使用 `size(instruments_played)`。相反，为了打印我们数组中的元素数量，我们会调用
    `size()` 方法作为 `instruments_played` 数组的方法：
- en: '[PRE53]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Since the array has four elements, we would get an output of `4`. Additionally,
    there is another method that does the same thing called `length`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组有四个元素，我们会得到一个输出为 `4`。此外，还有一个做同样事情的方法叫做 `length`。
- en: 'Two more internal methods that I find extremely useful are `first` and `last`.
    These methods (as we can infer from their names) let us fetch the first and last
    elements of the array, respectively. Let’s try the `first` method with some variable
    interpolation:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现另外两个内部方法极其有用，它们是 `first` 和 `last`。这些方法（如我们从它们的名字中推断出的）允许我们分别获取数组的第一个和最后一个元素。让我们尝试使用一些变量插值来使用
    `first` 方法：
- en: '[PRE54]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This would output the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE55]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `last` method works in the same way:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`last` 方法以相同的方式工作：'
- en: '[PRE56]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This would output as expected:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按预期输出：
- en: '[PRE57]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see, we’ve combined a string and a variable’s content to create a
    new string. This combination is referred to as variable interpolation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已经将字符串和变量的内容结合起来创建了一个新的字符串。这种组合被称为变量插值。
- en: Variable interpolation
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量插值
- en: 'Variable interpolation (a term you will hear a lot in programming) involves
    substituting a variable with its value. It’s extremely useful when printing messages
    and/or showing data to users. When used correctly, variable interpolation lets
    us embed a variable value inside a string. Let’s take the code from our previous
    example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 变量插值（这是一个你在编程中会经常听到的术语）涉及用变量的值替换变量。当打印消息和/或向用户展示数据时，这非常实用。当正确使用时，变量插值允许我们在字符串中嵌入变量值。让我们看看我们之前的示例中的代码：
- en: '[PRE58]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There are a couple of layers to the string interpolation feature, so let’s analyze
    it in parts.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串插值功能有几个层次，所以让我们分部分分析它。
- en: First, on the second line of the code, we can see that, inside the string, we
    have added a special block, which starts with the `#` symbol followed by a set
    of curly brackets ( `#{ }` ). When used inside a string, this block determines
    that we are going to use interpolation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在代码的第二行，我们可以看到，在字符串内部，我们添加了一个特殊的块，它以`#`符号开头，后跟一系列花括号（`#{ }`）。当在字符串中使用时，这个块确定我们将使用插值。
- en: Secondly, everything inside the curly brackets will be interpreted and returned.
    In this example, the code inside the curly brackets is `instruments_played.last`,
    which holds the last element of the array. This last element of the array will
    be returned as part of the string, thus finalizing the interpolation. This only
    works when the string is defined with double quotes (`“”`).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，花括号内的所有内容都将被解释并返回。在这个例子中，花括号内的代码是`instruments_played.last`，它包含数组的最后一个元素。这个数组的最后一个元素将作为字符串的一部分返回，从而完成插值。这仅当字符串用双引号定义时才有效。
- en: Combining array types
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合数组类型
- en: 'So far, we’ve seen arrays that hold the same type of data – we had an array
    exclusively made of strings and another array exclusively made of integers. But
    one last feature worth noting regarding Ruby arrays is that they can also combine
    different variable types within the same array. As a random example, let’s add
    unrelated values to an array:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到了包含相同类型数据的数组——我们有一个仅由字符串组成的数组，另一个仅由整数组成的数组。但关于Ruby数组，还有一个值得注意的最后一个特性，即它们可以在同一个数组中组合不同的变量类型。作为一个随机示例，让我们向一个数组添加一些无关的值：
- en: '[PRE59]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this array, we are combining different types of data (integers, strings,
    Booleans, and floating points) into a single array. Not all languages support
    this behavior within arrays, but both Ruby and PHP do.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个数组中，我们正在将不同类型的数据（整数、字符串、布尔值和浮点数）组合成一个单一数组。并非所有语言都支持数组内的这种行为，但Ruby和PHP都支持。
- en: As we mentioned when we started looking at variable types, Ruby is dynamically
    typed. One of the features of a dynamically typed language is that arrays can
    combine the type of data they hold. In contrast, in a strongly typed language
    such as Java, arrays are forced to have the same type of data on each element
    – that is, you can only have an array of integers or only an array of strings.
    That is not to say that Ruby is better than Java or that, in general, strongly
    typed languages are better than dynamically typed languages. They just have different
    designs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在开始查看变量类型时提到的，Ruby是动态类型的。动态类型语言的一个特性是数组可以组合它们所持有的数据类型。相比之下，在强类型语言（如Java）中，数组被迫在每个元素上具有相同类型的数据——也就是说，你只能有一个整数数组或只能有一个字符串数组。这并不是说Ruby比Java好，或者一般来说，强类型语言比动态类型语言好。它们只是有不同的设计。
- en: 'If you’re interested in learning more regarding the subject of arrays, please
    take a look at the official Ruby documentation: [https://ruby-doc.org/core-2.7.0/Array.html](https://ruby-doc.org/core-2.7.0/Array.html).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个主题的数组感兴趣，请查看官方Ruby文档：[https://ruby-doc.org/core-2.7.0/Array.html](https://ruby-doc.org/core-2.7.0/Array.html)。
- en: Hashes
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hashes
- en: 'Now, let’s take a look at another type of variable that PHP developers will
    also understand very easily: hashes. A hash is an array but the main difference
    is that it has textual indexes instead of numbered indexes. Hashes are very similar
    to arrays in their behavior, but with the difference that we use strings to reference
    certain values. In PHP, these are known as associative arrays.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一种PHP开发者也会很容易理解的变量类型：hashes。hash是一个数组，但主要区别在于它有文本索引而不是数字索引。hashes在行为上与数组非常相似，但不同之处在于我们使用字符串来引用某些值。在PHP中，这些被称为关联数组。
- en: 'Let’s see an example in action. Here, we have a hash with the index in English
    and the value in Spanish:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个实际例子。这里，我们有一个索引为英语、值为西班牙语的hash：
- en: '[PRE60]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Similar to what we could do with an array, to get the value of a single index,
    we could type the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们可以用数组做的，要获取单个索引的值，我们可以输入以下内容：
- en: '[PRE61]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We would get the following output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会得到以下输出：
- en: '[PRE62]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As you can see, the index is a string and is more readable to a human. It’s
    this readability where a hash can come in handy. Let’s rewrite the first example
    we used at the start of the *Exploring types of variables* section so that it
    uses a hash:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，索引是一个字符串，对人类来说更易读。正是在这种可读性上，哈希表可以派上用场。让我们重写我们在*探索变量类型*部分开始时使用的第一个例子，使其使用哈希表：
- en: '[PRE63]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Instead of having separate variables for `name`, `age`, `is_married`, and `books_read_this_week`,
    we have a hash that groups all of these values into a single variable called `person`.
    Now, we can reference each index, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要为`name`、`age`、`is_married`和`books_read_this_week`分别设置单独的变量，我们可以用一个哈希表将这些值组合成一个名为`person`的单个变量。现在，我们可以像以下这样引用每个索引：
- en: '[PRE64]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Additionally, we could print a very readable message with the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以使用以下方式打印一个非常易读的消息：
- en: '[PRE65]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Even for a developer who is just starting Ruby, this is not just readable but
    understandable regarding the intent of the code. As expected, it would output
    the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对于一个刚开始学习Ruby的开发者来说，这不仅是可读的，而且从代码的意图来看也是可理解的。正如预期的那样，它会输出以下内容：
- en: '[PRE66]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Hashes are super useful when working with mapped data that needs to be read
    by a human. It’s also useful when you’re working with data that is changing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理需要由人类读取的映射数据时，哈希表非常有用。当你处理正在变化的数据时，它也很有用。
- en: This brings us to the last variable type that we’re going to see, which I must
    say is more complicated than I wish it were. The types of variables we’ve seen
    so far are mutable, which means that they can be changed. However, sometimes,
    we don’t need certain values to change – we need more of a location where this
    value is stored. Symbols do just this.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这把我们带到了我们将要看到的最后一种变量类型，我必须说它比我希望的要复杂。我们迄今为止看到的变量类型是可变的，这意味着它们可以被更改。然而，有时我们不需要某些值改变——我们需要一个存储这个值的位置。符号正是这样做的。
- en: Symbols
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号
- en: Symbols are highly optimized identifiers that map immutable strings to fixed
    internal values. They are also immutable strings themselves – that is, they do
    not change their value.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 符号是高度优化的标识符，它们将不可变的字符串映射到固定的内部值。它们本身也是不可变的字符串——也就是说，它们的值不会改变。
- en: 'The concept is a bit complex, but I believe it will be more understandable
    with an example. Let’s take a simple string and view what its value is pointing
    to. So, run this code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念有点复杂，但我相信通过一个例子会更容易理解。让我们用一个简单的字符串来看看它的值指向什么。所以，运行以下代码：
- en: '[PRE67]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'When you create a string, Ruby will take the string object and internally save
    it somewhere in memory. The `object_id` method saves this internal unique identifier.
    Notice what happens when you call the same line a couple of times:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个字符串时，Ruby会将在内存中某个地方保存字符串对象。`object_id`方法保存这个内部唯一标识符。注意当你多次调用同一行时会发生什么：
- en: '[PRE68]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The first string is pointing to a different address than the second and third
    strings. So, every time we type the `name` string, Ruby creates and stores a brand
    new string. Even though they have the same value, they are still different. As
    an analogy, it would be like having a file with the same name but in different
    folders. Even if the files had the same contents, they are still different files.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符串指向的地址与第二个和第三个字符串不同。所以，每次我们输入`name`字符串时，Ruby都会创建并存储一个新的字符串。即使它们的值相同，它们仍然是不同的。作为一个类比，这就像有相同名称但位于不同文件夹的文件。即使文件有相同的内容，它们仍然是不同的文件。
- en: 'This is not the same with symbols. Symbols refer to the same memory location.
    Let’s try the same example with symbols:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这与符号不同。符号指的是相同的内存位置。让我们用符号尝试相同的例子：
- en: '[PRE69]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This should also return a unique identifier number. However, what happens when
    we call this same code multiple times?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这也应该返回一个唯一的标识符号码。然而，当我们多次调用相同的代码时会发生什么呢？
- en: '[PRE70]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Instead of returning different random numbers, this time, we get the same (though
    still random) number. This is because every time we call `:name`, the Ruby interpreter
    is looking at the same location in memory. Using the same analogy, it would be
    like creating a unique file, and then whenever we needed the file again, we would
    create links that would point to that original file. So, even if the links were
    in different folders, they would point to the same file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 与返回不同的随机数不同，这次我们得到的是相同的（尽管仍然是随机的）数字。这是因为每次我们调用 `:name` 时，Ruby 解释器都在查看内存中的同一位置。使用相同的类比，这就像创建一个唯一的文件，然后每次我们需要该文件时，我们都会创建指向原始文件的链接。所以，即使链接在不同的文件夹中，它们也会指向同一个文件。
- en: 'We won’t dive into this subject further for now as it’s enough to just understand
    the basics of it, but we will see more examples in future chapters, particularly
    the Ruby on Rails ones. At the moment, just remember this good rule of thumb:
    use a symbol when the identity of an object is important. Should the content be
    more important, use a string.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会深入探讨这个主题，因为只需要理解其基本知识就足够了，但我们在未来的章节中会看到更多示例，特别是 Ruby on Rails 的示例。目前，只需记住这个好的经验法则：当对象的身份很重要时使用符号。如果内容更重要，则使用字符串。
- en: 'If you would like to know more about symbols now, the following website is
    a great resource: [https://medium.com/@lcriswell/ruby-symbols-vs-strings-248842529fd9](https://medium.com/@lcriswell/ruby-symbols-vs-strings-248842529fd9).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在想了解更多关于符号的信息，以下网站是一个很好的资源：[https://medium.com/@lcriswell/ruby-symbols-vs-strings-248842529fd9](https://medium.com/@lcriswell/ruby-symbols-vs-strings-248842529fd9)。
- en: So far, we’ve learned all about variables. But what good is a variable if we
    can’t make decisions regarding these variables? That’s our next topic.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了所有关于变量的知识。但如果我们不能对变量做出决策，变量有什么用呢？这是我们下一个话题。
- en: Using conditional statements
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用条件语句
- en: Now that we know what types of variables we can use in Ruby, let’s give these
    variables some more practical use.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了在 Ruby 中可以使用哪些类型的变量，让我们给这些变量一些更实用的用途。
- en: The if statement
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if 语句
- en: 'By now, we should all be familiar with the `if` statement and its structure:
    if a sentence is true, the code should do or return something.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们都应该熟悉 `if` 语句及其结构：如果句子为真，代码应该执行或返回某些内容。
- en: 'Let’s take the person hash that we used in the previous section as our base:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以前面章节中使用的 person 哈希作为基础：
- en: '[PRE71]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Using that, we can create a basic `if` statement:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它，我们可以创建一个基本的 `if` 语句：
- en: '[PRE72]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This is pretty much self-explanatory. This would read: “If the value in `person["married"]`
    is equal to true, then print `Person is married`.” The `end` keyword limits when
    the `if` statement is done – that is, anything after the `end` keyword is not
    part of the block. You’ll see the end `key` keyword a lot in Ruby – just keep
    in mind that it is used to delimit certain blocks of code.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是自我解释的。这会读作：“如果 `person["married"]` 中的值等于 true，那么打印 `Person is married`。”
    `end` 关键字限制了 `if` 语句何时完成——也就是说，`end` 关键字之后的内容不是代码块的一部分。你会在 Ruby 中经常看到 `end` 关键字——只需记住，它用于界定特定的代码块。
- en: 'While the previous code is useful, there is a better way to write this – the
    “Ruby way.” First, we remove `== true` and if we are only going to execute a single
    action, we can write it in one line:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的代码很有用，但还有更好的写法——即“Ruby 方式”。首先，我们移除 `== true`，如果我们只打算执行一个动作，我们可以将其写在一行中：
- en: '[PRE73]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This reads much like a sentence and you’ll see a lot of Rubyists using this
    useful one-liner.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这读起来就像一个句子，你会在很多 Ruby 程序员中使用这个有用的单行代码。
- en: The if-else statement
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if-else 语句
- en: 'If you need a different action in case the value is not true, then you should
    use the `if-else` structure:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在值不为 true 的情况下需要不同的操作，那么你应该使用 `if-else` 结构：
- en: '[PRE74]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This would output the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE75]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Just remember, the `if` statement evaluates the condition. If the condition
    is true, Ruby executes the code that is on the next line. However, if the condition
    is false, Ruby skips the first block, goes to the `else` statement, and executes
    the code that is right after the `else` keyword.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，`if` 语句评估条件。如果条件为真，Ruby 执行下一行的代码。然而，如果条件为假，Ruby 跳过第一个代码块，转到 `else` 语句，并执行
    `else` 关键字之后的代码。
- en: The ternary operator
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三元运算符
- en: 'As a last example of the `if` statement, we also have the ternary operator,
    which we also have in other coding languages; though it’s not as readable, it’s
    still useful. Let’s see an example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `if` 语句的最后一个例子，我们还有三元运算符，它在其他编程语言中也有；尽管它不是那么易读，但仍然很有用。让我们看一个例子：
- en: '[PRE76]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'With the ternary operator, the condition between the `=` sign and `?` will
    be evaluated. If the condition is deemed as true, then the value to the left of
    the `:` symbol is returned. If the condition is deemed as false, then the value
    to the right of the `:` symbol is returned. In this case, the value stored in
    `person["age"]` is 35\. Since 35 is over 30, the `over` string will be stored
    in the `over_or_under` variable. The second line of code will simply interpolate
    this value and should return this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三元运算符时，将在`=`符号和`?`符号之间的条件进行评估。如果条件被认为是真的，则返回`:`符号左侧的值。如果条件被认为是假的，则返回`:`符号右侧的值。在这种情况下，存储在`person["age"]`中的值是35。由于35大于30，`over`字符串将被存储在`over_or_under`变量中。第二行代码将简单地插值这个值并应该返回以下内容：
- en: '[PRE77]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: While this is not as readable as the previous `if` statements, the code is still
    valid and available in most programming languages. The ternary operator is the
    same in PHP and is useful when you need to store a value that depends on a condition.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不如之前的`if`语句可读，但代码仍然是有效的，并且在大多数编程语言中都是可用的。三元运算符在PHP中也是一样的，当你需要存储一个依赖于条件的值时很有用。
- en: The `if` statement is probably one of the most used resources in programming,
    so it’s a good idea to understand the syntax, the use, and the different use cases
    that it solves. Now, let’s look at another resource that uses true/false values
    to run code.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句可能是编程中最常用的资源之一，因此了解其语法、用法以及它解决的不同用例是个好主意。现在，让我们看看另一个使用真/假值来运行代码的资源。'
- en: Repeating code with loops
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用循环重复代码
- en: 'We have come to our next topic, which is loops. Ruby, just like other languages,
    has different ways of making the same code execute repeatedly. When we discussed
    arrays, specifically the array that contained instruments’ names, we saw an example
    of the `for` loop, which was used to print each instrument contained in the array.
    But let’s look at another type of loop, one that is more commonly used: the `while`
    loop.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来到了下一个主题，即循环。Ruby与其他语言一样，有不同的方式来重复执行相同的代码。当我们讨论数组时，特别是包含乐器名称的数组，我们看到了一个`for`循环的例子，它被用来打印数组中包含的每个乐器。但让我们看看另一种更常用的循环类型：`while`循环。
- en: 'The `while` loop lets us repeat a code execution that is determined by a true/false
    condition. Let’s say we wanted to print a number from one to three. We could create
    a `print` statement and simply repeat it three times while incrementing the value.
    However, let’s try a different way that will be more concise. Start by creating
    a `counter` variable:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环让我们可以重复执行由真/假条件确定的代码。假设我们想要打印一个从一到三的数字。我们可以创建一个`print`语句，并简单地重复它三次，同时增加值。但是，让我们尝试一种更简洁的方法。首先创建一个`counter`变量：'
- en: '[PRE78]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, we can start the `while` loop cycle:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始`while`循环周期：
- en: '[PRE79]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This may seem like valid code, but we will get an error from the Ruby interpreter:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是有效的代码，但我们将从Ruby解释器得到一个错误：
- en: '[PRE80]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This is because of a common erroneous assumption that most Ruby newbies make.
    If you use PHP or JavaScript, you will be used to the `++` operator, which is
    equivalent to adding 1 to a variable. It’s the same as writing the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为大多数Ruby新手都会犯的一个常见错误假设。如果你使用PHP或JavaScript，你会习惯于`++`运算符，它相当于给变量加1。这就像写以下内容：
- en: '[PRE81]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'However, the `++` operator does not exist in Ruby (so this also goes for the
    `––` operator, which decreases a value by 1). So, instead of using the nonexistent
    operator in Ruby, we would have to rewrite our code so that it looks like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Ruby中不存在`++`运算符（这也适用于`––`运算符，它将值减1）。因此，我们不得不用重写我们的代码，使其看起来像这样：
- en: '[PRE82]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This would output the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE83]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `while` statement has a very similar structure to the `if` statement, but
    instead of just executing a line of code, the `while` statement evaluates the
    condition and will execute the code if the condition is still met.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`语句的结构与`if`语句非常相似，但它不是只执行一行代码，而是评估条件，如果条件仍然满足，则执行代码。'
- en: In this case, before entering the cycle, the `counter` variable has a value
    of `1` – as the condition to continue the cycle is for the value to be less than
    or equal to 3, the condition is met. Since the condition is met, Ruby will execute
    the code that is before the `end` keyword, so the number 1 will be printed and
    a 1 will be added to the `counter` variable. Since this is a cycle, Ruby will
    go back and read the condition again, but this time, `counter` has a value of
    `2`, so it will execute the whole block again. Once the value of the `counter`
    reaches `4`, Ruby will determine that the `while` condition is no longer met and
    break the loop without executing the code inside it again.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在进入循环之前，`counter` 变量的值为 `1` - 因为继续循环的条件是值小于或等于 `3`，条件得到了满足。由于条件得到了满足，Ruby
    将执行 `end` 关键字之前的代码，所以将打印数字 `1` 并将 `1` 添加到 `counter` 变量中。由于这是一个循环，Ruby 将再次读取条件，但这次
    `counter` 的值为 `2`，所以它将再次执行整个块。一旦 `counter` 的值达到 `4`，Ruby 将确定 `while` 条件不再满足，并且将中断循环，而不再执行其内部的代码。
- en: 'A more useful example of loops is when we work with arrays. We already saw
    one way to iterate through arrays with a counter, but we also have a method called
    `each` to iterate through every element of an array. Let’s take the `instruments_played`
    array again:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与数组一起工作时，循环的一个更有用的例子是。我们已经看到了使用计数器遍历数组的一种方法，但我们还有一个名为 `each` 的方法来遍历数组的每个元素。让我们再次使用
    `instruments_played` 数组：
- en: '[PRE84]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We can use `each` to go through each element, like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `each` 来遍历每个元素，如下所示：
- en: '[PRE85]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This code will loop through the array so that we don’t have to repeat code
    for every element of said array. And this is exactly what loops are for: to write
    less code. For every element in the array, Ruby will print the value of the element
    (we called it `instrument` for readability, and just for this example, but we
    can call it anything we want).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将遍历数组，这样我们就不必为该数组的每个元素重复代码。这正是循环的作用：编写更少的代码。对于数组中的每个元素，Ruby 将打印该元素的值（我们为了可读性将其称为
    `instrument`，并且仅在这个示例中如此，但我们可以将其命名为任何我们想要的）。
- en: 'Additionally, we can compress this code into a single line by using curly brackets,
    like so:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过使用花括号将此代码压缩成一行，如下所示：
- en: '[PRE86]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This will have the same output as the previous example, but as you can see,
    it’s more concise and it’s quite readable. Additionally, the `each` loop helps
    us write code that will adapt to the size of the contents. Should we add another
    element to the array, we would not have to modify anything within our loop to
    print the added instrument. The loop would do so automatically.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生与上一个示例相同的输出，但如您所见，它更简洁且易于阅读。此外，`each` 循环帮助我们编写能够适应内容大小的代码。如果我们向数组中添加另一个元素，我们就不必修改循环中的任何内容来打印添加的乐器。循环将自动完成此操作。
- en: 'Lastly, what happens when we want to access the index of an array? We have
    a method just for that. The `each_with_index` method will make the index of the
    array available, as you can see in this example:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们想要访问数组的索引时会发生什么？我们有一个专门为此而存在的方法。`each_with_index` 方法将使数组的索引可用，正如您在这个示例中可以看到的那样：
- en: '[PRE87]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This code will output the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将输出以下内容：
- en: '[PRE88]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Again, both `instrument` and `index` are just aliases – we can name them anything
    we choose – but the order in which we type them is what will decide which value
    will be stored in them. The array element value will be stored in the first variable
    (`instrument`) and the array counter will be stored in the second variable (`index`).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`instrument` 和 `index` 都是别名 - 我们可以将其命名为任何我们想要的 - 但我们键入它们的顺序将决定哪个值将被存储在其中。数组元素的值将存储在第一个变量（`instrument`）中，而数组计数器将存储在第二个变量（`index`）中。
- en: 'We could very well rewrite the example, like so, and still get the same output:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完全可以像这样重写示例，并且仍然得到相同的输出：
- en: '[PRE89]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The new code will have the same output as before, but this time, we renamed
    `instrument` and its `index` to `array_element` and `array_index`, which at this
    point was just a personal choice I made to make the code make more sense to me.
    This goes to show that, as programmers, we decide how to name variables in the
    defense of readability (trust me – the more you grow as a programmer, the more
    time you’ll spend trying to name variables).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 新的代码将产生与之前相同的输出，但这次我们将 `instrument` 和其 `index` 重命名为 `array_element` 和 `array_index`，这仅仅是我个人为了使代码对我更有意义而做出的选择。这表明，作为程序员，我们决定如何命名变量以保护可读性（请相信我
    - 随着你作为程序员的成长，你将花更多的时间尝试命名变量）。
- en: At this point, we know how to repeat code by using loops and by iterating through
    arrays. Instead of writing the same code multiple times, we exploited Ruby’s `while`
    statement and the `each` method to improve efficiency and readability within our
    code. But we are not done yet. Ruby has a few more tricks up its sleeve to further
    improve readability. We’ll take a look at these tricks in the next section.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道如何通过使用循环和遍历数组来重复代码。我们不是多次编写相同的代码，而是利用Ruby的`while`语句和`each`方法来提高代码的效率和可读性。但我们还没有完成。Ruby还有一些其他的技巧来进一步提高可读性。我们将在下一节中查看这些技巧。
- en: Using Ruby language enhancements
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ruby语言增强功能
- en: 'For the most part, as developers, we should always strive to increase the readability
    of our code as this will help everyone in the long run. I’ve been in scenarios
    where I’ve looked back at my code and had trouble understanding what the code
    was doing. That meant that my code was poorly written. Imagine the toll that this
    poorly written code may have on the next developer or team that has to use it
    or, worse, improve it. In contrast, if my code was well written, we wouldn’t have
    this issue. This is me saying this: please write readable code, and I can’t stress
    enough the lengths Ruby developers will go to make their code readable over any
    other enhancement in our code. Ruby comes with some additional tools to achieve
    this.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们大多数开发者来说，我们应该始终努力提高代码的可读性，因为这将在长远上帮助到每个人。我遇到过一些情况，当我回顾自己的代码时，很难理解代码在做什么。这意味着我的代码写得不好。想象一下，这种写得不好的代码可能会对下一个使用它或，更糟糕的是，改进它的开发者或团队造成多大的负担。相比之下，如果我的代码写得很好，我们就不会遇到这个问题。我想说的是：请编写可读的代码，我无法强调得更多，Ruby开发者为了使代码可读而付出的努力，超过了对代码的任何其他增强。Ruby附带了一些额外的工具来实现这一点。
- en: The unless sentence
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`unless`语句'
- en: One example of these options is a language enhancement called the `unless` sentence.
    The `unless` sentence is a negative `if` sentence – that is, it will execute the
    code only when the condition is *not* met. Let’s see it being used in an example.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项之一是一个名为`unless`语句的语言增强功能。`unless`语句是一个否定`if`语句——也就是说，它只会在条件不满足时执行代码。让我们看看它在示例中的使用情况。
- en: 'Let’s assume the following scenario: we have a product aimed at unmarried individuals.
    For simplicity, we will just print out the message “Promo for singles” if the
    person is not married. Let’s try to write the code for that. Let’s take our previous
    hash example for a person’s details:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设以下场景：我们有一个针对未婚个人的产品。为了简单起见，如果这个人是未婚的，我们将只打印出“单身促销”的消息。让我们尝试编写这段代码。让我们以我们之前的人的详细信息哈希为例：
- en: '[PRE90]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now, let’s change the `is_married` value to `false`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将`is_married`的值改为`false`：
- en: '[PRE91]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Once we have declared that hash, we can try to print a message if the person
    is single:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们声明了这个哈希，我们就可以尝试打印一条消息，如果这个人是单身的话：
- en: '[PRE92]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Because the person is not married, the output is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个人没有结婚，所以输出如下：
- en: '[PRE93]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'And while the code works, it simply doesn’t look good. We could use the bang
    (`!`) operator to invert the Boolean value from true to false:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码能正常工作，但看起来并不好。我们可以使用感叹号(`!`)运算符将布尔值从`true`反转到`false`：
- en: '[PRE94]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Though this code still works, it still looks bad. Let’s look at the options
    Ruby has to fix this.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码仍然能工作，但看起来仍然不好。让我们看看Ruby有哪些选项可以解决这个问题。
- en: 'In most programming languages, you’ll see a lot of sentences that read “if
    not.” Of course, this is awful to read and goes against the readability principles
    of Ruby. To solve this issue, Ruby’s creators added the exact sentence to make
    this more readable: `unless`. It works similarly to the `if` statement but will
    execute the code if the condition is deemed false.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，你会看到很多读起来像“if not”的句子。当然，这很难读，也违反了Ruby的可读性原则。为了解决这个问题，Ruby的创造者添加了确切的句子，使其更具可读性：`unless`。它的工作方式与`if`语句类似，但会在条件被认为是`false`时执行代码。
- en: 'In this case, this is helpful when we have code to be executed only when the
    person is not married. So, instead of writing an if negative sentence (if a person
    is *not* married), `if !person["is_married"]`, we could rewrite the example as
    follows (unless a person is married):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当我们需要执行的代码只有当这个人没有结婚时，这很有帮助。所以，我们不是写一个否定条件语句（如果一个人是*不*结婚的），`if !person["is_married"]`，我们可以将示例重写如下（除非一个人结婚）：
- en: '[PRE95]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This is looking much better already, but just like the `if` statement, we can
    convert it into a one-liner:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来已经好多了，但就像`if`语句一样，我们可以将其转换为单行代码：
- en: '[PRE96]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This is a very Ruby-esque sentence, reading exactly like it behaves: “Print
    “Show promotion” unless the person is married.” This is about as readable as it
    gets.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常Ruby风格的句子，读起来就像它的行为一样：“除非这个人已婚，否则打印“Show promotion”。”这几乎是可读性的极致。
- en: 'The `unless` sentence is so useful that one of the most used PHP frameworks
    today, called Laravel, has borrowed this functionality in the form of a directive:
    [https://laravel.com/docs/9.x/blade#if-statements](https://laravel.com/docs/9.x/blade#if-statements).'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`unless`语句非常有用，以至于今天最常用的PHP框架之一，名为Laravel，已经以指令的形式借用了这个功能：[https://laravel.com/docs/9.x/blade#if-statements](https://laravel.com/docs/9.x/blade#if-statements)。'
- en: The until loop
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`until`循环'
- en: Just like the `unless` sentence, the `until` loop solves the same issue with
    negative conditions.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`unless`语句一样，`until`循环解决了与负条件相同的问题。
- en: Instead of writing “while not,” which reads horribly, the `until` sentence takes
    a false statement and executes the loop until the condition becomes true.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 与其写“while not”，这听起来很糟糕，`until`语句接受一个假命题，并在条件变为真之前执行循环。
- en: 'The `until` sentence takes a false statement and executes the loop until the
    condition becomes true. Let’s look at our `while` example from earlier again:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`until`语句接受一个假命题，并在条件变为真之前执行循环。让我们再次看看我们之前的`while`示例：'
- en: '[PRE97]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Using `until`, we can rewrite it as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`until`，我们可以将其重写如下：
- en: '[PRE98]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The output is the same as with the `while` statement:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与`while`语句相同：
- en: '[PRE99]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Our code would read like “Print the counter until the counter is larger than
    3.” Whether you choose to use the `while not` sentence or the `until` sentence
    will be up to you as they both seem readable, but the fact that Ruby has both
    sentences available tells us that Ruby is designed to be read and not just programmed.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码将读作“打印计数器，直到计数器大于3。”你选择使用`while not`语句还是`until`语句将取决于你，因为它们都看起来很易读，但Ruby提供了这两种语句的事实告诉我们，Ruby的设计是为了可读性，而不仅仅是编程。
- en: Automatic returns
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动返回
- en: When working within the IRB, you may have noticed that whenever you type variables,
    the IRB will output the value you just typed. Even on our last `until` statement
    example, the shell first outputs the three numbers and then a final `=> nil` value.
    If you take a closer look at the other examples, you’ll see a similar behavior.
    This is because Ruby always attempts to return a value – be it a declaration,
    a method, or just a string, Ruby will try to automatically return a value.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在IRB（交互式Ruby解释器）中工作时，你可能已经注意到，每当你输入变量时，IRB都会输出你刚刚输入的值。即使在我们最后的`until`语句示例中，shell首先输出了三个数字，然后是一个最终的`=>
    nil`值。如果你仔细观察其他示例，你会发现类似的行为。这是因为Ruby总是尝试返回一个值——无论是声明、方法还是字符串，Ruby都会尝试自动返回一个值。
- en: 'If you’re not convinced, let’s use the IRB to see it more explicitly. So, type
    the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不信，让我们使用IRB来更明确地看到它。所以，输入以下内容：
- en: '[PRE100]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We are not declaring the string or assigning it to a value; we are simply typing
    a string into the IRB shell. And what does the shell do? It returns the value
    we just typed:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有声明字符串或将其赋值给一个值；我们只是在IRB shell中输入了一个字符串。那么shell会做什么呢？它会返回我们刚刚输入的值：
- en: '[PRE101]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Coming from a PHP background (and other languages for that matter), grasping
    the “automatic return” feature is crucial to understanding more complex Ruby code.
    It’s important to know that PHP (and most languages) do not behave this way. PHP
    (and other languages) require us to explicitly return the value, while Ruby does
    this by default. In PHP, this is achieved by using the `return` sentence. That
    said, from time to time, you will encounter Ruby code with an explicit `return`
    statement, as it will sometimes increase readability. To further understand this
    feature, for the next few examples, we’ll exit the IRB and continue by creating
    source code files and running Ruby to execute them. You may still follow the next
    examples in the IRB, but I would highly recommend that you follow them with source
    code files instead of the IRB.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 来自PHP背景（以及其他语言），理解“自动返回”功能对于理解更复杂的Ruby代码至关重要。重要的是要知道PHP（以及大多数语言）不会这样做。在PHP（以及其他语言）中，我们需要显式地返回值，而Ruby默认就会这样做。在PHP中，这是通过使用`return`语句来实现的。话虽如此，有时你会在Ruby代码中遇到显式的`return`语句，因为它有时会增加可读性。为了进一步理解这个特性，在接下来的几个示例中，我们将退出IRB，继续通过创建源代码文件并运行Ruby来执行它们。你仍然可以在IRB中跟随下一个示例，但我强烈建议你用源代码文件而不是IRB来跟随它们。
- en: 'Let’s say we wanted to create a method that prints a message on the screen.
    We can do so by creating a file called `methods.rb`. This file will contain the
    following code:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个在屏幕上打印消息的方法。我们可以通过创建一个名为 `methods.rb` 的文件来实现。这个文件将包含以下代码：
- en: '[PRE102]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: For now, we’re defining a method called `message` that returns a string. In
    Ruby, we define a method with the `def` reserved keyword and limit the definition
    with the `end` keyword.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义一个名为 `message` 的方法，它返回一个字符串。在 Ruby 中，我们使用 `def` 保留关键字来定义一个方法，并用 `end`
    关键字来限制定义。
- en: 'Now, let’s add another method called `say()` and, inside that method, call
    the `message()` method:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加另一个名为 `say()` 的方法，并在该方法内部调用 `message()` 方法：
- en: '[PRE103]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'So far, we haven’t done anything out of the ordinary – we just have one method
    calling another. If we opened a shell and executed this script, it would appear
    to be doing nothing:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们并没有做任何特别的事情——我们只是有一个方法调用了另一个方法。如果我们打开一个shell并执行这个脚本，它看起来就像什么都没做：
- en: '[PRE104]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This script outputs nothing, but behind the scenes, it has two methods that
    are now defined and ready to be used. The `message` method is explicitly (not
    automatically) returning a string because of the use of the `return` keyword.
    This code still looks familiar, but not for long.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本什么都没有输出，但在幕后，它现在有两个定义好的方法，并且可以随时使用。`message` 方法由于使用了 `return` 关键字而显式（不是自动）地返回一个字符串。这段代码看起来仍然很熟悉，但不会持续太久。
- en: 'Now, let’s print out the contents of the `say()` method with this last line
    on the code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打印出 `say()` 方法的这个最后一条代码的内容：
- en: '[PRE105]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'If we run this again, we will see the following message on the screen:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行它，我们将在屏幕上看到以下消息：
- en: '[PRE106]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'And this is where Ruby behaves differently to PHP. While you can explicitly
    use the `return` function in Ruby, Ruby does not need the `return` statement because
    it already does it automatically as part of its default behavior. So let''s try
    it out by removing the return statement from both the `message()` and the `say()`
    methods. Your final code should look like this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Ruby 与 PHP 表现不同的地方。虽然你可以在 Ruby 中显式使用 `return` 函数，但 Ruby 不需要 `return` 语句，因为它已经自动作为其默认行为的一部分执行了。所以，让我们通过从
    `message()` 和 `say()` 方法中移除 `return` 语句来试一试。你的最终代码应该看起来像这样：
- en: '[PRE107]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Admittedly, this looks weird, especially for someone from a PHP background.
    My advice to you is to just try to get used to this syntax. You’ll see it very
    often in Ruby. To make it easier to learn this rule, we can generalize and say,
    “Every sentence in Ruby will return a value.” With some notable exceptions, this
    is true for all Ruby sentences.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，这看起来很奇怪，尤其是对于有 PHP 背景的人来说。我的建议是，你只需尝试适应这种语法。你会在 Ruby 中非常频繁地看到它。为了更容易学习这个规则，我们可以概括地说，“Ruby
    中的每一句话都会返回一个值。”有一些明显的例外，但对于所有 Ruby 语句来说，这是真的。
- en: Optional parentheses
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选的括号
- en: 'Another weird but useful syntactic enhancement is that the parentheses on Ruby
    methods are purely optional – so, you can choose whether to include parentheses
    or not. And just like every Ruby resource we’ve learned about so far, we should
    try to use it to make our code easier to read, but we should also try to avoid
    overusing it. Excessive use of this feature could have us formatting our code
    like this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个奇怪但有用的语法增强是，Ruby 方法的括号完全是可选的——因此，你可以选择是否包含括号。并且就像我们迄今为止所学的每一个 Ruby 资源一样，我们应该尝试使用它来使我们的代码更容易阅读，但也应该尽量避免过度使用。过度使用这个特性可能会让我们把代码格式化成这样：
- en: '[PRE108]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The problem with this snippet is that we don’t know if the comma is being used
    for separating the arguments for `method1` or `method2`. In this case, we should
    use parenthesis:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段的问题是我们不知道逗号是用来分隔 `method1` 或 `method2` 的参数的。在这种情况下，我们应该使用括号：
- en: '[PRE109]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Now, it’s more than clear that `method2` is receiving two arguments while `method1`
    is just receiving one argument. Let’s look at a more simplified example by removing
    the parenthesis from our previous examples. Our example will now look like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，很明显 `method2` 接收了两个参数，而 `method1` 只接收一个参数。让我们通过从之前的例子中移除括号来查看一个更简化的例子。我们的例子现在看起来是这样的：
- en: '[PRE110]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The output is the same as before, but now, the code looks a lot more like proper
    sentences instead of code syntax. You’ll see a lot of code similar to this, especially
    when you start using Ruby on Rails. Because of the lack of parenthesis, Ruby allows
    us to have a method and a variable with the same name. In this case, we have a
    method called `message` and a variable called `message`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与之前相同，但现在，代码看起来更像正确的句子而不是代码语法。你将看到很多类似的代码，尤其是在你开始使用 Ruby on Rails 时。由于缺少括号，Ruby
    允许我们有一个方法和一个具有相同名称的变量。在这种情况下，我们有一个名为 `message` 的方法和一个名为 `message` 的变量。
- en: 'This scenario, if left unexplained, can lead to a lot of confusion later on.
    To that effect, let’s take our previous example and tweak it so that we have a
    better understanding of this naming behavior. First, we’ll add a parameter to
    the `say()` method so that the printed message is dynamic. This parameter will
    be named `message`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况，如果未进行解释，可能会在以后导致很多困惑。为了达到这个效果，让我们拿我们之前的例子稍作修改，以便更好地理解这种命名行为。首先，我们将向 `say()`
    方法添加一个参数，使得打印的消息是动态的。这个参数将被命名为 `message`：
- en: '[PRE111]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: In other programming languages, we would expect an error if we tried to run
    this code, and this is where Ruby can sometimes be overwhelming when you’re starting
    to use it. We purposely named the parameter `message`, which means we now have
    a `message` method and a `message` local variable. When reaching the `puts message`
    line, we are not sure if we are calling the `message` parameter or the `message`
    method without the parentheses. Unfortunately, this confusion happens more often
    than not, or at least that was my experience when I started to use Ruby more professionally.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他编程语言中，如果我们尝试运行这段代码，我们预期会出错，这就是为什么当你刚开始使用 Ruby 时，它有时会让人感到不知所措。我们故意将参数命名为 `message`，这意味着我们现在有一个
    `message` 方法和一个 `message` 本地变量。当我们到达 `puts message` 这一行时，我们不确定我们是调用带括号的 `message`
    参数还是不带括号的 `message` 方法。不幸的是，这种混淆经常发生，至少在我开始更专业地使用 Ruby 时是这样的经验。
- en: 'So, my advice here is to try to use parenthesis when calling methods, even
    when the syntax doesn’t require us to use them. For teaching purposes, we won’t
    be doing it in this example. So, our final source code should look like this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我的建议是，在调用方法时尽量使用括号，即使语法不需要我们这样做。出于教学目的，我们在这个例子中不会这样做。所以，我们的最终源代码应该看起来像这样：
- en: '[PRE112]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'As you would expect (or not), when executing the script on the shell, we’ll
    get the following output:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期（或不是），当在壳上执行脚本时，我们会得到以下输出：
- en: '[PRE113]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Why did it print that string and not the `"This is a message"` string? Well,
    this is because the `message` variable took precedence over the `message` method.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它打印了那个字符串而不是 `"This is a message"` 字符串呢？嗯，这是因为 `message` 变量优先于 `message`
    方法。
- en: While this feature may not seem pretty (I don’t like it that much), I guarantee
    you that you’ll come across it from time to time, and you should be prepared for
    it.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个特性可能看起来不太美观（我并不太喜欢它），但我保证你时不时地会遇到它，你应该为此做好准备。
- en: Questionable exclamation method names
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有疑问的感叹号方法名称
- en: 'As a cherry on top of the language enhancements in Ruby, its creators have
    also included a naming feature to add readability to our methods: the exclamation
    mark (`!`) (also known as a bang) and the question mark (`?`). They don’t change
    behavior in any way, but they allow for a line of code to read as a question or
    as an exclamation. Methods named with the exclamation mark are called dangerous
    methods because they modify the object from where they are called. Methods named
    with the question mark are called predicate methods and, by convention, return
    a Boolean.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Ruby 语言增强的甜点，其创造者也包含了一个命名特性，以增加我们方法的可读性：感叹号（`!`）（也称为感叹号）和问号（`?`）。它们在行为上没有任何改变，但允许一行代码读作一个问题或感叹。用感叹号命名的方法被称为危险方法，因为它们会修改它们被调用的对象。用问号命名的方法被称为谓词方法，并且按照惯例，返回一个布尔值。
- en: 'To see this in action, we’ll create a method with the question mark. Let’s
    create a new file called `enhanced_naming.rb` and add the following code:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个功能在实际中的运用，我们将使用带问号的创建一个方法。让我们创建一个名为 `enhanced_naming.rb` 的新文件，并添加以下代码：
- en: '[PRE114]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The `$married_status` variable is a global variable, which simply means that
    we can modify or access its contents on a method or outside the method. In this
    case, we defined a method that gets the `$married_status` value. However, knowing
    that we can add the `?` to the name of this method, let’s rename the `is_married`
    method like so:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`$married_status`变量是一个全局变量，这仅仅意味着我们可以在方法内或方法外修改或访问其内容。在这种情况下，我们定义了一个获取`$married_status`值的方法。然而，知道我们可以将`?`添加到这个方法的名称中，让我们将`is_married`方法重命名为如下：'
- en: '[PRE115]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Now, let’s use an already familiar one-liner to print a message for a married
    person:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用一个已经熟悉的单行代码来打印已婚人的消息：
- en: '[PRE116]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: While adding `?` to the name of the method does not affect its behavior, it
    does change the sentence into an obvious question. We’ll see this syntax very
    often in Ruby.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将`?`添加到方法名称中不会影响其行为，但它确实将句子变成了一个明显的问题。我们将在Ruby中非常频繁地看到这种语法。
- en: 'Similarly, we can use the bang symbol (`!`) as part of the name of a method.
    Again, adding it to the name doesn’t affect the behavior by itself, but it tells
    whoever is reading the code that we’re doing something different than just calling
    a method. As an example, let’s rename our `marry` method to `marry!` and see what
    it looks like:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们可以在方法名称中使用感叹号（`!`）作为一部分。再次强调，仅仅将感叹号添加到名称中本身并不会影响行为，但它告诉阅读代码的人我们正在做不同于仅仅调用方法的事情。作为一个例子，让我们将我们的`marry`方法重命名为`marry!`并看看它看起来像什么：
- en: '[PRE117]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'As a convention adopted by the Ruby community, the bang symbol (`!`) will tell
    the reader (of the code) that we are making a change within an object. A method
    without the bang symbol would simply return a value, but not affect the object
    itself. So, in this case, we are changing the `$married_status` value to `true`.
    This is what the code should look like now:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Ruby社区采用的一种约定，感叹号（`!`）将告诉代码的读者我们正在对象内部进行更改。没有感叹号的方法将简单地返回一个值，但不会影响对象本身。因此，在这种情况下，我们正在将`$married_status`的值更改为`true`。这就是代码现在的样子：
- en: '[PRE118]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Sadly, when we run this example, we don’t see any output. This is because the
    initial value of the global `$married_status` variable is `false`, and our code
    will only print a message if the value is `true`. Now, let’s call the `marry!`
    method and copy the one-liner again at the end of the code:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，当我们运行这个例子时，我们没有看到任何输出。这是因为全局变量`$married_status`的初始值是`false`，并且我们的代码只有在值是`true`时才会打印一条消息。现在，让我们调用`marry!`方法，并在代码末尾再次复制单行代码：
- en: '[PRE119]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Now, we can run the code again:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以再次运行代码：
- en: '[PRE120]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The output will look like this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将看起来像这样：
- en: '[PRE121]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: What’s happening here? We have a global `$married_status` variable with an initial
    `false` value. Then, we have two methods – one to get the `$married_status` value
    and another to change it to true. Finally, we attempt to print the message but
    since the initial value is `false`, the message is not printed. By calling the
    `marry!` method, we change `$married_status` to `true`, which makes the last line
    of our script print out the message.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？我们有一个初始值为`false`的全局变量`$married_status`。然后，我们有两个方法——一个用于获取`$married_status`的值，另一个将其更改为`true`。最后，我们尝试打印消息，但由于初始值是`false`，消息没有被打印出来。通过调用`marry!`方法，我们将`$married_status`更改为`true`，这使得脚本的最后一条打印出消息。
- en: Ruby brings language enhancements to programming merely to improve code readability.
    I’ve seen code written so beautifully that it reinforces the idea behind not writing
    comments on your code, but rather lets your code speak for itself. Once you start
    using them regularly, you will appreciate them more and more and you’ll wish all
    languages had these enhancements.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby通过提高代码可读性来为编程带来语言增强。我见过写得如此漂亮的代码，这强化了不写代码注释而是让代码为自己说话的想法。一旦你开始经常使用它们，你会越来越欣赏它们，并希望所有语言都有这些增强。
- en: Summary
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to write, execute, and require scripts with
    the Ruby binary, along with how to use the IRB to execute Ruby code directly on
    the command line without having to write source code.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Ruby二进制文件编写、执行和require脚本，以及如何使用IRB在命令行上直接执行Ruby代码，而无需编写源代码。
- en: Additionally, we reviewed Ruby’s syntax for writing variables, the syntax for
    `if` statements, and how to loop through both cycles and arrays. Finally, we learned
    some of the language enhancements that Ruby has and PHP doesn’t so that we can
    read and understand more complex Ruby code.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还回顾了Ruby编写变量的语法、`if`语句的语法以及如何遍历循环和数组。最后，我们学习了Ruby的一些语言增强，而PHP没有，这样我们就可以阅读和理解更复杂的Ruby代码。
- en: Now, we are ready to write Ruby code to solve real-life examples. We’ll start
    doing this in the next chapter.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好编写Ruby代码来解决现实生活中的例子了。我们将在下一章开始这样做。
