- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comparing Basic Ruby Syntax to PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running scripts in PHP and Ruby is similar, though each language has its peculiarities.
    Similarly, both Ruby’s and PHP’s syntax can be strangely similar at times, as
    we saw in [*Chapter 1*](B19230_01.xhtml#_idTextAnchor015). However, if we are
    serious about becoming Ruby programmers, we will need to learn both the differences
    and the enhancements that Ruby brings to the table.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s embark on this journey and start creating, executing, and debugging our
    own Ruby scripts with the resources that we already have from knowing PHP, and
    see Ruby’s language improvements over other languages. We’ll not only think in
    Ruby but program in “the Ruby way” too.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Running Ruby code from the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring types of variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using conditional statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeating code with loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ruby language enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with this chapter, we will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Any IDE to view/edit code (for example, SublimeText, Visual Studio Code, Notepad++
    Vim, Emacs, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For macOS users, you will also need to have Xcode Command Line Tools installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby version 2.6 or later will need to be installed and ready to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code presented in this chapter is available at [https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/](https://github.com/PacktPublishing/From-PHP-to-Ruby-on-Rails/).
  prefs: []
  type: TYPE_NORMAL
- en: Running Ruby code from the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first things we need to learn about when picking up Ruby is how to
    run our code and view the output directly on our screen. There are different ways
    to achieve this, but we will be doing so in the simplest of ways. While there
    are various ways to load code from the command line, we’ll start with one single
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Running a simple code file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I mentioned in the introduction, running scripts in Ruby is simple and easy.
    Similar to running scripts in PHP, we can create a file, add Ruby code to it,
    and execute it with Ruby. Running or executing code simply means that we will
    have Ruby read (also referred to as parse) through our source code, and then translate
    it into a language that the computer can understand and process.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a simple example by creating a folder called `ruby_syntax`
    on our desktop. In that folder, create our source code file, which is called `running_ruby.rb`,
    with your IDE of choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add some code to our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s open a shell and go to the same folder we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we are in this folder in our shell, we can run the script we just created
    with Ruby:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As I mentioned in [*Chapter 1*](B19230_01.xhtml#_idTextAnchor015), this syntax
    is strangely familiar to the PHP one. If we compared the two, we would have the
    following PHP equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We would then run the example in the same way as the Ruby one, but with the
    PHP executable instead, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The outcome would be the same as the Ruby one but with the string for PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the Ruby example, and just like we did to the examples in [*Chapter
    1*](B19230_01.xhtml#_idTextAnchor015), let’s modify our Ruby code so that it’s
    slightly more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Even though the syntax is slightly similar, the outcome is the same, with the
    advantage that it reads more naturally. While `print` is available in Ruby for
    outputting text for the user, you may also use `puts` or simply `p`. You’ll see
    this very often in Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a source code file with the load method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you know how to execute Ruby code in a single file. However,
    as our source code grows, it will become impractical to have a single source code
    file. That is why Ruby allows us to load source code from other source files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to do this. First, we must create a file to be loaded – in this
    example, the file is called `my_library.rb` and contains some simple content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'While we now have runnable Ruby code, we are not going to run `my_library.rb`
    directly, but rather let another script load its code. This is where the `load`
    method comes in. The `load` method takes a filename and its code and includes
    it in our execution. So, let’s create another file called `load_library.rb` with
    this content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the code with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the script should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `load_library.rb` file injects (or as its name implies, *loads*) the code
    from the `my_library.rb` file and executes it. This way, we can easily separate
    large chunks of code into smaller, more readable ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what happens if we call the `load` method more than once in Ruby? Well,
    let’s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the command again, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: From this behavior, we can infer that every time we load a file, its code will
    be executed, which is very useful when our files change multiple times during
    their execution – in these cases, the code is said to be dynamically changing.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of dynamically changing code, let’s say we needed a script to
    include new parts of the code, but could not be stopped for doing so. In a case
    such as this, we would need the code to be constantly refreshed, and this is where
    the `load` method comes in. The `load` method refreshes the code every single
    time it comes across the file that’s changing – that is, it renews our code every
    time the Ruby engine detects a change. Otherwise, we would have to stop the execution
    every time we needed a new change in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby’s `load` method is similar to PHP’s `include` and `require` functions.
    However, Ruby’s `require` method is slightly different than the one in PHP, as
    we’ll see next.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a source code file with the require method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast to the `load` method, sometimes, we just need the code to be executed
    only once, and for that, we can use the `require` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see it in action by creating another file called `require_library.rb`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s run it in the same way that we ran the `load_library.rb` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, the output will be the same as when we ran the `load_library.rb`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: However, notice that in this example, we included the dot slash prefix (`./`)
    before the filename. The `require` function needs either the absolute path or
    the relative path of the file – because the `my_library.rb` example is within
    the same folder, we use the relative path to the current folder, which would be
    `./`. In simple terms, the source code for `require_library.rb` would read as
    “inject the code that is in the `my_library.rb` file, which is in the same folder.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s try calling the `require` method more than once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s run it again with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To an experienced PHP developer, it should not be a surprise that the output
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Ruby’s `require` method works pretty much the same way as `include_once` and
    `require_once` from PHP. The Ruby interpreter only loads the code once, and whenever
    you try to load it again, the engine notices that you already loaded that code,
    so it doesn’t load it again, saving memory and resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing we may wish to consider while using the `require` method is
    that it is not compulsory to include the file extension, so this will also work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'By not using the file extension, our code looks slightly cleaner. Now, how
    is the `require` method useful, you may ask? Well, whenever you’re writing libraries
    that will be used in several parts of your code, you don’t have to worry about
    loading your library multiple times as the `require` method will only load it
    once, thus saving memory resources. We’ll keep it simple for now, but if you are
    interested in more options for importing code, there is also the `require_relative`
    method: [https://apidock.com/ruby/Kernel/require_relative](https://apidock.com/ruby/Kernel/require_relative).'
  prefs: []
  type: TYPE_NORMAL
- en: Ruby classes and modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Ruby, modules are a way to group code so that it can be reused. Specifically,
    modules are collections of methods and constants that can be injected into classes.
    By themselves, modules aren’t useful as you can’t use them in an isolated manner.
    We use modules to add functionality to a class.
  prefs: []
  type: TYPE_NORMAL
- en: A class, as you probably know, is a blueprint of an abstraction from the real
    world taken to the programming world. A class can have different methods to represent
    actions and attributes to represent values. A class can be enhanced by including
    additional methods and constants from a module. So, in simple terms, a class can
    attach methods and constants from a module – and that’s what the `include` method
    does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at this in a simplified example. Create a file called `include_module.rb`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’re creating a simple empty class called `MyClass` with no methods.
    Now, let’s create an instance of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can’t do much with this class as it is empty, so let’s add a `Utilities`
    module to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And just like the previous class (`MyClass`), this is just an empty module.
    Let’s add a method called `debug` to our module so that both our class and module
    end up looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With this code, we’ve declared a method named `debug` that prints the text “We
    are debugging.” Can we add this method to `MyClass`? Well, this is where the `include`
    method comes in.
  prefs: []
  type: TYPE_NORMAL
- en: The include method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, we should incorporate this newly built debug method with the
    `include` method because, as it stands now, the `debug` method is not currently
    being used. It’s merely defined. With the `include` method, we can now “attach”
    the `debug` method to our class by adding this to the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This simply means that the `debug` method is now available to `my_class_instance`.
    Let’s call our newly included `debug` method from our class instance. Your final
    code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for the moment of truth – let’s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This means that we have successfully attached the debug method to our empty
    class. This comes in handy whenever we need modules that are reused throughout
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: The equivalent to Ruby’s `include` method in PHP is a resource called `traits`.
    If you’re interested in this topic, check out [https://www.php.net/manual/en/language.oop5.traits.php](https://www.php.net/manual/en/language.oop5.traits.php).
    This might be a little complicated to grasp at first since we haven’t looked at
    object-oriented programming in Ruby so far, but don’t worry if you don’t fully
    understand it at this point – we will get there.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive Ruby Shell (IRB)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you may want to quickly test a very small piece of code and it may
    seem like a hassle to create a file, add the code, and then run it. Maybe we just
    want to test the syntax of a single line of code. Well, we don’t have to create
    a file to just test a line of code. Just like in other languages, such as Python
    or even PHP, we have a tool just for that in Ruby: it’s the **Interactive Ruby
    Shell**, better known as **IRB**. Let’s take a look at it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within a shell, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make your shell look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This shell works as a real-time Ruby interpreter – that is, after the `>` symbol,
    we can start typing Ruby commands that will be interpreted and executed right
    away. As a simple example, let’s add 1 and 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This comes in quite handy when you quickly want to test syntax and operations,
    or even view the content of a class. It works in the same way as the Ruby binary
    we’ve been using in previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as a final example, let’s load the `include_module` file we created, but
    now with this interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’ve included the code in our shell with the `require` method, we
    can use this loaded code in our `irb` session. Since we have the `MyClass` definition
    available, we can use it as a blueprint to create an instance of `MyClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns a unique identifier that Ruby uses internally to know where the
    instance resides in the computer’s memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we can call the `debug` method on our newly created instance too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And just like before, we get the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To exit this interactive shell, simply type `exit` to make your shell go back
    to normal. In case you were wondering, there is a similar shell in PHP called
    interactive shell. Be sure to check out this page if you’re interested in this
    topic: [https://www.php.net/manual/en/features.commandline.interactive.php](https://www.php.net/manual/en/features.commandline.interactive.php).'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can proudly say that we now know how to run Ruby code in
    a couple of different ways. We also know how to use a single source code file,
    or load code from a separate source code file. Either way, whether you’re running
    your code with the Ruby binary or with the interactive shell, you’re going to
    need a way to store and use values, which brings us to our next topic: variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring types of variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variables in Ruby have the same utility as in other programming languages:
    they are mutable containers for values. Simply put, variables are used to save
    values for later usage. These values may change over time, or even change the
    type of data they contain.'
  prefs: []
  type: TYPE_NORMAL
- en: Just like with PHP, Ruby is dynamically typed (or duck typing), which means
    that the interpreter infers what type of data we are handling at runtime. We don’t
    need to tell Ruby or PHP that a variable is either a string, a number, or a Boolean.
    One difference with PHP, however, is that in later versions of PHP, you *can*
    specify what type of data to use, especially in object-oriented PHP. However,
    even with this “enhancement,” the majority of the language remains duck-typed.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does this affect us as developers? Well, let’s take a look at a simple
    example. First, open an IRS. Type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw previously, once we type this command, the shell will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, type the following declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that though the information in the previous code block is what you should
    type, it will look like this in the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: One of the core features of the Ruby language is that with every line of code,
    Ruby will attempt to return a value. If you declare a variable, Ruby will return
    the assigned value. So, when we added the `name` variable, Ruby returned the value
    of the variable – that is, `"Oscar"`. This comes in handy when we use this behavior
    to obtain the type of data a variable is holding. Ruby “knows” what type of data
    this `name` variable contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we can make use of the internal `class` method. Just type `name.class`;
    `irb` should return something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The Ruby interpreter determined that the `name` variable is a string, or in
    simple terms, text. The same can be done to the other variables we just declared,
    such as the `age` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And in that same manner, the `is_married` variable is a Boolean variable. We
    can confirm this by getting the class of that variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the `is_married` variable has a Boolean value of `true`. We
    can do the same with the `books_read_this_week` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We did not explicitly tell Ruby what type of variables we were going to use,
    yet Ruby “knew” this automagically. This means that we don’t have to worry about
    telling Ruby the type of data we are going to use. This is pragmatic for the most
    part, but I must admit I’ve been in scenarios where it would have helped to have
    known the type of data before runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, in our previous examples, we’ve looked at four different types of variables
    in Ruby: strings, integers, Booleans (true or false), and float values. However,
    there are three more types of variables that we should look at in depth: arrays,
    hashes, and symbols. We’ll go through each of them now.'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays are a way of grouping common variables. Coming from a PHP background,
    arrays can be very simple to understand both conceptually and syntactically. Conceptually,
    we put together similar or related values. An example could be grouping a person’s
    phone numbers in a single variable. Another example could be storing a physical
    address by saving the street, number, city, zip code, and more all in the same
    variable. As we will see next, the Ruby syntax is very similar to the PHP one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays let us take related values and save them in a single variable. As an
    example, let’s say we wanted to save my siblings’ ages. We could create an array
    of integers that represented my siblings’ ages. Let’s do just that in PHP and
    Ruby and compare both syntaxes. This would be the PHP syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And this would be the Ruby syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Except for `$` and `;`,, both pieces of code are the same; this goes to show
    that understanding the concepts of Ruby arrays should not be difficult if you’re
    from a PHP background. While there are other ways to declare arrays, we’ll keep
    the syntax simple for now.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to declare arrays, let’s look at some practical uses
    for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays can have other types of values in Ruby (not just numbers). Let’s say
    I wanted to list the instruments someone knows how to play. We could make a list
    of strings and name it `instruments_played`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have grouped related values (in this case instruments) in
    a single variable. We’ve created a list ready to be used within our code. This
    type of array, as it was declared, has an internal counter to reference each value.
    This internal counter starts with 0, so the first value (`guitar`) would be contained
    in `instruments_played[0]`, the second value (`drums`) would be contained in `instruments_played[1]`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should we want to print out all of the instruments on the screen, we could
    print each instrument one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this is tedious and impractical, and as you may have guessed, we have
    a better programming way of doing this. Instead of counting one by one, we can
    iterate through all values of the array using the `do` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The three-dot notation (`…`) might be new and even weird to someone coming
    from PHP, but if you just read through the code, it almost makes sense. This notation
    is called range and you’ll see it used often in Ruby. The notation creates a counter
    that goes from 0 to a value less than 4 (3, in this case), then increments the
    counter by 1\. This counter is then assigned to the `i` variable. The example
    would read something like, “For the `i` variable, create a cycle that starts with
    0, ends in 3, increases by 1, and prints each value of the array one by one.”
    The output would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Did you notice that the `…` notation excludes the number 4, equivalent to [0,4]
    in mathematical notation? Well, what if we wanted the range to be inclusive –
    for example, [0,3] – which would include the last number? Ruby also has a two-dot
    notation (`..`) that *does* include the last number in its range. So, we could
    rewrite the example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would be the same as the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You may use the three-dot or the two-dot notation as you see fit. If you are
    more interested in the topic of ranges, I suggest that you look at the documentation
    regarding this topic: [https://ruby-doc.org/core-2.5.1/Range.html](https://ruby-doc.org/core-2.5.1/Range.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s get back to arrays. Just like PHP, Ruby has some internal methods
    to work with arrays. As an example of this parallel design, PHP has a function
    to tell us the size of an array. The function is called `count()` and has a Ruby
    equivalent called `size()`. Just remember that everything in Ruby is an object,
    so you would not use `size(instruments_played)` as you would in PHP. Instead,
    to print the number of elements of our array, we would call the `size()` method
    as a method of the `instruments_played` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Since the array has four elements, we would get an output of `4`. Additionally,
    there is another method that does the same thing called `length`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two more internal methods that I find extremely useful are `first` and `last`.
    These methods (as we can infer from their names) let us fetch the first and last
    elements of the array, respectively. Let’s try the `first` method with some variable
    interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This would output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `last` method works in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This would output as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we’ve combined a string and a variable’s content to create a
    new string. This combination is referred to as variable interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: Variable interpolation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Variable interpolation (a term you will hear a lot in programming) involves
    substituting a variable with its value. It’s extremely useful when printing messages
    and/or showing data to users. When used correctly, variable interpolation lets
    us embed a variable value inside a string. Let’s take the code from our previous
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of layers to the string interpolation feature, so let’s analyze
    it in parts.
  prefs: []
  type: TYPE_NORMAL
- en: First, on the second line of the code, we can see that, inside the string, we
    have added a special block, which starts with the `#` symbol followed by a set
    of curly brackets ( `#{ }` ). When used inside a string, this block determines
    that we are going to use interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, everything inside the curly brackets will be interpreted and returned.
    In this example, the code inside the curly brackets is `instruments_played.last`,
    which holds the last element of the array. This last element of the array will
    be returned as part of the string, thus finalizing the interpolation. This only
    works when the string is defined with double quotes (`“”`).
  prefs: []
  type: TYPE_NORMAL
- en: Combining array types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we’ve seen arrays that hold the same type of data – we had an array
    exclusively made of strings and another array exclusively made of integers. But
    one last feature worth noting regarding Ruby arrays is that they can also combine
    different variable types within the same array. As a random example, let’s add
    unrelated values to an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In this array, we are combining different types of data (integers, strings,
    Booleans, and floating points) into a single array. Not all languages support
    this behavior within arrays, but both Ruby and PHP do.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned when we started looking at variable types, Ruby is dynamically
    typed. One of the features of a dynamically typed language is that arrays can
    combine the type of data they hold. In contrast, in a strongly typed language
    such as Java, arrays are forced to have the same type of data on each element
    – that is, you can only have an array of integers or only an array of strings.
    That is not to say that Ruby is better than Java or that, in general, strongly
    typed languages are better than dynamically typed languages. They just have different
    designs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re interested in learning more regarding the subject of arrays, please
    take a look at the official Ruby documentation: [https://ruby-doc.org/core-2.7.0/Array.html](https://ruby-doc.org/core-2.7.0/Array.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Hashes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at another type of variable that PHP developers will
    also understand very easily: hashes. A hash is an array but the main difference
    is that it has textual indexes instead of numbered indexes. Hashes are very similar
    to arrays in their behavior, but with the difference that we use strings to reference
    certain values. In PHP, these are known as associative arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example in action. Here, we have a hash with the index in English
    and the value in Spanish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to what we could do with an array, to get the value of a single index,
    we could type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We would get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the index is a string and is more readable to a human. It’s
    this readability where a hash can come in handy. Let’s rewrite the first example
    we used at the start of the *Exploring types of variables* section so that it
    uses a hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of having separate variables for `name`, `age`, `is_married`, and `books_read_this_week`,
    we have a hash that groups all of these values into a single variable called `person`.
    Now, we can reference each index, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we could print a very readable message with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Even for a developer who is just starting Ruby, this is not just readable but
    understandable regarding the intent of the code. As expected, it would output
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Hashes are super useful when working with mapped data that needs to be read
    by a human. It’s also useful when you’re working with data that is changing.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the last variable type that we’re going to see, which I must
    say is more complicated than I wish it were. The types of variables we’ve seen
    so far are mutable, which means that they can be changed. However, sometimes,
    we don’t need certain values to change – we need more of a location where this
    value is stored. Symbols do just this.
  prefs: []
  type: TYPE_NORMAL
- en: Symbols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Symbols are highly optimized identifiers that map immutable strings to fixed
    internal values. They are also immutable strings themselves – that is, they do
    not change their value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept is a bit complex, but I believe it will be more understandable
    with an example. Let’s take a simple string and view what its value is pointing
    to. So, run this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'When you create a string, Ruby will take the string object and internally save
    it somewhere in memory. The `object_id` method saves this internal unique identifier.
    Notice what happens when you call the same line a couple of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The first string is pointing to a different address than the second and third
    strings. So, every time we type the `name` string, Ruby creates and stores a brand
    new string. Even though they have the same value, they are still different. As
    an analogy, it would be like having a file with the same name but in different
    folders. Even if the files had the same contents, they are still different files.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not the same with symbols. Symbols refer to the same memory location.
    Let’s try the same example with symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This should also return a unique identifier number. However, what happens when
    we call this same code multiple times?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Instead of returning different random numbers, this time, we get the same (though
    still random) number. This is because every time we call `:name`, the Ruby interpreter
    is looking at the same location in memory. Using the same analogy, it would be
    like creating a unique file, and then whenever we needed the file again, we would
    create links that would point to that original file. So, even if the links were
    in different folders, they would point to the same file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We won’t dive into this subject further for now as it’s enough to just understand
    the basics of it, but we will see more examples in future chapters, particularly
    the Ruby on Rails ones. At the moment, just remember this good rule of thumb:
    use a symbol when the identity of an object is important. Should the content be
    more important, use a string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to know more about symbols now, the following website is
    a great resource: [https://medium.com/@lcriswell/ruby-symbols-vs-strings-248842529fd9](https://medium.com/@lcriswell/ruby-symbols-vs-strings-248842529fd9).'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve learned all about variables. But what good is a variable if we
    can’t make decisions regarding these variables? That’s our next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Using conditional statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know what types of variables we can use in Ruby, let’s give these
    variables some more practical use.
  prefs: []
  type: TYPE_NORMAL
- en: The if statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now, we should all be familiar with the `if` statement and its structure:
    if a sentence is true, the code should do or return something.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the person hash that we used in the previous section as our base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Using that, we can create a basic `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This is pretty much self-explanatory. This would read: “If the value in `person["married"]`
    is equal to true, then print `Person is married`.” The `end` keyword limits when
    the `if` statement is done – that is, anything after the `end` keyword is not
    part of the block. You’ll see the end `key` keyword a lot in Ruby – just keep
    in mind that it is used to delimit certain blocks of code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While the previous code is useful, there is a better way to write this – the
    “Ruby way.” First, we remove `== true` and if we are only going to execute a single
    action, we can write it in one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This reads much like a sentence and you’ll see a lot of Rubyists using this
    useful one-liner.
  prefs: []
  type: TYPE_NORMAL
- en: The if-else statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need a different action in case the value is not true, then you should
    use the `if-else` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This would output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Just remember, the `if` statement evaluates the condition. If the condition
    is true, Ruby executes the code that is on the next line. However, if the condition
    is false, Ruby skips the first block, goes to the `else` statement, and executes
    the code that is right after the `else` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The ternary operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a last example of the `if` statement, we also have the ternary operator,
    which we also have in other coding languages; though it’s not as readable, it’s
    still useful. Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'With the ternary operator, the condition between the `=` sign and `?` will
    be evaluated. If the condition is deemed as true, then the value to the left of
    the `:` symbol is returned. If the condition is deemed as false, then the value
    to the right of the `:` symbol is returned. In this case, the value stored in
    `person["age"]` is 35\. Since 35 is over 30, the `over` string will be stored
    in the `over_or_under` variable. The second line of code will simply interpolate
    this value and should return this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: While this is not as readable as the previous `if` statements, the code is still
    valid and available in most programming languages. The ternary operator is the
    same in PHP and is useful when you need to store a value that depends on a condition.
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statement is probably one of the most used resources in programming,
    so it’s a good idea to understand the syntax, the use, and the different use cases
    that it solves. Now, let’s look at another resource that uses true/false values
    to run code.
  prefs: []
  type: TYPE_NORMAL
- en: Repeating code with loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have come to our next topic, which is loops. Ruby, just like other languages,
    has different ways of making the same code execute repeatedly. When we discussed
    arrays, specifically the array that contained instruments’ names, we saw an example
    of the `for` loop, which was used to print each instrument contained in the array.
    But let’s look at another type of loop, one that is more commonly used: the `while`
    loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `while` loop lets us repeat a code execution that is determined by a true/false
    condition. Let’s say we wanted to print a number from one to three. We could create
    a `print` statement and simply repeat it three times while incrementing the value.
    However, let’s try a different way that will be more concise. Start by creating
    a `counter` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start the `while` loop cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This may seem like valid code, but we will get an error from the Ruby interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because of a common erroneous assumption that most Ruby newbies make.
    If you use PHP or JavaScript, you will be used to the `++` operator, which is
    equivalent to adding 1 to a variable. It’s the same as writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the `++` operator does not exist in Ruby (so this also goes for the
    `––` operator, which decreases a value by 1). So, instead of using the nonexistent
    operator in Ruby, we would have to rewrite our code so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This would output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The `while` statement has a very similar structure to the `if` statement, but
    instead of just executing a line of code, the `while` statement evaluates the
    condition and will execute the code if the condition is still met.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, before entering the cycle, the `counter` variable has a value
    of `1` – as the condition to continue the cycle is for the value to be less than
    or equal to 3, the condition is met. Since the condition is met, Ruby will execute
    the code that is before the `end` keyword, so the number 1 will be printed and
    a 1 will be added to the `counter` variable. Since this is a cycle, Ruby will
    go back and read the condition again, but this time, `counter` has a value of
    `2`, so it will execute the whole block again. Once the value of the `counter`
    reaches `4`, Ruby will determine that the `while` condition is no longer met and
    break the loop without executing the code inside it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more useful example of loops is when we work with arrays. We already saw
    one way to iterate through arrays with a counter, but we also have a method called
    `each` to iterate through every element of an array. Let’s take the `instruments_played`
    array again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `each` to go through each element, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will loop through the array so that we don’t have to repeat code
    for every element of said array. And this is exactly what loops are for: to write
    less code. For every element in the array, Ruby will print the value of the element
    (we called it `instrument` for readability, and just for this example, but we
    can call it anything we want).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we can compress this code into a single line by using curly brackets,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This will have the same output as the previous example, but as you can see,
    it’s more concise and it’s quite readable. Additionally, the `each` loop helps
    us write code that will adapt to the size of the contents. Should we add another
    element to the array, we would not have to modify anything within our loop to
    print the added instrument. The loop would do so automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, what happens when we want to access the index of an array? We have
    a method just for that. The `each_with_index` method will make the index of the
    array available, as you can see in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Again, both `instrument` and `index` are just aliases – we can name them anything
    we choose – but the order in which we type them is what will decide which value
    will be stored in them. The array element value will be stored in the first variable
    (`instrument`) and the array counter will be stored in the second variable (`index`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We could very well rewrite the example, like so, and still get the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The new code will have the same output as before, but this time, we renamed
    `instrument` and its `index` to `array_element` and `array_index`, which at this
    point was just a personal choice I made to make the code make more sense to me.
    This goes to show that, as programmers, we decide how to name variables in the
    defense of readability (trust me – the more you grow as a programmer, the more
    time you’ll spend trying to name variables).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we know how to repeat code by using loops and by iterating through
    arrays. Instead of writing the same code multiple times, we exploited Ruby’s `while`
    statement and the `each` method to improve efficiency and readability within our
    code. But we are not done yet. Ruby has a few more tricks up its sleeve to further
    improve readability. We’ll take a look at these tricks in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ruby language enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the most part, as developers, we should always strive to increase the readability
    of our code as this will help everyone in the long run. I’ve been in scenarios
    where I’ve looked back at my code and had trouble understanding what the code
    was doing. That meant that my code was poorly written. Imagine the toll that this
    poorly written code may have on the next developer or team that has to use it
    or, worse, improve it. In contrast, if my code was well written, we wouldn’t have
    this issue. This is me saying this: please write readable code, and I can’t stress
    enough the lengths Ruby developers will go to make their code readable over any
    other enhancement in our code. Ruby comes with some additional tools to achieve
    this.'
  prefs: []
  type: TYPE_NORMAL
- en: The unless sentence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One example of these options is a language enhancement called the `unless` sentence.
    The `unless` sentence is a negative `if` sentence – that is, it will execute the
    code only when the condition is *not* met. Let’s see it being used in an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume the following scenario: we have a product aimed at unmarried individuals.
    For simplicity, we will just print out the message “Promo for singles” if the
    person is not married. Let’s try to write the code for that. Let’s take our previous
    hash example for a person’s details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s change the `is_married` value to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have declared that hash, we can try to print a message if the person
    is single:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the person is not married, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'And while the code works, it simply doesn’t look good. We could use the bang
    (`!`) operator to invert the Boolean value from true to false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Though this code still works, it still looks bad. Let’s look at the options
    Ruby has to fix this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most programming languages, you’ll see a lot of sentences that read “if
    not.” Of course, this is awful to read and goes against the readability principles
    of Ruby. To solve this issue, Ruby’s creators added the exact sentence to make
    this more readable: `unless`. It works similarly to the `if` statement but will
    execute the code if the condition is deemed false.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, this is helpful when we have code to be executed only when the
    person is not married. So, instead of writing an if negative sentence (if a person
    is *not* married), `if !person["is_married"]`, we could rewrite the example as
    follows (unless a person is married):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'This is looking much better already, but just like the `if` statement, we can
    convert it into a one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very Ruby-esque sentence, reading exactly like it behaves: “Print
    “Show promotion” unless the person is married.” This is about as readable as it
    gets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `unless` sentence is so useful that one of the most used PHP frameworks
    today, called Laravel, has borrowed this functionality in the form of a directive:
    [https://laravel.com/docs/9.x/blade#if-statements](https://laravel.com/docs/9.x/blade#if-statements).'
  prefs: []
  type: TYPE_NORMAL
- en: The until loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like the `unless` sentence, the `until` loop solves the same issue with
    negative conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of writing “while not,” which reads horribly, the `until` sentence takes
    a false statement and executes the loop until the condition becomes true.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `until` sentence takes a false statement and executes the loop until the
    condition becomes true. Let’s look at our `while` example from earlier again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `until`, we can rewrite it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is the same as with the `while` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Our code would read like “Print the counter until the counter is larger than
    3.” Whether you choose to use the `while not` sentence or the `until` sentence
    will be up to you as they both seem readable, but the fact that Ruby has both
    sentences available tells us that Ruby is designed to be read and not just programmed.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic returns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working within the IRB, you may have noticed that whenever you type variables,
    the IRB will output the value you just typed. Even on our last `until` statement
    example, the shell first outputs the three numbers and then a final `=> nil` value.
    If you take a closer look at the other examples, you’ll see a similar behavior.
    This is because Ruby always attempts to return a value – be it a declaration,
    a method, or just a string, Ruby will try to automatically return a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re not convinced, let’s use the IRB to see it more explicitly. So, type
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'We are not declaring the string or assigning it to a value; we are simply typing
    a string into the IRB shell. And what does the shell do? It returns the value
    we just typed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Coming from a PHP background (and other languages for that matter), grasping
    the “automatic return” feature is crucial to understanding more complex Ruby code.
    It’s important to know that PHP (and most languages) do not behave this way. PHP
    (and other languages) require us to explicitly return the value, while Ruby does
    this by default. In PHP, this is achieved by using the `return` sentence. That
    said, from time to time, you will encounter Ruby code with an explicit `return`
    statement, as it will sometimes increase readability. To further understand this
    feature, for the next few examples, we’ll exit the IRB and continue by creating
    source code files and running Ruby to execute them. You may still follow the next
    examples in the IRB, but I would highly recommend that you follow them with source
    code files instead of the IRB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we wanted to create a method that prints a message on the screen.
    We can do so by creating a file called `methods.rb`. This file will contain the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: For now, we’re defining a method called `message` that returns a string. In
    Ruby, we define a method with the `def` reserved keyword and limit the definition
    with the `end` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add another method called `say()` and, inside that method, call
    the `message()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we haven’t done anything out of the ordinary – we just have one method
    calling another. If we opened a shell and executed this script, it would appear
    to be doing nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This script outputs nothing, but behind the scenes, it has two methods that
    are now defined and ready to be used. The `message` method is explicitly (not
    automatically) returning a string because of the use of the `return` keyword.
    This code still looks familiar, but not for long.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s print out the contents of the `say()` method with this last line
    on the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this again, we will see the following message on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is where Ruby behaves differently to PHP. While you can explicitly
    use the `return` function in Ruby, Ruby does not need the `return` statement because
    it already does it automatically as part of its default behavior. So let''s try
    it out by removing the return statement from both the `message()` and the `say()`
    methods. Your final code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Admittedly, this looks weird, especially for someone from a PHP background.
    My advice to you is to just try to get used to this syntax. You’ll see it very
    often in Ruby. To make it easier to learn this rule, we can generalize and say,
    “Every sentence in Ruby will return a value.” With some notable exceptions, this
    is true for all Ruby sentences.
  prefs: []
  type: TYPE_NORMAL
- en: Optional parentheses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another weird but useful syntactic enhancement is that the parentheses on Ruby
    methods are purely optional – so, you can choose whether to include parentheses
    or not. And just like every Ruby resource we’ve learned about so far, we should
    try to use it to make our code easier to read, but we should also try to avoid
    overusing it. Excessive use of this feature could have us formatting our code
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this snippet is that we don’t know if the comma is being used
    for separating the arguments for `method1` or `method2`. In this case, we should
    use parenthesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it’s more than clear that `method2` is receiving two arguments while `method1`
    is just receiving one argument. Let’s look at a more simplified example by removing
    the parenthesis from our previous examples. Our example will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The output is the same as before, but now, the code looks a lot more like proper
    sentences instead of code syntax. You’ll see a lot of code similar to this, especially
    when you start using Ruby on Rails. Because of the lack of parenthesis, Ruby allows
    us to have a method and a variable with the same name. In this case, we have a
    method called `message` and a variable called `message`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This scenario, if left unexplained, can lead to a lot of confusion later on.
    To that effect, let’s take our previous example and tweak it so that we have a
    better understanding of this naming behavior. First, we’ll add a parameter to
    the `say()` method so that the printed message is dynamic. This parameter will
    be named `message`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: In other programming languages, we would expect an error if we tried to run
    this code, and this is where Ruby can sometimes be overwhelming when you’re starting
    to use it. We purposely named the parameter `message`, which means we now have
    a `message` method and a `message` local variable. When reaching the `puts message`
    line, we are not sure if we are calling the `message` parameter or the `message`
    method without the parentheses. Unfortunately, this confusion happens more often
    than not, or at least that was my experience when I started to use Ruby more professionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, my advice here is to try to use parenthesis when calling methods, even
    when the syntax doesn’t require us to use them. For teaching purposes, we won’t
    be doing it in this example. So, our final source code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'As you would expect (or not), when executing the script on the shell, we’ll
    get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Why did it print that string and not the `"This is a message"` string? Well,
    this is because the `message` variable took precedence over the `message` method.
  prefs: []
  type: TYPE_NORMAL
- en: While this feature may not seem pretty (I don’t like it that much), I guarantee
    you that you’ll come across it from time to time, and you should be prepared for
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Questionable exclamation method names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a cherry on top of the language enhancements in Ruby, its creators have
    also included a naming feature to add readability to our methods: the exclamation
    mark (`!`) (also known as a bang) and the question mark (`?`). They don’t change
    behavior in any way, but they allow for a line of code to read as a question or
    as an exclamation. Methods named with the exclamation mark are called dangerous
    methods because they modify the object from where they are called. Methods named
    with the question mark are called predicate methods and, by convention, return
    a Boolean.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, we’ll create a method with the question mark. Let’s
    create a new file called `enhanced_naming.rb` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$married_status` variable is a global variable, which simply means that
    we can modify or access its contents on a method or outside the method. In this
    case, we defined a method that gets the `$married_status` value. However, knowing
    that we can add the `?` to the name of this method, let’s rename the `is_married`
    method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s use an already familiar one-liner to print a message for a married
    person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: While adding `?` to the name of the method does not affect its behavior, it
    does change the sentence into an obvious question. We’ll see this syntax very
    often in Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can use the bang symbol (`!`) as part of the name of a method.
    Again, adding it to the name doesn’t affect the behavior by itself, but it tells
    whoever is reading the code that we’re doing something different than just calling
    a method. As an example, let’s rename our `marry` method to `marry!` and see what
    it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'As a convention adopted by the Ruby community, the bang symbol (`!`) will tell
    the reader (of the code) that we are making a change within an object. A method
    without the bang symbol would simply return a value, but not affect the object
    itself. So, in this case, we are changing the `$married_status` value to `true`.
    This is what the code should look like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Sadly, when we run this example, we don’t see any output. This is because the
    initial value of the global `$married_status` variable is `false`, and our code
    will only print a message if the value is `true`. Now, let’s call the `marry!`
    method and copy the one-liner again at the end of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run the code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: What’s happening here? We have a global `$married_status` variable with an initial
    `false` value. Then, we have two methods – one to get the `$married_status` value
    and another to change it to true. Finally, we attempt to print the message but
    since the initial value is `false`, the message is not printed. By calling the
    `marry!` method, we change `$married_status` to `true`, which makes the last line
    of our script print out the message.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby brings language enhancements to programming merely to improve code readability.
    I’ve seen code written so beautifully that it reinforces the idea behind not writing
    comments on your code, but rather lets your code speak for itself. Once you start
    using them regularly, you will appreciate them more and more and you’ll wish all
    languages had these enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to write, execute, and require scripts with
    the Ruby binary, along with how to use the IRB to execute Ruby code directly on
    the command line without having to write source code.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we reviewed Ruby’s syntax for writing variables, the syntax for
    `if` statements, and how to loop through both cycles and arrays. Finally, we learned
    some of the language enhancements that Ruby has and PHP doesn’t so that we can
    read and understand more complex Ruby code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to write Ruby code to solve real-life examples. We’ll start
    doing this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
