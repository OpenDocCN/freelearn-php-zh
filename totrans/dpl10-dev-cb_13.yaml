- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing Automated Tests in Drupal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we reviewed how to add custom functionality to Drupal
    with controllers, routes, responses, custom modules, custom entity types, hooks,
    and more. With even just a little bit of code, you can add a lot of functionality
    to your Drupal application.
  prefs: []
  type: TYPE_NORMAL
- en: But how do you know that *it works*? Sure, you can click around and try things
    out – but it is not a 100% guarantee that things are working under the hood as
    intended. The more code and features you add, the harder it will be to verify
    that existing functionality is still intact without providing tests.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing automated tests, you can ensure that the code and features you
    have added actually work the way you expect. Most importantly, automated tests
    help significantly reduce bugs and regressions making it to your production website,
    which in turn will help build your confidence as a developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drupal provides several classes of tools to help provide tests for your application.
    This chapter covers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the PHPUnit test suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running PHPUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a unit test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a kernel test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a functional test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a functional JavaScript test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a NightwatchJS test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are five types of tests you can run and write in Drupal – **unit tests**,
    **kernel tests**, **functional tests**, **functional JavaScript tests**, and **NightwatchJS
    tests**. Which ones you write will depend on the kind of feature(s) you are creating
    and the level of test coverage you are willing to accept to prove your code is
    working. Let’s take a look at each of these types of tests. You can find the full
    code used in this chapter on GitHub: [https://github.com/PacktPublishing/Drupal-10-Development-Cookbook/tree/main/chp13](https://github.com/PacktPublishing/Drupal-10-Development-Cookbook/tree/main/chp13)'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit tests are tests that do not need a Drupal installation to evaluate because
    they test code that executes code only. They are the lowest-level test you can
    write. Unit tests are useful for testing plugins, services, or other code that
    do not require interaction with the database. If you need to write tests that
    require a database or Drupal environment in some way, you would write a kernel
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kernel tests are the next step up from unit tests. A kernel test is a test that
    can execute and test functionality that requires some level of database interaction.
    If you want to test the functionality of features that act when saving entities,
    test field formatters, check user role access to routes, or test controllers and
    their responses, a kernel test is what you would write. When executing kernel
    tests, an instance of Drupal is installed where the tests are performed. This
    level of isolation is what permits you to test interactive functionality without
    interfering with your current working database. You are able to specify modules
    to install and configurations to include in a kernel test, making it an excellent
    way of testing your modules. These are the most common tests you will see in Drupal.
  prefs: []
  type: TYPE_NORMAL
- en: Functional tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional tests are the highest-level test you can write. Like kernel tests,
    a functional test will install a working copy of Drupal to run the tests in. These
    tests are evaluated with a headless browser and are useful for testing functionality
    from the user perspective. These types of tests are good for testing user workflows,
    user permissions, and evaluating page content for what you expect to see. For
    example, if you have a feature where a user navigates to a site, logs in, navigates
    to the Drupal admin, and sees sections that other roles should not, you can evaluate
    this with a functional test.
  prefs: []
  type: TYPE_NORMAL
- en: Functional JavaScript tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional JavaScript tests are executed using a real browser, such as Chrome
    or Firefox. Regular functional tests run in a headless PHP browser emulator called
    Mink under the hood. Since it is not a full-fledged browser, it cannot test any
    JavaScript-related features that real browsers such as Chrome have. If you want
    to test features related to AJAX, cookies, or DOM-related JavaScript events in
    the browser, you would write a functional JavaScript test. Functional JavaScript
    tests will require the presence of a browser such as Chrome and tools such as
    Selenium to orchestrate Chrome under test.
  prefs: []
  type: TYPE_NORMAL
- en: NightwatchJS tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to a functional JavaScript test, `yarn` to run and interact with. If
    you are a developer who tends to write far more JavaScript than you do PHP, you
    may be interested in using NightwatchJS instead of **PHPUnit**. Another added
    benefit is that you can write unit tests for the custom JavaScript you write,
    which is something you cannot test with PHPUnit.
  prefs: []
  type: TYPE_NORMAL
- en: Functional JavaScript and NightwatchJS tests require the most effort to set
    up and implement, but they can be very valuable because they are running under
    the same setup, conditions, user role(s), and browser that your visitors are using.
    They also take the longest to execute but still run in a fraction of the time
    any human could perform the same tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the PHPUnit test suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the preceding types of tests (with the exception of NightwatchJS tests)
    are executed from one test harness, PHPUnit. We can add any number of tests to
    our custom modules or custom themes and run them using PHPUnit – all we have to
    do is install it and configure it to point at our test files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing to do before proceeding is to install all the test dependencies
    so that you can actually run tests in Drupal. Drupal has a specific Composer package
    that brings in PHPUnit and the required dependencies for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up a Terminal (command line) at the root of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following Composer command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `drupal/core-dev` package will bring in PHPUnit and various dependencies
    to your project that are needed for writing and running tests in Drupal.
  prefs: []
  type: TYPE_NORMAL
- en: The --dev flag
  prefs: []
  type: TYPE_NORMAL
- en: Note that when installing, we are using the `--dev` flag. This tells Composer
    to list these packages under the `require-dev` section in `composer.json`. The
    `drupal/core-dev` package is not something you want to have in your production
    environment; it is for testing only.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we need to configure PHPUnit so that it knows where our tests reside.
    Drupal core ships with an example `phpunit.xml.dist` file in the `core` directory.
    This is the file that PHPUnit reads when it executes. You don’t have to understand
    it line for line, but there are a few areas we need to adjust so that it will
    execute within your custom module directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the `phpunit.xml.dist` file out of the `core` directory and place this
    file in the root of your project. Rename the file `phpunit.xml` and make the following
    edits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the bootstrap attribute on the `<phpunit>` tag at the top of the document
    to point to the core tests’ `bootstrap` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to run kernel or functional tests, edit the following environment
    settings in the `<``php>` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: DDEV, Lando, Docksal, or Docker?
  prefs: []
  type: TYPE_NORMAL
- en: If you use DDEV, Lando, Docksal, or other readymade tools to run Drupal locally,
    check their documentation and what the service names are. Depending on which one
    you use, the preceding values can differ for `SIMPLETEST_BASE_URL`, `SIMPLETEST_DB`,
    and `MINK_DRIVER_ARGS_WEBDRIVER`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, edit the `testsuites` section to point to your custom modules directory.
    You need to specify a `testsuite` entry per test type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These changes will tell PHPUnit where to locate the tests that we write for
    our custom modules, located in `web/modules/custom`. Tests live in the `tests/src`
    directory of a module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each type of test lives in its own directory within that:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests go into `tests/src/Unit`
  prefs: []
  type: TYPE_NORMAL
- en: Kernel tests go into `tests/src/Kernel`
  prefs: []
  type: TYPE_NORMAL
- en: Functional tests go into `tests/src/Functional`
  prefs: []
  type: TYPE_NORMAL
- en: Function JavaScript tests go into `tests/src/FunctionalJavascript`
  prefs: []
  type: TYPE_NORMAL
- en: 'By defining each type of test as its own test suite in `phpunit.xml`, we can
    choose which kind of test type to execute using PHPUnit, which we will look at
    in the next section. You can also set several `testsuite` entries, or several
    directories within a `testsuite` entry. For example, if you wanted to include
    all unit tests from contributed modules when you run PHPUnit, you can add another
    `directory` entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The reason we have created a `phpunit.xml` file and placed it at the root of
    the project is that the file prevents the project from being overwritten or removed
    the next time you update Drupal. This way, you can commit the configuration to
    your repository and share it with a team, as well as be able to run tests in continuous
    integration services provided by GitHub, GitLab, or CircleCI.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to know that this is just one possible way to set your PHPUnit
    configuration. There are more settings that you can configure here once you are
    more comfortable with PHPUnit.
  prefs: []
  type: TYPE_NORMAL
- en: There are other settings that can output test coverage results, where to save
    screenshots of test failures, additional test listeners, logging output, and so
    on. Be sure to check the online documentation ([https://phpunit.readthedocs.io/en/9.5/configuration.html](https://phpunit.readthedocs.io/en/9.5/configuration.html))
    for configuring PHPUnit for more information.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you execute PHPUnit, it uses the `phpunit.xml` file to inform how it executes.
    It will scan all listed directories for test files and execute them accordingly,
    providing test feedback in the command-line window (or IDE). Every project you
    write tests for will require a `phpunit.xml` file like this in order to run any
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you plan on writing functional JavaScript tests, you will also need Chrome,
    Chrome WebDriver, and Selenium. Installing and configuring this can vary, depending
    on whether you are using Lando, DDEV, Docksal, Docker Compose, or other tools
    to run Drupal. Please consult the documentation for the best information on how
    to install these tools to properly execute functional JavaScript tests. Assuming
    you are using `services` section of your `.``lando.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`chrome` becomes a new wired service in the `MINK_DRIVER_ARGS_WEBDRIVER` setting
    in `phpunit.xml`, which makes this all work for functional JavaScript tests).
    If you want to install and use Firefox as an alternative browser to test with,
    you can do that as well, but Chrome is the most common browser used for testing.'
  prefs: []
  type: TYPE_NORMAL
- en: The way these tools are added can vary, depending on what you use. Please consult
    the documentation on the best approach to add Chrome and Chrome WebDriver. There
    are simply too many stack-specific configurations to cover in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Running PHPUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we can verify that we have set up correctly by executing the `phpunit`
    command. There are no tests yet, but that’s okay. This step just verifies that
    the tool is installed and our configuration file is properly read.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consult the documentation
  prefs: []
  type: TYPE_NORMAL
- en: From here, we are going to provide bare-bones, verbose commands to use PHPUnit
    to execute tests. If you use Lando, DDEV, Docksal, or otherwise, please consult
    their documentation on how to best run PHPUnit. They usually have command wrappers
    that are small and convenient.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your command line, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is the main command you will run. PHPUnit will automatically detect our
    `phpunit.xml` configuration in the project directory.
  prefs: []
  type: TYPE_NORMAL
- en: Can’t find phpunit?
  prefs: []
  type: TYPE_NORMAL
- en: If you get an error about the `phpunit` command not being found, you may need
    to instead use the full path to it from the project root with `vendor/bin/phpunit`.
    Composer should automatically alias commands for you, but depending on how a project
    is set up, this may be required.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also run specific `testsuites` or individual tests by adding the `--testsuite`
    and `--filter` arguments to `phpunit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will run all unit tests found in the directories listed
    in your `unit` testsuite in `phpunit.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will run only the `FooBarTest` unit test. These two approaches
    are useful for testing certain `testsuites` only or specific tests themselves
    for faster feedback, when testing, debugging, and iterating your code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you execute PHPUnit, it scans all listed directories in the `phpunit.xml`
    file and provides test feedback in the command-line window.
  prefs: []
  type: TYPE_NORMAL
- en: In this instance, PHPUnit said that no tests were found or executed, which is
    correct because we do not have any yet. We are now ready to write our first unit
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s write our first test. As previously mentioned, a unit test is the lowest-level
    type of test you can write. It only executes and tests raw PHP code that has no
    dependencies on services such as a connected database or other integrated APIs.
    This means the test can execute using PHP only.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s create a scenario that will help you think about when and how to apply
    unit testing. Imagine you have to provide data to a frontend component. The frontend
    developer has requested that you provide all JSON keys in `camelCase` format in
    the API response. `camelCase` would turn strings such as `field_event_date` into
    `fieldEventDate`.
  prefs: []
  type: TYPE_NORMAL
- en: '`snake_case` is used in many places in Drupal; the most common place you will
    see this is with machine names (such as on the preceding event date field). All
    machine names in Drupal are in `snake_case`.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a very simple example but perfect to illustrate how we can wield a unit
    test to test our class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go ahead and create a custom module called `chapter13`. This is where we will
    be writing example code and its tests for the rest of this chapter. Refer to [*Chapter
    4*](B18548_04.xhtml#_idTextAnchor131), *Extending Drupal with Custom Code*, if
    you need a refresher on how to create a custom module in Drupal.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the custom module created, let’s add the `CamelCase` class in the `chapter13`
    module under the `src` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Looks like it works, right? Let’s prove it with a test.
  prefs: []
  type: TYPE_NORMAL
- en: In your custom module, create a `tests` directory. Under this directory, create
    an `src` directory, and within the `src` directory, create a `Unit` directory.
    You should have a path now that looks like `chapter13/tests/src/Unit`. Note that
    the `src` directory in your `tests` directory is different than the `src` directory
    at the root of the `chapter13` module, where the `CamelCase` class resides.
  prefs: []
  type: TYPE_NORMAL
- en: In the `chapter13/tests/src/Unit` directory, create a new file and name it `CamelCaseTest.php`.
    All test files must have `Test` at the end of their filenames to be discovered
    by PHPUnit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our test file needs to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide test data to convert with the `CamelCase` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assert that the convert method returns what we expect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Any method that begins with `test` in your test class will be evaluated by
    PHPUnit. With that in mind, let’s go ahead and fill in our unit test in `CamelCaseTest.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Go ahead and run `phpunit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It will result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This output indicates that the test was called three times (one for each set
    of data in `@dataProvider`) and each one passed. In other words, `$input` equaled
    `$expected`, which is what `assertEquals` evaluates. If a test were to fail, this
    output would indicate what test failed and on what line.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHPUnit reports that all three tests pass. But, wait – didn’t we only write
    the `testCamelCaseConversion` test method?
  prefs: []
  type: TYPE_NORMAL
- en: 'When the test is executed, PHPUnit detects a special annotation in our test
    method called `@dataProvider`, which tags the `exampleStrings` method. The `exampleStrings`
    method provides an array of data. Each array contains a value to send in and the
    value we expect to get back. PHPUnit will loop the data provider values, so our
    test method is called three times (one for each set of values) and evaluates the
    test. This means PHPUnit sees the test method called like this when executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The three values test that the method works for two or more words and returns
    the proper case.
  prefs: []
  type: TYPE_NORMAL
- en: Within the test, we pass the input along to `CamelCase::convert`. From that
    method, we pass the value it returned to `assertEquals`, one of the many value
    assertion methods of PHPUnit.
  prefs: []
  type: TYPE_NORMAL
- en: Every item you add to a data provider will be asserted by the test method(s)
    that use them. `dataProviders` is an excellent way to test our code under a variety
    of scenarios. Therefore, we know that any string passed to convert will be transformed
    from `foo_bar` to `fooBar` and returned. The test proves that.
  prefs: []
  type: TYPE_NORMAL
- en: So, how does automated testing help here? With our setup, any developer on a
    team is able to run the `testsuites` and see their output. If they fail, they
    can see what code is failing and where. This provides an opportunity to fix the
    code before it is deployed to production.
  prefs: []
  type: TYPE_NORMAL
- en: Under continuous integration setups, you can prevent code from being merged
    into your main branch until all tests pass. As we mentioned, this is an excellent
    way to reduce bugs and errors from surfacing on production to your users.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over time, requirements can and often do change. Assume that after you have
    deployed this code, your frontend developer returns and asks that any string such
    as `foo-bar` is also converted to camel case.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our test in place, we can add this new case to our data provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the test now, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This is fine – we have not updated our implementation yet. Adding new cases
    to the test first lets us iterate and improve the implementation code until the
    test passes. This provides a fast feedback loop because we can modify the implementation
    in the `CamelCase` class all we want. If the tests all pass, we know we have met
    the requirements and that our functionality works, and we can move on to other
    features in our module.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing tests first before having any implementation code is referred to as
    **test-driven development**. This means the tests drive the specification or requirements,
    and the implementation code makes them pass. There are many schools of thought
    on whether you should write all tests first or not.
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to testing, it is fine to write some initial code for a proof
    of concept if you need to hash out an idea in your Drupal module. You can always
    add tests to it at any point during development. The important point is to add
    tests for your code; don’t worry so much about when.
  prefs: []
  type: TYPE_NORMAL
- en: The more you practice and write tests, the better you will get, and you will
    eventually shift to writing the tests first.
  prefs: []
  type: TYPE_NORMAL
- en: Continue experimenting with the `CamelCase` class and its `CamelCaseTest` class.
    See whether you can invent some new requirements, change the code, run the tests,
    and get them to pass.
  prefs: []
  type: TYPE_NORMAL
- en: Drupal core has hundreds of great examples of unit tests. The most-popular contributed
    modules are useful as well. Be sure to check them out if you are stuck or need
    guidance.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the basics of unit testing in Drupal, let’s look at kernel
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a kernel test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s build upon the previous example. Assume now that stakeholders have asked
    you to output a field value on the screen in the camel case format. The good news
    is we have a working implementation and unit test, so we can make short work of
    this task in Drupal.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we need to make a field formatter class for string fields. When
    the formatter is used on a field to display output, we want to run the user input
    through our existing `CamelCase` class. If you need a refresher on field formatters
    and managing entity displays, refer to [*Chapter 2*](B18548_02.xhtml#_idTextAnchor059),
    *Content* *Building Experience*.
  prefs: []
  type: TYPE_NORMAL
- en: This provides an excellent example to step into a kernel test. Earlier, we mentioned
    that kernel tests create a minimal installation of Drupal with the setup that
    you specify in your test, in order to run and evaluate their test methods. There
    is no danger in running kernel tests, as they do not touch or interfere with your
    current site database in any way. When the test is done, it is *torn down*, or
    removed, from the database with no trace.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new directory in your `tests/src` directory called `Kernel`. This is
    where your kernel tests for the `chapter13` module will live. This time around,
    we are going to write the test first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under `chapter13/tests/src/Kernel`, create the `CamelCaseFormatterTest.php`
    file. Next, we are going to fill it in with the following code. There is a fair
    amount of boilerplate in the setup, but we will review what’s going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Don’t be discouraged by the amount of code in this test. A majority of the
    code is setting up the conditions we need to run the test itself:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the required modules needed to provide the field and `Node` entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the module configuration and entity schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `page` content type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating `field_chapter13_test` and assigning it to the page Node type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the Node default view mode and setting `field_chapter13_test` to use
    the `camel_case` field formatter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An alternative way to do this would be to create all of these items in Drupal
    (the content type, the field, set the formatter) and export that configuration
    into a module that is used only for this test. The result is more or less equivalent
    in the end, but you may find that creating the conditions entirely out of code
    is more maintainable in the long run than a few dozen YAML files.
  prefs: []
  type: TYPE_NORMAL
- en: Names in tests
  prefs: []
  type: TYPE_NORMAL
- en: When naming content types, entities, or fields in a kernel test, you can make
    them whatever you want. They don’t have to match your system exactly, especially
    if all you need is a random content type that can hold a field. What we are testing
    is the output returned, not the names.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the test now, it will fail; now, we can make the implementation so
    that the tests will pass.
  prefs: []
  type: TYPE_NORMAL
- en: To solve the ask, we need to create a `FieldFormatter` plugin that uses our
    existing `CamelCase` class. This exercise is easy, since the bulk of the work
    already exists for changing inputs to camel case format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `Plugin/Field/FieldFormatter` directory under the `src` directory of
    the `chapter13` module. Within that directory, add a file called `CamelCaseFormatter.php`.
    Our implementation will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: By extending the `StringFormatter` class from core Drupal, we can make modifications
    that leverage our `CamelCase` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run our kernel test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: It failed! What happened? Remember when we mentioned before that requirements
    can change? Our test case passes `A user entered string` as test data. Our `CamelCase`
    class does not currently handle strings with spaces, dashes, or commas. Since
    this is a field in Drupal, users can enter just about anything. We need to account
    for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `CamelCase` class to account for this new requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The addition of replacing the comma, space, and dash character should now satisfy
    new use cases. Let’s run the kernel test again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'However, let’s not forget about our unit test that broke earlier – let’s add
    our two new example strings to the `exampleStrings` data provider method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you run PHPUnit, both the unit and the kernel test should pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We now have another new and tested feature added to the site that we can deploy
    with confidence. Of course, we are free to reuse this functionality for our Drupal
    application when we need to.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When running a kernel test, Drupal will install an additional copy of itself
    to run tests in. The kernel test will use the install profile and modules you
    require in the test. This way, you can ensure that you are testing your code in
    the cleanest possible setup, with no interference from unnecessary contributed
    modules or other code. When the tests finish running, Drupal will automatically
    clean up and remove this second installation, including any data that was created
    within the test itself.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have written code and tests that prove they do what we need – but
    they can’t test that a user on the site sees the right thing. Let’s dive in and
    add a functional test to do just that!
  prefs: []
  type: TYPE_NORMAL
- en: Writing a functional test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know our code is working, let’s prove that a user can see the formatted
    string when they visit a node. Functional tests use an emulated browser that allows
    us to simulate users navigating the site. Functional tests install Drupal and
    test in an isolated fashion, so there is no risk of corrupting your current Drupal
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With a functional test, we can navigate the browser as if we were a real user,
    navigating and performing all kinds of assertions that unit and kernel tests cannot
    do. Like before, we do need to set some configurations in place in order to test.
    Within your `tests/src` directory, create a new directory called `Functional`,
    and then create a file inside of it called `CamelCaseFormatterDisplayTest.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this new test file, we are going to borrow some of the setups from the previous
    kernel test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: There are some differences here for the functional test.
  prefs: []
  type: TYPE_NORMAL
- en: In a functional test, you can specify two properties, `$profile` and `$defaultTheme`.
    `$profile` specifies which installation profile to use for this test, and `$defaultTheme`
    specifies which theme to activate for this test. By default, the *testing* profile
    is used, the absolute minimum needed to install Drupal. You can also specify *minimal*
    or *standard*, which installs either one of those profiles to use in testing.
  prefs: []
  type: TYPE_NORMAL
- en: Install profiles and testing
  prefs: []
  type: TYPE_NORMAL
- en: If you use install profiles that come with configurations or extras that create
    content types and roles, for example, be sure to not try to create them again
    in your test, with methods such as `createContentType`. In those cases, we will
    receive an error, since the install profile will have already created them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can also create your own install profile for testing that contains
    Drupal configuration files that you need – this is useful if you don’t want to
    write code in the state in the `setUp` method of the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need for this test to run are the defaults, so run PHPUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'It passes, but do note that the total time to perform functional tests is far
    higher than unit or kernel tests. This is due to having to install a full version
    of Drupal to run the functional tests in. On this machine, it took 7 seconds with
    the core *testing* profile. If we switch to the core *standard* profile, which
    installs a lot more, we can see the time increase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The time elapsed is double over the smaller install profile. This is not necessarily
    a problem, but do keep that in mind when writing tests. In the end, valuable tests
    and concrete feedback are worth a little extra time to make sure we get things
    right with custom code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional tests are more robust than kernel tests. Like a kernel test, Drupal
    will install another copy of itself to run tests in, but the installation is more
    *full* or complete than a kernel test. These tests are run with a browser emulator
    called Mink, and that is how it is able to navigate URLs, check for HTML elements,
    and perform actions as if a real user were navigating the site.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many things you can do with functional tests (see the end of this
    chapter for ideas on how to expand what we covered previously). However, Mink
    is not an actual browser and has no capability to run or react to JavaScript interactions.
    For example, if we had to hide the field text on the page after 5 seconds, or
    display the field value with AJAX, we would need to use a functional JavaScript
    test to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a functional JavaScript test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assume that you now have one last request. You have been asked to use AJAX to
    display the value from the Camel Case formatter 3 seconds after a user has visited
    a page.
  prefs: []
  type: TYPE_NORMAL
- en: Testing this requires using an actual browser such as Google Chrome. Checking
    anything that involves AJAX, cookies, user interactions, or the DOM cannot be
    done with a regular functional test.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, writing a functional JavaScript test is not all that different;
    we just extend from a different base class for the test – `WebDriverTestBase`
    instead of `BrowserTestBase`.
  prefs: []
  type: TYPE_NORMAL
- en: Chrome and Selenium required
  prefs: []
  type: TYPE_NORMAL
- en: If you use DDEV, Lando, Docksal, or other ready made tools to run Drupal locally,
    check their documentation on how to best integrate Chrome and Selenium for functional
    JavaScript tests. They all have variations in approach to installing them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In your `tests/src` directory, create a new directory named `FunctionalJavascript`.
    Within that new directory, create a file named `CamelCaseFormatterDisplayAjaxTest.php`.
    You can copy the previous functional test code into this file, with these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Update `namespace` from `Functional` to `FunctionalJavascript`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend `WebDriverTestBase` instead of `BrowserTestBase`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class name should be changed to `CamelCaseFormatterDisplayAjaxTest`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we now have a requirement to add JavaScript around the display of this
    text on the page, you can remove the old functional test, since it will fail.
    Text won’t be present on the page at first and the old test can’t listen or wait
    for AJAX, so we no longer need that test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can update the test method to account for the new requirement. Assume
    that JavaScript has been written already and that the field value is fetched and
    output by AJAX. The implementation details are not important here, but we can
    change our test method to *wait* until AJAX has completed before checking for
    text on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And after running our new test with PHPUnit, this is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional JavaScript tests are functional tests, with the added functionality
    of being run in a real browser such as Google Chrome. This is what makes it possible
    to assert even more tests for HTML elements, interactivity, AJAX, cookies, and
    other features that require using a real browser to perform actions.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a NightwatchJS test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to a functional JavaScript test, NightwatchJS uses Google Chrome to
    evaluate tests. However, instead of PHP files, the test files are written entirely
    in JavaScript and require NodeJS and `yarn` to run and interact with.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NightwatchJS is not included as part of PHPUnit, so you will need to install
    it using `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `/core` folder, run `yarn install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure `.env.example` to `.env` and editing as necessary. These settings
    will mostly be the same as your local environment settings. `DRUPAL_TEST_BASE_URL`
    will be the value of your local site URL, for example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NightwatchJS looks for tests in the following directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mymodule/tests/src/Nightwatch/Tests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mymodule/tests/src/Nightwatch/Commands`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mymodule/tests/src/Nightwatch/Assertions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mymodule/tests/src/Nightwatch/Pages`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, `mymodule` is your custom module name, like `chapter13`, which we have
    been using for all the code in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run NightwatchJS tests using `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can run a single test – for example, a test in your custom
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Let’s convert the `CamelCase` PHP class to a JavaScript function and test it
    with `nightwatch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory called `js` at `chapter13/js`. Inside, create a file called
    `camelCase.js`. The file will contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We can unit-test this JavaScript function just like we did with the PHP class
    at the start of the chapter. To do that, create a new directory under `chapter13/tests/src/Nightwatch`,
    and within that directory, create another directory called `Tests`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file in the `Tests` directory called `CamelCaseTest.js`. It will look
    like this, getting the same result that we got from the previous functional JavaScript
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now execute the test with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Nightwatch will execute the JavaScript function, loop over the `dataProvider`
    values, and assert that the function returns what we expect it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This is useful for testing JavaScript functions you have written for your custom
    modules or themes. Testing JavaScript functions or behaviors can be a time-intensive
    task to do manually. NightwatchJS is handy for automating that task.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NightwatchJS is also capable of doing browser-based test assertions such as
    the functional JavaScript tests we discussed earlier in the chapter. There are
    caveats though, as the scope of JavaScript is more limited than a language such
    as PHP – depending on what you are trying to test, the test setup may take way
    longer than it would in PHP. You can certainly script your way there by using
    JavaScript in the test to log in as an admin and navigate Drupal to create fields,
    nodes, and elements, but this would take a *lot* of JavaScript to do, and it is
    more suitable to make your own install profile in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, there are various tests in Drupal core that use NightwatchJS,
    so be sure to refer to them for pointers, examples, and ideas.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You are not strictly limited to writing tests using PHPUnit or NightwatchJS
    for Drupal. There are many third-party test harnesses you can use to write and
    run tests for different use cases in Drupal. Be sure to check out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Behat Drupal Extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drupal Test Traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cypress.io](https://Cypress.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
