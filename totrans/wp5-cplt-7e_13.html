<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Developing Plugins, Widgets, and an Introduction to REST API</h1>
                </header>
            
            <article>
                
<p>Plugins are a way to add to or extend WordPress' built-in functionalities. In <a href="1f05677b-dcae-4511-9add-b4cf68718507.xhtml" target="_blank">Chapter 5</a><em>, Plugins – What They Are and Why You Need Them,</em> you learned how to install them. There are thousands of useful plugins (at the time of writing, the official counter at <a href="https://wordpress.org/plugins/">https://wordpress.org/plugins/</a> shows over 55,000 plugins) available from the online WordPress community, and they all perform different kinds of functions. In the earlier chapters, we installed plugins that catch spam, back up your website, and give you basic SEO features. You can also get plugins that manage your podcasts, track your stats, translate your content into other languages, and much more.</p>
<p>Sometimes, however, you'll find yourself in a situation where the plugin you need just doesn't exist. Luckily, it's quite easy to write a plugin for WordPress that you can use on your own website and share with the larger community if you want to. All you need is some basic <strong>Hypertext Preprocessor</strong> (<strong>PHP</strong>) knowledge, and you can write any plugin you want.</p>
<p>This chapter is divided into four major parts, as follows:</p>
<ul>
<li>In the first part, we'll create two plugins using an easy-to-follow, step-by-step process.</li>
<li>In the second part, we'll create a widget using the built-in WordPress widget class.</li>
<li>In the third part, you will learn what shortcodes are and how to use them.</li>
<li>In the fourth part, we'll discuss the topic of the REST API.</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Plugins</h1>
                </header>
            
            <article>
                
<p>In this section, we'll create a plugin via a simple step-by-step process. We'll first see what the essential requirements are, then try out and test the plugin, and then briefly discuss the PHP code involved. That said, you should already have a basic background in PHP before going into this chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building plugins from scratch</h1>
                </header>
            
            <article>
                
<p>First of all, we're here to learn about WordPress, so in this particular case, we will indeed build things from scratch. This is always the best approach to get an in-depth look into how a particular technology works.</p>
<p>However, later on, once you're working with WordPress on a regular basis, and managing your own or other people's websites, I advise you to always look for an already existing plugin before deciding to write a new one yourself. As I mentioned earlier, there are around 55,000 plugins in the official directory alone, not to mention all the premium plugins available all over the web. In short, if you need some functionality, most likely, there's a plugin for it, so you can just go out and get it.</p>
<p>Why is this the recommended approach? If I'm correct, you've chosen to use WordPress because you wanted to make your website as functional as possible, with the least amount of effort possible. Following this line of thought, using an existing plugin simply requires much less effort than building one. Also, many existing plugins are already used by thousands of other people and have large communities supporting them. Choosing a high-quality plugin is, therefore, a safer path to take.</p>
<p>I feel that I should emphasize this clearly because experience tells me that many young WordPress developers tend to press their peers to create things from scratch just for the heck of it, despite the fact that there are other, better solutions available.</p>
<p>Moreover, remember that everything that's a derivative work based on WordPress is available under the <strong>GNU General Public License<span> </span></strong>(<strong>GPL</strong>). So, there's nothing stopping you from taking an existing plugin, building upon it, making it better, and then re-sharing your version with the world. That way, we all win and there's no redundant work.</p>
<p>However, before we can do that, we indeed must learn the craft by constructing something of our own from start to finish. Onward, then!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Plugin code requirements</h1>
                </header>
            
            <article>
                
<p>Just as there were requirements for a theme, there are requirements for a plugin. At the very least, your plugin must satisfy the following:</p>
<ul>
<li>It must be placed in the <kbd>wp-content/plugins</kbd> directory (inside the root directory of WordPress)</li>
<li>It must have a PHP file with a unique name (that is, a name not used by any other plugin in the main <kbd>wp-content/plugins</kbd> directory)</li>
<li>It must have a specially structured comment at the top of the file<br/>
(see <a href="https://codex.wordpress.org/File_Header">https://codex.wordpress.org/File_Header</a> for more information)</li>
</ul>
<p>Then, of course, you must have some functions or processing code; but WordPress will recognize any file that meets these requirements as a plugin.</p>
<p>If your plugin is a simple one, then you can just place a unique PHP file straight in your <kbd>wp-content/plugins</kbd> directory, so it can sit next to the default <span class="packt_screen">Hello Dolly</span> plugin that WordPress comes with. However, a much better practice is to create a subdirectory (again, with a unique name) and place your PHP file there. It makes the <kbd>wp-content/plugins</kbd> directory seem much more organized. Plus, you never know when your plugin is going to need some additional files (it's always easier to simply add new files to a previously existing <kbd>plugin</kbd> directory, than to restructure the plugin from scratch).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A basic plugin – adding link icons</h1>
                </header>
            
            <article>
                
<p>As a demonstration, we will create a simple plugin that adds icons to document links within WordPress. For example, if you create a new post and add a link to an MP3 file in it, it'll look something like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/fad653c5-7c77-4970-8f30-0000c54ed13f.png" style="width:40.75em;height:14.42em;" width="1038" height="368"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Once this plugin is complete, the link will look like the following screenshot instead:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/91e7d9e1-59f8-4301-b6b2-dccde7f9d85c.png" style="width:42.00em;height:14.92em;" width="1049" height="373"/></p>
<p>To accomplish this, we have to do the following:</p>
<ol>
<li>Provide images of the icons that will be used</li>
<li>Have a PHP function that identifies the links to documents and adds a special CSS class to them</li>
<li>Have a style sheet that creates the CSS classes for displaying the icons</li>
<li>Tell WordPress that whenever it prints the content of a post (that is, using the <kbd>the_content()</kbd> function), it has to run the PHP function first</li>
<li>Tell WordPress to include the new styles in the <kbd>&lt;head&gt;</kbd> tag</li>
</ol>
<p>Keep this list in mind as we move forward. Once all of these five requirements are met, the plugin will be done. So, let's get started!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Naming and organizing the plugin files</h1>
                </header>
            
            <article>
                
<p>Every plugin should have a unique name, so that it does not come into conflict with any other plugin in the WordPress universe. When choosing a name for your plugin and the PHP file, be sure to choose something unique. You may even want to do a Google search for the name you choose in order to be sure that someone else isn't already using it.</p>
<p>Apart from the main plugin file itself, your plugin can contain any number of other files and subdirectories. If the situation calls for it, you can even use media files, such as audio and video, to go along with your plugin. Of course, additional CSS or JS files (or even full libraries) are allowed as well.</p>
<p class="mce-root"/>
<p>In this case, as my plugin will be composed of multiple files (a PHP file, a style sheet, and some image files), I'm going to create a directory to house my plugin. I'll name the plugin <span class="packt_screen">Add Document Type Styles New,</span> and place it in a directory called <kbd>add_doctype_styles_new</kbd>. The PHP file, <kbd>doctype_styles_new.php</kbd>, will live in this directory. I've also collected a number of document type icons (provided by <a href="https://www.freepik.com/">https://www.freepik.com/</a> via <a href="https://www.flaticon.com/">https://www.flaticon.com/</a>).</p>
<p>The directory I created for my plugin now looks like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/facb5b34-df88-47ff-af14-058815d1f693.png" width="585" height="50"/></p>
<div class="packt_infobox">It is best practice to also create directories, such as <kbd>images</kbd>, <kbd>css</kbd>, and <kbd>js</kbd> inside your plugin's directory if what you're building will consist of more files.</div>
<p>Now that I've got the images in my directory, I've taken care of the <em>first</em> requirement in the list of requirements my plugin has to meet.</p>
<div class="packt_infobox">If your plugin has any unusual installation or configuration options, you may also want to include a <kbd>readme.txt</kbd> file in its directory that explains this. This <kbd>README</kbd> file will be useful, both as a reminder to you, and as an instructional document to others who may use your plugin in the future. If you plan to submit your plugin to the WordPress plugin directory, you will be required to create a <kbd>README</kbd> file. To get the template for such a file, visit <a href="https://wordpress.org/plugins/developers/">https://wordpress.org/plugins/developers/</a>.</div>
<p>As mentioned earlier, your plugin has to start with a special comment that tells WordPress how to describe the plugin to users on the plugins page. Now that I've got my directory and a blank PHP file created, I'll insert the special comment. It has to be structured like the following (this really is fundamental and is explained in more detail at <a href="https://codex.wordpress.org/File_Header">https://codex.wordpress.org/File_Header</a>):</p>
<pre>&lt;?php 
/* 
Plugin Name: Add Document Type Styles New 
Plugin URI: http://nio.tips/
Description: Detects URLs in your posts and pages and displays nice document type icons next to them. Includes support for PDF, DOC, MP3, and ZIP. 
Version: 1.1 
Author: Karol K 
Author URI: http://karol.cc/ 
Text Domain: add_doctype_styles_new 
License: GNU General Public License v2 or later 
*/</pre>
<div class="packt_infobox">Another good piece of information to have in your plugin is about licensing. Most plugins use GPL. This license essentially means that anyone can use, copy, and enhance your code, and that they are not allowed to prevent anyone else from redistributing it. I've also added a note about the GPL to my plugin's PHP file. Remember that all PHP code you encounter in any WordPress plugin is GPL by default. However, graphic files, CSS, JavaScript, and other elements might have a different license, so be careful when copying other people's work and making it part of your own. You can read more about the license at <a href="https://www.gnu.org/copyleft/gpl.html">https://www.gnu.org/copyleft/gpl.html</a>.</div>
<p>That's all about the introductory code. Now, we can add the <em>meat!</em></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing the plugin's core functions</h1>
                </header>
            
            <article>
                
<p>The core of any plugin is the unique PHP code that you bring to the table. This is the part of the plugin that makes it what it is. Since this plugin is so simple, it only has a few lines of code in the middle.</p>
<p>The <em>second</em> requirement the plugin has to meet is to have a PHP function that identifies links to documents and adds a special class to them. The following function does just that. Note that in keeping with my efforts to ensure that my code is unique, I've prefixed both of my functions with <kbd>doctype_styles_new</kbd>:</p>
<pre>function doctype_styles_new_regex($text) { 
  $text = preg_replace('/href=([\'|"][[:alnum:]|
     [:punct:]]*)\.(pdf|doc|mp3|zip)([\'|"])/', 'href=\\1.\\2\\3 
     class="link \\2"', $text); 
  return $text; 
}</pre>
<p>When the function is given some <kbd>$text</kbd>, it will perform a search for any HTML anchor tag linking to a PDF, DOC, MP3, or ZIP file, and replace it with a class to that anchor. Then, the function returns the altered <kbd>$text</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <em>third</em> requirement the plugin has to meet is to have a style sheet that creates classes for displaying the icons. The following function fetches our style sheet:</p>
<pre>function doctype_styles_new_styles() { 
  wp_register_style('doctypes_styles', plugins_url
     ('doctype_styles_new.css', __FILE__)); 
  wp_enqueue_style('doctypes_styles'); 
}</pre>
<p>As you can see, this function uses the same enqueue mechanism that we used in <a href="eb8f8110-a317-4b1f-afd4-b2bf72714b39.xhtml" target="_blank">Chapter 9</a><em>, Developing Your Own Theme,</em> when registering the style sheets for our custom theme. Here's the CSS file that the preceding function fetches (inside <kbd>doctype_styles_new.css</kbd>):</p>
<pre>.link { 
  background-repeat: no-repeat; 
  background-position: left center;  
  padding: 0 0 0 18px; 
} 
.pdf { background-image: url(icon-pdf.png); } 
.doc { background-image: url(icon-doc.png); } 
.mp3 { background-image: url(icon-mp3.png); } 
.zip { background-image: url(icon-zip.png); }</pre>
<p>Indeed, a very simple file, containing just a handful of styles and icons to distinguish our document links!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding hooks to the plugin</h1>
                </header>
            
            <article>
                
<p>We get our code to actually run when it is supposed to by making use of WordPress <strong>hooks</strong>. The way in which plugin hooks work is as follows: at various times while WordPress is running, they check to see whether any plugins have registered functions to run at that time. If there are, the functions are executed. These functions modify the default behavior of WordPress.</p>
<p>There are two kinds of hooks, as follows:</p>
<ul>
<li><strong>Actions</strong>: Actions are the hooks that the WordPress core launches at specific points during execution, or when specific events occur. Your plugin can specify that one or more of its PHP functions are executed at these points, using the <kbd>Action</kbd> API.</li>
<li><strong>Filters</strong>: Filters are the hooks that WordPress launches to modify the text of various types before adding it to the database or sending it to the browser screen. Your plugin can specify that one or more of its PHP functions is executed to modify specific types of text at these times, using the <kbd>Filter</kbd> API.</li>
</ul>
<p class="mce-root"/>
<p>This means that you can tell WordPress to run your plugin's functions at the same time, when it runs any of its built-in functions. In our case, we want our plugin's first function, <kbd>doctype_styles_new_regex()</kbd>, to run as a filter along with WordPress' <kbd>the_content()</kbd> function (this is the <em>fourth</em> requirement a plugin has to meet).</p>
<p>Now, add the following code to the bottom of the plugin:</p>
<pre>add_filter('the_content', 'doctype_styles_new_regex');</pre>
<p>This uses the <kbd>add_filter</kbd> hook that tells WordPress to register a function named <kbd>doctype_styles_new_regex()</kbd> when it is running the function called <kbd>the_content()</kbd>. By the way, if you have more than one function that you want to add as a filter to the content, you can add a third argument to the <kbd>add_filter()</kbd> function. This third argument will be a number representing the load priority (the default value is 10, the highest priority is 1, and there are no particular limits for the lowest priority<span>—</span>you can even assign values such as 100 or 999), and WordPress will run your functions in ascending order.</p>
<p>All that's left in our list of requirements that a plugin has to meet is the <em>fifth</em> requirement<span>—</span>that is, to tell WordPress to include the new styles in the <kbd>&lt;head&gt;</kbd> tag. This is actually done the same way that it's done for themes, which is through the following hook using <kbd>add_action()</kbd> with the <kbd>wp_enqueue_scripts</kbd> handle:</p>
<pre>add_action('wp_enqueue_scripts', 'doctype_styles_new_styles');</pre>
<p>Here is the complete plugin PHP file:</p>
<pre>&lt;?php 
/* 
Plugin Name: Add Document Type Styles New 
Plugin URI: http://nio.tips/
Description: Detects URLs in your posts and pages 
and displays nice document type icons next to them. 
Includes support for PDF, DOC, MP3 and ZIP. 
Version: 1.1 
Author: Karol K 
Author URI: http://karol.cc/ 
Text Domain: add_doctype_styles_new 
License: GNU General Public License v2 or later
*/ 
 
// this function does the magic 
function doctype_styles_new_regex($text) { 
  $text = preg_replace('/href=([\'|"][[:alnum:]|
     [:punct:]]*)\.(pdf|doc|mp3|zip)([\'|"])/', 
     'href=\\1.\\2\\3 class="link \\2"', $text); 
  return $text; 
} 
 
// this functions adds the stylesheet to the head 
function doctype_styles_new_styles() { 
    wp_register_style('doctypes_styles',      
    plugins_url('doctype_styles_new.css', __FILE__)); 
    wp_enqueue_style('doctypes_styles'); 
} 
 
// HOOKS ============= 
 
add_filter('the_content', 'doctype_styles_new_regex', 9); 
add_action('wp_enqueue_scripts', 'doctype_styles_new_styles');</pre>
<div class="packt_infobox">Make sure that there are no blank spaces before <kbd>&lt;?php</kbd>. If there are any spaces, the PHP code will break, complaining that headers have already been sent. This is quite a common mistake that developers stumble into during their initial attempts with WordPress plugins. It's also a generally good idea to not use the PHP closing tags (<kbd>?&gt;</kbd>) at the end of your PHP files. It saves you from some of the most unfortunate execution errors.</div>
<p>Make sure you save and close this PHP file. You can now do one of two things, as follows:</p>
<ul>
<li>Using your FTP client, upload <kbd>add_doctype_styles_new/</kbd> to your<br/>
<kbd>wp-content/plugins/</kbd> directory</li>
<li>Zip up your directory into <kbd>add_doctype_styles_new.zip</kbd>, and use the plugin uploader in <kbd>wp-admin</kbd> to add this plugin to your WordPress installation</li>
</ul>
<div class="packt_infobox">This version of the plugin is available in the code bundle for this chapter, inside a subdirectory called <kbd>phase 1</kbd>. Our plugin files will go through a couple of phases before we have the final version.</div>
<p>Once the plugin is installed, it will show up on the plugins page, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/cc94a249-6e72-4b00-8719-f0e5b32c61c3.png" style="width:43.92em;height:6.75em;" width="1720" height="264"/></p>
<p>Now, you can activate it and test it out.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Trying out the plugin</h1>
                </header>
            
            <article>
                
<p>If you go to view the same post that we created at the beginning of this chapter, you'll see the plugin in action. Here's the same screenshot again:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/dd37702b-594e-4fad-acb9-662044337a2d.png" style="width:39.92em;height:14.17em;" width="1049" height="373"/></p>
<p>You can also try adding a new post with links to PDF, ZIP, or DOC files. Then, when you view the post, you'll see that even more icons have been added to it by our plugin.</p>
<p>Now that you've learned about a basic plugin that uses hooks to piggyback on the existing WordPress functionality, let's enhance this plugin by giving the user some controls.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding an admin page</h1>
                </header>
            
            <article>
                
<p>Some plugins add a page to <kbd>wp-admin</kbd> where you or the user can edit plugin options. We've seen this with W3 Total Cache, Yoast SEO, and more. Now, let's modify our plugin to give the user some control over which document types are supported. The following screenshot shows what the new management page will look like when we are done:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ef4fb56c-f296-4bae-9943-8cd93dbd944e.png" width="1397" height="371"/></p>
<p class="mce-root"/>
<p>First, deactivate the plugin we just wrote. We'll make changes to it and then reactivate it. The following list details the steps we'll carry out to modify the plugin in order to make this new page possible:</p>
<ol>
<li>Add functions that create an admin page and save the user's input in a new option</li>
<li>Modify the <kbd>doctype_styles_new_regex()</kbd> function so that it retrieves the user's input</li>
<li>Add hooks for the admin page functions</li>
</ol>
<p>Let's get started!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding management page functions</h1>
                </header>
            
            <article>
                
<p>The management page that we will create is going to add an option to <kbd>wp-admin</kbd>. This uses the existing space in the WordPress <kbd>options</kbd> table in the database, so no database modifications are required. The name of this new option must be unique. I'm going to call the new option <kbd>doctype_styles_new_supportedtypes</kbd>.</p>
<p>There are six functions we need to add to the plugin, so that an admin page can be added to <kbd>wp-admin</kbd>. Let's take a look at the functions, one by one:</p>
<ol>
<li>The <em>first</em> function adds the new <kbd>doctype_styles_new_supportedtypes</kbd> option when the plugin is activated, and sets the default value as follows:</li>
</ol>
<pre>      function set_supportedtypes_options() { 
          add_option("doctype_styles_new_supportedtypes",
             "pdf,doc,mp3,zip"); 
      }</pre>
<ol start="2">
<li>The <em>second</em> function removes the new option when the plugin is deactivated, as follows:</li>
</ol>
<pre>      function unset_supportedtypes_options () { 
        delete_option("doctype_styles_new_supportedtypes"); 
      }</pre>
<ol start="3">
<li>Let's look at the new <em>third</em> function, as follows:</li>
</ol>
<pre>      function modify_menu_for_supportedtypes() { 
        add_submenu_page( 
        'options-general.php',    //The new options page will be added as 
                                  //a submenu to the Settings menu.  
        'Document Type Styles',   //Page &lt;title&gt; 
        'Document Type Styles',   //Menu title 
        'manage_options',         //Capability 
        'add_doctype_styles_new', //Slug 
        'supportedtypes_options'  //Function to call 
        );   
      }</pre>
<p style="padding-left: 60px">This function adds a new item to the <span class="packt_screen">Settings</span> menu in <kbd>wp-admin</kbd> using the <kbd>add_submenu_page()</kbd> function call. This takes six arguments, namely: where the options page should be placed, page title, menu link text, the user at the maximum level who can access the link, what file to open (none, in this case), and the function to call, <kbd>supportedtypes_options()</kbd>.</p>
<ol start="4">
<li>The <kbd>supportedtypes_options()</kbd> function is, in fact, the <em>fourth</em> new function we are adding:</li>
</ol>
<pre>      function supportedtypes_options() { 
        echo '&lt;div class="wrap"&gt;&lt;h2&gt;Supported Document 
           Types&lt;/h2&gt;'; 
        if (isset($_POST['submit'])) { 
          update_supportedtypes_options(); 
        } 
        print_supportedtypes_form(); 
        echo '&lt;/div&gt;'; 
      }</pre>
<p style="padding-left: 60px">This function actually displays our new page. It prints a title and checks to see whether someone has clicked on the <kbd>submit</kbd> button; if the <kbd>submit</kbd> button has been clicked on, the <kbd>supportedtypes_options()</kbd> function updates the options and then prints the form.</p>
<ol start="5">
<li>The new <em>fifth</em> function we have to add is responsible for updating options if the <kbd>submit</kbd> button has been clicked on, as follows:</li>
</ol>
<pre>      function update_supportedtypes_options() { 
        $updated = false; 
        if ($_POST['doctype_styles_new_supportedtypes']) {  
          $safe_val = addslashes(strip_tags($_POST
             ['doctype_styles_new_supportedtypes']));     
             update_option('doctype_styles_new_supportedtypes', 
             $safe_val);  
          $updated = true; 
        } 
       
        if ($updated) { 
          echo '&lt;div id="message" class="updated fade"&gt;'; 
          echo '&lt;p&gt;Supported types successfully updated!&lt;/p&gt;'; 
          echo '&lt;/div&gt;'; 
        } else { 
          echo '&lt;div id="message" class="error fade"&gt;'; 
          echo '&lt;p&gt;Unable to update supported types!&lt;/p&gt;'; 
          echo '&lt;/div&gt;'; 
        } 
      }</pre>
<ol start="6">
<li>The last function we need to add, which is the new <em>sixth</em> function, prints the form that the users will see. Make sure there are no spaces before or after the closing tag (<kbd>EOF;</kbd>), as follows:</li>
</ol>
<pre>      function print_supportedtypes_form() { 
        $val_doctype_styles_new_supportedtypes = 
           stripslashes(get_option('
           doctype_styles_new_supportedtypes')); 
        echo &lt;&lt;&lt;EOF 
      &lt;p&gt;Document types supported by the Add Document Type Styles New plugin are listed       as follows.&lt;br /&gt;To add a new type to be linked, take the following steps, in this order: 
      &lt;ol&gt; 
        &lt;li&gt;Upload the icon file for the new doctype to &lt;i&gt;wp-
           content/plugins/add_doctype_styles_new/&lt;/i&gt;&lt;/li&gt;  
        &lt;li&gt;Add a line for the new doctype to the stylesheet at 
           &lt;i&gt;wp-content/plugins/add_doctype_styles_new/
           doctype_styles_new.css&lt;/i&gt;&lt;/li&gt;  
        &lt;li&gt;Add the extension of the new doctype to the following list, keeping with the comma-separated format.&lt;/li&gt; 
      &lt;/ol&gt; 
      &lt;/p&gt; 
      &lt;form method="post"&gt; 
        &lt;input type="text" name=
           "doctype_styles_new_supportedtypes" size="50" 
           value="$val_doctype_styles_new_supportedtypes" /&gt;  
           &lt;input type="submit" name="submit" value="Save Changes" 
           /&gt; 
      &lt;/form&gt; 
      EOF; 
      }</pre>
<p>These six functions together take care of adding a link in the menu, adding the management page for this link, and updating the new option.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modifying the doctype_styles_new_regex() function</h1>
                </header>
            
            <article>
                
<p>Now that the users are able to edit the list of supported document types by appending the document types they want, we should have a way of telling the <kbd>doctype_styles_new_regex()</kbd> function to use the user's list instead of the built-in list. To do so, we need to use <kbd>get_option('doctype_styles_new_supportedtypes')</kbd> in our <kbd>doctype_styles_new_regex()</kbd> function. The <kbd>get_option()</kbd> function will retrieve the value that the user has saved in the new option we just created. Modify your <kbd>doctype_styles_new_regex()</kbd> function so that it looks like the following:</p>
<pre>function ahs_doctypes_regex($text) { 
  $types = get_option('doctype_styles_new_supportedtypes'); 
  $types = preg_replace('/,\s*/', '|', $types); 
 
  $text = preg_replace('/href=([\'|"][[:alnum:]|
     [:punct:]]*)\.('.$types.')([\'|"])/i', 'href=\\1.\\2\\3 
     class="link \\2"', $text); 
 
  return $text; 
}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding hooks</h1>
                </header>
            
            <article>
                
<p>We have added our management page functions, but now we have to tell WordPress to use them. To do so, we just need to add the following three new hooks:</p>
<pre>add_action('admin_menu', 'modify_menu_for_supportedtypes'); 
register_activation_hook(__FILE__, "set_supportedtypes_options"); 
register_deactivation_hook(__FILE__, 
   "unset_supportedtypes_options");</pre>
<p>The first hook tells WordPress to add our link to the menu when it creates the menu with <kbd>admin_menu()</kbd>. The next two hooks tell WordPress to call the activation and deactivation functions when the plugin is activated or deactivated.</p>
<div class="packt_infobox">This version of the plugin is available in the code bundle for this chapter, inside a subdirectory called <kbd>final</kbd>. It is the final version of our plugin.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Trying out the plugin</h1>
                </header>
            
            <article>
                
<p>We have added all of the new functions. Now it's time to save the file and see what happens. You can go ahead and reactivate the plugin. Now, when you look at the <span class="packt_screen">Settings</span> menu, you will see that a new link has been added, as demonstrated in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/69249065-f872-4ec0-b8e6-3453a9231dcd.png" style="width:12.17em;height:16.75em;" width="328" height="451"/></p>
<p>Click on the new link to see the management page, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/223ee559-51fa-42a8-b09b-af44ad3ee3c6.png" width="1397" height="371"/></p>
<p>If you follow the three steps shown in the preceding screenshot on the management page (upload the file icon, add a new style to the style sheet, and add the extension to the option), then the new document type will be supported.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>There are already a number of ways in which this plugin could be improved. Some of them are as follows:</p>
<ul>
<li>Instead of forcing the user to upload their new icons using FTP, the plugin could allow the user to upload icons directly via the <span class="packt_screen">Settings</span> page.</li>
<li>The plugin could display the icons for the supported document types on the <span class="packt_screen">Settings</span> page so that the users see what they look like.</li>
<li>The plugin could check to make sure that for every document type in the option field there is an existing icon, otherwise, it will display an error.</li>
</ul>
<p>Perhaps you'd like to try to make these changes yourself!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing your plugins</h1>
                </header>
            
            <article>
                
<p>We've tried out our new plugin, so it's probably a good moment to say a word or two about testing your plugins and making sure that they don't cause any problems for regular users in general.</p>
<p>Our particular plugin is a very simple one; the only thing it does is process each link it finds inside any post or page's content, and adds a custom icon next to it. However, even such a simple plugin can be a possible security breach point. For example, the only place where the user can input anything is the plugins section in <kbd>wp-admin</kbd> (the field handling the supported file types). Now, there is a possibility that someone might use this field to input a piece of specific PHP code instead of a standard file type; for instance, code that is meant to perform a specific action on the server side, and which could result in a serious security breach. That is why our <kbd>update_supportedtypes_options()</kbd> function has the following two lines:</p>
<pre>$safe_val = addslashes(strip_tags($_POST
   ['doctype_styles_new_supportedtypes'])); 
update_option('doctype_styles_new_supportedtypes', $safe_val);</pre>
<p>Thanks to them, everything that the user inputs will have all of the PHP and HTML tags stripped by <kbd>strip_tags()</kbd>, and then every character that needs to be quoted in database queries will be handled by <kbd>addslashes()</kbd>. Using such functions is a just-in-case practice, but it tends to be something that eventually pays off.</p>
<p>Apart from testing our work against some of the common hacking practices, such as code injection or SQL injection, we also need to handle all kinds of unconventional uses we can think of. For instance, would anything bad happen if someone put a value that's not a standard file type? Or, what if the CSS file goes missing all of a sudden? These are just some of the questions a good testing session should answer.</p>
<p class="mce-root"/>
<p>Another good way of testing plugins is to hand them over to a few trusted users and ask for feedback. Someone who's entirely new to your plugin will usually do a way better job of testing it than you, the author.</p>
<p>Of course, this short section here only scratches the surface of plugin testing and code testing in general, so I encourage you to give it a closer look on your own. There are many great resources on the web and in your nearest bookstore.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A plugin with database access – capturing searched words</h1>
                </header>
            
            <article>
                
<p>We're going to leave the document types plugin behind now, and create a new one<span>, </span>featuring active use of a database. Let's create a simple plugin that stores all the words that visitors search for (when using the blog's search feature).</p>
<p>Overall, this plugin is very basic, and doesn't require its own directory like the previous plugin that we worked on. That's why this whole plugin will be done inside one file: <kbd>capture_searches_new.php</kbd>. I'm calling the plugin <kbd>Capture Searched Words New</kbd>.</p>
<p>The database table structure for this plugin will be as follows. The table name is <kbd>wp_searchedwords</kbd>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Null</strong></td>
<td><strong>Key</strong></td>
<td><strong>Default</strong></td>
<td><strong>Extra</strong></td>
</tr>
<tr>
<td><kbd>Id</kbd></td>
<td><kbd>INT</kbd></td>
<td>NOT NULL</td>
<td>PRI</td>
<td>-</td>
<td><kbd>auto_increment</kbd></td>
</tr>
<tr>
<td><kbd>Word</kbd></td>
<td><kbd>VARCHAR(255)</kbd></td>
<td>-</td>
<td>-</td>
<td>NULL</td>
<td>-</td>
</tr>
<tr>
<td><kbd>created</kbd></td>
<td><kbd>DATETIME</kbd></td>
<td>NOT NULL</td>
<td>-</td>
<td>Today 00:00:01</td>
<td>-</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Now, let's write the plugin code.</p>
<div class="packt_infobox">Even though I say that the table is named <kbd>wp_searchedwords</kbd>, it won't always be the case. It's all based on the table prefix that's set for your website (the default one is indeed <kbd>wp_</kbd>). Here, I'm going to refer to the table as <kbd>wp_searchedwords</kbd> anyway, for convenience.</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting the plugin to talk to the database</h1>
                </header>
            
            <article>
                
<p>The first part of this plugin should only be run when the plugin is activated. This will be the initialization function. One of its tasks is to create or update the database table (the table will only be created if it hasn't been created before):</p>
<pre>function searchedwords_init($content) { 
  global $wpdb; 
  $sw_table_name = $wpdb-&gt;prefix.'searchedwords'; 
 
  //creating the table (if it doesn't exist) or updating it if 
  // necessary 
  if(isset($_GET['activate']) &amp;&amp; 'true' == $_GET['activate']) { 
    $sql = 'CREATE TABLE `'.$sw_table_name.'` ( 
      id INT NOT NULL AUTO_INCREMENT,  
      word VARCHAR(255),  
      created DATETIME NOT NULL DEFAULT \''.date('Y-m-d').' 
         00:00:01\',  
      PRIMARY KEY  (id) 
    )'; 
 
    require_once(ABSPATH.'wp-admin/includes/upgrade.php'); 
    dbDelta($sql); 
  } 
 
  // in case a search has just been performed, store the searched 
  // word 
  if (!empty($_GET['s'])) { 
    $current_searched_words = explode(" ",urldecode($_GET['s'])); 
    foreach ($current_searched_words as $word) { 
      $wpdb-&gt;query($wpdb-&gt;prepare("INSERT into `$sw_table_name` 
         VALUES(null,'%s','".date('Y-m-d H:i:s')."')", $word)); 
    } 
  } 
}</pre>
<p>This function connects to the database using various function calls, such as <kbd>dbDelta()</kbd>, <kbd>$wpdb-&gt;query()</kbd>, and <kbd>$wpdb-&gt;prepare()</kbd>. The <kbd>dbDelta()</kbd> function takes care of creating the table or updating it (it does whatever is needed at the time; you can find out more at <a href="https://codex.wordpress.org/Creating_Tables_with_Plugins">https://codex.wordpress.org/Creating_Tables_with_Plugins</a>). Apart from this, when dealing with the WordPress database, you can utilize any database-related PHP function in existence. Or, you can use WordPress' class member function: <kbd>$wpdb-&gt;get_results()</kbd>. The function we're using here also stores the searched word in the database table if a search has just been performed. This is done through the <kbd>$wpdb-&gt;query()</kbd> and <kbd>$wpdb-&gt;prepare()</kbd> functions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding management page functions</h1>
                </header>
            
            <article>
                
<p>We now need a familiar-looking function that adds a management page to <kbd>wp-admin</kbd>. In this case, we use <kbd>add_management_page()</kbd> instead of <kbd>add_submenu_page()</kbd>, because this plugin is more of a tool than something that requires settings:</p>
<pre>function modify_menu_for_searchedwords() { 
  $page = add_management_page( 
    "Capture Searched Words",  
    "Capture Searched Words",  
    'manage_options',  
    'capture_searches_new',  
    'searchedwords_page' 
  ); 
}</pre>
<p>For this plugin, we're not going to load any custom styling or CSS files. The purpose here is to just showcase how database connection can be done, so we're going to keep everything else ultra-simple and minimal. Therefore, the only thing we have to do at this point is to write a function that retrieves the information from the database and displays it on the new management page (again, everything is done through the <kbd>$wpdb</kbd> object<span>—</span>it's a class defined by WordPress that contains a set of functions that you can use to interact with the database):</p>
<pre>function searchedwords_page() { 
  global $wpdb; 
  $sw_table_name = $wpdb-&gt;prefix.'searchedwords'; 
 
$searched_words = $wpdb-&gt;get_results("SELECT COUNT(word) AS 
   occurrence, word FROM `$sw_table_name` GROUP BY word ORDER BY 
   occurrence DESC"); 
  ?&gt; 
&lt;div class="wrap" style="max-width: 600px;"&gt; 
&lt;h2&gt;Searched Words&lt;/h2&gt; 
&lt;table class="wp-list-table widefat"&gt; 
&lt;thead&gt; 
  &lt;tr&gt; 
    &lt;th scope="col"&gt;Search Words&lt;/th&gt; 
    &lt;th scope="col"&gt;# of Searches&lt;/th&gt; 
  &lt;/tr&gt; 
&lt;/thead&gt; 
&lt;tbody&gt; 
  &lt;?php 
  if($searched_words !== NULL) { 
    foreach($searched_words as $searched_word) { 
      echo '&lt;tr valign="top"&gt;&lt;td&gt;'.$searched_word-
         &gt;word.'&lt;/td&gt;&lt;td&gt;'.$searched_word-&gt;occurrence.'&lt;/td&gt;&lt;/tr&gt;'; 
    } 
    $searched_perfomed = true; 
  } 
  else { 
    echo '&lt;tr valign="top"&gt;&lt;td colspan="2"&gt;&lt;strong&gt;No searches 
       have been performed yet&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;'; 
  } 
  ?&gt; 
&lt;/tbody&gt; 
&lt;/table&gt; 
&lt;/div&gt; 
  &lt;?php 
}</pre>
<p>That's it. The previous plugin had more functions because data was being captured from the user and then saved. Here, that's not necessary.</p>
<p>Lastly, we just need to add two hooks, as follows:</p>
<pre>add_filter('init', 'searchedwords_init'); 
add_action('admin_menu', 'modify_menu_for_searchedwords');</pre>
<p>The first hook tells WordPress to run the initialization function when the plugin is activated, or when a search is performed. The second hook modifies the <kbd>admin_menu</kbd> to add a link to the new management page.</p>
<div class="packt_infobox">This version of the plugin is available in the code bundle for this chapter<span>, </span>inside a subdirectory called <kbd>final</kbd>. It is the first and final version of the plugin.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Trying out the plugin</h1>
                </header>
            
            <article>
                
<p>As with the last plugin, you can now either upload your plugin using FTP to <kbd>wp-content/plugins</kbd>, or turn it into a ZIP file and add it using the uploader to <kbd>wp-admin</kbd>.</p>
<p>Once you've installed it, activate it. Then, look at the menu under <span class="packt_screen">Tools</span> and you'll see a link to the new management page, as demonstrated in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/077b2777-d056-4de2-b5de-317b13d32a64.png" style="width:13.58em;height:13.25em;" width="329" height="321"/></p>
<p>When you click on <span class="packt_screen">Capture Searched Words</span>, you'll see a new page that the plugin has created, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/51b38be7-1b93-4377-8edc-c76fa8e99408.png" style="width:35.33em;height:11.17em;" width="746" height="236"/></p>
<p>As you can see, I did perform some searches beforehand just to have something to show on this new page. You can do the same by placing a search field widget in your sidebar (as shown in the following screenshot), and then experimenting with different search words and phrases. The plugin will pick them all up and display the most searched ones in its section in <kbd>wp-admin</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/78b4a7c6-e0cb-427d-bc8e-4a19bf67a823.png" style="width:17.00em;height:14.17em;" width="497" height="414"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building a plugin for the block-based editor</h1>
                </header>
            
            <article>
                
<p>As you know by now, there's a new content editor in WordPress that's been introduced in the 5.0 version of the platform. Essentially, it does away with the previous single editing window and instead, allows the user to work with individual content blocks, placing them one after another. When put together, all those blocks construct the final blog post. That's all fine and dandy for the user, but what does it mean for the plugin developer? A handful of things!</p>
<p>Firstly, building a plugin for a block-based editor is very different from building standard plugins like we've been doing in this chapter. While you can build those classic plugins with just a basic knowledge of PHP and HTML, building for the block-based editor is a bit more complex. It involves setting up and mastering additional web technologies. You need things such as <strong>npm</strong>, <strong>Node.js</strong>, and <strong>webpack</strong>, not to mention that you also need to be comfortable working with JavaScript in general. Teaching all of this is a large-enough topic for its own book. So, instead of doing that, I'm going to point you to some external sources where you can begin your adventure with the block-based editor. However, before I do that, let's summarize briefly what the general idea of building for the editor is and what is possible.</p>
<p>The new editor accepts two main types of elements, as follows:</p>
<ul>
<li>Blocks</li>
<li>Sidebar sections</li>
</ul>
<p>In other words, as a plugin developer, you can either create new blocks to be included in the editor, or new sidebar entries to customize the fine details about your plugin's functionality, or both.</p>
<p>I'm sure you know what a block is at this point, so let me show you an example of a good sidebar use in the new editor. It comes from the <span class="packt_screen">Yoast SEO</span> plugin (<a href="https://wordpress.org/plugins/wordpress-seo/">https://wordpress.org/plugins/wordpress-seo/</a>; we discussed this in <a href="1f05677b-dcae-4511-9add-b4cf68718507.xhtml" target="_blank">Chapter 5</a>, <em>Plugins - What They Are and Why You Need Them</em>). If the user has the plugin enabled on their site, and they proceed to work on a new blog post, they'll see this new sidebar section in the top-right corner of the editor, as demonstrated in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/cba766ff-fb2a-4f64-877e-acb598e89bc4.png" style="width:22.50em;height:25.17em;" width="682" height="762"/></p>
<p>It allows the user to tune up the SEO parameters of their post. The thing worth noticing is how well the plugin's block integrates with the rest of the editor's user interface. This seamless integration is the whole goal of building plugins with the block-based editor in mind.</p>
<p>The same thing goes if you want to build a plugin that enables new blocks. They also need to use the same interface conventions as the default blocks that come with WordPress built in. Here's an example of a plugin that does exactly that. It's called <span class="packt_screen">Otter</span> blocks (<a href="https://wordpress.org/plugins/otter-blocks/">https://wordpress.org/plugins/otter-blocks/</a>).</p>
<p>When you install and activate it, you'll get a whole set of new blocks, and the best part is that they blend in with the default blocks perfectly. For example, one of the blocks included is the <strong><span class="packt_screen">Sharing Icons</span></strong> block. The following screenshot shows what it looks like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/3cc96bbb-a45e-47f2-9791-7d9286174b9d.png" style="width:61.58em;height:28.50em;" width="2138" height="990"/></p>
<p>As you can see, it has the same controls and similar options to all of the other blocks. Of course, this plugin is a fairly complex creation, built by a team of developers, and you surely don't have to make your first block plugin similarly impressive.</p>
<p>That said, you might be notice one thing in particular as it relates to the block-based editor; that is, what if your plugin doesn't require creating any new blocks or sidebar elements? In such a case, you don't need to trouble yourself with the editor at all. The two plugins we've created in this chapter so far don't use the editor in any way, so making your plugin compatible with the editor certainly isn't a must.</p>
<p>To begin your adventure with the block-based editor, read this two-part guide on how to adapt your plugin for the block editor: part 1 can be found at <a href="https://www.codeinwp.com/blog/adapt-your-plugin-for-gutenberg-block-api/">https://www.codeinwp.com/blog/adapt-your-plugin-for-gutenberg-block-api/</a> and part 2 is available at <a href="https://www.codeinwp.com/blog/make-plugin-compatible-with-gutenberg-sidebar-api/">https://www.codeinwp.com/blog/make-plugin-compatible-with-gutenberg-sidebar-api/</a>.</p>
<p>Additionally, you can experiment with the free Gutenberg Boilerplate plugin (<a href="https://github.com/HardeepAsrani/gutenberg-boilerplate">https://github.com/HardeepAsrani/gutenberg-boilerplate</a>), which delivers the minimal block editor development setup and examples inside a single package. There's one example block, and one example sidebar included. You can build upon these elements when creating your own block-ready plugin.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Learning more</h1>
                </header>
            
            <article>
                
<p>There are hundreds of hooks available in WordPress<span>—</span>way too many to cover in this book. You can learn more about them by going online. Start out at these online reference sites:</p>
<ul>
<li>The <em>Plugin API</em> article contains very thorough information about writing plugins and using hooks, at: <a href="https://codex.wordpress.org/Plugin_API">https://codex.wordpress.org/Plugin_API</a>.</li>
<li>For a complete list of action hooks, visit <a href="https://codex.wordpress.org/Plugin_API/Action_Reference">https://codex.wordpress.org/Plugin_API/Action_Reference</a>.</li>
<li>For a complete list of filter hooks, visit <a href="https://codex.wordpress.org/Plugin_API/Filter_Reference">https://codex.wordpress.org/Plugin_API/Filter_Reference</a>.</li>
<li>You may also want to take a step back and look at the general <em>Plugin Resources</em> page in the WordPress Codex at <a href="https://codex.wordpress.org/Plugin_Resources">https://codex.wordpress.org/Plugin_Resources</a>.</li>
<li>Another page that you might find very helpful is the new <em>Code Reference</em> for developers: <a href="https://developer.wordpress.org/reference/">https://developer.wordpress.org/reference/</a>.</li>
<li>A key resource to bookmark if you want to build plugins for the new block-based editor is the <em>Gutenberg Handbook</em>, available at <a href="https://wordpress.org/gutenberg/handbook/">https://wordpress.org/gutenberg/handbook/</a>.</li>
<li>If you want to submit your plugin to the WordPress plugin repository, you'll need to take steps similar to those that you took when preparing a theme, and you'll also need to get hooked up to the WordPress SVN repository. Learn more about how to submit a plugin to the WordPress plugin repository at <a href="https://developer.wordpress.org/plugins/wordpress-org/">https://developer.wordpress.org/plugins/wordpress-org/</a>.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Widgets</h1>
                </header>
            
            <article>
                
<p>Writing a widget bears some similarities to writing a plugin. In some ways, it's even easier because there is a widget class that you can leverage for some of the functionalities. In other ways, it's also a bit more time-consuming as there's a lot of mandatory code that every widget has to feature.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Custom tag cloud widget</h1>
                </header>
            
            <article>
                
<p>In this section, we'll see how to write a widget that displays a custom tag cloud that we can then place in the sidebar. There will also be the possibility to change the title of the widget, and although this is a tag cloud widget, we'll be able to switch tags to categories and display them using a tag-cloud-like style as well. In its final form, the widget will look like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/3366b609-14b4-4e08-a259-1e061861bc6a.png" style="width:16.08em;height:18.25em;" width="492" height="557"/></p>
<p>Just as a comparison, here's what the standard tag cloud widget (the native one in WordPress) looks like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/e000c58b-eae6-4900-96c3-e9be9680a925.png" style="width:20.17em;height:8.17em;" width="472" height="191"/></p>
<p>Let's get started!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Naming our widget</h1>
                </header>
            
            <article>
                
<p>In this case, we're going to create the widget as a standalone plugin. So, just like any other plugin, it needs a unique name and a unique appearance in the <kbd>wp-content/plugins</kbd> directory.</p>
<p class="mce-root"/>
<div class="packt_infobox">I encourage you to search the web whenever you're creating a new widget or plugin, just to make sure that there's nothing out there going by the same name. On top of that, use a namespace as a prefix with every filename (and function name) that you're creating. For example, mine is <kbd>kk_</kbd>.</div>
<p>I'll name the new plugin file (which holds the widget) <kbd>kk_tag_cloud_widget.php</kbd>, and put it in its own <kbd>kk_tag_cloud_widget</kbd> directory inside <kbd>wp-content/plugins</kbd>.</p>
<p>This main PHP file starts just like any other plugin, with the following declaration:</p>
<pre>&lt;?php 
/* 
Plugin Name: Karol K's Tag Cloud Widget 
Description: Displays a nice tag cloud. 
Plugin URI: http://nio.tips/ 
Version: 1.1 
Author: Karol K 
Author URI: http://karol.cc/ 
License: GNU General Public License v2 or later 
*/</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The widget structure</h1>
                </header>
            
            <article>
                
<p>When you are building a widget using the widget class, your widget needs to have the following structure:</p>
<pre>class UNIQUE_WIDGET_NAME extends WP_Widget { 
 
  public function __construct() { 
    $widget_ops = array(); 
    $control_ops = array(); 
    parent::__construct('base id', 'name', $widget_ops, 
       $control_ops); 
  } 
 
  public function widget($args, $instance) { 
    // used when the sidebar calls the widget 
  } 
 
  public function form($instance) { 
    // prints the form on the widgets page 
  } 
 
  public function update($new_instance, $old_instance) { 
    // used when the user saves his/her widget options 
  } 
} 
 
// initiate the widget 
 
// register the widget</pre>
<p>My unique widget name for this project is <kbd>KK_Widget_Tag_Cloud</kbd>. Now, let's go over each of the preceding functions one by one and understand what's going on.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The widget initiation function</h1>
                </header>
            
            <article>
                
<p>Let's start with the widget initiation function. Before we add anything to it, it looks like the following:</p>
<pre>public function __construct() { 
  $widget_ops = array(); 
  $control_ops = array(); 
  parent::__construct('base-id', 'name', $widget_ops, 
     $control_ops); 
}</pre>
<p>In this function, which is the constructor of the class, we initialize various things that the <kbd>WP_Widget</kbd> class is expecting. The first two variables, to which you can give any name you want, are just a handy way to set the two array variables expected by the third line of code.</p>
<p>Let's take a look at these three lines of code, as follows:</p>
<ul>
<li>The <kbd>$widget_ops</kbd> variable is where you can set the class name, which is given to the <kbd>div</kbd> widget itself, and the description, which is shown in <kbd>wp-admin</kbd> on the widgets page.</li>
<li>The <kbd>$control_ops</kbd> variable is where you can set options for the control box in <kbd>wp-admin</kbd> on the widgets page, such as the width and height of the widget, and the ID prefix used for the names and IDs of the items inside. For my basic widget, I'm not going to use this variable (as it's optional).</li>
<li>When you call the parent class's constructor, <kbd>WP_Widget()</kbd>, you'll tell it the widget's unique ID, the widget's display title, and pass along the two arrays you created.</li>
</ul>
<p class="mce-root"/>
<p>For this widget, my code now looks like the following:</p>
<pre>public function __construct() { 
  parent::__construct( 
    'kk-tag-cloud', 
    'KK Tag Cloud', 
    array( 
      'description' =&gt; 'Your most used tags in cloud format; same 
         height; custom background' 
    ) 
  ); 
}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The widget form function</h1>
                </header>
            
            <article>
                
<p>The widget form function has to be named <kbd>form()</kbd>. You may not rename it if you want the widget class to know what its purpose is. You also need to have an argument in there, which I'm calling <kbd>$instance</kbd>, which the class also expects. This is where the current widget settings are stored. This function needs to have all of the functionalities to create the form that users will see when adding the widget to a sidebar. Let's look at some abbreviated code and then explore what it's doing, as follows:</p>
<pre>public function form($instance) { 
  $instance = wp_parse_args((array) $instance, 
  array('template' =&gt; '')); 
  $current_taxonomy = $this-&gt;_get_current_taxonomy($instance); 
  ?&gt; 
  &lt;p&gt; 
    &lt;label for="&lt;?php echo $this-&gt;get_field_id('title'); 
       ?&gt;"&gt;Title&lt;/label&gt;    
    &lt;input type="text" class="widefat" id="&lt;?php echo $this-
       &gt;get_field_id('title'); ?&gt;" name="&lt;?php echo $this-
       &gt;get_field_name('title'); ?&gt;" value="&lt;?php if  
       (isset($instance['title'])) 
       {echo esc_attr($instance['title']);} 
   ?&gt;" /&gt; 
  &lt;/p&gt; 
  &lt;p&gt; 
    &lt;label for="&lt;?php echo $this-&gt;get_field_id('taxonomy'); 
       ?&gt;"&gt;Taxonomy&lt;/label&gt;   
    &lt;select class="widefat" id="&lt;?php echo $this-
       &gt;get_field_id('taxonomy'); ?&gt;" name="&lt;?php echo $this-
       &gt;get_field_name('taxonomy'); ?&gt;"&gt; 
    &lt;?php foreach(get_object_taxonomies('post') as $taxonomy) : 
      $tax = get_taxonomy($taxonomy); 
      if(!$tax-&gt;show_tagcloud || empty($tax-&gt;labels-&gt;name)) 
        continue; 
      ?&gt; 
      &lt;option value="&lt;?php echo esc_attr($taxonomy) ?&gt;"
      &lt;?php selected($taxonomy, $current_taxonomy); ?&gt;&gt;
      &lt;?php echo $tax-&gt;labels-&gt;name; ?&gt;&lt;/option&gt; 
    &lt;?php endforeach; ?&gt; 
    &lt;/select&gt; 
  &lt;/p&gt; 
  &lt;?php 
}</pre>
<p>First, you use a WordPress function named <kbd>wp_parse_args()</kbd>, which creates an <kbd>$instance</kbd> array that your form will use. What's in it depends on what defaults you've set and what settings the user has already saved. Then, you create form fields. Note that for each form field, I make use of the built-in functions that will create unique names and IDs and input the existing values, as follows:</p>
<ul>
<li><kbd>$this-&gt;get-field_id()</kbd> creates a unique ID based on the widget instance (remember, you can create more than one instance of this widget).</li>
<li><kbd>$this-&gt;get_field_name()</kbd> creates a unique name based on the widget instance.</li>
<li>The <kbd>$instance</kbd> array is where you will find the current values for the widget, whether they are defaults or user-saved data.</li>
</ul>
<p>All the other code in there is just regular PHP and HTML. Note that if you give the user the ability to set a title, name that field <kbd>title</kbd>, and WordPress will show it on the widget form when it's minimized. The widget form this will create will look like the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/cc70ea47-8e76-40b5-b93f-84b45576ba91.png" style="width:32.00em;height:17.08em;" width="687" height="366"/></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The widget save function</h1>
                </header>
            
            <article>
                
<p>When a user clicks on the <span class="packt_screen">Save</span> button on the widget form, WordPress uses AJAX to run your save function. You need to be sure to save whatever the user types in, which is all we're doing in this case, but you can put other functionalities here if it's appropriate for your widget (for example, database interactions, conversions, calculations, and so on). The final code for this function is as follows:</p>
<pre>public function update($new_instance, $old_instance) { 
  $instance['title'] = $new_instance['title']; 
  $instance['taxonomy'] = stripslashes($new_instance['taxonomy']); 
  return $instance; 
}</pre>
<p>Be sure this function is named <kbd>update()</kbd> and is prepared to accept two instances, one with the old data and one with the just-submitted data. You can write your code to check <kbd>$new_instance</kbd> for problems, and thus, return <kbd>$old_instance</kbd> if the new one isn't valid. The <kbd>$instance</kbd> data you return will be what's shown in the update widget form.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The widget print function</h1>
                </header>
            
            <article>
                
<p>The third main function in your widget class is the one that is called by the sidebar when it's time to actually show the widget to people visiting the website. It needs to retrieve any relevant saved user data and print out information for the website visitor. In this case, our final print function looks like the following:</p>
<pre>public function widget($args, $instance) { 
  extract($args); 
  $current_taxonomy = $this-&gt;_get_current_taxonomy($instance); 
  if(!empty($instance['title'])) { 
    $title = $instance['title']; 
  } 
  else { 
    if('post_tag' == $current_taxonomy) { 
      $title = 'Tags'; 
    } 
    else { 
      $tax = get_taxonomy($current_taxonomy); 
      $title = $tax-&gt;labels-&gt;name; 
    } 
  } 
  $title = apply_filters('widget_title', $title, $instance, $this-
     &gt;id_base); 
  $before_widget = '&lt;div class="widget-container kk_widget_tag_cloud"&gt;'; 
  $after_widget = '&lt;/div&gt;'; 
  $before_title = '&lt;h1 class="widget-title"&gt;'; 
  $after_title = '&lt;/h1&gt;'; 
 
  echo $before_widget; 
  if ( $title )  echo $before_title . $title . $after_title;  
  echo '&lt;div class="kk_tagcloud"&gt;'; 
  wp_tag_cloud(apply_filters('widget_tag_cloud_args', 
     array('taxonomy' =&gt; $current_taxonomy))); 
  echo "&lt;/div&gt;\n"; 
  echo $after_widget; 
}</pre>
<p>The preceding function calls one more helper function responsible for fetching the current taxonomy. It is a very simple one, though, as follows:</p>
<pre>function _get_current_taxonomy($instance) { 
  if ( !empty($instance['taxonomy']) &amp;&amp; 
     taxonomy_exists($instance['taxonomy']) ) 
    return $instance['taxonomy']; 
  return 'post_tag'; 
}</pre>
<p>The first thing I do in the main function is to extract the data in the instance, which contains the information the website administrator had saved when filling out the widget form. Then, the widget takes a look into the selected taxonomy (tags or categories) and displays all of the individual items as a simple one-line list.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Custom widget styles</h1>
                </header>
            
            <article>
                
<p>Our small widget has its own style sheet that needs to be included in the current theme's <kbd>head</kbd> section, like any other style sheet.</p>
<p>The file is named <kbd>kk_tag_cloud_widget.css</kbd> and contains the following:</p>
<pre>.kk_widget_tag_cloud .kk_tagcloud { 
    line-height: 1.5em; 
} 
 
.kk_widget_tag_cloud .kk_tagcloud a { 
    display: inline-block; 
    margin: 3px 2px; 
    padding: 0 11px; 
    border-radius: 3px; 
    -webkit-border-radius: 3px; 
    background: #eee; 
    color: #279090; 
    font-size: 12px !important; 
    line-height: 30px; 
    text-transform: uppercase; 
} 
 
.kk_widget_tag_cloud .kk_tagcloud a:hover { 
    color: #f2f2f2; 
    background: #404040; 
}</pre>
<p>Nothing fancy, just a set of classes that will make sure that the widget looks great. The only thing we have to do with this style sheet is enqueue it through a standard WordPress hook. Place the following code in your plugin's main file:</p>
<pre>function kk_tag_cloud_widget_styles_load() { 
  wp_register_style('kk_tag_cloud_widget_styles', 
     plugins_url('kk_tag_cloud_widget.css', __FILE__)); 
  wp_enqueue_style('kk_tag_cloud_widget_styles'); 
} 
add_action('wp_enqueue_scripts', 
   'kk_tag_cloud_widget_styles_load');</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Initiating and hooking up the widget</h1>
                </header>
            
            <article>
                
<p>That's it for widget functionality! Now, you just need to add a little piece of code that will hook the widget up to the rest of WordPress, as follows:</p>
<pre>function KK_Widget_Tag_Cloud_Reg() { 
  register_widget('KK_Widget_Tag_Cloud'); 
} 
add_action('widgets_init', 'KK_Widget_Tag_Cloud_Reg');</pre>
<p>This tells WordPress that when it initiates widgets, it should be sure to register our new widget.</p>
<div class="packt_infobox">This version of the widget is available in the code bundle for this chapter, inside a subdirectory called <kbd>phase 1</kbd>. We'll still be adding one more feature before we can call it the final version.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Trying out the widget</h1>
                </header>
            
            <article>
                
<p>Your widget is ready to go! Let's try this widget we have created now:</p>
<ol>
<li>Save all your changes, and upload your widget to the <kbd>wp-content/plugins</kbd> directory.</li>
<li>Go to the <span class="packt_screen">Plugins</span> section and you'll see your widget waiting to be activated, as usual.</li>
<li>After you click on the <span class="packt_screen">Activate</span> button, you can navigate to <span class="packt_screen">Appearance</span> | <span class="packt_screen">Widgets</span>. You'll see the widget waiting to be added to a sidebar, as demonstrated in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7e8acbb5-f51c-4da8-92b3-65b9d4c5c802.png" style="width:29.83em;height:7.67em;" width="629" height="161"/></p>
<ol start="4">
<li>Drag the widget to a sidebar, and then click on the little downward arrow to edit it. You'll see the options slide down, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b1c90895-c431-43fa-a432-0b3a95e31911.png" width="1519" height="735"/></p>
<ol start="5">
<li>You can enter a <span class="packt_screen">Title</span> or leave it blank for the default, and choose the <span class="packt_screen">Taxonomy</span> that you want to display.</li>
</ol>
<ol start="6">
<li>Then, click on <span class="packt_screen">Save</span> as you would with any widget.</li>
<li>When you return to the frontend of the site and reload, the new tag cloud will be right there, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a1b31e41-abea-4bc0-8aaf-0133e5ff42f6.png" style="width:17.58em;height:19.92em;" width="492" height="557"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Learning more</h1>
                </header>
            
            <article>
                
<p>You can browse the following online reference sites to learn more about widgets:</p>
<ul>
<li>The WordPress <em>Widgets API</em> is located at <a href="https://codex.wordpress.org/Widgets_API">https://codex.wordpress.org/Widgets_API</a><span>.</span></li>
<li>WordPress lists a number of widgets at <a href="https://codex.wordpress.org/WordPress_Widgets">https://codex.wordpress.org/WordPress_Widgets</a>.</li>
<li>If you want to find more widgets to install on your website, visit the widgets section of the plugin repository at <a href="https://wordpress.org/plugins/tags/widget">https://wordpress.org/plugins/tags/widget</a>.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Bundling a widget with an existing plugin</h1>
                </header>
            
            <article>
                
<p>If you're writing a plugin and you'd like to make a widget available with it, you don't have to create a separate widget plugin. Just include all of the widget code<span>—</span>similar to what we created in the preceding section<span>—</span>in with your plugin's PHP file. When the user activates the plugin, the widget will automatically show up on the widgets page in <kbd>wp-admin</kbd>. There's no need for a separate file!</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Shortcodes</h1>
                </header>
            
            <article>
                
<p>Shortcodes are a handy way to let a non-technical person, such as an editor of a website, include dynamic content within pages and posts, without having to actually use any PHP, complex HTML structures, or custom JavaScript. In other words, shortcodes are handy reusable pieces of code, yet they don't require any actual coding experience or knowledge on the end user's part.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Shortcodes and the way they work</h1>
                </header>
            
            <article>
                
<p>The way a shortcode works is that you tell WordPress to look at the text within square brackets (<kbd>[]</kbd>) and evaluate it by running a PHP function. That PHP function can live in the <kbd>functions.php</kbd> file of your theme, or in a plugin file, or in a widget file. Let's create a simple shortcode and include it with our most recent widget plugin.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Types of shortcodes</h1>
                </header>
            
            <article>
                
<p>Shortcodes are a pretty simple concept by definition, but we can still distinguish three main types, as follows:</p>
<ul>
<li><strong>Single-tag shortcodes</strong>: These shortcodes are executed with just a single tag, for example, <kbd>[my_first_shortcode/]</kbd>.</li>
<li><strong>Double-tag shortcodes</strong>: These shortcodes are executed with opening and closing tags, for example, <kbd>[my_2nd_shortcode]some text here[/my_2nd_shortcode]</kbd> (notice that the closing tag has an additional <kbd>/</kbd>). As you can see, there's also some content within the tags. This content can be processed by the shortcode function.</li>
<li><strong>Shortcodes with attributes</strong>: These shortcodes can have one or two tags and also a number of attributes we can use to customize the output, for example, <kbd>[my_3rd_shortcode name="Karol" twitter="carlosinho"]some text here[/my_3rd_shortcode]</kbd>.</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a simple shortcode</h1>
                </header>
            
            <article>
                
<p>Let's create a simple shortcode that will make it possible to use our widget's output inside any given post or page. This is going to be a double-tag shortcode with one additional attribute, which we'll use to indicate whether the output should be formatted using our custom CSS or WordPress' native styling:</p>
<ol>
<li>Let's start by creating a new function at the bottom of our <kbd>kk_tag_cloud_widget.php</kbd> file, and then we'll go through each individual line, as follows:</li>
</ol>
<pre>function kk_tag_cloud_handler($atts, $content=null) { 
  extract(shortcode_atts(array( 
    'use_css' =&gt; '1', 
    'taxonomy' =&gt; 'post_tag' 
    ), $atts)); 
 
  $tax = 'post_tag'; 
  if(taxonomy_exists($taxonomy)) $tax = $taxonomy; 
 
  $result = ''; 
 
  if ('0' != $use_css) { 
    $result .= '&lt;div class="kk_widget_tag_cloud"&gt;&lt;div 
       class="kk_tagcloud"&gt;'; 
  } 
  if (null != $content) { 
    $result .= addslashes(strip_tags($content)).' '; 
  } 
  $result .= wp_tag_cloud(apply_filters( 
    'widget_tag_cloud_args',  
    array('taxonomy' =&gt; $tax, 'echo' =&gt; false) 
    )); 
  if ('0' != $use_css) { 
    $result .= '&lt;/div&gt;&lt;/div&gt;'; 
  } 
 
  return $result; 
}</pre>
<p style="padding-left: 60px">First of all, note that this function does not <em>echo</em> or <em>print</em> anything. It just returns a string. If you let your function print, it won't look correct on the website.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p style="padding-left: 60px">Inside our function, the first line handles the custom attributes that the shortcode receives (in this case, just the <kbd>use_css</kbd> parameter for indicating whether the styles should be used or not, and the <kbd>taxonomy</kbd> parameter to indicate the taxonomy that should be shown in the shortcode). WordPress will hand off the <kbd>$atts</kbd> argument automatically, and we only have to use the <kbd>extract()</kbd> function to turn the attributes the user submits into variables available in the function. The values in the array passed to the <kbd>extract()</kbd> functions set the defaults, in case the user chooses no options. In general, there is no limit to the number of options that you can make available to the shortcode users.</p>
<p style="padding-left: 60px">The next line extracts the taxonomy identifier and tries to turn it into a valid taxonomy. In case the user's input is not valid, the default <kbd>post_tag</kbd> taxonomy will be used. The final part of the function handles the display based on the state of the <kbd>use_css</kbd> attribute. It's pretty basic at this point! There's also a possibility to include custom text as the main content of the shortcode. This can be useful in some situations.</p>
<ol start="2">
<li>What we have to do now is tell WordPress that this function is a shortcode, and we do so using a hook. Be sure to choose something unique. I've chosen <kbd>kk_tag_cloud</kbd> as the name for this shortcode, so the hook looks like the following:</li>
</ol>
<pre>add_shortcode('kk_tag_cloud', 'kk_tag_cloud_handler');</pre>
<ol start="3">
<li>To use this shortcode in our content, all we have to do is edit any given post or page and insert a line such as the following:</li>
</ol>
<pre>[kk_tag_cloud taxonomy="category"] Select the category you'd like 
   to read next:[/kk_tag_cloud]</pre>
<ol start="4">
<li>Such usage will have the following effect:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/aeb6fc4a-78cc-407c-afc5-2c7fe994a00b.png" style="width:39.17em;height:6.17em;" width="927" height="146"/></p>
<ol start="5">
<li>We can also use the shortcode such as the following:</li>
</ol>
<pre>[kk_tag_cloud use_css="0" taxonomy="category"]Select the category 
   you'd like to read next:[/kk_tag_cloud]</pre>
<ol start="6">
<li>This will disable the custom styles and produce the following effect:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7224dcee-e5c2-4aa3-9138-24fa5938a658.png" style="width:37.58em;height:6.75em;" width="837" height="151"/></p>
<ol start="7">
<li>To display the tag cloud in its default form (showing the tags and using the custom style sheet), all we have to do is execute the shortcode, as follows:</li>
</ol>
<pre>[kk_tag_cloud][/kk_tag_cloud]</pre>
<p>The effect is shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/bce37ea4-0e90-4a50-9081-ddef2ef3c2d1.png" style="width:15.58em;height:3.58em;" width="374" height="85"/></p>
<p>There are very few limitations regarding what you <em>can</em> and <em>cannot</em> do with shortcodes.</p>
<div class="packt_infobox">This version of the widget is available in the code bundle for this chapter<span>, </span>inside a subdirectory called <kbd>final</kbd>. It is the final version of our widget.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The WordPress REST API</h1>
                </header>
            
            <article>
                
<p>The WordPress REST API is a relatively new addition to the WordPress platform. Before it was added to core, the REST API was available as a standalone mechanism via a separate plugin. You could get everything and also learn how to work with the package from the project's official website at <a href="http://v2.wp-api.org/">http://v2.wp-api.org/</a>.</p>
<p>However, the REST API was included in the WordPress core package in WordPress version 4.7. This means that you no longer need any additional plugins or tools to make it work. Basically, as long as you're on the most recent version of WordPress, you have the REST API installed and enabled by default. Which is great news! But let's get a bit deeper.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What is the REST API?</h1>
                </header>
            
            <article>
                
<p>Under the hood, the REST API<span>—</span>officially called the WordPress REST API<span>—</span>is just another layer of technology that allows you to interact with your WordPress site, as well as the sites of other people. Chiefly, the REST API allows you to separate the presentation layer of a WordPress site from the mechanism of how WordPress operates in the background. In other words, with specific REST API calls, you can perform actions on the contents of a WordPress site without having to enter the <kbd>wp-admin</kbd> of the site, or even visit it via a web browser at all.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Why use WordPress REST API?</h1>
                </header>
            
            <article>
                
<p>The introduction of the REST API opens up a lot of new possibilities as to <em>what you can do</em> with a WordPress site and <em>what you can use it for</em>. For instance, via the REST API, you can interact with WordPress content remotely, add new content, erase content, or perform any other operation. Just to name one major possibility, this makes it easy to create a mobile app for your website, and have the app communicate with the website via the REST API. In other words, if you want to communicate with a WordPress site via any other way than by visiting the site directly, then you can do that with the REST API.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to get started with the REST API</h1>
                </header>
            
            <article>
                
<p>We're only scratching the surface here, and the description provided in this chapter is by no means exhaustive. The REST API is a rather advanced piece of technology that lets you do a multitude of things<span>—</span>sometimes via rather complex code structures. So, the only thing we want to achieve here is to help you get started by giving you a foundation that you can then explore further as you're learning about the REST API elsewhere. A great place to get started if you want to truly master the REST API is the official developer manual at <a href="https://developer.wordpress.org/rest-api/">https://developer.wordpress.org/rest-api/</a>. With that said, what follows are the basics of how to begin with the REST API.</p>
<p>The REST API allows you to interact with any WordPress site via the means of sending <em>requests</em> and receiving <em>responses</em> through the WordPress HTTP API. To make a valid request, you need to reference the following: the <em>base URL path</em> of the REST API, the <em>route</em>, and the <em>endpoint.</em></p>
<p>The base URL path is similar for all WordPress websites: <kbd>http://YOURWEBSITE.com<br/>
/wp-json/wp/v2/</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The route defines the exact part of the website's content that you want to communicate with. For example, you can use <kbd>posts/</kbd> in order to communicate with the site's posts. In that case, the full URL would be <kbd>http://YOURWEBSITE.com/wp-json/wp/v2/posts/</kbd>.</p>
<p>Endpoints are specific functions available through the REST API. For example, if you expand the route to target a specific post by ID, such as <kbd>http://YOURWEBSITE.com<br/>
/wp-json/wp/v2/posts/123</kbd>, then this allows you to call one of three endpoints:</p>
<ul>
<li><kbd>GET</kbd> returns the post data</li>
<li><kbd>PUT</kbd> updates the post data and returns that updated post data</li>
<li><kbd>DELETE</kbd> deletes the post and returns the now-deleted post data</li>
</ul>
<p>Apart from the default endpoints, you can also create your own, depending on what you want to be able to do with your content through the REST API. This, however, is perhaps a topic for a more in-depth REST API manual. For the purpose of this book, let's just do a simple demonstration and create a plugin that will communicate with an external WordPress website via the REST API.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a plugin that uses the REST API</h1>
                </header>
            
            <article>
                
<p>You've already learned how to create basic WordPress plugins in this very chapter, so now, let's combine this knowledge with the new addition of the REST API. The plugin we're building is going to simply display a list of posts from another blog based on a shortcode.</p>
<p>Let's have a look at the full code of this plugin<span>—</span>all contained within a single file named <kbd>kk_rest_demo.php</kbd>, as follows:</p>
<pre>function kk_rest_handler($atts, $content=null) {
  extract(shortcode_atts(array( 
    'website_domain' =&gt; 'newinternetorder.com', 
    'how_many' =&gt; '3' 
  ), $atts)); 
  
  $response = wp_remote_get( 'http://' . $website_domain . '/wp-
  json/wp/v2/posts/' );
 
  if( is_wp_error( $response ) ) { 
    $error_string = $response-&gt;get_error_message(); 
    return 'Error occurred: &lt;em&gt;' . $error_string . '&lt;/em&gt;'; 
  }
  
  $posts = json_decode( wp_remote_retrieve_body( $response ) );
  
  if( empty( $posts ) ) { return 'No posts found'; } 
  else { 
    $result = '&lt;ul&gt;'; 
    $post_count = 0; 
    foreach( $posts as $post ) { 
      $post_count++; 
      if ($post_count &lt;= $how_many) { 
        $result .= '&lt;li&gt;&lt;a href="' . $post-&gt;link. '"&gt;'
        . $post-&gt;title-&gt;rendered . '&lt;/a&gt;&lt;/li&gt;'; 
      } 
    } 
    $result .= '&lt;/ul&gt;'; 
    return $result; 
  }
}
add_shortcode('kk_rest', 'kk_rest_handler');</pre>
<p>The first function call, <kbd>extract()</kbd>, is something we know from the previous shortcode plugin/widget. It extracts the attributes given to the shortcode. In our case, the shortcode works with two optional attributes, as follows:</p>
<ul>
<li><kbd>website_domain</kbd>: This indicates the domain name of the WordPress site that the plugin should communicate with (defaults to <kbd>newinternetorder.com</kbd>).</li>
<li><kbd>how_many</kbd>: This indicates how many posts should be fetched (defaults to <kbd>3</kbd>).</li>
</ul>
<p>The next function call is where the main REST API communication happens. This call references a given route and fetches blog posts using the GET endpoint (by default), as follows:</p>
<pre>$response = wp_remote_get( 'http://' . $website_domain . '/wp-json/wp/v2/posts/' );</pre>
<p>After that, we just need to check there weren't any errors, and if so, halt the function. The next function call decodes the response and allows us to reference individual posts one by one later on, as follows:</p>
<pre>$posts = json_decode( wp_remote_retrieve_body( $response ) );</pre>
<p>The final <kbd>foreach</kbd> loop and <kbd>if</kbd> clause go through each post and retrieve their title and URL, which then get added to a standard HTML-unordered list and returned by the shortcode. At this point, and once I activate this plugin on my test site, I can create a new post and add the following shortcode to it:</p>
<pre>[kk_rest website_domain="newinternetorder.com" how_many="2"]
[/kk_rest]</pre>
<p>This tells the plugin to communicate with <kbd>newinternetorder.com</kbd> and fetch the two most recent posts. The following screenshot shows the result of this as visible on the frontend:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/394d515e-fc5b-4ee4-8d16-3b7cbbd8acda.png" style="width:37.67em;height:16.00em;" width="1043" height="443"/></p>
<p>Of course, the plugin we've built here is very simple, and it does not do anything in terms of making sure that the domain provided is valid, or anything else security-related. However, the purpose of this demo is only to show you the simplest way of working with the REST API, and nothing else. Once again, I strongly encourage you to review some of the official resources, such as the <em>REST API Handbook</em> at <a href="https://developer.wordpress.org/rest-api/">https://developer.wordpress.org/rest-api/</a>.</p>
<div class="packt_infobox">This version of the plugin is available in the code bundle for this chapter<span>, </span>inside a subdirectory called <kbd>final</kbd>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned everything you need to know about creating basic plugins and widgets. Now you know how to structure the plugin's PHP files, where to put your functions, and how to use hooks. You also learned about adding management pages, enabling plugins and widgets to have database access, and how to create shortcodes.</p>
<p>On top of all of this, you learned how to work with the REST API and perform basic communication with other WordPress websites. With your existing knowledge of PHP and HTML, you have the tools to get started writing any plugin and/or widget your heart may desire.</p>
<p>In the next chapter, we'll walk you through the process of creating a complete non-blog website from scratch.</p>


            </article>

            
        </section>
    </div>



  </body></html>