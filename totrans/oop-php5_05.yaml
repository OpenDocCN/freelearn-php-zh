- en: Chapter 5. Reflection and Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP5 brings in many new flavors compared to PHP4\. It replaces many old APIs
    with smarter, new ones. One of them is Reflection API. Using this cool set of
    API, you can reverse engineer any class or object to figure out its properties
    and methods. You can invoke those methods dynamically and do some more. In this
    chapter we will learn in more detail about reflections and use of each of these
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Another very important part of software development is building test suits for
    automated testing of your piece of work. This is to ensure it's working correctly
    and after any changes it maintains backward compatibility. To ease the process
    for PHP developers, there are a lot of testing tools available on the market.
    Among them are some very popular tools like PHPUnit. In this chapter we will learn
    about unit testing with PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reflection API provides some functionality to find out what is inside an object
    or a class at runtime. Besides that, reflection API lets you invoke dynamically
    any method or property of any object. Let''s get our hands dirty with reflection.
    There are numerous objects introduced in reflection API. Among them, the following
    are important:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let us go and play with `ReflectionClass` first.
  prefs: []
  type: TYPE_NORMAL
- en: ReflectionClass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is one of the major core classes in reflection API. This class helps you
    to reverse engineer any object in the broad sense. The structure of this class
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss how this class actually works. First we will find their methods
    and purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '`export()` method dumps the internal structure of any object, which is almost
    similar to `var_dump` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getName()` function returns the internal name of an object, hence the class
    name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isInternal()` returns true if the class is a built-in object inside PHP5\.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isUserDefined()` is the opposite of `isInternal()` method. It just returns
    whether the object is defined by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getFileName()` function returns the PHP script file name where the class is
    written.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getStartLine()` returns at which line the code of that class begins in the
    script file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getDocComment()` is another interesting function which returns the class level
    document for that object. We will demonstrate it in examples later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getConstructor()` returns the reference of the constructor of the object as
    a `ReflectionMethod` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getMethod()` function returns the address of any method passed to it as a
    string. The returned object is a `ReflectionMethod` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getMethods()` returns an array of all the methods in the object. In that array
    every method is returned as `ReflectionMethod` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getProperty()` function returns a reference to any property in that object,
    as a `ReflectionProperty` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getConstants()` returns an array of constants in that object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getConstant()` returns the value of any particular constant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want a reference to the interfaces that a class implemented (if any),
    you can use `getInterfaces()` function which, returns an array of interfaces as
    `ReflectionClass` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getModifiers()` method returns the list of modifiers relevant to that class.
    For example, it could be public, private, protected, abstract, static, or final.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newInstance()` `f`unction returns a new instance of that class and returns
    it as a regular object (which is actually `stdClas;` `stdClass` is the base class
    of every PHP object).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want a reference to the parent class of any class? You can use `getParentClass()`
    method to get that as a `ReflectionClass` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another cool function of `ReflectionClass()` is that it can tell from which
    extension a class has been originated. For example, `ArrayObject` class is originated
    from SPL class. You have to use `getExtensionName()` function for that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's write some code now. We will see these functions in real life code. Here,
    I am showing a fantastic example taken from the PHP Manual.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now save the above code in a file named `class.counter.php`. When you run the
    above code, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**X-Powered-By: PHP/5.1.1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content-type: text/html**'
  prefs: []
  type: TYPE_NORMAL
- en: '**===> The user-defined class ''Counter'' [extends ReflectionClass::__set_state(array(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**''name'' => ''Object'',**'
  prefs: []
  type: TYPE_NORMAL
- en: '**))]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**declared in PHPDocument2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**lines 15 to 29**'
  prefs: []
  type: TYPE_NORMAL
- en: '**having the modifiers 0 []**'
  prefs: []
  type: TYPE_NORMAL
- en: '**---> Documentation:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**''/****'
  prefs: []
  type: TYPE_NORMAL
- en: '*** A counter class**'
  prefs: []
  type: TYPE_NORMAL
- en: '***/''**'
  prefs: []
  type: TYPE_NORMAL
- en: '**---> Implements:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**array (**'
  prefs: []
  type: TYPE_NORMAL
- en: '**0 =>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ReflectionClass::__set_state(array(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**''name'' => ''NSerializable'',**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)),**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**---> Constants: array (**'
  prefs: []
  type: TYPE_NORMAL
- en: '**''START'' => 0,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**---> Properties: array (**'
  prefs: []
  type: TYPE_NORMAL
- en: '**0 =>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ReflectionProperty::__set_state(array(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**''name'' => ''c'',**'
  prefs: []
  type: TYPE_NORMAL
- en: '**''class'' => ''Counter'',**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)),**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**---> Methods: array (**'
  prefs: []
  type: TYPE_NORMAL
- en: '**0 =>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ReflectionMethod::__set_state(array(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**''name'' => ''count'',**'
  prefs: []
  type: TYPE_NORMAL
- en: '**''class'' => ''Counter'',**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)),**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**---> $counter is instance? yes**'
  prefs: []
  type: TYPE_NORMAL
- en: '**---> new Object() is instance? No**'
  prefs: []
  type: TYPE_NORMAL
- en: ReflectionMethod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the class used to investigate any method of the class and then invoke
    it. Let us see the structure of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important methods of this class are `getNumberOfParamaters`, `getNumberOfRequiredParameters`,
    `getParameters`, and `invoke`. The first three of these are self explanatory;
    let''s look at the fourth one which is invoked. This is a nice example taken from
    the PHP Manual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, this code will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: ReflectionParameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another very important object in the reflection family is `ReflectionParameter`.
    Using this class you can analyze parameters of any method and take action accordingly.
    Let us take a look at the object structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To make things easier, have a look at the following example to see how this
    thing works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the above code snippet, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: ReflectionProperty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the last one under the reflection family that we are going to discuss
    here. This class helps you to investigate class properties and reverse engineer
    them. This class has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here is an example taken directly from the PHP Manual, that helps describe how
    it actually works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The code produces the following output upon execution. This code inspects a
    property with the help of `ReflectionProperty` and displays the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We will see some more uses of Reflection API in later chapters, when we will
    learn build an MVC framework.
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another very important part of programming is unit testing, by which you can
    test pieces of code, whether it works perfectly or not. You can write test cases
    against any version of your code to check if your code works after refactoring.
    Unit testing ensures the workability of the code and helps to pin-point the problem
    when it occurs. When you code your application, unit tests works as your skeleton.
    Unit testing is a mandatory part of programming for programmers of every language.
    There are unit testing packages available for almost all major programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: As with every other programming language, there is one package for Java that
    is considered as a standard model for every other unit testing package for other
    languages. This package is called as **JUnit** which is for Java developers. The
    standard and testing style maintained in JUnit is usually followed in many other
    unit testing packages. So JUnit has become a defacto in the unit testing area.
    The port of JUnit for PHP developers is known as **PHPUnit**, which was developed
    by Sebastian Bergmann. PHPUnit is a very popular unit testing package.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main reasons for writing unit tests is that you cannot figure out
    all the bugs if you just write your code and deploy your application. There might
    be small bugs that might crash your application violently by returning a non relevant
    value. Don't overlook these small scenarios. There might be cases when you wouldn't
    imagine one of your codes returning an extremely odd result. Unit testing helps
    you by writing different test cases. Unit testing is not a thing which needs a
    lot of time to write, however the outcome is amazing.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section we will learn the basics of unit testing, and get our
    hands dirty writing successful unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of Unit Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unit testing has a lot of benefits, some of them are that it:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensures the consistency of your application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensures the workability of your complete application after any kind of refactoring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks the redundancy and removes them from your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designs good API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily figures out where the problem is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speeds up the debugging process if anything goes wrong; as you know particularly
    where the bug resides.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimizes the effort of documentation by providing working examples of your
    API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helps to do a regression test so that no regression occurs again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A small Introduction to Vulnerable Bugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bugs can be of different types. Some bugs could just bother your users, some
    bug stops the functionality, and some bug vulnerability corrupts your resources.
    Let us consider the following example. You have written a function which takes
    two parameters and updates the database accordingly. The first parameter is the
    name of the field and the second parameter is the value of that field by which
    it should locate the data and then update them. Now let us design it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when you call it like this, it shows a specific data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'But when you call it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It displays the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is not a correct output; and as it is happening in runtime if it was `update`
    instead of a `select` query, your whole data may get corrupt. So how can you ensure
    that the output is always a valid one? Well, we will do that easily with unit
    testing later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for Unit Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write successful unit test for PHP applications using PHPUnit, you need to
    download the package, configure it, and then do some small tasks before actually
    being able to execute your tests.
  prefs: []
  type: TYPE_NORMAL
- en: You can either run PHPUnit tests from the command line or from inside your script.
    For now we will run our tests from within our script, but in later sections, we
    will learn how to run unit tests from command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, download the package from [http://www.phpunit.de](http://www.phpunit.de)
    and extract it in your include path. If you are not sure what is your include
    path you can get that from `include_path` settings in your `php.ini`. Or you can
    execute the following PHP script to display the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now extract the PHPUnit archive and place the PHPUnit folder in a folder, which
    is in your include path. This PHPUnit folder contains two other folders named
    `PHPUnit` and `PHPUnit2`.
  prefs: []
  type: TYPE_NORMAL
- en: You are done as soon as you place the folders in your include path directories.
    Now we are ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Starting Unit Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A unit test is actually a collection of different tests against your code. It
    is not a big job to write unit tests using PHPUnit. All you have to do is simply
    follow a set of conventions. Let's take a look at the following example, where
    you create a string manipulator class, which returns the number of words available
    in a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now we will write a unit test for this class. We have to extend the `PHPUnit_Framework_TestCase`
    to write any unit test. And we have to use `PHPUnit_Framework_TestSuite` to create
    the test suite, which actually holds a collection of tests. Then we will use `PHPUnit_TextUI_TestRunner`
    to run the tests from the suite and print the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you run the code in `testsuite.wordcount.php` you will get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That means our test has passed and our word-counter function works perfectly,
    however, we will write some more test cases for that function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us add this new test case in our `class.testwordcount.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we run our test suite we will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we found that our foolproof word-count function fails. So what was our
    test input? We just add more spaces in our test parameter `my` `name` `is` `afif`,
    and then our function fails. This is because it splits the sentence with white
    space and returns the number of split parts. As there are more white spaces, so
    our function fails gracefully. That''s a pretty nice test case; we found that
    our function might fail in real life if we release our code with this version
    of word counter. PHPUnit has become useful for us already. Now we will solve our
    function so that it returns the correct result if our sentence contains more white
    spaces. We change our `class.wordcount.php` to this new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now if we run our test suite, it will give the following output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'However we want more proof that our function will work better in the wild.
    So we are writing another test case. Let''s add this new test case in our `class.testwordcount.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And let's run the suit again. What is the result now?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That's pretty satisfying. All our tests are running ok. The function is now
    a good one.
  prefs: []
  type: TYPE_NORMAL
- en: This is how unit test can help us in real life.
  prefs: []
  type: TYPE_NORMAL
- en: Testing an Email Validator Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s repeat the steps again. This time we will write unit tests for
    our brand new `Emailvalidator` class which our developer said is a good one. Let''s
    take a look at our validator function first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And here comes our test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you have to write the test suit and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output when you run this test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try harder; try to break your code. Try all the possible cases that may
    occur in an email and try as many as you can. We are going to add more test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the test suite, you will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So our email validator fails! If you look at the result you will see that it
    fails with `testEmailWithDotInName`. Therefore, we have to change the regular
    expression pattern we used and allow `.` in the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s redesign the validator as show here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you run your test suites again, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Our test passes.
  prefs: []
  type: TYPE_NORMAL
- en: So what is the benefit? Time after time, when you need to add new validation
    rules to your regular expression, this unit test will help to do the regression
    test so that the same fault never occurs again.
  prefs: []
  type: TYPE_NORMAL
- en: That's the beauty of Unit Testing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will find two functions named `setUp()` and `tearDown()` in the above example.
    `setUp()` is used for setting up everything for the test; you can use it to connect
    to DB, to open a file or something similar. `tearDown()` is for cleaning. It is
    called when the script finishes executing.
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing for Everyday Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Alongside these unit tests for functions and small classes, you will need to
    write unit tests for a final result achieved by different functions. However,
    as specific you go with your unit tests, the better outcome you can expect. Do
    also remember that of the many unit tests you write, only few of them are actually
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will discuss how to test routines that works with a database. Let us
    create a small class which inserts, finds and updates the record, which we will
    write unit tests for. Here comes our small class, which directly interacts with
    a table named `users` in our database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We need to test all the public methods in this class to ensure they are working
    properly. So here come our test cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The test suite is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: So what result will you get?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'However, these are basic functionality tests. We must make more versatile tests
    and find out how our objects may fail. Let''s add two more tests as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you run the test suite you will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Our DB code is looking hard to break.
  prefs: []
  type: TYPE_NORMAL
- en: In real life unit testing, you need to think beyond how you can break your own
    code. If you can write unit tests that break your existing code, that's better.
  prefs: []
  type: TYPE_NORMAL
- en: Test Driven Development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now it''s time to go further into unit testing. You may ask when you need to
    write unit tests before coding for applications: during time of development, or
    after finishing coding? Well, developers from different corners have different
    things to say, however it is found to be more useful to write the test first and
    then go for a real application. This is called **Test Driven Development** or
    **TDD** in short. TDD helps you to design better API for your application.'
  prefs: []
  type: TYPE_NORMAL
- en: You may ask how to write tests when you don't have any real code, and which
    things to test? You don't need real objects for TDD. Just imagine some mock objects,
    which have just the functions. You will use those functions with the imaginary
    result. You can also write incomplete tests, which means a test with blank body.
    At your own convenience, you can write you can write the content of the test.
    Let's see the following example to understand how unit testing before real code
    actually fits in project development.
  prefs: []
  type: TYPE_NORMAL
- en: 'PHPUnit provides you a lot of useful API for test-first programming such as
    `markTestSkipped()` and `markTestIncomplete()`. We will use these two methods
    to mark some of our tests, which are not implemented. Let us design a small feedback
    manager which can accept user''s feedback and mail them to you. So what could
    be the useful features of a feedback manager? I would suggest the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It can render a feedback form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will handle user's input and properly filter it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will have a spam prevention functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will prevent any automated feedback submitted by bots or spammers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will render a confirmation after submission of feedback, mailing it to owner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create some blank unit tests for this. Here comes our test case, before
    we have the real code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This is good; we have now created 11 blank tests. Now if you run this test
    case using test suite, you will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'PHPUnit successfully figured out that all our tests are marked as incomplete.
    Now let''s think again. If you generate an `InputValidator` object, which validates
    user input and filters all malicious data from it, then we may have only one test
    case, `testValidInput()` instead of all these `testValidUserName()`, `testValidSubject()`,
    `testValidContent()`. So we can skip those tests. Now let''s create the new test
    routine `testValidInput()` and mark it as incomplete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'What will we do with those three tests that we plan to skip? We will not delete
    them but mark them as skipped. Modify the line `$this->markTestIncomplete()` to
    `$this->markTestSkipped()`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you run your test suite again you will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: PHPUnit is showing that it skipped three tests.
  prefs: []
  type: TYPE_NORMAL
- en: To keep our discussion short and focussed, we will now implement only one test
    from these nine. We will test that the feedback form renderer is actually working
    fine.
  prefs: []
  type: TYPE_NORMAL
- en: Now here is our revised test routine `testFormRenderer()` in our test case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'It clearly states that in our feedback manager there must be a method named
    `renderFeedbackForm()` and in the generated output there must be four input fields
    namely, `email`,`subject`,`username` and `message`. Now let''s create our `FeedBackManager`
    object. Here is `FeedBackManager` with a single method to render a feedback form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you run the unit test suite you will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Our form renderer failed. Why? Take a look at the output that comes from PHPUnit.
    It says `Message` `field` `is` `not` `present`. Oh! We forgot to place a `textarea`
    object named `message`. Let's revise our `renderFeedbackForm()` method and correct
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added the message field. Now let''s run the suite again. You will get
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Great! Our test has passed. That means our rendered form is potentially error
    free.
  prefs: []
  type: TYPE_NORMAL
- en: This is the style of Test Driven Development. You have to foresee your application
    code before it is actually written. Using TDD helps you to design good API and
    good code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Multiple Assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't write multiple assertions under one test. Split it as shown in the example
    above. To clarify, the following example is a bad example of a unit test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This code will run, but multiple assertions in a single routine are prohibited
    and are against good application design.
  prefs: []
  type: TYPE_NORMAL
- en: PHPUnit API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several types of asserting API provided by PHPUnit. In our examples
    we used ones like `assertTrue()`, `assertEquals()`, `assertFalse()`, and `assertNotNull()`.
    However, there are dozens more. The function names are self explanatory. The following
    table is taken from the book *PHPUnit Pocket Guide* written by Sebastian Bergmann
    himself and published by O'Reilly. The book is made free by O'Reilly and Sebastian
    Bergmann under the Creative Commons License. The latest version of this book is
    currently available at [http://www.phpunit.de/pocket_guide/3.0/en/index.html](http://www.phpunit.de/pocket_guide/3.0/en/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows all the assert functions possible with PHPUnit:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Assertion | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertTrue(bool` `$condition)` | Reports an error if `$condition`
    is `FALSE`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertTrue(bool` `$condition,` `string` `$message)` | Reports an
    error identified by `$message` if `$condition` is `FALSE`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertFalse(bool` `$condition)` | Reports an error if `$condition`
    is `TRUE`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertFalse(bool` `$condition,` `string` `$message)` | Reports an
    error identified by `$message` if `$condition` is `TRUE`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNull(mixed` `$variable)` | Reports an error if `$variable`
    is not `NULL`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNull(mixed` `$variable,` `string` `$message)` | Reports an
    error identified by `$message` if `$variable` is not `NULL`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotNull(mixed` `$variable)` | Reports an error if `$variable`
    is `NULL`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotNull(mixed` `$variable,` `string` `$message)` | Reports
    an error identified by `$message` if `$variable` is `NULL`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertSame(object` `$expected,` `object` `$actual)` | Reports an
    error if the two variables `$expected` and `$actual` do not reference the same
    object. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertSame(object` `$expected,` `object` `$actual,` `string` `$message)`
    | Reports an error identified by `$message` if the two variables `$expected` and
    `$actual` do not reference the same object. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertSame(mixed` `$expected,` `mixed` `$actual)` | Reports an error
    if the two variables `$expected` and `$actual` do not have the same type and value.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertSame(mixed` `$expected,` `mixed` `$actual,` `string` `$message)`
    | Reports an error identified by `$message` if the two variables `$expected` and
    `$actual` do not have the same type and value. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotSame(object` `$expected,` `object` `$actual)` | Reports
    an error if the two variables `$expected` and `$actual` reference the same object.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotSame(object` `$expected,` `object` `$actual,` `string` `$message)`
    | Reports an error identified by `$message` if the two variables `$expected` and
    `$actual` reference the same object. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotSame(mixed` `$expected,` `mixed` `$actual)` | Reports an
    error if the two variables `$expected` and `$actual` have the same type and value.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotSame(mixed` `$expected,` `mixed` `$actual,` `string` `$message)`
    | Reports an error identified by `$message` if the two variables `$expected` and
    `$actual` have the same type and value. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeSame(object` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject)` | Reports an error if `$actualObject->actualAttributeName`
    and `$actual` do not reference the same object. The visibility of the `$actualObject->actualAttributeName`
    attribute may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeSame(object` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject,` `string` `$message)` | Reports an error identified by
    `$message` if `$actualObject->actualAttributeName` and `$actual` do not reference
    the same object. The visibility of the `$actualObject->actualAttributeName` attribute
    may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeSame(mixed` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject)` | Reports an error if `$actualObject->actualAttributeName`
    and `$actual` do not have the same type and value. The visibility of the `$actualObject->actualAttributeName`
    attribute may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeSame(mixed` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject,` `string` `$message)` | Reports an error identified by
    `$message` if `$actualObject->actualAttributeName` and `$actual` do not have the
    same type and value. The visibility of the `$actualObject->actualAttributeName`
    attribute may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeNotSame(object` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject)` | Reports an error if `$actualObject->actualAttributeName`
    and `$actual` reference the same object. The visibility of the `$actualObject->actualAttributeName`
    attribute may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeNotSame(object` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject,` `string` `$message)` | Reports an error identified by
    `$message` if `$actualObject->actualAttributeName` and `$actual` reference the
    same object. The visibility of the `$actualObject->actualAttributeName` attribute
    may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeNotSame(mixed` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject)` | Reports an error if `$actualObject->actualAttributeName`
    and `$actual` have the same type and value. The visibility of the `$actualObject->actualAttributeName`
    attribute may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeNotSame(mixed` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject,` `string` `$message)` | Reports an error identified by
    `$message` if `$actualObject->actualAttributeName` and `$actual` have the same
    type and value. The visibility of the `$actualObject->actualAttributeName` attribute
    may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertEquals(array` `$expected,` `array` `$actual)` | Reports an
    error if the two arrays `$expected` and `$actual` are not equal. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertEquals(array` `$expected,` `array` `$actual,` `string` `$message)`
    | Reports an error identified by `$message` if the two arrays `$expected` and
    `$actual` are not equal. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotEquals(array` `$expected,` `array` `$actual)` | Reports
    an error if the two arrays `$expected` and `$actual` are equal. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotEquals(array` `$expected,` `array` `$actual,` `string` `$message)`
    | Reports an error identified by `$message` if the two arrays `$expected` and
    `$actual` are equal. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertEquals(float` `$expected,` `float` `$actual,` `'''',` `float`
    `$delta` `=` `0)` | Reports an error if the two floats `$expected` and `$actual`
    are not within `$delta` of each other. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertEquals(float` `$expected,` `float` `$actual,` `string` `$message,`
    `float` `$delta` `=` `0)` | Reports an error identified by `$message` if the two
    floats `$expected` and `$actual` are not within `$delta` of each other. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotEquals(float` `$expected,` `float` `$actual,` `'''',` `float`
    `$delta` `=` `0)` | Reports an error if the two floats `$expected` and `$actual`
    are within `$delta` of each other. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotEquals(float` `$expected,` `float` `$actual,` `string` `$message,`
    `float` `$delta` `=` `0)` | Reports an error identified by `$message` if the two
    floats `$expected` and `$actual` are within `$delta` of each other. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertEquals(string` `$expected,` `string` `$actual)` | Reports an
    error if the two strings `$expected` and `$actual` are not equal. The error is
    reported as the delta between the two strings. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertEquals(string` `$expected,` `string` `$actual,` `string` `$message)`
    | Reports an error identified by `$message` if the two strings `$expected` and
    `$actual` are not equal. The error is reported as the delta between the two strings.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotEquals(string` `$expected,` `string` `$actual)` | Reports
    an error if the two strings `$expected` and `$actual` are equal. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotEquals(string` `$expected,` `string` `$actual,` `string`
    `$message)` | Reports an error identified by `$message` if the two strings `$expected`
    and `$actual` are equal. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertEquals(mixed` `$expected,` `mixed` `$actual)` | Reports an
    error if the two variables `$expected` and `$actual` are not equal. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertEquals(mixed` `$expected,` `mixed` `$actual,` `string` `$message)`
    | Reports an error identified by `$message` if the two variables `$expected` and
    `$actual` are not equal. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotEquals(mixed` `$expected,` `mixed` `$actual)` | Reports
    an error if the two variables `$expected` and `$actual` are equal. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotEquals(mixed` `$expected,` `mixed` `$actual,` `string` `$message)`
    | Reports an error identified by `$message` if the two variables `$expected` and
    `$actual` are equal. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeEquals(array` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject)` | Reports an error if the two arrays `$expected` and
    `$actualObject->actualAttributeName` are not equal. The visibility of the `$actualObject->actualAttributeName`
    attribute may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeEquals(array` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject,` `string` `$message)` | Reports an error identified by
    `$message` if the two arrays `$expected` and `$actualObject->actualAttributeName`
    are not equal. The visibility of the `$actualObject->actualAttributeName` attribute
    may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeNotEquals(array` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject)` | Reports an error if the two arrays `$expected` and
    `$actualObject->actualAttributeName` are equal. The visibility of the `$actualObject->actualAttributeName`
    attribute may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeNotEquals(array` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject,` `string` `$message)` | Reports an error identified by
    `$message` if the two arrays `$expected` and `$actualObject->actualAttributeName`
    are equal. The visibility of the `$actualObject->actualAttributeName` attribute
    may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeEquals(float` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject,` `'''',` `float` `$delta` `=` `0)` | Reports an error
    if the two floats `$expected` and `$actualObject->actualAttributeName` are not
    within `$delta` of each other. The visibility of the `$actualObject->actualAttributeName`
    attribute may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeEquals(float` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject,` `string` `$message,` `float` `$delta` `=` `0)` | Reports
    an error identified by `$message` if the two floats `$expected` and `$actualObject->actualAttributeName`
    are not within `$delta` of each other. The visibility of the `$actualObject->actualAttributeName`
    attribute may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeNotEquals(float` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject,` `'''',` `float` `$delta` `=` `0)` | Reports an error
    if the two floats `$expected` and `$actualObject->actualAttributeName` are within
    `$delta` of each other. The visibility of the `$actualObject->actualAttributeName`
    attribute may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeNotEquals(float` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject,` `string` `$message,` `float` `$delta` `=` `0)` | Reports
    an error identified by `$message` if the two floats `$expected` and `$actualObject->actualAttributeName`
    are within `$delta` of each other. The visibility of the `$actualObject->actualAttributeName`
    attribute may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeEquals(string` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject)` | Reports an error if the two strings `$expected` and
    `$actualObject->actualAttributeName` are not equal. The error is reported as the
    delta between the two strings. The visibility of the `$actualObject->actualAttributeName`
    attribute may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeEquals(string` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject,` `string` `$message)` | Reports an error identified by
    `$message` if the two strings `$expected` and `$actualObject->actualAttributeName`
    are not equal. The error is reported as the delta between the two strings. The
    visibility of the `$actualObject->actualAttributeName` attribute may be public,
    protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeNotEquals(string` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject)` | Reports an error if the two strings `$expected` and
    `$actualObject->actualAttributeName` are equal. The visibility of the `$actualObject->actualAttributeName`
    attribute may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeNotEquals(string` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject,` `string` `$message)` | Reports an error identified by
    `$message` if the two strings `$expected` and `$actualObject->actualAttributeName`
    are equal. The visibility of the `$actualObject->actualAttributeName` attribute
    may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeEquals(mixed` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject)` | Reports an error if the two variables `$expected`
    and `$actualObject->actualAttributeName` are not equal. The visibility of the
    `$actualObject->actualAttributeName` attribute may be public, protected, or private.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeEquals(mixed` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject,` `string` `$message)` | Reports an error identified by
    `$message` if the two variables `$expected` and `$actualObject->actualAttributeName`
    are not equal. The visibility of the `$actualObject->actualAttributeName` attribute
    may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeNotEquals(mixed` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject)` | Reports an error if the two variables `$expected`
    and `$actualObject->actualAttributeName` are equal. The visibility of the `$actualObject->actualAttributeName`
    attribute may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeNotEquals(mixed` `$expected,` `string` `$actualAttributeName,`
    `object` `$actualObject,` `string` `$message)` | Reports an error identified by
    `$message` if the two variables `$expected` and `$actualObject->actualAttributeName`
    are equal. The visibility of the `$actualObject->actualAttributeName` attribute
    may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertContains(mixed` `$needle,` `array` `$expected)` | Reports an
    error if `$needle` is not an element of `$expected`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertContains(mixed` `$needle,` `array` `$expected,` `string` `$message)`
    | Reports an error identified by `$message` if `$needle` is not an element of
    `$expected`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotContains(mixed` `$needle,` `array` `$expected)` | Reports
    an error if `$needle` is an element of `$expected`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotContains(mixed` `$needle,` `array` `$expected,` `string`
    `$message)` | Reports an error identified by `$message` if `$needle` is an element
    of `$expected`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertContains(mixed` `$needle,` `Iterator` `$expected)` | Reports
    an error if `$needle` is not an element of `$expected`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertContains(mixed` `$needle,` `Iterator` `$expected,` `string`
    `$message)` | Reports an error identified by `$message` if `$needle` is not an
    element of `$expected`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotContains(mixed` `$needle,` `Iterator` `$expected)` | Reports
    an error if `$needle` is an element of `$expected`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotContains(mixed` `$needle,` `Iterator` `$expected,` `string`
    `$message)` | Reports an error identified by `$message` if `$needle` is an element
    of `$expected`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertContains(string` `$needle,` `string` `$expected)` | Reports
    an error if `$needle` is not a substring of `$expected`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertContains(string` `$needle,` `string` `$expected,` `string`
    `$message)` | Reports an error identified by `$message` if `$needle` is not a
    substring of `$expected`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotContains(string` `$needle,` `string` `$expected)` | Reports
    an error if `$needle` is a substring of `$expected`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotContains(string` `$needle,` `string` `$expected,` `string`
    `$message)` | Reports an error identified by `$message` if `$needle` is a substring
    of `$expected`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeContains(mixed` `$needle,` `string` `$actualAttributeName,`
    `object` `$actualObject)` | Reports an error if `$needle` is not an element of
    `$actualObject->actualAttributeName` which can be an array, a string, or an object
    that implements the Iterator interface. The visibility of the `$actualObject->actualAttributeName`
    attribute may be public, protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeContains(mixed` `$needle,` `string` `$actualAttributeName,`
    `object` `$actualObject,` `string` `$message)` | Reports an error identified by
    `$message` if `$needle` is not an element of `$actualObject->actualAttributeName`
    which can be an array, a string, or an object that implements the Iterator interface.
    The visibility of the `$actualObject->actualAttributeName` attribute may be public,
    protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeNotContains(mixed` `$needle,` `string` `$actualAttributeName,`
    `object` `$actualObject)` | Reports an error if `$needle` is an element of `$actualObject->actualAttributeName`
    which can be an array, a string, or an object that implements the Iterator interface.
    The visibility of the `$actualObject->actualAttributeName` attribute may be public,
    protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertAttributeNotContains(mixed` `$needle,` `string` `$actualAttributeName,`
    `object` `$actualObject,` `string` `$message)` | Reports an error identified by
    `$message` if `$needle` is an element of `$actualObject->actualAttributeName`
    which can be an array, a string, or an object that implements the Iterator interface.
    The visibility of the `$actualObject->actualAttributeName` attribute may be public,
    protected, or private. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertRegExp(string` `$pattern,` `string` `$string)` | Reports an
    error if `$string` does not match the regular expression `$pattern`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertRegExp(string` `$pattern,` `string` `$string,` `string` `$message)`
    | Reports an error identified by `$message` if `$string` does not match the regular
    expression `$pattern`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotRegExp(string` `$pattern,` `string` `$string)` | Reports
    an error if `$string` matches the regular expression `$pattern`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotRegExp(string` `$pattern,` `string` `$string,` `string`
    `$message)` | Reports an error identified by `$message` if `$string` matches the
    regular expression `$pattern`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertType(string` `$expected,` `mixed` `$actual)` | Reports an error
    if the variable `$actual` is not of type `$expected`.. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertType(string` `$expected,` `mixed` `$actual,` `string` `$message)`
    | Reports an error identified by `$message` if the variable `$actual` is not of
    type `$expected`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotType(string` `$expected,` `mixed` `$actual)` | Reports an
    error if the variable `$actual` is of type `$expected`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertNotType(string` `$expected,` `mixed` `$actual,` `string` `$message)`
    | Reports an error identified by `$message` if the variable `$actual` is of type
    `$expected`. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertFileExists(string` `$filename)` | Reports an error if the file
    specified by `$filename` does not exist. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertFileExists(string` `$filename,` `string` `$message)` | Reports
    an error identified by `$message` if the file specified by `$filename` does not
    exist. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertFileNotExists(string` `$filename)` | Reports an error if the
    file specified by `$filename` exists. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertFileNotExists(string` `$filename,` `string` `$message)` | Reports
    an error identified by `$message` if the file specified by `$filename` exists.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertObjectHasAttribute(string` `$attributeName,` `object` `$object)`
    | Reports an error if `$object->attributeName` does not exist. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertObjectHasAttribute(string` `$attributeName,` `object` `$object,`
    `string` `$message)` | Reports an error identified by `$message` if `$object->attributeName`
    does not exist. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertObjectNotHasAttribute(string` `$attributeName,` `object` `$object)`
    | Reports an error if `$object->attributeName` exists. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `assertObjectNotHasAttribute(string` `$attributeName,` `object` `$object,`
    `string` `$message)` | Reports an error if `$object->attributeName` exists. |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on two very important features of object oriented programming
    in PHP. One is reflection, which is a part of all major programming languages
    like Java, Ruby, and Python. The second one is unit testing, which is an essential
    part of good, stable, and manageable application design. We focused on one very
    popular package, which is a port of JUnit in PHP, named PHPUnit. If you follow
    the guideline provided in this chapter you will be able to design your unit tests
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about some built-in objects in PHP which
    will make your life much easier than usual. We will learn about the huge object
    repository called Standard PHP Library or SPL. Before that, enjoy the debugging
    by writing your own unit tests.
  prefs: []
  type: TYPE_NORMAL
