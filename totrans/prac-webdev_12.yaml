- en: Chapter 12. Mobile First, Responsive Design with Progressive Enhancement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is most definitely the chapter with the longest title. There is also a
    lot of text inside the first part of this chapter, as you will find little or
    no code examples there. Here, we discuss the newest trends in web development,
    what is causing it, and what it replaces.
  prefs: []
  type: TYPE_NORMAL
- en: Responsive design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A viewport, or the section of the screen where your browser is, comes in all
    kinds of sizes. Some are very small, such as the screen of your smartphone, and
    some can be very large. When I looked at my old website on a screen a lot larger
    than the one I was used to work on, it was so ugly that I decided to completely
    redo it using a **responsive design**.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a web page with a fixed width specified in pixels today really is
    out of the question, as is making several versions of your website to accommodate
    all these sizes.
  prefs: []
  type: TYPE_NORMAL
- en: In responsive design—I am always tempted to call it responsible design—one does
    not start off with a canvas of, let us say, 960 px wide and build a site that
    way, chopping it into fixed size `<div>` blocks. As soon as the view port is smaller
    than 960px, a part of the site would not be visible and, maybe worse, when the
    screen is really big, everything around your 960x wide rectangle will look boring
    and empty. This is simply not done today.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good design should adjust, respond, to the screen size and always look good.
    To have a good responsive design, you need to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a flexible grid: have your building blocks sit side by side when there
    is room, stack them on top of each other when there is none, and proportionally
    adjust sizes to do so'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use percentages, not pixels, in your CSS when you define those sizes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use media queries to specify different properties for different screen sizes,
    resolutions, orientations, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use flexible images and fonts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This seems like a lot of work. The good news is that others have already done
    that hard work for you. There are several CSS/JavaScript frameworks available
    that feature all the things we just listed. You will simply have to add media
    queries, customized to your site. The hardest part is probably which framework
    to choose, as there are several really good ones, in particular **Bootstrap**
    and **Foundation**.
  prefs: []
  type: TYPE_NORMAL
- en: We have chosen for Foundation and that will be the topic of the next chapter.
    That choice was a matter of taste or preference. *De gustibus non disputandum!*
  prefs: []
  type: TYPE_NORMAL
- en: Déjà vu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I am writing this, I am having a flashback-like experience. In my first job
    in the software industry, I was responsible for porting a software package, TEN/PLUS,
    to several different flavors of UNIX. Its main component was a full-screen editor.
  prefs: []
  type: TYPE_NORMAL
- en: A full screen in those days was that of a so called **dumb terminal** with 24
    lines holding 80 characters each. Then came the **X Window System** and monitors
    in graphics mode, with icons and many utilities, support for a mouse, and so on.
    One of those utilities is **xterm**, an X client emulating a dumb terminal. That
    of course meant you could run full screen editors inside it. But you could resize
    the xterm window, to be one with more lines or longer lines.
  prefs: []
  type: TYPE_NORMAL
- en: So I had to modify our software to adjust to that size and still be a full-screen
    editor inside xterm, even if it was 64 lines by 120 characters. This was responsive
    design 25 years ago! And in 2015 people are still using editors such as vi, emacs,
    nano, and so on inside terminal windows.
  prefs: []
  type: TYPE_NORMAL
- en: Media queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The keyword **media** has been in use from the very beginning in HTML and CSS,
    but it was basically limited to specifying `media="print"` or `media="screen"`
    inside the `<link>` tag where you specified your CSS file, or by using `@media`
    screen inside the CSS file itself.
  prefs: []
  type: TYPE_NORMAL
- en: As of CSS3 and HTML5, we can use media queries in more sophisticated ways, to
    have specific styling that is applied only when certain conditions are met. Although
    the `media` attribute can still be used inside the `<link>` tag, we recommend
    you use them inside your CSS files. Media queries are essential to responsive
    design and, even though we promised you little or no work thanks to available
    frameworks, it is essential to know how to write or read them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical media query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In between the curly braces, you would write the styling that is applicable
    to viewports that are between 480 and 690 pixels wide and your device is in portrait
    mode. Everything that came before will apply. Everything that is between those
    curly braces will override what came before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the most common keywords that can be used in media queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**width**: Width of display area'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**height**: Height of display area'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**device-width**: Width of device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**device-height**: Height of device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**orientation**: Orientation of device (portrait or landscape)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**resolution**: Density of pixels, expressed as dpi or dpcm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All, except for orientation of course, can be preceded by minimum or maximum.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the media query with the word `only` is a handy way to deal with browsers
    that do not support these newer media queries. It will be silently ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between width and height and the equivalent values prefixed
    by device should be easy to understand: width and height refer to the size of
    the browser viewport, whereas device-width and device-height refer to the dimensions
    of the monitor. Not everybody runs his or her browser full-screen, so width and
    height are the measurements that you need to use. There is one big caveat though.'
  prefs: []
  type: TYPE_NORMAL
- en: Mobile browsers fill the available screen, so you might expect width and device-width
    to be the same. Unfortunately, that's not always the case. Most smart-phones set
    the width to a nominal value approximately 1,000 pixels wide (for an iPhone, it's
    980 pixels). You have seen several adds of mobile phones showing a full page of
    the New York Times on the tiny phone. That's why!
  prefs: []
  type: TYPE_NORMAL
- en: 'With the fine retina displays of today, you would even be able to read the
    paper that way. But if you worked hard in getting your media queries right for
    various devices and have one for, let''s say `max-width:480px`, your beautiful
    responsive design will not show up on that mobile phone. Fortunately, there is
    a remedy for this. Simply put the following line in the `<head>` section of your
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we are truly on our way to a responsive design. By using media queries,
    we can create a page with a single design that will show elements on the page
    (think `<div>`) next to each other on a large screen, show them stacked on top
    of each other on a tablet in portrait mode, and show fewer of them on a mobile
    phone.
  prefs: []
  type: TYPE_NORMAL
- en: Using the media attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You have probably seen sites containing a line like this in the `<head>` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It uses the `media` attribute to indicate if this stylesheet needs to be used.
    In HTML4 this was basically `screen` or `print`. In HTML5 the media attribute
    can have a lot more values. Those can be the same as what we put after `@media`
    only on our examples. So if we wanted, we could organize our CSS code in separate
    stylesheets, one for each media type and use them as appropriate, as is shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Do more with less
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This term probably brings back bad memories to people who lived through the
    period before and during the financial crisis, but that is not what we are going
    to talk about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have introduced media queries, we are at risk of having to write
    a lot more CSS, one set of rules for each media query we decide to use. Assume
    we divide it like three T-shirt sizes: small, medium, large. Add to that portrait
    and landscape flavors of each: you now have six.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that someone in the marketing department decides to change the corporate
    color: you now have to make six changes to your stylesheet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where extensions to CSS, such as **less** (**SASS** is another one)
    prove to be very handy. One of its features is the use of **variables**. Create
    a `.less` file to hold your stylesheet information. Use a variable to hold the
    color information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside your media queries, wherever you need to specify this color, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine you want to change it to `teal`. Just replace that single line by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Bingo! You have changed your color in all six places. Isn't that nice?
  prefs: []
  type: TYPE_NORMAL
- en: 'Less has more features such as mixins, nested rules, media queries, and more,
    resulting in better structured and easier to maintain stylesheets. It is all described
    very clearly at [lesscss.org](http://lesscss.org). The name of the site immediately
    explains why they call it less: You will end up writing less CSS. Just look at
    these two examples. The following is the `less` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be translated into the following CSS. And if you really start nesting,
    this can become a lot more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have one more example with media queries. We could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will be translated into the following CSS. Don't you think the `less` version
    is less verbose?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now how do we convert the less file to CSS content? There are two ways to do
    this. When we reach the production stage, we want to use a compiler to generate
    the CSS file from our less file. In [Chapter 14](ch14.html "Chapter 14. Node.js"),
    *Node.js*, you will learn about Node.js and node modules. There is a `node` module
    for less.
  prefs: []
  type: TYPE_NORMAL
- en: For now, while we are still developing and experimenting more with less, download
    `less.js` from the [lesscss.org](http://lesscss.org) site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `<head>` section of your page, list your `less` file in a `link`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'I like to keep my `less` files in a `less` folder. In the right spot on your
    page, for example, right before the closing `</body>` tag, add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now your `less` file will be converted to CSS on-the-fly, each time the page
    is loaded. Note that, when editing your `less` files, not all editors will give
    you the nice color coding and formatting they feature when you edit CSS files.
    I use Textastic to edit my `less` files. To paraphrase the governator: *You have
    to watch this editor: it is fantastic!*'
  prefs: []
  type: TYPE_NORMAL
- en: Mobile first
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we covered how to make our design responsive and make our page look
    good on screens of all sizes, you might think we have covered mobile devices as
    well. Nope.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting mobiles is not just about screen sizes. You may have seen the add
    we talked about where a guy is reading the *New York Times* on his iPhone, a full
    page spread. This is how mobile devices will render websites on high- resolution
    displays, unless you tell them not to. Before we continue this thread, I would
    like to stress that this discussion is about how to design **web applications**
    that are interpreted by mobile browsers, not native iOS or Android apps.
  prefs: []
  type: TYPE_NORMAL
- en: Why mobile first?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s reply with a question: why not? Or let''s answer it: because mobile
    *is* first. Mobile devices (smart-phones and tablets) have been shipping 4-5x
    more units than PCs or TVs for several years now. More users are visiting the
    Web using a mobile connection than with fixed Internet access. That is why it
    is important to think first what experience these mobile users will have when
    they visit our site and not create a fixed canvas version of a site first and
    then make changes to deal with mobile users. That would be another case of (not
    so) *graceful degradation*.'
  prefs: []
  type: TYPE_NORMAL
- en: You may not always have the choice if your marketing person shows up with yet
    another static design from the design firm. But marketing people like numbers,
    so tell them to check the numbers and you may have a soul mate soon.
  prefs: []
  type: TYPE_NORMAL
- en: We have come a long way
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In 2007, not all that long ago, I was developing a modest website with my photographs.
    A friend of mine was checking it out on his smartphone. After seeing this, I had
    to buy one myself, not because it was so great but because I needed one to test
    my website; at least, that was my justification. Even though I could not really
    afford it, I got the latest greatest Nokia, a brick compared to today's iPhone,
    that you could flip open to give you a bigger screen and a real keyboard. But
    the web access on it was terrible. It took what seemed like forever to get a browser
    started. The little keyboard was OK but the experience is quite different today
    when I use my iPhone or iPad with a sturdy Bluetooth keyboard. As a matter of
    fact, a lot of this book was written on an iPad while sitting on the train.
  prefs: []
  type: TYPE_NORMAL
- en: The year before I made several trips back to Belgium and, because my parents
    had no Internet at home, I went to a so-called Internet hotspot to check my e-mails.
    For 10 Euros an hour, you could buy a scratchcard that revealed an access code
    that you needed to use on the local carrier's website together with your cell
    phone number; then they sent you a password by SMS. This whole procedure would
    sometimes take 20 minutes and cost me international roaming charges because I
    had a U.S. phone number. Now I had 40 minutes worth of Wi-Fi left to myself. Mobile
    Internet was slow and expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Now most of these barriers are gone, bandwidth is up, Wi-Fi is free in most
    places, or you can install a SIM card.
  prefs: []
  type: TYPE_NORMAL
- en: To take the term *We have come a long way* one step further, allow me to share
    one little anecdote. I am a big fan of the Eastern Sierra and have taken many
    trips there, most of the time going through Yosemite National Park. I know a nice
    alternate road to take you to the West entrance of the Park that goes through
    the Gold Country town of Coulterville.
  prefs: []
  type: TYPE_NORMAL
- en: 'The local Jeffery Hotel has a saloon with two signs above the entrance door.
    One says: *"Magnolia Saloon - est. 1851 - California''s Oldest Operating Saloon"*.
    The one right above it says: *Free WiFi*.'
  prefs: []
  type: TYPE_NORMAL
- en: Mobile devices have newer capabilities
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The situation described in the last few paragraphs—except for the saloon—has
    definitely turned around. Mobile devices perform well, Internet access is affordable,
    and the majority of the devices used can access the World Wide Web, so we better
    make sure people can access our site or applications with them.
  prefs: []
  type: TYPE_NORMAL
- en: I am not in the habit of using a lot of numbers, I have only used a few so far,
    but in a recent survey I learned that, of mobile phone users, 84% use them while
    at home, 63% while in the office, and 42% while on the move.
  prefs: []
  type: TYPE_NORMAL
- en: On mobile devices, there is no clicking with the mouse and no hovering on a
    phone or tablet, but there is **swiping**. There are many new interfaces, often
    tied to hardware and iOS that you will not find on desktops. The interface to
    select a date on a phone is different than, for example, using the jQuery UI date
    picker.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you read the specs of the latest greatest iPhone on the Apple website, I
    bet you they forgot to mention one important feature of the product, at least
    not in a very visible and obvious way: you can make phone calls with it. So if
    the contact information of your site contains phone numbers, let the user make
    a phone call by just clicking that number. It is as easy as putting an `<a>` tag
    around it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This may be a trivial example, but it illustrates mobile first thinking. And
    the phone will do the rest. So make sure that, when an application is used on
    a mobile with one of these new capabilities, it can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile devices are not only used while on the road
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Forget screen sizes, think content. It is not about small versus large, but
    about mobile versus local, about on-the-road versus at home. When someone is traveling
    and is looking for his hotel, he expects to quickly find contact info when he
    checks the hotel's website on his mobile, not photographs of the rooms and the
    indoor and outdoor pool. But he may have used that same mobile, while sitting
    in his couch at home to make the reservation, because the kids were using the
    computer or iPad. So on that day he was interested in those pictures.
  prefs: []
  type: TYPE_NORMAL
- en: So if he is looking for the hotel we could, if the phone supports it, show him
    a map on his smart phone, in a GPS-like fashion, showing his location as well
    as that of his hotel.
  prefs: []
  type: TYPE_NORMAL
- en: What we do not want to do is to make his cellular phone carrier wealthy by forcing
    a download of 900x600 JPG files in areas where bandwidth is poor yet expensive,
    because someone decided to have a photo banner on the home page at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: Content first, navigation next
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The previous comments boil down to this. In our thinking, we should put the
    most important content within immediate reach. Having a horizontal menu with *contact*
    all the way to the right or, worse, somewhere at the bottom of the page is not
    going to help our traveler.
  prefs: []
  type: TYPE_NORMAL
- en: In a recent project where I had to deal with a design firm's wireframe made
    for a desktop screen, containing a horizontal navigation, I looked at all the
    navigation items and rearranged them, contact first, replaced the photo banner
    with responsive images and replaced that menu with the word `menu` with three
    stripes underneath.
  prefs: []
  type: TYPE_NORMAL
- en: I placed most of my code inside my `max-width:480px` media query. A simple tab
    on `menu` would present the visitor with a menu on the small screen with all the
    relevant topics.
  prefs: []
  type: TYPE_NORMAL
- en: The way I did this, the menu will appear to be coming from the left of your
    phone somewhere, similar to what the Facebook app does. I used **Foundation**
    to achieve that. You will learn about Foundation in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Small means big
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You may have noticed on many sites, even really good ones, that you are being
    switched to a mobile version of the site, a different URL like `m.site.com`, while
    visiting them on your smart-phone. This is not what we recommend. Once you decide
    to go with two, what is to stop you from creating a third, and so on? Many web
    designers who stay with a single site react to smaller by shrinking everything
    down so things still fit on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, you may want to do the opposite because it is going to become
    hard to read. Retina screens and the like are so crisp these days that smaller
    typefaces on these screens are actually easy to read. You could do both by handling
    the Retina or not question in a media query.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, this is an as-good-as-ever moment to point out that, of these
    millions of new people accessing the Web on mobiles, many are of an older generation
    who would appreciate a bigger font size because their eyes are not what they used
    to be.
  prefs: []
  type: TYPE_NORMAL
- en: The real issue is not the text but that you do not have the pixel-level accuracy
    of a mouse. When you want to click on something you will have to use your finger.
    If these areas are shrunk down as well, the risk of clicking on the wrong thing
    goes up dramatically.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We mentioned reading, we mentioned clicking, how about filling out a web form?
    A lot of old-school websites—for example, web shops containing registration forms—have
    many `<input>` fields and are designed to fit on a full screen with a single *submit*
    button at the end. So, on a phone this is going to be hard; therefore you may
    want to consider splitting up these forms. If the input field is not big enough,
    tapping with a finger may take the user to the wrong spot. So you want to make
    these bigger than on a desktop. But there is one other thing about input that
    is often forgotten: the keyboard.'
  prefs: []
  type: TYPE_NORMAL
- en: On a smart phone or tablet, there is no keyboard. When the web application/browser
    detects that input is needed, a soft keyboard shows up as part of your screen.
    On a smart phone in portrait mode, that makes it hard to type.
  prefs: []
  type: TYPE_NORMAL
- en: 'When there is a need to type in a number, you need to first switch that keyboard
    to a different mode, and yet another mode for some symbols. Not everybody is schlepping
    a Bluetooth keyboard with him everywhere he goes, like I do. For this part, you
    can use the new `<input>` types in HTML5\. Most mobile browsers are HTML5-capable
    so when you use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Those browsers will present you with a keyboard layout that has at least the
    `@` sign in it, which on some keyboards is hard to find. I live in *azerty* country
    again. I know.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile first recap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You probably get the picture. In this new world with millions of mobile devices,
    we need a new way of thinking about what information we provide on our site and
    how we do that. Use features of the phone, when you can; put content before navigation.
    Design your site as *one site fits all*, not *one size fits all*. This is not
    a technology, but a philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: But we will need a technology to determine whether the browser/device combination
    supports certain features, such as **geolocation**, or even interprets JavaScript,
    and use it only when present. When we do that, we are practicing **progressive
    enhancement**.
  prefs: []
  type: TYPE_NORMAL
- en: Progressive enhancement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A few years ago, a colleague once told our project manager that 80% of the time
    he spent changing already finished code to make it work in old browsers. In those
    days, a lot of people spent a lot of time making *round corners* work on Internet
    Explorer in a costly (in terms of development time and performance) attempt to
    make everything look exactly the same everywhere. A lot of folks decided to postpone
    adapting the new features in CSS3 and HTML5 because some browsers did not support
    them. This was just to support a single digit number of browsers and make sure
    the website was still functional when you switched off JavaScript (graceful degradation).
  prefs: []
  type: TYPE_NORMAL
- en: Today, there is bad news and there is good news. The bad news is that there
    are more browsers than you can imagine and a lot of browser/device pairs support
    APIs that others don't. The good news is that several technologies have emerged
    to tackle this problem in a more proactive or, shall I say, progressive way.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do we handle this and still come up with a single version of our site?
    First, we need another philosophical change: do not be afraid to use the features
    that are available, make your sites and applications more cool and exciting, and
    enhance them with those features. How will we handle browsers or devices that
    do not support those features?'
  prefs: []
  type: TYPE_NORMAL
- en: We propose a two-stage process. First, we will determine what the minimal content
    of our site has to be if virtually no modern features (for example JavaScript,
    fancy CSS features, and media queries) are available and start by writing our
    page accordingly. This is our basic site. Next we will add things such as jQuery
    and JavaScript code, media queries, and newer CSS and HTML features, animation,
    and so on to make our site nicer, to enhance it. This is called progressive enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, there is jQuery and another library, called **EnhanceJS**, to help
    us do that. We will illustrate how. After that we show how to refine this technique:
    test for a particular feature, use it if available, and possibly use a replacement
    library or polyfill that adds the feature to non-capable browsers. We already
    used such a polyfill in a previous chapter—the history plugin for jQuery.'
  prefs: []
  type: TYPE_NORMAL
- en: EnhanceJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: EnhanceJS will test the browser for a comprehensive set of features. If they
    all pass, we load the files that make up the enhanced version of our site, such
    as jQuery, a CSS file with media queries, and so on. If not, the site that we
    look at is our basic site.
  prefs: []
  type: TYPE_NORMAL
- en: Please note, if we want to use Ajax to dynamically inject HTML into parts of
    our page, we will not be able to do this in the basic version. Depending on how
    much content we decide we want on there, it may be "Back to the future" all over
    again, as we will have to provide links to static pages. That way, all our visitors
    using old equipment will see at least a functional site with reasonable content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: enhance.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**enhance.js** is a JavaScript library that performs a comprehensive suite
    of tests to see whether the browser supports enough features to handle what you
    had in mind for your enhanced site. At the time of writing, one could find it
    at [https://code.google.com/p/enhancejs](https://code.google.com/p/enhancejs).
    You can also find documentation there and useful links.'
  prefs: []
  type: TYPE_NORMAL
- en: If the test fails, nothing inside `enhance()` will happen and your basic site,
    in our example good ol' *Hello World*, will be what the visitor sees. If the test
    succeeds, enhance.js will add the class `enhanced` to the `<html>` tag and attempt
    to perform the tasks you put inside it.
  prefs: []
  type: TYPE_NORMAL
- en: loadStyles and loadScripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**loadStyles** and **loadScripts** are two arrays where you can specify which
    stylesheets and JavaScript files you want to load. You can also specify conditions
    such as media queries to conditionally load one file or another. Instead of placing
    simply the pathname of the files in your array, you could use a JavaScript object
    using attribute names as the keys. So in our first example, we could have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a more elaborate example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: enhanced and FOUC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a common problem known as **Flash of unstyled** **content** (**FOUC**)—be
    careful how you spell the acronym. This is the phenomenon where your see some
    flickering on your screen caused by temporarily displaying your HTML that is not
    yet processed by your JavaScript code during page load. There is an opportunity
    here to tackle this problem based on the knowledge that, if the enhance.js test
    is successful, it will add the class `enhanced` to the `<html>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, you could add the following to your **enhanced.css** and **enhanced.js**
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The above statement almost implies that, in the enhanced version of the site,
    we have code in our enhanced.js that will result in HTML being injected inside
    the `#content` div. Another approach would be to have `#basiccontent` div and
    `#enhancedcontent` div and make only the one that is appropriate visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enhance.js, as described here, gives us an all-or-nothing approach. It runs
    a comprehensive set of tests to determine whether the visitor should see the basic
    version or the enhanced version. They are described in the documentation and of
    course in the code of enhance.js itself. At the time of writing, enhance.js had
    not been updated since 2010\. There is nothing wrong with that: it does a job
    that has not changed and it does it well.'
  prefs: []
  type: TYPE_NORMAL
- en: None of these tests check support for some of the newer HTML5 and CSS3 features
    such as **Canvas**. Enhance.js has more configurable options that allow you to
    add your own tests and, if you like, run `enhance()` more than once to test different
    conditions. So you could do it that way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There really is no need to because, as is often the case in the world of web
    development, an entire team has done this for us already.
  prefs: []
  type: TYPE_NORMAL
- en: Modernizr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Modernizr.js** is similar to Enhance.js, it is a JavaScript library that
    tests browsers for features. But it has a lot more tests, can be customized, and
    can be used at a more granular level than Enhance.js. Modernizr tests for individual
    features. Depending on whether the test succeeds (*Yep*) or not (*Nope*), we can
    load different stylesheets and `.js` scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even use the two together. Start by using enhance.js to determine whether
    the browser supports JavaScript. If it does, load modernizr.js together with jQuery
    and refine what you want to do, in your own JavaScript code. Your basic page could
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So, we have changed it a little bit from the previous section. We of course
    added the `modernizr.js` library to be part of our JavaScript line-up, but one
    remarkable tiny change is the `class="no-js"` attribute for the `<html>` tag.
    Whereas enhance.js adds the class `enhanced` to this tag, Modernizr will replace
    this class with `js` when it runs. So if it does not, because there is no JavaScript,
    you can account for it in your stylesheets with the `.no-js` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modernizr will add a lot more classes to the `<html>` tag, almost one for every
    test passed. So once again you could accommodate them in your stylesheet. Using
    this example on my MacBook Pro with Firefox as the browser, I checked with Firebug
    and noticed that modernizr.js had replaced `no-js` with `js` and added the following
    classes to the `<html>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The Modernizr object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have loaded modernizr.js and all the tests have been performed, you
    have access to the `Modernizr` object and can check in your JavaScript code whether
    or not a test has passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Polyfills and Modernizr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Polyfills** are scripts that take care of functionality a browser lacks when
    you need it. The `history.js` library that we discussed at length in [Chapter
    9](ch09.html "Chapter 9. The History API – Not Forgetting Where We Are"), *The
    History API— Not Forgetting Where We Are*, could be a polyfill for the HTML 5
    History API. I said, could, because in our example in that chapter we used history.js
    regardless. True polyfills are used only when the feature is lacking. So the code
    above could use a different API if HTML5 support is there compared to the API
    available through the polyfill.'
  prefs: []
  type: TYPE_NORMAL
- en: This could explain why the name Modernizr is chosen. Whereas enhance.js allows
    you to take care of people using the old stuff and give them an interface using
    the current stuff, Modernizr allows you to write today the code that your visitor
    will use tomorrow or next week, when they update their computer or buy a new phone
    or tablet. You are now ahead of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Your site or application already uses all the cool stuff HTML5 and CSS3 offers
    and has fallback code in case older technology is involved. You can motivate your
    customer or visitor to update sooner rather than later, but your site or application
    already supports what to them lies in the future. Is this cool, or what?
  prefs: []
  type: TYPE_NORMAL
- en: yepnope.js or Modernizr.load
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like you saw in the *Enhance.js* section, you conditionally load files
    based on passing or failing a test. The coolest conditional loader is **yepnope.js**.
    At the time of writing, it was going to be deprecated, so its inclusion inside
    Modernizr might disappear. For sure, something newer will show up. So, for now,
    we include a short example of how you can do conditional loading of static assets
    with Modernizr:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has the longest title in the book, fitting for the most important
    one. In it, we explained the difference between web development yesterday and
    web development tomorrow. We explained that you need to think mobile first, that
    your design has to be responsive, and that you should reward customers who have
    the latest, greatest stuff by using the cool new features through progressive
    enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, we will guide you through how to apply all that came before
    using a cool CSS/JavaScript framework, Foundation, so you can use what someone
    already did for you. We will also show you a way to take full control of how you
    want things to be handled on the server side, using node.js.
  prefs: []
  type: TYPE_NORMAL
- en: If you stop right here, you have learned the basics of modern web development
    and I congratulate you for doing that. If you go on, you will learn to use a framework
    that will save you a lot of time and work in the long run as well as what looks
    like a totally different way of doing things. As we go on explaining it, you will
    realize that it is not all that different in the first place.
  prefs: []
  type: TYPE_NORMAL
