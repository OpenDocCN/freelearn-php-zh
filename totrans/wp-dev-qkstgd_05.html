<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Extending Plugins with Addons, Filters, and Actions</h1>
                </header>
            
            <article>
                
<p>uilding sites with WordPress involves using existing plugins or creating your own plugins. You should be able to extend existing plugins with new features as well as make your plugins extendable for other developers. We use addons to extend the functionality of a core plugin. So, it's important to keep your plugins extendable so that you can later use addons to add or remove functionality. On the other hand, using and customizing existing plugins with addons allows you to provide low-cost and quality solutions. So, you need to master the techniques of building addons for customizing plugin features as well as integrating multiple plugins.</p>
<p>In this chapter, <span>we explain</span> the importance of addons while following the step-by-step guide to creating an addon for a plugin. WordPress uses a hook-based architecture and hence the built-in hooks are executed in a predefined sequence. We look at the proper execution of these hooks to prevent unnecessary conflicts. Then, we move into customization techniques for plugins while learning the advance uses of script loading and built-in AJAX features. We will be developing a product files addon for WooCommerce, in order to practically experience the customization process. Finally, we integrate the WooCommerce, MyCred, and BuddyPress plugins to learn the best practices of plugin integrations and their limitations.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Introduction to addons development</li>
<li>Creating a basic addon for the post attachments plugin</li>
<li>Understanding the WordPress core action execution process</li>
<li>Customizing third-party plugins</li>
<li>Identifying techniques for integrating plugins</li>
<li>Integrating multiple plugins for <span>continuous </span>workflow</li>
</ul>
<p class="mce-root"/>
<p>By the end of this chapter, you will have the ability to customize third-party plugins using different techniques, and integrate multiple plugins to build a continuous workflow for your site.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical Requirements</h1>
                </header>
            
            <article>
                
<p>You will be required to have WordPress 4.9.8 installed to follow this procedure. Even if you<br/>
have a later version of WordPress, the described examples should work with no significant problems.</p>
<p class="mce-root">The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter05">https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter05</a></p>
<p class="mce-root">Check out the following video to see the code in action:<br/>
<a href="http://bit.ly/2Q8LtBa" target="_blank">http://bit.ly/2Q8LtBa</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to addons</h1>
                </header>
            
            <article>
                
<p>In general terms, addons are components that change the behavior of a core component. As a developer, you might be familiar with using browser extensions to support development tasks. In such a scenario, the web browser acts as the core component and the extensions act as the addons that install on top of the web browser. The addons in WordPress follows the same concept. However, WordPress addons itself are plugins that change the behavior of a main plugin. Unlike browser extensions, addons in WordPress don't install on top of a plugin. Instead, they act as separate addon plugins.</p>
<p>Usually, addons are used to add new features to the core component. However, WordPress addons are developed to add, change, or remove features of a core component. Let's take a look at some of the popular plugins with a large addons base:</p>
<ul>
<li><strong>WooCommerce</strong>: This is an eCommerce plugin that allows you to sell physical goods as well as digital products. This plugin has an extensive addons base of over 250 addons in various categories. Payment gateways are the most popular type of addon in WooCommerce with over 75 addons. You can view and learn more about the addons base at <a href="https://woocommerce.com/product-category/woocommerce-extensions/">https://woocommerce.com/product-category/woocommerce-extensions/.</a> <a href="https://woocommerce.com/product-category/woocommerce-extensions/"/></li>
<li><strong>Easy Digital Downloads</strong>: This is an eCommerce solution allowing you to sell digital products. This plugin also offers over 100 addons while many of them fall into the marketing category. You can learn more about the addons base at <a href="https://easydigitaldownloads.com/downloads/">https://easydigitaldownloads.com/downloads/.</a>
<p class="mceNonEditable"/>
<a href="https://easydigitaldownloads.com/downloads/"/></li>
<li><strong>WP Bakery Page Builder</strong>:<strong> </strong>This is a plugin used for building page using pre-built components. Both WooCommerce and Easy Digital Downloads are free plugins in the WordPress plugin directory. However, this is a premium-only plugin with over 250 addons in various categories. The UI elements is the most popular addon category for this plugin. <span>You can view and learn more about the addons base at <a href="https://wpbakery.com/addons/">https://wpbakery.com/addons/.</a></span></li>
</ul>
<p>hese are some of the plugins with a large addons base. The existence of addons means that the plugin is coded with necessary hooks for future extension. You can check more popular free and premium plugins to check the availability of addons. Also, you should check the role of each addon and how it interacts with the main plugin. Once you explore different types of addons, you will understand the types of hooks needed in development and how to add them to keep the code open for extension. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating addons for plugins</h1>
                </header>
            
            <article>
                
<p>The process of creating addons is similar to the process we used for plugins. However, the possibility of creating an addon depends on the quality of the code in the core plugin. The core plugin should either provide an API to build addons or necessary hooks for extension. As many plugins don't contain a separate API, most addons are built by using the existing hooks. Let's see how we can create an addon for the post attachments plugin created in the previous chapter. Assume that we have the following requirements to be developed as an addon:</p>
<ul>
<li>Restrict attachment file types based on default WordPress user roles. Let's provide PDF file access only for non-subscriber members and all other file types to all users in the site.</li>
<li>Download counter for attachments. We have to count the number of downloads for all attachments of a post, separately for guest users and logged-in users.</li>
</ul>
<p>In order to implement such requirements without touching the core plugin files, we need to check the availability of any hooks within the plugin. Unfortunately, we don't have any hooks within the plugin, as it was not planned for future extension. So, we have to make the plugin extendable, by adding the necessary hooks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a filter hook for restricting attachments</h1>
                </header>
            
            <article>
                
<p>Implementing attachment restrictions requires us to conditionally check the user permissions and hide the attachment for unauthorized users. So, we need a filter that can modify the output of attachments in list. Let's add a filter to the file list code inside <kbd>wpqpa_file_attachment_list</kbd>. We need to replace the following code:</p>
<pre>$display .= '<br/>      &lt;div class="wpqpa-file-item" id="PF'.$file_row-&gt;id.'"  data-file-id="'.$file_row-&gt;id.'" &gt;<br/>        &lt;div class="wpqpa-file-item-row"    &gt;<br/>            &lt;div class="wpqpa-file-item-name wpqpa-files-list-name" &gt;'.$file_row-&gt;file_name.'&lt;/div&gt;<br/>            &lt;div class="wpqpa-file-item-download" &gt;&lt;a href="'.$url.'" &gt;'.__("Download","wpqpa").'&lt;/a&gt;&lt;/div&gt;<br/>            &lt;div class="wpqpa-clear"&gt;&lt;/div&gt;<br/>        &lt;/div&gt;<br/>        &lt;div class="wpqpa-clear"&gt;&lt;/div&gt;<br/>      &lt;/div&gt;';</pre>
<p>First, you should remove the preceding code and add the following code to the same location:</p>
<pre>$file_display = '<br/>  &lt;div class="wpqpa-file-item" id="PF'.$file_row-&gt;id.'" data-file-id="'.$file_row-&gt;id.'" &gt;<br/>    &lt;div class="wpqpa-file-item-row" &gt;<br/>      &lt;div class="wpqpa-file-item-name wpqpa-files-list-name" &gt;'.$file_row-&gt;file_name.'&lt;/div&gt;<br/>      &lt;div class="wpqpa-file-item-download" &gt;&lt;a href="'.$url.'" &gt;'.__("Download","wpqpa").'&lt;/a&gt;          &lt;/div&gt;<br/>      &lt;div class="wpqpa-clear"&gt;&lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="wpqpa-clear"&gt;&lt;/div&gt;<br/>  &lt;/div&gt;';<br/><br/><strong>$file_display = apply_filters('wpqpa_post_attachment_list_item', $file_display, $file_row);</strong><br/>$display .= $file_display;</pre>
<p>Instead of directly adding each file HTML code to the <kbd>$display</kbd> variable, we use a custom filter called <kbd>wpqpa_post_attachment_list_item</kbd> with file details passed as a parameter. This filter allows us to modify the HTML for each file before it's delivered to the browser.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding an action hook for counting downloads</h1>
                </header>
            
            <article>
                
<p>In the preceding section, we looked at the process of using filter hooks to extend plugins. We can also use action hooks to extend plugins through addons. The process of counting downloads should be initialized just after the user clicks the <span class="packt_screen">Download</span> link and before the file download popup is shown on the browser. So, we need an action hook within those two events. Let's modify the <kbd>wpqpa_file_attachment_download</kbd> function to include a new action, as shown in the following code:</p>
<pre>$file_mime_type = mime_content_type( $file_dir );<br/>if( $file_mime_type != '' ){ <br/>  <strong>do_action('wpqpa_before_download_post_attachment',$attachments[0]);</strong> <br/>  header( 'Cache-Control: public' );<br/>  header( 'Content-Description: File Transfer' );</pre>
<p>The highlighted line shows the modifications added to the existing code. This action allows us to implement additional features before the file is sent to the browser as a download. Now, we have the necessary hooks to create the addon and implement the features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the attachments addon</h1>
                </header>
            
            <article>
                
<p>As usual, we have to start by creating a plugin directory with a main plugin file, and inserting the header comments to define it as a plugin. We are not going to repeat the code in this section. You can find a directory and files for attachments addon inside the <kbd>wpquick-attachments-addon</kbd> directory in source codes. We are going to start the development by restricting the PDF files to users with a subscriber role. Let's implement the <kbd>wpqpa_post_attachment_list_item</kbd> filter we added in the previous section:</p>
<pre>add_filter( 'wpqpa_post_attachment_list_item', 'wpqaa_post_attachment_list_item' , 10 ,2 );<br/>function wpqaa_post_attachment_list_item( $display, $file_data ){<br/> $upload_dir = wp_upload_dir();<br/> $file_dir = $upload_dir['basedir'] . $file_data-&gt;file_path;<br/> $file_mime_type = mime_content_type( $file_dir );<br/><br/> if($file_mime_type == 'application/pdf'){<br/>   if( !is_user_logged_in() || ( is_user_logged_in() &amp;&amp; current_user_can('subscriber') ) ){<br/>     $display = '';<br/>   }<br/> }<br/> return $display;<br/>}</pre>
<p><span><span>Here's what this code does</span>:</span></p>
<ol>
<li>The callback function has two parameters, with the first one being the HTML for displaying the file link and the second one being the details about the file from database. </li>
<li>First, we construct the path of the file by using the WordPress <kbd>wp_upload_dir</kbd> function and file path captured from our custom table.</li>
<li>Then, we use the PHP <kbd>mime_content_type</kbd> function to get the MIME type of the attachment.</li>
</ol>
<ol start="4">
<li>Next, we filter the files with the MIME type for PDF.</li>
<li>Then, we use the condition to check whether the file should be displayed to the user. The first part of the condition checks if we are logged into the site, as the file needs to be restricted for guest users. The second part of the condition checks if the user is logged in as a subscriber.</li>
<li>We restrict the file by emptying the content when one of these conditions is met. </li>
</ol>
<p>Now, we have implemented one of the addon features using a filter hook. Next, we can implement our second requirement for counting downloads using an action hook. Let's implement the custom <kbd>wpqpa_before_download_post_attachment</kbd> action using the following code:</p>
<pre>add_action( 'wpqpa_before_download_post_attachment', 'wpqaa_before_download_post_attachment' );<br/>function wpqaa_before_download_post_attachment( $data ){<br/> $post_id = $data['post_id'];<br/> if( is_user_logged_in() ){<br/>   $count = get_post_meta( $post_id, 'wpqaa_member_download_count',true );<br/>   update_post_meta( $post_id, 'wpqaa_member_download_count', $count + 1);<br/> }else{<br/>   $count = get_post_meta( $post_id, 'wpqaa_guest_download_count', true );<br/>   update_post_meta( $post_id, 'wpqaa_guest_download_count', $count + 1 );<br/> }<br/>}</pre>
<p>First, we define the action with a callback function, <kbd>wpqaa_before_download_post_attachment</kbd>. The attachment data received from the <kbd>wp_wpqpa_post_attachments</kbd> table is passed as an array type parameter to this function. We use a conditional check to filter the logged in users and guest users. Our requirement is to count the total downloads for attachments of a single file. So, we can use the <kbd>wp_postmeta</kbd> table to store the download count.</p>
<div class="packt_tip">In actual implementations, we may need to count the downloads for individual attachments, instead of the total count for all attachments in a post. In such a scenario, we can't use the <kbd>wp_postmeta</kbd> table as we can only store data based on post ID. So, we need to have an additional column in the <kbd>wp_wpqpa_post_attachments</kbd> table to keep and display the download counts for each attachment.</div>
<p>We can get the existing download count for a post using the <kbd>get_post_meta</kbd> function. Here, we use two keys called <kbd>wpqaa_member_download_count</kbd> and <kbd>wpqaa_guest_download_count</kbd> to separate the counts for guests and members. Later, we can use these keys to display the counts along with files.</p>
<p>In just a few lines of code, we have an addon that adds functionality to the core plugin and works independently. <span>So, developing addons for any plugin is simple.</span> However, the core plugin needs to provide the correct actions and filters, as well as developers being capable of finding the appropriate hooks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The WordPress action execution process</h1>
                </header>
            
            <article>
                
<p>Up to this point, we used some of the built-in actions and filters, while explaining the practical uses. However, you might be still trying to grab the concept, as it's not a practice used in pure PHP development. The process gets even tougher when coping with the lack of knowledge in the action execution process.</p>
<p><strong>What is the action execution process?</strong></p>
<p>WordPress has a set of built-in actions that are executed within the loading process of each and every request. Each of these actions has a sepcific responsibility in the loading process. The actions used for the loading process are executed in a predefined sequence. However, The WordPress Codex specially mentions that we shouldn't rely entirely on the loading process as it can vary based on the other components in the site.</p>
<div class="packt_infobox">This list may show only the first time each action is called, and in many cases no function is hooked to the action. Themes and plugins can cause actions to be called multiple times and at differing times during a request. This list should be viewed as a guideline or approximation of the WordPress action execution order, and not a concrete specification.</div>
<p>Implementing features using these actions without considering the sequence can often lead to conflicts. In WordPress, execution of these actions in the admin page requests differs from a typical page request. So, we have to be aware of both the frontend action execution process as well as the backend action execution process.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The frontend action execution process</h1>
                </header>
            
            <article>
                
<p>The frontend action execution process starts with the <kbd>muplugins_loaded</kbd> action, which fires after the must-use and network-activated plugins are completed loading. The process completes by executing the <kbd>shutdown</kbd> action. There are 40+ actions called in a typical request, where some of them have higher importance in the development tasks. However, some of these actions change based on the request, and hence we can only use this as guidance. Let's take a look at the following illustration to understand the general actions and the order of execution:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="assets/e884d276-47f6-45a3-904e-77b432fd9e53.png"/></div>
<p class="mce-root"/>
<p>Let's understand the illustration of the loading process. The process begins with the <kbd>muplugins_loaded</kbd> action and moves downwards until it reaches the <kbd>admin_bar_init</kbd> action. Then, it starts from the <kbd>add_admin_bar_menus</kbd> action in the second column and moves downward, and so on. We have highlighted some of the actions used frequently in development. You can learn more about the action execution process at <a href="https://codex.wordpress.org/Plugin_API/Action_Reference">https://codex.wordpress.org/Plugin_API/Action_Reference</a>. The order of execution of these actions is very important in custom development, especially when we use the built-in global objects of WordPress.</p>
<p>First, we are going to create a new plugin called <strong>WPQAL Action Loading</strong>, to test the functionality when loading specific actions. The process of creating the plugin is same as the one used in previous occurrences. Therefore, you can check the source codes directory of this chapter to find the implementation for the WPQAL Action Loading plugin. Let's use the preceding illustration and some practical usage scenarios to understand the importance of proper use of actions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scenario 1 – Using parent plugin features</h1>
                </header>
            
            <article>
                
<p>This is commonly used in addon development, as we rely on the features of the main plugin. In addon development, we have to use constants, functions, classes, global objects from the main plugin. Unless we use the proper WordPress actions, these features may not be accessible within the addon. Assume that we have an addon plugin that gets loaded before the parent plugin. We can think of the <strong>WPQPA Post Attachments</strong> plugin as the main plugin and WPQAL Action Loading as the addon plugin to check this scenario. The WPQPA Post Attachments plugin is loaded after WPQAL Action Loading plugin. So, we can add the following line of code to main file of WPQAL Action Loading plugin and check the output by refreshing the browser:</p>
<pre>echo WPQPA_PLUGIN_URL;exit;</pre>
<p>This is the constant used to define the plugin path of the <strong>WPQPA Post Attachments</strong> plugin and hence it should print the actual path to the browser. Instead, the output will be <kbd>WPQPA_PLUGIN_URL</kbd>, as string. The problem is we are trying to access a constant not defined when we are trying to access it. So, we need to access such constants, functions, variables when all plugins have completed the loading process. We can refer to the image and find an action called <kbd>plugins_loaded</kbd>. This action is executed after WordPress has completed loading all active plugins. So, let's take a look at the proper implementation of the preceding code to print the plugin path:</p>
<pre>add_action( 'plugins_loaded', 'wpqal_plugins_loaded_action' );<br/>function wpqal_plugins_loaded_action() {<br/>  echo WPQPA_PLUGIN_URL;<br/>}</pre>
<p>Now, you should see the correct plugin path printed to the browser. You can uncomment the code for <em>Scenario 1</em> in the WPQAL Action Loading plugin to test the scenario. <span>To access features from other plugins, we must use <kbd>plugins_loaded</kbd> or a later action.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scenario 2 – Accessing the WordPress post object</h1>
                </header>
            
            <article>
                
<p>Usually, we can use the WordPress global <kbd>$post</kbd> object in the post details page to get the necessary information about a post. Let's assume we want to get the ID of the loaded post within a plugin function to execute some tasks. Let's use the <kbd>init</kbd> action to print the post ID to the browser while accessing an individual post:</p>
<pre>add_action( 'init', 'wpqal_init_action' );<br/>function wpqal_init_action() {<br/>  global $post;<br/>  print_r($post-&gt;ID);exit;<br/>}</pre>
<p>We expect the post ID to be printed on the browser. However, we will get an empty output as the <kbd>$post</kbd> object is not loaded at this stage. So, we have to use an action executed later in the loading process. The global <kbd>$post</kbd> object is only accessible in the <kbd>wp</kbd> action and the actions executed afterward. Use the following code to test the process:</p>
<pre>add_action( 'wp', 'wpqal_wp_action' );<br/>function wpqal_wp_action() {<br/>  global $post;<br/>  print_r($post-&gt;ID);exit;<br/>}</pre>
<p>Now, you can see the ID printed to the browser. You can also test the process by using the actions between <kbd>init</kbd> and <kbd>wp</kbd> in the loading process.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scenario 3 – Accessing the WordPress query object</h1>
                </header>
            
            <article>
                
<p>WordPress executes many database queries in the process of loading a certain post, page or screen. In development, we might need to access the details of the query such as query variables, conditions, and even the complete <kbd>sql</kbd> query generated from WordPress functions. So, we use the global <kbd>$wp_query</kbd> variable to access query details as well as make necessary modifications before execution.</p>
<p>Let's try to access the <kbd>$wp_query</kbd> variable using the <kbd>pre_get_posts</kbd> action that gets executed after the query variable object is created:</p>
<pre>add_action( 'pre_get_posts', 'wpqal_pre_get_posts_action' );<br/>function wpqal_pre_get_posts_action( $query ) {<br/>  global $wp_query;<br/>  print_r($wp_query); <br/>}</pre>
<p class="mceNonEditable"><span>Once the post is refreshed, you will see the details of the</span> <kbd>$wp_query</kbd> <span>variable with some parameters. But, most of the query conditions and queries are not set at this stage. Even though the query variable object is created, the actual query is not executed at this stage. This action allows us to make the modifications to the query using the</span> <kbd>$query</kbd> <span>variable passed to the function. Let's use an action executed later in the process to check the</span> <kbd>$wp_query</kbd> <span>details using following code:</span></p>
<pre>add_action( 'wp', 'wpqal_wp_action' );<br/>function wpqal_wp_action() {<br/>  global $wp_query;<br/>  print_r($wp_query); <br/>}</pre>
<p>Now, you will see the complete <kbd>$wp_query</kbd> variable with all the query parameters, conditions, and actual SQL queries.</p>
<p>As we experienced in these three scenarios, the action loading process plays a major role in development. We need to use the proper action hooks to access built-in WordPress variables as well as execute certain core WordPress functions. The method of identifying which hook to be used for certain features may not be straightforward. You can define the necessary actions and print the details to the browser without using the <kbd>exit</kbd> statements. Then you will see the action execution process and which action is responsible for handling each WordPress built-in variable and method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The backend action execution process</h1>
                </header>
            
            <article>
                
<p>The backend action execution process starts with the <kbd>muplugins_loaded</kbd> action, which fires after the must-use and network-activated plugins are completed loading. The process completes by executing the <kbd>wp_dashboard_setup</kbd> action, instead of the <kbd>shutdown</kbd> action.</p>
<p class="mce-root"/>
<p>There are six more actions in the backend execution process, compared to the frontend process. Let's take a look at the following image to understand the actions and the order of execution:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-324 image-border" src="assets/8b306c8f-5feb-4493-906f-7deec60a6311.png" style="width:87.83em;height:47.50em;"/><br/></div>
<p>As you can see, the initial part of the loading process is similar to the frontend process. Then, we see some admin-related actions executed for menus, styles, and header sections. So, you can use the same technique we used earlier to understand the execution of each action, its responsibility, and when we should use them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to use the priority of actions and filters</h1>
                </header>
            
            <article>
                
<p>We learned the action loading process and how it should be used to grab the proper data and execute the core features. However, developers may still get into trouble, even after knowing the loading process. This is due to the priority of executing actions. As we discussed, these actions can be executed multiple times within a request by WordPress core, theme, as well as other plugins. So, the same action hook will be implemented with different priorities. Consider the following code for using the <kbd>pre_get_posts</kbd> action:</p>
<pre>function wpqal_pre_get_posts_action1( $query ) {<br/>  if ( !is_admin() &amp;&amp; $query-&gt;is_main_query() ) {<br/>    if ($query-&gt;is_search) {<br/>      $query-&gt;set('post_type', 'post');<br/>    }<br/>  }<br/>}<br/>add_action( 'pre_get_posts', 'wpqal_pre_get_posts_action1' );<br/><br/>function wpqal_pre_get_posts_action2( $query ) {<br/>  if ( !is_admin() &amp;&amp; $query-&gt;is_main_query() ) {<br/>    if ($query-&gt;is_search) {<br/>      $query-&gt;set('post_type', array( 'post', 'product' ) );<br/>    }<br/>  }<br/>}<br/>add_action( 'pre_get_posts', 'wpqal_pre_get_posts_action2', 20 );</pre>
<p>In the first part, we use the <kbd>pre_get_posts</kbd> action to call the <kbd>wpqal_pre_get_posts_action1</kbd> function and restrict site search to only posts. However, another plugin executes the same action with higher priority number of 20 and changes the searchable post types to both posts and products. So, our implementation doesn't work as expected. So, it's important to consider the action loading process as well as priority when working on a site with many plugins. Before implementing a critical hook, you should check the use of the same hook in other plugins of the site and make sure to use the correct priority to avoid conflicts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Identifying the extendable features of third-party plugins</h1>
                </header>
            
            <article>
                
<p>As we already discovered in the <em>Creating addons for plugins</em> section, not all plugins are extendable. Even within extendable plugins, we have a low to high degree of extendibility in features. So, identifying the extendable features is not an easy task, especially when working with advanced plugins such as WooCommerce, BuddyPress, and bbPress.</p>
<p>In <a href="94db5df8-bbb4-4e75-ae88-fa38a9aabe05.xhtml" target="_blank">Chapter 3</a>, <em>Designing Flexible Frontends with Theme Development</em>, we identified the extendable features of a theme by searching for built-in actions and filters. We can use the same process for plugins, unless each and every hook in the plugin is documented on the plugin site. Let's take a quick look at the extendable features of the popular WooCommerce plugin. Use the code editor to search actions and filters within the WooCommerce directory.</p>
<p class="mce-root"/>
<p>We are using WooCommerce 3.4.4 version, and we get 849 action executions and 1,553 filter executions. So, this means we have over 2,000 locations where we can customize the WooCommerce plugin. In the process of customization, we have to find the necessary hooks with the support of documentation, checking the code files and experiences shared by other developers in development communities such as StackOverflow.</p>
<p>The availability of hooks differentiates from one plugin to another. Sometimes, we find plugins with a limited amount of hooks and popular plugins with thousands of hooks. So, you have to master the process of identifying the hook and how it impacts the plugin to be successful in customizing any plugin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customizing third-party plugins</h1>
                </header>
            
            <article>
                
<p>As developers, we prefer building our own solutions compared to using third-party solutions. The main reason for building our own solutions is to gain more control over the features as well as future enhancements. However, the main purpose of using WordPress is to develop rapid low-cost solutions with the use of existing features. It's obvious that you have to work on customizing third-patty plugins at some point in your development career. These third-party plugins are developed to provide standard solutions to common problems. Therefore, these plugins won't fit into the complete requirements of most sites. Often, we have to adapt these plugins by adding, changing, or removing features. In this section, we are going to look at the techniques and implementation of plugin customization using sample scenarios.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Techniques for customizing third-party plugins</h1>
                </header>
            
            <article>
                
<p>As with themes, plugins consists of various types of common customization's. Most site owners and developers misunderstand the meaning of plugin customization. Often, they think of it as a process that completely changes the plugin to suit the needs of your site. However, we may only need a few style changes as the customization. Sometime,s we have quicker and simple ways to customize plugins compared to using advanced processes. So, it's important to understand the different types of customization's and techniques for implementing them. Let's go through some of the common types of customization's.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customizing look and feel using styles</h1>
                </header>
            
            <article>
                
<p>This is one of the frequently used customization's where you need all plugins to match the styles of the theme. We have three ways of applying style customization's for a plugin:</p>
<ul>
<li><strong>Using theme styles files</strong>: We can add the styles to the <kbd>style.cs</kbd> file of theme theme and override the plugin styles. This method should be only used in the child theme, when there are minor style changes to the plugin.</li>
<li><strong>Using a custom CSS plugin</strong>: There are many existing CSS plugins that allows us to add dynamic custom styles to various parts of the site without needing to create CSS files. These plugins provide a settings section, where we can add the dynamic CSS to be stored in the database and loaded to the site. This technique can be used for minor style customizations of many plugins.</li>
<li><strong>Using an addon plugin</strong>: This is the recommended method to keep the styles changes independent from other plugins. In this method, we have to create a simple addon plugin and include a new CSS file. Then, we can override the plugin styles by using new styles for the same CSS classes. We have to use the dependency parameter of the <kbd>wp_register_style</kbd> function to include the plugin CSS file as a dependency, and load our CSS file after loading the plugin CSS file.</li>
</ul>
<p>These are the common methods for changing the look and feel of a plugin. However, some plugins may provide you with a setting to add a dynamic plugin-specific CSS or settings to adjust the styles of different parts by modifying values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customizing the features with hooks</h1>
                </header>
            
            <article>
                
<p>In the beginning of this chapter, we have seen that the execution of hooks isn't always trivial. WordPress is using hooks all over the place, and this can sometimes make things complex. However, in plugin customization, this solution helps a lot, and we will see the benefit of using such a solution. </p>
<p>We may have to use different plugins every day. So, it's impossible to learn each and every feature of the plugins we us on different projects. Instead, we can look for files or classes that implement the customized feature. Then, we can search for possible hooks that supports our customization. Once the necessary hooks are found, we implement them based on the guidelines. Implementing a hook makes sure that the complete process for the feature is executed. If hooks were not available, we have to go through complete plugin files and classes to identify the location for the customization's. Also, we have to go through follow-up code to check if it affects our customization or possible future modifications.</p>
<p>Let's consider an example from a popular WooCommerce plugin. Assume we want to execute certain code after the user completes product payment. So, we can just search for a payment success hook and its implementation. WooCommerce executes the <kbd>woocommerce_payment_complete</kbd> action after the payment. Therefore, we can implement it using the following code to execute any kind of custom code on completion of the payment:</p>
<pre>add_action( 'woocommerce_payment_complete', 'wpaql_payment_complete' );<br/>function wpaql_payment_complete( $order_id ){<br/>  // Custom code<br/>}</pre>
<p>As you can see, within few lines of code, we have customized WooCommerce without spending too much time or getting in-depth knowledge of WooCommerce. Let's assume there are no such hooks in WooCommerce. In such a case, first we have to find the <kbd>WC_Order</kbd> class and the <kbd>payment_complete</kbd> function used to handle the payment process. Then, we have to go through each and every line of code within the <kbd>payment_complete</kbd> function to understand the location for the completion of payment. You can already see the difficulty in the second process compared to the method of using hooks. So, we should always look for possible hooks to customize the plugins. There are two types of feature customization's in plugin development:</p>
<ul>
<li><strong>Customizing existing features</strong>: Sometimes, we want to change or remove the existing features of a plugin. In such cases, we can implement an existing hook and change existing data or settings using the parameters passed to the function. Sometimes, we may want to go one step further by completely changing a feature with our own implementation. In such a case, we can remove the existing hook using the built-in <kbd>remove_action</kbd> or <kbd>remove_filter</kbd> functions. Then, we add the same hook with our own implementation.</li>
<li><strong>Adding new features</strong>: In customization's, a high percentage of tasks are involved in adding new features, compared to modifying existing features. In this method, we implement the existing hooks similar to the previous section. However, we use our own code and add new features on top of existing features, rather than modifying the existing ones.</li>
</ul>
<p>We discussed different types of customization's in plugins. In the next section, we are going to customize a plugin by implementing a real-world requirement.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the WooCommerce product file manager</h1>
                </header>
            
            <article>
                
<p>The process of changing or adding a new feature using hooks is the most common type of customization for third-party plugins. These hooks allow us to build advanced features without spending much time. In this section, we are going to implement a real-world use case to understand the hook-based customization process in detail. So, we have chosen to customize WooCommerce.</p>
<div class="packt_infobox">Assume we want to provide files related to each WooCommerce product. These files may contain product specifications, user guides, or any information related to the product. So, we need a way to upload these files while creating or editing a product. Then, we have to list them in the frontend product page as a separate tab. This might seem like an uphill task for developers not familiar with WooCommerce. However, the implementation is quite simple once we find out the necessary WooCommerce hooks. Also, another purpose of this implementation is to reuse the code from the post attachments plugin and learn the use of AJAX, instead of normal form submissions.</div>
<p>Let's start the implementation by creating a new plugin called <strong>WQWPF Product Files</strong> with the same process. You can find the plugin files inside the source codes directory for this chapter. Consider the initial code for the plugin:</p>
<pre>register_activation_hook( __FILE__, 'wqwpf_activate' );<br/>function wqwpf_activate(){<br/>  global $wpdb,$wp_roles;<br/>  $table_product_files = $wpdb-&gt;prefix . 'wqwpf_product_files';<br/>$sql_product_files = "CREATE TABLE IF NOT EXISTS $table_product_files (<br/>      id int(11) NOT NULL AUTO_INCREMENT,<br/>      user_id int(11) NOT NULL,<br/>      post_id int(11) NOT NULL,<br/>      file_path longtext NOT NULL,<br/>      updated_at datetime NOT NULL,<br/>      uploaded_file_name varchar(255) NOT NULL,<br/>      PRIMARY KEY (id)<br/>    );";<br/>  require_once( ABSPATH . 'wp-admin/includes/upgrade.php' );<br/>  dbDelta( $sql_product_files );<br/>}<br/><br/>if ( ! defined( 'WQWPF_PLUGIN_DIR' ) ) {<br/>  define( 'WQWPF_PLUGIN_DIR', plugin_dir_path( __FILE__ ) );<br/>}<br/>if ( ! defined( 'WQWPF_PLUGIN_URL' ) ) {<br/>  define( 'WQWPF_PLUGIN_URL', plugin_dir_url( __FILE__ ) );<br/>}<br/><br/>add_action( 'plugins_loaded', 'wqwpf_plugins_loaded_action' );<br/>function wqwpf_plugins_loaded_action() {<br/>  if( class_exists('WooCommerce')){<br/>    // All actions and filters need to be added here<br/>  }<br/>}</pre>
<p>The initial part of the code is similar to the code we used in WPQPA Post Attachments plugin, with the exception of removing the <kbd>file_name</kbd> column from the custom table for product files. This will be an addon for WooCommerce and hence we need to check whether WooCommerce is activated before executing any addon functions. Therefore, we use the <kbd>plugins_loaded</kbd> action to check the availability of <kbd>WooCommerce</kbd> class. We can use constants, classes, or functions to check the availability of a core plugin. When <kbd>WooCommerce</kbd> class is available, we add all the actions and filters related to the addon, so that they are executed only when <kbd>WooCommerce</kbd> is available. Now, we can start building the required functionalities for customization.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the file upload field to WooCommerce products</h1>
                </header>
            
            <article>
                
<p>The first step in the development process is to provide an interface to let administrators upload files to products. We can implement this by using the metabox technique we used while building the post attachments plugin. However, we are trying to understand plugin customization and hence we are going to integrate this feature into WooCommerce. In the WooCommerce product creation screen, we can find a meta box called <span class="packt_screen">Product Data</span> with various tabs such as <span class="packt_screen">General</span>, <span class="packt_screen">Inventory</span>, <span class="packt_screen">Shipping</span> and so on. We are going to add a new tab to the meta box as <span class="packt_screen">Product Files</span>. First, we have to look for actions or filters that let us modify the <span class="packt_screen">Product Data</span> tabs. You can find a filter called <kbd>woocommerce_product_data_tabs</kbd> for customizing the tabs. Let's use the following code to add a new tab using this filter:</p>
<pre>add_filter( 'woocommerce_product_data_tabs', 'wqwpf_custom_product_tabs' );<br/>function wqwpf_custom_product_tabs( $tabs ) {<br/>  $tabs['wqwpf_files'] = array(<br/>        'label'     =&gt; __( 'Product Files', 'wqwpf' ),<br/>        'target'    =&gt; 'wqwpf_file_options',<br/>        'class'     =&gt; array( 'show_if_simple' ),<br/>    );<br/>  return $tabs;<br/>}</pre>
<p>This filter is dependent on WooCommerce and hence the <kbd>add_filter</kbd> line should be placed inside the <kbd>wqwpf_plugins_loaded_action</kbd> function. The existing tabs are passed as a parameter to the callback function of this filter. We add a new tab with a unique key and assign the necessary options. The <kbd>target</kbd> setting contains the ID of the HTML element that is used to display the content for this tab. The tab content will be added in next stage. The <kbd>class</kbd> setting defines an array of classes assigned to this tab. Here, we have used <kbd>show_if_simple</kbd> as the class. So, our tab will be only visible for Simple WooCommerce products. We need to add more classes in case we want to make the tab available for other product types.</p>
<div class="packt_tip">In this scenario, we added a new tab. We can also use this filter to remove existing tabs by using the <kbd>unset</kbd> function on <kbd>$tab</kbd> array elements, or change the settings of existing tabs by using the proper array key.</div>
<p>The next step is adding a file field to the tab for uploading files. We can find another action hook called <kbd>woocommerce_product_data_panels</kbd> for adding tab content. Let's use it to add the file field, as shown in the following code:</p>
<pre>function wqwpf_product_files_panel_content() {<br/>  global $post;    ?&gt;<br/><br/>  &lt;div id='wqwpf_file_options' class='panel woocommerce_options_panel'&gt;<br/>    &lt;div class='options_group'&gt;<br/>      &lt;div id="wqwpf-product-files-msg"&gt;&lt;/div&gt;<br/>      &lt;p class="form-field _wqwpf_product_files_field show_if_simple" style="display: block;"&gt;<br/>       &lt;label for="_wqwpf_product_files"&gt;&lt;?php _e('Product Files','wqwpf'); ?&gt;&lt;/label&gt;<br/>       &lt;input type="file" name="wqwpf_product_files" id="wqwpf_product_files" /&gt;<br/>       &lt;input type="hidden" id="wqwpf_product_file_nonce" name="wqwpf_product_file_nonce" /&gt;<br/>       &lt;input type="button" name="wqwpf_product_file_upload" id="wqwpf_product_file_upload"  value="&lt;?php echo __('Upload','wqwpf'); ?&gt;" /&gt;<br/>     &lt;/p&gt;<br/>   &lt;/div&gt;<br/>  &lt;/div&gt;<br/>    &lt;?php<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">In this code, we have added a file field to upload files, a button to initialize the upload process, and a hidden field to keep the nonce value. The structure of the HTML is copied from the other available tabs. The most important part is understanding how this tab content connects with the tab we created earlier. We have used <kbd>wqwpf_file_options</kbd> as the ID of the main container for the tab. We used the same ID as the <kbd>target</kbd> setting for our new tab. So, once the tab is clicked, WooCommerce will use the target setting to find the container and display it to the user. The following screen previews the new tab after using the custom code:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="assets/5feef139-31d1-42b0-bfe8-cc388e892f0d.png"/></div>
<p>The new tab for <span class="packt_screen">Product Files</span> is added between the <span class="packt_screen">Inventory</span> and <span class="packt_screen">Shipping</span> tabs. Now, we are ready to start uploading files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding scripts for uploading files</h1>
                </header>
            
            <article>
                
<p>In <a href="6bc0e5d5-b12d-4710-ac11-a600af054efa.xhtml" target="_blank">Chapter 4</a>, <em>Building Custom Modules with Plugin Development</em>, we created a plugin to upload attachments to posts. However, we had to select a file and upload files one by one while updating the post for each file. This is not ideal in situations where we have many files to be uploaded. Instead, we have to use AJAX and let the user upload multiple files without refreshing the browser. Before moving into the process of uploading files, we need to add the necessary scripts to the plugin. First, you have to create a new directory inside <kbd>wpquick-woo-product-files</kbd> as <kbd>js</kbd>, and create a new file called <kbd>wqwpf-admin.js</kbd>. Next, we can add the script to the plugins, as shown in the following code:</p>
<pre>add_action( 'admin_enqueue_scripts', 'wqwpf_admin_load_scripts',9 );<br/>function wqwpf_admin_load_scripts(){   <br/>  wp_register_script( 'wqwpf_admin_js', WQWPF_PLUGIN_URL . 'js/wqwpf-admin.js', array('jquery') );<br/>  wp_enqueue_script( 'wqwpf_admin_js' );<br/>  $custom_js_strings = array(       <br/>        'AdminAjax' =&gt; admin_url('admin-ajax.php'),<br/>        'Messages' =&gt; array('fileRequired' =&gt; __('File is required.','wqwpf') ),<br/>        'nonce' =&gt; wp_create_nonce('wqwpf-private-admin'),<br/>    );<br/>  wp_localize_script( 'wqwpf_admin_js', 'WQWPFAdmin', $custom_js_strings );<br/>}</pre>
<p>We can use the preceding code to learn some of the important techniques in script loading. Let's list the important parts of script loading:</p>
<ul>
<li><strong>Registering and enqueuing scripts</strong>: Until this point, we only learned how to include CSS files. So, we can now move onto loading scripts with the <kbd>wp_register_script</kbd> function. Here, we are including a script in admin side and hence we have to use the <kbd>admin_enqueue_scripts</kbd> action to use a callback function for including scripts. The first line of the preceding code should be placed inside the <kbd>wqwpf_plugins_loaded_action</kbd> function, as it depends on the existence of WooCommerce. Inside the callback function, we can use the <kbd>wp_register_script</kbd> function to register a custom script for WordPress. The parameters of this function include a unique key for the script, a path to the script, and dependent script files. The script is only registered at this stage and not included in the browser. Then, we use <kbd>wp_enqueue_script</kbd> wherever we want to include the script to the browser using the key used in script registration.</li>
<li><strong>Defining script dependencies</strong>: We can define dependent scripts using the third parameter of the <kbd>wp_register_script</kbd> function. In this scenario, our script is coded using <strong>jQuery</strong>, and hence it's a dependency. So, we add jQuery as the key to dependency array. WordPress has a set of built-in scripts with specific keys. We need to use these keys without loading these libraries from our own plugins or external sources. The list of available script libraries can be found at <a href="https://developer.wordpress.org/reference/functions/wp_register_script#core-registered-scripts">https://developer.wordpress.org/reference/functions/wp_register_script#core-registered-scripts</a>. You can use the key in the <span class="packt_screen">Handle</span> column to load these dependencies. Once we define <kbd>script 2</kbd> as a dependency of <kbd>script 1</kbd>, the second script will be loaded before the first script. Apart from using core script files, we can also use custom script files as dependencies. Consider the following line of code:In this code, we are registering a script of another plugin with <strong>jQuery</strong> and <kbd>wpwpf_admin_js</kbd> scripts. So, both of these files will be loaded before loading the script with <kbd>upme_admin_js</kbd> as the handle.</li>
</ul>
<p class="mce-root"/>
<pre><span>      wp_register_script( 'upme_admin_js', WQWPF_PLUGIN_URL . 'js/<br/>      wqwpf-admin.js',   <br/>      array('jquery','wqwpf_admin_js') );   </span></pre>
<ul>
<li><strong>Localizing scripts</strong>: Sometimes, we need to add necessary settings and dynamic data to specific scripts. WordPress allows us to add such data by using the <kbd>wp_localize_script</kbd> function. This function uses three parameters, starting with script handle, variable name, and the data. Once used, these data will be added inline to the browser, before loading the script file. Therefore, these data will be accessible within the specified script and the other scripts loaded after that defined script.</li>
</ul>
<p>In this implementation, we are going to use AJAX, and hence we add the AJAX url to the script by using the <kbd>admin_url('admin-ajax.php')</kbd> function. More about AJAX will be discussed later in this section. Next, we add the necessary data using preferred array keys. Here, we are only adding messages as an array. We also add a nonce value to the script to verify the AJAX request from the server side. Once the page is loaded, you can use <span class="packt_screen">View Source</span> option to check this data loaded before the <kbd>wqwpf_admin_js</kbd> script. Now, we have completed the script loading process and hence we can move into uploading product files.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uploading files to products</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to upload files for products using AJAX requests. Before diving into AJAX, we need to complete the initial script with necessary data retrieval and validation. Add the following code to the <kbd>wqwpf-admin.js</kbd> file of our plugin:</p>
<pre>jQuery(document).ready( function( $ ) {<br/>  $('#wqwpf_product_file_upload').click(function(e){<br/>      e.preventDefault();<br/>      var file_form = $('#post');<br/>      var file = file_form.find('#wqwpf_product_files').val();<br/>      var post_id = $('#post_ID').val();<br/>      var msg_container = file_form.find('#wqwpf-product-files-msg");<br/>      msg_container.removeClass('wqwpf-message-info-error').removeClass('wqwpf-message-info-success');<br/><br/>      var err = 0;<br/>      var err_msg = '';<br/>      if(file == '' ){<br/>        err_msg += '' + WQWPFAdmin.Messages.fileRequired + '&lt;br/&gt;';<br/>        err++;<br/>      }<br/>      if(err != 0){<br/>        msg_container.html(err_msg).addClass('wqwpf-message-info-error').show();<br/>      }else{<br/>          // AJAX request for uploading files <br/>      }<br/>    });<br/>});</pre>
<p><span>Here's what this code does:</span></p>
<ol>
<li>First, we define a callback function for the <kbd>click</kbd> event of the <span class="packt_screen">Upload</span> button, within the jQuery <kbd>ready</kbd> function.</li>
<li>Inside the <kbd>click</kbd> event, we need to capture the file and the post ID. We can't add our own form as the metabox is inside the WordPress form for creating posts. So, we use the form with the ID <strong>post</strong>, to capture the values of form fields.</li>
<li>Next, we retrieve the container element used to display messages and reset the CSS classes.</li>
<li>Then, we start the validation process for fields. Here, we have only filed field and hence checking for empty value is the only required validation.</li>
<li>Finally, we check for any errors and display the error message by adding the necessary CSS classes and enabling the message container. </li>
</ol>
<p>In the previous section, we used the <kbd>wp_localize_script</kbd> function to add the data to the scripts. In this section, we are using it to add the error message using the following line:</p>
<pre>WQWPFAdmin.Messages.fileRequired</pre>
<p>In this line, <kbd>WQWPFAdmin</kbd> is the variable name we used earlier and <kbd>Messages</kbd> is the sub-key of the main array. The <kbd>fileRequired</kbd> option in the <kbd>Messages</kbd> array will contain the actual message. Similarly, we can access the other data using respective keys. Now, we need to implement the AJAX request when the validation is completed without errors. Before that, we are going to have a brief introduction to AJAX.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to AJAX in WordPress</h1>
                </header>
            
            <article>
                
<p>AJAX is an abbreviation for Asynchronous JavaScript And XML. This technology allows us to sent and retrieve data without refreshing the browser. So, the execution of repetitive tasks such as multiple file uploading can be simplified by using AJAX. Usually, we use a direct URL to execute AJAX requests. However, WordPress offers a built-in interface for executing AJAX requests and it's recommended to use this technique without using our own AJAX handlers.</p>
<p>WordPress uses a file called <kbd>admin-ajax.php</kbd> for handling requests, and the file is located inside the <kbd>wp-admin</kbd> directory. This file contains the necessary code for built-in core AJAX requests as well as code for supporting custom requests through <em>actions</em>. The action is responsible for handling the AJAX request and providing the output. Let's consider the following code:</p>
<pre>add_action( 'wp_ajax_sample_action', 'wqwpf_sample_action' );<br/>add_action( 'wp_ajax_nopriv_sample_action', ' wqwpf_sample_action ' );<br/>function wqwpf_sample_action(){<br/>  // Get data from client side request, process and return the output<br/>}</pre>
<p>The preceding code defines how we should use AJAX in WordPress. Each different AJAX request has an action name. We have to use the <kbd>wp_ajax_{action name}</kbd> or <kbd>wp_ajax_nopriv_{action name}</kbd> action to define the handling function for each request. The action with the <kbd>wp_ajax</kbd> prefix is used for requests when the user is already logged into the site. The action with <kbd>wp_ajax_nopriv</kbd> is used for guest users of the site. So, you have to define one or both of these actions depending on who is allowed to execute the request.</p>
<p>Now, we have the basic knowledge about AJAX in WordPress and the method for handling the request from the server side. So, we can get back to the file uploading process by implementing the AJAX call to upload files. The following code should be added to the <kbd>else</kbd> statement of the <kbd>click</kbd> event in the <kbd>wqwpf-admin.js</kbd> file:</p>
<pre>msg_container.html('').hide();<br/>var formObj = file_form;<br/>var formURL = WQWPFAdmin.AdminAjax+'?action=wqwpf_save_product_files';<br/>var formData = new FormData();<br/>var file_data = $('#wqwpf_product_files').prop('files')[0];  <br/><br/>formData.append('post_id', post_id);      <br/>formData.append('file_nonce', WQWPFAdmin.nonce);<br/>formData.append('file_data', file_data);<br/>jQuery.ajax({<br/>  url: formURL,<br/>  type: 'POST',<br/>  data:  formData,<br/>  mimeType:'multipart/form-data',<br/>  contentType: false,<br/>  cache: false,<br/>  dataType : 'json',<br/>  processData:false,<br/>  success: function(data, textStatus, jqXHR){<br/><br/>    if(data.status == 'success'){<br/>      msg_container.html(data.msg).removeClass('wqwpf-message-info-error').addClass('wqwpf-message-info-success').show();<br/>      $('#wqwpf-files-container').html(data.files);                                         file_form.find('#wqwpf_product_files').val('');<br/>    }else if(data.status == 'error'){<br/>      msg_container.html(data.msg).removeClass('wqwpf-message-info-success').addClass('wqwpf-message-info-error').show();<br/>    }<br/>  }<br/>});</pre>
<p><span>Here's what this code does:</span></p>
<ol>
<li>The first two lines resets message container and assigns form object to a variable.</li>
<li>Then, we use the <kbd>WQWPFAdmin</kbd> variable to retrieve the WordPress AJAX URL and assign a custom parameter called action with a custom action name. This action name will be used with the <kbd>wp_ajax</kbd> and <kbd>wp_ajax_nopriv</kbd> actions to connect the client-side request with the server side.</li>
<li>Next, we create a new <kbd>FormData</kbd> object to sent the data to the server. We can assign the necessary data to the <kbd>FormData</kbd> object by using the <kbd>append</kbd> function with key-value pairs. Here, we have added a file, nonce value, and post ID as form data.</li>
<li>The next step is configuring the AJAX request with the jQuery <kbd>ajax</kbd> <span>function. You should be familiar with the settings of the AJAX function. Now, the request is executed from client side whenever the user clicks the</span> <span class="packt_screen">Upload</span> <span>button.</span></li>
<li><span>Finally, we use the success event of the</span> <kbd>ajax</kbd> <span>function to display the resulting message, reset the fields, and display a list of files uploaded to the product.</span></li>
</ol>
<p>Now, we can complete the process by handling the server-side function for uploads. Let's consider the following implementation with WordPress AJAX actions:</p>
<pre>add_action( 'wp_ajax_wqwpf_save_product_files','wqwpf_save_product_files');<br/>function wqwpf_save_product_files(){<br/>  global $wpdb;<br/>  $file_nonce   = isset( $_POST['file_nonce'] ) ? ( $_POST['file_nonce'] ) : '';           <br/>  $post_id = isset( $_POST['post_id'] ) ? (int) ( $_POST['post_id'] ) : 0;   <br/>  $user_id    = get_current_user_id();  <br/>  <br/>  if(check_ajax_referer( 'wqwpf-private-admin', 'file_nonce',false )){               $result_upload = wqwpf_process_file_upload();<br/>    if( isset( $result_upload['status'] ) &amp;&amp; $result_upload['status'] == 'success' ){<br/>      $file_date = date("Y-m-d H:i:s");   <br/>      $uploaded_file_name = $result_upload['base_name']; <br/>      $wqwpf_product_files_table = "{$wpdb-&gt;prefix}wqwpf_product_files";<br/>      $wpdb-&gt;insert(<br/>              $wqwpf_product_files_table,<br/>              array(<br/>                  'user_id'           =&gt; $user_id,<br/>                  'post_id'           =&gt; $post_id,<br/>                  'file_path'         =&gt; $result_upload['relative_file_path'],<br/>                  'updated_at'        =&gt; $file_date, <br/>'uploaded_file_name' =&gt; $uploaded_file_name,<br/>              ),<br/>              array( '%d','%d','%s', '%s','%s' ) );<br/>        $files_list = wqwpf_product_file_list( $post_id ); <br/>        $result = array( 'status' =&gt; 'success', 'msg' =&gt; $result_upload['msg'] , 'files' =&gt; $files_list );<br/>    }else{<br/>      $result = array( 'status' =&gt; 'error', 'msg' =&gt; $result_upload['msg'] );<br/>    }<br/>  }else{<br/>    $result = array( 'status' =&gt; 'error', 'msg' =&gt; __('Invalid file upload request.','wqwpf') );<br/>  }<br/>  echo json_encode($result);exit;<br/>}</pre>
<p>Only administrators are allowed to upload files to products, and hence we only use the action with the <kbd>wp_ajax</kbd> prefix for logged-in users. <span>Here's what this code does</span><span>:</span></p>
<ol>
<li>First, we have to capture the <kbd>POST</kbd> request data for post ID and nonce.</li>
<li>Then, we use the <kbd>check_ajax_referer</kbd> function to check the nonce values. The first parameter of this function uses the action we defined inside the <kbd>wqwpf_admin_load_scripts</kbd> function by calling the <kbd>wp_create_nonce</kbd> function. The second and third parameters are used respectively for the nonce value key in the POST request and whether to <kbd>die</kbd> if nonce is invalid. We have set the third parameter as <kbd>false</kbd> since we want to display a custom error.</li>
</ol>
<div class="packt_tip packt_infobox"><span>Once nonce is verified, we use the </span><kbd>wqwpf_process_file_upload</kbd><span> function to upload the files and get the results. The </span><kbd>wqwpf_process_file_upload</kbd><span> function is similar to the function we used in the post attachments plugin, and hence you can check the source code for this chapter to go through the implementation.</span></div>
<ol start="3">
<li><span>Then, we save the file details to the custom table, similar to the post attachments plugin. Then, we retrieve the HTML with the list of uploaded files using the</span> <span><kbd>wqwpf_product_file_list</kbd> function. The implementation of this function is similar to the one we used in post attachments plugin in <a href="6bc0e5d5-b12d-4710-ac11-a600af054efa.xhtml" target="_blank">Chapter 4</a>, <em>Building Custom Modules with Plugin Development</em>. Therefore, we are not going to include and discuss the source code. You can find the implementation of this function within the source codes for this chapter. </span></li>
<li><span>Finally,</span><span> we return the output as a JSON-encoded array with a message, status, and the HTML for the list of uploaded files.</span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying uploaded files in products</h1>
                </header>
            
            <article>
                
<p>In the last section, we displayed the list of files in the product edit screen and updated it each time we uploaded a new file using AJAX. Now, we need to complete the implementation by displaying the files list in the frontend product page as a new tab. We already used a common function to generate the list of files for a product, and hence it's just a matter of using it within a product page tab. Let's use the following code to display the file list:</p>
<pre>add_filter( 'woocommerce_product_tabs', 'wqwpf_product_files_tab' );<br/>function wqwpf_product_files_tab( $tabs ) {<br/>  $tabs['wqwpf_tab'] = array(<br/>    'title' =&gt; __( 'Product Files', 'wqwpf' ),<br/>    'priority' =&gt; 50,<br/>    'callback' =&gt; 'wqwpf_product_files_tab_content'<br/> );<br/> return $tabs;<br/>}<br/><br/>function wqwpf_product_files_tab_content() {<br/> global $post;<br/> echo wqwpf_product_file_list( $post-&gt;ID );<br/>}</pre>
<p>WooCommerce provides a filter called <kbd>woocommerce_product_tabs</kbd> to add, modify, or remove tabs from the frontend product page. The existing tab details are passed as a parameter to this function. So, we add a new tab by using a unique key and assigning necessary settings. We have used a <strong>Title</strong> for the tab and custom callback function called <kbd>wqwpf_product_files_tab_content</kbd>. The <strong>priority</strong> setting defines the order of the tab within the product page. You can check the priority of existing tabs by executing a <kbd>var_dump</kbd> on the <kbd>$tabs</kbd> array and assigning the priority based on where you want to display the tab. Inside the callback function, we use the global <kbd>$post</kbd> object to retrieve the post ID and pass it to the <kbd>wqwpf_product_file_list</kbd> function to generate the files list.</p>
<p>Now, we have completed the customization and added a new feature for uploading and displaying files for WooCommerce products. The product page will look similar to the following screen with the product files tab:</p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-325 image-border" src="assets/5b437d1d-51c9-49eb-9541-a0ae7bd9ec59.png" style="width:78.83em;height:48.08em;"/></div>
<p>In this chapter, we have omitted the code and explanation for file downloading, uploading, and listing, as we used the same functions of the post attachments plugin, with minor modification. Make sure to check the implementation of these functions within the source code for this chapter.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating multiple plugins for a continuous workflow</h1>
                </header>
            
            <article>
                
<p>The purpose of building plugins is to provide independent feature or set of features as a reusable module. So, most third-party plugins are designed to provide solutions to a specific feature and related sub-features. We rarely find third-party plugins that can power an entire system. BuddyPress is one of the few plugins that offers many of the features of a complete system such as a social network. In the previous section, we discussed the need for customizing third-party plugins. Here, we have to move one step further by understanding how to customize and integrate multiple plugins.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Types of plugin integrations</h1>
                </header>
            
            <article>
                
<p>We can integrate two plugins or more using the WordPress hook system. However, there are different types of integrations depending on who is responsible for providing the integration. It's important to understand these integration types in order avoid or control the risks, when the integrated plugins change behavior. Let's take a look at the types of plugin integrations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom integrations</h1>
                </header>
            
            <article>
                
<p>This method is used when there are no integrations between the two plugins. Therefore, each plugin is not aware of the existence of other plugin. This is the most common scenario in WordPress development, as we rarely find the necessary plugins integrating with the other plugins needed for our site. In such a scenario, we have to create an addon plugin by implementing the integrations with necessary plugins. In this process, we use the existing hooks or functions of the necessary plugins and connect them to work together for our requirements.</p>
<p>There is a major limitation in this method as connecting more and more plugins increases the risks of breaking the site functionality. We have no control over the integrated plugins as they are developed by third-party developers. So, when implementing such integrations, we have to use the same plugin versions without updating, or be prepared to check the integration and apply necessary fixes on updates of each plugin. You will see many sites using custom integrations with fixed versions of the integrated plugins. This is not the ideal process as keeping fixed versions of plugins increases security risks. Therefore, you should develop integrations with minimum dependency with each plugin, and be prepared to alter the integration when necessary to be compatible with plugin updates.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">One-sided integrations</h1>
                </header>
            
            <article>
                
<p>In this method, one of the two plugins provides an integration with the other plugin. However, the second plugin is not aware of the existence or integration of the first plugin. We can find many existing plugins with this type of integration. The integration is implemented within one of the plugins or an addon of the plugin. Let's take a look at some of the popular plugins with one-sided integrations with other plugins:</p>
<ul>
<li><strong>MyCred integration with WooCommerce</strong>: MyCred is a point management system for WordPress and integrates with WooCommerce through the <strong>Gateway</strong> addon. The MyCred team is responsible for providing the integration and hence they will make sure the integration works with WooCommerce version updates. You can find more details about the integration at <a href="https://mycred.me/add-ons/gateway/">https://mycred.me/add-ons/gateway/</a>.<a href="https://mycred.me/add-ons/gateway/"/></li>
<li><strong>Easy Digital Downloads integration with Gravity Forms</strong>: Easy Digital Downloads is a plugin used to sell digital products. This plugin integrates with the popular <strong>Gravity Forms</strong> plugin through an addon called <strong>Gravity Forms checkout</strong>. The Easy Digital Downloads team is responsible for providing the integration and hence they will make sure the integration works with Gravity Forms version updates. You can find more details about the integration at <a href="https://easydigitaldownloads.com/downloads/gravity-forms-checkout/">https://easydigitaldownloads.com/downloads/gravity-forms-checkout/</a>.<a href="https://easydigitaldownloads.com/downloads/gravity-forms-checkout/"/></li>
<li><strong>User Profiles Made Easy integration with WooCommerce</strong>: User Profiles Made Easy is a frontend profile management system and provides a built-in integration with WooCommerce. In the previous two examples, integration was provided by a separate addon. In this scenario, integration is built into the plugin. The User Profiles Made Easy team is responsible for providing the integration, and hence they will make sure the integration works with WooCommerce version updates. You can find more details about the integration at <a href="https://codecanyon.net/item/user-profiles-made-easy-wordpress-plugin/4109874">https://codecanyon.net/item/user-profiles-made-easy-wordpress-plugin/4109874</a>.<a href="https://codecanyon.net/item/user-profiles-made-easy-wordpress-plugin/4109874"/></li>
</ul>
<p>As developers, we can use these kind of existing integrations with minor modifications. So, we can spend less time and avoid any risks compared to custom integration method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mutual integrations</h1>
                </header>
            
            <article>
                
<p>In this method, integration is supported by both plugins. Therefore, both plugins are aware of the existence and integration of the other plugin. Usually, this is implemented through functions or APIs designed for the other plugins. The developers from both plugins agrees to keep the features in way that integrates with the other plugin. As developers, we can directly use these integrations as the functionality is tested by both plugins. The risk of such integrations is quite low and requires less time.</p>
<p>We looked at three common methods for integrations. We rarely find plugins with mutual integrations as it requires lot of effort from the developers of the two plugins. So, when a need for integration occurs, we have to check the availability of one-sided integrations, mainly through addons. You should always use the available integrations as they are used and tested by many users of that plugin. In scenarios where we can't find existing integrations, we have to use the custom integration process. In the custom integration process, we have to plan the solutions by reducing the impact on both plugins.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Considerations in custom plugin integrations</h1>
                </header>
            
            <article>
                
<p>The process of integrating plugins can be as simple as a few lines of code or as complex as thousands of lines of code. There are no recommended processes or techniques for integrating plugins. We have to find ways to connect plugins without affecting the other features or breaking the functionality on version upgrades. Let's take a look at some of the important things to be considered in the custom integration process.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking the feasibility of integration</h1>
                </header>
            
            <article>
                
<p>This is the first step, where we explore the available hooks for integration. In the <em>Creating addons</em> section, we identified the limitations of the post attachments plugin due to lack of actions and filters. We might face similar situations in plugins integration, where the second plugin doesn't provide necessary hooks to integrate with the features of the first plugin. In such a case, our only option is to add custom hooks to one of the plugins. Even though it's not recommended and difficult to manage, developers use this method when there are no other alternatives.</p>
<p>Assume that we use a frontend login plugin, and a content restriction plugin with a private page for each user. By default, the login plugin redirects the user to the backend profile after login. So, our integration requires us to redirect the user to the private page after login. We need to have at least one hook in the login plugin for modifying the redirection. Let's assume we have the following filter in the login plugin to change the redirection URL:</p>
<pre>$login_redirect = apply_filters('wpquick_login_redirect_url', $default_url);</pre>
<p>Then, we can use the following code in the content restriction plugin to modify the URL and integrate the two plugins:</p>
<pre>add_filter('wpquick_login_redirect_url','wpquick_content_restriction_redirect_url',10);<br/>function wpquick_content_restriction_redirect_url($url){<br/>  $url = "URL of private page";<br/>  return $url;<br/>}</pre>
<p>The integration was possible due to the availability of the login redirect hook. So, we have to make sure necessary hooks exists and integration is feasible between two plugins.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Identifying exact data changes and hooks</h1>
                </header>
            
            <article>
                
<p>In the integration process, usually we use the data from the first plugin in the second plugin or execute a certain feature of the second plugin when an event occurred in first plugin. The main problem is the consistency and intergrity of data.</p>
<p>Assume that we use a frontend profile management plugin to capture and display the user details using custom fields. We also use WooCommerce to capture payments for the members. Let's say we want to integrate the two plugins to synchronize the user profile data with WooCommerce customer data. So, when updating profile details from the profile management plugin, we need to also update the WooCommerce customer data, and vice-versa. If the two plugins use different data formats for the same field, there is going to be a conflict. In such situations, we have to convert the data when switching between the two plugins.</p>
<p>Also, the use of proper execution of hooks is important in integrations. Assume we have a user registrations plugin and a user groups plugin. The integration requires us to assign the user to a group after the registration process. Usually, we look for a function in the groups plugin that allows us to directly add users to a group by passing the necessary data. Then, we integrate the two plugins by using the registration success hook of the first plugin and executing the add user to group function within the hook. The main integration process works. But, the groups plugin may have other hooks that get executed after adding a user to a group. Such hooks may include features to send emails, assign group permissions, and so on. So, the overall process fails, even though the main integration works without issues. Therefore, it's important to consider all the hooks related to the integration process as well as data formats.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking the impact with other plugins</h1>
                </header>
            
            <article>
                
<p>Usually, we use at least a few plugins in every website, and some sites may contain dozens of plugins. Some of these plugins may have existing integrations between them. Let's assume we need to implement a new feature by integrating two or more plugins. In such scenarios, it's not sufficient to check the data, hooks, and integration points of those two plugins. We have to also check the impact by <span>other existing plugins,</span> or the impact on other existing plugins not involved in the integration.</p>
<p>Let's consider the same scenario discussed in the <em>Checking the feasibility of integrations</em> section. We integrated two plugins to redirect the user to a private page of the content restrictions plugin after login. Assume we have a third plugin not involved in the integration. This plugin is used to change the login redirection URL based on user role. Consider the following integration in the third plugin:</p>
<pre>add_filter('wpquick_login_redirect_url','wpquick_user_role_redirect_url',20);<br/>function wpquick_user_role_redirect_url($url){<br/>  // Get the role of the user being logged in<br/>  if($role == 'subscriber'){<br/>   $url = "Subscriber redirect URL";<br/>  }<br/>  return $url;<br/>}</pre>
<p>The URL modification hook in user role based redirection plugin has a higher priority value, and hence is executed later than the hook used in the previous scenario. Therefore, the logged-in user will be redirected to the user role specific page, instead of the private page of the content restrictions plugin. So, our integration completely falls apart.</p>
<p>We can prevent such issues by considering how other plugins use the data, and the hooks related to our integration process. In this scenario, we could prevent this situation by using a higher priority value for the hook in the first scenario:</p>
<pre>add_filter('wpquick_login_redirect_url','wpquick_content_restriction_redirect_url',30);</pre>
<p>This line of code is executed after the filter code in the role-based redirection plugin, and hence our integration works without issues. However, now you must also check how our integration affects the functionality of the role-based redirection plugin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing multiple plugin integrations</h1>
                </header>
            
            <article>
                
<p>Up to this point, we looked at the methods used in plugin integrations and important considerations. Now, it's time to integrate a few plugins to understand their practical usage. We are going to integrate three popular plugins to illustrate the process. Let's identify the plugins used for this integration and their functionality:</p>
<ul>
<li><strong>WooCommerce</strong>: This is the most popular eCommerce plugin. The main functionality is selling physical and digital goods. These days, it's also being used for selling services, bookings, and memberships by modifying the features through addons.</li>
<li><strong>MyCred</strong>: This is a point management plugin where you can allow users to earn points by doing various tasks in a site such as commenting, viewing content, publishing content, registering on the site, and so on. Then, you can reward these users by providing benefits with the use of these points.</li>
<li><strong>BuddyPress</strong>: This is a plugin used to build online communities in your site. The default features include user management, groups, messages, activities, friends, and notifications. Many people use this plugin to build mini-social networks.</li>
</ul>
<p>Now, we can take a look at the requirement for integrating these three plugins.</p>
<p>Assume that we have a point system in our site using <strong>MyCred</strong>. Users can earn points through various tasks and spend those points to get wide range of benefits. In this scenario, we assume users only get points by purchasing products from the <strong>WooCommerce</strong> store. The points will be given for <em>completed orders</em> based on order value. Once the user reaches a specific number of points, the user will be added automatically to a private <strong>BuddyPress</strong> group.</p>
<p>Before starting the implementation, we need to create a new plugin called <strong>WPQPI Plugin Integrations</strong> in a new plugin directory called <kbd>wpquick-plugin-integrations</kbd>. The process for creating the main file and using header comments to define the plugin will be the same as previous scenarios.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Assigning points for completed orders</h1>
                </header>
            
            <article>
                
<p>We have to start the implementation by connecting WooCommerce and MyCred plugins to award points for completed orders. First, we need to find the ways for tracking the completion of a WooCommerce order. The simplest way is to use a search engine to check the availability of <span class="packt_screen">order complete hook</span>, or go through the documentation of the WooCommerce plugin. We can find an action called <kbd>woocommerce_order_status_completed</kbd> for handling tasks after the completion of order. Let's take a look at the implementation of order complete hook:</p>
<pre>add_action( 'woocommerce_order_status_completed',  'wpqpi_payment_complete' );<br/>public function wpqpi_payment_complete( $order_id ) {<br/>    // Execute code after the order is successfully completed<br/>}</pre>
<p>We can define the action using the <kbd>add_action</kbd> function with a specific callback function. The order ID is passed as a parameter to this function, and hence we can execute any tasks based on order details. The next task is to identify how we can add points in MyCred using custom code.</p>
<p class="mce-root"/>
<p>We have few tasks to be implemented before we can add points to orders. First, we have to add a new hook to enable points for WooCommerce orders. MyCred points are added through built-in and custom hooks. The available hooks can be viewed by visiting the <span class="packt_screen">Points</span> | <span class="packt_screen">Hooks</span> section in WordPress admin. You need to go through the MyCred documentation to find the necessary hooks for adding custom MyCred hooks. So, let's create a new hook for enabling points for WooCommerce orders:</p>
<pre>add_filter( 'mycred_setup_hooks', 'wpqpi_woocommerce_hooks', 10, 2 );<br/>function wpqpi_woocommerce_hooks( $installed, $point_type ) {<br/>  $installed['wpqpi_woo_purchase'] = array('title' =&gt; __( 'Points for WooCommerce Purchases', 'wpqpi' ), 'description'  =&gt; __( 'User will get points for completing product purchases.', 'wpqpi' ), 'callback' =&gt; array( 'WPQPI_WooCommerce_Hooks' ) );<br/>  return $installed;<br/>}</pre>
<p>The <kbd>mycred_setup_hooks</kbd> filter is used to add custom hooks to MyCred, or remove existing hooks. In this scenario, we add a new hook called <kbd>wpqpi_woo_purchase</kbd> for awarding points for WooCommerce purchases. The array defines the name of the hook, the description, and the PHP class to implement the point awarding procedure.</p>
<p>We have added a custom class called <kbd>WPQPI_WooCommerce_Hooks</kbd>. Once this code is added, you will see a new hook named <span class="packt_screen"><span class="packt_screen">Points for WooCommerce</span> Purchases</span> in the <span class="packt_screen">Available Hooks</span> section. You can drag the hook to <span class="packt_screen">Active Hooks</span> section to make it work, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-326 image-border" src="assets/c13b2308-d53a-441c-8f50-aef6df6aa731.png" style="width:73.33em;height:39.67em;"/></p>
<p>The next step is to implement the class to award points for WooCommerce purchases. So, we need to implement the <kbd>mycred_load_hooks</kbd> action to load the hook set up in the previous section. Let's take a look at the implementation of the <kbd>WPQPI_WooCommerce_Hooks</kbd> class inside the <kbd>mycred_load_hooks</kbd> action:</p>
<pre>add_action( 'mycred_load_hooks', 'wpqpi_load_custom_taxonomy_hook', 10 );<br/>function wpqpi_load_custom_taxonomy_hook() {<br/>  class WPQPI_WooCommerce_Hooks extends myCRED_Hook {<br/><br/>    public function __construct( $hook_prefs, $type ) {<br/>      parent::__construct( array(   'id'       =&gt; 'wpqpi_woo_purchase',       'defaults' =&gt; array( 'creds'   =&gt; 1,  'log'     =&gt; '%plural% for purchasing a product' ) ), $hook_prefs, $type );<br/>    }<br/><br/>  }<br/>}</pre>
<p>Inside the hook, we just define the class by extending the <kbd>myCRED_Hook</kbd> core class of MyCred plugin. Then, we add the class constructor with unique ID and default settings. The settings include the number of points awarded by default and the text for the log entry of awarding points. This class executes a built-in function called <kbd>run</kbd>, while loading the hooks. This will be the point of integration where we define the WooCommerce order completed hook. Let's see how we can implement the <kbd>run</kbd> function after the class constructor:</p>
<pre>public function run() {<br/>    add_action( 'woocommerce_order_status_completed', array( $this, 'wpqpi_payment_complete') );<br/>}</pre>
<p>We can define any number of actions in the loading process of the MyCred hook created earlier. Here, we have the <kbd>woocommerce_order_status_completed</kbd> action and the callback function ready to be executed on successful orders. Now, we can move into the process of awarding points by implementing the <kbd>wpqpi_payment_complete</kbd> function, as shown here:</p>
<pre>public function wpqpi_payment_complete( $order_id ) {<br/>    $order = wc_get_order( $order_id );<br/>    $total = $order-&gt;get_total();<br/>    $credits = (int) $total / 10;<br/>    $user = $order-&gt;get_user();<br/>    $user_id = $user-&gt;ID;<br/>    $this-&gt;core-&gt;add_creds( 'wpqpi_woo_purchasing', $user_id, $credits,              $this-&gt;prefs['log'], 0, '', $m  );<br/>}</pre>
<p>First, we use the <kbd>$order_id</kbd> parameter to load the order details using the <kbd>wc_get_order</kbd> function. Next, we get the order total by calling the <kbd>get_total</kbd> function on the <kbd>$order</kbd> object, and divide it by 10 to generate the number of MyCred points for the order. Next, we get the ID of the user who purchased the products by using the <kbd>get_user</kbd> function on the <kbd>$order</kbd> object. Finally, we call the MyCred <kbd>add_creds</kbd> function to add the points to the user for the order.</p>
<p>The <kbd>add_creds</kbd> function has three required parameters and some optional parameters. The first three parameters are used respectively for the reference ID, user ID, and number of points to be awarded. The other parameters are not important for the scenario used in this book. Now, the two plugins are integrated to award MyCred points to the user on successful WooCommerce order completion. We have used an event of one plugin to integrate with another plugin by modifying the data of the second plugin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding users to BuddyPress private groups</h1>
                </header>
            
            <article>
                
<p>In the previous section, we completed the first part of the integration with MyCred and WooCommerce. The next step is to complete the integration by connecting MyCred with BuddyPress groups. As we discussed, the requirement is to assign users to a BuddyPress private group once they reach specific number of MyCred points. So, we have to look for a way to add users to a BuddyPress group. We can either check for the documentation or use a search engine to find the appropriate implementation. BuddPress provides a function called <kbd>groups_join_group</kbd> to add users into a group. Let's use that function to modify the <kbd>wpqpi_payment_complete</kbd> function and add users to groups:</p>
<pre>public function wpqpi_payment_complete( $order_id ) {<br/>    // Existing code for adding MyCred points<br/>    $balance = mycred_get_users_balance( $user_id );<br/>    if($balance &gt; 100){<br/>      groups_join_group(1, $user_id);<br/>    }<br/>}</pre>
<p>First, we use the built-in <kbd>mycred_get_users_balance</kbd> function to receive the available points of the user. Then, we call the BuddyPress <kbd>groups_join_group</kbd> function with the group ID and user ID once the user balance has reached the limit we specified.</p>
<div class="packt_infobox">We have simplified the code in this scenario to illustrate the process of plugin integration. In an ideal scenario, we have to implement a lot more permission checks before we add a user to a group, and points to a user.</div>
<p>In this implementation, we only award points for WooCommerce orders, and the user can only use points to join the group. Therefore, we can implement the points checking process within the same function. When we award points for multiple tasks, this balance checking code needs to be implemented in all of these tasks. </p>
<p>Now, we have completed the integration and made three plugins work together for our requirements. Similarly, you can use existing hooks and functions to connect the necessary plugins for your requirements. However, I strongly recommend not to custom-integrate a large number of plugins in a single site, as it's hard to manage on plugin updates.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>The process of customizing and extending plugins is crucial for building websites in a rapid process. So, we started extending plugins by creating an addon for the post attachments plugin developed in the previous chapter. Next, we looked at the WordPress core action execution process and its importance using sample scenarios. Then, we moved into the process of using various techniques for customizing plugins, while modifying WooCommerce product features. Finally, we looked at the different types of integrations between plugins, while integrating popular plugins to understand the process.</p>
<p>In <a href="e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml" target="_blank">Chapter 6</a>, <em>Practical Usage of WordPress APIs</em>, we will be exploring the built-in WordPress APIs, while learning how to use them practically in plugin development.</p>


            </article>

            
        </section>
    </body></html>