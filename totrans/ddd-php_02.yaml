- en: Architectural Styles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构风格
- en: In order to be able to build complex applications, one of the key requirements
    is having an architectural design that fits the application's needs. One advantage
    of Domain-Driven Design is that it's not tied to any particular architecture style.
    Instead, we're free to choose the architecture that best fits the needs of every
    Bounded Context inside the Core Domain, which offers a diverse set of architectural
    choices for every specific Domain problem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够构建复杂的应用程序，一个关键要求是拥有适合应用程序需求的架构设计。领域驱动设计（Domain-Driven Design）的一个优点是它不依赖于任何特定的架构风格。相反，我们可以自由选择最适合核心领域内每个边界上下文需求的架构。这为每个特定的领域问题提供了多样化的架构选择。
- en: For example, an Order Processing System can use Event Sourcing to track all
    the different order operations; a Product Catalog can use CQRS to expose the product
    details to the different clients; and a Content Management System can use plain
    Hexagonal Architecture to expose requirements such as blogs, static pages, and
    so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个订单处理系统可以使用事件溯源（Event Sourcing）来跟踪所有不同的订单操作；一个产品目录可以使用CQRS（Command Query
    Responsibility Segregation）来向不同的客户端暴露产品详情；一个内容管理系统可以使用纯六边形架构（Hexagonal Architecture）来暴露如博客、静态页面等需求。
- en: This chapter presents an introduction to every relevant architecture style in
    the land of PHP, following the evolution from traditional old school PHP code
    to a more sophisticated architecture. Please note that although there are many
    other existing architecture styles, such as Data Fabric or SOA, we found some
    of them a bit too complex to introduce from the PHP perspective.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了PHP领域所有相关的架构风格，从传统的老式PHP代码到更复杂的架构进行演变。请注意，尽管存在许多其他现有的架构风格，如数据编织或服务导向架构（SOA），但我们发现其中一些从PHP的角度来看过于复杂，难以介绍。
- en: The Good Old Days
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旧时光
- en: 'Before the release of PHP 4, the language didn''t embrace the Object-Oriented
    paradigm. Back then, the usual way of writing applications was by using procedures
    and global state. Concepts like **Separation of Concerns **(**SoC**) and **Model-View-Controller**
    (**MVC**) were alien among the PHP community. The example below is an application
    written in this traditional way, where applications were composed of many front
    controllers mixed with HTML code. During this time, Infrastructure-, Presentation-,
    UI-, and Domain-layer code were all tangled together:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 4发布之前，该语言并没有拥抱面向对象范式。那时，编写应用程序的通常方式是使用过程和全局状态。像**关注点分离（SoC**）和**模型-视图-控制器（MVC**）这样的概念在PHP社区中是陌生的。以下是一个以这种方式编写的应用程序示例，其中应用程序由许多前端控制器与HTML代码混合组成。在这段时间里，基础设施层、表示层、UI层和领域层代码都纠缠在一起：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This style of coding is often referred to as the *Big Ball of Mud* we mentioned
    in the first chapter. An improvement seen in this style, however, was to encapsulate
    the header and the footer of the webpage in their own separate files, which were
    included in the header and footer files. This avoided duplication and favored
    reuse:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程风格通常被称为我们在第一章中提到的*大泥球（Big Ball of Mud*）。然而，在这种风格中看到的一个改进是将网页的页眉和页脚封装在自己的单独文件中，这些文件被包含在页眉和页脚文件中。这避免了重复并促进了重用：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Nowadays, and although it is highly discouraged, there are still applications
    that use this procedural way of coding. The main disadvantage of this style of
    architecture is that there's no real Separation of Concerns — the maintenance
    and cost of evolving an application being developed this way increases drastically
    in relation to other well-known and proven architectures.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尽管这种方法被高度禁止，但仍有一些应用程序使用这种过程式编程方式。这种架构风格的主要缺点是没有真正的关注点分离——以这种方式开发的应用程序在维护和成本方面与其它知名且经过验证的架构相比急剧增加。
- en: Layered Architecture
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分层架构
- en: 'From the code maintainability and reuse perspectives, the best way to make
    this code a bit easier to maintain would be by splitting up concepts, that is
    creating layers for each different concern. In our previous example, it''s easy
    to shape different layers: one to encapsulate the data access and manipulation,
    another one to handle infrastructure concerns, and a final one for encapsulating
    the orchestration of the previous two. An essential rule of Layered Architecture
    — is that each layer must be tightly coupled with the layers beneath it, as shown
    in the following picture:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码的可维护性和重用性角度来看，使这段代码更容易维护的最佳方法是通过分割概念，即为每个不同的关注点创建层。在我们之前的例子中，塑造不同的层很容易：一个用于封装数据访问和处理，另一个用于处理基础设施问题，最后一个用于封装前两个层的编排。分层架构的一个基本规则是，每一层必须与它下面的层紧密耦合，如下面的图片所示：
- en: '![](img/layered-architecture.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![分层架构](img/layered-architecture.png)'
- en: Layered Architecture for SoC
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: SoC的分层架构
- en: What Layered Architecture really seeks is the separation of the different components
    of an application. For instance, in terms of the previous example, a blog post
    representation must be completely independent of a blog post as a conceptual entity.
    A blog post as a conceptual entity can instead be associated with one or more
    representations, as opposed to being tightly coupled to a specific representation.
    This is commonly referred to as Separation of Concerns.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 分层架构真正寻求的是将应用程序的不同组件分离。例如，就之前的例子而言，博客文章的表示必须完全独立于作为概念实体的博客文章。相反，作为概念实体的博客文章可以与一个或多个表示相关联，而不是与特定的表示紧密耦合。这通常被称为关注点分离。
- en: Another architecture paradigm and pattern that seeks the same purpose is the
    Model-View-Controller pattern. It was initially thought of and widely used for
    building desktop GUI applications, and now it's mainly used in web applications,
    thanks to popular web frameworks like Symfony, Zend Framework, and CodeIgniter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个寻求相同目的的架构模式和范例是模型-视图-控制器模式。它最初是为了构建桌面GUI应用程序而构思和广泛使用的，现在它主要应用于Web应用程序，这得益于像Symfony、Zend
    Framework和CodeIgniter这样的流行Web框架。
- en: Model-View-Controller
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-控制器
- en: 'Model-View-Controller is an architectural pattern and paradigm that divides
    the application into three main layers, described in the following points:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图-控制器是一种架构模式和范例，它将应用程序分为三个主要层，以下是一些描述：
- en: '**The Model**: Captures and centralizes all the Domain Model behavior. This
    layer manages all the data, logic, and business rules independently of the data
    representation. It has been said that **the Model layer is the heart and soul
    of every MVC application**.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：捕获并集中所有领域模型的行为。这一层独立于数据表示管理所有数据、逻辑和业务规则。据说**模型层是每个MVC应用程序的核心和灵魂**。'
- en: '**The Controller**: Orchestrates interactions between the other layers, triggers
    actions on the Model in order to update its state, and refreshes the representations
    associated with the Model. Additionally, the Controller can send messages to the
    View layer in order to change the specific Model representation.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：协调其他层之间的交互，触发模型上的操作以更新其状态，并刷新与模型关联的表示。此外，控制器可以向视图层发送消息，以改变特定的模型表示。'
- en: '**The View**: Exposes the differing representations of the Model layer and
    provides a way to trigger changes on the Model''s state.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：展示模型层的不同表示，并提供一种触发模型状态变化的方式。'
- en: '![](img/mvc.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![模型-视图-控制器](img/mvc.png)'
- en: The MVC pattern
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式
- en: Example of Layered Architecture
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分层架构示例
- en: The Model
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型
- en: 'Continuing with the previous example, we mentioned that different concerns
    should be split up. In order to do so, all layers should be identified in our
    original tangled code. Throughout this process, we need to pay special attention
    to the code conforming to the Model layer, which will be the beating heart of
    the application:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上一个例子，我们提到应该将不同的关注点分开。为了做到这一点，我们需要在我们的原始混乱代码中识别出所有层。在整个过程中，我们需要特别注意符合模型层的代码，它将成为应用程序的核心：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The Model layer is now defined by a `Post` class and a `PostRepository` class.
    The `Post` class represents a blog post, and the `PostRepository` class represents
    the whole collection of blog posts available. Additionally, another layer — one
    that coordinates and orchestrates the Domain Model behavior — is needed inside
    the Model. Enter the Application layer:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 模型层现在由 `Post` 类和 `PostRepository` 类定义。`Post` 类代表一篇博客文章，而 `PostRepository` 类代表所有可用的博客文章集合。此外，模型内部还需要另一个层——一个协调和编排领域模型行为的层——那就是应用程序层：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `PostService` class is what is known as an Application Service, and its
    purpose is to orchestrate and organize the Domain behavior. In other words, the
    Application services are the ones that make things happen, and they're the direct
    clients of a Domain Model. No other type of object should be able to directly
    talk to the internal layers of the Model layer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostService` 类被称为应用程序服务，其目的是协调和组织领域行为。换句话说，应用程序服务是使事情发生的服务，它们是领域模型直接客户端。其他类型的对象不应能够直接与模型层的内部层进行通信。'
- en: The View
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: The View is a layer that can both send and receive messages from the Model layer
    and/or from the Controller layer. Its main purpose is to represent the Model to
    the user at the UI level, as well as to refresh the representation in the UI each
    time the Model is updated. Generally speaking, the View layer receives an object
    — often a **Data Transfer Object **(**DTO**) instead of instances of the Model
    layer — thereby gathering all the needed information to be successfully represented.
    For PHP, there are several template engines that can help a great deal in separating
    the Model representation from the Model itself and from the Controller. The most
    popular one by far is called [Twig](http://twig.sensiolabs.org/). Let's see how
    the View layer would look with Twig.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是一个可以发送和接收来自模型层和/或控制器层的消息的层。其主要目的是在用户界面级别代表模型，以及每次模型更新时在用户界面中刷新表示。一般来说，视图层接收一个对象——通常是
    **数据传输对象（DTO**）而不是模型层的实例——从而收集所有需要成功表示的信息。对于PHP，有几个模板引擎可以帮助将模型表示与模型本身和控制器本身分离。最受欢迎的一个叫做
    [Twig](http://twig.sensiolabs.org/)。让我们看看使用 Twig 的视图层将如何看起来。
- en: DTOs Instead of Model Instances?This is an old and active topic. Why create
    a DTO instead of giving an instance of the Model to the View layer? The main reason
    and the short answer is, again, Separation of Concerns. Letting the View inspect
    and use a Model instance leads to tight coupling between the View layer and the
    Model layer. In fact, a change in the Model layer can potentially break all the
    views that make use of the changed Model instances.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: DTOs 而不是模型实例？这是一个老生常谈且活跃的话题。为什么创建一个 DTO 而不是将模型实例提供给视图层？主要原因和简短的回答是，又是关注点的分离。让视图检查和使用模型实例会导致视图层和模型层之间的紧密耦合。实际上，模型层的变化可能会破坏所有使用更改后的模型实例的视图。
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Most of the time, when the Model triggers a state change, it also notifies
    the related Views so that the UI is refreshed. In a typical web scenario, the
    synchronization between the Model and its representations can be a bit tricky
    because of the client-server nature. In these kind of environments, some JavaScript-defined
    interactions are usually needed to maintain that synchronization. For this reason,
    JavaScript MVC frameworks like the ones below have become widely popular in recent
    years:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，当模型触发状态变化时，它也会通知相关的视图，以便刷新用户界面。在典型的网络场景中，由于客户端-服务器性质，模型与其表示之间的同步可能有点棘手。在这些环境中，通常需要一些JavaScript定义的交互来维护这种同步。因此，近年来，像以下这样的JavaScript
    MVC框架变得非常流行：
- en: '[AngularJS](https://angularjs.org/)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[AngularJS](https://angularjs.org/)'
- en: '[Ember.js](http://emberjs.com/)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ember.js](http://emberjs.com/)'
- en: '[Marionette.js](http://marionettejs.com/)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Marionette.js](http://marionettejs.com/)'
- en: '[React](https://facebook.github.io/react/)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[React](https://facebook.github.io/react/)'
- en: The Controller
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: The Controller layer is responsible for organizing and orchestrating the View
    and the Model. It receives messages from the View layer and triggers Model behavior
    in order to perform the desired action. Furthermore, it sends messages to the
    View in order to display Model representations. Both operations are performed
    thanks to the Application layer, which is responsible for orchestrating, organizing,
    and encapsulating Domain behavior.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 控制层负责组织和协调视图和模型。它从视图层接收消息，并触发模型行为以执行所需操作。此外，它向视图发送消息以显示模型表示。这两个操作都得益于应用层，应用层负责协调、组织和封装领域行为。
- en: 'In terms of a web application in PHP, the Controller usually comprehends a
    set of classes, which, in order to fulfill their purpose, "speak HTTP." In other
    words, they receive an HTTP request and return an HTTP response:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP的Web应用程序中，控制器通常包含一组类，为了实现其目的，它们“说HTTP”。换句话说，它们接收HTTP请求并返回HTTP响应：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inverting Dependencies: Hexagonal Architecture'
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反转依赖：六边形架构
- en: Following the essential rule of Layered Architecture, there's a risk when implementing
    Domain interfaces that contain infrastructural concerns.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循分层架构的基本规则，在实现包含基础设施关注点的领域接口时存在风险。
- en: As an example, with MVC, the `PostRepository` class from the previous example
    should be placed in the Domain Model. However, placing infrastructural details
    right in the middle of our Domain violates Separation of Concerns. This can be
    problematic; it's difficult to avoid violating the essential rules of Layered
    Architecture, which leads to a style of code that can become hard to test if the
    Domain layer is aware of technical implementations.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在MVC中，上一个例子中的`PostRepository`类应该放在领域模型中。然而，将基础设施细节直接放在我们的领域中间违反了关注点分离。这可能是个问题；如果领域层知道技术实现，就难以避免违反分层架构的基本规则，这会导致一种代码风格，如果领域层知道技术实现，就难以测试。
- en: The Dependency Inversion Principle (DIP)
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置原则（DIP）
- en: How can we fix this? As the Domain Model layer depends on concrete infrastructure
    implementations, the [Dependency Inversion Principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle),
    or DIP, could be applied by relocating the Infrastructure layer on top of the
    other three layers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？由于领域模型层依赖于具体的基础设施实现，可以通过将基础设施层放置在其他三个层之上来应用依赖倒置原则（[Dependency Inversion
    Principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)），或DIP。
- en: The Dependency Inversion Principle
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: High-level modules should not depend on low-level modules. Both should depend
    on abstractions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 高层模块不应依赖于底层模块。两者都应依赖于抽象。
- en: Abstractions should not depend on details. Details should depend on abstractions.
    *Robert C. Martin*
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象不应依赖于细节。细节应依赖于抽象。*罗伯特·C·马丁*
- en: By using the Dependency Inversion Principle, the architecture schema changes,
    and the Infrastructure layer — which can be referred to as the low-level module
    — now depends on the UI, the Application layer, and the Domain layer, which are
    the high-level modules. The dependency has been inverted.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用依赖倒置原则，架构模式发生变化，基础设施层——可以称为底层模块——现在依赖于UI、应用层和领域层，这些是高层模块。依赖关系已经反转。
- en: But what is Hexagonal Architecture, and how does it fit within all of this?
    Hexagonal Architecture (also known as Ports and Adapters) was defined by Alistair
    Cockburn in his book, [Hexagonal Architecture](http://alistair.cockburn.us/Hexagonal+architecture).
    It depicts the application as a hexagon, where each side represents a Port with
    one or more Adapters. A Port is a connector with a pluggable Adapter that transforms
    an outside input to something the inside application can understand. In terms
    of the DIP, a Port would be a high-level module, and an Adapter would be a low-level
    module. Furthermore, if the application needs to emit a message to the outside,
    it will also use a Port with an Adapter to send it and transform it into something
    that the outside can understand. For this reason, Hexagonal Architecture brings
    up the concept of symmetry in the application, and it's also the main reason why
    the schema of the architecture changes. It's often represented as a hexagon because
    it no longer makes sense to talk about a top layer or a bottom layer. Instead,
    Hexagonal Architecture talks mainly in terms of the outside and the inside.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但什么是六边形架构，它是如何适应所有这些的？六边形架构（也称为端口和适配器）由Alistair Cockburn在他的书中定义，[六边形架构](http://alistair.cockburn.us/Hexagonal+architecture)。它将应用程序描绘成一个六边形，其中每一边代表一个带有一个或多个适配器的端口。端口是一个具有可插拔适配器的连接器，它将外部输入转换为内部应用程序可以理解的东西。在DIP（依赖倒置原则）的术语中，端口将是一个高级模块，而适配器将是一个低级模块。此外，如果应用程序需要向外部发送消息，它也将使用带有适配器的端口来发送并转换成外部可以理解的东西。因此，六边形架构提出了应用程序中的对称概念，这也是架构模式变化的主要原因。它通常被表示为六边形，因为不再有意义讨论顶层或底层。相反，六边形架构主要从外部和内部的角度来讨论。
- en: There are great videos on YouTube by *Matthias Noback* where he talks about
    Hexagonal Architecture. You may want to take a look at one of those for more [detailed
    information](https://www.youtube.com/watch?v=K1EJBmwg9EQ).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: YouTube上有许多由*Matthias Noback*制作的关于六边形架构的优秀视频，他讨论了六边形架构。你可能想看看其中之一以获取更多[详细信息](https://www.youtube.com/watch?v=K1EJBmwg9EQ)。
- en: Applying Hexagonal Architecture
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用六边形架构
- en: 'Continuing with the blog example application, the first concept we need is
    a Port where the outside world can talk to the application. For this case, we''ll
    use an HTTP Port and its corresponding Adapter. The outside will use the Port
    to send messages to the application. The blog example was using a database to
    store the whole collection of blog posts, so in order to allow the application
    to retrieve blog posts from the database, a Port is needed:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用博客示例应用程序，我们需要的第一概念是外部世界可以与应用程序通信的端口。在这种情况下，我们将使用HTTP端口及其相应的适配器。外部将通过端口向应用程序发送消息。博客示例使用数据库来存储整个博客文章集合，因此为了允许应用程序从数据库检索博客文章，需要一个端口：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This interface exposes the Port that the application will retrieve information
    about blog posts through, and it''ll be located in the Domain Layer. Now an Adapter
    for this Port is needed. The Adapter is in charge of defining the way in which
    the blog posts will be retrieved using a specific technology:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口公开了应用程序将通过它检索有关博客文章信息的端口，它将位于域层。现在需要为这个端口创建一个适配器。适配器负责定义使用特定技术检索博客文章的方式：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we have the Port and its Adapter defined, the last step is to refactor
    the `PostService` class so that it uses them. This can be easily achieved by using
    [Dependency Injection](http://www.martinfowler.com/articles/injection.html):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了端口和适配器，最后一步就是重构`PostService`类，使其使用它们。这可以通过使用[依赖注入](http://www.martinfowler.com/articles/injection.html)轻松实现：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is just a simple example of Hexagonal Architecture. It's a flexible architecture
    that promotes Separation of Concerns, like Layered Architecture. It also promotes
    symmetry, due to having an inside application that communicates with the outside
    via ports. From now on, this will be the foundational architecture used to build
    and explain CQRS and Event Sourcing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的六边形架构示例。它是一个灵活的架构，它促进了关注点的分离，就像分层架构一样。它还通过拥有一个与外部通过端口通信的内部应用程序来促进对称性。从现在开始，这将是构建和解释CQRS和事件源的基础架构。
- en: For more examples about this architecture, you can check out the [Appendix](b7e5ae5b-cf31-496b-986e-a6b60e087304.xhtml),
    *Hexagonal Architecture with PHP*. For a more detailed example, you should jump
    to the [Chapter 11](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml), *Application*,
    which explains advanced topics like transactionality and other cross-cutting concerns.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此架构的更多示例，您可以查看[附录](b7e5ae5b-cf31-496b-986e-a6b60e087304.xhtml)，*使用PHP的六边形架构*。对于更详细的示例，您应该跳转到[第11章](145aa94e-d316-4e2b-b18c-1a3555f53e3f.xhtml)，*应用程序*，其中解释了事务性和其他横切关注点等高级主题。
- en: Command Query Responsibility Segregation (CQRS)
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令查询责任分离（Command Query Responsibility Segregation, CQRS）
- en: 'Hexagonal Architecture is a good foundational architecture, but it has some
    limitations. For example, complex UIs can require Aggregate information displayed
    in diverse forms (**[Chapter 8](0641c26d-552b-48f5-aeb7-91c67806c20b.xhtml)**,
    *Aggregates*), or they can require data obtained from multiple Aggregates. And
    in this scenario, we could end up with a lot of finder methods inside the Repositories
    (maybe as many as the UI views which exist within the application). Or, maybe
    we can decide to move this complexity to the Application Services, using complex
    structures to accumulate data from multiple Aggregates. Here''s an example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构是一个良好的基础架构，但它有一些局限性。例如，复杂的UI可能需要以不同形式显示的聚合信息（**[第8章](0641c26d-552b-48f5-aeb7-91c67806c20b.xhtml)**，*聚合*），或者它们可能需要从多个聚合中获得数据。在这种情况下，我们可能会在仓储中拥有大量的查找方法（可能和应用程序中存在的UI视图一样多）。或者，我们可能决定将这种复杂性移至应用程序服务，使用复杂结构从多个聚合中积累数据。以下是一个例子：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When these techniques are abused, the construction of the UI views can become
    really painful. We should evaluate the tradeoff between making Application Services
    return Domain Model instances and returning some kind of DTOs. With the latter
    option, we avoid tight coupling between the Domain Model and Infrastructure code
    (web controllers, CLI controllers, and so on).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些技术被滥用时，UI视图的构建可能会变得非常痛苦。我们应该评估在使应用程序服务返回领域模型实例和返回某种类型的DTO之间的权衡。后者选项可以避免领域模型和基础设施代码（Web控制器、CLI控制器等）之间的紧密耦合。
- en: Luckily, there's another approach. If the problem is having multiple and disparate
    views, we can exclude them from the Domain Model and start treating them as a
    purely infrastructural concern. This option is based on a design principle, the
    **Command Query Separation** (**CQS**). This principle was defined by Bertrand
    Meyer, and, in turn, it gave birth to a new architectural pattern named **Command
    Query Responsibility Segregation** (**CQRS**), as defined by Greg Young.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，还有另一种方法。如果问题是存在多个且不同的视图，我们可以将它们从领域模型中排除，并开始将它们视为纯粹的基础设施关注点。这个选项基于一个设计原则，即**命令查询分离**（Command
    Query Separation, **CQS**）。这个原则由贝特朗·梅耶定义，反过来，它催生了一个新的架构模式，即**命令查询责任分离**（Command
    Query Responsibility Segregation, **CQRS**），由格雷格·杨定义。
- en: Command Query Separation (CQS)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 命令查询分离（Command Query Separation, CQS）
- en: '*Asking a question should not change the answer* - Bertrand Meyer'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*提问不应改变答案* - 贝特朗·梅耶'
- en: This design principle states that every method should be either a command that
    performs an action, or a query that returns data to the caller, but not both, [Wikipedia](https://en.wikipedia.org/wiki/Command%E2%80%93query_separation)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计原则指出，每个方法应该是执行动作的命令，或者返回数据的查询，但不能两者兼而有之，[维基百科](https://en.wikipedia.org/wiki/Command%E2%80%93query_separation)
- en: 'CQRS seeks an even more aggressive Separation of Concerns, splitting the Model
    in two:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS寻求更激进的关注点分离，将模型分为两部分：
- en: 'The **Write Model**: Also known as the **Command Model**, it performs the writes
    and takes responsibility for the true Domain behavior.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写模型**：也称为**命令模型**，执行写入操作并负责真正的领域行为。'
- en: 'The **Read Model**: It takes responsibility of the reads within the application
    and treats them as something that should be out of the Domain Model.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读模型**：负责应用程序内的读取操作，并将它们视为应该从领域模型中分离出来的内容。'
- en: Every time someone triggers a command to the Write Model, this performs the
    write to the desired data store. Additionally, it triggers the Read Model update,
    in order to display the latest changes on the Read Model.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每次有人触发对写模型的命令时，都会执行对所需数据存储的写入操作。此外，它还会触发读模型更新，以便在读模型上显示最新的更改。
- en: 'This strict separation causes another problem: Eventual Consistency. The consistency
    of the Read Model is now subject to the commands performed by the Write Model.
    In other words, the Read Model is eventually consistent. That is, every time the
    Write Model performs a command, it will pull up a process that will be responsible
    for updating the Read Model according to the last updates on the Write Model.
    There''s a window of time where the UI may present stale information to the user.
    In the web scenario, this happens often, as we''re somewhat limited by the current
    technologies.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种严格的分离导致另一个问题：最终一致性。读取模型的一致性现在取决于写模型执行的命令。换句话说，读取模型是最终一致的。也就是说，每次写模型执行命令时，都会启动一个负责根据写模型上的最后更新来更新读取模型的过程。在一段时间内，UI可能会向用户展示过时的信息。在Web场景中，这种情况经常发生，因为我们受到当前技术的限制。
- en: Think about a caching system in front of a web application. Every time the database
    is updated with new information, the data on the cache layer may potentially be
    stale, so every time it gets updated, there should be a process that updates the
    cache system. Cache systems are eventually consistent.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下在Web应用程序前面有一个缓存系统。每次数据库更新新信息时，缓存层上的数据可能已经过时，因此每次更新时，都应该有一个更新缓存系统的过程。缓存系统是最终一致的。
- en: These kinds of processes, speaking in CQRS terminology, are called Write Model
    Projections, or just Projections. We project the Write Model onto the Read Model.
    This process can be synchronous or asynchronous, depending on your needs, and
    it can be done thanks to another useful tactical design pattern — Chapter Domain
    Events — which will be explained in detail later on in the book. The basis of
    the Write Model projections is to gather all the published Domain Events and update
    the Read Model with all the information coming from the events.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的流程，用CQRS术语来说，被称为写模型投影，或简称投影。我们将写模型投影到读取模型上。这个过程可以是同步的或异步的，取决于您的需求，并且可以通过另一个有用的战术设计模式——章节领域事件——来实现，这在本书后面的章节中将详细解释。写模型投影的基础是收集所有发布的领域事件，并使用事件中来的所有信息更新读取模型。
- en: The Write Model
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写模型
- en: 'This is the true holder of Domain behavior. Continuing with our example, the
    Repository interface would be simplified to the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是领域行为的真正持有者。继续我们的例子，仓库接口将被简化为以下内容：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now the `PostRepository` has been freed from all the read concerns except one:
    The `byId` function which is responsible for loading the Aggregate by its ID so
    that we can operate on it. And once this is done, all the query methods are also
    stripped down from the Post model, leaving it only with command methods. This
    means we''ll effectively get rid of all the getter methods and any other methods
    exposing information about the Post Aggregate. Instead, Domain Events will be
    published in order to be able to trigger Write Model projections by subscribing
    to them:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`PostRepository`已经从所有的读取关注点中解放出来，除了一个：`byId`函数，它负责通过ID加载聚合体，以便我们可以对其进行操作。一旦完成这项工作，所有查询方法也从帖子模型中移除，只留下命令方法。这意味着我们将有效地去除所有获取方法以及任何其他暴露帖子聚合体信息的其他方法。相反，将通过发布领域事件来触发，以便能够通过订阅它们来触发写模型投影：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'All actions that trigger a state change are implemented via Domain Events.
    For each Domain Event published, there''s an apply method responsible for reflecting
    the state change:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所有触发状态变化的操作都通过领域事件来实现。对于每个发布的领域事件，都有一个负责反映状态变化的应用方法：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Read Model
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取模型
- en: 'The Read Model, also known as the Query Model, is a pure denormalized data
    model lifted from Domain concerns. In fact, with CQRS, all the read concerns are
    treated as reporting processes, an infrastructure concern. In general, when using
    CQRS, the Read Model is subject to the needs of the UI and how complex the views
    compounding the UI are. In a situation where the Read Model is defined in terms
    of relational databases, the simplest approach would be to set one-to-one relationships
    between database tables and UI views. These database tables and UI views will
    be updated using Write Model projections triggered from the Domain Events published
    by the write side:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 读取模型，也称为查询模型，是一个从领域关注点提升的纯反规范化数据模型。实际上，在 CQRS 中，所有的读取关注点都被视为报告过程，一个基础设施关注点。一般来说，当使用
    CQRS 时，读取模型受 UI 需求和构成 UI 的视图复杂性的影响。在读取模型以关系数据库为定义的情况下，最简单的方法是在数据库表和 UI 视图之间设置一对一的关系。这些数据库表和
    UI 视图将使用从写入端发布的领域事件触发的写入模型投影进行更新：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: An important feature of this architectural style is that the Read Model should
    be completely disposable, since the true state of the application is handled by
    the Write Model. This means the Read Model can be removed and recreated when needed,
    using Write Model projections.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构风格的一个重要特性是读取模型应该是完全可丢弃的，因为应用程序的真实状态由写入模型处理。这意味着读取模型可以在需要时通过写入模型投影进行删除和重建。
- en: 'Here we can see some examples of possible views within a blog application:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到博客应用中可能的一些视图示例：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It''s important to point out that CQRS doesn''t constrain the definition and
    implementation of the Read Model to a relational database. It depends exclusively
    on the needs of the application being built. It could be a relational database,
    a document-oriented database, a key-value store, or whatever best suits the needs
    of your application. Following the blog post application, we''ll use [Elasticsearch](https://en.wikipedia.org/wiki/Elasticsearch) —
    a document-oriented database — to implement a Read Model:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，CQRS 并不限制读取模型的定义和实现必须使用关系数据库。它完全取决于正在构建的应用程序的需求。它可以是关系数据库、面向文档的数据库、键值存储，或者任何最适合您应用程序需求的数据库。在博客应用博客文章之后，我们将使用
    [Elasticsearch](https://en.wikipedia.org/wiki/Elasticsearch) ——一个面向文档的数据库——来实现读取模型：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Read Model code has been drastically simplified to a single query against
    an Elasticsearch index.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 读取模型代码已经被大大简化为对 Elasticsearch 索引的单个查询。
- en: This reveals that the Read Model doesn't really need an object-relational mapper,
    as this might be overkill. However, the Write Model might benefit from the use
    of an object-relational mapper, as this would allow you to organize and structure
    the Read Model according to the needs of the application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明读取模型实际上并不需要一个对象关系映射器，因为这可能是过度设计。然而，写入模型可能从使用对象关系映射器中受益，因为这将允许您根据应用程序的需求组织和结构化读取模型。
- en: Synchronizing the Write Model with the Read Model
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步写入模型与读取模型
- en: Here comes the tricky part. How do we synchronize the Read Model with the Write
    Model? We already said we would do it by using Domain Events captured in a Write
    Model transaction. For each type of Domain Event captured, a specific projection
    will be executed. So a one-to-one relationship between Domain Events and projections
    will be set.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是棘手的部分。我们如何同步读取模型与写入模型？我们之前已经说过，我们将通过使用写入模型事务中捕获的领域事件来实现。对于捕获的每种类型的领域事件，将执行一个特定的投影。因此，领域事件与投影之间将建立一对一的关系。
- en: 'Let''s have a look at an example of configuring projections so that we can
    get a better idea. First of all, we need to define a skeleton for the projections:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看配置投影的一个例子，以便我们更好地理解。首先，我们需要为投影定义一个框架：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So defining an `Elasticsearch` projection for a `PostWasCreated` event would
    be as simple as this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为 `PostWasCreated` 事件定义一个 `Elasticsearch` 投影将像这样简单：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The Projector implementation is a kind of specialized Domain Event listener.
    The main difference between that and the default Domain Event listener is that
    the Projector reacts to a group of Domain Events instead of only one:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 投影器实现是一种专门的领域事件监听器。与默认的领域事件监听器相比，主要区别在于投影器对一组领域事件做出反应，而不仅仅是单个事件：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following code shows how the flow between the projector and the events
    would appear:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了投影器和事件之间的流程：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code is kind of synchronous, but the process can be asynchronous if needed.
    And you could make your customers aware of this out-of-sync data by placing some
    alerts in the view layer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有点同步，但如果需要，过程可以是异步的。您可以通过在视图层放置一些警报来让客户意识到这种不同步的数据。
- en: 'For the next example, we''ll use the `amqplib` PHP extension in combination
    with [ReactPHP](https://github.com/GeniusesOfSymfony/ReactAMQP):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将结合使用`amqplib` PHP扩展和[ReactPHP](https://github.com/GeniusesOfSymfony/ReactAMQP)：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For this to work, we need an asynchronous projector. Here''s a naive implementation
    of that:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这可行，我们需要一个异步投影器。以下是一个简单的实现：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the event consumer on the RabbitMQ exchange would look something like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 并且RabbitMQ交换上的事件消费者看起来可能像这样：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'From now on, it could be as simple as making all the needed Repositories consume
    an instance of the projector and then making them invoke the projection process:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，这可能只需要让所有必要的仓库消费一个投影器实例，然后让它们调用投影过程：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Post` instance and the recorded events are triggered and persisted in the
    same transaction. This ensures that no events are lost, as we'll project them
    to the Read Model if the transaction is successful. As a result, no inconsistencies
    will exist between the Write Model and the Read Model.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Post`实例和记录的事件在同一事务中被触发和持久化。这确保了不会丢失任何事件，因为如果事务成功，我们将它们投影到读取模型。因此，写入模型和读取模型之间不会存在不一致性。'
- en: '**To ORM or Not To ORM  **'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**是使用ORM还是不使用ORM**'
- en: One of the most common questions when implementing CQRS is if an **Object-Relational
    Mapper** (**ORM**) is really needed. We strongly believe that using an ORM for
    the Write Model is perfectly fine and has all of the advantages of using a tool,
    which will help us save a lot of work in case we use a relational database. But
    we shouldn't forget that we still need to persist and retrieve the Write Model's
    state in a relational database.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现CQRS时，最常见的疑问之一是是否真的需要**对象关系映射器（ORM**）。我们坚信，对于写入模型使用ORM是完全可以接受的，并且具有使用工具的所有优点，这将在我们使用关系数据库时帮助我们节省大量工作。但我们不应忘记，我们仍然需要在关系数据库中持久化和检索写入模型的状态。
- en: Event Sourcing
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件溯源
- en: CQRS is a powerful and flexible architecture. There's an added benefit to it
    in regard to gathering and saving the Domain Events (which occurred during an
    Aggregate operation), giving you a high-level degree of detail of what's going
    on within your Domain. Domain Events are one of the key tactical patterns because
    of their significance within the Domain, as they describe past occurrences.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS是一种强大且灵活的架构。它在收集和保存领域事件（在聚合操作期间发生）方面提供了额外的优势，这为您提供了对领域内部发生情况的详细高级度。由于它们在领域中的重要性，领域事件是关键战术模式之一，因为它们描述了过去发生的事情。
- en: '**Be careful with recording too many events**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意不要记录过多的事件**'
- en: An ever-growing number of events is a smell. It might reveal an addiction to
    event recording at the Domain, most likely incentivized by the business. As a
    rule of thumb, remember to keep it simple.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 事件数量不断增长是一个信号。它可能揭示了在领域中对事件记录的依赖，这很可能是由于业务激励的。作为经验法则，请记住保持简单。
- en: By using CQRS, we've been able to record all the relevant events that occurred
    in the Domain Layer. The state of the Domain Model can be represented by reproducing
    the Domain Events we previously recorded. We just need a tool for storing all
    those events in a consistent way. We need an event store.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用CQRS，我们已经能够记录在领域层发生的所有相关事件。领域模型的状态可以通过重现我们之前记录的领域事件来表示。我们只需要一个工具来以一致的方式存储所有这些事件。我们需要一个事件存储库。
- en: The fundamental idea behind Event Sourcing is to express the state of Aggregates
    as a linear sequence of events
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源背后的基本思想是将聚合的状态表示为一系列事件的线性序列
- en: 'With CQRS, we partially achieved the following: The `Post` entity alters its
    state by using Domain Events, but it''s persisted, as explained already, thereby
    mapping the object to a database table.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通过CQRS，我们部分实现了以下目标：`Post`实体通过使用领域事件来改变其状态，但它被持久化，如前所述，因此将对象映射到数据库表。
- en: 'Event Sourcing takes this a step further. If we were using a database table
    to store the state of all the blog posts, another to store the state of all the
    blog post comments, and so on, using Event Sourcing would allow us to use a single
    database table: A single append —  only database table that would store all the
    Domain Events published by all the Aggregates within the Domain Model. Yes, you
    read that correctly. A **single** database table.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源将这一概念进一步发展。如果我们使用数据库表来存储所有博客文章的状态，另一个来存储所有博客文章评论的状态，依此类推，使用事件溯源将允许我们使用单个数据库表：一个单一的追加——只存储域模型内所有聚合体发布的所有域事件的数据库表。是的，你读得对。一个**单一**的数据库表。
- en: 'With this model in mind, tools like object-relational mappers are no longer
    needed. The only tool needed would be a simple database abstraction layer by which
    events can be appended:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型下，不再需要对象关系映射器等工具。所需的唯一工具是一个简单的数据库抽象层，通过它可以追加事件：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now the `Post` Aggregate has a method which, when given a set of events (or,
    in other words, an event stream), is able to replay the state step by step until
    it reaches the current state, all before saving. The next step would be building
    an adapter of the `PostRepository` port that will fetch all the published events
    from the `Post` Aggregate and append them to the data store where all the events
    are appended. This is what we call an event store:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Post`聚合体有一个方法，当给定一组事件（或者说，一个事件流）时，能够逐步回放状态直到达到当前状态，所有这些都在保存之前完成。下一步将是构建一个`PostRepository`端口的适配器，该适配器将从`Post`聚合体中检索所有已发布的事件并将它们附加到所有事件都附加的数据存储中。这就是我们所说的事件存储：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is how the implementation of the `PostRepository` looks when we use an
    event store to save all the events published by the `Post` Aggregate. Now we need
    a way to restore an Aggregate from its events history. A `reconstitute` method
    implemented by the `Post` Aggregate and used to rebuild a blog post state from
    triggered events comes in handy:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用事件存储来保存`Post`聚合体发布的所有事件的`PostRepository`实现方式。现在我们需要一种方法来从其事件历史中恢复聚合体。`Post`聚合体实现了一个`reconstitute`方法，并用于从触发事件中重建博客文章状态，这在实际操作中非常有用：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The event store is the workhorse that carries out all the responsibility in
    regard to saving and restoring event streams. Its public API is composed of two
    simple methods: They are `append` and `getEventsFrom`. The former appends an event
    stream to the event store, and the latter loads event streams to allow Aggregate
    rebuilding.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 事件存储是执行所有与保存和恢复事件流相关的责任的工作马。其公共API由两个简单的方法组成：它们是`append`和`getEventsFrom`。前者将事件流追加到事件存储中，后者加载事件流以允许聚合体重建。
- en: 'We could use a key-value implementation to store all events:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用键值实现来存储所有事件：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This event store implementation is built upon [Redis](http://redis.io), a widely
    used key-value store. The events are appended in a list using the prefix events:
    In addition, before persisting the events, we extract some metadata like the event
    class or the creation date, as it will come in handy later.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件存储实现建立在广泛使用的键值存储[Redis](http://redis.io)之上。事件通过前缀events:附加到列表中。此外，在持久化事件之前，我们会提取一些元数据，如事件类别或创建日期，因为它们在以后会很有用。
- en: Obviously, in terms of performance, it's expensive for an Aggregate to go over
    its full event history to reach its final state all of the time. This is especially
    the case when an event stream has hundreds or even thousands of events. The best
    way to overcome this situation is to take a snapshot from the Aggregate and replay
    only the events in the event stream that occurred after the snapshot was taken.
    A snapshot is just a simple serialized version of the Aggregate state at any given
    moment. It can be based on the number of events of the Aggregate's event stream,
    or it can be time based. With the first approach, a snapshot will be taken every
    *n* triggered events (every 50, 100, or 200 events, for example). With the second
    approach, a snapshot will be taken every *n* seconds.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，从性能角度来看，聚合体每次都要遍历其完整的事件历史以到达最终状态是非常昂贵的。这尤其适用于事件流包含数百甚至数千个事件的情况。克服这种情况的最佳方法是从聚合体中获取快照，并仅重新播放快照之后发生的事件流中的事件。快照只是聚合体在任何给定时刻状态的简单序列化版本。它可以基于聚合体事件流的数量，或者基于时间。在第一种方法中，每*n*个触发事件（例如每50、100或200个事件）将获取一个快照。在第二种方法中，每*n*秒获取一个快照。
- en: 'To follow the example, we''ll use the first way of snapshotting. In the event''s
    metadata, we store an additional field, the version, from which we''ll start replaying
    the Aggregate history:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循示例，我们将使用快照的第一种方式。在事件的元数据中，我们存储一个额外的字段，版本号，我们将从它开始重新播放聚合的历史：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And now we need to refactor the `EventStore` class so that it starts using
    the `SnapshotRepository` to load the Aggregate with acceptable performance times:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要重构`EventStore`类，使其开始使用`SnapshotRepository`以可接受的性能时间加载聚合：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We just need to take Aggregate snapshots periodically. We could do this synchronously
    or asynchronously by a process responsible for monitoring the event store. The
    following code is a simple example demonstrating the implementation of Aggregate
    snapshotting:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要定期进行聚合快照。我们可以通过负责监控事件存储的过程同步或异步地完成这项工作。以下代码是一个简单的示例，展示了聚合快照的实现：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To ORM or Not To ORM
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 是否使用ORM
- en: It's clear from the use case of this architectural style that using an ORM just
    to persist / fetch events would be overkill. Even if we use a relational database
    for storing them, we only need to persist / fetch events from the data store.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从这种架构风格的使用案例中可以看出，仅仅为了持久化/检索事件而使用ORM会过度设计。即使我们使用关系数据库来存储它们，我们也只需要从数据存储中持久化/检索事件。
- en: Wrap-Up
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'As there are plenty of options for architectural styles, you may have gotten
    a bit confused in this chapter. You''ll have to consider the tradeoffs for each
    one of them in order to choose wisely. One thing is clear: the Big Ball of Mud
    approach is not an option, as the code will rot pretty fast. Layered Architecture
    is a better option, but it presents some disadvantages, like tight coupling between
    layers. Arguably, the most balanced option would be Hexagonal Architecture, as
    it can be used as a foundational base architecture, and it promotes a high-level
    degree of decoupling and symmetry between the inside and outside of the application.
    This is what we recommend for most scenarios.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有大量的架构风格选项，你可能会在本章中感到有些困惑。你必须考虑每个选项的权衡，以便明智地选择。有一点是明确的：巨大的泥球方法不是一个选择，因为代码会很快腐烂。分层架构是一个更好的选择，但它有一些缺点，比如层与层之间的紧密耦合。可以说，最平衡的选项是六边形架构，因为它可以用作基础架构，并促进应用内外部的高度解耦和对称。这是我们推荐在大多数场景下的做法。
- en: We've also seen CQRS and Event Sourcing as relatively flexible architectures
    that will help you in fighting serious complexity. CQRS and Event Sourcing both
    have their places, but don't let the *coolness factor* distract you from the value
    they provide. As they both come with some overhead, you should have a technical
    reason for justifying their use. These architectural styles are indeed really
    useful, and the heuristics to start using them can be discovered in the number
    of finders on the Repositories for CQRS and the volume of triggered events for
    Event Sourcing. If the number of finder methods starts growing and Repositories
    become difficult to maintain, then it's time to consider the use of CQRS, in order
    to split read and write concerns. And after that, if the volume of events on each
    Aggregate operation tends to grow and the business is interested in more granular
    information, then an option to consider is whether a move toward Event Sourcing
    might pay off.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了CQRS和事件溯源作为相对灵活的架构，它们将帮助你应对严重的复杂性。CQRS和事件溯源都有它们的位置，但不要让*酷炫因素*分散你对它们提供的价值的注意力。由于它们都带来了一些开销，你应该有一个技术理由来证明它们的使用是合理的。这些架构风格确实非常有用，而开始使用它们的启发式方法可以在CQRS的存储库中的查找器数量和事件溯源触发事件的量中找到。如果查找方法开始增加，并且存储库变得难以维护，那么是时候考虑使用CQRS来分割读/写关注点。然后，如果每个聚合操作的事件量趋于增长，并且业务对更细粒度的信息感兴趣，那么可以考虑的一个选择是转向事件溯源可能会带来回报。
- en: 'Extracted from a paper by Brian Foote and Joseph Yoder:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 摘自布赖恩·福特和约瑟夫·约德的一篇论文：
- en: '*A BIG BALL OF MUD is haphazardly structured, sprawling, sloppy, duct-tape
    and bailing wire,* [spaghetti code jungle](http://www.laputan.org/mud/mud.html#BigBallOfMud).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个巨大的泥球结构混乱、杂乱无章、粘土和铁丝网粘合*，[意大利面代码丛林](http://www.laputan.org/mud/mud.html#BigBallOfMud)。'
