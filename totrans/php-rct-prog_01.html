<html><head></head><body>
<div class="book" title="Chapter&#xA0;1.&#xA0;Introduction to Reactive Programming" id="E9OE1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Introduction to Reactive Programming</h1></div></div></div><p class="calibre8">Reactive programming has become a very popular and in demand topic over the last few years, and even though the ideas behind it aren't new, it takes the good parts from multiple different programming paradigms. This book's purpose is to teach you how to start writing PHP applications with principles of reactive programming in mind and in combination with pre-existing libraries.</p><p class="calibre8">In this chapter, we'll learn the most important principles that will guide us throughout this entire book:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Recap well-known programming paradigms and quickly explain their meaning for humans.</li><li class="listitem">We'll see how we can use functional PHP programming, even today, using practical examples. We pay special attention to how we can use anonymous functions.</li><li class="listitem">Explain what reactive programing is and what good parts it takes from other programming paradigms.</li><li class="listitem">We'll have a look at some examples of widely spread JavaScript and PHP libraries that already use very similar principles to reactive programming.</li><li class="listitem">Introduce Reactive Extensions and see how these fit into the world of reactive programming.</li><li class="listitem">Show what using Reactive Extensions looks like using RxJS and how it fits into the grand scheme of things.</li><li class="listitem">Create a first simple demo with RxPHP library.</li></ul></div><p class="calibre8">Since reactive programming is a programming paradigm, we'll take a quick look at other common paradigms that all of us have probably already heard of and that you'll see mentioned every time you read or hear about reactive programming.</p></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Introduction to Reactive Programming" id="E9OE1-bd355a22cf10407cb10df27e65585b8d">
<div class="book" title="Imperative programming"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec7" class="calibre1"/>Imperative programming</h1></div></div></div><p class="calibre8">Imperative programming is a programming paradigm around executing statements that change the program's state.</p><p class="calibre8">What this means in human language:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre17">Programming paradigm</strong></span>: This is a set of concepts defining a style of building and structuring programs. Most programming languages, such as PHP, support multiple paradigms. We can also think of it as a mindset and a way we approach problems when using such paradigms.</li><li class="listitem"><span class="strong"><strong class="calibre17">Statements</strong></span>: Units of action with side effects in imperative programming evaluated in sequences usually containing expressions. Statements are executed for their side effects and expressions for their return value. Consider this example:<pre class="programlisting">        $a = 2 + 5 
</pre><p class="calibre23">This line of code is a statement where <code class="literal">2 + 5</code> is an expression. The expected side effect is assigning the value <code class="literal">7</code> to the <code class="literal">$a</code> variable. This leads to changing the program's current state. Another statement could be, for instance:</p><pre class="programlisting">        if ($a &gt; 5) { } 
</pre><p class="calibre23">This statement has one expression and no return value.</p></li><li class="listitem"><span class="strong"><strong class="calibre17">State</strong></span>: Values of program variables in memory at any given time. In imperative programming, we define a series of statements that control the program's flow and, therefore, change its state.</li></ul></div></div></div>
<div class="book" title="Declarative programming" id="F8901-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec8" class="calibre1"/>Declarative programming</h1></div></div></div><p class="calibre8">Declarative programming is a paradigm focused on describing a program's logic instead of particular executional steps. In other words, in declarative programming, we define what we want instead of how we want it. In contrast to imperative programming, programs in declarative programming are defined with expressions instead of statements.</p><p class="calibre8">Very common examples could be SQL and HTML languages. Consider the following database query:</p><pre class="programlisting">SELECT * FROM user WHERE id = 42 
</pre><p class="calibre8">In SQL, we define what data from what table we want to query, but the implementation details are completely hidden for us. We don't even want to worry about how the database engine stores or indexes the data.</p><p class="calibre8">In HTML, we define the structure of elements; what's behind the browser's rendering process isn't important for us. We just want to see the page on the screen.</p></div>
<div class="book" title="Sequential and parallel programming" id="G6PI1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec9" class="calibre1"/>Sequential and parallel programming</h1></div></div></div><p class="calibre8">We can think of sequential and parallel programming as counterparts.</p><p class="calibre8">In sequential programming, we're executing processes in order. This means that a process is started when the preceding process has finished. In other words, there is always only one process being executed. The following figure illustrates this principle:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00002.jpeg" alt="Sequential and parallel programming" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">In parallel programming, multiple processes can be executed concurrently:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00003.jpeg" alt="Sequential and parallel programming" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">To make this easier to understand and more relevant to PHP, we can, instead of processes, think of lines of code. PHP interpreter is always sequential and it never executes code in parallel.</p><p class="calibre8">In <a class="calibre1" title="Chapter 9. Multithreaded and Distributed Computing with pthreads and Gearman" href="part0066_split_000.html#1UU542-bd355a22cf10407cb10df27e65585b8d">Chapter 9</a>, <span class="strong"><em class="calibre18">Multithreaded and Distributed Computing with pthreads and Gearman</em></span>, we'll use PHP module pthreads that makes it possible to run PHP code in multiple threads, but we'll see that it's not as simple as it seems. Module pthreads, in fact, creates multiple independent PHP interpreters, each running in a separate thread.</p></div>

<div class="book" title="Asynchronous programming" id="H5A41-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>Asynchronous programming</h1></div></div></div><p class="calibre8">The term asynchronous programming is very common in languages such as JavaScript. A very general definition is that, in asynchronous programming, we're executing code in a different order than it was defined. This is typical for any event based application.</p><p class="calibre8">For example, in JavaScript, we first define an event listener with its handler, which is executed some time later, when an appropriate event occurs.</p><p class="calibre8">In PHP, this could be, for example, a web application that needs to send an e-mail when we create a new blog article. Just, instead of lines of code, we're considering tasks. The following figure demonstrates an asynchronously triggered event:</p><p class="calibre8">
</p><div class="mediaobject"><img src="../images/00004.jpeg" alt="Asynchronous programming" class="calibre19"/></div><p class="calibre20"> </p><p class="calibre8">
</p><p class="calibre8">While the web application was saving an article (processing a task), it triggered an event that sent an e-mail and then carried on with the original task. The event handler had to be defined somewhere before we started this task.</p></div>

<div class="book" title="Asynchronous programming" id="H5A41-bd355a22cf10407cb10df27e65585b8d">
<div class="book" title="Asynchronous versus parallel programming"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch01lvl2sec5" class="calibre1"/>Asynchronous versus parallel programming</h2></div></div></div><p class="calibre8">A very common misconception is that asynchronous and parallel programming are the same, or that one is an implication of the other. This is very common in JavaScript where, from the user's perspective, it looks like things are running in parallel.</p><p class="calibre8">This isn't true, but many programming languages (in fact, just their interpreters), create the illusion of running in parallel while they're still sequential. They appear to be parallel due to it's event-based nature (JavaScript), or because of their interpreter internals.</p><p class="calibre8">For example, Python simulates threads by switching the execution context between different parts of the application. The Python interpreter is still single threaded and executes instructions sequentially, but creates the illusion of running code in parallel.</p></div></div>

<div class="book" title="Functional programming"><div class="book" id="I3QM2-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Functional programming</h1></div></div></div><p class="calibre8">The functional programming paradigm treats program flow as an evaluation of functions. It utilizes several concepts, where the most important for us are eliminating side effects, avoiding mutable data, functions as first-class citizens and higher-order functions. The output of each function is dependent only on its input argument values, therefore, calling the same function twice has to always return the same value. It's based on declarative programming, in the sense of using expressions instead of statements.</p><p class="calibre8">Let's have a deeper look what this means:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre17">Eliminating side effects</strong></span>: While in imperative programming side-effects were desired during program execution, in functional programming it's the exact opposite. Each function is supposed to be an individual building block whose return value is based only on its input values. Note that, in functional programming, it almost never makes sense to define a function that takes no arguments and returns no value. Assuming that functions have no side effects, this means that this function can't do anything (or at least anything observable from the outside). This is in contrast to imperative programming, where using such functions makes sense because they can modify some internal state (of an object for instance). Eliminating side effects leads to more independent and better testable code.</li><li class="listitem"><span class="strong"><strong class="calibre17">Avoiding mutable data</strong></span>: The concept of not modifying any input values and working with their copies works well with not creating any side effects. Executing the same function with the same input parameters will always return the same value.</li><li class="listitem"><span class="strong"><strong class="calibre17">First-class citizens and higher-order functions</strong></span>: In programming languages, stating that type/object/function is a first-class citizen (or first-class element) means that this entity supports operations generally available to all other entities. Usually, this includes:<div class="book"><ul class="itemizedlist1"><li class="listitem">It can be passed as a parameter to functions</li><li class="listitem">It can be returned from a function</li><li class="listitem">It can be assigned to a variable</li></ul></div><p class="calibre23">Higher-order functions have a very similar meaning and have to do at least one of these:</p><div class="book"><ul class="itemizedlist1"><li class="listitem">Take a function as an argument</li><li class="listitem">Return a function as a result</li></ul></div><p class="calibre23">In functional programming, this concept of higher-order function is often used in connection with methods on collections such as <code class="literal">map()</code>, <code class="literal">filter()</code>, <code class="literal">reduce()</code>, <code class="literal">concat()</code>, and <code class="literal">zip()</code>
</p></li></ul></div></div>

<div class="book" title="Functional programming">
<div class="book" title="Functional programming in PHP"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch01lvl2sec6" class="calibre1"/>Functional programming in PHP</h2></div></div></div><p class="calibre8">Let's step aside for a moment and see how the three concepts mentioned above are related to PHP.</p><div class="book" title="Eliminating side effects"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch01lvl3sec0" class="calibre1"/>Eliminating side effects</h3></div></div></div><p class="calibre8">This is mostly a matter of a good programming style and self-discipline. Of course, PHP doesn't restrict us from violating this rule. Note that, by side effects, we also mean use cases like the following:</p><pre class="programlisting">function sum($array) { 
    $sum = 0; 
    foreach ($array as $value) { 
        $sum += $value; 
    } 
    saveToDatabase($sum); 
    return $sum; 
} 
sum([5, 1, 3, 7, 9]); 
</pre><p class="calibre8">Even though we have not defined the function <code class="literal">saveToDatabase()</code> ourselves (for example, it comes from a framework we are using), it's still a side effect. If we execute the same function again, it will return the same value, but the end state is different. For example, it will create the record in the database twice.</p></div><div class="book" title="Avoiding mutable data"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch01lvl3sec1" class="calibre1"/>Avoiding mutable data</h3></div></div></div><p class="calibre8">This concept is simple with primitive data types, for example:</p><pre class="programlisting">function add($first, $second) { 
    return $first + $second; 
} 
add(5, 2); 
</pre><p class="calibre8">However, when working with collections, this principle requires the creation of a new collection and copying values from the old collection to the new one:</p><pre class="programlisting">function greaterThan($collection, $threshold) { 
    $out = []; 
    foreach ($collection as $val) { 
        if ($val &gt; $threshold) { 
            $out[] = $val; 
        } 
    } 
    return $out; 
} 
greaterThan([5, 12, 8, 9, 42], 8); 
// will return: [12, 9, 42] 
</pre><p class="calibre8">The preceding example shows this principle in practice.</p><p class="calibre8">In PHP, arrays are passed by reference for performance reasons until the first attempt to modify them. Then the interpreter will create a copy of the original array behind the scene (so called copy-on-write). However, objects are always passed as references, so we'll have to be very careful when working with them.</p><p class="calibre8">This concept of immutable collections (or objects in general) became very popular in JavaScript with libraries such as <code class="literal">Immutable.js</code>, made by Facebook (<a class="calibre1" href="https://facebook.github.io/immutable-js/">
https://facebook.github.io/immutable-js/
</a>), or the so-called <code class="literal">onPush</code> change detection mechanism in Angular2.</p><p class="calibre8">Apart from making our code more predictable, when it's used appropriately, it will simplify checking for changes in large collections because, if any of its items have changed, then the entire collection is replaced by a new instance.</p><p class="calibre8">In order to check if two collections contain the same data, we can use the identity operator (<code class="literal">===</code> three equal signs) instead of comparing the collections' items one by one.</p><p class="calibre8">In PHP, there are already libraries that make this task easier, for instance, <code class="literal">Immutable.php</code> (<a class="calibre1" href="https://github.com/jkoudys/immutable.php">
https://github.com/jkoudys/immutable.php
</a>). Also, for example, PHP 5.5+ comes with an immutable version of <code class="literal">DateTime</code> class called <code class="literal">DateTimeImmutable</code> by default.</p></div><div class="book" title="First-class citizens and higher-order functions"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch01lvl3sec2" class="calibre1"/>First-class citizens and higher-order functions</h3></div></div></div><p class="calibre8">Now it starts to get interesting. Functions in PHP have been first-class citizens for a very long time already. Moreover, since PHP 5.3+, we can use anonymous functions, which greatly simplifies the usage of higher-order functions.</p><p class="calibre8">Consider a very trivial example that applies a function on every item in a collection with the built-in <code class="literal">array_map()</code> function:</p><pre class="programlisting">$input = ['apple', 'banana', 'orange', 'raspberry']; 
$lengths = array_map(function($item) { 
    return strlen($item); 
}, $input); 
// $lengths = [5, 6, 6, 9]; 
</pre><p class="calibre8">We have used PHP's <code class="literal">array_map()</code> function to iterate the array and return the length of each string. If we consider just this function call, it uses many of the concepts from multiple paradigms that we have explained above:</p><pre class="programlisting">array_map(function($item) { 
    return strlen($item); 
}, $input); 
</pre><p class="calibre8">What this means in particular:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Single expression <code class="literal">strlen($item)</code> and no assignments (declarative programming).</li><li class="listitem">Implementation details on how the array is actually iterated are hidden from us (declarative programming).</li><li class="listitem">First-class citizens and higher-order functions (functional programming).</li><li class="listitem">Immutable data - this function call doesn't change the original, but creates a new array (functional programming).</li><li class="listitem">No side effects - everything happens inside the inner closure. If we used any variables, they would exist only inside this closure (functional programming).</li></ul></div><p class="calibre8">Just for comparison, if we wanted to write the same example in imperative programming, it would be just one line longer:</p><pre class="programlisting">$result = []; 
foreach ($input as $value) { 
    $result[] = strlen($value); 
} 
</pre><p class="calibre8">Let's take this a little further, and say we want to get the sum of all lengths greater than <code class="literal">5</code>. First, we'll start with the most obvious imperative approach:</p><pre class="programlisting">$input = ['apple', 'banana', 'orange', 'raspberry']; 
$sum = 0; 
foreach ($input as $fruit) { 
    $length = strlen($fruit); 
    if ($length &gt; 5) { 
        $sum += $length; 
    } 
} 
// $sum = 21 
printf("sum: %d\n", $sum); 
</pre><p class="calibre8">Now, we can write the same thing using functional programming, utilizing three methods we mentioned earlier: map, filter and reduce. In PHP, these are called <code class="literal">array_map()</code>, <code class="literal">array_filter()</code>, and <code class="literal">array_reduce()</code> respectively:</p><pre class="programlisting">$lengths = array_map(function($fruit) { 
    return strlen($fruit); 
}, $input); 
$filtered = array_filter($lengths, function($length) { 
    return $length &gt; 5; 
}); 
$sum = array_reduce($filtered, function($a, $b) { 
    return $a + $b; 
}); 
</pre><p class="calibre8">We got rid of all statements and used only expressions. The resulting code isn't short, and we had to also create three variables to hold partially processed arrays. So let's transform this into one large nested call:</p><pre class="programlisting">$sum = array_reduce(array_filter(array_map(function($fruit) { 
    return strlen($fruit); 
}, $input), function($length) { 
    return $length &gt; 5; 
}), function($a, $b) { 
    return $a + $b; 
}); 
</pre><p class="calibre8">This is a little shorter; we can see the sequence of functions applied and their respective expressions in the same order. We've already encountered inconsistency in function declarations in PHP, as shown in the following code, which has been highly criticized:</p><pre class="programlisting">array array_map(callable $callback, array $array1 [, $... ]) 
array array_filter(array $array, callable $callback) 
mixed array_reduce(array $array, callable $callback) 
</pre><p class="calibre8">These are shortened function definitions from PHP documentation. We can see that, sometimes the first argument is the iterated collection; sometimes it's the callback function. The same problem exists with string functions and their haystack-needle arguments. We can try to improve the readability a little with functional-PHP library (<a class="calibre1" href="https://github.com/lstrojny/functional-php">
https://github.com/lstrojny/functional-php
</a>) - a collection of functions for functional programming in PHP.</p><p class="calibre8">The following code represents the same example as above, but uses <code class="literal">lstrojny/functional-php</code> library:</p><pre class="programlisting">use function Functional\map; 
use function Functional\filter; 
use function Functional\reduce_left; 
 
$sum = reduce_left(filter(map($input, function($fruit) { 
    return strlen($fruit); 
}), function($length) { 
    return $length &gt; 5; 
}), function($val, $i, $col, $reduction) { 
    return $val + $reduction; 
}); 
</pre><p class="calibre8">It definitely looks better, but this is probably the best we can get when using standard PHP arrays.</p><p class="calibre8">Let's have a look at how the same problem could be solved in a language where arrays are objects and map, filter and reduce are its methods. Javascript, for example, is such a language, so we can rewrite the same example from above one more time:</p><pre class="programlisting">var sum = inputs 
    .map(fruit =&gt; fruit.length) 
    .filter(len =&gt; len &gt; 5) 
    .reduce((a, b) =&gt; a + b);  
</pre><div class="informaltable" title="Note"><h3 class="title1"><a id="note3" class="calibre1"/>Note</h3><p class="calibre8">We'll use the new ES6 standard whenever we show any JavaScript code throughout this entire book.</p></div><p class="calibre8">Well, this was quite easy and it meets all our expectations from functional programming much better than PHP. This might be the reason why we almost never use higher-order functions in PHP. They are just too hard to write, read and maintain.</p><p class="calibre8">Before we move on, we should look at another topic related to functional programming in PHP that is worth mentioning.</p></div><div class="book" title="Anonymous functions in PHP"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch01lvl3sec3" class="calibre1"/>Anonymous functions in PHP</h3></div></div></div><p class="calibre8">Every anonymous function is internally represented as an instance of a Closure class, shown as follows (we'll also refer to anonymous functions as closures or callables):</p><pre class="programlisting">$count = function() { 
    printf("%d ", count($this-&gt;fruits)); 
}; 
var_dump(get_class($count)); 
// string(7) "Closure" 
</pre><p class="calibre8">What's unusual is that we can bind custom <code class="literal">$this</code> object when calling a closure, a concept that is very common in JavaScript but very rarely used in PHP.</p><p class="calibre8">Let's define a simple class that we'll use for demonstration:</p><pre class="programlisting">class MyClass { 
    public $fruits; 
    public function __construct($arr) { 
        $this-&gt;fruits = $arr; 
    } 
} 
</pre><p class="calibre8">Then, test the function stored in <code class="literal">$count</code> variable on two objects:</p><pre class="programlisting">// closures_01.php 
// ... the class definition goes here 
$count = function() { 
    printf("%d ", count($this-&gt;fruits)); 
}; 
 
$obj1 = new MyClass(['apple', 'banana', 'orange']); 
$obj2 = new MyClass(['raspberry', 'melon']); 
 
$count-&gt;call($obj1); 
$count-&gt;call($obj2); 
</pre><p class="calibre8">This example prints to console the following output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php closures_01.php</strong></span>
<span class="strong"><strong class="calibre17">3</strong></span>
<span class="strong"><strong class="calibre17">2</strong></span>
</pre><p class="calibre8">In PHP, we can specify what variables we want to pass from the parent scope to the closure with the <code class="literal">use</code> keyword. Variables can be also passed by reference, similar to passing variables by reference on function calls. Consider the following example that demonstrates both principles:</p><pre class="programlisting">// closures_03.php 
$str = 'Hello, World'; 
 
$func = function() use ($str) { 
    $str .= '!!!'; 
    echo $str . "\n"; 
}; 
$func(); 
echo $str . "\n"; 
 
$func2 = function() use (&amp;$str) { 
    $str .= '???'; 
    echo $str . "\n"; 
}; 
$func2(); 
echo $str . "\n"; 
</pre><p class="calibre8">We have two closures <code class="literal">$func</code> and <code class="literal">$func2</code>. The first one works with a copy of <code class="literal">$str</code> so, when we print it outside of the function, it's unmodified. However, the second closure, <code class="literal">$func2</code> works with a reference to the original variable. The output for this demo is as follows:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php closures_03.php</strong></span>
<span class="strong"><strong class="calibre17">Hello, World!!!</strong></span>
<span class="strong"><strong class="calibre17">Hello, World</strong></span>
<span class="strong"><strong class="calibre17">Hello, World???</strong></span>
<span class="strong"><strong class="calibre17">Hello, World???</strong></span>
</pre><p class="calibre8">We'll be passing objects to closures a lot in this book.</p><p class="calibre8">There's also a <code class="literal">bindTo($newThis)</code> method with a similar purpose. Instead of evaluating the closure, it returns a new Closure object with <code class="literal">$this</code> binded to <code class="literal">$newThis</code>, which can be later called with for example, <code class="literal">call_user_func()</code> method. When using closures inside objects, the context <code class="literal">$this</code> is bind automatically, so we don't need to worry about it.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note4" class="calibre1"/>Note</h3><p class="calibre8">Anonymous functions and the Closure class are very well explained in the official documentation, so head over there if you have any hesitations:
<a class="calibre1" href="http://php.net/manual/en/functions.anonymous.php">
http://php.net/manual/en/functions.anonymous.php
</a>
</p></div></div><div class="book" title="PHP magic methods"><div class="book"><div class="book"><div class="book"><h3 class="title1"><a id="ch01lvl3sec4" class="calibre1"/>PHP magic methods</h3></div></div></div><p class="calibre8">PHP defines a set of names that can be used as class methods with a special effect. These are all prefixed with two underscores <code class="literal">__</code>. For our purposes, we'll be particularly interested in two of them, called <code class="literal">__invoke()</code> and <code class="literal">__call()</code>.</p><p class="calibre8">The <code class="literal">__invoke()</code> method is used when we try to use an object as if it were a regular function. This is useful when we use higher-order functions because we can treat objects and functions exactly the same way.</p><p class="calibre8">The second <code class="literal">__call()</code> method is used when we attempt to call an object method that doesn't exist (to be precise, a method that is inaccessible). It receives as arguments the original method name and an array of its arguments that was used when trying to call it.</p><p class="calibre8">We'll use both of these magic methods in <a class="calibre1" title="Chapter 2. Reactive Programming with RxPHP" href="part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d">Chapter 2</a>, <span class="strong"><em class="calibre18">Reactive Programming with RxPHP</em></span>.</p><p class="calibre8">The principles shown here aren't very common in PHP, but we'll meet them on several occasions when using functional programming.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note5" class="calibre1"/>Note</h3><p class="calibre8">Throughout this entire book, we'll try to follow PSR-1 and PSR-2 coding standards (<a class="calibre1" href="http://www.php-fig.org/psr/">http://www.php-fig.org/psr/</a>). However, we'll often violate them on purpose to keep the source codes as short as possible.</p></div><p class="calibre8">Now, we'll finally grasp reactive programming.</p></div></div></div>

<div class="book" title="Reactive programming"><div class="book" id="J2B82-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec12" class="calibre1"/>Reactive programming</h1></div></div></div><p class="calibre8">Reactive programming is yet another programming paradigm. It is based around the ability to easily express data flows and the automatic propagation of changes.</p><p class="calibre8">Let's explore this in more depth:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre17">Data flows</strong></span> (or data streams): In reactive programming, we want to think about variables as "values that change over time". For example, this could be a mouse position, user click or data coming via WebSockets. Basically, any event-based system can be considered a data stream.</li><li class="listitem"><span class="strong"><strong class="calibre17">Propagation of change</strong></span>: A very nice example is a spreadsheet editor. If we set the value of a single cell to <code class="literal">A1 = A2 + A3</code>, this means that every change to cells <code class="literal">A2</code> and <code class="literal">A3</code> will be propagated to <code class="literal">A1</code>. In programmers' speech, this corresponds to the observer design pattern where <code class="literal">A2</code> and <code class="literal">A3</code> are observables and <code class="literal">A1</code> is an observer. We'll talk about the observer pattern again later in this chapter.</li><li class="listitem"><span class="strong"><strong class="calibre17">Easily express data flows</strong></span>: This is related mostly to libraries we use rather than to the language itself. It means that, if we want to use reactive programming effectively, we need to be able to manipulate data streams easily. This principle also suggests that reactive programming falls under the category of declarative paradigms.</li></ul></div><p class="calibre8">As we can see, the definition is very broad.</p><p class="calibre8">The first part about data flows and propagation of change looks like the observer design pattern with iterables. Expressing data flows with ease could be done with functional programming. This all basically describes what we've already seen in this chapter.</p><p class="calibre8">The main differences to the observer pattern are how we think and manipulate with data streams. In previous examples, we always worked with arrays as inputs, which are synchronous, while data streams can be both synchronous and asynchronous. From our point of view, it doesn't matter.</p><p class="calibre8">Let's see what a typical implementation of the observer pattern might look like in PHP:</p><pre class="programlisting">// observer_01.php 
class Observable { 
    /** @var Observer[] */ 
    private $observers = []; 
    private $id; 
    static private $total = 0; 
 
    public function __construct() { 
        $this-&gt;id = ++self::$total; 
    } 
 
    public function registerObserver(Observer $observer) { 
        $this-&gt;observers[] = $observer; 
    } 
 
    public function notifyObservers() { 
        foreach ($this-&gt;observers as $observer) { 
            $observer-&gt;notify($this, func_get_args()); 
        } 
    } 
 
    public function __toString() { 
        return sprintf('Observable #%d', $this-&gt;id); 
    } 
} 
</pre><p class="calibre8">In order to be notified about any changes made by the Observable, we need another class called <code class="literal">Observer</code> that subscribes to an Observable:</p><pre class="programlisting">// observer_01.php 
class Observer { 
    static private $total = 0; 
    private $id; 
 
    public function __construct(Observable $observable) { 
        $this-&gt;id = ++self::$total; 
        $observable-&gt;registerObserver($this); 
    } 
 
    public function notify($obsr, $args) { 
        $format = "Observer #%d got "%s" from %s\n"; 
        printf($format, $this-&gt;id, implode(', ', $args), $obsr); 
    } 
} 
</pre><p class="calibre8">Then, a typical usage might look like the following:</p><pre class="programlisting">$observer1 = new Observer($subject); 
$observer2 = new Observer($subject); 
$subject-&gt;notifyObservers('test'); 
</pre><p class="calibre8">This example will print two messages to the console:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php observer_01.php</strong></span>
<span class="strong"><strong class="calibre17">// Observer #1 got "test" from Observable #1</strong></span>
<span class="strong"><strong class="calibre17">// Observer #2 got "test" from Observable #1</strong></span>
</pre><p class="calibre8">This almost follows how we defined the reactive programming paradigm. A data stream is a sequence of events coming from an Observable, and changes are propagated to all listening observers. The last point we mentioned above - being able to easily express data flows - isn't really there. What if we wanted to filter out all events that don't match a particular condition, just like we did in the examples with <code class="literal">array_filter()</code> and functional programming? This logic would have to go into each <code class="literal">Observer</code> class implementation.</p><p class="calibre8">The principles of reactive programming are actually very common in some libraries. We'll have a look at three of them and see how these relate to what we've just learned about reactive and functional programming.</p></div>

<div class="book" title="Reactive programming">
<div class="book" title="jQuery Promises"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch01lvl2sec7" class="calibre1"/>jQuery Promises</h2></div></div></div><p class="calibre8">Probably every web developer has used jQuery at some point. A very handy way of avoiding so-called <span class="strong"><strong class="calibre17">callback hell</strong></span> is using Promises when dealing with asynchronous calls. For example, calling <code class="literal">jQuery.ajax()</code> returns a <code class="literal">Promise</code> object that is resolved or rejected when the AJAX call has finished:</p><pre class="programlisting">$.get('/foo/bar').done(response =&gt; { 
    // ... 
}).fail(response =&gt; { 
    // ... 
}).complete(response =&gt; { 
    // ... 
}); 
</pre><p class="calibre8">A <code class="literal">Promise</code> object represents a value in the future. It's non-blocking (asynchronous), but lets us handle it in a declarative approach.</p><p class="calibre8">Another useful use case is chaining callbacks, forming a chain, where each callback can modify the value before propagating it further:</p><pre class="programlisting">// promises_01.js 
function functionReturningAPromise() { 
    var d = $.Deferred(); 
    setTimeout(() =&gt; d.resolve(42), 0); 
    return d.promise(); 
} 
 
functionReturningAPromise() 
    .then(value =&gt; value + 1) 
    .then(value =&gt; 'result: ' + value) 
    .then(value =&gt; console.log(value)); 
</pre><p class="calibre8">In this example, we have a single source which is the <code class="literal">functionReturningAPromise()</code> call, and three callbacks where only the last one prints the value that resolved the Promise. We can see that the number <code class="literal">42</code> was modified twice when going through the chain of callbacks:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ node promises_01.js </strong></span>
<span class="strong"><strong class="calibre17">result: 43</strong></span>
</pre><div class="informaltable" title="Note"><h3 class="title1"><a id="note6" class="calibre1"/>Note</h3><p class="calibre8">In reactive programming, we'll use a very similar approach to Promises, but while a <code class="literal">Promise</code> object is always resolved only once (it carries just one value); data streams can generate multiple or even an infinite number of values.</p></div></div></div>

<div class="book" title="Reactive programming">
<div class="book" title="Gulp streaming build system"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch01lvl2sec8" class="calibre1"/>Gulp streaming build system</h2></div></div></div><p class="calibre8">The Gulp build system has become the most popular build system in JavaScript. It's completely based on streams and manipulating them. Consider the following example:</p><pre class="programlisting">gulp.src('src/*.js') 
  .pipe(concat('all.min.js')) 
  .pipe(gulp.dest('build')); 
</pre><p class="calibre8">This creates a stream of files that match the predicate <code class="literal">src/*.js</code>, concats all of them together and finally writes one single file to <code class="literal">build/all.min.js</code>. Does this remind you of anything?</p><p class="calibre8">This is the same declarative and functional approach we used above, when talking about functional programming in PHP. In particular, this <code class="literal">concat()</code> function could be replaced with PHP's <code class="literal">array_reduce()</code>.</p><p class="calibre8">Streams in gulp (aka vinyl-source-stream) can be modified in any way we want. We can, for example, split a stream into two new streams:</p><pre class="programlisting">var filter = require('gulp-filter'); 
var stream = gulp.src('src/*.js'); 
var substream1 = stream.pipe(filter(['*.min.js'])); 
var substream2 = stream.pipe(filter(['!/app/*'])); 
</pre><p class="calibre8">Or, we can merge two streams and uglify (minify and obfuscate the source code) into one stream:</p><pre class="programlisting">var merge = require('merge2'); 
merge(gulp.src('src/*.js'), gulp.src('vendor/*')) 
    .pipe(uglify()); 
    .pipe(gulp.dest('build')); 
</pre><p class="calibre8">This stream manipulation corresponds very well to the last concept we used to define the reactive programming paradigm - express data flows with ease - while it's both functional and declarative.</p></div></div>

<div class="book" title="Reactive programming">
<div class="book" title="EventDispatcher component in PHP"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_3"><a id="ch01lvl2sec9" class="calibre1"/>EventDispatcher component in PHP</h2></div></div></div><p class="calibre8">Probably every PHP framework comes with some type of event-driven component to notify various different parts of an application using events.</p><p class="calibre8">One such component comes with the Symfony framework out-of-the-box (<a class="calibre1" href="https://github.com/symfony/event-dispatcher">
https://github.com/symfony/event-dispatcher
</a>). It's an independent component that allows subscribing and listening to events (the observer pattern).</p><p class="calibre8">Event listeners can be later grouped by the events they subscribe to and can also be assigned custom tags, as shown in the following code:</p><pre class="programlisting">use Symfony\Component\EventDispatcher\EventDispatcher; 
$dispatcher = new EventDispatcher(); 
$listener = new AcmeListener(); 
$dispatcher-&gt;addListener('event_name', [$listener, 'action']); 
</pre><p class="calibre8">This principle is very similar to Zend\EventManager used in Zend Framework. It is just another variation of the Observable - observer combination.</p><p class="calibre8">We'll come back to Symfony <code class="literal">EventDispatcher</code> component in <a class="calibre1" title="Chapter 4. Reactive versus a Typical Event-Driven Approach" href="part0039_split_000.html#1565U2-bd355a22cf10407cb10df27e65585b8d">
Chapter 4
</a>, <span class="strong"><em class="calibre18">Reactive vs a Typical Event-Driven approach</em></span>, where we'll explore how to apply the reactive programming approach to event-based systems, which should lead to simplification and better-organized code.</p></div></div>

<div class="book" title="Reactive Extensions" id="K0RQ1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec13" class="calibre1"/>Reactive Extensions</h1></div></div></div><p class="calibre8">Now that we've seen that the principles in the reactive programming paradigm aren't completely new for us, we can start thinking about how to put all this together. In other words, what libraries or frameworks do we really need in order to start writing reactive code.</p><p class="calibre8">Reactive Extensions (ReactiveX or just Rx in short) are a set of libraries in various languages that make reactive programming easy even in languages where concepts of asynchronous and functional programming are clumsy, such as PHP. However, there's a very important distinction:</p><p class="calibre8">Reactive programming doesn't equal Reactive Extensions.</p><p class="calibre8">A Reactive Extension is a library that introduces certain principles as one of the possible ways to approach reactive programming. Very often, when somebody tells you they're using reactive programming to do something in their applications, they're in fact talking about a particular Reactive Extension library in their favorite language.</p><p class="calibre8">Reactive Extensions were originally made by Microsoft for .NET and called <span class="strong"><strong class="calibre17">Rx.NET</strong></span>. Later, it was ported by Netflix to Java as <span class="strong"><strong class="calibre17">RxJava</strong></span>. Now, there are over a dozen supported languages, the most popular probably being <span class="strong"><strong class="calibre17">RxJS</strong></span> - the JavaScript implementation.</p><p class="calibre8">All ports follow a very similar API design, however, differences occur and we'll talk about them a couple of times. We'll be mostly interested in differences between RxPHP and RxJS.</p><p class="calibre8">RxPHP is mostly uncharted territory. A more typical environment where we encounter asynchronous events is JavaScript, so we'll first demonstrate examples in JavaScript (and RxJS 5), and afterwards we will have a look at RxPHP.</p></div>

<div class="book" title="Reactive Extensions" id="K0RQ1-bd355a22cf10407cb10df27e65585b8d">
<div class="book" title="Autocomplete with RxJS"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch01lvl2sec10" class="calibre1"/>Autocomplete with RxJS</h2></div></div></div><p class="calibre8">Imagine we want to implement an autocomplete feature that downloads suggestions from Wikipedia (this example comes from the official collection of demos on RxJS's GitHub page):</p><pre class="programlisting">function searchAndReturnPromise(term) { 
    // perform an AJAX request and return a Promise 
} 
 
var keyup = Rx.Observable.fromEvent($('#textInput'), 'keyup') 
    .map(e =&gt; e.target.value) 
    .filter(text =&gt; text.length &gt; 2) 
    .debounceTime(750) 
    .distinctUntilChanged(); 
var searcher = keyup.switchMap(searchAndReturnPromise); 
</pre><p class="calibre8">Let's take a closer look at how this works:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">We create an Observable from the form input's <code class="literal">keyup</code> event. This function is built into RxJS to simplify creating Observables. We can, of course, create our own Observables as well.</li><li class="listitem" value="2">Apply the <code class="literal">map()</code> function. This is exactly what we have already seen above. Note that this <code class="literal">map()</code> function, is in fact, not <code class="literal">Array.map()</code>, but <code class="literal">Observable.map()</code> instead, because we're not working with arrays here.</li><li class="listitem" value="3">Chain with <code class="literal">filter()</code> method. Exactly the same case as with <code class="literal">map()</code>.</li><li class="listitem" value="4">Method <code class="literal">debounceTime()</code> is used to limit propagating an event down the stream only once after a period of time. In this case, we're using 750ms, which means that, when the user starts typing, it won't download data from Wikipedia on every <code class="literal">keyup</code> event, but only after at least a 750ms delay between two events.</li><li class="listitem" value="5">The <code class="literal">distinctUntilChanged()</code> method makes sure we're calling the AJAX request only when the value has really changed from the last time, because it makes no sense to download the same suggestions twice.</li><li class="listitem" value="6">The last statement with <code class="literal">keyup.switchMap()</code> guarantees that when making multiple asynchronous calls, only the last one in the stream gets processed. All the others are dismissed. This is important because, when dealing with AJAX calls, we have absolutely no control over which Promise resolves first.</li></ol><div class="calibre22"/></div><p class="calibre8">If we didn't use RxJS, this feature would require multiple state variables. At least to keep the last value from the input, the last time the event occurred, and the last request value for the AJAX call. With RxJS, we can focus on what we want to do and not worry about its implementation details (declarative approach).
</p><p class="calibre8">With Reactive Extensions, this approach fulfills all we described above about reactive programming, functional programming and also, mostly, declarative programming.</p></div></div>

<div class="book" title="Reactive Extensions" id="K0RQ1-bd355a22cf10407cb10df27e65585b8d">
<div class="book" title="Mouse position on drag and drop"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch01lvl2sec11" class="calibre1"/>Mouse position on drag and drop</h2></div></div></div><p class="calibre8">Let's have a look at a slightly more complicated example in RxJS. We want to track the relative mouse position from where we start dragging an HTML element, until we release it (<code class="literal">mouseup</code> event).</p><p class="calibre8">Pay attention to how this example combines multiple Observables (this example also comes from the official collection of demos on RxJS's GitHub page):</p><pre class="programlisting">var mouseup   = Rx.Observable.fromEvent(dragTarget, 'mouseup'); 
var mousemove = Rx.Observable.fromEvent(document, 'mousemove'); 
var mousedown = Rx.Observable.fromEvent(dragTarget, 'mousedown'); 
 
var mousedrag = mousedown.mergeMap(md =&gt; { 
    var sX = md.offsetX, sY = md.offsetY; 
    return mousemove.map(mm =&gt; { 
        mm.preventDefault(); 
        return {left: mm.clientX - sX, top: mm.clientY - sY}; 
    }).takeUntil(mouseup); 
}); 
 
var subscription = mousedrag.subscribe(pos =&gt; { 
    dragTarget.style.top = pos.top + 'px'; 
    dragTarget.style.left = pos.left + 'px'; 
}); 
</pre><p class="calibre8">Notice that <code class="literal">mousedrag</code> is an Observable created by calling <code class="literal">return mousemove(...)</code> and that it emits events only until a <code class="literal">mouseup</code> event is emitted thanks to <code class="literal">takeUntil(mouseup)</code>.</p><p class="calibre8">Normally, without RxJS and with a typical imperative approach, this would be even more complicated than the previous example, with more state variables.</p><p class="calibre8">Of course, this requires some basic knowledge of what functions are available for Observables, but even without any previous experience, the code should be reasonably easy to understand. Yet again, the implementation details are completely hidden for us.</p></div></div>

<div class="book" title="Introducing RxPHP" id="KVCC1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec14" class="calibre1"/>Introducing RxPHP</h1></div></div></div><p class="calibre8">RxPHP (<a class="calibre1" href="https://github.com/ReactiveX/RxPHP">
https://github.com/ReactiveX/RxPHP
</a>) is a port of RxJS. We're going to be using Composer to handle all dependencies in our PHP projects. It has become a state of the art tool, so if you haven't used it before, download it first and check out some basic usage at <a class="calibre1" href="https://getcomposer.org/">
https://getcomposer.org/
</a>.</p><p class="calibre8">Then, create a new directory and initialize a composer project:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ mkdir rxphp_01</strong></span>
<span class="strong"><strong class="calibre17">$ cd rxphp_01</strong></span>
<span class="strong"><strong class="calibre17">$ php composer.phar init</strong></span>
</pre><p class="calibre8">Fill in the required fields by the interactive wizard and then add RxPHP as a dependency:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php composer.phar require reactivex/rxphp</strong></span>
</pre><p class="calibre8">When the library successfully downloads, composer will also create <code class="literal">autoload.php</code> file to handle all class auto-loading on demand.</p><p class="calibre8">Then, our code will print string lengths of different types of fruit:</p><pre class="programlisting">// rxphp_01.php 
require __DIR__ . '/vendor/autoload.php'; 
 
$fruits = ['apple', 'banana', 'orange', 'raspberry']; 
$observer = new \Rx\Observer\CallbackObserver( 
    function($value) { 
        printf("%s\n", $value); 
    }, null, function() { 
        print("Complete\n"); 
    }); 
 
\Rx\Observable::fromArray($fruits) 
    -&gt;map(function($value) { 
        return strlen($value); 
    }) 
    -&gt;subscribe($observer); 
</pre><div class="informaltable" title="Note"><h3 class="title1"><a id="note7" class="calibre1"/>Note</h3><p class="calibre8">In all future examples, we won't include the <code class="literal">autoload.php</code> file, to keep the examples as short as possible. However, it's obviously required in order to run the examples. If you're unsure, have a look at the source codes provided for each chapter.</p></div><p class="calibre8">We first created an observer - <code class="literal">CallbackObserver</code> to be precise - which takes three functions as arguments. These are called on the next item in the stream, on error and when the input stream is complete and won't emit any more items.</p><p class="calibre8">The advantage of the <code class="literal">CallbackObserver</code> class is that we don't need to write a custom observer class every time we want to handle incoming items in some special and not very reusable way. With <code class="literal">CallbackObserver</code>, we can just write the callables for signals we want to handle.</p><p class="calibre8">When we run this example, we'll see:</p><pre class="programlisting">
<span class="strong"><strong class="calibre17">$ php rxphp_01.php </strong></span>
<span class="strong"><strong class="calibre17">5</strong></span>
<span class="strong"><strong class="calibre17">6</strong></span>
<span class="strong"><strong class="calibre17">6</strong></span>
<span class="strong"><strong class="calibre17">9</strong></span>
<span class="strong"><strong class="calibre17">Complete</strong></span>
</pre><p class="calibre8">This example was very easy, but compared to the JavaScript environment, it's not very common to use asynchronous operations in PHP and, in case we do have to work asynchronously, it's probably something non-trivial. In <a class="calibre1" title="Chapter 3. Writing a Reddit Reader with RxPHP" href="part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d">Chapter 3</a>, <span class="strong"><em class="calibre18">Writing a Reddit reader with RxPHP</em></span>, we'll use <span class="strong"><strong class="calibre17">Symfony Console component</strong></span> to handle all user input from the command line and, where we can, use similar principles to handling mouse events as we saw in the two RxJS examples above.</p><p class="calibre8">The JavaScript examples work very well as examples of what reactive programming using Reactive Extensions looks like and what its benefits are.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note8" class="calibre1"/>Note</h3><p class="calibre8">If you want to know more about Reactive Extensions, head over to <a class="calibre1" href="http://reactivex.io/">http://reactivex.io/</a>. Also, before continuing to the next chapter, you can have a look at how many different operators Rx supports <a class="calibre1" href="http://reactivex.io/documentation/operators.html">http://reactivex.io/documentation/operators.html</a> and how these can be used in different languages.</p></div></div>

<div class="book" title="Introducing RxPHP" id="KVCC1-bd355a22cf10407cb10df27e65585b8d">
<div class="book" title="RxPHP 1.x and RxPHP 2"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch01lvl2sec12" class="calibre1"/>RxPHP 1.x and RxPHP 2</h2></div></div></div><p class="calibre8">As of April 2017, there're two versions of RxPHP.</p><p class="calibre8">The RxPHP 1.x is stable and requires PHP 5.5+. All examples in this book are made for RxPHP 1.x, more specifically, RxPHP 1.5+. It's API is based mostly on RxJS 4, but it takes some features from RxJS 5 as well.</p><p class="calibre8">There's also RxPHP 2 in development, which requires PHP 7.0+. RxPHP 2 API from the user's perspective is almost the same as 1.x, it just makes some things easier (for example working with even loops, as we'll see in <a class="calibre1" title="Chapter 6. PHP Streams API and Higher-Order Observables" href="part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d">Chapter 6</a>, <span class="strong"><em class="calibre18">PHP Streams API and Higher-Order Observables</em></span>). When we encounter any differences worth mentioning, we'll give them extra space.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note9" class="calibre1"/>Note</h3><p class="calibre8">The newer RxPHP 2 was meant to be based to the PHP loop interoperability specification (<a class="calibre1" href="https://github.com/async-interop/event-loop">https://github.com/async-interop/event-loop</a>). However, the specification is still in pre-release stage and it won't be stable in the nearest future. For this reason, the RxPHP team decided to leave the async-interop support for future releases. For more information visit <a class="calibre1" href="https://github.com/ReactiveX/RxPHP/pull/150">https://github.com/ReactiveX/RxPHP/pull/150</a>.</p></div></div></div>
<div class="book" title="Summary" id="LTSU1-bd355a22cf10407cb10df27e65585b8d"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec15" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we tried to explain the common programming paradigms used in most programming languages. These were: imperative, declarative and functional programming. We also compared the meanings of asynchronous and parallel code.</p><p class="calibre8">We spent some time on practical examples of functional programming in PHP and its downsides, and we went through examples of some not very common features, such as the Closure class.</p><p class="calibre8">Then, we examined the definition of reactive programming and how it's related to all we saw previously in this chapter.</p><p class="calibre8">We introduced Reactive Extensions (Rx) as a library for one of the possible approaches to reactive programming.</p><p class="calibre8">In two examples of RxJS, we saw what working with Reactive Extensions looks like in practice and how this matches our definition of reactive programming.</p><p class="calibre8">Finally, we introduced RxPHP, which we'll use throughout this entire book. We also quickly talked about differences between RxPHP 1.x and RxPHP 2.</p><p class="calibre8">In the next chapter, we'll have a closer look at various parts of the RxPHP library and talk more about the principles used in Reactive Extensions.</p></div></body></html>