<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Design Patterns"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Design Patterns</h1></div></div></div><a id="id123" class="indexterm"/><a id="id124" class="indexterm"/><a id="id125" class="indexterm"/><p>Object oriented programming was basically introduced to ease the development process as well as reduce the time of development by reducing amounts of code. If properly planned and designed, OOP can increase the performance of the program to a great extent. One of those magical performance cum code reduction issues is "Design Pattern" which was introduced by Eric Gamma and his three other friends in the book <span class="emphasis"><em>Design Patterns</em></span> in 1972. Because of four authors, the book was introduced as written by <span class="emphasis"><em>Gang of Four</em></span> or simply <span class="emphasis"><em>Goff</em></span>. In that legendary book, Gang of Four introduced several patterns to minimize the amount of code as well as to introduce effective coding practice. In this chapter we will learn some of those patterns to implement in PHP. </p><div class="section" title="You Might have Done this Before…"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec40"/>You Might have Done this Before…</h1></div></div></div><p>While coding, many of us use these patterns without being aware that these techniques are actually known as patterns. Even in my early coding life, I used some coding techniques, which I later found out to be similar to some patterns. So don't be afraid about using patterns. They are daily coding tricks, which you may have always performed, but you may not have known. </p><p>While developing software, some problems are addressed on a regular basis. Almost every software development faces some of these problems. These problems are termed "design patterns" and are given some common solutions. So knowing design patterns saves a lot of time for developers in software development. Let's have a closer look at design patterns. </p></div></div>
<div class="section" title="Strategy Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Strategy Pattern</h1></div></div></div><a id="id126" class="indexterm"/><a id="id127" class="indexterm"/><p>One of the common problems we face whilst programming, is that we have to make decisions on different strategies. Strategy pattern is a common pattern helps us make decisions on different cases, more easily. To understand this better, let us use a scenario that you're developing a notifier program. This notifier program will check the given options for a user. A user may want to be notified in many ways, like email, SMS, or fax. Your program has to check the available options to contact that user and then make a decision upon that. This case can easily be solved by Strategy pattern: <a id="id128" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/2561_04_01.jpg" alt="Strategy Pattern"/></div><p>In the above pattern we are using three classes called <code class="literal">SMSNotifier</code>, <code class="literal">EmailNotifier</code>, and <code class="literal">FaxNotifier</code>. All these classes implement the Notifier interface, which has a method named <code class="literal">notify</code>. Each of these classes implement that method on their own. </p><p>Let's create the interface first. </p><div class="informalexample"><pre class="programlisting">&lt;?
//interface.Notifier.php
interface notifier
{
  public function notify();
}
?&gt;</pre></div><p>N<a id="id129" class="indexterm"/>ow we will create different types of notifiers. </p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>class.emailnotifier.php</strong></span>
&lt;?
include_once("interface.notifier.php");
class EmailNotifier implements notifier 
{
  public function notify()
  {
    //do something to notify the user by Email
  }
}
?&gt;</pre></div><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>class.faxnotifier.php</strong></span>
&lt;?
include_once("notifier.php");
class FaxNotifier implements notifier 
{
  public function notify()
  {
    //do something to notify the user by Fax
  }
}
?&gt;</pre></div><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>class.smsnotifier.php</strong></span>
&lt;?
include_once("notifier.php");
class SMSNotifier implements notifier 
{
  public function notify()
  {
    //do something to notify the user by SMS
  }
}
?&gt;</pre></div><p>N<a id="id130" class="indexterm"/>ow we will use this code:</p><div class="informalexample"><pre class="programlisting">&lt;?
include_once("EmailNotifier.php");
include_once("FaxNotifier.php");
include_once("SMSNotifier.php");

/**
 * Let's create a mock object User which we assume has a method named
 * getNotifier(). This method returns either "sms" or "fax" or "email"
 */

$user = new User();
$notifier = $user-&gt;getNotifier();
switch ($notifier)
{
  case "email":
    $objNotifier = new EmailNotifier();
    break;
  case "sms":
    $objNotifier = new SMSNotifier();
    break;
  case "fax":
    $objNotifier = new FaxNotifier();
  break;
}

$objNotifier-&gt;notify();
?&gt;</pre></div><p>I'm sure you'll agree that this is pretty simple. I am also sure that you have already used such solutions in your existing codes on more than one occasion</p></div>
<div class="section" title="Factory Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec42"/>
<a id="id131" class="indexterm"/>Factory Pattern
</h1></div></div></div><p><a id="id132" class="indexterm"/>
<a id="id133" class="indexterm"/>Another common design pattern is factory pattern. The main goal of this pattern is delivering an object by hiding all the complexities behind it. This may sound cryptic, so let's look at it using a real life scenario. </p><p>You are doing a project that works on a very complex system. For this example, you are creating an online document repository, which saves documents in temporary storage. For this you need support for PostgreSQL, MySQL, Oracle, and SQLite because users may deploy your application using any of these. So you create an object, which connects to MySQL and perform the necessary tasks. Your MySQL object is: </p><div class="informalexample"><pre class="programlisting">
<a id="id134" class="indexterm"/>&lt;?
class MySQLManager
{
  public function setHost($host)
  {
    //set db host
  }

  public function setDB($db)
  {
    //set db name
  }
  public function setUserName($user)
  {
    //set user name
  }
  public function setPassword($pwd)
  {
    //set password
  }

  public function connect()
  {
    //now connect
  }
}
s
?&gt;</pre></div><p>Well, now you use this class like this:</p><div class="informalexample"><pre class="programlisting">&lt;?
$MM = new MySQLManager();
$MM-&gt;setHost("host");
$MM-&gt;setDB("db");
$MM-&gt;setUserName("user");
$MM-&gt;setPassword("pwd");
$MM-&gt;connect();
?&gt;</pre></div><p>You can now see that before you started using your class, you needed to do a lot of things. Your PostgreSQL class also looks similar: </p><div class="informalexample"><pre class="programlisting">&lt;?
class PostgreSQLManager
{
  public function setHost($host)
  {
    //set db host
  }

  public function setDB($db)
  {
    //set db name
  }
  public function setUserName($user)
  {
    //set user name
  }
  public function setPassword($pwd)
  {
    //set password
  }

  public function connect()
  {
    //now connect
  }
}

?&gt;</pre></div><p>And usage is also the same:</p><div class="informalexample"><pre class="programlisting">&lt;?
$PM = new PostgreSQLManager();
$PM-&gt;setHost("host");
$PM-&gt;setDB("db");
$PM-&gt;setUserName("user");
$PM-&gt;setPassword("pwd");
$PM-&gt;connect();
?&gt;</pre></div><p>But now usage could be a bit difficult when you merge them together: </p><div class="informalexample"><pre class="programlisting">&lt;?
  If ($dbtype=="mysql")
  //use mysql class
  Else if ($dbtype=="postgresql")
  //use postgresql class
?&gt;</pre></div><p>Shortly after this you will find that as more database engines are added, the core code changes significantly and you have to hard code all these things in core classes. However, a very good practice of programming is loose coupling. Here you make a separate class called <code class="literal">DBManager</code>, which will perform all these things from a central place. Let's make it:</p><div class="informalexample"><pre class="programlisting">&lt;?
class DBManager
{
  public static function setDriver($driver)
  {
    $this-&gt;driver = $driver;
  //set the driver
  }

  public static function connect()
  {
    if ($this-&gt;driver=="mysql")
    {
      $MM = new MySQLManager();
      $MM-&gt;setHost("host");
      $MM-&gt;setDB("db");
      $MM-&gt;setUserName("user");
      $MM-&gt;setPassword("pwd");
      $this-&gt;connection = $MM-&gt;connect();
    }
    else if($this-&gt;driver=="pgsql")
    {
      $PM = new PostgreSQLManager();
      $PM-&gt;setHost("host");
      $PM-&gt;setDB("db");
      $PM-&gt;setUserName("user");
      $PM-&gt;setPassword("pwd");
      $this-&gt;connection= $PM-&gt;connect();
    }
  }
}
?&gt;</pre></div><div class="mediaobject"><img src="graphics/2561_04_02.jpg" alt="Strategy patternexampleFactory Pattern"/></div><p>No<a id="id135" class="indexterm"/>w you can use it from a single place called <code class="literal">DBManager</code>. This makes the thing a whole lot easier than before. </p><div class="informalexample"><pre class="programlisting">&lt;?
$DM = new DBManager();
$DM-&gt;setDriver("mysql");
$DM-&gt;connect("host","user","db","pwd");
?&gt;</pre></div><p>This is the real life example of a Factory design pattern. The <code class="literal">DBManager</code> now works as a Factory, which encapsulates all the complexities behind the scene and delivers two products. Factory simplifies programming by encapsulating the difficulties inside it. </p></div>
<div class="section" title="Abstract Factory"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec43"/>A<a id="id136" class="indexterm"/>bstract Factory
</h1></div></div></div><p><a id="id137" class="indexterm"/>
<a id="id138" class="indexterm"/>Abstract Factory is almost similar to Factory, the only difference is that all your concrete objects must extend a common abstract class. You may ask what is the benefit of doing so is. Well, as long as concrete objects are derived from a known abstract object, programming is simplified because they all come in the same standard.</p><p>Let's have a look at the previous example. We first create an abstract class and then extend that object to develop all concrete driver classes. </p><div class="informalexample"><pre class="programlisting">&lt;<a id="id139" class="indexterm"/>?
abstract class DBDriver
{
  public function connect();
  public function executeQuery();
  public function insert_id();
  public function setHost($host)
  {
    //set db host
  }

  public function setDB($db)
  {
    //set db name
  }
  public function setUserName($user)
  {
    //set user name
  }
  public function setPassword($pwd)
  {
    //set password
  }
  //.....
}
?&gt;</pre></div><p>Now our MySQL will be derived from it: </p><div class="informalexample"><pre class="programlisting">&lt;?
class MySQLManager extends DBDriver 
{
  public function connect()
  {
    //implement own connection procedures
  }

  public function executeQuery()
  {
    //execute mysql query and return result
  }

  public function insertId()
  {
    //find the latest inserted id
  }
}
?&gt;</pre></div><div class="mediaobject"><img src="graphics/2561_04_03.jpg" alt="Afactory patternexamplebstract Factory"/></div><a id="id140" class="indexterm"/><p>Later we will use this <code class="literal">MySQLManager</code> class as usual in our <code class="literal">DBManager</code>. One major benefit is that we define all the necessary functions in a single place, which is present in all derived classes with the same standard. We can also encapsulate common functions/procedures in the abstract class. </p></div>
<div class="section" title="Adapter Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Ad<a id="id141" class="indexterm"/>apter Pattern
</h1></div></div></div><p><a id="id142" class="indexterm"/>
<a id="id143" class="indexterm"/>Another interesting problem in OOP is solved by a design pattern named Adapter. So what is an Adapter pattern and what type of problems does it solve?</p><p>Adapter is actually an object that acts like an adapter in real life, in that it converts one thing to another. Using Adapter you can convert electric sources from higher to lower volts. Similarly in OOP, using Adapter pattern, one object can fit for the same methods of another object.  </p><p>Let us discuss patterns in real life coding in more detail. Suppose you develop an online document repository, which exports written documents to popular online file storage services. You have developed one wrapper, which can store and retrieve documents from Writely using their native API. Well, soon after Google acquired Writely, you find that they are temporarily shut down and you have to use Google docs as the base of that repository. Now what will you do? You find open source solutions to use with Google docs but unfortunately you find that the methods of that Google doc object differ from the Writely object. </p><p>This is a very common scenario and it happens when classes are developed by different developers. You want to use this Google docs object but you don't want to change your core code, because then you will have to change it a lot then. On top of this there are chances that the code may break after these core changes. </p><p>In this scenario an Adapter pattern comes to save your life. You develop a common interface which a Writely object implements. Now all you have to do is develop another wrapper class, which implements the same interface that was implemented by Google Docs. So what will our wrapper class do? It wraps all the methods of Google docs class into those available in the interface. After successfully wrapping everything, you can use this object straight in your code. You may need to change a line or two, but the rest of the core code remains unchanged. </p><p>That's what's great about using Adapter pattern. You can keep your core code unchanged even when the code of third-party dependencies and external API changes. Let us have a closer look at it: </p><div class="mediaobject"><img src="graphics/2561_04_04.jpg" alt="AdAbstract Factoryexampleapter Pattern"/></div><p>Here comes our first version of a Writely object: </p><div class="informalexample"><pre class="programlisting">&lt;?
class Writely implements DocManager()
{
  public function authenticate($user, $pwd)
  {
    //authenticate using Writely authentication scheme
  }

  public function getDocuments($folderid)
  {
    //get documents available in a folder
  }

  public function getDocumentsByType($folderid, $type)
  {
    //get documents of specific type from a folder
  }
  public function getFolders($folderid=null)
  {
    //get all folders under a specific folder
  }

  public function saveDocuments($document)
  {
    //save the document
  }
}
?&gt; </pre></div><p>Here is the <code class="literal">DocManager</code> interface: </p><div class="informalexample"><pre class="programlisting">&lt;?
interface DocManager
{
  public function authenticate($user, $pwd);
  public function getDocuments($folderid);
  public function getDocumentsByType($folderid, $type);
  public function getFolders($folderid=null);
  public function saveDocument($document);
}
?&gt;</pre></div><p>Now <a id="id144" class="indexterm"/>the <code class="literal">GoogleDoc</code> object looks like something below: </p><div class="informalexample"><pre class="programlisting">&lt;?
class GoogleDocs
{
  public function authenticateByClientLogin()
  {
    //authenticate using Writely authentication scheme
  }

  public function setUser()
  {
    //set user
  }

  public function setPassword()
  {
    //set password
  }

  public function getAllDocuments()
  {
    //get documents available in a folder
  }
  public function getRecentDocuments()
  {
 
  }

  public function getDocument()
  {

  }
}
?&gt;</pre></div><p>So how does it fit with our existing code? </p><p>To make it compatible with our existing code, we need to develop the wrapper object, which implements the same <code class="literal">DocManager</code> interface but uses the <code class="literal">GoogleDoc</code> object to perform the actual work.</p><div class="informalexample"><pre class="programlisting">&lt;?php
Class GoogleDocsAdapter implements DocManager 
{
  private $GD;

  public function __construct()
  {
    $this-&gt;GD = new GoogleDocs();
  }

  public function authenticate($user, $pwd)
  {
    $this-&gt;GD-&gt;setUser($user);
    $this-&gt;GD-&gt;setPwd($pwd);
    $this-&gt;GD-&gt;authenticateByClientLogin();
  }

  <a id="id145" class="indexterm"/>public function getDocuments($folderid)
  {
    return $this-&gt;GD-&gt;getAllDocuments();
  }

  public function getDocumentsByType($folderid, $type)
  {
     //get documents using GoogleDocs object and return only
     // which match the type
  }

  public function getFolders($folderid=null)
  {
    //for example there is no folder in GoogleDocs, so 
    //return anything. 
  }

  public function saveDocument($document)
  {
    //save the document using GoogleDocs object
  }
}
?&gt;</pre></div><p>Now we will just instantiate an instance of <code class="literal">GoogleDocsAdapter</code> and then use that instance in our core code. As it implements the same interface, there is no need to change the core code. </p><p>However, there's one more thing to note: what about the missing functions? For example your <code class="literal">WritelyDocs</code> object supports the <code class="literal">getFolders()</code> method, which is of no use in <code class="literal">GoogleDocs</code>. You must implement those methods more carefully. For example, if your core code requires some folder ID returned by this method, in <code class="literal">GoogleDocsAdapter</code> you can generate a random folder ID and return them (which has no use in <code class="literal">GoogleDocsAdapter)</code>. So your core code won't break at all. </p></div>
<div class="section" title="Singleton Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Sin<a id="id146" class="indexterm"/>gleton Pattern
</h1></div></div></div><p>One <a id="id147" class="indexterm"/>
<a id="id148" class="indexterm"/>of the most used design patterns is Singleton. This pattern solves a very significant problem in object oriented programming and saves the lives of millions of programmers in practical programming. </p><p>The <a id="id149" class="indexterm"/>main purpose of the Singleton pattern is to deliver a single instance of object no matter how many times you instantiate it. That is, if an object is instantiated once, using the Singleton pattern you can deliver only that instance when you require it again in your code. This saves memory consumption by preventing the creation of multiple instances of an object. Thus Singleton pattern is used to improve the performance of your application.</p><div class="mediaobject"><img src="graphics/2561_04_04.jpg" alt="SinAdapter patternexamplegleton Pattern"/></div><p>Let's take the <code class="literal">MySQLManager</code> class, which we created in the previous example. Now we are adding a single instance feature using Singleton pattern.</p><div class="informalexample"><pre class="programlisting">&lt;?
c<a id="id150" class="indexterm"/>lass MySQLManager
{
  private static $instance;

  public function __construct()
  {
    if (!self::$instance)
    {
      self::$instance = $this;
      echo "New Instance\n";
      return self::$instance;
    }
    else 
    {
      echo "Old Instance\n";
      return self::$instance;
    }
  }
//keep other methods same
}
?&gt;</pre></div><p>Now let us see how it actually works. If you execute the following script, you will be surprised to see the result. </p><div class="informalexample"><pre class="programlisting">&lt;?
$a = new MYSQLManager();
$b = new MYSQLManager();
$c = new MYSQLManager();
$d = new MYSQLManager();
$e = new MYSQLManager();
?&gt;</pre></div><p>The output is:</p><div class="informalexample"><pre class="programlisting">New Instance
Old Instance
Old Instance
Old Instance
Old Instance</pre></div><p>Strange, isn't it? The <code class="literal">MySQLManager</code> class creates only a single instance at the very first call, after that it is using the same old object instead of creating a new object all the time. Let us see how we achieve it.</p><div class="informalexample"><pre class="programlisting">private static $instance;</pre></div><p>Our class has a static variable named <code class="literal">$instance</code>. At the constructor we check if the static variable actually contains anything. If it is empty, we instantiate the object itself and set the instance in this static variable. As it is static, it will remain available throughout the execution of this script. </p><p>Let us get back to the constructor. At the second call, we just check if the <code class="literal">$instance</code> variable contains anything. We find that the <code class="literal">$instance</code> variable is actually containing an instance of this object, and it is still preserved because it is a static variable. So in the second call, we actually return the instance of this object, which was created by the previous call. </p><p>Singl<a id="id151" class="indexterm"/>eton is a very important pattern and you should understand properly what it actually does. You can optimize your application and increase its performance using this pattern properly.</p></div>
<div class="section" title="Iterator Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec46"/>Iterator Pattern </h1></div></div></div><p><a id="id152" class="indexterm"/>
<a id="id153" class="indexterm"/>Iterator is a common pattern, which helps you to manipulate a collection more easily. Almost every language has built-in support of Iterators. Even PHP5 has a built-in Iterator objects. Iterators are very useful to provide an easy interface to manipulate a collection sequentially. </p><p>Let us consider this scenario when the Iterator pattern can save the life if a developer is in complex applications. Let us imagine you are creating a blog, where users write their daily web logs. How can you display the different posts, one by one? </p><p>In th<a id="id154" class="indexterm"/>e following example you pass all the <code class="literal">post_id</code> made by an author in your template and the template designer writes the following code to display it properly in the template:</p><div class="informalexample"><pre class="programlisting">&lt;?
$posts = getAllPosts(); //example function return all post ids of this author
for($i = 0; $i&lt;count($posts); $i++) 
{
  $title = getPostTitle($post[$i]);
  echo $title;
  $author = getPostAuthor($post[$i]);
  $content = parseBBCode(getPostContent($post[$i]));
  echo "Content";
  $comments = getAllComments($post[$i]);
  for ($j=0; $j&lt;count($comments); $j++)
  {
    $commentAuthor = getCommentAuthor($comments[$j]);
    echo $commentAuthor;
    $comment = getCommentContent($comments[$j]);
    echo $comment;
  }
}
?&gt;</pre></div><p>In this example we do everything in the template; we fetch all post ids, then get authors, comments, content, and display it. We also fetch the comments list in the template code. The whole code is too hazy to read and manage and may crash successively at any core changes. But just think, if we turn the comments into a collection of comment object for that post and all the posts into a collection of post object for easier accessing, it will remove the burden of template designing as well as create manageable code. </p><p>Let u<a id="id155" class="indexterm"/>s implement Iterator pattern for our comments and posts and see how effectively it turns your code into a readable piece of poem. After all, coding is poetry.</p><p>To use iteration effectively in PHP5 we can use <code class="literal">Iterator</code> interface. The interface is shown below: </p><div class="informalexample"><pre class="programlisting">&lt;?
interface Iterator 
{
  function rewind();

  function current();

  function key();

  function next();

  function valid();
}
?&gt;</pre></div><p>The <code class="literal">rewind()</code> function of Iterator sets the index to the start of collection. The <code class="literal">Current()</code> returns the current object. <code class="literal">key()</code> function returns the current key. The Function <code class="literal">next()</code> returns if there are more object ahead in the current loop counter. If the return is yes, this function returns true, otherwise it returns false. The <code class="literal">valid()</code> function returns the current object if it has any value in it. Let us create an Iterator for our post object.</p><p>We will create a function named <code class="literal">getAllPosts()</code> that will return all posts from the DB. All these posts are returned as a <code class="literal">Post</code> object, which has methods like <code class="literal">getAuthor()</code>, <code class="literal">getTitle()</code>, <code class="literal">getDate()</code>, <code class="literal">getComments()</code>, etc. Now we will create the Iterator:<a id="id156" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">&lt;?php
class Posts implements Iterator
{
  private $posts = array();

  public function __construct($posts)
  {
    if (is_array($posts)) {
      $this-&gt;posts = $posts;
    }
  }

  public function rewind() {
    reset($this-&gt;posts);
  }

  public function current() {
    return current($this-&gt;posts);
  }

  public function key() {
    return key($this-&gt;var);
  }

  public function next() {
    return next($this-&gt;var);
  }

  public function valid() {
    return ($this-&gt;current() !== false);
  }
}
?&gt;</pre></div><a id="id157" class="indexterm"/><p>Now let's use the Iterator we just created.</p><div class="informalexample"><pre class="programlisting">&lt;?
$blogposts = getAllPosts();
$posts = new Posts($posts);
foreach ($posts as $post)
{
  echo $post-&gt;getTitle();
  echo $post-&gt;getAuthor();
  echo $post-&gt;getDate();
  echo $post-&gt;getContent();
  $comments = new Comments($post-&gt;getComments()); 
  //another Iterator for comments, code is same as Posts
  foreach ($comments as $comment)
  {
    echo $comment-&gt;getAuthor();
    echo $comment-&gt;getContent();
  }
}
?&gt;</pre></div><p>The code becomes much readable and maintainable now. </p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>In PHP array, object implements this Iterator interface by default. But of course you can implement it to add many more user-defined functionalities to ease your development cycle. </p></div></div></div>
<div class="section" title="Observer Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec47"/>Observer Pattern</h1></div></div></div><a id="id158" class="indexterm"/><a id="id159" class="indexterm"/><p>You might wonder how these events actually work and how they are raised. Well, if you are familiar with the Observer pattern, you can create event driven applications easier than ever.</p><p>An Observer pattern solves a common problem in OOP. For example, if you want some objects to be notified automatically when something happens (an event raised), you can solve that problem with this pattern. Let us take a closer look. </p><p>An Observer pattern consists of two types of objects; one is an observable object, which is observed by <code class="literal">observer</code> object. When the state of an observable object changes, it notifies all observers registered with it. <a id="id160" class="indexterm"/>
</p><p>So where can it be used? Actually it is being used everywhere. Think about a logging application, which can log errors in different ways when an error occurs. Think about a messenger application, which pops up when the latest message arrives. Think about a web bulletin board where the latest messages display automatically whenever a new message is posted. Well, there are thousands more. Let us implement this pattern.</p><div class="mediaobject"><img src="graphics/2561_01_01_200.jpg" alt="Observer Pattern"/></div><p>O<a id="id161" class="indexterm"/>ur entire <code class="literal">observer</code> objects implement <code class="literal">observer</code> interface as shown below: </p><div class="informalexample"><pre class="programlisting">&lt;?
interface observer
{
  public function notify();
}
?&gt;</pre></div><p>Now some <code class="literal">observer</code> objects, which we will notify when the state of an observable object changes: </p><div class="informalexample"><pre class="programlisting">&lt;?
class YMNotifier implements observer 
{
  public function notify()
  {
    //send alerts using YM
    echo "Notifying via YM\n";
  }
};
?&gt;</pre></div><p>Another notifier:</p><div class="informalexample"><pre class="programlisting">&lt;?
class EmailNotifier implements observer 
{
  public function notify()
  {
    //send alerts using Email
    echo "Notifying via Email\n";
   }
};
?&gt;</pre></div><p>Now we need to create our <code class="literal">observer</code>.</p><div class="informalexample"><pre class="programlisting">&lt;?
class observable
{
  private $observers = array();

  public function register($object)
  {
    if ($object instanceof observer )
    $this-&gt;observers[] =$object; 
    else 
    echo "The object must implement observer interface\n";
  }
  public function stateChange()
  {
    foreach ($this-&gt;observers as $observer)
    {
      $observer-&gt;notify();
    }
  }
}
?&gt;</pre></div><p>Now let us use it:</p><div class="informalexample"><pre class="programlisting">
<a id="id162" class="indexterm"/>&lt;?
$postmonitor = new observable();
$ym = new YMNotifier();
$em = new EmailNotifier();
$s= new stdClass();
$postmonitor-&gt;register($ym);
$postmonitor-&gt;register($em);
$postmonitor-&gt;register($s);
$postmonitor-&gt;stateChange();
?&gt;</pre></div><p>The output is as follows:</p><div class="informalexample"><pre class="programlisting">The object must implement observer interface
Notifying via YM
Notifying via Email </pre></div></div>
<div class="section" title="Proxy Pattern or Lazy Loading"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec48"/>Proxy Pattern or Lazy Loading</h1></div></div></div><p>Another very important programming practice in OOP is lazy loading and loose coupling. The main idea is to decrease the concrete dependency among objects while coding. What is the benefit of such programming? One simple answer—it always increases the portability of your code. </p><p>Using the Proxy pattern you can create a local version of a remote object. It provides a common API for accessing methods of a remote object without knowing the things behind the scene. The best example of a Proxy pattern could be the XML RPC and SOAP client and server for PHP. </p><a id="id163" class="indexterm"/><p>Let's take a look at the following code. Here we are creating a class, which can access any method of a remotely created object. The methods of a remote object are exposed via the XML RPC server and then they are accessed via XML RPC clients. </p><div class="mediaobject"><img src="graphics/2561_04_06.jpg" alt="Proxy Pattern or Lazy Loading"/></div><p>If you are wondering how it works, you will find that almost every blog engine supports three popular blogging API: i.e. Blogger, MetaWebLog, and MovableType. Using these methods you can remotely manage your blog. Which methods are supported, will depend on the blog engine. </p><p>We will use Incutio PHP XML-RPC library to create a sample server and client object. Let us create a server first. You can download the XML-RPC Library from here:<a class="ulink" href="http://scripts.incutio.com/xmlrpc/IXR_Library.inc.php.txt">http://scripts.incutio.com/xmlrpc/IXR_Library.inc.php.txt</a>
</p><p>We are creating a time server from which we can get Greenwich Mean Time (GMT): </p><div class="informalexample"><pre class="programlisting">&lt;?php

include('IXR_Library.inc.php');

function gmtTime() {
    return gmdate("F, d Y H:i:s");
}

$server = new IXR_Server(array(
    'time.getGMTTime' =&gt; 'gmtTime',
));

?&gt;</pre></div><p>Well very simple. We just create some methods and then map them to the XML RPC server. Now let us see how we can code for clients:</p><div class="informalexample"><pre class="programlisting">&lt;<a id="id164" class="indexterm"/>?
include('IXR_Library.inc.php');
$client = new IXR_Client('http://localhost/proxy/server.php');

if (!$client-&gt;query('time.getGMTTime')) 
{
    die('Something went wrong - '.$client-&gt;getErrorCode().' : 
                                 '.$client-&gt;getErrorMessage());
}

echo ($client-&gt;getResponse());
?&gt;</pre></div><p>If you place the server in your web server (here <code class="literal">localhost</code>) document, the root in a folder named <code class="literal">proxy</code> and then access the client, you will get the following output: </p><p>
<span class="strong"><strong>March, 28 2007 16:13:20</strong></span>
</p><p>That's it! This is how Proxy pattern works and gives interface to remote objects for local applications. </p></div>
<div class="section" title="Decorator Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec49"/>Decorator Pattern</h1></div></div></div><p><a id="id165" class="indexterm"/>
<a id="id166" class="indexterm"/>Decorator pattern is an important problem-solving approach introduced by GoF in their legendary design pattern book. Using this pattern you can add additional functionalities in an existing object without extending an object. So you might ask what is the benefit of adding additional functionalities without inheritance. </p><p>Well, there certainly are some benefits. To extend an object, sometimes you need to know many inner things of that class. Sometimes it's not possible to extend the class without rewriting the existing functionalities. If you want to add the same functionalities to many types of objects, it is much better to add them using Decorator pattern instead of extending all of them individually. Otherwise it might lead you to a horrible maintenance nightmare.</p><div class="mediaobject"><img src="graphics/2561_04_08.jpg" alt="Decorator Pattern"/></div><p>Let us go for a common scenario. Fo<a id="id167" class="indexterm"/>r example, imagine that you are building a blog or message board where all your posts and comments come as separate post and comment objects. Both of these objects have a common method <code class="literal">getContents()</code> which returns the filtered content of that post or comment. </p><p>Now your manager is asking to add functionalities to parse emoticon and BBCode of those posts and comments. The core code is complex and you don't want to touch it anymore. Here Decorator pattern comes to save your life. </p><p>Let us see our <code class="literal">Post</code> and <code class="literal">Comment</code> object first. </p><div class="informalexample"><pre class="programlisting">&lt;?
class Post
{
  private $title;
  private $content;
  //additional properties

  public function filter()
  {
    //do necessary processing
    $this-&gt;content = $filtered_content;
    $this-&gt;title = $filtered_title;
  }

  public function getContent()
  {
    return $this-&gt;content;
  }

  //additional methods
}
?&gt;
&lt;?
class Comment
{
  private $date;
  private $content;
  //additional properties

  public function filter()
  {
    //do necessary processing
    $this-&gt;content = $filtered_content;
  }

  public function getContent()
  {
    return $this-&gt;content;
  }

  //additional methods
}
?&gt;</pre></div><p>Now<a id="id168" class="indexterm"/> we create two Decorator objects, which can parse the BBCode and Emoticon respectively: </p><div class="informalexample"><pre class="programlisting">&lt;?
class BBCodeParser
{
  private $post;
  public function __construct($object)
  {
    $this-&gt;post = $object;
  }

  public function getContent()
  {
    //parse bbcode
  $post-&gt;filter();
    $content = $this-&gt;parseBBCode($post-&gt;getContent());
    return $content;
  }

  private function parseBBCode($content)
  {
    //process BB code in the content and return it
  }
}
?&gt; </pre></div><p>And here comes the emoticon parser:</p><div class="informalexample"><pre class="programlisting">&lt;?<a id="id169" class="indexterm"/>
class EmoticonParser
{
  private $post;
  public function __construct($object)
  {
    $this-&gt;post = $object;
  }

  public function getContent()
  {
    //parse bbcode
    $post-&gt;filter();
    $content = $this-&gt;parseEmoticon($post-&gt;getContent());
    return $content;
  }

  private function parseEmoticon($content)
  {
    //process Emoticon code in the content and return it
  }

}
?&gt;</pre></div><p>These Decorator objects just add the BBCode and EmoticonCode parsing capability to the existing objects without touching them. </p><p>Let us see how we can use that:</p><div class="informalexample"><pre class="programlisting">&lt;?
$post = new Post();//set the properties of the post object
$comment = new Comment();//set the properties of the comment object

$post-&gt;filter();
$comment-&gt;filter();

if ($BBCodeEnabled==false &amp;&amp; $EmoticonEnabled==false)
{
  $PostContent = $post-&gt;getContent();
  $CommentContent = $comment-&gt;getContent();
}
elseif ($BBCodeEnabled==true &amp;&amp; $EmoticonEnabled==false)
{
  $bb = new BBCodeParser($post);//passing a post object to 
                                //BBCodeParser
  $PostContent = $bb-&gt;getContent();

  $bb = new BBCodeParser($comment);//passing a comment object to 
                                   //BBCodeParser

  $CommentContent = $bb-&gt;getContent();
}

elseif ($BBCodeEnabled==true &amp;&amp; $EmoticonEnabled==false)
{
  $em = new EmoticonParser($post);
  $PostContent = $bb-&gt;getContent();
  $em = new EmoticonParser($comment);
  $CommentContent = $bb-&gt;getContent();
}
?&gt;</pre></div><p>This is how you can add additional functionalities to existing objects without even touching them. However, you saw that BBCodeParser and EmoticonParser accept any object, which means that if you supply an object, which doesn't have any method named <code class="literal">getContent()</code>, the code will crash. So you can implement a common interface in those objects, which you might want to decorate. Also in the Decorator object you can accept only those objects, which implement that or those interfaces. </p></div>
<div class="section" title="Active Record Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec50"/>Active Record Pattern</h1></div></div></div><p><a id="id170" class="indexterm"/>
<a id="id171" class="indexterm"/>This is another very important design pattern to simplify database manipulation. We will learn more about this pattern in Chapter 7. </p></div>
<div class="section" title="Facade Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec51"/>Facade Pattern</h1></div></div></div><p>So <a id="id172" class="indexterm"/>
<a id="id173" class="indexterm"/>far we have learned many common problem-solving approaches using design patterns in OOP. Here comes another interesting pattern, which we often use unintentionally in our code without knowing that it is also a pattern. Let us learn about this common pattern named Facade pattern. </p><p>Facade provides a common interface to many objects. In other words, it just simplifies the programming providing a necessary interface, which actually uses a lot of other objects behind the scenes. Thus it minimizes the learning curve for developers. When a new developer joins the team, he suddenly gets introduced to a lot of objects with tons of methods and properties, among which he might need a few to accomplish his work. So why bother spending time learning them all? This is where Facade helps developers and saves a lot of their time. Let's look at some examples to understand it more clearly. </p><p>Sup<a id="id174" class="indexterm"/>pose you are creating an apartment rental system, where you have three objects in your repository. One object performs the geocoding with the help of online geocoding services. Another object locates that place using a map service. Finally, another service searches all the apartments for sale in that area. </p><p>Now you want to create an easier interface over these three so that any future developer can work with your library instead of studying them all together. The following picture shows us the code structure before there is a Facade:</p><div class="mediaobject"><img src="graphics/2561_04_09.jpg" alt="Facade Pattern"/></div><p>Here is the code structure after using Facade:</p><div class="mediaobject"><img src="graphics/2561_04_10.jpg" alt="Facade Pattern"/></div><p>Now let us take a look at the code:</p><div class="informalexample"><pre class="programlisting">&lt;?
class ApartmentFinder
{

  public function locateApartments($place)
  {
    //use the web service and locate all apartments suitable 
    //search name
    //now return them all in an array
    return $apartmentsArray();
  }
}
?&gt;

&lt;?
class GeoLocator
{
  public function getLocations($place)
  {
    //use public geo coding service like yahoo and get the 
    //lattitude and
    //longitude of that place

   <a id="id175" class="indexterm"/> return array("lat"=&gt;$lattitude, "lng"=&gt;$longitude);
  }
}
?&gt;

&lt;?
class GoogleMap
{
  public function initialize()
  {
    //do initialize

  }

  public function drawLocations($locations /* array */)
  {
    //locate all the points using Google Map Locator
  }

  public function dispatch($divid)
  {
    //draw the map with in a div with the div id
  }
}
?&gt;</pre></div><p>These are our concrete classes. Now you want to develop a Facade using all of them and provide an easier interface for developers. See how easy it makes combining three of them:</p><div class="informalexample"><pre class="programlisting">&lt;?
class Facade
{

  public function findApartments($place, $divid)
  {
    $AF = new ApartmentFinder();
    $GL =new GeoLocator();
    $GM = new GoogleMap();

    $apartments = $AF-&gt;locateApartments($place);
    foreach ($apartments as $apartment)
    {
      $locations[] = $GL-&gt;getLocations($apartment);
    }

    $GM-&gt;initialize();
    $GM-&gt;drawLocations($locations);
    $GM-&gt;dispatch($divid);
  }

}
?&gt;</pre></div><p>Anyone can now use the service of all three classes using only one single interface Facade: </p><div class="informalexample"><pre class="programlisting">&lt;?
$<a id="id176" class="indexterm"/>F = new Facade();
$F-&gt;findApartments("London, Greater London","mapdiv");
?&gt;</pre></div><p>As I said before, in object oriented programming we have done this type of job several times in our times in our project, however we might not have known that the technique is defined as a design pattern named Facade. </p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec52"/>Summ<a id="id177" class="indexterm"/>ary
</h1></div></div></div><p>Design patterns are an essential part of OOP. It makes your code more effective, better performing, and easier to maintain. Sometimes we implement these design patterns in our code without knowing that these solutions are defined as design patterns. There are many design patterns as well, which we cannot cover in this book, because it would then simply be a book on just design patterns. However, if you are interested in learning other design patterns, you can read <span class="emphasis"><em>Head First Design Patterns</em></span> published by O'reilly and <span class="emphasis"><em>Design Patterns Explained</em></span> by Addison-Wesley.</p><p>Don't think that you have to implement design pattern in your code. Use them only when you need them. Proper usage of correct patterns can make your code perform better; similarly using them improperly could make your code slow and less efficient. </p><p>In the next chapter we will learn about another important section of OOP in PHP. That is Unit testing and Reflections. Until then, keep playing with the patterns and explore them. </p></div></body></html>