- en: Chapter 8. Using Existing PHP Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。使用现有的PHP框架
- en: In the same way that you wrote your framework with PHP, other people did it
    too. It did not take long for people to realize that entire frameworks were reusable
    too. Of course, one man's meat is another man's poison, and as with many other
    examples in the IT world, loads of frameworks started to appear. You will never
    hear about most of them, but a handful of these frameworks got quite a lot of
    users.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你用PHP编写框架一样，其他人也在做同样的事情。人们很快意识到整个框架也是可重用的。当然，对某人是肉的人对另一个人来说是毒药，正如IT世界中的许多其他例子一样，大量的框架开始出现。你永远不会听说其中大多数，但其中一些框架获得了相当多的用户。
- en: 'As we write, there are four or five main frameworks that most PHP developers
    know of: **Symfony** and **Zend Framework** were the main characters of this last
    PHP generation, but Laravel is also there, providing a lightweight and fast framework
    for those who need fewer features. Due to the nature of this book, we will focus
    on the latest ones, **Silex** and **Laravel**, as they are quick enough to learn
    in a chapter—or at least their basics are.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写的时候，有四到五个主要的框架是大多数PHP开发者所熟知的：**Symfony**和**Zend Framework**是上一代PHP的主要角色，但Laravel也在其中，为那些需要较少特性的开发者提供了一个轻量级且快速的框架。由于这本书的性质，我们将重点关注最新的框架，**Silex**和**Laravel**，因为它们足够快，可以在一章中学习——至少它们的基础是。
- en: 'In this chapter, you will learn about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: The importance of frameworks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架的重要性
- en: Other features of frameworks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架的其他特性
- en: Working with Laravel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Laravel
- en: Writing applications with Silex
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Silex编写应用程序
- en: Reviewing frameworks
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查框架
- en: 'In [Chapter 6](part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 6. Adapting to MVC"), *Adapting to MVC*, we barely introduced the idea
    of frameworks using the MVC design pattern. In fact, we did not explain what a
    framework is; we just developed a very simple one. If you are looking for a definition,
    here it is: a framework is the structure that you choose to build your program
    on. Let''s discuss this in more detail.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851 "第6章。适应MVC")《适应MVC》中，我们只是简要介绍了使用MVC设计模式的框架概念。实际上，我们没有解释什么是框架；我们只是开发了一个非常简单的框架。如果你在寻找一个定义，这里就是：框架是你选择用来构建程序的结构。让我们更详细地讨论这个问题。
- en: The purpose of frameworks
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架的目的
- en: When you write an application, you need to add your models, views, and controllers
    if you use the MVC design pattern, which we really encourage you to do. These
    three elements, together with the JavaScript and CSS files that complete your
    views, are the ones that differentiate your application from others. There is
    no way you can skip on writing them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个应用程序时，如果你使用MVC设计模式，你需要添加你的模型、视图和控制器，我们强烈建议你这样做。这三个元素，加上完成你视图的JavaScript和CSS文件，是使你的应用程序与其他应用程序区分开来的因素。你无法跳过编写它们。
- en: On the other hand, there is a set of classes that, even though you need them
    for the correct functioning of your application, they are common to all other
    applications, or at least, they are very similar. Examples of these classes are
    the ones we have in the `src/Core` directory, such as the router, the configuration
    reader, and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有一组类，尽管你需要它们来正确运行你的应用程序，但它们对所有其他应用程序都是通用的，或者至少非常相似。这些类的例子包括我们在`src/Core`目录中拥有的，比如路由器、配置读取器等等。
- en: 'The purpose of frameworks is clear and necessary: they add some structure to
    your application and connect the different elements of it. In our example, it
    helped us route the HTTP requests to the correct controller, connect to the database,
    and generate dynamic HTML as the response. However, the idea that has to strive
    is the reusability of frameworks. If you had to write the framework each time
    you start an application, would that be okay?'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的目的明确且必要：它们为你的应用程序添加一些结构，并连接其不同元素。在我们的例子中，它帮助我们路由HTTP请求到正确的控制器，连接到数据库，并生成动态HTML作为响应。然而，必须努力实现的是框架的可重用性。如果你每次开始一个应用程序时都必须编写框架，那会好吗？
- en: So, in order for a framework to be useful, it must be easy to reuse in different
    environments. This means that the framework has to be downloaded from a source,
    and it has to be easy to install. Download and install a dependency? It seems
    Composer is going to be useful again! Even though this was quite different some
    years ago, nowadays, all the main frameworks can be installed using Composer.
    We will show you how to in a bit.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了使框架有用，它必须易于在不同的环境中重用。这意味着框架必须从源下载，并且必须易于安装。下载并安装依赖项？看来Composer又要派上用场了！尽管这在几年前相当不同，但现在，所有主要框架都可以使用Composer安装。我们将在稍后向您展示如何操作。
- en: The main parts of a framework
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架的主要部分
- en: If we open source our framework so that other developers can make use of it,
    we need to structure our code in a way that is intuitive. We need to reduce the
    learning curve as much as we can; nobody wants to spend weeks on learning how
    to work with a framework.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将我们的框架开源，以便其他开发者可以使用它，我们需要以直观的方式组织我们的代码。我们需要尽可能减少学习曲线；没有人愿意花几周时间来学习如何使用一个框架。
- en: As MVC is the de facto web design pattern used in web applications, most frameworks
    will separate the three layers, model, view, and controller, in three different
    directories. Depending on the framework, they will be under a `src/` directory,
    even though it is quite common to find the views outside of this directory, as
    we did with our own. Nevertheless, most frameworks will give you enough flexibility
    to decide where to place each of the layers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在Web应用程序中实际使用的MVC设计模式，大多数框架都会将模型、视图和控制器这三个层次分别放在三个不同的目录中。根据框架的不同，它们可能会位于`src/`目录下，尽管将视图放在这个目录之外是很常见的，就像我们自己的做法一样。然而，大多数框架都会给你足够的灵活性来决定每个层次放置的位置。
- en: The rest of the classes that complete the frameworks used to be all grouped
    in a separate directory—for example, `src/Core`. It is important to separate these
    elements from yours so that you do not mix the code and modify a core class unintentionally,
    thus messing up the whole framework. Even better, this last generation of PHP
    frameworks used to incorporate the core components as independent modules, which
    will be required via Composer. In doing so, the framework's `composer.json` file
    will require all the different components, such as routers, configuration, database
    connections, loggers, template engine, and so on, and Composer will download them
    in the `vendor/` directory, making them available with the autogenerated autoloader.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，框架中其余的类通常都放在一个单独的目录中——例如，`src/Core`。将它们与你的代码分开是很重要的，这样你就不会无意中混淆代码并修改核心类，从而搞乱整个框架。更好的是，这一代PHP框架通常将核心组件作为独立的模块来整合，这些模块将通过Composer来要求。这样做，框架的`composer.json`文件将要求所有不同的组件，如路由器、配置、数据库连接、日志记录器、模板引擎等，Composer将在`vendor/`目录中下载它们，并通过自动生成的自动加载器使它们可用。
- en: Separating the different components in different codebases has many benefits.
    First of all, it allows different teams of developers to work in an isolated way
    with the different components. Maintaining them is also easier as the code is
    separated enough not to affect each other. Finally, it allows the end user to
    choose which components to get for his application in an attempt to customize
    the framework, leaving out those heavy components that are not used.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的代码库中分离不同的组件有许多好处。首先，它允许不同的开发团队以隔离的方式使用不同的组件进行工作。由于代码足够分离，不会相互影响，因此维护它们也更容易。最后，它允许最终用户为其应用程序选择要获取哪些组件，以尝试自定义框架，排除那些未使用的重型组件。
- en: 'Either the framework is organized in independent modules or everything is together;
    however, there are always the same common components, which are:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 框架要么是组织成独立的模块，要么是所有内容都在一起；然而，总是有相同的常见组件，它们是：
- en: '**The router**: This is the class that, given an HTTP request, finds the correct
    controller, instantiates it, and executes it, returning the HTTP response.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由器**：这是一个类，给定一个HTTP请求，找到正确的控制器，实例化它并执行它，然后返回HTTP响应。'
- en: '**The request**: This contains a handful of methods that allows you to access
    parameters, cookies, headers, and so on. This is mostly used by the router and
    sent to the controller.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求处理**：这包含了一些方法，允许你访问参数、cookies、headers等。这通常由路由器使用，并发送到控制器。'
- en: '**The configuration handler**: This allows you to get the correct configuration
    file, read it, and use its contents to configure the rest of the components.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置处理器**：这允许你获取正确的配置文件，读取它，并使用其内容来配置其他组件。'
- en: '**The template engine**: This merges HTML with content from the controller
    in order to render the template with the response.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板引擎**：它将HTML与控制器中的内容合并，以便在响应中渲染模板。'
- en: '**The logger**: This adds entries to a log file with the errors or other messages
    that we consider important.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录器**：它将错误或其他我们认为重要的消息添加到日志文件中。'
- en: '**The dependency injector**: This manages all the dependencies that your classes
    need. Maybe the framework does not have a dependency injector, but it has something
    similar—that is, a service locator—which tries to help you in a similar way.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入器**：它管理你的类需要的所有依赖项。也许框架没有依赖注入器，但它有类似的东西——即服务定位器——它试图以类似的方式帮助你。'
- en: '**The way you can write and run your unit tests**: Most of the time, the frameworks
    include PHPUnit, but there are more options in the community.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写和运行单元测试的方式**：大多数框架都包含PHPUnit，但社区中还有更多选择。'
- en: Other features of frameworks
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架的其他特性
- en: Most frameworks have more than just the features that we described in the previous
    section, even though these are enough to build simple applications as you already
    did by yourself. Still, most web applications have a lot more common features,
    so the frameworks tried to implement generic solutions to each of them. Thanks
    to this, we do not have to reinvent the wheel with features that virtually all
    medium and big web applications need to implement. We will try to describe some
    of the most useful ones so that you have a better idea when choosing a framework.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经在上一节中描述了框架的一些特性，但大多数框架的功能远不止这些，即使这些功能已经足够构建简单的应用程序，就像你之前自己做的那样。然而，大多数Web应用程序还有更多常见的特性，因此框架试图为每个特性实现通用的解决方案。多亏了这一点，我们不需要在那些几乎所有中大型Web应用程序都需要实现的功能上重新发明轮子。我们将尝试描述一些最有用的特性，以便你在选择框架时有一个更好的想法。
- en: Authentication and roles
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证和角色
- en: Most websites enforce users to authenticate in order to perform some action.
    The reason for this is to let the system know whether the user trying to perform
    certain action has the right to do so. Therefore, managing users and their roles
    is something that you will probably end up implementing in all your web applications.
    The problem comes when way too many people try to attack your system in order
    to get the information of other users or performing actions authenticated as someone
    else, which is called **impersonification**. It is for this reason that your authentication
    and authorization systems should be as secure as possible—a task that is never
    easy.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网站强制用户进行身份验证才能执行某些操作。这样做的原因是让系统知道尝试执行特定操作的用户是否有权这样做。因此，管理用户及其角色是你在所有Web应用程序中可能最终要实现的事情。问题是当太多的人试图攻击你的系统以获取其他用户的信息或以他人的身份执行操作时，这被称为**冒充**。正因为如此，你的身份验证和授权系统应该尽可能安全——这是一项永远都不容易的任务。
- en: Several frameworks include a pretty secure way of managing users, permissions,
    and sessions. Most of the time, you can manage this through a configuration file
    probably by pointing the credentials to a database where the framework can add
    the user data, your customized roles, and some other customizations. The downside
    is that each framework has its own way of configuring it, so you will have to
    dig into the documentation of the framework you are using at this time. Still,
    it will save you more time than if you had to implement it by yourself.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 几个框架包括一种相当安全的方式来管理用户、权限和会话。大多数情况下，你可以通过配置文件来管理这些，可能是指定凭据到一个数据库，框架可以在其中添加用户数据、你自定义的角色和一些其他自定义设置。缺点是每个框架都有自己的配置方式，因此你将不得不深入研究你当前使用的框架的文档。尽管如此，这还是比你自己实现它节省更多时间。
- en: ORM
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ORM
- en: '**Object-relational mapping** (**ORM**) is a technique that converts data from
    a database or any other data storage into objects. The main goal is to separate
    the business logic as much as possible from the structure of the database and
    to reduce the complexity of your code. When using ORM, you will probably never
    write a query in MySQL; instead, you will use a chain of methods. Behind the scenes,
    ORM will write the query with each method invocation.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象关系映射（ORM**）是一种将数据库或任何其他数据存储中的数据转换为对象的技术。主要目标是尽可能地将业务逻辑与数据库的结构分离，并减少代码的复杂性。当使用ORM时，你很可能永远不会在MySQL中编写查询；相反，你将使用方法链。在幕后，ORM将在每次方法调用时编写查询。'
- en: There are good and bad things when using ORM. On one hand, you do not have to
    remember all the SQL syntax all the time and only the correct methods to invoke,
    which can be easier if you work with an IDE that can autocomplete methods. It
    is also good to abstract your code from the type of storage system, because even
    though it is not very common, you might want to change it later. If you use ORM,
    you probably have to change only the type of connection, but if you were writing
    raw queries, you would have a lot of work to do in order to migrate your code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ORM既有好的一面也有不好的一面。一方面，你不必总是记住所有的SQL语法，只需记住正确的调用方法，如果你与一个可以自动完成方法的IDE一起工作，这可能会更容易。将你的代码从存储系统的类型中抽象出来也是一件好事，因为尽管这并不常见，但你可能以后想改变它。如果你使用ORM，你可能只需要更改连接的类型，但如果你编写原始查询，你将不得不做很多工作来迁移你的代码。
- en: The arguable downside of using ORM could be that it may be quite difficult to
    write complicated queries using method chains, and you will end up writing them
    manually. You are also at the mercy of ORM in order to speed up the performance
    of your queries, whereas when writing them manually, it is you who can choose
    better what and how to use when querying. Finally, something that OOP purists
    complain about quite a lot is that using ORM fills your code with a large amount
    of dummy objects, similar to the domain objects that you already know.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ORM的潜在缺点可能是，使用方法链编写复杂的查询可能相当困难，你最终可能需要手动编写它们。你也会受到ORM的支配，以便加快查询的性能，而当你手动编写它们时，你可以选择在查询时更好地使用什么和如何使用。最后，面向对象编程（OOP）的纯粹主义者相当多抱怨的是，使用ORM会让你的代码充满大量的虚拟对象，类似于你已知的领域对象。
- en: As you can see, using ORM is not always an easy decision, but just in case you
    choose to use it, most of the big frameworks include one. Take your time in deciding
    whether or not to use one in your applications; in case you do, choose wisely
    which one. You might end up requiring an ORM different from the one that the framework
    provides.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，使用对象关系映射（ORM）并不总是容易的决定，但如果你选择使用它，大多数大型框架都包含一个。在你决定是否在你的应用程序中使用ORM时，请花些时间；如果你决定使用，请明智地选择哪一个。你可能会发现你需要一个与框架提供的ORM不同的ORM。
- en: Cache
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: The bookstore is a pretty good example that may help in describing the cache
    feature. It has a database of books that is queried every time that someone either
    lists all the books or asks for the details of a specific one. Most of the time
    the information related to books will be the same; the only change would be the
    stock of the books from time to time. We could say that our system has way more
    reads than writes, where reads means querying for data and writes means updating
    it. In this kind of system, it seems like a waste of time and resources to access
    the database each time, knowing that most of the time, we will get the same results.
    This feeling increases if we do some expensive transformation to the data that
    we retrieve.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 书店是一个很好的例子，可以帮助描述缓存功能。它有一个数据库，每次有人列出所有书籍或请求特定一本书的详细信息时都会查询这个数据库。大多数时候，与书籍相关的信息将是相同的；唯一的变化是书籍的库存有时会变化。我们可以这样说，我们的系统有更多的读取操作而不是写入操作，其中读取意味着查询数据，写入意味着更新它。在这种类型的系统中，每次都访问数据库似乎是一种时间和资源的浪费，因为我们知道大多数时候，我们会得到相同的结果。如果我们对检索到的数据进行一些昂贵的转换，这种感觉会加剧。
- en: A **cache layer** allows the application to store temporary data in a storage
    system faster than our database, usually in memory rather than disk. Even though
    cache systems are getting more complex, they usually allow you to store data by
    key-value pairs, as in an array.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存层**允许应用程序在比数据库更快的存储系统中存储临时数据，通常是在内存中而不是在磁盘上。尽管缓存系统变得越来越复杂，但它们通常允许你通过键值对存储数据，就像在数组中一样。'
- en: 'The idea is not to access the database for data that we know is the same as
    the last time we accessed it in order to save time and resources. Implementations
    can vary quite a lot, but the main flow is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 策略不是为了节省时间和资源，而访问数据库获取我们知道与上次访问时相同的数据。实现方式可能大相径庭，但主要流程如下：
- en: You try to access a certain piece of data for the first time. We ask the cache
    whether a certain key is there, which it is not.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你试图首次访问某些数据。我们询问缓存是否存在某个键，它不存在。
- en: You query the database, getting back the result. After processing it—and maybe
    transforming it to your domain objects—you store the result in the cache. The
    key would be the same you used in step 1, and the value would be the object/array/JSON
    that you generated.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你查询数据库，获取结果。在处理它——也许将其转换为你的领域对象——之后，你将结果存储在缓存中。键将与步骤1中使用的相同，而值将是您生成的对象/数组/JSON。
- en: You try to access the same piece of data again. You ask the cache whether the
    key is there; here, it is, so you do not need to access the database at all.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你试图再次访问同一份数据。你询问缓存该键是否存在；这里，它存在，因此你根本不需要访问数据库。
- en: 'It seems easy, right? The main problem with caches comes when we need to invalidate
    a certain key. How and when should we do it? There are a couple of approaches
    that are worth mentioning:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单，但缓存的主要问题在于我们需要使某个键失效时。我们应该如何以及何时进行操作？有几个值得注意的方法：
- en: You will set an expiration time to the key-value pair in the cache. After this
    time passes, the cache will remove the key-value pair automatically, so you will
    have to query the database again. Even though this system might work for some
    applications, it does not for ours. If the stock changes to 0 before the cache
    expires, the user will see books that they cannot borrow or buy.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将为缓存中的键值对设置一个过期时间。在此时间过后，缓存将自动移除键值对，因此你需要再次查询数据库。尽管这个系统可能适用于某些应用程序，但对我们来说并不适用。如果库存在缓存过期之前变为0，用户将看到他们无法借阅或购买的书。
- en: The data never expires, but each time we make a change in the database, we will
    identify which keys in the cache are affected by this change and then purge them.
    This is ideal since the data will be in the cache until it is no longer valid,
    whether this is 2 seconds or 3 weeks. The downside is that identifying these keys
    could be a hard task depending on your data structure. If you miss deleting some
    of them, you will have corrupted data in your cache, which is quite difficult
    to debug and detect.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据永远不会过期，但每次我们在数据库中做出更改时，我们都会确定哪些缓存中的键受到此更改的影响，然后清除它们。这是理想的，因为数据将保留在缓存中，直到它不再有效，无论是2秒还是3周。缺点是，根据你的数据结构，确定这些键可能是一项艰巨的任务。如果你遗漏了删除其中的一些，你的缓存中将会出现损坏的数据，这非常难以调试和检测。
- en: You can see that cache is a double-edged sword, so we would recommend you to
    only use it when necessary and not just because your framework comes with it.
    As with ORM, if you are not convinced by the cache system that your framework
    provides, using a different one should not be difficult. In fact, your code should
    not be aware of which cache system you are using except when creating the connection
    object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到缓存是一把双刃剑，所以我们建议你仅在必要时使用它，而不仅仅是因为你的框架自带它。与ORM一样，如果你对你框架提供的缓存系统不满意，使用另一个系统不应该很难。实际上，你的代码不应该知道你正在使用哪个缓存系统，除非在创建连接对象时。
- en: Internationalization
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 国际化
- en: 'English is not the only language out there, and you would like to make your
    website as accessible as possible. Depending on your target, it would be a good
    idea to have your website translated to other languages too, but how do you do
    this? We hope that by now you did not answer: "Copy-pasting all the templates
    and translating them". This is way too inefficient; when making a little change
    in a template, you need to replicate the change everywhere.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 英语并不是唯一的语言，你希望你的网站尽可能易于访问。根据你的目标，将你的网站翻译成其他语言也是一个好主意，但你怎么做呢？我们希望你现在没有回答：“复制粘贴所有模板并翻译它们”。这太低效了；当你在模板中做一点改动时，你需要将改动复制到每个地方。
- en: There are tools that can be integrated with either controllers and/or template
    engines in order to translate strings. You usually keep a file for each language
    that you have, in which you will add all the strings that need to be translated
    plus their translation. One of the most common formats for this is PO files, in
    which you have a map of key-value pairs with originally translated pairs. Later
    on, you will invoke a `translate` method sending the original string, which will
    return the translated string depending on the language you selected.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可以与控制器和/或模板引擎集成，以翻译字符串。你通常会为每种语言保留一个文件，在其中添加所有需要翻译的字符串及其翻译。这种格式中最常见的是 PO
    文件，其中包含原始翻译的键值对映射。稍后，你将调用一个 `translate` 方法，发送原始字符串，它将根据你选择的语言返回翻译后的字符串。
- en: When writing templates, it might be tiring to invoke the translation each time
    you want to display a string, but you will end up with only one template, which
    is much easier to maintain than any other option.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写模板时，每次你想显示一个字符串时调用翻译可能会感到疲倦，但最终你将只有一个模板，这比任何其他选项都更容易维护。
- en: Usually, internationalization is very much tied to the framework that you use;
    however, if you have the opportunity to use the system of your choice, pay special
    attention to its performance, the translation files it uses, and how it manages
    strings with parameters—that is, how we can ask the system to translate messages
    such as "Hello %s, who are you?" in which "%s" needs to be injected each time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，国际化与国际上使用的框架紧密相关；然而，如果你有机会使用你选择的系统，请特别注意其性能、它使用的翻译文件以及它如何管理带参数的字符串——也就是说，我们如何请求系统翻译像“Hello
    %s, who are you?”这样的消息，其中“%s”需要每次都注入。
- en: Types of frameworks
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架的类型
- en: Now that you know quite a lot about what a framework can offer you, you are
    in a position to decide what kind of framework you would like to use. In order
    to make this decision, it might be useful to know what kinds of frameworks are
    available. This categorization is nothing official, just some guidelines that
    we offer you to make your choice easier.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对框架能为你提供什么有了相当多的了解，你就可以决定你想使用哪种类型的框架了。为了做出这个决定，了解可用的框架类型可能会有所帮助。这种分类并不是官方的，只是我们提供的一些指导，以帮助你更容易做出选择。
- en: Complete and robust frameworks
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整且健壮的框架
- en: This type of framework comes with the whole package. It contains all the features
    that we discussed earlier, so it will allow you to develop very complete applications.
    Usually, these frameworks allow you to create applications very easily with just
    a few configuration files that define things such as how to connect to a database,
    what kind of roles you need, or whether you want to use a cache. Other than this,
    you will just have to add your controllers, views, and models, which saves you
    a lot of time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的框架包含了一个完整的包。它包含了我们之前讨论的所有功能，因此它将允许你开发非常完整的应用程序。通常，这些框架允许你通过仅使用几个配置文件来轻松创建应用程序，这些配置文件定义了诸如如何连接到数据库、你需要什么类型的角色或你是否想使用缓存等内容。除此之外，你只需添加你的控制器、视图和模型，这可以为你节省大量时间。
- en: The problem with these frameworks is the learning curve. Given all the features
    they contain, you need to spend quite a lot of time on learning how to use each
    one, which is usually not very pleasant. In fact, most companies looking for web
    developers require that you have experience with the framework they use; otherwise,
    it will be a bad investment for them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些框架的问题在于学习曲线。鉴于它们包含的所有功能，你需要花费相当多的时间来学习如何使用每个框架，这通常并不愉快。事实上，大多数寻找网络开发者的公司都要求你有使用他们使用的框架的经验；否则，对他们来说这将是一个糟糕的投资。
- en: Another thing you should consider when choosing these frameworks is whether
    they are structured in modules or come as a huge monolith. In the first case,
    you will be able to choose which modules to use that add a lot of flexibility.
    On the other hand, if you have to stick with all of them, it might make your application
    slow even if you do not use all of the features.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择这些框架时，你还应该考虑它们是否以模块化结构构建或是一个庞大的单体。在前一种情况下，你将能够选择使用哪些模块，这提供了很大的灵活性。另一方面，如果你必须使用所有这些模块，即使你并不使用所有功能，这也可能使你的应用程序变慢。
- en: Lightweight and flexible frameworks
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轻量级且灵活的框架
- en: Even when working on a small application, you would like to use a framework
    to save you a lot of time and pain, but you should avoid using one of the larger
    frameworks as they will be too much to handle for what you really need. In this
    case, you should choose a lightweight framework, one that contains very few features,
    similar to what we implemented in previous chapters.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是在开发小型应用程序时，你也希望使用一个框架来节省大量时间和痛苦，但你应该避免使用大型框架，因为它们对于你真正需要的功能来说处理起来会过于复杂。在这种情况下，你应该选择一个轻量级框架，它包含非常少的功能，类似于我们在前几章中实现的那样。
- en: The benefit of these frameworks is that even though you get the basic features
    such as routing, you are completely free to implement the login system, cache
    layer, or internationalization system that suits your specific application better.
    In fact, you could build a more complete framework using this one as the base
    and then adding all the complements you need, making it completely customized.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些框架的好处是，尽管你获得了基本功能，如路由，但你完全自由地实现适合你特定应用的登录系统、缓存层或国际化系统。实际上，你可以使用这个作为基础构建一个更完整的框架，然后添加所有需要的补充，使其完全定制化。
- en: As you can note, both types have their pros and cons. It will be up to you to
    choose the correct one each time, depending on your needs, the time that you can
    spend, and the experience that you have with each one.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，这两种类型都有其优缺点。每次选择正确的类型将取决于你的需求、你可以投入的时间以及你对每种类型的经验。
- en: An overview of famous frameworks
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 知名框架概述
- en: You already have a good idea about what a framework can offer and what types
    there are. Now, it is time to review some of the most important ones out there
    so that you get an idea of where to start looking for your next PHP web application.
    Note that with the release of PHP 7, there will be quite a lot of new or improved
    PHP frameworks. Try to always be in the loop!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经对框架能提供什么以及有哪些类型有了很好的了解。现在，是时候回顾一些最重要的框架了，这样你就可以了解从哪里开始寻找你的下一个PHP网络应用程序。请注意，随着PHP
    7的发布，将会有相当多的新或改进的PHP框架。尽量保持跟进！
- en: Symfony 2
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Symfony 2
- en: Symfony has been one of the most favorite frameworks of developers during the
    last 10 years. After reinventing itself for its version 2, Symfony entered the
    generation of frameworks by modules. In fact, it is quite common to find other
    projects using Symfony 2 components mixed up with some other framework as you
    just need to add the name of the module in your Composer file to use it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的10年中，Symfony一直是开发者最喜欢的框架之一。在对其版本2进行自我革新之后，Symfony进入了模块化框架的世代。实际上，发现其他项目使用Symfony
    2组件与其他框架混合是很常见的，因为你只需在你的Composer文件中添加模块名称即可使用它。
- en: You can start applications with Symfony 2 by just executing a command. Symfony
    2 creates all the directories, empty configuration files, and so on ready for
    you. You can also add empty controllers from the command line. They use Doctrine
    2 as ORM, which is probably one of the most reliable ORMs that PHP can offer nowadays.
    For the template engine, you will find Twig, which is the same as what we used
    in our framework.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行一个命令来使用Symfony 2开始应用程序。Symfony 2为你创建所有目录、空配置文件等，一切准备就绪。你也可以从命令行添加空控制器。它们使用Doctrine
    2作为ORM，这可能是PHP现在能提供的最可靠的ORM之一。对于模板引擎，你会发现Twig，这是我们框架中使用的相同工具。
- en: In general, this is a very attractive framework with a huge community behind
    it giving support; plus, a lot of companies also use it. It is always worth at
    least checking the list of modules in case you do not want to use the whole framework
    but want to take advantage of some bits of it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这是一个非常吸引人的框架，背后有一个庞大的社区提供支持；此外，许多公司也在使用它。至少检查一下模块列表总是值得的，以防你不想使用整个框架，但想利用其中的一些部分。
- en: Zend Framework 2
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Zend Framework 2
- en: The second big PHP framework, at least since last year, is Zend Framework 2\.
    As with Symfony, it has been out there for quite a long time too. Also, as with
    any other modern framework, it is built in an OOP way, trying to implement all
    the good design patterns used for web applications. It is composed of multiple
    components that you can reuse in other projects, such as their well-known authentication
    system. It lacks some elements, such as a template engine—usually they mix PHP
    and HTML—and ORM, but you can easily integrate the ones that you prefer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第二大PHP框架，至少从去年开始，就是Zend Framework 2。与Symfony一样，它也已经存在很长时间了。同样，像任何其他现代框架一样，它是用面向对象的方式构建的，试图实现用于Web应用程序的所有良好设计模式。它由多个组件组成，您可以在其他项目中重用，例如他们知名的认证系统。它缺少一些元素，例如模板引擎——通常他们会混合PHP和HTML——以及ORM，但您可以轻松地集成您喜欢的那些。
- en: There is a lot of work going on in order to release Zend Framework 3, which
    will come with support for PHP 7, performance improvements, and some other new
    components. We recommend you to keep an eye on it; it could be a good candidate.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发布Zend Framework 3，目前正在进行大量工作，它将支持PHP 7、性能改进和一些其他新组件。我们建议您密切关注；它可能是一个不错的选择。
- en: Other frameworks
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他框架
- en: Even though Symfony and Zend Framework are the two big players, more and more
    PHP frameworks have appeared in these last years, evolving quite fast and bringing
    to the game more interesting features. Names such as CodeIgniter, Yii, PHPCake,
    and others will start to sound familiar as soon as you start browsing PHP projects.
    As some of them came into play later than Symfony and Zend Framework, they implement
    some new features that the others do not have, such as components related to JavaScript
    and jQuery, integration with Selenium for UI testing, and others.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Symfony和Zend Framework是两大主要玩家，但在过去的几年里，越来越多的PHP框架出现了，发展迅速，带来了更多有趣的功能。像CodeIgniter、Yii、PHPCake等名字，一旦您开始浏览PHP项目，就会变得熟悉起来。由于其中一些比Symfony和Zend
    Framework出现得晚，它们实现了一些其他框架没有的新功能，例如与JavaScript和jQuery相关的组件、与Selenium的UI测试集成等。
- en: Even though it is always a good thing to have diversification simply because
    you will probably get exactly what you need from one or the other, be smart when
    choosing your framework. The community plays an important role here because if
    you have any problem, it will help you to fix it or you can just help evolve the
    framework with each new PHP release.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管仅仅因为您可能会从其中一个或另一个中确切地得到您需要的东西，所以多样化总是好事，但在选择框架时也要明智。社区在这里扮演着重要角色，因为如果您有任何问题，它将帮助您解决问题，或者您可以帮助随着每个新的PHP版本而演变的框架。
- en: The Laravel framework
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Laravel框架
- en: Even though Symfony and Zend Framework have been the big players for quite a
    long time, during this last couple of years, a third framework came into play
    that has grown in popularity so much that nowadays it is the favorite framework
    among developers. Simplicity, elegant code, and high speed of development are
    the trump cards of this "framework for artisans". In this section, you will have
    a glance at what Laravel can do, taking the first steps to create a very simple
    application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Symfony和Zend Framework已经很长时间一直是主要玩家，但在过去的几年里，第三个框架开始崭露头角，其受欢迎程度增长如此之快，以至于如今它已成为开发者最喜欢的框架。简洁、优雅的代码和高开发速度是这个“工匠框架”的杀手锏。在本节中，您将一瞥Laravel能做什么，并迈出创建一个非常简单的应用程序的第一步。
- en: Installation
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'Laravel comes with a set of command-line tools that will make your life easier.
    Because of this, it is recommended to install it globally instead of per project—that
    is, to have Laravel as another program in your environment. You can still do this
    with Composer by running the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel附带了一套命令行工具，这将使您的生活更加轻松。因此，建议您全局安装它，而不是按项目安装——也就是说，将Laravel作为您环境中的另一个程序。您仍然可以通过运行以下命令使用Composer来完成此操作：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command should download the Laravel installer to `~/.composer/vendor`.
    In order to be able to use the executable from the command line, you will need
    to run something similar to this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应将Laravel安装程序下载到`~/.composer/vendor`。为了能够在命令行中使用可执行文件，您需要运行类似以下命令：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, you are able to use the `laravel` command. To ensure that everything went
    all right, just run the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`laravel`命令。为了确保一切顺利，只需运行以下命令：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If everything went OK, this should output the version installed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，这将输出已安装的版本。
- en: Project setup
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目设置
- en: 'Yes, we know. Every single tutorial starts by creating a blog. However, we
    are building web applications, and this is the easiest approach we can take that
    adds some value to you. Let''s start then; execute the following command wherever
    you want to add your application:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command will output something similar to what Composer does, simply because
    it fetches dependencies using Composer. After a few seconds, the application will
    hopefully tell you that everything was installed successfully and that you are
    ready to go.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Laravel created a new `php-blog` directory with quite a lot of content. You
    should have something similar to the directory structure shown in the following
    screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![Project setup](img/00036.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: 'Let''s set up the database. The first thing you should do is update the `.env`
    file with the correct database credentials. Update the `DB_DATABASE` values with
    your own; here''s an example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will also need to create the `php_blog` database. Do it with just one command,
    as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With Laravel, you have a migrations system; that is, you keep all the database
    schema changes under `database/migrations` so that anyone else using your code
    can quickly set up their database. The first step is to run the following command,
    which will create a migrations file for the `blogs` table:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Open the generated file, which should be something similar to `database/migrations/<date>_create_posts_table.php`.
    The `up` method defines the table blogs with an autoincremental ID and timestamp
    field. We would like to add a title, the content of the post, and the user ID
    that created it. Replace the `up` method with the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, the title will be a string, whereas the content is a text. The difference
    is in the length of these fields, string being a simple `VARCHAR` and text a `TEXT`
    data type. For the user ID we defined `INT UNSIGNED`, which references the `id`
    field of the `users` table. Laravel already defined the `users` table when creating
    the project, so you do not have to worry about it. If you are interested in how
    it looks, check the `database/migrations/2014_10_12_000000_create_users_table.php`
    file. You will note that a user is composed by an ID, a name, the unique e-mail,
    and the password.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have just written the migration files. In order to apply them, you
    need to run the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If everything went as expected, you should have a `blogs` table now similar
    to the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Project setup](img/00037.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: 'To finish with all the preparations, we need to create a model for our `blogs`
    table. This model will extend from **Illuminate\Database\Eloquent\Model**, which
    is the ORM that Laravel uses. To generate this model automatically, run the following
    command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The name of the model should be the same as that of the database table but in
    singular. After running this command, you can find the empty model in `app/Post.php`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Adding the first endpoint
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s add a quick endpoint just to understand how routes work and how to link
    controllers with templates. In order to avoid database access, let''s build the
    add new post view, which will display a form that allows the user to add a new
    post with a title and text. Let''s start by adding the route and controller. Open
    the `app/Http/routes.php` file and add the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These three very simple lines say that for the `/new` endpoint, we want to reply
    with the `new` view. Later on, we will complicate things here in the controller,
    but for now, let's focus on the views.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Laravel uses Blade as the template engine instead of Twig, but the way they
    work is quite similar. They can also define layouts from where other templates
    can extend. The place for your layouts is in `resources/views/layouts`. Create
    an `app.blade.php` file with the following content inside this directory, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is just a normal layout with a title, some CSS, and an `ul` list of sections
    in the body, which will be used as the navigation bar. There are two important
    elements to note here other than the HTML code that should already sound familiar:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a block, Blade uses the `@yield` annotation followed by the name
    of the block. In our layout, we defined two blocks: `css` and `content`.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a feature that allows you to build URLs in templates. We want to include
    the CSS file in `public/css/layout.css`, so we will use `URL::asset` to build
    this URL. It is also helpful to include JS files.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you saw, we included a `layout.css` file. CSS and JS files are stored under
    the `public` directory. Create yours in `public/css/layout.css` with the following
    code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can focus on our view. Templates are stored in `resources/views`, and,
    as with layouts, they need the `.blade.php` file extension. Create your view in
    `resources/views/new.blade.php` with the following content:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The syntax is quite intuitive. This template extends from the layouts'' one
    and defines two sections or blocks: `css` and `content`. The CSS file included
    follows the same format as the previous one. You can create it in `public/css/new.css`
    with content similar to the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The rest of the template just defines the POST form pointing to the same URL
    with title and text fields. Everything is ready to test it in your browser! Try
    accessing `http://localhost:8080/new` or the port number of your choice. You should
    see something similar to the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the first endpoint](img/00038.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: Managing users
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As explained before, user authentication and authorization is one of the features
    that most frameworks contain. Laravel makes our lives very easy by providing the
    user model and the registration and authentication controllers. It is quite easy
    to make use of them: you just need to add the routes pointing to the already existing
    controllers and add the views. Let''s begin.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five routes that you need to consider here. There are two that belong
    to the registration step, one to get the form and another one for the form to
    submit the information provided by the user. The other three are related to the
    authentication part: one to get the form, one to post the form, and one for the
    logout. All five of them are included in the `Auth\AuthController` class. Add
    to your `routes.php` file the following routes:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note how we defined these routes. As opposed to the one that we created previously,
    the second argument of these is a string with the concatenation of the controller's
    class name and method. This is a better way to create routes because it separates
    the logic to a different class that can later be reused and/or unit tested.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested, you can browse the code for this controller. You will
    find a complex design, where the functions the routes will invoke are actually
    part of two traits that the `AuthController` class uses: `RegistersUsers` and
    `AuthenticatesUsers`. Checking these methods will enable you to understand what
    goes on behind the scenes.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Each `get` route expects a view to render. For the user's registration, we need
    to create a template in `resources/views/auth/register.blade.php`, and for the
    login view, we need a template in `resources/views/auth/login.blade.php`. As soon
    as we send the correct POST parameters to the correct URL, we can add any content
    that we think necessary.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: User registration
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start with the registration form; this form needs four POST parameters:
    name, e-mail, password, and password confirmation, and as the route says, we need
    to submit it to `/auth/register`. The template could look similar to the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This template is quite similar to the form for new posts: it extends the layout,
    adds a CSS file, and populates the content section with a form. The new addition
    here is the use of the `old` function that retrieves the value submitted on the
    previous request in case that the form was not valid and we showed it back to
    the user.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we try it, we need to add a `register.css` file with the styles for
    this form. A simple one could be as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we should edit the layout in order to add a link on the menu pointing
    to the registration and login pages. This is as simple as adding the following
    `li` elements at the end of the `ul` tag:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add also the style for the `right` class at the end of `layout.css`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To make things even more useful, we could add the information for what went
    wrong when submitting the form. Laravel flashes the errors into the session, and
    they can be accessed via the `errors` template variable. As this is common to
    all forms and not only to the registration one, we could add it to the `app.blade.php`
    layout, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this piece of code, we will use Blade's `@if` conditional and `@foreach`
    loop. The syntax is the same as PHP; the only difference is the `@` prefix.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to go. Launch your application and click on the registration
    link on the right-hand side of the menu. Attempt to submit the form, but leave
    some fields blank so that we can note how the errors are displayed. The result
    should be something similar to this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![User registration](img/00039.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: 'One thing that we should customize is where the user will be redirected once
    the registration is successful. In this case, we can redirect them to the login
    page. In order to achieve this, you need to change the value of the `$redirectTo`
    property of `AuthController`. So far, we only have the new post page, but later,
    you could add any path that you want via the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: User login
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The user''s login has a few more changes other than the registration. We not
    only need to add the login view, we should also modify the menu in the layout
    in order to acknowledge the authenticated user, remove the register link, and
    add a logout one. The template, as mentioned earlier, has to be saved in `resources/views/auth/login.blade.php`.
    The form needs an e-mail and password and optionally a checkbox for the *remember
    me* functionality. An example could be the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The layout has to be changed slightly. Where we displayed the links to register
    and log in users, now we need to check whether there is a user already authenticated;
    if so, we should rather show a logout link. You can get the authenticated user
    through the `Auth::user()` method even from the view. If the result is not empty,
    it means that the user was authenticated successfully. Change the two links using
    the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Protected routes
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This last part of the user management session is probably the most important
    one. One of the main goals when authenticating users is to authorize them to certain
    content—that is, to allow them to visit certain pages that unauthenticated users
    cannot. In Laravel, you can define which routes are protected in this way by just
    adding the `auth` middleware. Update the new post route with the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Everything is ready! Try to access the new post page after logging out; you
    will be redirected automatically to the login page. Can you feel how powerful
    a framework can be?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Setting up relationships in models
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned before, Laravel comes with an ORM, Eloquent ORM, which makes
    dealing with models a very easy task. In our simple database, we defined one table
    for posts, and we already had another one for users. Posts contain the ID of the
    user that owns it—that is, `user_id`. It is good practice to use the singular
    of the name of the table followed by `_id` so that Eloquent will know where to
    look. This was all we did regarding the foreign key.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also mention this relationship on the model side. Depending on the
    type of the relationship (one to one, one to many, or many to many), the code
    will be slightly different. In our case, we have a one-to-many relationship because
    one user can have many posts. To say so in Laravel, we need to update both the
    `Post` and the `User` models. The `User` model needs to specify that it has many
    posts, so you need to add a `posts` method with the following content:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This method says that the model for users has many posts. The other change
    that needs to be made in `Post` is similar: we need to add a `user` method that
    defines the relationship. The method should be similar to this one:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It looks like very little, but this is the whole configuration that we need.
    In the next section, you will see how easy it is to save and query using these
    two models.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Creating complex controllers
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though the title of this section mentions complex controllers, you will
    note that we can create complete and powerful controllers with very little code.
    Let''s start by adding the code that will manage the creation of posts. This controller
    needs to be linked to the following route:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you can imagine, now, we need to create the `Post\PostController` class
    with the `createPost` method in it. Controllers should be stored in `app/Http/Controllers`,
    and if they can be organized in folders, it would be even better. Save the following
    class in `app/Http/Controllers/Post/PostController.php`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So far, the only two things we can note from this class are:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Controllers extend from the `App\Http\Controllers\Controller` class, which contains
    some general helpers for all the controllers.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods of controllers can get the `Illuminate\Http\Request` argument as the
    user's request. This object will contain elements such as the posted parameters,
    cookies, and so on. This is very similar to the one we created in our own application.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first thing we need to do in this kind of controller is check whether the
    parameters posted are correct. For this, we will use the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first thing we did is create a validator. For this, we used the `Validator::make`
    function and sent two arguments: the first one contains all the parameters from
    the request, and the second one is an array with the expected fields and their
    constraints. Note that we expect two required fields: `title` and `content`. Here,
    the first one can be up to 255 characters long, and the second one needs to be
    at least 20 characters long.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `validator` object is created, we can check whether the data posted
    by the user matches the requirements with the `fails` method. If it returns `true`—that
    is, the validation fails—we will redirect the user back to the previous page with
    `redirect()->back()`. To perform this invocation, we will add two more method
    calls: `withInput` will send the submitted values so that we can display them
    again, and `withErrors` will send the errors the same way `AuthController` did.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, it would be helpful to the user if we show the previously submitted
    title and text in case the post is not valid. For this, use the already known
    `old` method in the view:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At this point, we can already test how the controller behaves when the post
    does not match the required validations. If you miss any of the parameters or
    they do not have correct lengths, you will get an error page similar to the following
    one:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating complex controllers](img/00040.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now add the logic to save the post in case it is valid. If you remember
    the interaction with the models from our previous application, you will be gladly
    surprised at how easy it is to work with them here. Take a look at the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first thing we will do is create a `post` object setting the title and content
    from the request values. Then, given the result of `Auth::user()`, which gives
    us the instance of the currently authenticated user model, we will save the post
    that we just created through `posts()->save($post)`. If we wanted to save the
    post without the information of the user, we could use `$post->save()`. Really,
    that is all.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly add another endpoint to retrieve the list of posts for a given
    user so that we can take a look at how Eloquent ORM allows us to fetch data easily.
    Add the following route:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The way we retrieve data is very similar to how we save it. We need the instance
    of a model—in this case, the authenticated user—and we will add a concatenation
    of method invocations that will internally generate the query to execute. In this
    case, we will ask for the posts ordered by the creation date. In order to send
    information to the view, we need to pass a second argument, which will be an array
    of parameter names and values.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following template as `resources/views/posts.blade.php`, which will
    display the list of posts for the authenticated user as a table. Note how we will
    use the `$post` object, which is an instance of the model, in the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The lists of posts are finally displayed. The result should be something similar
    to the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating complex controllers](img/00041.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: Adding tests
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a very short time, we created an application that allows you to register,
    log in, and create and list posts from scratch. We will end this section by talking
    about how to test your Laravel application with PHPUnit.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: It is extremely easy to write tests in Laravel as it has a very nice integration
    with PHPUnit. There is already a `phpunit.xml` file, a customized `TestCase` class,
    customized assertions, and plenty of helpers in order to test with the database.
    It also allows you to test routes, emulating the HTTP request instead of testing
    the controllers. We will visit all these features while testing the creation of
    new posts.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to remove `tests/ExampleTest.php` because it tested the
    home page, and as we modified it, it will fail. Do not worry; this is an example
    test that helps developers to start testing, and making it fail is not a problem
    at all.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to create our new test. To do this, we can either add the file
    manually or use the command line and run the following command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This command creates the `tests/NewPostTest.php` file, which extends from `TestCase`.
    If you open it, you will note that there is already a dummy test, which you can
    also remove. Either way, you can run PHPUnit to make sure everything passes. You
    can do it in the same way we did previously, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The first test we can add is one where we try to add a new post but the data
    passed by the POST parameters is not valid. In this case, we should expect that
    the response contains errors and old data, so the user can edit it instead of
    rewriting everything again. Add the following test to the `NewPostTest` class:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first thing we can note in the test is the creation of a `user` instance
    using a factory. You can pass an array with any parameter that you want to set
    to the `make` invocation; otherwise, defaults will be used. After we get the `user`
    instance, we will send it to the `be` method to let Laravel know that we want
    that user to be the authorized one for this test.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Once we set the grounds for the test, we will use the `call` helper that will
    emulate a real HTTP request. To this method, we have to send the HTTP method (in
    this case, POST), the route to request, and optionally the parameters. Note that
    the `call` method returns the response object in case you need it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'We will send a title and the content, but this second one is not long enough,
    so we will expect some errors. Laravel comes with several customized assertions,
    especially when testing these kinds of responses. In this case, we could use two
    of them: `assertSessionHasErrors`, which checks whether there are any flash errors
    in the session (in particular, the ones for the content parameter), and `assertHasOldInput`,
    which checks whether the response contains old data in order to show it back to
    the user.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'The second test that we would like to add is the case where the user posts
    valid data so that we can save the post in the database. This test is trickier
    as we need to interact with the database, which is usually a not a very pleasant
    experience. However, Laravel gives us enough tools to help us in this task. The
    first and most important is to let PHPUnit know that we want to use database transactions
    for each test. Then, we need to persist the authenticated user in the database
    as the post has a foreign key pointing to it. Finally, we should assert that the
    post is saved in the database correctly. Add the following code to the `NewPostTest`
    class:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `DatabaseTransactions` trait will make the test to start a transaction at
    the beginning and then roll it back once the test is done, so we will not leave
    the database with data from tests. Saving the authenticated user in the database
    is also an easy task as the result of the factory is an instance of the user's
    model, and we can just invoke the `save` method on it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The `assertRedirectedTo` assertion will make sure that the response contains
    the valid headers that redirect the user to the specified URL. More interestingly,
    `seeInDatabase` will verify that there is an entity in the `posts` table, which
    is the first argument, with the data provided in the array, which is the second
    argument.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a lot of assertions, but as you can note, they are extremely
    useful, reducing what could be a long test to a very few lines. We recommend you
    to visit the official documentation for the full list.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The Silex microframework
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a taste of what Laravel can offer you, you most likely do not want to
    hear about minimalist microframeworks. Still, we think it is good to know more
    than one framework. You can get to know different approaches, be more versatile,
    and everyone will want you in their team.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: We chose Silex because it is a microframework, which is very different from
    Laravel, and also because it is part of the Symfony family. With this introduction
    to Silex, you will learn how to use your second framework, which is of a totally
    different type, and you will be one step closer to knowing Symfony as well, which
    is one of the big players.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: What is the benefit of microframeworks? Well, they provide the very basics—that
    is, a router, a simple dependency injector, request helpers, and so on, but this
    is the end of it. You have plenty of room to choose and build what you really
    need, including external libraries or even your own ones. This means that you
    can have a framework specially customized for each different project. In fact,
    Silex provides a handful of built-in service providers that you can integrate
    very easily, from template engines to logging or security.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s no news here. Composer does everything for you, as it does with Laravel.
    Execute the following command on your command line at the root of your new project
    in order to include Silex in your `composer.json` file:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You may require more dependencies, but let's add them when we need them.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Project setup
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Silex''s most important class is `Silex\Application`. This class, which extends
    from **Pimple** (a lightweight dependency injector), manages almost anything.
    You can use it as an array as it implements the `ArrayAccess` interface, or you
    could invoke its methods to add dependencies, register services, and so on. The
    first thing to do is to instantiate it in your `public/index.php` file, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Managing configuration
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the first things we like to do is load the configuration. We could do
    something very simple, such as including a file with PHP or JSON content, but
    let''s make use of one of the service providers, `ConfigServiceProvider`. Let''s
    add it with Composer via the following line:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This service allows us to have multiple configuration files, one for each environment
    we need. Imagining that we want to have two environments, `prod` and `dev`, this
    means we need two files: one in `config/prod.json` and one in `config/dev.json`.
    The `config/dev.json` file would look similar to this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `config/prod.json` file would look similar to this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In order to work in a development environment, you will need to set the correct
    value to the environment variable by running the following command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `APP_ENV` environment variable will be the one telling us which environment
    we are in. Now, it is time to use this service provider. In order to register
    it by reading from the configuration file of the current environment, add the
    following lines to your `index.php` file:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The first thing we did here is to get the environment from the environment
    variable. By default, we set it to `prod`. Then, we invoked `register` from the
    `$app` object to add an instance of `ConfigServiceProvider` by passing the correct
    configuration file path. From now on, the `$app` "array" will contain three entries:
    `debug`, `cache`, and `db` with the content of the configuration files. We will
    be able to access them whenever we have access to `$app`, which will be mostly
    everywhere.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Setting the template engine
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another of the handy service providers is Twig. As you might remember, Twig
    is the template engine that we used in our own framework, and it is, in fact,
    from the same people that developed Symfony and Silex. You also already know how
    to add the dependency with Composer; simply run the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To register the service, we will need to add the following lines in our `public/index.php`
    file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Also, create the `views/` directory where we will later store our templates.
    Now, you have the `Twig_Environment` instance available by just accessing `$app['twig']`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Adding a logger
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last one of the service providers that we will register for now is the
    logger. This time, the library to use is **Monolog**, and you can include this
    via the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The quickest way to register a service is by just providing the path of the
    log file, which can be done as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you would like to add more information to this service provider, such as
    what level of logs you want to save, the name of the log, and so on, you can add
    them to the array together with the log file. Take a look at the documentation
    at [http://silex.sensiolabs.org/doc/providers/monolog.html](http://silex.sensiolabs.org/doc/providers/monolog.html)
    for the full list of parameters available.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: As with the template engine, from now on, you can access the `Monolog\Logger`
    instance from the `Application` object by accessing `$app['monolog']`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Adding the first endpoint
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is time to see how the router works in Silex. We would like to add a simple
    endpoint for the home page. As we already mentioned, the `$app` instance can manage
    almost anything, including routes. Add the following code at the end of the `public/index.php`
    file:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This is a similar way of adding routes to the one that Laravel follows. We
    invoked the `get` method as it is a GET endpoint, and we passed the route string
    and the `Application` instance. As we mentioned here, `$app` also acts as a dependency
    injector—in fact, it extends from one: Pimple—so you will notice the `Application`
    instance almost everywhere. The result of the anonymous function will be the response
    that we will send to the user—in this case, a rendered Twig template.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, this will not do the trick. In order to let Silex know that you
    are done setting up your application, you need to invoke the `run` method at the
    very end of the `public/index.php` file. Remember that if you need to add anything
    else to this file, it has to be before this line:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You have already worked with Twig, so we will not spend too much time on this.
    The first thing to add is the `views/home.twig` template:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, as you might have already guessed, we will add the `views/layout.twig`
    template, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Try accessing the home page of your application; you should get the following
    result:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the first endpoint](img/00042.jpeg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: Accessing the database
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this section, we will write an endpoint that will create recipes for our
    cookbook. Run the following MySQL queries in order to set up the `cookbook` database
    and create the empty `recipes` table:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Silex does not come with any ORM integration, so you will need to write your
    SQL queries by hand. However, there is a Doctrine service provider that gives
    you a simpler interface than the one PDO offers, so let''s try to integrate it.
    To install this, run the following command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, we are ready to register the service provider. As with the rest of services,
    add the following code to your `public/index.php` before the route definitions:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: When registering, you need to provide the options for the database connection.
    Some of them will be the same regardless of the environment, such as the driver
    or even the host, but some will come from the configuration file, such as `$app['database']['user']`.
    From now on, you can access the database connection via `$app['db']`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'With the database set up, let''s add the routes that will allow us to add and
    fetch recipes. As with Laravel, you can specify either the anonymous function,
    as we already did, or a controller and method to execute. Replace the current
    route with the following three routes:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As you can observe, there will be a new controller, `CookBook\Controllers\RecipesController`,
    which will be placed in `src/Controllers/RecipesController.php`. This means that
    you need to change the autoloader in Composer. Edit your `composer.json` file
    with the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, let''s add the controller class, as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The first method we will add is the `getNewForm` method, which will just render
    the add a new recipe page. The method looks similar to this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The method will just render `new_recipe.twig`. An example of this template
    could be as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This template sends the name, ingredients, instructions, and the time that
    it takes to prepare the dish. The endpoint that will get this form needs to get
    the response object in order to extract this information. In the same way that
    we could get the `Application` instance as an argument, we can get the `Request`
    one too if we specify it in the method definition. Accessing the POST parameters
    is as easy as invoking the `get` method by sending the name of the parameter or
    calling `$request->request->all()` to get all of them as an array. Add the following
    method that checks whether all the data is valid and renders the form again if
    it is not, sending the submitted data and errors:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `layout.twig` template needs to be edited too in order to show the errors
    returned. We can do this by executing the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'At this point, you can already try to access `http://localhost/recipes`, fill
    the form leaving something empty, submitting, and getting the form back with the
    errors. It should look something similar to this (with some extra CSS styles):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing the database](img/00043.jpeg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: 'The continuation of the controller should allow us to store the correct data
    as a new recipe in the database. To do so, it would be a good idea to create a
    separate class, such as `CookBook\Models\RecipeModel`; however, to speed things
    up, let''s add the following few lines that would go into the model to the controller.
    Remember that we have the Doctrine service provider, so there is no need to use
    PDO directly:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Doctrine also helps when fetching data. To see it working, check the third
    and final method, in which we will fetch all the recipes in order to show the
    user:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'With only one line, we performed a query. It is not as clean as the Eloquent
    ORM of Laravel, but at least it is much less verbose than using raw PDO. Finally,
    you can update your `home.twig` template with the following content in order to
    display the recipes that we just fetched from the database:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Silex versus Laravel
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though we did some similar comparison before starting the chapter, it is
    time to recapitulate what we said and compare it with what you noted by yourself.
    Laravel belongs to the type of framework that allows you to create great things
    with very little work. It contains all the components that you, as a web developer,
    will ever need. There has to be some good reason for how fast it became the most
    popular framework of the year!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Silex is a microframework, which by itself does very little.
    It is just the skeleton on which you can build the framework that you exactly
    need. It already provides quite a lot of service providers, and we did not discuss
    even half of them; we recommend you to visit [http://silex.sensiolabs.org/doc/providers.html](http://silex.sensiolabs.org/doc/providers.html)
    for the full list. However, if you prefer, you can always add other dependencies
    with Composer and use them. If, for some reason, you stop liking the ORM or the
    template engine that you use, or it just happens that a new and better one appears
    in the community, switching them should be easy. On the other hand, when working
    with Laravel, you will probably stick to what it comes with it.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: There is always an occasion for each framework, and we would like to encourage
    you to be open to all the possibilities that there are out there, keep up to date,
    and explore new frameworks or technologies from time to time.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how important it is to know some of the most important
    frameworks. You also learned the basics of two famous ones: Laravel and Silex.
    Now, you are ready to either use your framework or to use these two for your next
    application. With this, you also have the capacity to take any other similar framework
    and understand it easily.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will study what REST APIs are and how to write one with
    Laravel. This will expand your set of skills and give you more flexibility for
    when you need to decide which approach to take when designing and writing applications.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
