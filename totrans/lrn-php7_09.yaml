- en: Chapter 8. Using Existing PHP Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the same way that you wrote your framework with PHP, other people did it
    too. It did not take long for people to realize that entire frameworks were reusable
    too. Of course, one man's meat is another man's poison, and as with many other
    examples in the IT world, loads of frameworks started to appear. You will never
    hear about most of them, but a handful of these frameworks got quite a lot of
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we write, there are four or five main frameworks that most PHP developers
    know of: **Symfony** and **Zend Framework** were the main characters of this last
    PHP generation, but Laravel is also there, providing a lightweight and fast framework
    for those who need fewer features. Due to the nature of this book, we will focus
    on the latest ones, **Silex** and **Laravel**, as they are quick enough to learn
    in a chapter—or at least their basics are.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other features of frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Laravel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing applications with Silex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 6](part0056_split_000.html#1LCVG1-edcc22b134104d5db0bf3aa086c86851
    "Chapter 6. Adapting to MVC"), *Adapting to MVC*, we barely introduced the idea
    of frameworks using the MVC design pattern. In fact, we did not explain what a
    framework is; we just developed a very simple one. If you are looking for a definition,
    here it is: a framework is the structure that you choose to build your program
    on. Let''s discuss this in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you write an application, you need to add your models, views, and controllers
    if you use the MVC design pattern, which we really encourage you to do. These
    three elements, together with the JavaScript and CSS files that complete your
    views, are the ones that differentiate your application from others. There is
    no way you can skip on writing them.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there is a set of classes that, even though you need them
    for the correct functioning of your application, they are common to all other
    applications, or at least, they are very similar. Examples of these classes are
    the ones we have in the `src/Core` directory, such as the router, the configuration
    reader, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of frameworks is clear and necessary: they add some structure to
    your application and connect the different elements of it. In our example, it
    helped us route the HTTP requests to the correct controller, connect to the database,
    and generate dynamic HTML as the response. However, the idea that has to strive
    is the reusability of frameworks. If you had to write the framework each time
    you start an application, would that be okay?'
  prefs: []
  type: TYPE_NORMAL
- en: So, in order for a framework to be useful, it must be easy to reuse in different
    environments. This means that the framework has to be downloaded from a source,
    and it has to be easy to install. Download and install a dependency? It seems
    Composer is going to be useful again! Even though this was quite different some
    years ago, nowadays, all the main frameworks can be installed using Composer.
    We will show you how to in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: The main parts of a framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we open source our framework so that other developers can make use of it,
    we need to structure our code in a way that is intuitive. We need to reduce the
    learning curve as much as we can; nobody wants to spend weeks on learning how
    to work with a framework.
  prefs: []
  type: TYPE_NORMAL
- en: As MVC is the de facto web design pattern used in web applications, most frameworks
    will separate the three layers, model, view, and controller, in three different
    directories. Depending on the framework, they will be under a `src/` directory,
    even though it is quite common to find the views outside of this directory, as
    we did with our own. Nevertheless, most frameworks will give you enough flexibility
    to decide where to place each of the layers.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the classes that complete the frameworks used to be all grouped
    in a separate directory—for example, `src/Core`. It is important to separate these
    elements from yours so that you do not mix the code and modify a core class unintentionally,
    thus messing up the whole framework. Even better, this last generation of PHP
    frameworks used to incorporate the core components as independent modules, which
    will be required via Composer. In doing so, the framework's `composer.json` file
    will require all the different components, such as routers, configuration, database
    connections, loggers, template engine, and so on, and Composer will download them
    in the `vendor/` directory, making them available with the autogenerated autoloader.
  prefs: []
  type: TYPE_NORMAL
- en: Separating the different components in different codebases has many benefits.
    First of all, it allows different teams of developers to work in an isolated way
    with the different components. Maintaining them is also easier as the code is
    separated enough not to affect each other. Finally, it allows the end user to
    choose which components to get for his application in an attempt to customize
    the framework, leaving out those heavy components that are not used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Either the framework is organized in independent modules or everything is together;
    however, there are always the same common components, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The router**: This is the class that, given an HTTP request, finds the correct
    controller, instantiates it, and executes it, returning the HTTP response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The request**: This contains a handful of methods that allows you to access
    parameters, cookies, headers, and so on. This is mostly used by the router and
    sent to the controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The configuration handler**: This allows you to get the correct configuration
    file, read it, and use its contents to configure the rest of the components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The template engine**: This merges HTML with content from the controller
    in order to render the template with the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The logger**: This adds entries to a log file with the errors or other messages
    that we consider important.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The dependency injector**: This manages all the dependencies that your classes
    need. Maybe the framework does not have a dependency injector, but it has something
    similar—that is, a service locator—which tries to help you in a similar way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The way you can write and run your unit tests**: Most of the time, the frameworks
    include PHPUnit, but there are more options in the community.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other features of frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most frameworks have more than just the features that we described in the previous
    section, even though these are enough to build simple applications as you already
    did by yourself. Still, most web applications have a lot more common features,
    so the frameworks tried to implement generic solutions to each of them. Thanks
    to this, we do not have to reinvent the wheel with features that virtually all
    medium and big web applications need to implement. We will try to describe some
    of the most useful ones so that you have a better idea when choosing a framework.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most websites enforce users to authenticate in order to perform some action.
    The reason for this is to let the system know whether the user trying to perform
    certain action has the right to do so. Therefore, managing users and their roles
    is something that you will probably end up implementing in all your web applications.
    The problem comes when way too many people try to attack your system in order
    to get the information of other users or performing actions authenticated as someone
    else, which is called **impersonification**. It is for this reason that your authentication
    and authorization systems should be as secure as possible—a task that is never
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: Several frameworks include a pretty secure way of managing users, permissions,
    and sessions. Most of the time, you can manage this through a configuration file
    probably by pointing the credentials to a database where the framework can add
    the user data, your customized roles, and some other customizations. The downside
    is that each framework has its own way of configuring it, so you will have to
    dig into the documentation of the framework you are using at this time. Still,
    it will save you more time than if you had to implement it by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Object-relational mapping** (**ORM**) is a technique that converts data from
    a database or any other data storage into objects. The main goal is to separate
    the business logic as much as possible from the structure of the database and
    to reduce the complexity of your code. When using ORM, you will probably never
    write a query in MySQL; instead, you will use a chain of methods. Behind the scenes,
    ORM will write the query with each method invocation.'
  prefs: []
  type: TYPE_NORMAL
- en: There are good and bad things when using ORM. On one hand, you do not have to
    remember all the SQL syntax all the time and only the correct methods to invoke,
    which can be easier if you work with an IDE that can autocomplete methods. It
    is also good to abstract your code from the type of storage system, because even
    though it is not very common, you might want to change it later. If you use ORM,
    you probably have to change only the type of connection, but if you were writing
    raw queries, you would have a lot of work to do in order to migrate your code.
  prefs: []
  type: TYPE_NORMAL
- en: The arguable downside of using ORM could be that it may be quite difficult to
    write complicated queries using method chains, and you will end up writing them
    manually. You are also at the mercy of ORM in order to speed up the performance
    of your queries, whereas when writing them manually, it is you who can choose
    better what and how to use when querying. Finally, something that OOP purists
    complain about quite a lot is that using ORM fills your code with a large amount
    of dummy objects, similar to the domain objects that you already know.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, using ORM is not always an easy decision, but just in case you
    choose to use it, most of the big frameworks include one. Take your time in deciding
    whether or not to use one in your applications; in case you do, choose wisely
    which one. You might end up requiring an ORM different from the one that the framework
    provides.
  prefs: []
  type: TYPE_NORMAL
- en: Cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bookstore is a pretty good example that may help in describing the cache
    feature. It has a database of books that is queried every time that someone either
    lists all the books or asks for the details of a specific one. Most of the time
    the information related to books will be the same; the only change would be the
    stock of the books from time to time. We could say that our system has way more
    reads than writes, where reads means querying for data and writes means updating
    it. In this kind of system, it seems like a waste of time and resources to access
    the database each time, knowing that most of the time, we will get the same results.
    This feeling increases if we do some expensive transformation to the data that
    we retrieve.
  prefs: []
  type: TYPE_NORMAL
- en: A **cache layer** allows the application to store temporary data in a storage
    system faster than our database, usually in memory rather than disk. Even though
    cache systems are getting more complex, they usually allow you to store data by
    key-value pairs, as in an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is not to access the database for data that we know is the same as
    the last time we accessed it in order to save time and resources. Implementations
    can vary quite a lot, but the main flow is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You try to access a certain piece of data for the first time. We ask the cache
    whether a certain key is there, which it is not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You query the database, getting back the result. After processing it—and maybe
    transforming it to your domain objects—you store the result in the cache. The
    key would be the same you used in step 1, and the value would be the object/array/JSON
    that you generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You try to access the same piece of data again. You ask the cache whether the
    key is there; here, it is, so you do not need to access the database at all.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It seems easy, right? The main problem with caches comes when we need to invalidate
    a certain key. How and when should we do it? There are a couple of approaches
    that are worth mentioning:'
  prefs: []
  type: TYPE_NORMAL
- en: You will set an expiration time to the key-value pair in the cache. After this
    time passes, the cache will remove the key-value pair automatically, so you will
    have to query the database again. Even though this system might work for some
    applications, it does not for ours. If the stock changes to 0 before the cache
    expires, the user will see books that they cannot borrow or buy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data never expires, but each time we make a change in the database, we will
    identify which keys in the cache are affected by this change and then purge them.
    This is ideal since the data will be in the cache until it is no longer valid,
    whether this is 2 seconds or 3 weeks. The downside is that identifying these keys
    could be a hard task depending on your data structure. If you miss deleting some
    of them, you will have corrupted data in your cache, which is quite difficult
    to debug and detect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see that cache is a double-edged sword, so we would recommend you to
    only use it when necessary and not just because your framework comes with it.
    As with ORM, if you are not convinced by the cache system that your framework
    provides, using a different one should not be difficult. In fact, your code should
    not be aware of which cache system you are using except when creating the connection
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'English is not the only language out there, and you would like to make your
    website as accessible as possible. Depending on your target, it would be a good
    idea to have your website translated to other languages too, but how do you do
    this? We hope that by now you did not answer: "Copy-pasting all the templates
    and translating them". This is way too inefficient; when making a little change
    in a template, you need to replicate the change everywhere.'
  prefs: []
  type: TYPE_NORMAL
- en: There are tools that can be integrated with either controllers and/or template
    engines in order to translate strings. You usually keep a file for each language
    that you have, in which you will add all the strings that need to be translated
    plus their translation. One of the most common formats for this is PO files, in
    which you have a map of key-value pairs with originally translated pairs. Later
    on, you will invoke a `translate` method sending the original string, which will
    return the translated string depending on the language you selected.
  prefs: []
  type: TYPE_NORMAL
- en: When writing templates, it might be tiring to invoke the translation each time
    you want to display a string, but you will end up with only one template, which
    is much easier to maintain than any other option.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, internationalization is very much tied to the framework that you use;
    however, if you have the opportunity to use the system of your choice, pay special
    attention to its performance, the translation files it uses, and how it manages
    strings with parameters—that is, how we can ask the system to translate messages
    such as "Hello %s, who are you?" in which "%s" needs to be injected each time.
  prefs: []
  type: TYPE_NORMAL
- en: Types of frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know quite a lot about what a framework can offer you, you are
    in a position to decide what kind of framework you would like to use. In order
    to make this decision, it might be useful to know what kinds of frameworks are
    available. This categorization is nothing official, just some guidelines that
    we offer you to make your choice easier.
  prefs: []
  type: TYPE_NORMAL
- en: Complete and robust frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This type of framework comes with the whole package. It contains all the features
    that we discussed earlier, so it will allow you to develop very complete applications.
    Usually, these frameworks allow you to create applications very easily with just
    a few configuration files that define things such as how to connect to a database,
    what kind of roles you need, or whether you want to use a cache. Other than this,
    you will just have to add your controllers, views, and models, which saves you
    a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with these frameworks is the learning curve. Given all the features
    they contain, you need to spend quite a lot of time on learning how to use each
    one, which is usually not very pleasant. In fact, most companies looking for web
    developers require that you have experience with the framework they use; otherwise,
    it will be a bad investment for them.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing you should consider when choosing these frameworks is whether
    they are structured in modules or come as a huge monolith. In the first case,
    you will be able to choose which modules to use that add a lot of flexibility.
    On the other hand, if you have to stick with all of them, it might make your application
    slow even if you do not use all of the features.
  prefs: []
  type: TYPE_NORMAL
- en: Lightweight and flexible frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even when working on a small application, you would like to use a framework
    to save you a lot of time and pain, but you should avoid using one of the larger
    frameworks as they will be too much to handle for what you really need. In this
    case, you should choose a lightweight framework, one that contains very few features,
    similar to what we implemented in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of these frameworks is that even though you get the basic features
    such as routing, you are completely free to implement the login system, cache
    layer, or internationalization system that suits your specific application better.
    In fact, you could build a more complete framework using this one as the base
    and then adding all the complements you need, making it completely customized.
  prefs: []
  type: TYPE_NORMAL
- en: As you can note, both types have their pros and cons. It will be up to you to
    choose the correct one each time, depending on your needs, the time that you can
    spend, and the experience that you have with each one.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of famous frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You already have a good idea about what a framework can offer and what types
    there are. Now, it is time to review some of the most important ones out there
    so that you get an idea of where to start looking for your next PHP web application.
    Note that with the release of PHP 7, there will be quite a lot of new or improved
    PHP frameworks. Try to always be in the loop!
  prefs: []
  type: TYPE_NORMAL
- en: Symfony 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Symfony has been one of the most favorite frameworks of developers during the
    last 10 years. After reinventing itself for its version 2, Symfony entered the
    generation of frameworks by modules. In fact, it is quite common to find other
    projects using Symfony 2 components mixed up with some other framework as you
    just need to add the name of the module in your Composer file to use it.
  prefs: []
  type: TYPE_NORMAL
- en: You can start applications with Symfony 2 by just executing a command. Symfony
    2 creates all the directories, empty configuration files, and so on ready for
    you. You can also add empty controllers from the command line. They use Doctrine
    2 as ORM, which is probably one of the most reliable ORMs that PHP can offer nowadays.
    For the template engine, you will find Twig, which is the same as what we used
    in our framework.
  prefs: []
  type: TYPE_NORMAL
- en: In general, this is a very attractive framework with a huge community behind
    it giving support; plus, a lot of companies also use it. It is always worth at
    least checking the list of modules in case you do not want to use the whole framework
    but want to take advantage of some bits of it.
  prefs: []
  type: TYPE_NORMAL
- en: Zend Framework 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second big PHP framework, at least since last year, is Zend Framework 2\.
    As with Symfony, it has been out there for quite a long time too. Also, as with
    any other modern framework, it is built in an OOP way, trying to implement all
    the good design patterns used for web applications. It is composed of multiple
    components that you can reuse in other projects, such as their well-known authentication
    system. It lacks some elements, such as a template engine—usually they mix PHP
    and HTML—and ORM, but you can easily integrate the ones that you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot of work going on in order to release Zend Framework 3, which
    will come with support for PHP 7, performance improvements, and some other new
    components. We recommend you to keep an eye on it; it could be a good candidate.
  prefs: []
  type: TYPE_NORMAL
- en: Other frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though Symfony and Zend Framework are the two big players, more and more
    PHP frameworks have appeared in these last years, evolving quite fast and bringing
    to the game more interesting features. Names such as CodeIgniter, Yii, PHPCake,
    and others will start to sound familiar as soon as you start browsing PHP projects.
    As some of them came into play later than Symfony and Zend Framework, they implement
    some new features that the others do not have, such as components related to JavaScript
    and jQuery, integration with Selenium for UI testing, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Even though it is always a good thing to have diversification simply because
    you will probably get exactly what you need from one or the other, be smart when
    choosing your framework. The community plays an important role here because if
    you have any problem, it will help you to fix it or you can just help evolve the
    framework with each new PHP release.
  prefs: []
  type: TYPE_NORMAL
- en: The Laravel framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though Symfony and Zend Framework have been the big players for quite a
    long time, during this last couple of years, a third framework came into play
    that has grown in popularity so much that nowadays it is the favorite framework
    among developers. Simplicity, elegant code, and high speed of development are
    the trump cards of this "framework for artisans". In this section, you will have
    a glance at what Laravel can do, taking the first steps to create a very simple
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Laravel comes with a set of command-line tools that will make your life easier.
    Because of this, it is recommended to install it globally instead of per project—that
    is, to have Laravel as another program in your environment. You can still do this
    with Composer by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command should download the Laravel installer to `~/.composer/vendor`.
    In order to be able to use the executable from the command line, you will need
    to run something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you are able to use the `laravel` command. To ensure that everything went
    all right, just run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If everything went OK, this should output the version installed.
  prefs: []
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Yes, we know. Every single tutorial starts by creating a blog. However, we
    are building web applications, and this is the easiest approach we can take that
    adds some value to you. Let''s start then; execute the following command wherever
    you want to add your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command will output something similar to what Composer does, simply because
    it fetches dependencies using Composer. After a few seconds, the application will
    hopefully tell you that everything was installed successfully and that you are
    ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Laravel created a new `php-blog` directory with quite a lot of content. You
    should have something similar to the directory structure shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project setup](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s set up the database. The first thing you should do is update the `.env`
    file with the correct database credentials. Update the `DB_DATABASE` values with
    your own; here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also need to create the `php_blog` database. Do it with just one command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With Laravel, you have a migrations system; that is, you keep all the database
    schema changes under `database/migrations` so that anyone else using your code
    can quickly set up their database. The first step is to run the following command,
    which will create a migrations file for the `blogs` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the generated file, which should be something similar to `database/migrations/<date>_create_posts_table.php`.
    The `up` method defines the table blogs with an autoincremental ID and timestamp
    field. We would like to add a title, the content of the post, and the user ID
    that created it. Replace the `up` method with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, the title will be a string, whereas the content is a text. The difference
    is in the length of these fields, string being a simple `VARCHAR` and text a `TEXT`
    data type. For the user ID we defined `INT UNSIGNED`, which references the `id`
    field of the `users` table. Laravel already defined the `users` table when creating
    the project, so you do not have to worry about it. If you are interested in how
    it looks, check the `database/migrations/2014_10_12_000000_create_users_table.php`
    file. You will note that a user is composed by an ID, a name, the unique e-mail,
    and the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have just written the migration files. In order to apply them, you
    need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything went as expected, you should have a `blogs` table now similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project setup](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To finish with all the preparations, we need to create a model for our `blogs`
    table. This model will extend from **Illuminate\Database\Eloquent\Model**, which
    is the ORM that Laravel uses. To generate this model automatically, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The name of the model should be the same as that of the database table but in
    singular. After running this command, you can find the empty model in `app/Post.php`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the first endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s add a quick endpoint just to understand how routes work and how to link
    controllers with templates. In order to avoid database access, let''s build the
    add new post view, which will display a form that allows the user to add a new
    post with a title and text. Let''s start by adding the route and controller. Open
    the `app/Http/routes.php` file and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These three very simple lines say that for the `/new` endpoint, we want to reply
    with the `new` view. Later on, we will complicate things here in the controller,
    but for now, let's focus on the views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Laravel uses Blade as the template engine instead of Twig, but the way they
    work is quite similar. They can also define layouts from where other templates
    can extend. The place for your layouts is in `resources/views/layouts`. Create
    an `app.blade.php` file with the following content inside this directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a normal layout with a title, some CSS, and an `ul` list of sections
    in the body, which will be used as the navigation bar. There are two important
    elements to note here other than the HTML code that should already sound familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a block, Blade uses the `@yield` annotation followed by the name
    of the block. In our layout, we defined two blocks: `css` and `content`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a feature that allows you to build URLs in templates. We want to include
    the CSS file in `public/css/layout.css`, so we will use `URL::asset` to build
    this URL. It is also helpful to include JS files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you saw, we included a `layout.css` file. CSS and JS files are stored under
    the `public` directory. Create yours in `public/css/layout.css` with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can focus on our view. Templates are stored in `resources/views`, and,
    as with layouts, they need the `.blade.php` file extension. Create your view in
    `resources/views/new.blade.php` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax is quite intuitive. This template extends from the layouts'' one
    and defines two sections or blocks: `css` and `content`. The CSS file included
    follows the same format as the previous one. You can create it in `public/css/new.css`
    with content similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the template just defines the POST form pointing to the same URL
    with title and text fields. Everything is ready to test it in your browser! Try
    accessing `http://localhost:8080/new` or the port number of your choice. You should
    see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the first endpoint](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Managing users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As explained before, user authentication and authorization is one of the features
    that most frameworks contain. Laravel makes our lives very easy by providing the
    user model and the registration and authentication controllers. It is quite easy
    to make use of them: you just need to add the routes pointing to the already existing
    controllers and add the views. Let''s begin.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five routes that you need to consider here. There are two that belong
    to the registration step, one to get the form and another one for the form to
    submit the information provided by the user. The other three are related to the
    authentication part: one to get the form, one to post the form, and one for the
    logout. All five of them are included in the `Auth\AuthController` class. Add
    to your `routes.php` file the following routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note how we defined these routes. As opposed to the one that we created previously,
    the second argument of these is a string with the concatenation of the controller's
    class name and method. This is a better way to create routes because it separates
    the logic to a different class that can later be reused and/or unit tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested, you can browse the code for this controller. You will
    find a complex design, where the functions the routes will invoke are actually
    part of two traits that the `AuthController` class uses: `RegistersUsers` and
    `AuthenticatesUsers`. Checking these methods will enable you to understand what
    goes on behind the scenes.'
  prefs: []
  type: TYPE_NORMAL
- en: Each `get` route expects a view to render. For the user's registration, we need
    to create a template in `resources/views/auth/register.blade.php`, and for the
    login view, we need a template in `resources/views/auth/login.blade.php`. As soon
    as we send the correct POST parameters to the correct URL, we can add any content
    that we think necessary.
  prefs: []
  type: TYPE_NORMAL
- en: User registration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start with the registration form; this form needs four POST parameters:
    name, e-mail, password, and password confirmation, and as the route says, we need
    to submit it to `/auth/register`. The template could look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This template is quite similar to the form for new posts: it extends the layout,
    adds a CSS file, and populates the content section with a form. The new addition
    here is the use of the `old` function that retrieves the value submitted on the
    previous request in case that the form was not valid and we showed it back to
    the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we try it, we need to add a `register.css` file with the styles for
    this form. A simple one could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we should edit the layout in order to add a link on the menu pointing
    to the registration and login pages. This is as simple as adding the following
    `li` elements at the end of the `ul` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add also the style for the `right` class at the end of `layout.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To make things even more useful, we could add the information for what went
    wrong when submitting the form. Laravel flashes the errors into the session, and
    they can be accessed via the `errors` template variable. As this is common to
    all forms and not only to the registration one, we could add it to the `app.blade.php`
    layout, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this piece of code, we will use Blade's `@if` conditional and `@foreach`
    loop. The syntax is the same as PHP; the only difference is the `@` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to go. Launch your application and click on the registration
    link on the right-hand side of the menu. Attempt to submit the form, but leave
    some fields blank so that we can note how the errors are displayed. The result
    should be something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User registration](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'One thing that we should customize is where the user will be redirected once
    the registration is successful. In this case, we can redirect them to the login
    page. In order to achieve this, you need to change the value of the `$redirectTo`
    property of `AuthController`. So far, we only have the new post page, but later,
    you could add any path that you want via the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: User login
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The user''s login has a few more changes other than the registration. We not
    only need to add the login view, we should also modify the menu in the layout
    in order to acknowledge the authenticated user, remove the register link, and
    add a logout one. The template, as mentioned earlier, has to be saved in `resources/views/auth/login.blade.php`.
    The form needs an e-mail and password and optionally a checkbox for the *remember
    me* functionality. An example could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The layout has to be changed slightly. Where we displayed the links to register
    and log in users, now we need to check whether there is a user already authenticated;
    if so, we should rather show a logout link. You can get the authenticated user
    through the `Auth::user()` method even from the view. If the result is not empty,
    it means that the user was authenticated successfully. Change the two links using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Protected routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This last part of the user management session is probably the most important
    one. One of the main goals when authenticating users is to authorize them to certain
    content—that is, to allow them to visit certain pages that unauthenticated users
    cannot. In Laravel, you can define which routes are protected in this way by just
    adding the `auth` middleware. Update the new post route with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Everything is ready! Try to access the new post page after logging out; you
    will be redirected automatically to the login page. Can you feel how powerful
    a framework can be?
  prefs: []
  type: TYPE_NORMAL
- en: Setting up relationships in models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned before, Laravel comes with an ORM, Eloquent ORM, which makes
    dealing with models a very easy task. In our simple database, we defined one table
    for posts, and we already had another one for users. Posts contain the ID of the
    user that owns it—that is, `user_id`. It is good practice to use the singular
    of the name of the table followed by `_id` so that Eloquent will know where to
    look. This was all we did regarding the foreign key.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also mention this relationship on the model side. Depending on the
    type of the relationship (one to one, one to many, or many to many), the code
    will be slightly different. In our case, we have a one-to-many relationship because
    one user can have many posts. To say so in Laravel, we need to update both the
    `Post` and the `User` models. The `User` model needs to specify that it has many
    posts, so you need to add a `posts` method with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This method says that the model for users has many posts. The other change
    that needs to be made in `Post` is similar: we need to add a `user` method that
    defines the relationship. The method should be similar to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It looks like very little, but this is the whole configuration that we need.
    In the next section, you will see how easy it is to save and query using these
    two models.
  prefs: []
  type: TYPE_NORMAL
- en: Creating complex controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even though the title of this section mentions complex controllers, you will
    note that we can create complete and powerful controllers with very little code.
    Let''s start by adding the code that will manage the creation of posts. This controller
    needs to be linked to the following route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can imagine, now, we need to create the `Post\PostController` class
    with the `createPost` method in it. Controllers should be stored in `app/Http/Controllers`,
    and if they can be organized in folders, it would be even better. Save the following
    class in `app/Http/Controllers/Post/PostController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, the only two things we can note from this class are:'
  prefs: []
  type: TYPE_NORMAL
- en: Controllers extend from the `App\Http\Controllers\Controller` class, which contains
    some general helpers for all the controllers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods of controllers can get the `Illuminate\Http\Request` argument as the
    user's request. This object will contain elements such as the posted parameters,
    cookies, and so on. This is very similar to the one we created in our own application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first thing we need to do in this kind of controller is check whether the
    parameters posted are correct. For this, we will use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we did is create a validator. For this, we used the `Validator::make`
    function and sent two arguments: the first one contains all the parameters from
    the request, and the second one is an array with the expected fields and their
    constraints. Note that we expect two required fields: `title` and `content`. Here,
    the first one can be up to 255 characters long, and the second one needs to be
    at least 20 characters long.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `validator` object is created, we can check whether the data posted
    by the user matches the requirements with the `fails` method. If it returns `true`—that
    is, the validation fails—we will redirect the user back to the previous page with
    `redirect()->back()`. To perform this invocation, we will add two more method
    calls: `withInput` will send the submitted values so that we can display them
    again, and `withErrors` will send the errors the same way `AuthController` did.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, it would be helpful to the user if we show the previously submitted
    title and text in case the post is not valid. For this, use the already known
    `old` method in the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can already test how the controller behaves when the post
    does not match the required validations. If you miss any of the parameters or
    they do not have correct lengths, you will get an error page similar to the following
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating complex controllers](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now add the logic to save the post in case it is valid. If you remember
    the interaction with the models from our previous application, you will be gladly
    surprised at how easy it is to work with them here. Take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we will do is create a `post` object setting the title and content
    from the request values. Then, given the result of `Auth::user()`, which gives
    us the instance of the currently authenticated user model, we will save the post
    that we just created through `posts()->save($post)`. If we wanted to save the
    post without the information of the user, we could use `$post->save()`. Really,
    that is all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly add another endpoint to retrieve the list of posts for a given
    user so that we can take a look at how Eloquent ORM allows us to fetch data easily.
    Add the following route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The way we retrieve data is very similar to how we save it. We need the instance
    of a model—in this case, the authenticated user—and we will add a concatenation
    of method invocations that will internally generate the query to execute. In this
    case, we will ask for the posts ordered by the creation date. In order to send
    information to the view, we need to pass a second argument, which will be an array
    of parameter names and values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following template as `resources/views/posts.blade.php`, which will
    display the list of posts for the authenticated user as a table. Note how we will
    use the `$post` object, which is an instance of the model, in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The lists of posts are finally displayed. The result should be something similar
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating complex controllers](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a very short time, we created an application that allows you to register,
    log in, and create and list posts from scratch. We will end this section by talking
    about how to test your Laravel application with PHPUnit.
  prefs: []
  type: TYPE_NORMAL
- en: It is extremely easy to write tests in Laravel as it has a very nice integration
    with PHPUnit. There is already a `phpunit.xml` file, a customized `TestCase` class,
    customized assertions, and plenty of helpers in order to test with the database.
    It also allows you to test routes, emulating the HTTP request instead of testing
    the controllers. We will visit all these features while testing the creation of
    new posts.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to remove `tests/ExampleTest.php` because it tested the
    home page, and as we modified it, it will fail. Do not worry; this is an example
    test that helps developers to start testing, and making it fail is not a problem
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to create our new test. To do this, we can either add the file
    manually or use the command line and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates the `tests/NewPostTest.php` file, which extends from `TestCase`.
    If you open it, you will note that there is already a dummy test, which you can
    also remove. Either way, you can run PHPUnit to make sure everything passes. You
    can do it in the same way we did previously, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The first test we can add is one where we try to add a new post but the data
    passed by the POST parameters is not valid. In this case, we should expect that
    the response contains errors and old data, so the user can edit it instead of
    rewriting everything again. Add the following test to the `NewPostTest` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we can note in the test is the creation of a `user` instance
    using a factory. You can pass an array with any parameter that you want to set
    to the `make` invocation; otherwise, defaults will be used. After we get the `user`
    instance, we will send it to the `be` method to let Laravel know that we want
    that user to be the authorized one for this test.
  prefs: []
  type: TYPE_NORMAL
- en: Once we set the grounds for the test, we will use the `call` helper that will
    emulate a real HTTP request. To this method, we have to send the HTTP method (in
    this case, POST), the route to request, and optionally the parameters. Note that
    the `call` method returns the response object in case you need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will send a title and the content, but this second one is not long enough,
    so we will expect some errors. Laravel comes with several customized assertions,
    especially when testing these kinds of responses. In this case, we could use two
    of them: `assertSessionHasErrors`, which checks whether there are any flash errors
    in the session (in particular, the ones for the content parameter), and `assertHasOldInput`,
    which checks whether the response contains old data in order to show it back to
    the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second test that we would like to add is the case where the user posts
    valid data so that we can save the post in the database. This test is trickier
    as we need to interact with the database, which is usually a not a very pleasant
    experience. However, Laravel gives us enough tools to help us in this task. The
    first and most important is to let PHPUnit know that we want to use database transactions
    for each test. Then, we need to persist the authenticated user in the database
    as the post has a foreign key pointing to it. Finally, we should assert that the
    post is saved in the database correctly. Add the following code to the `NewPostTest`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `DatabaseTransactions` trait will make the test to start a transaction at
    the beginning and then roll it back once the test is done, so we will not leave
    the database with data from tests. Saving the authenticated user in the database
    is also an easy task as the result of the factory is an instance of the user's
    model, and we can just invoke the `save` method on it.
  prefs: []
  type: TYPE_NORMAL
- en: The `assertRedirectedTo` assertion will make sure that the response contains
    the valid headers that redirect the user to the specified URL. More interestingly,
    `seeInDatabase` will verify that there is an entity in the `posts` table, which
    is the first argument, with the data provided in the array, which is the second
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a lot of assertions, but as you can note, they are extremely
    useful, reducing what could be a long test to a very few lines. We recommend you
    to visit the official documentation for the full list.
  prefs: []
  type: TYPE_NORMAL
- en: The Silex microframework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a taste of what Laravel can offer you, you most likely do not want to
    hear about minimalist microframeworks. Still, we think it is good to know more
    than one framework. You can get to know different approaches, be more versatile,
    and everyone will want you in their team.
  prefs: []
  type: TYPE_NORMAL
- en: We chose Silex because it is a microframework, which is very different from
    Laravel, and also because it is part of the Symfony family. With this introduction
    to Silex, you will learn how to use your second framework, which is of a totally
    different type, and you will be one step closer to knowing Symfony as well, which
    is one of the big players.
  prefs: []
  type: TYPE_NORMAL
- en: What is the benefit of microframeworks? Well, they provide the very basics—that
    is, a router, a simple dependency injector, request helpers, and so on, but this
    is the end of it. You have plenty of room to choose and build what you really
    need, including external libraries or even your own ones. This means that you
    can have a framework specially customized for each different project. In fact,
    Silex provides a handful of built-in service providers that you can integrate
    very easily, from template engines to logging or security.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s no news here. Composer does everything for you, as it does with Laravel.
    Execute the following command on your command line at the root of your new project
    in order to include Silex in your `composer.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You may require more dependencies, but let's add them when we need them.
  prefs: []
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Silex''s most important class is `Silex\Application`. This class, which extends
    from **Pimple** (a lightweight dependency injector), manages almost anything.
    You can use it as an array as it implements the `ArrayAccess` interface, or you
    could invoke its methods to add dependencies, register services, and so on. The
    first thing to do is to instantiate it in your `public/index.php` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Managing configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the first things we like to do is load the configuration. We could do
    something very simple, such as including a file with PHP or JSON content, but
    let''s make use of one of the service providers, `ConfigServiceProvider`. Let''s
    add it with Composer via the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This service allows us to have multiple configuration files, one for each environment
    we need. Imagining that we want to have two environments, `prod` and `dev`, this
    means we need two files: one in `config/prod.json` and one in `config/dev.json`.
    The `config/dev.json` file would look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `config/prod.json` file would look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to work in a development environment, you will need to set the correct
    value to the environment variable by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `APP_ENV` environment variable will be the one telling us which environment
    we are in. Now, it is time to use this service provider. In order to register
    it by reading from the configuration file of the current environment, add the
    following lines to your `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we did here is to get the environment from the environment
    variable. By default, we set it to `prod`. Then, we invoked `register` from the
    `$app` object to add an instance of `ConfigServiceProvider` by passing the correct
    configuration file path. From now on, the `$app` "array" will contain three entries:
    `debug`, `cache`, and `db` with the content of the configuration files. We will
    be able to access them whenever we have access to `$app`, which will be mostly
    everywhere.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the template engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another of the handy service providers is Twig. As you might remember, Twig
    is the template engine that we used in our own framework, and it is, in fact,
    from the same people that developed Symfony and Silex. You also already know how
    to add the dependency with Composer; simply run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To register the service, we will need to add the following lines in our `public/index.php`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Also, create the `views/` directory where we will later store our templates.
    Now, you have the `Twig_Environment` instance available by just accessing `$app['twig']`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a logger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last one of the service providers that we will register for now is the
    logger. This time, the library to use is **Monolog**, and you can include this
    via the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The quickest way to register a service is by just providing the path of the
    log file, which can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If you would like to add more information to this service provider, such as
    what level of logs you want to save, the name of the log, and so on, you can add
    them to the array together with the log file. Take a look at the documentation
    at [http://silex.sensiolabs.org/doc/providers/monolog.html](http://silex.sensiolabs.org/doc/providers/monolog.html)
    for the full list of parameters available.
  prefs: []
  type: TYPE_NORMAL
- en: As with the template engine, from now on, you can access the `Monolog\Logger`
    instance from the `Application` object by accessing `$app['monolog']`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the first endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is time to see how the router works in Silex. We would like to add a simple
    endpoint for the home page. As we already mentioned, the `$app` instance can manage
    almost anything, including routes. Add the following code at the end of the `public/index.php`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a similar way of adding routes to the one that Laravel follows. We
    invoked the `get` method as it is a GET endpoint, and we passed the route string
    and the `Application` instance. As we mentioned here, `$app` also acts as a dependency
    injector—in fact, it extends from one: Pimple—so you will notice the `Application`
    instance almost everywhere. The result of the anonymous function will be the response
    that we will send to the user—in this case, a rendered Twig template.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, this will not do the trick. In order to let Silex know that you
    are done setting up your application, you need to invoke the `run` method at the
    very end of the `public/index.php` file. Remember that if you need to add anything
    else to this file, it has to be before this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You have already worked with Twig, so we will not spend too much time on this.
    The first thing to add is the `views/home.twig` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as you might have already guessed, we will add the `views/layout.twig`
    template, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Try accessing the home page of your application; you should get the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the first endpoint](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this section, we will write an endpoint that will create recipes for our
    cookbook. Run the following MySQL queries in order to set up the `cookbook` database
    and create the empty `recipes` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Silex does not come with any ORM integration, so you will need to write your
    SQL queries by hand. However, there is a Doctrine service provider that gives
    you a simpler interface than the one PDO offers, so let''s try to integrate it.
    To install this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to register the service provider. As with the rest of services,
    add the following code to your `public/index.php` before the route definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: When registering, you need to provide the options for the database connection.
    Some of them will be the same regardless of the environment, such as the driver
    or even the host, but some will come from the configuration file, such as `$app['database']['user']`.
    From now on, you can access the database connection via `$app['db']`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the database set up, let''s add the routes that will allow us to add and
    fetch recipes. As with Laravel, you can specify either the anonymous function,
    as we already did, or a controller and method to execute. Replace the current
    route with the following three routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can observe, there will be a new controller, `CookBook\Controllers\RecipesController`,
    which will be placed in `src/Controllers/RecipesController.php`. This means that
    you need to change the autoloader in Composer. Edit your `composer.json` file
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add the controller class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The first method we will add is the `getNewForm` method, which will just render
    the add a new recipe page. The method looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The method will just render `new_recipe.twig`. An example of this template
    could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This template sends the name, ingredients, instructions, and the time that
    it takes to prepare the dish. The endpoint that will get this form needs to get
    the response object in order to extract this information. In the same way that
    we could get the `Application` instance as an argument, we can get the `Request`
    one too if we specify it in the method definition. Accessing the POST parameters
    is as easy as invoking the `get` method by sending the name of the parameter or
    calling `$request->request->all()` to get all of them as an array. Add the following
    method that checks whether all the data is valid and renders the form again if
    it is not, sending the submitted data and errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `layout.twig` template needs to be edited too in order to show the errors
    returned. We can do this by executing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you can already try to access `http://localhost/recipes`, fill
    the form leaving something empty, submitting, and getting the form back with the
    errors. It should look something similar to this (with some extra CSS styles):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing the database](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The continuation of the controller should allow us to store the correct data
    as a new recipe in the database. To do so, it would be a good idea to create a
    separate class, such as `CookBook\Models\RecipeModel`; however, to speed things
    up, let''s add the following few lines that would go into the model to the controller.
    Remember that we have the Doctrine service provider, so there is no need to use
    PDO directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Doctrine also helps when fetching data. To see it working, check the third
    and final method, in which we will fetch all the recipes in order to show the
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'With only one line, we performed a query. It is not as clean as the Eloquent
    ORM of Laravel, but at least it is much less verbose than using raw PDO. Finally,
    you can update your `home.twig` template with the following content in order to
    display the recipes that we just fetched from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Silex versus Laravel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though we did some similar comparison before starting the chapter, it is
    time to recapitulate what we said and compare it with what you noted by yourself.
    Laravel belongs to the type of framework that allows you to create great things
    with very little work. It contains all the components that you, as a web developer,
    will ever need. There has to be some good reason for how fast it became the most
    popular framework of the year!
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Silex is a microframework, which by itself does very little.
    It is just the skeleton on which you can build the framework that you exactly
    need. It already provides quite a lot of service providers, and we did not discuss
    even half of them; we recommend you to visit [http://silex.sensiolabs.org/doc/providers.html](http://silex.sensiolabs.org/doc/providers.html)
    for the full list. However, if you prefer, you can always add other dependencies
    with Composer and use them. If, for some reason, you stop liking the ORM or the
    template engine that you use, or it just happens that a new and better one appears
    in the community, switching them should be easy. On the other hand, when working
    with Laravel, you will probably stick to what it comes with it.
  prefs: []
  type: TYPE_NORMAL
- en: There is always an occasion for each framework, and we would like to encourage
    you to be open to all the possibilities that there are out there, keep up to date,
    and explore new frameworks or technologies from time to time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how important it is to know some of the most important
    frameworks. You also learned the basics of two famous ones: Laravel and Silex.
    Now, you are ready to either use your framework or to use these two for your next
    application. With this, you also have the capacity to take any other similar framework
    and understand it easily.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will study what REST APIs are and how to write one with
    Laravel. This will expand your set of skills and give you more flexibility for
    when you need to decide which approach to take when designing and writing applications.
  prefs: []
  type: TYPE_NORMAL
