- en: '[*Chapter 5*](B17606_05_Final_PD_ePub.xhtml#_idTextAnchor097): Diving into
    Liquid Core with Filters'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, we learned about all the different Liquid tags
    and objects, and now, we will be focusing on the last of the Liquid Core features,
    which is `|`, through which we can manipulate different data types, including
    strings, numbers, variables, or even objects, making it a compelling feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can split the chapter into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: HTML and URL filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing the product media gallery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building product accordions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Math and money filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the additional filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the time we complete this chapter, we will precisely understand how much
    power filters provide us. Similarly, as with the previous chapter, instead of
    simply listing and going through all of the filters, we will only explain some
    essential filters through a series of small projects.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will learn about generating HTML elements through **HTML and URL filters**.
    Second, understanding **media filters** will help us with the product media gallery,
    one of Shopify's latest additions and one of the most sought-after features. Third,
    by working on the product accordions project, we will learn how to manipulate
    the string and array types of data through their respective filters. Lastly, working
    on a product price discount project will provide us with the necessary knowledge
    of **math and money filters**.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we will explain each topic and present it with accompanying screenshots,
    you will need an internet connection to follow the steps outlined in this chapter,
    considering that Shopify is a hosted service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter is available on GitHub: [https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter05](https://github.com/PacktPublishing/Shopify-Theme-Customization-with-Liquid/tree/main/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3zmum4j](https://bit.ly/3zmum4j)'
  prefs: []
  type: TYPE_NORMAL
- en: Working with HTML and URL filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we had the chance to see a type of URL filter when
    we worked on outputting the product images, `{{ image | img_url: "400x400" }}`.
    *However, what exactly are URL filters?*'
  prefs: []
  type: TYPE_NORMAL
- en: '`image` tag, inside which we can add the string path to a specific asset as
    the `href` attribute. Alternatively, we can combine URL filters with **HTML filters**
    to automatically generate the necessary HTML element with the necessary attributes.
    Let''s see them in action now.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B17606_01_Final_PD_ePub.xhtml#_idTextAnchor015), *Getting
    Started with Shopify*, we learned about the `Assets` directory inside our theme
    files and how it contains all of the internal assets that our theme requires,
    such as stylesheets, JavaScript files, font files, and images. However, we will
    first need to load these files within our theme, by following the next steps,
    since they will not automatically be accessible to us by simply uploading them
    within the `Assets` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can retrieve the path to a file within the `Assets` directory by encapsulating
    the file''s name within quotation marks, followed by a pipeline, followed by the
    `asset_url` filter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the previous example, we have used the name of the stylesheet file within
    our store in combination with `asset_url`, which will provide us with the string
    path toward this specific file: [https://cdn.shopify.com/s/files/1/0559/0089/7434/t/4/assets/theme.css?v=10188701410004355449](https://cdn.shopify.com/s/files/1/0559/0089/7434/t/4/assets/theme.css?v=10188701410004355449)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have recovered the path toward our location, as previously mentioned,
    we have two choices. The first option is to use an HTML `link` tag to link the
    CSS file with our theme:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <link rel="stylesheet" href="//cdn.shopify.com/s/files/1/0559/0089/7434/t/4/assets/theme.css?v=10188701410004355449">
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, as we have previously mentioned, besides using the HTML `link` tag,
    we can also combine URL filters with an HTML filter to generate the necessary
    HTML attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the previous example, we used the asset name whose path we are looking to
    recover, followed by the `asset_url` filter, which would usually only return the
    string path. However, pairing it with `stylesheet_tag` will automatically generate
    the HTML `link` tag with all the necessary attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Besides being a lot cleaner, the main difference between the two approaches
    is that `stylesheet_tag` does not accept additional parameters. So, for example,
    if we were looking to change the `rel` attribute to preload, modify the `media`
    attribute, or even include the `defer` attribute, we would have to use the first
    approach and include the asset file using the HTML `link` tag.
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned how to connect our theme file with the necessary stylesheet.
    However, note that we will be using a different type of HTML filter depending
    on which file we are looking to access.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we were looking to output the content of the `theme.js` file
    into our theme, we would use a similar approach, the theme filename followed by
    `asset_url` to get its path, but instead of using `stylesheet_tag`, we will use
    `script_tag`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `script_tag`, we will automatically generate and include the HTML `script`
    tag in our theme. However, do note that similarly as with `stylesheet_tag`, `script_tag`
    also does not accept any parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides `stylesheet_tag` and `script_tag`, we also have access to `img_tag`.
    Accessing an image file within the assets can be done using the name of the image
    file, followed by `asset_url`, followed by `img_tag`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The crucial difference between `img_tag` and the previous two filters is that
    `img_tag` does accept additional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079), *Diving into
    Liquid Core with Objects*, we had the chance to see the `img_url` filter in action
    by using it to return the product image URL string, which we combined with the
    HTML `img` tag to output the product image to our storefront:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that besides the `img_url` filter, we have also used the `size` parameter
    to set the limit size of our image, which is one of the three parameters that
    we can use with the `img_url` and `img_tag` filters. However, note that both types
    of filters use different parameters, which we will explain shortly through the
    following mini project.
  prefs: []
  type: TYPE_NORMAL
- en: Building a product gallery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside this mini project, we will learn how to output the necessary elements
    for the product gallery:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a new page named `Product Gallery` and a new page template
    named `product-gallery`, which we will assign to the previously created page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have created the page and assigned the appropriate template, we should
    identify one product with more than one image and recover its handle. We will
    use gardening gloves for our selection, which is one of the products that we previously
    imported from the `product-data.csv` file in [*Chapter 3*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047),
    *Diving into Liquid Core with Tags*. We can retrieve the product handle by previewing
    the product page and copying the page handle from the page URL. Alternatively,
    we can retrieve it by navigating to the product page inside the admin section
    and copying the page handle from the page URL link at the bottom of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have recovered the product handle, let's start by creating a product
    object through its handle and assigning it to a variable. To achieve this, we
    can use the previously learned method of accessing the page object through its
    handle. However, compared to the previous chapters, where we learned how to access
    the product object through its collection, accessing the product object directly
    using its handle is slightly different.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of pluralizing the product object name, we will be using a global object
    tag named `all_products`, which gives us access to all products in our store.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: While `all_products` is quite a practical method that allows us to access any
    product directly through its handle, it comes with a limitation that we can only
    run it 20 times per page. This means that if we need to recover more than 20 specific
    products on a single page, we will need to recover them by looping over a collection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can access the product object through its handle by using the `all_products`
    global object, followed by the handle of the product we are trying to access.
    For our example, we will be using square brackets, `[]`. However, we could have
    also used the dot (`.`) annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this, we now have access to the gardening gloves product object. To access
    all images attached to a product, we will use the `product_object` variable as
    our object, followed by the `images` attribute, to recover the array of images
    for the specific product. Since we are dealing with an array, we will have to
    use the `for` tag to loop over them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have now successfully extracted an array of product images, which we can
    use to create powerful galleries using various slider plugins. However, notice
    that the size of the images we have on our storefront is relatively small.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because Liquid always defaults to a size of `100x100` if we do not
    introduce the `size` parameter. Let''s introduce the `size` parameter by limiting
    the image dimension to 300 px in width and 300 px in height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice that our images now have 300 px in width but only 200 px in height even
    though we have specified that we would like 300 px in height. This is because
    the `size` parameter can only limit the image size by decreasing its size to match
    the assigned values. It cannot change the image aspect, nor can it increase the
    size of the image beyond the original image size.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we have used `"300x300"` to limit our product images
    in both width and height. However, we can also limit only one side by using `"300x"`
    to set the image width to 300 px or `"x300"` to limit the height to 300 px. If
    we only specify one of the two values, Shopify will automatically calculate the
    dimension of the image while maintaining the image aspect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second parameter we can use with the `img_url` filter is the `crop` parameter,
    which allows us to crop the image to the specified size when combined with the
    `size` parameter. The `crop` parameter can have five different values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`top`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`center`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bottom`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`left`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`right`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the correct option, we can specify which side of the image we would like
    to crop out. For our example, we can use the `center` option to ensure that the
    image is cropped equally from each side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By changing the image size using the `crop` parameter, we have also changed
    the image's aspect, as all the images are now exactly 300 px in width and 300
    px in height.
  prefs: []
  type: TYPE_NORMAL
- en: The last two parameters that we can use with the `img_url` filter are `scale`,
    which allows us to specify the pixel density of the image using the `2` and `3`
    as its option values, and `format`, which is a quite interesting parameter that
    allows us to specify the format of the displayed image. The two acceptable values
    for the `format` parameter are `jpg` and `pjpg`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `pjpg`, we can convert the image format to **Progressive JPEG**, automatically
    loading a full-size image and increasing its quality gradually instead of loading
    the image from top to bottom like a traditional JPEG (we can read more about the
    Progressive JPEG at the following link: [https://en.wikipedia.org/wiki/JPEG#JPEG_compression](https://en.wikipedia.org/wiki/JPEG#JPEG_compression)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have familiarized ourselves with the parameters that are accessible
    using the `img_url` filter, it is time to learn more about the parameters available
    with the `img_tag` filter. Let''s start by modifying our last example to use `img_tag`
    to generate the HTML tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that when we first mentioned `img_tag`, we used it in combination with
    `asset_url` to recover the URL string of the image location inside the `Assets`
    directory. However, since we are not accessing the `Assets` directory but the
    product images, whose array of URL strings we already have from using `product_object.images`,
    we do not need to use any additional filters besides `img_tag`.
  prefs: []
  type: TYPE_NORMAL
- en: By reviewing the results, we can see that we have successfully created the HTML
    `img` tag for each image within the image array. Since we haven't declared the
    image size, Shopify has by default resized our images to `100x100`.
  prefs: []
  type: TYPE_NORMAL
- en: '`img_tag` accepts only three parameters. Contrary to `img_url`, where we can
    apply only the parameter we need, for `img_tag`, we need to apply all parameters
    in a specific order. This means that we would first have to use the other parameters
    if we would like to use the `class` and `alt` tag parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we need to add all parameters in a specific order, the parameters require
    no representation. We only need to assign their values. The first value is alt
    text, inside of which we can use a fixed string value or a Liquid value, such
    as `image_item.alt`, to recover the actual image alt text. The second parameter
    we can use to assign specific classes to each image tag, while only in the third
    parameter can we assign the size value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we have had the chance to see, both the `image_url` and `img_tag` filters
    have their helpful parameters, and while `img_tag` is cleaner, it has limitations
    as we are limited in the number of attributes we can include in the generated
    HTML `img` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we were looking to extract an image file from the `Assets` directory
    with the appropriate `size` parameter applied to apply it as a background image.
    We cannot use `img_tag`, as previously mentioned, as that would return an HTML
    `img` tag. We also cannot use `asset_url` alone, as `asset_url` does not accept
    any additional parameters, including the `size` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, as with `stylesheet_tag` and `script_tag`, we have access to the
    special `asset_img_url` filter, which allows us to include the `size` parameter
    to recover the images from the `Assets` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that `asset_img_url` allows us to include the `size` parameter and other
    parameters previously available with the `img_url` filter, including `size`, `crop`,
    `scale`, and `format`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned how to access different types of files within the `Assets`
    directory and generate the appropriate HTML tag for each of them. We have also
    learned how to work with the `img_url` filter by working through a small project
    of outputting the necessary elements to create a basic product gallery. While
    we have not gone over all of the URL and HTML filters that Liquid offers, we have
    now set the proper groundwork for working with HTML and URL filters, knowledge
    of which is essential in Liquid and will be of great help to our future work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs: []
  type: TYPE_NORMAL
- en: For additional information on all the available HTML filters, we can refer to
    [https://shopify.dev/docs/themes/liquid/reference/filters/html-filters](https://shopify.dev/docs/themes/liquid/reference/filters/html-filters),
    and for additional information on the available URL filters, we can refer to [https://shopify.dev/docs/themes/liquid/reference/filters/url-filters](https://shopify.dev/docs/themes/liquid/reference/filters/html-filters).
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the product media gallery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous exercise, we learned how to output the image elements needed
    to output the necessary elements to create a basic product gallery that contains
    only images. In the following project, we will learn how to use media objects
    and filters to create a multifunctional gallery that will support images, 3D models,
    and internal videos hosted on Shopify. Additionally, we will also embed external
    video links to some of the most popular video platforms, Vimeo and YouTube, and
    autogenerate the appropriate video player for both.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the newest themes today already contain a product media gallery. However,
    many stores still use outdated theme files, so it is essential to know how to
    create the feature from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by navigating to the `Product Gallery` page we created in the
    previous *Building a product gallery* subsection, located under the *Working with
    HTML and URL filters* section, and revise the previously included code to accept
    additional media types besides images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, we have used the `product_object` variable to capture the product
    object of the gardening gloves product, after which we have used a `for` tag to
    loop over the array of images received from `product_object.images`. Considering
    that we are dealing with various media types, we will need to use a `media` attribute
    to recover the media array and replace the `image_item` variable with `media`
    to keep everything cohesive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `media` attribute, we have now recovered an array of all the different
    media objects, which can contain the following media types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`image`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`external_video`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`video`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`model`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, having an array of media types also means that we now have a mixed
    array of objects, so we need to filter them out before anything.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `case/when` tags combined with the `media_type` attribute, a
    part of the media object that will allow us to create a `switch` statement to
    recover an array of all media of a specific type. We can remind ourselves of `case/when`
    tags by visiting the *Controlling the flow of Liquid* section, which we can find
    in [*Chapter 3*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047), *Diving into
    Liquid Core with Tags*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `case` tag to filter out `media_type` and write a `switch`
    statement for each media type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With the `case/when` tags in place, we have successfully filtered out the media
    types and have gained access to each media type object we will need to output
    the media tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at our code, we will notice that the code we have previously used
    to output the images in our previous example is still there. Since we now have
    access to the `image` object within the first `switch` statement, we can simply
    reposition the code inside, which will be the first step in outputting the image
    media files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With `img_tag` in place, we have now successfully outputted all the image files
    for our product. However, we still lack tags for other media types. So, let's
    proceed with the external video.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `external_video` object provides us with information about Vimeo or YouTube
    videos associated with a specific product. Similarly, as with image objects, to
    output the `external_video` media types, we will need to use `external_video_tag`
    to generate the necessary `iframe` element, whether for Vimeo or YouTube:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With `external_video_tag` in place, we will automatically generate an iframe
    with all the necessary attributes for each `external_video` media type, so let''s
    give it a quick test:'
  prefs: []
  type: TYPE_NORMAL
- en: To test out whether `external_video_tag` works, we will first need to include
    either a Vimeo or YouTube video on our product page media.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will need to click on the **Products** section in our admin sidebar and navigate
    to the product whose media files we are currently viewing to do this. In our case,
    that product is gardening gloves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After opening the specific product page, we will need to scroll down to the
    **Media** section, where in the top-right corner, we will find a drop-down link
    named **Add media from URL**, which we should click to reveal the drop-down options.
    Inside the dropdown, we will find two options, the first one allowing us to add
    an external image to our product, and the second one allowing us to embed either
    a Vimeo or YouTube video.![Figure 5.1 – Example of embedding external assets to
    a product media
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_5.01_B17606.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.1 – Example of embedding external assets to a product media
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We should proceed by clicking on **Embed video**, which will trigger a popup
    where we can include the URL of either a Vimeo or YouTube video. After pasting
    the link, click on the **Embed video** button to complete the process. After a
    few seconds of processing, the media video will be visible in the **Media** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Example of various media files on the product admin page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.02_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Example of various media files on the product admin page
  prefs: []
  type: TYPE_NORMAL
- en: With the video now successfully loaded within the product media assets, all
    that is left is to test whether `external_video_tag` works well.
  prefs: []
  type: TYPE_NORMAL
- en: By clicking on the media video asset, we will trigger a popup with a preview
    on one side and the option to include alt text on the other. Additionally, in
    the top-right corner, we can see three icons. The first one is a trash icon, which
    will allow us to delete the specific media. The middle icon, represented by three
    dots, when clicked will reveal a drop-down menu with the **Replace thumbnail**
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking this option will allow us to upload a thumbnail visible as a poster
    image for the iframe video and avoid having the first frame of the video as a
    poster. Note that the icon represented with three dots is only visible on video
    assets and will not be visible on regular image assets.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Example of video media asset pop-up tools'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.03_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Example of video media asset pop-up tools
  prefs: []
  type: TYPE_NORMAL
- en: 'Previewing the `iframe` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, by default, there are many attributes included in our YouTube
    video embedding, such as visible controls and branding. *But what if we wanted
    to modify those attributes or include some new ones?*
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify existing external video attributes or include new ones, we will need
    to introduce a new media filter, `external_video_url`. By including the `external_video_url`
    filter, in combination with `external_video_tag`, we will be able to modify any
    attribute of the YouTube embedding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we can include any number of attributes from the official YouTube
    documentation. While helpful for YouTube video embeddings, the attributes we have
    included will not help us when dealing with Vimeo videos, considering that Vimeo
    uses different attributes based on its own documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to differentiate which embedding link belongs to YouTube and which
    belongs to Vimeo, we will need to introduce the `host` attribute through the `external_video`
    object, which returns one of two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`youtube`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vimeo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the `host` attribute in combination with an `if` statement, we can easily
    distinguish the two `iframe` elements and apply the appropriate attributes to
    each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: With the introduction of the `host` attribute, we have ensured that each type
    of external video embedding will receive the appropriate attributes based on its
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs: []
  type: TYPE_NORMAL
- en: For available attributes for YouTube videos, refer to [https://developers.google.com/youtube/player_parameters#Parameters](https://developers.google.com/youtube/player_parameters#Parameters).
  prefs: []
  type: TYPE_NORMAL
- en: For available attributes for Vimeo videos, refer to [https://vimeo.zendesk.com/hc/en-us/articles/360001494447-Using-Player-Parameters](https://vimeo.zendesk.com/hc/en-us/articles/360001494447-Using-Player-Parameters).
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned how to include both types of external videos and include
    any attributes for each type. Now we can move on to the following `switch` statement
    and learn how to output a video hosted on the Shopify platform itself.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading a video as a product media asset is the same as uploading an image.
    To upload a video, click on the **Products** section within the admin sidebar
    and select the product for which we are uploading the video asset. Once inside,
    scroll down to the **Media** section and click on the **Add Media** button to
    start the uploading process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: Aside from external videos, uploading assets to the Shopify platform has specific
    limitations for all assets, including images and videos. Besides the specific
    types of formats that we can use, an image file cannot exceed the resolution of
    20 MP, 20 MB in size, and must be in either `.jpeg` or `.png` format, whereas
    video files are limited to a maximum length of 60 seconds, 20 MB in size, and
    must be in either `.mp4` or `.mov` video format.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have uploaded the video, we can also add optional information by including
    alt text and a poster image in the same way as for external media.
  prefs: []
  type: TYPE_NORMAL
- en: 'To output the video uploaded to product media files, we will need to use `video_tag`,
    accessible through the `video` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: By previewing the `video` tag. However, since we haven't enabled the controls,
    they have been hidden by default. Additionally, if we look closer, we will notice
    that the URL for the `poster` attribute within the HTML `video` tag has a small
    size, which is why the image on the storefront is small.
  prefs: []
  type: TYPE_NORMAL
- en: As we recall from when learning about image filters, if we try to output an
    image without defining the image size, Shopify will automatically resize the image
    to `100x100`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `video_tag`, we can include any number of attributes that we could use
    with the regular HTML `video` tag, including the `image_size` parameter, allowing
    us to modify the video `poster` attribute size. Let''s modify `video_tag` to make
    the controls visible, set the poster image size, and set the video size to `300x`
    to match the poster size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With the additional attributes included, we have now successfully generated
    the HTML `video` tag while retaining the ability to modify any attribute as we
    see fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following media type that we need to look into is the 3D model, which we
    can output using `model_viewer_tag`, accessible through the `model` object. Simply
    including `model_viewer_tag` with the `media` object will automatically generate
    the appropriate model viewer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that the model viewer will automatically include specific attributes by
    default as with the previous `media` tags. Although, if we choose so, we can easily
    update or even include new attributes by following the same format mentioned with
    the previous `media` tags.
  prefs: []
  type: TYPE_NORMAL
- en: With `model_viewer_tag` in place, we have covered all four media types and ensured
    that we would represent each media type with an appropriate `media` tag. However,
    notice that we still have one final `switch` statement without any `media` tag.
  prefs: []
  type: TYPE_NORMAL
- en: We can consider the final `switch` statement as a failsafe if, for some reason,
    any of the previous `switch` statements or media fail to produce results, and
    we will use it with `media_tag`.
  prefs: []
  type: TYPE_NORMAL
- en: The `media_tag` filter is somewhat of a special kind of filter as this particular
    filter will automatically generate the appropriate `media` tag for any of the
    four previously mentioned media types. *So, if we can use* `media_tag` *to generate
    all the* `media` *tags automatically,* *why don't we use* `media_tag` *to generate
    all the media files? Why did we bother to learn about all the* `media` *tags until
    now?*
  prefs: []
  type: TYPE_NORMAL
- en: 'While it is correct that `media_tag` will automatically detect each type of
    media type and render the appropriate `media` tag for it, by using `media_tag`,
    we will lose the ability to assign custom class names and attributes to specific
    media types. For this reason, we should never use `media_tag` as the primary option
    for rendering media assets. Instead, we should use it as a failsafe to correctly
    render the media assets on the storefront:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have learned how to output image type media files, differentiate
    between different types of external media assets, render the media tag for a video
    hosted on the Shopify platform, and generate the appropriate media tag for 3D
    models. Finally, with `media_tag`, we have covered every media type Shopify currently
    covers and have ensured that we will correctly present each media asset on our
    storefront.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all the necessary assets to create the media gallery, the only
    thing left to do is to refine our code by including some HTML elements to format
    it properly. Besides the code format, we can also use some slider plugins, such
    as **Slick**, depending on the gallery we are looking to create. To keep everything
    concise and to the point, we will not be covering the media gallery's style and
    functionality. However, we can find the necessary suggestions on styling and functionality
    in the following Shopify article for those looking to test their skills by finishing
    the project ([https://shopify.dev/tutorials/add-theme-support-for-rich-media-3d-and-video](https://shopify.dev/tutorials/add-theme-support-for-rich-media-3d-and-video)).
  prefs: []
  type: TYPE_NORMAL
- en: Inside the article, we can find information such as using the aspect ratio box
    to create responsiveness or answers to some of the frequently asked questions
    on functionality, such as connecting the thumbnail images to the main gallery
    or the variant themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs: []
  type: TYPE_NORMAL
- en: For additional information on all the available media filters, we can refer
    to [https://shopify.dev/docs/themes/liquid/reference/filters/media-filters](https://shopify.dev/docs/themes/liquid/reference/filters/media-filters).
  prefs: []
  type: TYPE_NORMAL
- en: While working on this project, we created a fundamental version of the product
    media gallery, allowing us to output any type of product media to any page. While
    it might not look impressive, the knowledge we have learned with this project
    has taught us how to create one of the most sought-after features today, and it
    will be of great help to us in creating more advanced functionalities as our knowledge
    grows further.
  prefs: []
  type: TYPE_NORMAL
- en: Building product accordions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following project, we will be learning about the string and array filters
    by working with and creating the product accordions feature. *But, before we proceed
    with the project, what exactly do string and array filters do?*
  prefs: []
  type: TYPE_NORMAL
- en: '**String filters** are methods that allow us to manipulate the output of Liquid
    code or the variable itself as long as the variable is a string type, whereas
    array filters allow us to manipulate the output of arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: For this project, we will first find one product with a lengthy description.
    To save some time, we already included the necessary description in the `product-data.csv`
    file in [*Chapter 3*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047), *Diving
    into Liquid Core with Tags*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Example of a long product description'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.04_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Example of a long product description
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see from the previous screenshot, having a lengthy product description
    can be quite inefficient as it takes up a lot of space. While we can easily format
    the product description code to include the necessary HTML tags to create product
    accordions, manually adjusting the code for each product would be a long process.
    Maintaining it is even worse. Luckily, by using string and array filters, we can
    easily manipulate the product description output to break it up and format it
    in any way we need:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s begin by identifying the piece of code that is rendering the
    current product description. We can find the product description inside `product-template.liquid`
    under the `Sections` directory, which we are currently rendering using `product.description`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we are looking to create reusable code, the first thing we should do
    is to create a variable that will hold the `product.description` output, so that
    we can avoid calling `product.description` multiple times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have the variable in place, we should outline what exactly we are
    trying to achieve. Again, looking over the current product description, we can
    clearly see that we have three solid blocks, so let's say that we are looking
    to separate the entire product description into three or even more distinctive
    product accordions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know *what*, we need to think of *how*. While we can easily hardcode
    the product accordion titles, such as **Description**, **Ingredients**, and **Instructions**,
    we are looking to create a dynamic feature that allows us to easily include any
    number of product accordions without modifying the code itself. We''ll use the
    following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by navigating to the `Description`, `Ingredients`, and `Instructions`
    as h6 headings, one before each text block. To do this, we can use the headings
    to include any number of product tab titles and set the proper markings for later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we can apply the headings using the rich text editor by simply highlighting
    the text we are looking to format and clicking the **A** button, which will trigger
    a dropdown where we can select the h6 heading we need:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Example of applying headings inside the product description'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.05_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Example of applying headings inside the product description
  prefs: []
  type: TYPE_NORMAL
- en: With the headings in place, we now have proper markup that we can use to separate
    the text blocks into separate blocks, which we can do using the following string
    filter, `split`.
  prefs: []
  type: TYPE_NORMAL
- en: The split filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `split` filter uses a single substring as a parameter, which acts as a delimiter,
    dividing the string into an array whose items we can later output using array
    filters. *But how exactly does it work?*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have created a variable named `methods` and assigned a
    string message to it. Let''s now use the `split` filter to divide the string message
    into an array and call it immediately to see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, after applying the `split` filter, the substring that we used
    as a delimiter was removed entirely from the initial string, and we have ended
    up with an array result. Therefore, any value assigned to the `split` filter substring
    parameter will not only serve as a markup delimiter but will also automatically
    remove any occurrence of the substring value from the string.
  prefs: []
  type: TYPE_NORMAL
- en: After using the `split` filter, we have now modified the `methods` variable
    into an array. However, this is not obvious since we have also included empty
    space within the delimiter, so as a result, we have two words written next to
    each other without any space. To test whether our `methods` variable is an array,
    we need to run it through a loop using the `for` tag. *However, what if we wanted
    to avoid using a loop since we only have two items inside the array?*
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the `first` array filter comes to help. As we recall, we previously
    mentioned both the `first` and `last` filters in the previous chapter when we
    worked on the `Product Customization` project. Using the `first` or `last` filter
    will automatically recover the first or last element inside the array. Since our
    array only has two elements after using the `split` filter, it is a perfect fit.
    Otherwise, we would need to include a `for` tag to loop over the array to recover
    the proper values. Let''s see it in action by recovering only data before the
    delimiter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We can now see that we have successfully modified the initial string type variable
    into an array type and have successfully recovered only the first item of the
    array. While this specific method might look non-important, the knowledge we have
    gained will be of great use in our future work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to our project, let''s take one more example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have assigned a short string inside the `message` variable.
    We have then applied the `split` filter and set its substring to an empty space
    value, meaning that we are looking to divide the initial string for every empty
    space occurrence. Let''s create a short loop to confirm whether the `message`
    variable is now an array type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, by introducing the `split` filter, we have successfully divided
    the initial string message using the substring parameter and created an array,
    which we have confirmed using the `for` tag. Let's now return to our project and
    use our newfound knowledge to divide the product description into three separate
    blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are looking to create a dynamic feature, we will need to set the substring
    parameter to a value that we know will be present in each product description.
    Remember that we have previously added the headings, formatted using the `h6`
    heading. So, let''s use the `split` filter and set the substring value to the
    opening `h6` heading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sense of using the `h6` heading as a substring parameter, we will first
    need to look over the current HTML format of our product description. If we were
    to inspect the product description before using the `split` filter, we would notice
    the following HTML format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As the markup shows, each heading is located just above the text block, providing
    perfect markup. Using the opening `h6` heading as a delimiter, we should have
    four items inside our array. Let''s now see what happens when we apply the `split`
    filter using the opening `h6` heading as a delimiter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on our markup, after applying the `split` filter with the opening `h6`
    heading as a delimiter, the first item in our array should be empty, as there
    is no content before the first occurrence of our delimiter. The other three should
    contain both the heading and any content between the first and the following delimiter
    occurrence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking over the results, we can see that we were successful in extracting
    each product description block. However, there are still a few things to cover.
    For example, we will have one empty `div`, which we can quickly resolve by introducing
    the `offset` parameter and setting its value to `1`, allowing us to skip the first
    iteration within the `for` loop. We can remind ourselves of the `offset` parameter
    by visiting the *Iterations tags* section located in [*Chapter 3*](B17606_03_Final_PD_ePub.xhtml#_idTextAnchor047),
    *Diving into Liquid Core with Tags*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the `offset` parameter to the `for` tag will skip the first iteration,
    otherwise returning an empty value. Additionally, we have ensured that our array
    only contains the three product description blocks we initially intended. However,
    let''s take a closer look at the current results of our array after applying the
    `offset` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As we recall, by using the opening `h6` heading as a substring to the `split`
    filter, we will automatically remove any opening `h6` heading within the initial
    string. However, notice that we have not only removed the opening `h6` tag but
    we have also removed the closing `h6` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, the closing `h6` tag is still there, located after the closing
    `span` tag. However, since we have removed the opening `h6` tag, the browser interpreted
    this as an error and automatically removed the closing `h6` tag. So, instead of
    relying on the browser to clean up, let's use the closing `h6` tag to divide our
    three blocks further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, each item variable inside the `for` loop contains both the heading
    and the content text. By applying the `split` filter using the closing `h6` heading,
    we will modify the `item` variable into an array of its own, containing the heading
    and the content. So, instead of using another `for` loop to loop over those, let''s
    recall the `first` and `last` filters that we previously mentioned and use them
    here to recover each value separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: By applying the `split` filter again, we have removed the leftover closing `h6`
    tag. Additionally, we have separated the content more clearly, allowing us to
    use the results to complete our mini project more easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we possess all the necessary elements to finalize the product
    accordions project. The only thing left is to include some styling and introduce
    the script to handle the on-input animation. To keep everything concise, we will
    not cover the styling and functionality within this project. However, we will
    provide the final expectation to help us visualize a clear goal that we should
    work on, as it will serve as an excellent practice for future work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Example of a complete product accordions project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.06_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – Example of a complete product accordions project
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have learned how to manipulate string variables by turning them
    into an array type variable and using them to create the product accordions feature.
    In addition, we have learned about the `split` and `first`/`last` filters that
    we included using the pipeline character. However, specific filters, such as `size`,
    can be used with pipeline and dot annotation, depending on the situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we have created a `message` variable and have assigned
    a short string to it. Using the `size` filter with the `message` variable, we
    will render the total number of characters within the message string. However,
    by using the size with the dot annotation, we gained the ability to use the `size`
    filter as part of Liquid logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `size` filter to improve our product accordions by including
    an `if` statement that will check whether the product description has more than
    `1` block of code and render the product accordions if it does. Otherwise, it
    should simply output the regular product description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: With the introduction of the `size` filter, we have made our code a lot cleaner
    and more optimized, as we will not run a `for` loop for a single item inside the
    array type variable.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, by simply using everyday filters, we can improve our code significantly.
    For example, *what if we wanted to split the product description and render the
    content into various places and not simply output them all at once?* For this,
    we will need to use a combination of the `split`, `first`/`last`, and `index`
    filters. We have already covered the `split` and `first`/`last` filters, *but
    what does the* `index` *filter do?*
  prefs: []
  type: TYPE_NORMAL
- en: The index filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As its name suggests, the `index` filters allow us to access a specific array
    using its index location, starting from 0\. Let''s try to apply the index location
    to our product accordions project. Note that we will no longer have any need for
    the `for` tag, as we will be accessing the `productDescription` variable directly
    through the `index` filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The previous code will return the first heading and block of text from our product
    description. However, we have mentioned that the index position starts at `0`,
    *so why is position* `1` *returning the results of the first block?*
  prefs: []
  type: TYPE_NORMAL
- en: As we recall, since we have used the opening `h6` tag as a delimiter to our
    `split` filter, the first item in our array is empty. Previously we skipped the
    first item inside the array by including the `offset` parameter, whereas now we
    will simply skip the *first index position*, which is `0`. The downside of this
    method is that we will have to repeat the code to recover each block separately.
    However, on the plus side, we gain the flexibility of positioning them at the
    place of our choosing, which sometimes will be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs: []
  type: TYPE_NORMAL
- en: For additional information on all the available string filters, we can refer
    to [https://shopify.dev/docs/themes/liquid/reference/filters/string-filters](https://shopify.dev/docs/themes/liquid/reference/filters/string-filters).
  prefs: []
  type: TYPE_NORMAL
- en: For additional information on all the available array filters, we can refer
    to [https://shopify.dev/docs/themes/liquid/reference/filters/array-filters](https://shopify.dev/docs/themes/liquid/reference/filters/array-filters).
  prefs: []
  type: TYPE_NORMAL
- en: We saw how somewhat insignificant filters could be a powerful tool that will
    allow us to create complex features that merchants regularly seek. Through this
    type of learning process, we gain valuable lessons by working on a real-life project,
    but we also learn how to deal with various types of filters, which is a lot more
    essential than simply listing them all.
  prefs: []
  type: TYPE_NORMAL
- en: Math and money filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we had a chance to see money filters in action while
    working on the `Custom collections` project. **Money filters** are simple types
    of filters whose only task is to format the number value based on the currency
    formatting options, *but what exactly does this mean?*
  prefs: []
  type: TYPE_NORMAL
- en: To better understand, let's navigate to our admin page and click on the **Settings**
    button in the bottom-left corner. Consequently, click on the **General** option
    to open where we will be able to update the store's basic information. Once inside,
    scroll down until you have reached the section named **Store currency**. This
    is where we can change the store's default currency, which our customers will
    use to make their purchases. Instead of changing the store currency, let's click
    on the **Change formatting** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Location of the store currency formatting'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.07_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Location of the store currency formatting
  prefs: []
  type: TYPE_NORMAL
- en: By clicking the **Change formatting** button, we will reveal additional currency
    formatting options where we can define the global markup for the currency formatting
    that the money filter will later use to format any number value.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to apply the money filter to any number value, based on the formatting
    settings, the only change that we would see is that we would see a dollar sign
    before the price and USD after the price. So, let's try to modify these two fields
    to include some more helpful markup.
  prefs: []
  type: TYPE_NORMAL
- en: We can edit the first two fields named `span` tag with the `money` class. However,
    note that when writing a `money` class, we should not include quote marks. Otherwise,
    we risk breaking the currency formatting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Example of updating the store currency formatting'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.08_B17606.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – Example of updating the store currency formatting
  prefs: []
  type: TYPE_NORMAL
- en: By including the `span` tag with the `money` class inside the currency formatting,
    we have now ensured that each pricing element in our store will contain the same
    selector, which will help if we need to update the pricing dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, **math filters** are self-explanatory, as they allow us to
    perform specific mathematical tasks. Similarly, as with the string and array filters,
    we can chain multiple math filters inside one line, in which case, the filters
    will apply in order from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have familiarized ourselves with the money and math filters, let's
    see them in action and start working on our next mini project.
  prefs: []
  type: TYPE_NORMAL
- en: Product discount price
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following project, we will be learning about the math and money filters
    by working on one of the projects we started in [*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079),
    *Diving into Liquid Core with Objects*, which is `Custom collection`, located
    under the *Global Objects* section.
  prefs: []
  type: TYPE_NORMAL
- en: We aim to create the product discount price and update the sale badge to display
    an actual percentage discount. Let's start by navigating to the location of the
    code that we have previously developed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created the `Custom collection` feature by including the `collection-form.liquid`
    snippet inside the `collection.liquid` file, located under the `Templates` directory.
    Inside the `collection-form.liquid` snippet, we will see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: With the current setup, we display both the regular price and the comparison
    price, so let's start by modifying the comparison price and replacing it with
    the actual discount price. To output the discount between the two prices, it should
    be relatively straightforward as we only need to subtract the regular price from
    the comparison price.
  prefs: []
  type: TYPE_NORMAL
- en: 'To subtract the regular price from the comparison price, we will need to use
    the `minus` math filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Notice that with the introduction of the `minus` filter, we had to remove the
    `money` filter entirely. As previously mentioned, we can only use math filters
    if all the values are number values. If we were to include `money` filters, we
    would turn both values into a string due to our previously set currency formatting.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have successfully applied the `minus` filter, we need to think of
    a way to include the `money` filter. With the current setup, we have received
    a number value without any currency formatting. However, as mentioned, if we were
    to apply the `money` filter to any of the two values, even after `product.price`,
    the `money` filter would only affect `product.price`, not the final results. Consequently,
    the math filter would no longer work.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this, we would need to introduce a variable using an `assign` or
    `capture` keywords to calculate the difference between the two numbers and later
    call the variable with the `money` filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If we preview our collection page now, we will see that we have correctly performed
    both the discount price calculations and the currency formatting. So now we can
    move to the second part of our project, which is replacing the sale badge with
    an actual percentage value discount.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find the sale badge HTML code within the same `collection-form.liquid`
    snippet file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate the discounted percentage, we can use the following formula, which
    will return the discounted percentage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we had to include the calculation inside a variable
    so that later we could apply the `money` filter. However, since this time we do
    not need money, we can simply include the calculation with the addition of the
    percentage string at the end. Let''s put it all together now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As we had the chance to see, similarly as with the string filters, we could
    chain multiple math filters easily to perform the calculations we needed. However,
    it is worth mentioning that besides only working with number values, math filters
    do not accept any type of brackets, which we would usually use to perform math
    calculations in specific priority.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to perform calculations, we have two choices. The first one is that
    we let Liquid perform math calculations from left to right. On the other hand,
    if we need to perform calculations in a specific order, we will need to split
    the formula into multiple variables and combine the results later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs: []
  type: TYPE_NORMAL
- en: For additional information on all the available math filters, we can refer to
    [https://shopify.dev/docs/themes/liquid/reference/filters/math-filters](https://shopify.dev/docs/themes/liquid/reference/filters/math-filters).
  prefs: []
  type: TYPE_NORMAL
- en: For additional information on all the available money filters, we can refer
    to [https://shopify.dev/docs/themes/liquid/reference/filters/money-filters](https://shopify.dev/docs/themes/liquid/reference/filters/money-filters).
  prefs: []
  type: TYPE_NORMAL
- en: While we have not covered all the math and money filter types, we have gained
    a solid understanding of how both math and money filters work through this project.
    This type of knowledge will serve as a stepping stone for the features that we
    will be working on as Shopify experts.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the additional filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **additional filters** are a set of filters that do not fit under any other
    filter groups. However, this does not make them any less important. While there
    are many types of filters that we can name here, we will only mention three of
    them that are the most essential as we will be using them regularly.
  prefs: []
  type: TYPE_NORMAL
- en: The default filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As its name suggests, the `nil`, `false`, or an empty string. If the variable
    contains whitespace characters, we will not be able to return the `default` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: By introducing the `default` value in the previous example, we have ensured
    that we will not end up with a broken string even if the customer has not provided
    us with their name. Additionally, we also make our code look a lot cleaner. Without
    the `default` filter, we would have to use an `if` statement to check whether
    `customer.name` exists, and depending on the results, output the value.
  prefs: []
  type: TYPE_NORMAL
- en: The t (translation) filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Locales` directory. If we navigate to the `Locales` directory, we will
    notice a large number of files. However, one of them will contain the string default,
    which is the currently active language in our store.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look over one of our previous projects, `Custom collections`, which we
    worked on in [*Chapter 4*](B17606_04_Final_PD_ePub.xhtml#_idTextAnchor079), *Diving
    into Liquid Core with Objects*, in the *Working with global objects* section,
    where we developed a submit button whose value we hardcoded with the text **Add
    to Cart**. This works well for now, *but what if we changed our store language?*
    We would have to update any occurrence of the **Add to Cart** string manually
    for the entire theme.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `t` filter, we can update any string value through our entire theme
    by updating a single value. The first thing that we need to do is to define the
    three-level JSON inside the currently active language file using the Shopify naming
    and grouping guidelines. Since we are looking to modify the submit button of a
    product, we can set the first level to product, the second to something more specific,
    which is the form itself, and finally, the third level points to the string we
    are looking to translate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have successfully created the JSON inside the language file, all that
    is left is to use the `t` filter to read the translated key value and render it
    on the storefront:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: By implementing a `t` filter on all product forms, we will gain the ability
    to automatically translate all the strings without having to search for them throughout
    our files manually. Additionally, using the same JSON naming and grouping inside
    the other language files will allow us to quickly translate our entire theme by
    simply changing the store language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `t` filter is a powerful tool that allows us to pass multiple arguments
    by separating them with commas and interpolating them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we are trying to access the customer string inside
    the language file. However, we have also passed the `customer.name` value as an
    argument, which we have then interpolated inside the language JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Besides providing us with the ability to interpolate the variables, we can also
    escape the translated content, include the HTML in translation keys, and pluralize
    translation keys, making it a pretty powerful tool at our disposal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs: []
  type: TYPE_NORMAL
- en: For additional information on the `t` filter naming and grouping guidelines,
    we can refer to [https://shopify.dev/tutorials/develop-theme-localization-organize-translation-keys](https://shopify.dev/tutorials/develop-theme-localization-organize-translation-keys).
  prefs: []
  type: TYPE_NORMAL
- en: For additional information on all the available arguments for the `t` filter,
    we can refer to [https://shopify.dev/tutorials/develop-theme-localization-use-translation-keys](https://shopify.dev/tutorials/develop-theme-localization-use-translation-keys).
  prefs: []
  type: TYPE_NORMAL
- en: Once we have created the necessary translation keys, we can also update the
    translation by navigating to our admin page and clicking on **Themes** located
    inside the expanded **Online store** option within the sidebar. Clicking on the
    **Actions** button on the theme file will trigger a dropdown, whereby clicking
    on **Edit Language** will quickly update any translation inside the language JSON
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JSON filter, as its name suggests, allows us to convert strings into JSON,
    and more importantly, will make Liquid code readable by JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note that when using the JSON filter on Liquid output, there is no need to include
    quotations marks, as the JSON filter will include them automatically. However,
    note that specific values, such as the `inventory_quantity` and `inventory_policy`
    fields, are not something that we can return via JSON, as Shopify has deprecated
    these fields due to security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs: []
  type: TYPE_NORMAL
- en: For additional information on all the available additional filters, we can refer
    to [https://shopify.dev/docs/themes/liquid/reference/filters/additional-filters](https://shopify.dev/docs/themes/liquid/reference/filters/additional-filters).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how using something trivial such as a filter
    to manipulate different data types can create powerful features. We have learned
    how using URL and HTML filters can provide us with access to the various types
    of assets throughout Shopify and help us generate them in the storefront using
    their respective HTML tags.
  prefs: []
  type: TYPE_NORMAL
- en: Working on the product media gallery project has provided us with a deeper understanding
    of media objects and filters, which every developer needs to be familiar with.
    The product accordions project taught us how to easily manipulate data using string
    and array filters to create unique page content elements that are clean and easily
    maintainable. Moving on to the math and money filters, we have gained much-needed
    insight into performing complex calculations through Shopify and formatting the
    prices according to the currency formatting set in our store.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we learned about the additional filters, which provided us with essential
    knowledge on how we can assign default value variables with no assigned values
    and make Liquid code readable by JavaScript. By understanding how to use the translation
    keys, we now have the necessary knowledge to quickly update any value across our
    theme without manually updating each value.
  prefs: []
  type: TYPE_NORMAL
- en: The knowledge that we have attained through this chapter will be especially
    helpful in the next chapter, where we will learn more about the JSON settings
    and how we can use them to create settings that merchants can access using the
    theme editor.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose that we have an array named `product_handles` with handles of 30 products.
    What issue in the following code would prevent us from outputting the images of
    all 30 products successfully?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Why is only using the `model_viewer_tag` tag not recommended when creating the
    product media gallery?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Which filter could we use if we were looking to access an item at a specific
    location inside the array?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What filter can we use to quickly update any occurrence of a string value inside
    the theme files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Practice makes perfect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Project 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In one of our previous exercises, we learned how to create basic and complex
    product galleries by outputting all types of product media types. *However, what
    if we only needed to output several images related to the specific variant at
    a time?*
  prefs: []
  type: TYPE_NORMAL
- en: For our third project, we will be working on rendering a product media gallery
    with distinctive markings that will allow us to show only the thumbnails of the
    currently selected variant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the instructions for the assets:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new page template using the name `variant-thumbnails.liquid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new page named `Product Variant Thumbnails`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new layout file with the name `alternate.liquid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new product with at least three color variants and upload at least
    three media assets to represent each variant. When creating a new product, we
    should set the product status to Active and not leave it to Draft. Otherwise,
    we will not be able to access it later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two new asset files, a stylesheet with the name `custom.css` and a script
    file with the name `script.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new snippet file with the name `custom-media`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following are the steps for the assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit the new layout file by including two asset files that we have previously
    used throughout this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the layout file to the previously created page template and assign the
    new page template to the newly created page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the `red_This` is an image description. Repeat the process for all
    images. Note that each variant should have at least three images to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `variant-thumbnails.liquid`, create a variable that we will use to access
    the previously created product object using the product handle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a `for` loop, access the product media object, and pass the media object
    inside the `custom-media` snippet as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the snippet, using the case-control flow tag and the object that we have
    passed as a parameter, create code that will output each media file type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit each `media` tag to include three attributes. The first one, `data-variant`,
    will contain the first part of the media alt text before the underscore. The second
    attribute, `alt`, will contain the second part of the media alt text. Finally,
    the third attribute, named `index`, will contain the index position value of the
    media file. If we are having trouble calling the `forloop` object's index value
    directly inside the snippet, we might want to pass it as a parameter through the
    snippet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the attributes in place, we should have all the necessary elements needed
    to filter out product media files and only display the thumbnails related to the
    currently selected color variant using the `data-variant` attribute value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For those looking to finalize the project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply the necessary styling inside `custom.css` and the necessary script inside
    `script.js` that will hide or display only the media files with the correct `data-attribute`
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additionally, we can create a new `for` loop that will serve as a primary media
    gallery.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include any type of slider plugin, such as a Slick slider, and connect it to
    the primary media gallery.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clicking on the thumbnail media asset should automatically make the primary
    slider scroll to the selected asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
