- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you’ve read all the chapters of this book from the very beginning, you’ll
    have not only an idea of the theoretical background but also a good set of tools
    at hand that will help you write great **PHP: Hypertext Preprocessor** (**PHP**)
    code. Of course, you can just go and refactor all the code there is, probably
    using some automated code manipulation capabilities our tools offer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will not write perfect code on the first try—it usually takes several iterations
    until you are satisfied. And since you never stop learning, you will refactor
    parts of your code even months or years later. Yet even the most sophisticated
    code quality tools will not prevent you from having to do one tedious task: testing
    your code after you’ve made changes to ensure that it still works as expected.
    That is why in this chapter, we want to introduce you to **automated testing**.'
  prefs: []
  type: TYPE_NORMAL
- en: Through automated testing, you will be able to verify that your improvements
    to the code did not break its functionality in a fast and reliable way. This is
    one of the cornerstones of writing clean code since it enables you to refactor
    code with confidence.
  prefs: []
  type: TYPE_NORMAL
- en: The topic of automated testing deserves a whole book or two, so we can only
    scratch the surface here. Yet since we are convinced you will greatly benefit
    from it in your daily work, we hope that this chapter will make you want to learn
    more about this exciting topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sections will give you a good overview:'
  prefs: []
  type: TYPE_NORMAL
- en: Why you need automated tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of automated tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: About code coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Additional to the technical requirements of the previous chapters, you will
    need to install the **Xdebug** PHP extension. We will provide you with more information
    on that topic in the corresponding section, *About code coverage*, later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Clean-Code-in-PHP](https://github.com/PacktPublishing/Clean-Code-in-PHP)'
  prefs: []
  type: TYPE_NORMAL
- en: Why you need automated tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although **PHPUnit**, the standard unit testing framework for PHP, has existed
    since 2006, automated tests are still not used in all PHP projects today. A lot
    of potential is wasted here because automated tests have many benefits, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speed and reliability**: Imagine you need to execute the same testing steps
    over and over. Soon enough, you would make mistakes, or just skip the tests at
    some point. Automated tests, however, do the boring work for you in a much faster
    and more reliable way—and they do not complain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: With automated tests, you can indirectly document the functionality
    of code through assertions, which explain what the code is expected to do. Compared
    to comments or articles in a wiki, you will immediately be notified by the failing
    tests when something has changed significantly. We will discuss this topic again
    in [*Chapter 13*](B19050_13.xhtml#_idTextAnchor195)*, Creating Effective Documentation,*
    when we talk about creating effective documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Onboarding**: A test suite with good coverage of our code will help new developers
    to get productive on a project faster. Not only do the tests act as additional
    documentation, but they also let the developers make changes or add features with
    confidence. They can verify that their changes do not break anything before they
    get deployed to any staging or production environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous integration/continuous deployment (CI/CD)**: Be it CI or CD, if
    your tests are automated, you can trust through your build pipeline that the code
    you merge is not broken, which enables you to push code to production faster,
    and thus more often. In the next chapter, we will have an in-depth look at this
    topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better code**: You do not strictly have to follow the infamous **test-driven
    development** (**TDD**) approach to benefit from tests already in development.
    Writing unit-testable code even improves your code. To be able to test code in
    isolation (for example, without having a real database running in the background),
    you need to write your code with separation in mind. If external dependencies
    are injected using **dependency injection** (**DI**), they are much easier to
    replace with test objects than if you instantiate them in the class functions.
    We will have a closer look at the **DI pattern** in [*Chapter 12*](B19050_12.xhtml#_idTextAnchor174)*,
    Working in a Team*. Additionally, long and complex functions are equally hard
    to test as short ones (think of—for example—the **NPath complexity** here, which
    we discussed in [*Chapter 8*](B19050_08.xhtml#_idTextAnchor100)), so you will
    very soon start to write shorter functions to reduce the number of decision paths
    in your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier refactoring**: Automated tests are an invaluable tool when you want
    to refactor a project based on the results of the static code analyzers we introduced
    back in [*Chapter 7*](B19050_07.xhtml#_idTextAnchor084). You can apply their recommendations
    or even the automated code fixes, and just after running the tests, you will know
    if this introduced any side effects or not. Since refactoring is the most important
    use case for us in the context of this book, we will discuss it in more detail
    in the next section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD
  prefs: []
  type: TYPE_NORMAL
- en: 'TDD is a way of developing code that combines writing tests and the actual
    code at the same time. The basic idea is simple and often referred to as **red/green/refactor**:
    before you write any code for a new feature or even a bug fix, the first step
    is to write a test that checks the expected outcome. Since you have no actual
    code written yet, the tests will fail (indicated by the color red). In the second
    step, you write the code, without paying too much attention to making it perfect,
    until the tests pass (green). Since you now already have working tests, you can
    easily improve (refactor) the code until you are satisfied.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The TDD paradigm ensures that you will have all your code covered with tests
    and that the code is already written in a fully testable way. Do not take things
    too seriously, though: there are times when you just want to experiment without
    having a clear goal in mind—for example when you play around with a new **application
    programming interface** (**API**). In this case, you do not need to follow TDD.'
  prefs: []
  type: TYPE_NORMAL
- en: Easier refactoring with tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you start a project *on the green* (that is, you write it from scratch),
    you can have the comfort of getting immediate feedback from your code quality
    tools as soon as you start coding it. This is a great help, yet even the best
    tools will not prevent you from making bad decisions and writing code that you
    will want to undo at some point.
  prefs: []
  type: TYPE_NORMAL
- en: That happens to everyone and should not discourage you at all. You learn something
    new every day, and while your personal skills evolve, so will your code. If you
    look at your code from 1 year ago, you’ll probably want to refactor it right away.
  prefs: []
  type: TYPE_NORMAL
- en: And of course, not only your skills, but the whole PHP ecosystem constantly
    improves. Many things that are standard today were simply non-existent back in
    the day. New packages or language features are constantly being introduced, and
    you want to use them in your projects to not stick with the old techniques forever.
  prefs: []
  type: TYPE_NORMAL
- en: So, code changes over time—that is completely normal, and we as developers should
    embrace change; no piece of our code will ever be final. We refer to changing
    existing code as **refactoring**. The interesting part about refactoring is that
    code gets changed, but the software appears unchanged to the user. All work happens
    “under the hood”. If you—for example—updated the framework of your project to
    the latest version, and the users noticed no direct changes, then you did your
    job well.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring has benefits; otherwise, we would not do it. If done right, it can
    lead—for example—to improved performance, increased security, or generally allows
    an application to be scalable in the cloud. And yet, refactoring often comes with
    a bad connotation. Managers in particular tend to think that refactoring means
    changing code just because there is yet another hype in the web development world
    the engineers want to follow, and precious working hours are wasted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us be honest: of course, this happens too. The line is often difficult
    to draw. For example, imagine your duty is to maintain an old but perfectly working
    PHP application that uses the **Singleton pattern** for object instantiation.
    If you only have to do small changes occasionally, there actually is no need to
    refactor it to use DI. However, if you are required to implement ongoing changes,
    such as adding new modules and tests for it, it might be a good choice to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, you will have to justify your refactoring work. It is then helpful to
    rather speak of **system health maintenance** on the code instead. Everybody is
    completely fine with the fact that machines require maintenance: parts get replaced,
    the lubricant must be renewed, and so on. Yet, for some reason, our software ought
    to work forever.'
  prefs: []
  type: TYPE_NORMAL
- en: Having good arguments for refactoring now, we want to understand how testing
    can help us here. To accomplish that, let us have a closer look at the different
    test types there are in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Types of automated tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although **unit tests** are probably the most known type of automated testing,
    there is more to discover. In this section, we will introduce the most common
    (and important) test types. A well-known testing concept is the **testing pyramid**,
    which is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Testing pyramid'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.1_B19050.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.1: Testing pyramid'
  prefs: []
  type: TYPE_NORMAL
- en: This concept basically shows three types of tests—namely, **end-to-end tests**
    (or **E2E tests** in short), **integration tests**, and **unit tests**. We will
    explain each test type and its position in the testing pyramid in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name implies, **unit tests** are about testing small units of code. It
    is best practice to write one test for each functionality of an object only; otherwise,
    the tests will become bigger and harder to understand and maintain. This keeps
    the tests small as well, and that is why there is usually a lot of them. Depending
    on the project size, having hundreds or thousands of unit tests is completely
    normal, so it is important to keep them executing as fast as possible. Usually,
    they should not take longer than a few microseconds each.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests should run in isolation, which means that in the tests, the tested
    objects do not interact with any other external services, such as databases or
    APIs. This is achieved by faking the external dependencies, which is called **mocking**
    in unit testing jargon. Simply speaking, we replace external objects—such as services
    or repositories that are used within our test object—with **mock objects** (or
    **mocks**, in short). These objects simulate the behavior of the dependencies
    they replace during the runtime of the unit tests. This ensures that a test does
    not suddenly fail just because—for example—some data in the database, which our
    test was relying on, has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Because tests of this type are small, fast, and do not rely on external dependencies,
    it is relatively easy to create a test setup for them. They are extremely helpful
    because they can tell you within seconds if your last changes to the code caused
    any problems or not. That is why they are the foundation of the testing pyramid.
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to testing, it makes sense to start with **PHPUnit**, as it is
    the industry standard in the PHP world. If you start on a new project, it is most
    likely that PHPUnit will be used. There are other testing frameworks that have
    their unique advantages, such as **Pest** ([https://pestphp.com](https://pestphp.com)).
    Once you have grasped the concept of unit testing with PHPUnit, we encourage you
    to give them a try as well.
  prefs: []
  type: TYPE_NORMAL
- en: A drawback of unit tests is the fact that they do not interact with each other.
    This may even lead to having all your tests passing while your application is
    broken, just because the interaction between the classes was not tested properly.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this problem, we create an elementary demo application. Let us
    have a look at the most important parts of it.
  prefs: []
  type: TYPE_NORMAL
- en: Demo application source code
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find the full source code in the GitHub repository to this book:'
  prefs: []
  type: TYPE_NORMAL
- en: https://github.com/PacktPublishing/Clean-Code-in-PHP
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a rudimentary class, called `MyApp`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `MyRepository` method gets injected through the constructor. The only method,
    `run`, uses the repository to fetch data and concatenate it. It is important to
    note that `MyClass` expects a certain array structure to be returned by `MyRepository`.
    This is not recommended to do, but you will still find this a lot “in the wild”.
    Therefore, it serves perfectly as a demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: '`MyRepository` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In real life, `MyRepository` would fetch the data from an external data source,
    such as a database. For our example, it returns a hardcoded array. If the `run`
    method of `MyClass` gets executed, it will return a `some data...and some more
    data` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we also added tests (using PHPUnit) for the preceding classes. For
    brevity, we will only show the test cases in the following code snippet, not the
    whole test classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Arrange-Act-Assert (AAA) pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that we added three lines of comments to both of our test
    cases: `Arrange`, `Act`, and `Assert`. We did that to demonstrate the most used
    pattern to write unit tests: the **AAA pattern**. Even without having ever written
    a single unit test yourself, it helps you to understand how they work.'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the test objects and required prerequisites such as mock objects get
    prepared (`Arrange`). Secondly, the actual work of the object under test is executed
    (`Act`). Finally, we ensure that the results of the test meet our expectations
    (`Assert`). If one of the assertions is not met, the whole test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two things are noteworthy here, as set out next:'
  prefs: []
  type: TYPE_NORMAL
- en: In `testRun()`, we create a `$repositoryMock` mock instead of using the actual
    `MyRepository` method. This is because we assume that `MyRepository` would normally
    fetch the data from an external data source, and we do not want to write unit
    tests that have external dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`testGetDataReturnsAnArray()` does not test the repository very well. We just
    check if the result is an array and that it has two entries, but not which array
    keys are returned.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, imagine that for whatever reason, one fellow developer decided that the
    `value_1` and `value_2` array keys were too long, and renamed them `val1` and
    `val2`. If we now execute our application, it will of course break, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you execute the tests, they will still pass, as we see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This illustrates that having unit tests is important, but it does not necessarily
    mean that we will not introduce bugs anymore because they can be faulty or they
    test the wrong things, as in our example.
  prefs: []
  type: TYPE_NORMAL
- en: Often enough, objects such as **repositories** that interact with external systems
    are not tested at all because it requires a more complex test setup—for example,
    using an additional test database with fake data. If we just replace such an object
    with a mock, the test will work correctly. If there are significant changes on
    the original object later and the mock does not get updated to reflect those changes,
    we can end up in a situation like we just described.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this problem, we need a way to additionally test our classes without
    replacing dependencies with mocks. For that, we will introduce the second test
    type of the testing pyramid—integration tests—in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second types of test we want to look at are **integration tests**. Unlike
    unit tests, which are supposed to not use any external dependencies, with this
    test type we want to do the opposite: we want to test code as it would normally
    run, without replacing anything with mocks.'
  prefs: []
  type: TYPE_NORMAL
- en: You might have already witnessed unit test suites that made use of a test database
    or some external API. Technically speaking, these tests are not unit tests anymore,
    but integration tests (or **functional tests**, as they are also called). We could
    theoretically use PHPUnit for these tests as well, or use particular testing tools
    that take over a lot of groundwork for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows an example of an integration test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function shows what an integration test could look like if we
    used the `$tester` gets passed into the test that is a `Helper` object that offers
    the functionality we need to perform—for example, database checks. After executing
    the `save` method on the `$product` test object, we use this `Helper` object to
    validate if the data we would expect has actually been written into the database.
  prefs: []
  type: TYPE_NORMAL
- en: Codeception
  prefs: []
  type: TYPE_NORMAL
- en: Codeception ([https://codeception.com](https://codeception.com)) combines a
    variety of test types, such as unit, integration, and even E2E tests in one tool.
    Under the hood, it is based on existing tools such as PHPUnit. It offers modules
    for all major frameworks and thus integrates well into most PHP projects.
  prefs: []
  type: TYPE_NORMAL
- en: Using integration tests makes the test setup more complex because we must make
    sure that the external dependencies we use are always in a reliable state. For
    example, if you need to rely on a certain user in your database, you must make
    sure that it always has the same data, such as the user **identifier** (**ID**)
    you test for; otherwise, your tests will fail. This usually requires creating
    a fresh test database before every test run, to make sure no leftovers from previous
    test runs disturb our test. Furthermore, we need to run **database migrations**
    to ensure that the test database schema is up to date. Finally, we have to fill
    it with test data, which is called **seeding**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main drawback of this test type is the execution speed. Database transactions
    are slow (compared to using mock objects), and we need to prepare the test database
    upon every test run. Integration tests also tend to break easier, or they become
    flaky (unstable) because the interaction with other dependencies quickly becomes
    very complex: if the previous test changed the database in a way the next test
    did not expect, your test run fails, although the code has not changed.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, a new test is added to the test suite that checks if a class updates
    a dataset in a certain way. Since this is an integration test, it will use the
    test database for it and change that particular dataset. After the execution of
    this test, however, the changed data will still be in the test database. If another
    test that runs *after* this new test is relying on the previous data, it will
    fail. Despite the added complexity of your test setup, integration tests ensure
    that the integration of tested objects within the application context works fine.
    That is why they should be an integral part of your test strategy, being the second
    layer in the testing pyramid.
  prefs: []
  type: TYPE_NORMAL
- en: You will find a lot of integration tests when it comes to testing repositories,
    models, or controllers. However, they cannot test the interaction between PHP
    and the browser. Since we use PHP mainly to build web applications, this is an
    aspect that we should not forget about. Luckily, the last test type from the testing
    pyramid covers exactly this problem.
  prefs: []
  type: TYPE_NORMAL
- en: E2E tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this test type, we will leave the realm of PHP for a moment. With **E2E
    tests**, we want to ensure that the whole flow from the server to the client (for
    example, the browser) and back again to the server is working alright. We basically
    simulate a user sitting in front of the computer and clicking through our application.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we first need a reproducible testing environment. Just as for
    integration tests, we must ensure that the application we want to test is always
    in the same state. This means that we need to ensure that the same set of data
    (for example, blog posts, or articles in a shop) is available on every test run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, we need to automate the user interaction with our testing environment.
    Here is where things get interesting: we not only need the application, but also
    a local web server and a browser to run it in and simulate the user interaction.
    The web server adds more complexity to the test setup but is usually not a blocker.
    For user interaction, we need to use a so-called **headless browser**. Such a
    browser can interact with a server without having to open a browser window. This
    is an extremely useful feature because we can use it on the command line without
    having to install a full-fledged operating system with a **graphical user interface**
    (**GUI**) such as Ubuntu Desktop or Windows. This saves us a lot of installation
    time and helps us not to increase the complexity even further.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, **Google Chrome** is the preferred choice, as it is
    not only the most widely used browser engine nowadays, but also provides a **Headless**
    mode, or in other words, it can act like a headless browser. With modern frameworks
    such as **Cypress**, it is effortless to automate user interaction with our application.
    Think of it as a script that tells the browser which **Uniform Resource Locator**
    (**URL**) to open, which button to click, and so on. The following example shows
    a simplified Cypress test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Cypress
  prefs: []
  type: TYPE_NORMAL
- en: The Cypress testing framework ([https://www.cypress.io/](https://www.cypress.io/))
    makes writing E2E tests very easy, as it handles the setup of and communication
    with the headless browser for you. Yes—the tests are to be written in JavaScript,
    but that should not stop you from giving it a try.
  prefs: []
  type: TYPE_NORMAL
- en: The `cy` object represents the tester, which executes certain steps. In the
    preceding code example, it firstly opens the login page of a fictive application,
    fills out the `#username` and `#password` fields in a login form, and submits
    it by clicking on the **#submit** button. As the last step, it checks whether
    the login was successful and if the tester has been forwarded to the home screen.
    All these actions are then executed in a real browser, running in the background.
    Using this technology, it is possible to write test suites that literally click
    through our application, just as a human being would. They do not just test the
    PHP code but also the frontend code—a JavaScript error, for example, will quickly
    break the tests. Even if you cannot fix the bug yourself, you can still inform
    the frontend engineers in your team that there is a problem.
  prefs: []
  type: TYPE_NORMAL
- en: The modern frameworks make it much easier to write tests than was the case with
    older technologies, such as Selenium. In fact, it is so comfortable nowadays that
    also people who are not developers but have a solid technical foundation, such
    as **quality assurance** (**QA**) engineers, can easily write their own test suites.
    This approach takes a lot of pressure from the teams because the developers have
    to write fewer tests, and the QA people can set up their tests as they need them
    without having to wait for the developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, E2E tests have some drawbacks, which is why they are just the third
    layer of tests in the testing pyramid: the test environment is more complex and
    needs more work to set up, especially if a database or any external API is used.
    This test type is also the slowest since it involves the browser in addition to
    the test setups of the previous test types. Lastly, these tests can easily break
    because usually, the testing frameworks use `id` and `class` attributes, or even
    **Document Object Model** (**DOM**) selectors, to navigate through the DOM and
    find elements to interact with. Thus, a small change on the DOM can quickly break
    your whole test suite.'
  prefs: []
  type: TYPE_NORMAL
- en: Page objects
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in creating maintainable E2E tests, you should check out
    the concept of **page objects** ([https://www.martinfowler.com/bliki/PageObject.html](https://www.martinfowler.com/bliki/PageObject.html)).
  prefs: []
  type: TYPE_NORMAL
- en: The testing pyramid in practice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With unit, integration, and E2E tests, you now know the three most important
    test types, and their pros and cons. The suggested approach of having unit tests
    as a huge foundation, a fair amount of integration tests, and—finally—some E2E
    tests is a good starting point.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you do not have to strictly follow it all the time, since every project
    is different: if you, for example, want to start testing a yet completely untested
    application, introducing unit tests would require a lot of refactoring effort
    to make the classes testable. This refactoring will most likely introduce more
    bugs in the beginning than it will solve.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, starting with a good E2E test coverage will be quicker and safer.
    Once the main parts of the application can be automatically tested, you can safely
    start with the refactoring and introduce unit and/or integration tests. If your
    application breaks because of the necessary refactoring, your E2E tests have you
    covered.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, we will list some more test types for you to evaluate
    if you are interested. For now, the three test types we covered in this chapter
    are the most important ones and should be enough for you to get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important question that we have not really covered yet, though:
    how much of your code do you really need to test? We will discuss this in the
    next section.'
  prefs: []
  type: TYPE_NORMAL
- en: About code coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we’ve explored the different test types, you probably want to start writing
    tests right away. But before you put this book away to get coding, let us finish
    this chapter with the question of how much of your code you should test.
  prefs: []
  type: TYPE_NORMAL
- en: A part of the answer lies within the concept of code coverage, which we already
    briefly mentioned in [*Chapter 8*](B19050_08.xhtml#_idTextAnchor100)*, Code Quality
    Metrics* when we talked about code quality metrics. Let us have a closer look
    at it now.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding code coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Code coverage** measures the proportion of code that is covered with tests.
    The higher the code coverage, the better—if there are more tests, the software
    is less likely to contain bugs, and it will be harder to introduce new ones unnoticed.
    Higher code coverage is also a possible indicator of better code quality—as we
    discussed in a previous section of this chapter, tested code must be written in
    a certain way, which usually leads to better quality.'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the degree of coverage is expressed simply using the percentage of
    tested code—that is, from 0% (fully untested) to 100% (complete code coverage).
    But how can we measure code coverage? For that, we will use PHPUnit, as it can
    create a code coverage report for us. However, it requires an additional PHP extension
    for the code coverage functionality. For this chapter, we decided to use **Xdebug**,
    the standard PHP **debugger** and **profiler**.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Xdebug
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Xdebug is an extension for PHP, so it requires to be loaded as a module. Since
    its installation is a bit more complex and mainly depends on the operating system
    you are running PHP on, please refer to the official documentation at [https://xdebug.org](https://xdebug.org)
    on how to install and configure it. There are also plenty of tutorials available
    on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: If you refactor your code, you probably want to know what performance implications
    the changes had. Did you improve the execution time, or did it get even worse?
    With a so-called **profiler**, you can measure the execution time of each function
    in detail and see where bottlenecks are hidden.
  prefs: []
  type: TYPE_NORMAL
- en: 'We cannot cover this topic in our book, but since over the course of this chapter
    we already worked with Xdebug, you might want to check out its profiling capabilities
    as well: [https://xdebug.org/docs/profiler](https://xdebug.org/docs/profiler).
    Other commercial services that offer more comfort are—for example—**Tideways**
    ([https://tideways.com](https://tideways.com)) or **Blackfire** ([https://www.blackfire.io](https://www.blackfire.io)).'
  prefs: []
  type: TYPE_NORMAL
- en: Xdebug alternatives
  prefs: []
  type: TYPE_NORMAL
- en: Please note that you can use other extensions for this, such as **PCOV** ([https://github.com/krakjoe/pcov](https://github.com/krakjoe/pcov)),
    which performs better if you only want to do code coverage reports. However, Xdebug
    is an incredibly useful debugger that you should know—if you do not, we encourage
    you to check out some tutorials about it.
  prefs: []
  type: TYPE_NORMAL
- en: How to generate code coverage reports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate how to create a code coverage report, we will use our little
    demo application from the previous section of this chapter. To follow up on the
    example, check it out from GitHub, run `composer install`, and make sure you have
    Xdebug installed with `mode` set to `coverage`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start generating a report, let us see which report formats PHPUnit
    has to offer. It can generate reports in a variety of formats that you will most
    likely not need right now, such as `Clover`, `Cobertura`, `Crap4J`, or the `PHPUnit`
    XML format. They can get more relevant, though, when you start integrating PHPUnit
    with other tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we do not want to do this in this book, so we are only interested
    in the two most accessible formats: text and HTML. The text format can directly
    be printed on the command line, which is useful when you want instant results
    or to integrate PHPUnit in your build pipeline, while the HTML format offers more
    information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, we want to write both report formats into a new folder called
    `reports` in the project root. Although you can generate them using the many PHPUnit
    runtime options, we want to use the `phpunit.xml` configuration file to define
    what to generate upon every test run. The following code snippet shows a minimal
    version, reduced for readability. In our GitHub repository, you will find the
    full `phpunit.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the basic configuration, which includes a definition of the `tests`
    folder we need for the regular test runs, we added the `<coverage>` node. This
    contains two child nodes: `<includes>` and `<report>`. It is important to specify
    when using the `<includes>` node which directory and file extension should be
    used for collecting code coverage information. Otherwise, PHPUnit will not generate
    any reports, but also will not complain about missing information. This can be
    quite confusing at times.'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we need to tell PHPUnit where to write which reports. We use the
    `<report>` node for this, and as you can see, we specified both the HTML and text
    reports to be written into the `reports` folder in our project root, which will
    be created if it does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'PHPUnit expects the configuration file to be named `phpunit.xml` and to be
    in the project root. If this has been done, you can quickly execute the generation
    of the reports by running the following command without any further options or
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After the execution of the preceding command, you will find a `reports` folder
    generated in your project root. It should contain two things: first, a `coverage.txt`
    file that contains a report in text format, and second, a `coverage` folder that
    contains an HTML report.'
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage is costly
  prefs: []
  type: TYPE_NORMAL
- en: Using Xdebug to generate code coverage reports will slow down the execution
    of your test suite because Xdebug has to collect a lot of data, and it was not
    built for performance. We therefore recommend you enable Xdebug and the report
    generation only if necessary but keep it disabled during your regular test runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The text report is short, but already tells you how well your tests cover your
    application, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: Text code coverage report'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.2_B19050.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.2: Text code coverage report'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get more details, please open the `reports/coverage/index.html` file in
    your browser. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: HTML code coverage report'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.3_B19050.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.3: HTML code coverage report'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find the same information from the text report there, but with a better
    visualization. Furthermore, the report is interactive. For example, if you click
    on the `MyOtherClass.php` link on the left, you will be taken to a detailed report
    for that class, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: HTML code coverage report – class view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.4_B19050.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.4: HTML code coverage report – class view'
  prefs: []
  type: TYPE_NORMAL
- en: 'Two things are noteworthy here: firstly, in the **Functions and Methods** section,
    you might have already recognized the CRAP metric which we introduced in [*Chapter
    8*](B19050_08.xhtml#_idTextAnchor100)*, Code Quality Metrics*. Here, you can finally
    see it in action.'
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the report shows you in detail which lines have been accessed during
    the test (green background), and which have not (red background). If there had
    been any lines that were inaccessible at all (for example, another statement after
    the last `return` statement), it would have been displayed as **Dead Code** (yellow
    background). Dead code can safely be removed.
  prefs: []
  type: TYPE_NORMAL
- en: You now have a nice overview of the code coverage of your project. If files
    appear with a red bar, they have not been executed during the test run at all,
    so this is where you could improve your test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Using the @covers annotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one problem with code coverage: it tells you which code has been *executed*
    during the test, but that does not mean that the executed code has also been *tested*
    (that is, using assertions). This is something that PHPUnit cannot determine automatically.
    This means that even if your code coverage reports show 100% and green bars everywhere,
    it does not mean that your code is well tested. It was just executed during the
    run of your test suite.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome this problem, it is recommended to use the `@covers` annotation
    at the class level, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This improves the accuracy of our tests because by using the `@covers` annotation,
    we explicitly declare which code is meant to be tested by our tests. For example,
    let us say the class under test uses an external service. You only want to test
    that one class, not the service it uses, so you solely write assertions that check
    the class under test. Without the `@covers` annotation, though, PHPUnit would
    still include the external service in the code coverage report because it was
    executed during the test.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `@covers` also on a method level; however, this could cause problems
    if— for example—you refactor a class and extract methods to some other class.
    If you forget to adjust the `@covers` annotation on the method level here, the
    coverage report will not be accurate anymore.
  prefs: []
  type: TYPE_NORMAL
- en: To force usage of the `@covers` annotation, use the `forceCoversAnnotation`
    option in the `phpunit.xml` file. If it is set to `true`, tests that do not use
    the annotation will be marked as risky; they do not fail, but they appear separately
    in the reports as something to be improved. This way, your fellow developers (and
    you) will not forget to use it.
  prefs: []
  type: TYPE_NORMAL
- en: What to test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now know how to get detailed information about how much of our code is tested.
    So, should you strive for complete code coverage now? Should 100% be your goal?
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw in the tests of our example application in a previous part of this
    chapter, writing tests for a class does not automatically mean that you really
    test every aspect of it. Here, unfortunately, even measuring the code coverage
    will not help. However, it can help you identify tests that do not test anything.
    Especially when a lot of mocks are used in a test case, it can happen that only
    the mock gets tested, but no “real code”. Consider the following test case, which
    is a valid test that would pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This example is simplified, but it demonstrates how code coverage reports can
    help because this test would not add a single tested line to our code coverage
    ratio. Unfortunately, no tool can tell you (yet) which tests are well written
    and which should be improved or are even useless, as in our example.
  prefs: []
  type: TYPE_NORMAL
- en: Following the **Pareto principle**, aiming for 80% code coverage should already
    vastly improve your code base, and this can be achieved with a reasonable amount
    of effort. Put your focus on the code that makes your application special—often
    referred to as **business logic**. This is the code that requires most of your
    attention.
  prefs: []
  type: TYPE_NORMAL
- en: Pareto principle
  prefs: []
  type: TYPE_NORMAL
- en: The Pareto principle states that 80% of results are achieved with 20% of the
    total effort. The remaining 20% of the results require the quantitatively most
    work, with 80% of the total effort.
  prefs: []
  type: TYPE_NORMAL
- en: There is also trivial code that does not really need to be tested. A common
    example is testing for getters and setters. If these methods contain further logic,
    it makes sense to test them, of course. But if they are just simple functions
    that set or return the value of a property, it is a waste of time to write tests
    for them. Still, you would need to do this if you would like to strive for 100%
    code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Other examples are configuration files, factories, or route definitions. It
    is sufficient to use E2E or integration tests, which ensure that the application
    works in general. They implicitly (that is, without using concrete assertions)
    test all the **glue code**, which is all the code that keeps your application
    together but is tedious to test.
  prefs: []
  type: TYPE_NORMAL
- en: Particularly, E2E tests are usually not counted into the code coverage metric
    because it is technically difficult to do so. If you have them, though, they will
    add an extra layer of test coverage that cannot be measured. You cannot brag about
    100% code coverage, but you know that all the different test types have your back,
    and that should be our number one goal.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed why you should use automated testing and how it
    improves your code quality. We covered the main three testing types, which are
    unit testing, integration testing, and E2E testing, with their pros and cons,
    potential pitfalls, and our recommendations on how to use them. Finally, you learned
    about the concept of code coverage, and how to use it in your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: Together with the knowledge from the previous chapter about code quality tools
    and how to organize them, in the next chapter, we can finally start combining
    all these tools together into a process that helps to run all of them in structured
    and reliable ways—build pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are more test types out there than we could cover in this chapter. If
    you find the world of automated testing as fascinating as the authors do, you
    might want to check out other test types as well, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mutation testing** is about modifying the code to be tested in tiny changes
    (so-called mutants). If your tests can catch these mutants, they are usually well
    written; otherwise, they will let the mutant escape. **Infection** is currently
    the best-known tool for this test type in the PHP world ([https://infection.github.io](https://infection.github.io)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual regression testing** literally compares screenshots of the application
    made during tests with original screenshots to catch problems in **Cascading Style
    Sheets** (**CSS**). While this is not directly PHP-related, it could be interesting
    for you if you want to keep the styling of your web project perfect. A good candidate
    to check is **BackstopJS** ([https://github.com/garris/BackstopJS](https://github.com/garris/BackstopJS)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API testing** can be considered E2E testing, but just for the API your application
    might provide. Since the tests are based on **Hypertext Transfer Protocol** (**HTTP**)
    requests, a headless browser is not needed, which makes the setup easier. A good
    choice to start with API testing is **Codeception** (https://codeception.com).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavior-driven development** (**BDD**) is a very interesting approach because
    it focuses on the communication between stakeholders (for example, the project
    manager), QA (if there is any), and the developers. This is done by a special
    way of writing tests in a language called **Gherkin**, which basically enables
    non-technical people to write test suites. The BDD tool for PHP is called **Behat**
    ([https://github.com/Behat/Behat](https://github.com/Behat/Behat)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
