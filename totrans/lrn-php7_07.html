<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;6.&#xA0;Adapting to MVC" id="1LCVG1-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. Adapting to MVC</h1></div></div></div><p class="calibre8">Web applications are more complex than what we have built so far. The more functionality you add, the more difficult the code is to maintain and understand. It is for this reason that structuring your code in an organized way is crucial. You could design your own structure, but as with OOP, there already exist some design patterns that try to solve this problem.</p><p class="calibre8">
<span class="strong"><strong class="calibre2">MVC</strong></span> (<span class="strong"><strong class="calibre2">model-view-controller</strong></span>) has<a id="id464" class="calibre1"/> been the favorite pattern for web developers. It helps us separate the different parts of a web application, leaving the code easy to understand even for beginners. We will try to refactor our bookstore example to use the MVC pattern, and you will realize how quickly you can add new functionality after that.</p><p class="calibre8">In this chapter, you will learn the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Using Composer to manage dependencies</li><li class="listitem">Designing a router for your application</li><li class="listitem">Organizing your code into models, views, and controllers</li><li class="listitem">Twig as the template engine</li><li class="listitem">Dependency injection</li></ul></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Adapting to MVC" id="1LCVG1-edcc22b134104d5db0bf3aa086c86851">
<div class="book" title="The MVC pattern"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec50" class="calibre1"/>The MVC pattern</h1></div></div></div><p class="calibre8">So far, each time <a id="id465" class="calibre1"/>we have had to add a feature, we added a new PHP file with a mixture of PHP and HTML for that specific page. For chunks of code with a single purpose, and which we have to reuse, we created functions and added them to the functions file. Even for very small web applications like ours, the code starts becoming very confusing, and the ability to reuse code is not as helpful as it could be. Now imagine an application with a large number of features: that would be pretty much chaos itself.</p><p class="calibre8">The problems do not stop here. In our code, we have mixed HTML and PHP code in a single file. That will give us a lot of trouble when trying to change the design of the web application, or even if we want to perform a very small change across all pages, such as changing the menu or footer of the page. The more complex the application, the more problems we will encounter.</p><p class="calibre8">MVC came <a id="id466" class="calibre1"/>up as a pattern to help us divide the different parts of the application. These parts are known as models, views, and controllers. <span class="strong"><strong class="calibre2">Models</strong></span> manage <a id="id467" class="calibre1"/>the <a id="id468" class="calibre1"/>data and/or the business logic, <span class="strong"><strong class="calibre2">views</strong></span> contain the templates for our responses (for example, HTML pages), and <span class="strong"><strong class="calibre2">controllers</strong></span> orchestrate<a id="id469" class="calibre1"/> requests, deciding what data to use and how to render the appropriate template. We will go through them in later sections of this chapter.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using Composer"><div class="book" id="1MBG22-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec51" class="calibre1"/>Using Composer</h1></div></div></div><p class="calibre8">Even though <a id="id470" class="calibre1"/>this is not a necessary component when implementing the MVC pattern, Composer has been an indispensable tool for any PHP web application over the last few years. The main goal of this tool is to help you manage the dependencies of your application, that is, the third-party libraries (of code) that we need to use in our application. We can achieve that by just creating a configuration file that lists them, and by running a command in your command line.</p><p class="calibre8">You need to install Composer on your development machine (see <a class="calibre1" title="Chapter 1. Setting Up the Environment" href="part0014_split_000.html#DB7S1-edcc22b134104d5db0bf3aa086c86851">Chapter 1</a>, <span class="strong"><em class="calibre12">Setting Up the Environment</em></span>). Make sure that you have it by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ composer –version</strong></span>
</pre></div><p class="calibre8">This should return the version of your Composer installation. If it does not, return to the installation section to fix the problem.</p></div>

<div class="book" title="Using Composer">
<div class="book" title="Managing dependencies"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec85" class="calibre1"/>Managing dependencies</h2></div></div></div><p class="calibre8">As we <a id="id471" class="calibre1"/>stated earlier, the main goal of Composer is to manage dependencies. For example, we've already implemented our configuration reader, the <code class="email">Config</code> class, but if we knew of someone that implemented a better version of it, we could just use theirs instead of reinventing the wheel; just make sure that they allow you to do so!</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note15" class="calibre1"/>Note</h3><p class="calibre8">
<span class="strong"><strong class="calibre2">Open source</strong></span>
</p><p class="calibre8">Open source refers to the code that developers write and share with the community in order to be used by others without restrictions. There are actually different types of licenses, and some give you more flexibility than others, but the basic idea is that we can reuse the libraries that other developers have written in our applications. That helps the community to grow in knowledge, as we can learn what others have done, improve it, and share it afterwards.</p></div><p class="calibre8">We've already implemented a decent configuration reader, but there are other elements of our application that need to be done. Let's take advantage of Composer to reuse someone else's libraries. There are a couple of ways of adding a dependency to our project: executing<a id="id472" class="calibre1"/> a command in our command line, or editing the configuration file manually. As we still do not have Composer's configuration file, let's use the first option. Execute the following command in the root directory of your application:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ composer require monolog/monolog</strong></span>
</pre></div><p class="calibre8">This command will show the following result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">Using version ^1.17 for monolog/monolog</strong></span>
<span class="strong"><strong class="calibre2">./composer.json has been created</strong></span>
<span class="strong"><strong class="calibre2">Loading composer repositories with package information</strong></span>
<span class="strong"><strong class="calibre2">Updating dependencies (including require-dev)</strong></span>
<span class="strong"><strong class="calibre2">  - Installing psr/log (1.0.0)</strong></span>
<span class="strong"><strong class="calibre2">    Downloading: 100%</strong></span>

<span class="strong"><strong class="calibre2">  - Installing monolog/monolog (1.17.2)</strong></span>
<span class="strong"><strong class="calibre2">    Downloading: 100%</strong></span>
<span class="strong"><strong class="calibre2">...</strong></span>
<span class="strong"><strong class="calibre2">Writing lock file</strong></span>
<span class="strong"><strong class="calibre2">Generating autoload files</strong></span>
</pre></div><p class="calibre8">With this command, we asked Composer to add the library <code class="email">monolog/monolog</code> as a dependency of our application. Having executed that, we can now see some changes in our directory:</p><div class="book"><ul class="itemizedlist"><li class="listitem">We have a new file named <code class="email">composer.json</code>. This is the configuration file where we can add our dependencies.</li><li class="listitem">We have a new file named <code class="email">composer.lock</code>. This is a file that Composer uses in order to track the dependencies that have already been installed and their versions.</li><li class="listitem">We have a new directory named <code class="email">vendor</code>. This directory contains the code of the dependencies that Composer downloaded.</li></ul></div><p class="calibre8">The output of the command also shows us some extra information. In this case, it says that it downloaded two libraries or packages, even though we asked for only one. The reason is that the package that we needed also contained other dependencies that were resolved by Composer. Also note the version that Composer downloaded; as we did not specify any version, Composer took the most recent one available, but you can always try to write the specific version that you need.</p><p class="calibre8">We will need another library, in this case <code class="email">twig/twig</code>. Let's add it to our dependencies list with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ composer require twig/twig</strong></span>
</pre></div><p class="calibre8">This command will show the following result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">Using version ^1.23 for twig/twig</strong></span>
<span class="strong"><strong class="calibre2">./composer.json has been updated</strong></span>
<span class="strong"><strong class="calibre2">Loading composer repositories with package information</strong></span>
<span class="strong"><strong class="calibre2">Updating dependencies (including require-dev)</strong></span>
<span class="strong"><strong class="calibre2">  - Installing twig/twig (v1.23.1)</strong></span>
<span class="strong"><strong class="calibre2">    Downloading: 100%</strong></span>

<span class="strong"><strong class="calibre2">Writing lock file</strong></span>
<span class="strong"><strong class="calibre2">Generating autoload files</strong></span>
</pre></div><p class="calibre8">If we check the <code class="email">composer.json</code> file, we will see the following content:</p><div class="informalexample"><pre class="programlisting">{
    "require": {
        "monolog/monolog": "^1.17",
        "twig/twig": "^1.23"
    }
}</pre></div><p class="calibre8">The file <a id="id473" class="calibre1"/>is just a JSON map that contains the configuration of our application; in this case, the list of the two dependencies that we installed. As you can see, the dependencies' name follows a pattern: two words separated by a slash. The first of the words refers to the vendor that developed the library. The second of them is the name of the library itself. The dependency has a version, which could be the exact version number—as in this case—or it could contain wildcard characters<a id="id474" class="calibre1"/> or tag names. You can read more about this at <a class="calibre1" href="https://getcomposer.org/doc/articles/aliases.md">https://getcomposer.org/doc/articles/aliases.md</a>.</p><p class="calibre8">Finally, if you would like to add another dependency, or edit the <code class="email">composer.json</code> file in any other way, you should run <code class="email">composer update</code> in your command line, or wherever the <code class="email">composer.json</code> file is, in order to update the dependencies.</p></div></div>

<div class="book" title="Using Composer">
<div class="book" title="Autoloader with PSR-4"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec86" class="calibre1"/>Autoloader with PSR-4</h2></div></div></div><p class="calibre8">In the <a id="id475" class="calibre1"/>previous chapters, we also added an autoloader to our application. As we are now using someone else's code, we need to know how to load their classes too. Soon, developers realized that this scenario without a standard would be virtually impossible to manage, and they came out with some standards that<a id="id476" class="calibre1"/> most developers follow. You can find a lot of information on this topic at <a class="calibre1" href="http://www.php-fig.org">http://www.php-fig.org</a>.</p><p class="calibre8">Nowadays, PHP has two main standards for autoloading: <span class="strong"><strong class="calibre2">PSR-0</strong></span> and <span class="strong"><strong class="calibre2">PSR-4</strong></span>. They are very <a id="id477" class="calibre1"/>similar, but we will be implementing the latter, as it is <a id="id478" class="calibre1"/>the most recent standard published. This standard basically follows what we've already introduced when talking about namespaces: the namespace of a class must be the same as the directory where it is, and the name of the class should be the name of the file, followed by the extension <code class="email">.php</code>. For example, the file in <code class="email">src/Domain/Book.php</code> contains the class <code class="email">Book</code> inside the namespace <code class="email">Bookstore\Domain</code>.</p><p class="calibre8">Applications <a id="id479" class="calibre1"/>using Composer should follow one of those standards, and they should note in their respective <code class="email">composer.json</code> file which one they are using. This means that Composer knows how to autoload its own application files, so we will not need to take care of it when we download external libraries. To specify that, we edit our <code class="email">composer.json</code> file, and add the following content:</p><div class="informalexample"><pre class="programlisting">{
    "require": {
        "monolog/monolog": "^1.17",
        "twig/twig": "^1.23"
    },
<span class="strong"><strong class="calibre2">    "autoload": {</strong></span>
<span class="strong"><strong class="calibre2">        "psr-4": {</strong></span>
<span class="strong"><strong class="calibre2">            "Bookstore\\": "src"</strong></span>
<span class="strong"><strong class="calibre2">        }</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
}</pre></div><p class="calibre8">The preceding code means that we will use PSR-4 in our application, and that all the namespaces that start with <code class="email">Bookstore</code> should be found inside the <code class="email">src/</code> directory. This is exactly what our autoloader was doing already, but reduced to a couple of lines in a configuration file. We can safely remove our autoloader and any reference to it now.</p><p class="calibre8">Composer generates some mappings that help to speed up the loading of classes. In order to update those maps with the new information added to the configuration file, we need to run the <code class="email">composer update</code> command that we ran earlier. This time, the output will tell us that there is no package to update, but the autoload files will be generated again:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ composer update</strong></span>
<span class="strong"><strong class="calibre2">Loading composer repositories with package information</strong></span>
<span class="strong"><strong class="calibre2">Updating dependencies (including require-dev)</strong></span>
<span class="strong"><strong class="calibre2">Nothing to install or update</strong></span>
<span class="strong"><strong class="calibre2">Writing lock file</strong></span>
<span class="strong"><strong class="calibre2">Generating autoload files</strong></span>
</pre></div></div></div>

<div class="book" title="Using Composer">
<div class="book" title="Adding metadata"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec87" class="calibre1"/>Adding metadata</h2></div></div></div><p class="calibre8">In order to<a id="id480" class="calibre1"/> know where to find the libraries that you define as dependencies, Composer keeps a repository of packages and versions, known as <span class="strong"><strong class="calibre2">Packagist</strong></span>. This<a id="id481" class="calibre1"/> repository keeps a lot of useful information for developers, such as all the versions available for a given package, the authors, some description of what the package does (or a website pointing to that information), and the dependencies that this package will download. You can also browse the packages, searching by name or categories.</p><p class="calibre8">But how does Packagist know about this? It is all thanks to the <code class="email">composer.json</code> file itself. In there, you can define all the metadata of your application in a format that Composer understands. Let's see an example. Add the following content to your <code class="email">composer.json</code> file:</p><div class="informalexample"><pre class="programlisting">{
    "name": "picahielos/bookstore",
    "description": "Manages an online bookstore.",
    "minimum-stability": "stable",
    "license": "Apache-2.0",
    "type": "project",
    "authors": [
        {
            "name": "Antonio Lopez",
            "email": "antonio.lopez.zapata@gmail.com"
        }
    ],
    // ...
}</pre></div><p class="calibre8">The configuration file now contains the name of the package following the Composer convention: vendor name, slash, and the package name—in this case, <code class="email">picahielos/bookstore</code>. We also add a description, license, authors, and other metadata. If you have your code in a pubic repository such as GitHub, adding this <code class="email">composer.json</code> file will allow you to go to Packagist and insert the URL of your repository. Packagist will add your code as a new package, extracting the info from your <code class="email">composer.json</code> file. It will show the available versions based on your tags or branches. In order to<a id="id482" class="calibre1"/> learn more about it, we encourage you to visit the official documentation at <a class="calibre1" href="https://getcomposer.org/doc/04-schema.md">https://getcomposer.org/doc/04-schema.md</a>.</p></div></div>

<div class="book" title="Using Composer">
<div class="book" title="The index.php file"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch06lvl2sec88" class="calibre1"/>The index.php file</h2></div></div></div><p class="calibre8">In MVC <a id="id483" class="calibre1"/>applications, we usually have one file that gets all the requests, and routes them to the specific controller depending on the URL. This logic can generally be found in the <code class="email">index.php</code> file in our root directory. We already have one, but as we are adapting our features to the MVC pattern, we will not need the current <code class="email">index.php</code> anymore. Hence, you can safely replace it with the following:</p><div class="informalexample"><pre class="programlisting">&lt;?php

require_once __DIR__ . '/vendor/autoload.php';</pre></div><p class="calibre8">The only thing that this file will do now is include the file that handles all the autoloading from the Composer code. Later, we will initialize everything here, such as database connections, configuration readers, and so on, but right now, let's leave it empty.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Working with requests"><div class="book" id="1NA0K2-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec52" class="calibre1"/>Working with requests</h1></div></div></div><p class="calibre8">As you <a id="id484" class="calibre1"/>might recall from previous chapters, the main purpose of a web application is to process HTTP requests coming from the client and return a response. If that is the main goal of your application, managing requests and responses should be an important part of your code.</p><p class="calibre8">PHP is a language that can be used for scripts, but its main usage is in web applications. Due to this, the language comes ready with a lot of helpers for managing requests and responses. Still, the native way is not ideal, and as good OOP developers, we should come up with a set of classes that help with that. The main elements for this small project—still inside your application—are the request and the router. Let's start!</p></div>

<div class="book" title="Working with requests">
<div class="book" title="The request object"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec89" class="calibre1"/>The request object</h2></div></div></div><p class="calibre8">As we <a id="id485" class="calibre1"/>start our mini framework, we need to change our directory structure a bit. We will create the <code class="email">src/Core</code> directory for all the classes related to the framework. As the configuration reader from the previous chapters is also part of the framework (rather than functionality for the user), we should move the <code class="email">Config.php</code> file to this directory too.</p><p class="calibre8">The first thing to consider is what a request looks like. If you remember <a class="calibre1" title="Chapter 2. Web Applications with PHP" href="part0019_split_000.html#I3QM2-edcc22b134104d5db0bf3aa086c86851">Chapter 2</a>, <span class="strong"><em class="calibre12">Web Applications with PHP</em></span>, a request is basically a message that goes to a URL, and has a method—GET or POST for now. The URL is at the same time composed of two parts: the domain of the web application, that is, the name of your server, and the path of the request inside the server. For example, if you try to access <code class="email">http://bookstore.com/my-books</code>, the first part, <code class="email">http://bookstore.com</code>, would be the domain and <code class="email">/my-books</code> would be the path. In fact, <code class="email">http</code> would not be part of the domain, but we do not need that level of granularity for our application. You can get this information from the global array <code class="email">$_SERVER</code> that PHP populates for each request.</p><p class="calibre8">Our <code class="email">Request</code> class should have a property for each of those three elements, followed by a set of <a id="id486" class="calibre1"/>getters and some other helpers that will be useful for the user. Also, we should initialize all the properties from <code class="email">$_SERVER</code> in the constructor. Let's see what it would look like:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Core;

class Request {
    const GET = 'GET';
    const POST = 'POST';

    private $domain;
    private $path;
    private $method;

    public function __construct() {
        $this-&gt;domain = $_SERVER['HTTP_HOST'];
        $this-&gt;path = $_SERVER['REQUEST_URI'];
        $this-&gt;method = $_SERVER['REQUEST_METHOD'];
    }

    public function getUrl(): string {
        return $this-&gt;domain . $this-&gt;path;
    }

    public function getDomain(): string {
        return $this-&gt;domain;
    }

    public function getPath(): string {
        return $this-&gt;path;
    }

    public function getMethod(): string {
        return $this-&gt;method;
    }

    public function isPost(): bool {
        return $this-&gt;method === self::POST;
    }

    public function isGet(): bool {
        return $this-&gt;method === self::GET;
    }
}</pre></div><p class="calibre8">We can<a id="id487" class="calibre1"/> see in the preceding code that other than the getters for each property, we added the methods <code class="email">getUrl</code>, <code class="email">isPost</code>, and <code class="email">isGet</code>. The user could find the same information using the already existing getters, but as they will be needed a lot, it is always good to make it easier for the user. Also note that the properties are coming from the values of the <code class="email">$_SERVER</code> array: <code class="email">HTTP_HOST</code>, <code class="email">REQUEST_URI</code>, and <code class="email">REQUEST_METHOD</code>.</p></div></div>

<div class="book" title="Working with requests">
<div class="book" title="Filtering parameters from requests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec90" class="calibre1"/>Filtering parameters from requests</h2></div></div></div><p class="calibre8">Another<a id="id488" class="calibre1"/> important part of a request is the information that comes from the user, that is, the GET and POST parameters, and the cookies. As with the <code class="email">$_SERVER</code> global array, this information comes from <code class="email">$_POST</code>, <code class="email">$_GET</code>, and <code class="email">$_COOKIE</code>, but it is always good to avoid using them directly, without filtering, as the user could send malicious code.</p><p class="calibre8">We will now implement a class that will represent a map—key-value pairs—that can be filtered. We will call it <code class="email">FilteredMap</code>, and will include it in our namespace, <code class="email">Bookstore\Core</code>. We will use it to contain the parameters GET and POST and the cookies as two new properties in our <code class="email">Request</code> class. The map will contain only one property, the array of data, and will have some methods to fetch information from it. To construct the object, we need to send the array of data as an argument to the constructor:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Core;

class FilteredMap {
    private $map;

    public function __construct(array $baseMap) {
        $this-&gt;map = $baseMap;
    }
    
    public function has(string $name): bool {
        return isset($this-&gt;map[$name]);
    }

    public function get(string $name) {
        return $this-&gt;map[$name] ?? null;
    }
}</pre></div><p class="calibre8">This class does not do much so far. We could have the same functionality with a normal array. The utility of this class comes when we add filters while fetching data. We will implement three filters, but you can add as many as you need:</p><div class="informalexample"><pre class="programlisting">public function getInt(string $name) {
    return (int) $this-&gt;get($name);
}

public function getNumber(string $name) {
    return (float) $this-&gt;get($name);
}

public function getString(string $name, bool $filter = true) {
    $value = (string) $this-&gt;get($name);
    return $filter ? addslashes($value) : $value;
}</pre></div><p class="calibre8">These three<a id="id489" class="calibre1"/> methods in the preceding code allow the user to get parameters of a specific type. Let's say that the developer needs to get the ID of the book from the request. The best option is to use the <code class="email">getInt</code> method to make sure that the returned value is a valid integer, and not some malicious code that can mess up our database. Also note the function <code class="email">getString</code>, where we use the <code class="email">addSlashed</code> method. This method adds slashes to some of the suspicious characters, such as slashes or quotes, trying to prevent malicious code with it.</p><p class="calibre8">Now we are ready to get the GET and POST parameters as well as the cookies from our <code class="email">Request</code> class using our <code class="email">FilteredMap</code>. The new code would look like the following:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Core;

class Request {
    // ...
<span class="strong"><strong class="calibre2">    private $params;</strong></span>
<span class="strong"><strong class="calibre2">    private $cookies;</strong></span>

    public function __construct() {
        $this-&gt;domain = $_SERVER['HTTP_HOST'];
        $this-&gt;path = explode('?', $_SERVER['REQUEST_URI'])[0];
        $this-&gt;method = $_SERVER['REQUEST_METHOD'];
<span class="strong"><strong class="calibre2">        $this-&gt;params = new FilteredMap(</strong></span>
<span class="strong"><strong class="calibre2">            array_merge($_POST, $_GET)</strong></span>
<span class="strong"><strong class="calibre2">        );</strong></span>
<span class="strong"><strong class="calibre2">        $this-&gt;cookies = new FilteredMap($_COOKIE);</strong></span>
    }

    // ...

<span class="strong"><strong class="calibre2">    public function getParams(): FilteredMap {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;params;</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>

<span class="strong"><strong class="calibre2">    public function getCookies(): FilteredMap {</strong></span>
<span class="strong"><strong class="calibre2">        return $this-&gt;cookies;</strong></span>
<span class="strong"><strong class="calibre2">    }</strong></span>
}</pre></div><p class="calibre8">With this new addition, a developer could get the POST parameter <code class="email">price</code> with the following line of code:</p><div class="informalexample"><pre class="programlisting">$price = $request-&gt;getParams()-&gt;getNumber('price');</pre></div><p class="calibre8">This is<a id="id490" class="calibre1"/> way safer than the usual call to the global array:</p><div class="informalexample"><pre class="programlisting">$price = $_POST['price'];</pre></div></div></div>

<div class="book" title="Working with requests">
<div class="book" title="Mapping routes to controllers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec91" class="calibre1"/>Mapping routes to controllers</h2></div></div></div><p class="calibre8">If you <a id="id491" class="calibre1"/>can recall from any URL that you use daily, you will probably not see any PHP file as part of the path, like we have with <code class="email">http://localhost:8000/init.php</code>. Websites try to format their URLs to make them easier to remember instead of depending on the file that should handle that request. Also, as we've already mentioned, all our requests go through the same file, <code class="email">index.php</code>, regardless of their path. Because of this, we need to keep a map of the URL paths, and who should handle them.</p><p class="calibre8">Sometimes, we have URLs that contain parameters as part of their path, which is different from when they contain the GET or POST parameters. For example, to get the page that shows a specific book, we might include the ID of the book as part of the URL, such as <code class="email">/book/12</code> or <code class="email">/book/3</code>. The ID will change for each different book, but the same controller should handle all of these requests. To achieve this, we say that the URL contains an argument, and we could represent it by <code class="email">/book/:id</code>, where <code class="email">id</code> is the argument that identifies the ID of the book. Optionally, we could specify the kind of value this argument can take, for example, number, string, and so on.</p><p class="calibre8">Controllers, the ones in charge of processing requests, are defined by a method's class. This method takes as arguments all the arguments that the URL's path defines, such as the ID of the book. We group controllers by their functionality, that is, a <code class="email">BookController</code> class will contain the methods related to requests about books.</p><p class="calibre8">Having defined all the elements of a route—a URL-controller relationship—we are ready to create our <code class="email">routes.json</code> file, a configuration file that will keep this map. Each entry of this file should contain a route, the key being the URL, and the value, a map of information about the controller. Let's see an example:</p><div class="informalexample"><pre class="programlisting">{
  "books/:page": {
    "controller": "Book",
    "method": "getAllWithPage",
    "params": {
      "page": "number"
    }
  }
}</pre></div><p class="calibre8">The route in the preceding example refers to all the URLs that follow the pattern <code class="email">/books/:page</code>, with <code class="email">page</code> being any number. Thus, this route will match URLs such as <code class="email">/books/23</code> or <code class="email">/books/2</code>, but it should not match <code class="email">/books/one</code> or <code class="email">/books</code>. The controller that will handle this request should be the <code class="email">getAllWithPage</code> method from <code class="email">BookController</code>; we will append <code class="email">Controller</code> to all the class names. Given the parameters that we defined, the definition of the method should be something like the following:</p><div class="informalexample"><pre class="programlisting">public function getAllWithPage(int $page): string {
    //...
}</pre></div><p class="calibre8">There is <a id="id492" class="calibre1"/>one last thing we should consider when defining a route. For some endpoints, we should enforce the user to be authenticated, such as when the user is trying to access their own sales. We could define this rule in several ways, but we chose to do it as part of the route, adding the entry <code class="email">"login": true</code> as part of the controller's information. With that in mind, let's add the rest of the routes that define all the views that we expect to have:</p><div class="informalexample"><pre class="programlisting">{
//...
  "books": {
    "controller": "Book",
    "method": "getAll"
  },
  "book/:id": {
    "controller": "Book",
    "method": "get",
    "params": {
      "id": "number"
    }
  },
  "books/search": {
    "controller": "Book",
    "method": "search"
  }, 
  "login": {
    "controller": "Customer",
    "method": "login"
  },
  "sales": {
    "controller": "Sales",
    "method": "getByUser" ,
    "login": true
  },
  "sales/:id": {
    "controller": "Sales",
    "method": "get",
    "login": true,
    "params": {
      "id": "number"
    }
  },
  "my-books": {
    "controller": "Book",
    "method": "getByUser",
    "login": true
  }
}</pre></div><p class="calibre8">These <a id="id493" class="calibre1"/>routes define all the pages we need; we can get all the books in a paginated way or specific books by their ID, we can search books, list the sales of the user, show a specific sale by its ID, and list all the books that a certain user has borrowed. However, we are still lacking some of the endpoints that our application should be able to handle. For all those actions that are trying to modify data rather than requesting it, that is, borrowing a book or buying it, we need to add endpoints too. Add the following to your <code class="email">routes.json</code> file:</p><div class="informalexample"><pre class="programlisting">{
  // ...
  "book/:id/buy": {
    "controller": "Sales",
    "method": "add",
    "login": true
    "params": {
      "id": "number"
    }
  },
  "book/:id/borrow": {
    "controller": "Book",
    "method": "borrow",
    "login": true
    "params": {
      "id": "number"
    }
  },
  "book/:id/return": {
    "controller": "Book",
    "method": "returnBook",
    "login": true
    "params": {
      "id": "number"
    }
  }
}</pre></div></div></div>

<div class="book" title="Working with requests">
<div class="book" title="The router"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch06lvl2sec92" class="calibre1"/>The router</h2></div></div></div><p class="calibre8">The router will <a id="id494" class="calibre1"/>be by far the most complicated piece of code in our application. The<a id="id495" class="calibre1"/> main goal is to receive a <code class="email">Request</code> object, decide which controller should handle it, invoke it with the necessary parameters, and return the response from that controller. The main goal of this section is to understand the importance of the router rather than its detailed implementation, but we will try to describe each of its parts. Copy the following content as your <code class="email">src/Core/Router.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Core;

use Bookstore\Controllers\ErrorController;
use Bookstore\Controllers\CustomerController;

class Router {
    private $routeMap;
    private static $regexPatters = [
        'number' =&gt; '\d+',
        'string' =&gt; '\w'
    ];

    public function __construct() {
        $json = file_get_contents(
            __DIR__ . '/../../config/routes.json'
        );
        $this-&gt;routeMap = json_decode($json, true);
    }

    public function route(Request $request): string {
        $path = $request-&gt;getPath();

        foreach ($this-&gt;routeMap as $route =&gt; $info) {
            $regexRoute = $this-&gt;getRegexRoute($route, $info);
            if (preg_match("@^/$regexRoute$@", $path)) {
                return $this-&gt;executeController(
                    $route, $path, $info, $request
                );
            }
        }

        $errorController = new ErrorController($request);
        return $errorController-&gt;notFound();
    }
}</pre></div><p class="calibre8">The <a id="id496" class="calibre1"/>constructor of this class reads from the <code class="email">routes.json</code> file, and stores the<a id="id497" class="calibre1"/> content as an array. Its main method, <code class="email">route</code>, takes a <code class="email">Request</code> object and returns a string, which is what we will send as output to the client. This method iterates all the routes from the array, trying to match each with the path of the given request. Once it finds one, it tries to execute the controller related to that route. If none of the routes are a good match to the request, the router will execute the <code class="email">notFound</code> method of the <code class="email">ErrorController</code>, which will then return an error page.</p><div class="book" title="URLs matching with regular expressions"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec14" class="calibre1"/>URLs matching with regular expressions</h3></div></div></div><p class="calibre8">While<a id="id498" class="calibre1"/> matching a URL with the route, we need to take care of the arguments for dynamic URLs, as they do not let us perform a simple string comparison. PHP—and other languages—has a very strong tool for performing string comparisons with dynamic content: regular expressions. Being an expert in regular expressions takes time, and it is outside the scope of this book, but we will give you a brief introduction to them.</p><p class="calibre8">A regular expression is a string that contains some wildcard characters that will match the dynamic content. Some of the most important ones are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">^</code>: This is used to specify that the matching part should be the start of the whole string</li><li class="listitem"><code class="email">$</code>: This is used to specify that the matching part should be the end of the whole string</li><li class="listitem"><code class="email">\d</code>: This is used to match a digit</li><li class="listitem"><code class="email">\w</code>: This is used to match a word</li><li class="listitem"><code class="email">+</code>: This is used for following a character or expression, to let that character or expression to appear at least once or many times</li><li class="listitem"><code class="email">*</code>: This is used for following a character or expression, to let that character or expression to appear zero or many times</li><li class="listitem"><code class="email">.</code>: This is used to match any single character</li></ul></div><p class="calibre8">Let's see some examples:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The pattern <code class="email">.*</code> will match anything, even an empty string</li><li class="listitem">The pattern <code class="email">.+</code> will match anything that contains at least one character</li><li class="listitem">The pattern <code class="email">^\d+$</code> will match any number that has at least one digit</li></ul></div><p class="calibre8">In PHP, we <a id="id499" class="calibre1"/>have different functions to work with regular expressions. The easiest of them, and the one that we will use, is <code class="email">pregmatch</code>. This function takes a pattern as its first argument (delimited by two characters, usually <code class="email">@</code> or <code class="email">/</code>), the string that we are trying to match as the second argument, and optionally, an array where PHP stores the occurrences found. The function returns a Boolean value, being <code class="email">true</code> if there was a match, <code class="email">false</code> otherwise. We use it as follows in our <code class="email">Route</code> class:</p><div class="informalexample"><pre class="programlisting">preg_match("@^/$regexRoute$@", $path)</pre></div><p class="calibre8">The <code class="email">$path</code> variable contains the path of the request, for example, <code class="email">/books/2</code>. We match using a pattern that is delimited by <code class="email">@</code>, has the <code class="email">^</code> and <code class="email">$</code> wildcards to force the pattern to match the whole string, and contains the concatenation of <code class="email">/</code> and the variable <code class="email">$regexRoute</code>. The content of this variable is given by the following method; add this as well to your <code class="email">Router</code> class:</p><div class="informalexample"><pre class="programlisting">private function getRegexRoute(
    string $route,
    array $info
): string {
    if (isset($info['params'])) {
        foreach ($info['params'] as $name =&gt; $type) {
            $route = str_replace(
                ':' . $name, self::$regexPatters[$type], $route
            );
        }
    }

    return $route;
}</pre></div><p class="calibre8">The preceding method iterates the parameters list coming from the information of the route. For each parameter, the function replaces the name of the parameter inside the route by the <a id="id500" class="calibre1"/>wildcard character corresponding to the type of parameter—check the static array, <code class="email">$regexPatterns</code>. To illustrate the usage of this function, let's see some examples:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The route <code class="email">/books</code> will be returned without a change, as it does not contain any argument</li><li class="listitem">The route <code class="email">books/:id/borrow</code> will be changed to <code class="email">books/\d+/borrow</code>, as the URL argument, <code class="email">id</code>, is a number</li></ul></div></div><div class="book" title="Extracting the arguments of the URL"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec15" class="calibre1"/>Extracting the arguments of the URL</h3></div></div></div><p class="calibre8">In<a id="id501" class="calibre1"/> order to execute the controller, we need three pieces of data: the name of the class to instantiate, the name of the method to execute, and the arguments that the method needs to receive. We already have the first two as part of the route <code class="email">$info</code> array, so let's focus our efforts on finding the third one. Add the following method to the <code class="email">Router</code> class:</p><div class="informalexample"><pre class="programlisting">private function extractParams(
    string $route,
    string $path
): array {
    $params = [];

    $pathParts = explode('/', $path);
    $routeParts = explode('/', $route);

    foreach ($routeParts as $key =&gt; $routePart) {
        if (strpos($routePart, ':') === 0) {
            $name = substr($routePart, 1);
            $params[$name] = $pathParts[$key+1];
        }
    }

    return $params;
}</pre></div><p class="calibre8">This last method expects that both the path of the request and the URL of the route follow the same pattern. With the <code class="email">explode</code> method, we get two arrays that should match each of their entries. We iterate them, and for each entry in the route array that looks like a parameter, we fetch its value in the URL. For example, if we had the route <code class="email">/books/:id/borrow</code> and the path <code class="email">/books/12/borrow</code>, the result of this method would be the array <span class="strong"><em class="calibre12">['id' =&gt; 12]</em></span>.</p></div><div class="book" title="Executing the controller"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec16" class="calibre1"/>Executing the controller</h3></div></div></div><p class="calibre8">We end<a id="id502" class="calibre1"/> this section by implementing the method that executes the controller in charge of a given route. We already have the name of the class, the method, and the arguments that the method needs, so we could make use of the <code class="email">call_user_func_array</code> native function that, given an object, a method name, and the arguments for the method, invokes the method of the object passing the arguments. We have to make use of it as the number of arguments is not fixed, and we cannot perform a normal invocation.</p><p class="calibre8">But we are still missing a behavior introduced when creating our <code class="email">routes.json</code> file. There are some routes that force the user to be logged in, which, in our case, means that the user has a cookie with the user ID. Given a route that enforces authorization, we will check whether our request contains the cookie, in which case we will set it to the controller class through <code class="email">setCustomerId</code>. If the user does not have a cookie, instead of executing the controller for the current route, we will execute the <code class="email">showLogin</code> method of the <code class="email">CustomerController</code> class, which will render the template for the login form. Let's see how everything would look on adding the last method of our <code class="email">Router</code> class:</p><div class="informalexample"><pre class="programlisting">private function executeController(
    string $route,
    string $path,
    array $info,
    Request $request
): string {
    $controllerName = '\Bookstore\Controllers\\'
        . $info['controller'] . 'Controller';
    $controller = new $controllerName($request);

    if (isset($info['login']) &amp;&amp; $info['login']) {
        if ($request-&gt;getCookies()-&gt;has('user')) {
            $customerId = $request-&gt;getCookies()-&gt;get('user');
            $controller-&gt;setCustomerId($customerId);
        } else {
            $errorController = new CustomerController($request);
            return $errorController-&gt;login();
        }
    }

    $params = $this-&gt;extractParams($route, $path);
    return call_user_func_array(
        [$controller, $info['method']], $params
    );
}</pre></div><p class="calibre8">We have already warned you about the lack of security in our application, as this is just a project with <a id="id503" class="calibre1"/>didactic purposes. So, avoid copying the authorization system implemented here.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="M for model"><div class="book" id="1O8H62-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec53" class="calibre1"/>M for model</h1></div></div></div><p class="calibre8">Imagine<a id="id504" class="calibre1"/> for a moment that our bookstore website is quite successful, so we think of building a mobile app to increase our market. Of course, we would want to use the same database that we use for our website, as we need to sync the books that people borrow or buy from both apps. We do not want to be in a position where two people buy the same last copy of a book!</p><p class="calibre8">Not only the database, but the queries used to get books, update them, and so on, have to be the same too, otherwise we would end up with unexpected behavior. Of course, one apparently easy option would be to replicate the queries in both codebases, but that has a huge maintainability problem. What if we change one single field of our database? We need to apply the same change to at least two different codebases. That does not seem to be useful at all.</p><p class="calibre8">Business logic plays an important role here too. Think of it as decisions you need to take that affect your business. In our case, that a premium customer is able to borrow 10 books and a normal one only 3, is business logic. This logic should be put in a common place too, because, if we want to change it, we will have the same problems as with our database queries.</p><p class="calibre8">We hope that by now we've convinced you that data and business logic should be separated from the rest of the code in order to make it reusable. Do not worry if it is hard for you to define what should go as part of the model or as part of the controller; a lot of people struggle with this distinction. As our application is very simple, and it does not have a lot of business logic, we will just focus on adding all the code related to MySQL queries.</p><p class="calibre8">As you can imagine, for an application integrated with MySQL, or any other database system, the database connection is an important element of a model. We chose to use PDO in order to interact with MySQL, and as you might remember, instantiating that class was a bit of a pain. Let's create a singleton class that returns an instance of <code class="email">PDO</code> to make things easier. Add this code to <code class="email">src/Core/Db.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Core;

use PDO;

class Db {
    private static $instance;

    private static function connect(): PDO {
        $dbConfig = Config::getInstance()-&gt;get('db');
        return new PDO(
            'mysql:host=127.0.0.1;dbname=bookstore',
            $dbConfig['user'],
            $dbConfig['password']
        );
    }

    public static function getInstance(){
        if (self::$instance == null) {
            self::$instance = self::connect();
        }
        return self::$instance;
    }
}</pre></div><p class="calibre8">This class, defined in<a id="id505" class="calibre1"/> the preceding code snippet, just implements the singleton pattern and wraps the creation of a <code class="email">PDO</code> instance. From now on, in order to get a database connection, we just need to write <code class="email">Db::getInstance()</code>.</p><p class="calibre8">Although it might not be true for all models, in our application, they will always have to access the database. We could create an abstract class where all models extend. This class could contain a <code class="email">$db</code> protected property that will be set on the constructor. With this, we avoid duplicating the same constructor and property definition across all our models. Copy the following class into <code class="email">src/Models/AbstractModel.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Models;

use PDO;

abstract class AbstractModel {
    private $db;

    public function __construct(PDO $db) {
        $this-&gt;db = $db;
    }
}</pre></div><p class="calibre8">Finally, to finish the setup of the models, we could create a new exception (as we did with the <code class="email">NotFoundException</code> class) that represents an error from the database. It will not contain any code, but we will be able to differentiate where an exception is coming from. We will save it in <code class="email">src/Exceptions/DbException.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Exceptions;

use Exception;

class DbException extends Exception {
}</pre></div><p class="calibre8">Now that we've set the ground, we can start writing our models. It is up to you to organize your models, but it is a good idea to mimic the domain objects structure. In this case, we would have three models: <code class="email">CustomerModel</code>, <code class="email">BookModel</code>, and <code class="email">SalesModel</code>. In the <a id="id506" class="calibre1"/>following sections, we will explain the contents of each of them.</p></div>

<div class="book" title="M for model">
<div class="book" title="The customer model"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec93" class="calibre1"/>The customer model</h2></div></div></div><p class="calibre8">Let's start <a id="id507" class="calibre1"/>with the easiest one. As our application is still very primitive, we will not allow the creation of new costumers, and work with the ones we inserted manually into the database instead. That means that the only thing we need to do with customers is to query them. Let's create a <code class="email">CustomerModel</code> class in <code class="email">src/Models/CustomerModel.php</code> with the following content:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Models;

use Bookstore\Domain\Customer;
use Bookstore\Domain\Customer\CustomerFactory;
use Bookstore\Exceptions\NotFoundException;

class CustomerModel extends AbstractModel {
    public function get(int $userId): Customer {
        $query = 'SELECT * FROM customer WHERE customer_id = :user';
        $sth = $this-&gt;db-&gt;prepare($query);
        $sth-&gt;execute(['user' =&gt; $userId]);

        $row = $sth-&gt;fetch();

        if (empty($row)) {
            throw new NotFoundException();
        }

        return CustomerFactory::factory(
            $row['type'],
            $row['id'],
            $row['firstname'],
            $row['surname'],
            $row['email']
        );
    }

    public function getByEmail(string $email): Customer {
        $query = 'SELECT * FROM customer WHERE email = :user';
        $sth = $this-&gt;db-&gt;prepare($query);
        $sth-&gt;execute(['user' =&gt; $email]);

        $row = $sth-&gt;fetch();

        if (empty($row)) {
            throw new NotFoundException();
        }

        return CustomerFactory::factory(
            $row['type'],
            $row['id'],
            $row['firstname'],
            $row['surname'],
            $row['email']
        );
    }
}</pre></div><p class="calibre8">The <code class="email">CustomerModel</code> class, which extends from the <code class="email">AbstractModel</code> class, contains two methods; both<a id="id508" class="calibre1"/> of them return a <code class="email">Customer</code> instance, one of them when providing the ID of the customer, and the other one when providing the e-mail. As we already have the database connection as the <code class="email">$db</code> property, we just need to prepare the statement with the given query, execute the statement with the arguments, and fetch the result. As we expect to get a customer, if the user provided an ID or an e-mail that does not belong to any customer, we will need to throw an exception—in this case, a <code class="email">NotFoundException</code> is just fine. If we find a customer, we use our factory to create the object and return it.</p></div><div class="book" title="The book model"><div class="book"><div class="book"><div class="book"><div class="calibre11" id="calibre_pb_2"/>
</div></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="M for model">
<div class="book" title="The book model">
<div class="book">
<div class="book">
<div class="book">
<h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec94" class="calibre1"/>The book model</h2></div></div></div><p class="calibre8">Our <code class="email">BookModel</code> class <a id="id509" class="calibre1"/>gives us a bit more of work. Customers had a factory, but it is not worth having one for books. What we use for creating them from MySQL rows is not the constructor, but a fetch mode that PDO has, and that allows us to map a row into an object. To do so, we need to adapt the <code class="email">Book</code> domain object a bit:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The names of the properties have to be the same as the names of the fields in the database</li><li class="listitem">There is no need for a constructor or setters, unless we need them for other purposes</li><li class="listitem">To go with encapsulation, properties should be private, so we will need getters for all of them</li></ul></div><p class="calibre8">The new <code class="email">Book</code> class should look like the following:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Domain;

class Book {
    private $id;
    private $isbn;
    private $title;
    private $author;
    private $stock;
    private $price;

    public function getId(): int {
        return $this-&gt;id;
    }

    public function getIsbn(): string {
        return $this-&gt;isbn;
    }

    public function getTitle(): string {
        return $this-&gt;title;
    }

    public function getAuthor(): string {
        return $this-&gt;author;
    }

    public function getStock(): int {
        return $this-&gt;stock;
    }

    public function getCopy(): bool {
        if ($this-&gt;stock &lt; 1) {
            return false;
        } else {
            $this-&gt;stock--;
            return true;
        }
    }

    public function addCopy() {
        $this-&gt;stock++;
    }

    public function getPrice(): float {
        return $this-&gt;price;
    }
}</pre></div><p class="calibre8">We retained the <code class="email">getCopy</code> and <code class="email">addCopy</code> methods even though they are not getters, as we will need <a id="id510" class="calibre1"/>them later. Now, when fetching a group of rows from MySQL with the <code class="email">fetchAll</code> method, we can send two parameters: the constant <code class="email">PDO::FETCH_CLASS</code> that tells PDO to map rows to a class, and the name of the class that we want to map to. Let's create the <code class="email">BookModel</code> class with a simple <code class="email">get</code> method that fetches a book from the database with a given ID. This method will return either a <code class="email">Book</code> object or throw an exception in case the ID does not exist. Save it as <code class="email">src/Models/BookModel.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Models;

use Bookstore\Domain\Book;
use Bookstore\Exceptions\DbException;
use Bookstore\Exceptions\NotFoundException;
use PDO;

class BookModel extends AbstractModel {
    const CLASSNAME = '\Bookstore\Domain\Book';

    public function get(int $bookId): Book {
        $query = 'SELECT * FROM book WHERE id = :id';
        $sth = $this-&gt;db-&gt;prepare($query);
        $sth-&gt;execute(['id' =&gt; $bookId]);

<span class="strong"><strong class="calibre2">        $books = $sth-&gt;fetchAll(</strong></span>
<span class="strong"><strong class="calibre2">            PDO::FETCH_CLASS, self::CLASSNAME</strong></span>
<span class="strong"><strong class="calibre2">        );</strong></span>
        if (empty($books)) {
            throw new NotFoundException();
        }

        return $books[0];
    }
}</pre></div><p class="calibre8">There<a id="id511" class="calibre1"/> are advantages and disadvantages of using this fetch mode. On one hand, we avoid a lot of dull code when creating objects from rows. Usually, we either just send all the elements of the row array to the constructor of the class, or <a id="id512" class="calibre1"/>use setters for all its properties. If we add more fields to the MySQL table, we just need to add the properties to our domain class, instead of changing everywhere where we were instantiating the objects. On the other hand, you <a id="id513" class="calibre1"/>are forced to use the same names for the fields in both the table's as well as the class' properties, which means high coupling (always a bad idea). This also causes some conflicts when following conventions, because in MySQL, it is common to use <code class="email">book_id</code>, but in PHP, the property is <code class="email">$bookId</code>.</p><p class="calibre8">Now that we know how this fetch mode works, let's add three other methods that fetch data from MySQL. Add the following code to your model:</p><div class="informalexample"><pre class="programlisting">public function getAll(int $page, int $pageLength): array {
    $start = $pageLength * ($page - 1);

    $query = 'SELECT * FROM book LIMIT :page, :length';
    $sth = $this-&gt;db-&gt;prepare($query);
    $sth-&gt;bindParam('page', $start, PDO::PARAM_INT);
    $sth-&gt;bindParam('length', $pageLength, PDO::PARAM_INT);
    $sth-&gt;execute();

    return $sth-&gt;fetchAll(PDO::FETCH_CLASS, self::CLASSNAME);
}

public function getByUser(int $userId): array {
    $query = &lt;&lt;&lt;SQL
SELECT b.*
FROM borrowed_books bb LEFT JOIN book b ON bb.book_id = b.id
WHERE bb.customer_id = :id
SQL;
    $sth = $this-&gt;db-&gt;prepare($query);
    $sth-&gt;execute(['id' =&gt; $userId]);

    return $sth-&gt;fetchAll(PDO::FETCH_CLASS, self::CLASSNAME);
}

public function search(string $title, string $author): array {
    $query = &lt;&lt;&lt;SQL
SELECT * FROM book
WHERE title LIKE :title AND author LIKE :author
SQL;
    $sth = $this-&gt;db-&gt;prepare($query);
    $sth-&gt;bindValue('title', "%$title%");
    $sth-&gt;bindValue('author', "%$author%");
    $sth-&gt;execute();

    return $sth-&gt;fetchAll(PDO::FETCH_CLASS, self::CLASSNAME);
}</pre></div><p class="calibre8">The methods added are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">getAll</code> returns an array of all the books for a given page. Remember that <code class="email">LIMIT</code> allows<a id="id514" class="calibre1"/> you to return a specific number of rows with an offset, which can work as a paginator.</li><li class="listitem"><code class="email">getByUser</code> returns all the books that a given customer has borrowed—we will need to use a join query for this. Note that we return <code class="email">b.*</code>, that is, only the fields of the <code class="email">book</code> table, skipping the rest of the fields.</li><li class="listitem">Finally, there is a method to search by either title or author, or both. We can do that using the operator <code class="email">LIKE</code> and enclosing the patterns with <code class="email">%</code>. If we do not specify one of the parameters, we will try to match the field with <code class="email">%%</code>, which matches everything.</li></ul></div><p class="calibre8">So far, we have been adding methods to fetch data. Let's add methods that will allow us to modify the data in our database. For the book model, we will need to be able to borrow books and return them. Here is the code for those two actions:</p><div class="informalexample"><pre class="programlisting">public function borrow(Book $book, int $userId) {
    $query = &lt;&lt;&lt;SQL
INSERT INTO borrowed_books (book_id, customer_id, start)
VALUES(:book, :user, NOW())
SQL;
    $sth = $this-&gt;db-&gt;prepare($query);
    $sth-&gt;bindValue('book', $book-&gt;getId());
    $sth-&gt;bindValue('user', $userId);
    if (!$sth-&gt;execute()) {
        throw new DbException($sth-&gt;errorInfo()[2]);
    }

    $this-&gt;updateBookStock($book);
}

public function returnBook(Book $book, int $userId) {
    $query = &lt;&lt;&lt;SQL
UPDATE borrowed_books SET end = NOW()
WHERE book_id = :book AND customer_id = :user AND end IS NULL 
SQL;
    $sth = $this-&gt;db-&gt;prepare($query);
    $sth-&gt;bindValue('book', $book-&gt;getId());
    $sth-&gt;bindValue('user', $userId);
    if (!$sth-&gt;execute()) {
        throw new DbException($sth-&gt;errorInfo()[2]);
    }

    $this-&gt;updateBookStock($book);
}

private function updateBookStock(Book $book) {
    $query = 'UPDATE book SET stock = :stock WHERE id = :id';
    $sth = $this-&gt;db-&gt;prepare($query);
    $sth-&gt;bindValue('id', $book-&gt;getId());
    $sth-&gt;bindValue('stock', $book-&gt;getStock());
    if (!$sth-&gt;execute()) {
        throw new DbException($sth-&gt;errorInfo()[2]);
    }
}</pre></div><p class="calibre8">When <a id="id515" class="calibre1"/>borrowing a book, you are adding a row to the <code class="email">borrower_books</code> table. When returning books, you do not want to remove that row, but rather to set the end date in order to keep a history of the books that a user has been borrowing. Both methods need to change the stock of the borrowed book: when borrowing it, reducing the stock by one, and when returning it, increasing the stock. That is why, in the last code snippet, we created a private method to update the stock of a given book, which will be used from both the <code class="email">borrow</code> and <code class="email">returnBook</code> methods.</p></div></div>

<div class="book" title="M for model">
<div class="book" title="The sales model"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch06lvl2sec95" class="calibre1"/>The sales model</h2></div></div></div><p class="calibre8">Now we<a id="id516" class="calibre1"/> need to add the last model to our application: the <code class="email">SalesModel</code>. Using the same fetch mode that we used with books, we need to adapt the domain class as well. We need to think a bit more in this case, as we will be doing more than just fetching. Our application has to be able to create new sales on demand, containing the ID of the customer and the books. We can already add books with the current implementation, but we need to add a setter for the customer ID. The ID of the sale will be given by the autoincrement ID in MySQL, so there is no need to add a setter for it. The <a id="id517" class="calibre1"/>final implementation would look as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Domain;

class Sale {
    private $id;
    private $customer_id;
    private $books;
    private $date;

    public function setCustomerId(int $customerId) {
        $this-&gt;customer_id = $customerId;
    }

    public function getId(): int {
        return $this-&gt;id;
    }

    public function getCustomerId(): int {
        return $this-&gt;customer_id;
    }

    public function getBooks(): array {
        return $this-&gt;books;
    }

    public function getDate(): string {
        return $this-&gt;date;
    }

    public function addBook(int $bookId, int $amount = 1) {
        if (!isset($this-&gt;books[$bookId])) {
            $this-&gt;books[$bookId] = 0;
        }
        $this-&gt;books[$bookId] += $amount;
    }

    public function setBooks(array $books) {
        $this-&gt;books = $books;
    }
}</pre></div><p class="calibre8">The <code class="email">SalesModel</code> will be the most difficult one to write. The problem with this model is that it includes <a id="id518" class="calibre1"/>manipulating different tables: <code class="email">sale</code> and <code class="email">sale_book</code>. For example, when getting the information of a sale, we need to get the information from the <code class="email">sale</code> table, and then the information of all the books in the <code class="email">sale_book</code> table. You could argue about whether to have one unique method that fetches all the necessary information related to a sale, or to have two different methods, one to fetch the sale and the other to fetch the books, and let the controller to decide which one to use.</p><p class="calibre8">This actually starts a very interesting discussion. On one hand, we want to make things easier for the controller—having one unique method to fetch the entire <code class="email">Sale</code> object. This makes sense as the controller does not need to know about the internal implementation of the <code class="email">Sale</code> object, which lowers coupling. On the other hand, forcing the model to always fetch the whole object, even if we only need the information in the <code class="email">sale</code> table, is a bad idea. Imagine if the sale contains a lot of books; fetching them from MySQL will decrease performance unnecessarily.</p><p class="calibre8">You should think how your controllers need to manage sales. If you will always need the entire object, you can have one method without being concerned about performance. If you only need to fetch the entire object sometimes, maybe you could add both methods. For our application, we will have one method to rule them all, since that is what we will always need.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note16" class="calibre1"/>Note</h3><p class="calibre8">
<span class="strong"><strong class="calibre2">Lazy loading</strong></span>
</p><p class="calibre8">As with any other design challenge, other developers have already given a lot of thought to<a id="id519" class="calibre1"/> this problem. They came up with a design pattern named <span class="strong"><strong class="calibre2">lazy load</strong></span>. This pattern basically lets the controller think that there is only one method to fetch the whole domain object, but we will actually be fetching only what we need from database.</p><p class="calibre8">The model fetches the most used information for the object and leaves the rest of the properties that need extra database queries empty. Once the controller uses a getter of a property that is empty, the model automatically fetches that data from the database. We get the best of both worlds: there is simplicity for the controller, but we do not spend more time than necessary querying unused data.</p></div><p class="calibre8">Add the following as your <code class="email">src/Models/SaleModel.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php
namespace Bookstore\Models;

use Bookstore\Domain\Sale;
use Bookstore\Exceptions\DbException;
use PDO;

class SaleModel extends AbstractModel {
    const CLASSNAME = '\Bookstore\Domain\Sale';

    public function getByUser(int $userId): array {
        $query = 'SELECT * FROM sale WHERE s.customer_id = :user';
        $sth = $this-&gt;db-&gt;prepare($query);
        $sth-&gt;execute(['user' =&gt; $userId]);

        return $sth-&gt;fetchAll(PDO::FETCH_CLASS, self::CLASSNAME);
    }

    public function get(int $saleId): Sale {
        $query = 'SELECT * FROM sale WHERE id = :id';
        $sth = $this-&gt;db-&gt;prepare($query);
        $sth-&gt;execute(['id' =&gt; $saleId]);
        $sales = $sth-&gt;fetchAll(PDO::FETCH_CLASS, self::CLASSNAME);

        if (empty($sales)) {
            throw new NotFoundException('Sale not found.');
        }
        $sale = array_pop($sales);

        $query = &lt;&lt;&lt;SQL
SELECT b.id, b.title, b.author, b.price, sb.amount as stock, b.isbn
FROM sale s
LEFT JOIN sale_book sb ON s.id = sb.sale_id
LEFT JOIN book b ON sb.book_id = b.id
WHERE s.id = :id
SQL;
        $sth = $this-&gt;db-&gt;prepare($query);
        $sth-&gt;execute(['id' =&gt; $saleId]);
        $books = $sth-&gt;fetchAll(
            PDO::FETCH_CLASS, BookModel::CLASSNAME
        );

        $sale-&gt;setBooks($books);
        return $sale;
    }
}</pre></div><p class="calibre8">Another<a id="id520" class="calibre1"/> tricky method in this model is the one that takes care of creating a sale in the database. This method has to create a sale in the <code class="email">sale</code> table, and then add all the books for that sale to the <code class="email">sale_book</code> table. What would happen if we have a problem when adding one of the books? We would leave a corrupted sale in the database. To avoid that, we need to use transactions, starting with one at the beginning of the model's or the controller's method, and either rolling back in case of error, or committing it at the end of the method.</p><p class="calibre8">In the<a id="id521" class="calibre1"/> same method, we also need to take care of the ID of the sale. We do not set the ID of the sale when creating the <code class="email">sale</code> object, because we rely on the autoincremental field in the database. But when inserting the books into <code class="email">sale_book</code>, we do need the ID of the sale. For that, we need to request the PDO for the last inserted ID with the <code class="email">lastInsertId</code> method. Let's add then the <code class="email">create</code> method into your <code class="email">SaleModel</code>:</p><div class="informalexample"><pre class="programlisting">public function create(Sale $sale) {
<span class="strong"><strong class="calibre2">    $this-&gt;db-&gt;beginTransaction();</strong></span>

    $query = &lt;&lt;&lt;SQL
INSERT INTO sale(customer_id, date)
VALUES(:id, NOW())
SQL;
    $sth = $this-&gt;db-&gt;prepare($query);
    if (!$sth-&gt;execute(['id' =&gt; $sale-&gt;getCustomerId()])) {
<span class="strong"><strong class="calibre2">        $this-&gt;db-&gt;rollBack();</strong></span>
        throw new DbException($sth-&gt;errorInfo()[2]);
    }

<span class="strong"><strong class="calibre2">    $saleId = $this-&gt;db-&gt;lastInsertId();</strong></span>
    $query = &lt;&lt;&lt;SQL
INSERT INTO sale_book(sale_id, book_id, amount)
VALUES(:sale, :book, :amount)
SQL;
    $sth = $this-&gt;db-&gt;prepare($query);
    $sth-&gt;bindValue('sale', $saleId);
    foreach ($sale-&gt;getBooks() as $bookId =&gt; $amount) {
        $sth-&gt;bindValue('book', $bookId);
        $sth-&gt;bindValue('amount', $amount);
        if (!$sth-&gt;execute()) {
<span class="strong"><strong class="calibre2">            $this-&gt;db-&gt;rollBack();</strong></span>
            throw new DbException($sth-&gt;errorInfo()[2]);
        }
    }

<span class="strong"><strong class="calibre2">    $this-&gt;db-&gt;commit();</strong></span>
}</pre></div><p class="calibre8">One last thing to note from this method is that we prepare a statement, bind a value to it (the sale ID), and then bind and execute the same statement as many times as the books in the array. Once you have a statement, you can bind the values as many times as you want. Also, you can<a id="id522" class="calibre1"/> execute the same statement as many times as you want, and the values stay the same.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="V for view"><div class="book" id="1P71O2-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec54" class="calibre1"/>V for view</h1></div></div></div><p class="calibre8">The <a id="id523" class="calibre1"/>view is the layer that takes care of the… view. In this layer, you find all the templates that render the HTML that the user gets. Although the separation between views and the rest of the application is easy to see, that does not make views an easy part. In fact, you will have to learn a new technology in order to write views properly. Let's get into the details.</p></div>

<div class="book" title="V for view">
<div class="book" title="Introduction to Twig"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec96" class="calibre1"/>Introduction to Twig</h2></div></div></div><p class="calibre8">In our<a id="id524" class="calibre1"/> first attempt at writing views, we mixed up PHP and HTML code. We already know that the logic should not be mixed in the same place as HTML, but that is not the end of the story. When rendering HTML, we need some logic there too. For example, if we want to print a list of books, we need to repeat a certain block of HTML for each book. And since a priori we do not know the number of books to print, the best option would be a <code class="email">foreach</code> loop.</p><p class="calibre8">One option that a lot of people take is minimizing the amount of logic that you can include in a view. You could set some rules, such as <span class="strong"><em class="calibre12">we should only include conditionals and loops</em></span>, which is a reasonable amount of logic needed to render basic views. The problem is that there is not a way of enforcing this kind of rule, and other developers can easily start adding heavy logic in there. While some people are OK with that, assuming that no one will do it, others prefer to implement more restrictive systems. That was the beginning of template engines.</p><p class="calibre8">You could think of a template engine as another language that you need to learn. Why would you do that? Because this new "language" is more limited than PHP. These languages usually allow you to perform conditionals and simple loops, and that is it. The developer is not able to add PHP to that file, since the template engine will not treat it as PHP code. Instead, it will just print the code to the output—the response' body—as if it was plain text. Also, as it is specially oriented to write templates, the syntax is usually easier to read when mixed with HTML. Almost everything is an advantage.</p><p class="calibre8">The inconvenience of using a template engine is that it takes some time to translate the new language to PHP, and then to HTML. This can be quite time consuming, so it is very important that you choose a good template engine. Most of them also allow you to cache templates, improving the performance. Our choice is a quite light and widely used one: <span class="strong"><strong class="calibre2">Twig</strong></span>. As we've <a id="id525" class="calibre1"/>already added the dependency in our Composer file, we can use it straight away.</p><p class="calibre8">Setting up <a id="id526" class="calibre1"/>Twig is quite easy. On the PHP side, you just need to specify the location of the templates. A common convention is to use the <code class="email">views</code> directory for that. Create the directory, and add the following two lines into your <code class="email">index.php</code>:</p><div class="informalexample"><pre class="programlisting">$loader = new Twig_Loader_Filesystem(__DIR__ . '/views');
$twig = new Twig_Environment($loader);</pre></div></div><div class="book" title="The book view"><div class="book"><div class="book"><div class="book"><div class="calibre11" id="calibre_pb_2"/>
</div></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="V for view">
<div class="book" title="The book view">
<div class="book">
<div class="book">
<div class="book">
<h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec97" class="calibre1"/>The book view</h2></div></div></div><p class="calibre8">In these <a id="id527" class="calibre1"/>sections, as we work with templates, it would be nice to see the result of your work. We have not yet implemented any controllers, so we will force our <code class="email">index.php</code> to render a specific template, regardless of the request. We can start rendering the view of a single book. For that, let's add the following code at the end of your <code class="email">index.php</code>, after creating your <code class="email">twig</code> object:</p><div class="informalexample"><pre class="programlisting">$bookModel = new BookModel(Db::getInstance());
$book = $bookModel-&gt;get(1);

$params = ['book' =&gt; $book];
echo $twig-&gt;loadTemplate('book.twig')-&gt;render($params);</pre></div><p class="calibre8">In the preceding code, we request the book with ID 1 to the <code class="email">BookModel</code>, get the <code class="email">book</code> object, and create an array where the <code class="email">book</code> key has the value of the <code class="email">book</code> object. After that, we tell Twig to load the template <code class="email">book.twig</code> and to render it by sending the array. This takes the template and injects the <code class="email">$book</code> object, so that you are able to use it inside the template.</p><p class="calibre8">Let's now create our first template. Write the following code into <code class="email">view/book.twig</code>. By convention, all Twig templates should have the <code class="email">.twig</code> extension:</p><div class="informalexample"><pre class="programlisting">&lt;h2&gt;{{ book.title }}&lt;/h2&gt;
&lt;h3&gt;{{ book.author }}&lt;/h3&gt;

&lt;hr&gt;

&lt;p&gt;
    &lt;strong&gt;ISBN&lt;/strong&gt; {{ book.isbn }}
&lt;/p&gt;
&lt;p&gt;
    &lt;strong&gt;Stock&lt;/strong&gt; {{ book.stock }}
&lt;/p&gt;
&lt;p&gt;
    &lt;strong&gt;Price&lt;/strong&gt; {{ book.price|number_format(2) }} €
&lt;/p&gt;

&lt;hr&gt;

&lt;h3&gt;Actions&lt;/h3&gt;

&lt;form method="post" action="/book/{{ book.id }}/borrow"&gt;
    &lt;input type="submit" value="Borrow"&gt;
&lt;/form&gt;

&lt;form method="post" action="/book/{{ book.id }}/buy"&gt;
    &lt;input type="submit" value="Buy"&gt;
&lt;/form&gt;</pre></div><p class="calibre8">Since this is your first Twig template, let's go step by step. You can see that most of the content is HTML: some headers, a couple of paragraphs, and two forms with two buttons. You can recognize the Twig part, since it is enclosed by <code class="email">{{ }}</code>. In Twig, everything that is between those curly brackets will be printed out. The first one that we find contains <code class="email">book.title</code>. Do you remember that we injected the <code class="email">book</code> object when rendering the template? We can access it here, just not with the usual PHP syntax. To access an object's property, use <code class="email">.</code> instead of <code class="email">-&gt;</code>. So, this <code class="email">book.title</code> will return the value of the <code class="email">title</code> property of the <code class="email">book</code> object, and the <code class="email">{{ }}</code> will make Twig print it out. The same applies to the rest of the template.</p><p class="calibre8">There is <a id="id528" class="calibre1"/>one that does a bit more than just access an object's property. The <code class="email">book.price|number_format(2)</code> gets the price of the book and sends it as an argument (using the pipe symbol) to the function <code class="email">number_format</code>, which has already got <code class="email">2</code> as another argument. This bit of code basically formats the price to two digital figures. In Twig, you also have some functions, but they are mostly reduced to formatting the output, which is an acceptable amount of logic.</p><p class="calibre8">Are you convinced now about how clean it is to use a template engine for your views? You can try it in your browser: accessing any path, your web server should execute the <code class="email">index.php</code> file, forcing the template <code class="email">book.twig</code> to be rendered.</p></div></div>

<div class="book" title="V for view">
<div class="book" title="Layouts and blocks"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch06lvl2sec98" class="calibre1"/>Layouts and blocks</h2></div></div></div><p class="calibre8">When<a id="id529" class="calibre1"/> you design your web application, usually you would want to <a id="id530" class="calibre1"/>share a common layout across most of your views. In our case, we want to always have a menu at the top of the view that allows us to go to the different sections of the website, or even to search books from wherever the user is. As with models, we want to avoid code duplication, since if we were to copy and paste the layout everywhere, updating it would be a nightmare. Instead, Twig comes with the ability to define layouts.</p><p class="calibre8">A <span class="strong"><strong class="calibre2">layout</strong></span> in Twig is <a id="id531" class="calibre1"/>just another template file. Its content is just the common HTML code that we want to display across all views (in our case, the menu and search bar), and contains some tagged gaps (blocks in Twig's world), where you will be able to inject the specific HTML of each view. You can define one of those blocks with the tag <code class="email">{% block %}</code>. Let's see what our <code class="email">views/layout.twig</code> file would look like:</p><div class="informalexample"><pre class="programlisting">&lt;html&gt;
&lt;head&gt;
<span class="strong"><strong class="calibre2">    &lt;title&gt;{% block title %}{% endblock %}&lt;/title&gt;</strong></span>
&lt;/head&gt;
&lt;body&gt;
    &lt;div style="border: solid 1px"&gt;
        &lt;a href="/books"&gt;Books&lt;/a&gt;
        &lt;a href="/sales"&gt;My Sales&lt;/a&gt;
        &lt;a href="/my-books"&gt;My Books&lt;/a&gt;
        &lt;hr&gt;
        &lt;form action="/books/search" method="get"&gt;
            &lt;label&gt;Title&lt;/label&gt;
            &lt;input type="text" name="title"&gt;
            &lt;label&gt;Author&lt;/label&gt;
            &lt;input type="text" name="author"&gt;
            &lt;input type="submit" value="Search"&gt;
        &lt;/form&gt;
    &lt;/div&gt;
<span class="strong"><strong class="calibre2">    {% block content %}{% endblock %}</strong></span>
&lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre8">As you <a id="id532" class="calibre1"/>can see in the preceding code, blocks have a name so that templates<a id="id533" class="calibre1"/> using the layout can refer to them. In our layout, we defined two blocks: one for the title of the view and the other for the content itself. When a template uses the layout, we just need to write the HTML code for each of the blocks defined in the layout, and Twig will do the rest. Also, to let Twig know that our template wants to use the layout, we use the tag <code class="email">{% extends %}</code> with the layout filename. Let's update <code class="email">views/book.twig</code> to use our new layout:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">{% extends 'layout.twig' %}</strong></span>

<span class="strong"><strong class="calibre2">{% block title %}</strong></span>
<span class="strong"><strong class="calibre2">    {{ book.title }}</strong></span>
<span class="strong"><strong class="calibre2">{% endblock %}</strong></span>

<span class="strong"><strong class="calibre2">{% block content %}</strong></span>
&lt;h2&gt;{{ book.title }}&lt;/h2&gt;
//...
&lt;/form&gt;
<span class="strong"><strong class="calibre2">{% endblock %}</strong></span>
</pre></div><p class="calibre8">At the top of the file, we add the layout that we need to use. Then, we open a block tag with the reference name, and we write inside it the HTML that we want to use. You can use anything valid inside a block, either Twig code or plain HTML. In our template, we used the title<a id="id534" class="calibre1"/> of the book as the <code class="email">title</code> block, which refers to the title of the <a id="id535" class="calibre1"/>view, and we put all the previous HTML inside the <code class="email">content</code> block. Note that everything in the file is inside a block now. Try it in your browser now to see the changes.</p></div><div class="book" title="Paginated book list"><div class="book"><div class="book"><div class="book"><div class="calibre11" id="calibre_pb_5"/>
</div></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="V for view">
<div class="book" title="Paginated book list">
<div class="book">
<div class="book">
<div class="book">
<h2 class="title1" id="calibre_pb_6"><a id="ch06lvl2sec99" class="calibre1"/>Paginated book list</h2></div></div></div><p class="calibre8">Let's<a id="id536" class="calibre1"/> add another view, this time for a paginated list of books. In order to see the result of your work, update the content of <code class="email">index.php</code>, replacing the code of the previous section with the following:</p><div class="informalexample"><pre class="programlisting">$bookModel = new BookModel(Db::getInstance());
$books = $bookModel-&gt;getAll(1, 3);

$params = ['books' =&gt; $books, 'currentPage' =&gt; 2];
echo $twig-&gt;loadTemplate('books.twig')-&gt;render($params);</pre></div><p class="calibre8">In the preceding snippet, we force the application to render the <code class="email">books.twig</code> template, sending an array of books from page number 1, and showing 3 books per page. This array, though, might not always return 3 books, maybe because there are only 2 books in the database. We should then use a loop to iterate the list instead of assuming the size of the array. In Twig, you can emulate a <code class="email">foreach</code> loop using <code class="email">{% for &lt;element&gt; in &lt;array&gt; %}</code> in order to iterate an array. Let's use it for your <code class="email">views/books.twig</code>:</p><div class="informalexample"><pre class="programlisting">{% extends 'layout.twig' %}

{% block title %}
    Books
{% endblock %}

{% block content %}
&lt;table&gt;
    &lt;thead&gt;
        &lt;th&gt;Title&lt;/th&gt;
        &lt;th&gt;Author&lt;/th&gt;
        &lt;th&gt;&lt;/th&gt;
    &lt;/thead&gt;
<span class="strong"><strong class="calibre2">{% for book in books %}</strong></span>
    &lt;tr&gt;
        &lt;td&gt;{{ book.title }}&lt;/td&gt;
        &lt;td&gt;{{ book.author }}&lt;/td&gt;
        &lt;td&gt;&lt;a href="/book/{{ book.id }}"&gt;View&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
<span class="strong"><strong class="calibre2">{% endfor %}</strong></span>
&lt;/table&gt;
{% endblock %}</pre></div><p class="calibre8">We can also use conditionals in a Twig template, which work the same as the conditionals in PHP. The syntax is <code class="email">{% if &lt;boolean expression&gt; %}</code>. Let's use it to decide if we should show the previous and/or following links on our page. Add the following code at the end of the content block:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">{% if currentPage != 1 %}</strong></span>
    &lt;a href="/books/{{ currentPage - 1 }}"&gt;Previous&lt;/a&gt;
<span class="strong"><strong class="calibre2">{% endif %}</strong></span>
{% if not lastPage %}
    &lt;a href="/books/{{ currentPage + 1 }}"&gt;Next&lt;/a&gt;
{% endif %}</pre></div><p class="calibre8">The last thing to note from this template is that we are not restricted to using only variables when printing out content with <code class="email">{{ }}</code>. We can add any valid Twig expression that returns a <a id="id537" class="calibre1"/>value, as we did with <code class="email">{{ currentPage + 1 }}</code>.</p></div></div>

<div class="book" title="V for view">
<div class="book" title="The sales view"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch06lvl2sec100" class="calibre1"/>The sales view</h2></div></div></div><p class="calibre8">We have<a id="id538" class="calibre1"/> already shown you everything that you will need for using templates, and now we just have to finish adding all of them. The next one in the list is the template that shows the list of sales for a given user. Update your <code class="email">index.php</code> file with the following hack:</p><div class="informalexample"><pre class="programlisting">$saleModel = new SaleModel(Db::getInstance());
$sales = $saleModel-&gt;getByUser(1);

$params = ['sales' =&gt; $sales];
echo $twig-&gt;loadTemplate('sales.twig')-&gt;render($params);</pre></div><p class="calibre8">The template for this view will be very similar to the one listing the books: a table populated with the content of an array. The following is the content of <code class="email">views/sales.twig</code>:</p><div class="informalexample"><pre class="programlisting">{% extends 'layout.twig' %}

{% block title %}
    My sales
{% endblock %}

{% block content %}
&lt;table&gt;
    &lt;thead&gt;
        &lt;th&gt;Id&lt;/th&gt;
        &lt;th&gt;Date&lt;/th&gt;
    &lt;/thead&gt;
{% for sale in sales %}
    &lt;tr&gt;
        &lt;td&gt;{{ sale.id}}&lt;/td&gt;
        &lt;td&gt;{{ sale.date }}&lt;/td&gt;
        &lt;td&gt;&lt;a href="/sales/{{ sale.id }}"&gt;View&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
{% endfor %}
&lt;/table&gt;
{% endblock %}</pre></div><p class="calibre8">The other view related to sales is where we want to display all the content of a specific one. This sale, again, will be similar to the books list, as we will be listing the books related to that sale. The hack to force the rendering of this template is as follows:</p><div class="informalexample"><pre class="programlisting">$saleModel = new SaleModel(Db::getInstance());
$sale = $saleModel-&gt;get(1);

$params = ['sale' =&gt; $sale];
echo $twig-&gt;loadTemplate('sale.twig')-&gt;render($params);</pre></div><p class="calibre8">And <a id="id539" class="calibre1"/>the Twig template should be placed in <code class="email">views/sale.twig</code>:</p><div class="informalexample"><pre class="programlisting">{% extends 'layout.twig' %}

{% block title %}
    Sale {{ sale.id }}
{% endblock %}

{% block content %}
&lt;table&gt;
    &lt;thead&gt;
        &lt;th&gt;Title&lt;/th&gt;
        &lt;th&gt;Author&lt;/th&gt;
        &lt;th&gt;Amount&lt;/th&gt;
        &lt;th&gt;Price&lt;/th&gt;
        &lt;th&gt;&lt;/th&gt;
    &lt;/thead&gt;
    {% for book in sale.books %}
        &lt;tr&gt;
            &lt;td&gt;{{ book.title }}&lt;/td&gt;
            &lt;td&gt;{{ book.author }}&lt;/td&gt;
            &lt;td&gt;{{ book.stock }}&lt;/td&gt;
            &lt;td&gt;{{ (book.price * book.stock)|number_format(2) }} €&lt;/td&gt;
            &lt;td&gt;&lt;a href="/book/{{ book.id }}"&gt;View&lt;/a&gt;&lt;/td&gt;
        &lt;/tr&gt;
    {% endfor %}
&lt;/table&gt;
{% endblock %}</pre></div></div></div>

<div class="book" title="V for view">
<div class="book" title="The error template"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_8"><a id="ch06lvl2sec101" class="calibre1"/>The error template</h2></div></div></div><p class="calibre8">We <a id="id540" class="calibre1"/>should add a very simple template that will be shown to the user when there is an error in our application, rather than showing a PHP error message. This template will just expect the <code class="email">errorMessage</code> variable, and it could look like the following. Save it as <code class="email">views/error.twig</code>:</p><div class="informalexample"><pre class="programlisting">{% extends 'layout.twig' %}

{% block title %}
    Error
{% endblock %}

{% block content %}
    &lt;h2&gt;Error: {{ errorMessage }}&lt;/h2&gt;
{% endblock %}</pre></div><p class="calibre8">Note that even the error page extends from the layout, as we want the user to be able to do something else when this happens.</p></div></div>

<div class="book" title="V for view">
<div class="book" title="The login template"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_9"><a id="ch06lvl2sec102" class="calibre1"/>The login template</h2></div></div></div><p class="calibre8">Our last <a id="id541" class="calibre1"/>template will be the one that allows the user to log in. This template is a bit different from the others, as it will be used in two different scenarios. In the first one, the user accesses the login view for the first time, so we need to show the form. In the second one, the user has already tried to log in, and there was an error when doing so, that is, the e-mail address was not found. In this case, we will add an extra variable to the template, <code class="email">errorMessage</code>, and we will add a conditional to show its contents only when this variable is defined. You can use the operator <code class="email">is defined</code> to check that. Add the following template as <code class="email">views/login.twig</code>:</p><div class="informalexample"><pre class="programlisting">{% extends 'layout.twig' %}

{% block title %}
    Login
{% endblock %}

{% block content %}
<span class="strong"><strong class="calibre2">    {% if errorMessage is defined %}</strong></span>
        &lt;strong&gt;{{ errorMessage }}&lt;/strong&gt;
    {% endif %}
    &lt;form action="/login" method="post"&gt;
        &lt;label&gt;Email&lt;/label&gt;
        &lt;input type="text" name="email"&gt;
        &lt;input type="submit"&gt;
    &lt;/form&gt;
{% endblock %}</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="C for controller"><div class="book" id="1Q5IA2-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec55" class="calibre1"/>C for controller</h1></div></div></div><p class="calibre8">It is finally <a id="id542" class="calibre1"/>time for the director of the orchestra. Controllers represent the layer in our application that, given a request, talks to the models and builds the views. They act like the manager of a team: they decide what resources to use depending on the situation.</p><p class="calibre8">As we stated when explaining models, it is sometimes difficult to decide if some piece of logic should go into the controller or the model. At the end of the day, MVC is a pattern, like a recipe that guides you, rather than an exact algorithm that you need to follow step by step. There will be scenarios where the answer is not straightforward, so it will be up to you; in these cases, just try to be consistent. The following are some common scenarios that might be difficult to localize:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The request points to a path that we do not support. This scenario is already covered in our application, and it is the router that should take care of it, not the controller.</li><li class="listitem">The request tries to access an element that does not exist, for example, a book ID that is not in the database. In this case, the controller should ask the model if the book exists, and depending on the response, render a template with the book's contents, or another with a "Not found" message.</li><li class="listitem">The user tries to perform an action, such as buying a book, but the parameters coming from the request are not valid. This is a tricky one. One option is to get all the parameters from the request without checking them, sending them straight to the model, and leaving the task of sanitizing the information to the model. Another option is that the controller checks that the parameters provided make sense, and then gives them to the model. There are other solutions, like building a class that checks if the parameters are valid, which can be reused in different controllers. In this case, it will depend on the amount of parameters and logic involved in the sanitization. For requests receiving a lot of data, the third option looks like the best of them, as we will be able to reuse the code in different endpoints, and we are not writing controllers that are too long. But in requests where the user sends one or two parameters, sanitizing them in the controller might be good enough.</li></ul></div><p class="calibre8">Now that we've set the ground, let's prepare our application to use controllers. The first thing to do is to update our <code class="email">index.php</code>, which has been forcing the application to always render the same template. Instead, we should be giving this task to the router, which will return the response as a string that we can just print with <code class="email">echo</code>. Update your <code class="email">index.php</code> file with the following content:</p><div class="informalexample"><pre class="programlisting">&lt;?php

use Bookstore\Core\Router;
use Bookstore\Core\Request;

require_once __DIR__ . '/vendor/autoload.php';

<span class="strong"><strong class="calibre2">$router = new Router();</strong></span>
<span class="strong"><strong class="calibre2">$response = $router-&gt;route(new Request());</strong></span>
<span class="strong"><strong class="calibre2">echo $response;</strong></span>
</pre></div><p class="calibre8">As you<a id="id543" class="calibre1"/> might remember, the router instantiates a controller class, sending the request object to the constructor. But controllers have other dependencies as well, such as the template engine, the database connection, or the configuration reader. Even though this is not the best solution (you will improve it once we cover dependency injection in the next section), we could create an <code class="email">AbstractController</code> that would be the parent of all controllers, and will set those dependencies. Copy the following as <code class="email">src/Controllers/AbstractController.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Controllers;

use Bookstore\Core\Config;
use Bookstore\Core\Db;
use Bookstore\Core\Request;
use Monolog\Logger;
use Twig_Environment;
use Twig_Loader_Filesystem;
use Monolog\Handler\StreamHandler;

abstract class AbstractController {
    protected $request;
    protected $db;
    protected $config;
    protected $view;
    protected $log;

    public function __construct(Request $request) {
        $this-&gt;request = $request;
        $this-&gt;db = Db::getInstance();
        $this-&gt;config = Config::getInstance();

        $loader = new Twig_Loader_Filesystem(
            __DIR__ . '/../../views'
        );
        $this-&gt;view = new Twig_Environment($loader);

        $this-&gt;log = new Logger('bookstore');
        $logFile = $this-&gt;config-&gt;get('log');
        $this-&gt;log-&gt;pushHandler(
            new StreamHandler($logFile, Logger::DEBUG)
        );
    }

    public function setCustomerId(int $customerId) {
        $this-&gt;customerId = $customerId;
    }
}</pre></div><p class="calibre8">When<a id="id544" class="calibre1"/> instantiating a controller, we will set some properties that will be useful when handling requests. We already know how to instantiate the database connection, the configuration reader, and the template engine. The fourth property, <code class="email">$log</code>, will allow the developer to write logs to a given file when necessary. We will use the Monolog library for that, but there are many other options. Notice that in order to instantiate the logger, we get the value of log from the configuration, which should be the path to the log file. The convention is to use the <code class="email">/var/log/</code> directory, so create the <code class="email">/var/log/bookstore.log</code> file, and add <code class="email">"log": "/var/log/bookstore.log"</code> to your configuration file.</p><p class="calibre8">Another thing that is useful to some controllers—but not all of them—is the information about the user performing the action. As this is only going to be available for certain routes, we should not set it when constructing the controller. Instead, we have a setter for the router to set the customer ID when available; in fact, the router does that already.</p><p class="calibre8">Finally, a handy helper method that we could use is one that renders a given template with parameters, as all the controllers will end up rendering one template or the other. Let's add the following protected method to the <code class="email">AbstractController</code> class:</p><div class="informalexample"><pre class="programlisting">protected function render(string $template, array $params): string {
    return $this-&gt;view-&gt;loadTemplate($template)-&gt;render($params);
}</pre></div></div>

<div class="book" title="C for controller">
<div class="book" title="The error controller"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec103" class="calibre1"/>The error controller</h2></div></div></div><p class="calibre8">Let's <a id="id545" class="calibre1"/>start by creating the easiest of the controllers: the <code class="email">ErrorController</code>. This controller does not do much; it just renders the <code class="email">error.twig</code> template sending the "Page not found!" message. As you might remember, the router uses this controller when it cannot match the request to any of the other defined routes. Save the following class in <code class="email">src/Controllers/ErrorController.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Controllers;

class ErrorController extends AbstractController {
    public function notFound(): string {
        $properties = ['errorMessage' =&gt; 'Page not found!'];
        return $this-&gt;render('error.twig', $properties);
    }
}</pre></div></div></div>

<div class="book" title="C for controller">
<div class="book" title="The login controller"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec104" class="calibre1"/>The login controller</h2></div></div></div><p class="calibre8">The second<a id="id546" class="calibre1"/> controller that we have to add is the one that manages the login of the customers. If we think about the flow when a user wants to authenticate, we have the following scenarios:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The user wants to get the login form in order to submit the necessary information and log in.</li><li class="listitem">The user tries to submit the form, but we could not get the e-mail address. We should render the form again, letting them know about the problem.</li><li class="listitem">The user submits the form with an e-mail, but it is not a valid one. In this case, we should show the login form again with an error message explaining the situation.</li><li class="listitem">The user submits a valid e-mail, we set the cookie, and we show the list of books so the user can start searching. This is absolutely arbitrary; you could choose to send them to their borrowed books page, their sales, and so on. The important thing here is to notice that we will be redirecting the request to another controller.</li></ul></div><p class="calibre8">There are up to four possible paths. We will use the <code class="email">request</code> object to decide which of them to use in each case, returning the corresponding response. Let's create, then, the <code class="email">CustomerController</code> class in <code class="email">src/Controllers/CustomerController.php</code> with the <code class="email">login</code> method, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Controllers;

use Bookstore\Exceptions\NotFoundException;
use Bookstore\Models\CustomerModel;

class CustomerController extends AbstractController {
    public function login(string $email): string {
        if (!$this-&gt;request-&gt;isPost()) {
<span class="strong"><strong class="calibre2">            return $this-&gt;render('login.twig', []);</strong></span>
        }

        $params = $this-&gt;request-&gt;getParams();

        if (!$params-&gt;has('email')) {
            $params = ['errorMessage' =&gt; 'No info provided.'];
<span class="strong"><strong class="calibre2">            return $this-&gt;render('login.twig', $params);</strong></span>
        }

        $email = $params-&gt;getString('email');
        $customerModel = new CustomerModel($this-&gt;db);

        try {
            $customer = $customerModel-&gt;getByEmail($email);
        } catch (NotFoundException $e) {
            $this-&gt;log-&gt;warn('Customer email not found: ' . $email);
            $params = ['errorMessage' =&gt; 'Email not found.'];
<span class="strong"><strong class="calibre2">            return $this-&gt;render('login.twig', $params);</strong></span>
        }

        setcookie('user', $customer-&gt;getId());

        $newController = new BookController($this-&gt;request);
<span class="strong"><strong class="calibre2">        return $newController-&gt;getAll();</strong></span>
    }
}</pre></div><p class="calibre8">As you <a id="id547" class="calibre1"/>can see, there are four different returns for the four different cases. The controller itself does not do anything, but orchestrates the rest of the components, and makes decisions. First, we check if the request is a POST, and if it is not, we will assume that the user wants to get the form. If it is, we will check for the e-mail in the parameters, returning an error if the e-mail is not there. If it is, we will try to find the customer with that e-mail, using our model. If we get an exception saying that there is no such customer, we will render the form with a "Not found" error message. If the login is successful, we will set the cookie with the ID of the customer, and will execute the <code class="email">getAll</code> method of <code class="email">BookController</code> (still to be written), returning the list of books.</p><p class="calibre8">At this point, you should be able to test the login feature of your application end to end with the browser. Try to access <code class="email">http://localhost:8000/login</code> to see the form, adding <a id="id548" class="calibre1"/>random e-mails to get the error message, and adding a valid e-mail (check your <code class="email">customer</code> table in MySQL) to log in successfully. After this, you should see the cookie with the customer ID.</p></div><div class="book" title="The book controller"><div class="book"><div class="book"><div class="book"><div class="calibre11" id="calibre_pb_3"/>
</div></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="C for controller">
<div class="book" title="The book controller">
<div class="book">
<div class="book">
<div class="book">
<h2 class="title1" id="calibre_pb_4"><a id="ch06lvl2sec105" class="calibre1"/>The book controller</h2></div></div></div><p class="calibre8">The <code class="email">BookController</code> class will be the largest of our controllers, as most of the application <a id="id549" class="calibre1"/>relies on it. Let's start by adding the easiest methods, the ones that just retrieve information from the database. Save this as <code class="email">src/Controllers/BookController.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Controllers;

use Bookstore\Models\BookModel;

class BookController extends AbstractController {
    const PAGE_LENGTH = 10;

    public function getAllWithPage($page): string {
        $page = (int)$page;
        $bookModel = new BookModel($this-&gt;db);

        $books = $bookModel-&gt;getAll($page, self::PAGE_LENGTH);

        $properties = [
            'books' =&gt; $books,
            'currentPage' =&gt; $page,
            'lastPage' =&gt; count($books) &lt; self::PAGE_LENGTH
        ];
        return $this-&gt;render('books.twig', $properties);
    }

    public function getAll(): string {
        return $this-&gt;getAllWithPage(1);
    }

    public function get(int $bookId): string {
        $bookModel = new BookModel($this-&gt;db);

        try {
            $book = $bookModel-&gt;get($bookId);
        } catch (\Exception $e) {
            $this-&gt;log-&gt;error(
                'Error getting book: ' . $e-&gt;getMessage()
            );
            $properties = ['errorMessage' =&gt; 'Book not found!'];
            return $this-&gt;render('error.twig', $properties);
        }

        $properties = ['book' =&gt; $book];
        return $this-&gt;render('book.twig', $properties);
    }

    public function getByUser(): string {
        $bookModel = new BookModel($this-&gt;db);

        $books = $bookModel-&gt;getByUser($this-&gt;customerId);

        $properties = [
            'books' =&gt; $books,
            'currentPage' =&gt; 1,
            'lastPage' =&gt; true
        ];
        return $this-&gt;render('books.twig', $properties);
    }
}</pre></div><p class="calibre8">There's nothing <a id="id550" class="calibre1"/>too special in this preceding code so far. The <code class="email">getAllWithPage</code> and <code class="email">getAll</code> methods do the same thing, one with the page number given by the user as a URL argument, and the other setting the page number as 1—the default case. They ask the model for the list of books to be displayed and passed to the view. The information of the current page—and whether or not we are on the last page—is also sent to the template in order to add the "previous" and "next" page links.</p><p class="calibre8">The <code class="email">get</code> method will get the ID of the book that the customer is interested in. It will try to fetch it using the model. If the model throws an exception, we will render the error template with a "Book not found" message. Instead, if the book ID is valid, we will render the book template as expected.</p><p class="calibre8">The <code class="email">getByUser</code> method will return all the books that the authenticated customer has borrowed. We will make use of the <code class="email">customerId</code> property that we set from the router. There is no sanity check here, since we are not trying to get a specific book, but rather a list, which could be empty if the user has not borrowed any books yet—but that is not an issue.</p><p class="calibre8">Another getter controller is the one that searches for a book by its title and/or author. This method will be triggered when the user submits the form in the layout template. The form sends both the <code class="email">title</code> and the <code class="email">author</code> fields, so the controller will ask for both. The model is ready to use the arguments that are empty, so we will not perform any extra checking here. Add the method to the <code class="email">BookController</code> class:</p><div class="informalexample"><pre class="programlisting">public function search(): string {
    $title = $this-&gt;request-&gt;getParams()-&gt;getString('title');
    $author = $this-&gt;request-&gt;getParams()-&gt;getString('author');

    $bookModel = new BookModel($this-&gt;db);
    $books = $bookModel-&gt;search($title, $author);

    $properties = [
        'books' =&gt; $books,
        'currentPage' =&gt; 1,
        'lastPage' =&gt; true
    ];
    return $this-&gt;render('books.twig', $properties);
}</pre></div><p class="calibre8">Your<a id="id551" class="calibre1"/> application cannot perform any actions, but at least you can finally browse the list of books, and click on any of them to view the details. We are finally getting something here!</p></div></div>

<div class="book" title="C for controller">
<div class="book" title="Borrowing books"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch06lvl2sec106" class="calibre1"/>Borrowing books</h2></div></div></div><p class="calibre8">Borrowing<a id="id552" class="calibre1"/> and returning books are probably the actions that involve the most logic, together with buying a book, which will be covered by a different controller. This is a good place to start logging the user's actions, since it will be useful later for debugging purposes. Let's see the code first, and then discuss it briefly. Add the following two methods to your <code class="email">BookController</code> class:</p><div class="informalexample"><pre class="programlisting">public function borrow(int $bookId): string {
    $bookModel = new BookModel($this-&gt;db);

    try {
        $book = $bookModel-&gt;get($bookId);
    } catch (NotFoundException $e) {
<span class="strong"><strong class="calibre2">        $this-&gt;log-&gt;warn('Book not found: ' . $bookId);</strong></span>
        $params = ['errorMessage' =&gt; 'Book not found.'];
        return $this-&gt;render('error.twig', $params);
    }

    if (!$book-&gt;getCopy()) {
        $params = [
            'errorMessage' =&gt; 'There are no copies left.'
       ];
        return $this-&gt;render('error.twig', $params);
    }

    try {
        $bookModel-&gt;borrow($book, $this-&gt;customerId);
    } catch (DbException $e) {
<span class="strong"><strong class="calibre2">        $this-&gt;log-&gt;error(</strong></span>
<span class="strong"><strong class="calibre2">            'Error borrowing book: ' . $e-&gt;getMessage()</strong></span>
        );
        $params = ['errorMessage' =&gt; 'Error borrowing book.'];
        return $this-&gt;render('error.twig', $params);
    }

    return $this-&gt;getByUser();
}

public function returnBook(int $bookId): string {
    $bookModel = new BookModel($this-&gt;db);

    try {
        $book = $bookModel-&gt;get($bookId);
    } catch (NotFoundException $e) {
<span class="strong"><strong class="calibre2">        $this-&gt;log-&gt;warn('Book not found: ' . $bookId);</strong></span>
        $params = ['errorMessage' =&gt; 'Book not found.'];
        return $this-&gt;render('error.twig', $params);
    }

    $book-&gt;addCopy();

    try {
        $bookModel-&gt;returnBook($book, $this-&gt;customerId);
    } catch (DbException $e) {
<span class="strong"><strong class="calibre2">        $this-&gt;log-&gt;error(</strong></span>
<span class="strong"><strong class="calibre2">            'Error returning book: ' . $e-&gt;getMessage()</strong></span>
        );
        $params = ['errorMessage' =&gt; 'Error returning book.'];
        return $this-&gt;render('error.twig', $params);
    }

    return $this-&gt;getByUser();
}</pre></div><p class="calibre8">As we<a id="id553" class="calibre1"/> mentioned earlier, one of the new things here is that we are logging user actions, like when trying to borrow or return a book that is not valid. Monolog allows you to write logs with different priority levels: error, warning, and notices. You can invoke methods such as <code class="email">error</code>, <code class="email">warn</code>, or <code class="email">notice</code> to refer to each of them. We use warnings when something unexpected, yet not critical, happens, for example, trying to borrow a book that is not there. Errors are used when there is an unknown problem from which we cannot recover, like an error from the database.</p><p class="calibre8">The modus operandi of these two methods is as follows: we get the <code class="email">book</code> object from the 3database with the given book ID. As usual, if there is no such book, we return an error page. Once we have the <code class="email">book</code> domain object, we make use of the helpers <code class="email">addCopy</code> and <code class="email">getCopy</code> in order to update the stock of the book, and send it to the model, together with the customer ID, to store the information in the database. There is also a sanity check when borrowing a book, just in case there are no more books available. In both cases, we return the list of books that the user has borrowed as the response of the controller.</p></div></div>

<div class="book" title="C for controller">
<div class="book" title="The sales controller"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch06lvl2sec107" class="calibre1"/>The sales controller</h2></div></div></div><p class="calibre8">We <a id="id554" class="calibre1"/>arrive at the last of our controllers: the <code class="email">SalesController</code>. With a different model, it will end up doing pretty much the same as the methods related to borrowed books. But we need to create the <code class="email">sale</code> domain object in the controller instead of getting it from the model. Let's add the following code, which contains a method for buying a book, <code class="email">add</code>, and two getters: one that gets all the sales of a given user and one that gets the info of a specific sale, that is, <code class="email">getByUser</code> and <code class="email">get</code> respectively. Following the convention, the file will be <code class="email">src/Controllers/SalesController.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Controllers;

use Bookstore\Domain\Sale;
use Bookstore\Models\SaleModel;

class SalesController extends AbstractController {
    public function add($id): string {
        $bookId = (int)$id;
        $salesModel = new SaleModel($this-&gt;db);

        $sale = new Sale();
        $sale-&gt;setCustomerId($this-&gt;customerId);
        $sale-&gt;addBook($bookId);

        try {
            $salesModel-&gt;create($sale);
        } catch (\Exception $e) {
            $properties = [
                'errorMessage' =&gt; 'Error buying the book.'
           ];
            $this-&gt;log-&gt;error(
                'Error buying book: ' . $e-&gt;getMessage()
            );
            return $this-&gt;render('error.twig', $properties);
        }

        return $this-&gt;getByUser();
    }

    public function getByUser(): string {
        $salesModel = new SaleModel($this-&gt;db);

        $sales = $salesModel-&gt;getByUser($this-&gt;customerId);

        $properties = ['sales' =&gt; $sales];
        return $this-&gt;render('sales.twig', $properties);
    }

    public function get($saleId): string {
        $salesModel = new SaleModel($this-&gt;db);

        $sale = $salesModel-&gt;get($saleId);

        $properties = ['sale' =&gt; $sale];
        return $this-&gt;render('sale.twig', $properties);
    }
}</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Dependency injection"><div class="book" id="1R42S2-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec56" class="calibre1"/>Dependency injection</h1></div></div></div><p class="calibre8">At the <a id="id555" class="calibre1"/>end of the chapter, we will cover one of the most interesting and controversial of the topics that come with, not only the MVC pattern, but <a id="id556" class="calibre1"/>OOP in general: <span class="strong"><strong class="calibre2">dependency injection</strong></span>. We will show you why it is so important, and how to implement a solution that suits our specific application, even though there are quite a few different implementations that can cover different necessities.</p></div>

<div class="book" title="Dependency injection">
<div class="book" title="Why is dependency injection necessary?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec108" class="calibre1"/>Why is dependency injection necessary?</h2></div></div></div><p class="calibre8">We still<a id="id557" class="calibre1"/> need to cover the way to unit test your code, hence you have not experienced it by yourself yet. But one of the signs of a potential source of problems is when you use the <code class="email">new</code> statement in your code to create an instance of a class that does not belong to your code base—also known as a dependency. Using <code class="email">new</code> to create a domain object like <code class="email">Book</code> or <code class="email">Sale</code> is fine. Using it to instantiate models is also acceptable. But manually instantiating, which something else, such as the template engine, the database connection, or the logger, is something that you should avoid. There are different reasons that support this idea:</p><div class="book"><ul class="itemizedlist"><li class="listitem">If you want to use a controller from two different places, and each of these places needs a different database connection or log file, instantiating those dependencies inside the controller will not allow us to do that. The same controller will always use the same dependency.</li><li class="listitem">Instantiating the dependencies inside the controller means that the controller is fully aware of the concrete implementation of each of its dependencies, that is, the controller knows that we are using PDO with the MySQL driver and the location of the credentials for the connection. This means a high level of coupling in your application—so, bad news.</li><li class="listitem">Replacing one dependency with another that implements the same interface is not easy if you are instantiating the dependency explicitly everywhere, as you will have to search all these places, and change the instantiation manually.</li></ul></div><p class="calibre8">For all these reasons, and more, it is always good to provide the dependencies that a class such as a controller needs instead of letting it create its own. This is something that everybody agrees with. The problem comes when implementing a solution. There are different options:</p><div class="book"><ul class="itemizedlist"><li class="listitem">We have a constructor that expects (through arguments) all the dependencies that the controller, or any other class, needs. The constructor will assign each of the arguments to the properties of the class.</li><li class="listitem">We have an empty constructor, and instead, we add as many setter methods as the dependencies of the class.</li><li class="listitem">A hybrid of both, where we set the main dependencies through a constructor, and set the rest of the dependencies via setters.</li><li class="listitem">Sending an object that contains all the dependencies as a unique argument for the constructor, and the controller gets the dependencies that it needs from that container.</li></ul></div><p class="calibre8">Each solution has its pros and cons. If we have a class with a lot of dependencies, injecting all of them via the constructor would make it counterintuitive, so it would be better if we inject them using setters, even though a class with a lot of dependencies looks like bad design. If we have just one or two dependencies, using the constructor could be acceptable, and we will write less code. For classes with several dependencies, but not all of them mandatory, using the hybrid version could be a good solution. The fourth option makes it<a id="id558" class="calibre1"/> easier when injecting the dependencies as we do not need to know what each object expects. The problem is that each class should know how to fetch its dependency, that is, the dependency name, which is not ideal.</p></div></div>

<div class="book" title="Dependency injection">
<div class="book" title="Implementing our own dependency injector"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec109" class="calibre1"/>Implementing our own dependency injector</h2></div></div></div><p class="calibre8">Open<a id="id559" class="calibre1"/> source solutions for dependency injectors are already available, but we think that it would be a good experience to implement a simple one by yourself. The idea of our dependency injector is a class that contains instances of the dependencies that your code needs. This class, which is basically a map of dependency names to dependency instances, will have two methods: a getter and a setter of dependencies. We do not want to use a static property for the dependencies array, as one of the goals is to be able to have more than one dependency injector with a different set of dependencies. Add the following class to <code class="email">src/Utils/DependencyInjector.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Utils;

use Bookstore\Exceptions\NotFoundException;

class DependencyInjector {
    private $dependencies = [];

    public function set(string $name, $object) {
        $this-&gt;dependencies[$name] = $object;
    }

    public function get(string $name) {
        if (isset($this-&gt;dependencies[$name])) {
            return $this-&gt;dependencies[$name];
        }
        throw new NotFoundException(
            $name . ' dependency not found.'
        );
    }
}</pre></div><p class="calibre8">Having a dependency injector means that we will always use the same instance of a given class every time we ask for it, instead of creating one each time. That means that singleton implementations are not needed anymore; in fact, as mentioned in <a class="calibre1" title="Chapter 4. Creating Clean Code with OOP" href="part0033_split_000.html#VF2I2-edcc22b134104d5db0bf3aa086c86851">Chapter 4</a>, <span class="strong"><em class="calibre12">Creating Clean Code with OOP</em></span>, it is preferable to avoid them. Let's get rid of them, then. One of the places where we were using it was in our configuration reader. Replace the existing code with the following in the <code class="email">src/Core/Config.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Bookstore\Core;

use Bookstore\Exceptions\NotFoundException;

class Config {
    private $data;

    public function __construct() {
        $json = file_get_contents(
            __DIR__ . '/../../config/app.json'
        );
        $this-&gt;data = json_decode($json, true);
    }

    public function get($key) {
        if (!isset($this-&gt;data[$key])) {
            throw new NotFoundException("Key $key not in config.");
        }
        return $this-&gt;data[$key];
    }
}</pre></div><p class="calibre8">The other <a id="id560" class="calibre1"/>place where we were making use of the singleton pattern was in the <code class="email">DB</code> class. In fact, the purpose of the class was only to have a singleton for our database connection, but if we are not making use of it, we can remove the entire class. So, delete your <code class="email">src/Core/DB.php</code> file.</p><p class="calibre8">Now we need to define all these dependencies and add them to our dependency injector. The <code class="email">index.php</code> file is a good place to have the dependency injector before we route the request. Add the following code just before instantiating the <code class="email">Router</code> class:</p><div class="informalexample"><pre class="programlisting">$config = new Config();

$dbConfig = $config-&gt;get('db');
$db = new PDO(
    'mysql:host=127.0.0.1;dbname=bookstore',
    $dbConfig['user'],
    $dbConfig['password']
);

$loader = new Twig_Loader_Filesystem(__DIR__ . '/../../views');
$view = new Twig_Environment($loader);

$log = new Logger('bookstore');
$logFile = $config-&gt;get('log');
$log-&gt;pushHandler(new StreamHandler($logFile, Logger::DEBUG));

$di = new DependencyInjector();
$di-&gt;set('PDO', $db);
$di-&gt;set('Utils\Config', $config);
$di-&gt;set('Twig_Environment', $view);
$di-&gt;set('Logger', $log);

$router = new Router($di);
//...</pre></div><p class="calibre8">There are<a id="id561" class="calibre1"/> a few changes that we need to make now. The most important of them refers to the <code class="email">AbstractController</code>, the class that will make heavy use of the dependency injector. Add a property named <code class="email">$di</code> to that class, and replace the constructor with the following:</p><div class="informalexample"><pre class="programlisting">public function __construct(
    DependencyInjector $di,
    Request $request
) {
    $this-&gt;request = $request;
    $this-&gt;di = $di;

    $this-&gt;db = $di-&gt;get('PDO');
    $this-&gt;log = $di-&gt;get('Logger');
    $this-&gt;view = $di-&gt;get('Twig_Environment');
    $this-&gt;config = $di-&gt;get('Utils\Config');

    $this-&gt;customerId = $_COOKIE['id'];
}</pre></div><p class="calibre8">The other changes refer to the <code class="email">Router</code> class, as we are sending it now as part of the constructor, and we need to inject it to the controllers that we create. Add a <code class="email">$di</code> property to that class as well, and change the constructor to the following one:</p><div class="informalexample"><pre class="programlisting">public function __construct(DependencyInjector $di) {
    $this-&gt;di = $di;

    $json = file_get_contents(__DIR__ . '/../../config/routes.json');
    $this-&gt;routeMap = json_decode($json, true);
}</pre></div><p class="calibre8">Also <a id="id562" class="calibre1"/>change the content of the <code class="email">executeController</code> and <code class="email">route</code> methods:</p><div class="informalexample"><pre class="programlisting">public function route(Request $request): string {
    $path = $request-&gt;getPath();

    foreach ($this-&gt;routeMap as $route =&gt; $info) {
        $regexRoute = $this-&gt;getRegexRoute($route, $info);
        if (preg_match("@^/$regexRoute$@", $path)) {
            return $this-&gt;executeController(
                $route, $path, $info, $request
            );
        }
    }

<span class="strong"><strong class="calibre2">    $errorController = new ErrorController(</strong></span>
<span class="strong"><strong class="calibre2">        $this-&gt;di,</strong></span>
<span class="strong"><strong class="calibre2">        $request</strong></span>
<span class="strong"><strong class="calibre2">    );</strong></span>
    return $errorController-&gt;notFound();
}

private function executeController(
    string $route,
    string $path,
    array $info,
    Request $request
): string {
    $controllerName = '\Bookstore\Controllers\\' 
        . $info['controller'] . 'Controller';
<span class="strong"><strong class="calibre2">    $controller = new $controllerName($this-&gt;di, $request);</strong></span>

    if (isset($info['login']) &amp;&amp; $info['login']) {
        if ($request-&gt;getCookies()-&gt;has('user')) {
            $customerId = $request-&gt;getCookies()-&gt;get('user');
            $controller-&gt;setCustomerId($customerId);
        } else {
<span class="strong"><strong class="calibre2">            $errorController = new CustomerController(</strong></span>
<span class="strong"><strong class="calibre2">                $this-&gt;di,</strong></span>
<span class="strong"><strong class="calibre2">                $request</strong></span>
<span class="strong"><strong class="calibre2">            );</strong></span>
            return $errorController-&gt;login();
        }
    }

    $params = $this-&gt;extractParams($route, $path);
    return call_user_func_array(
        [$controller, $info['method']], $params
    );
}</pre></div><p class="calibre8">There is one last place that you need to change. The <code class="email">login</code> method of <code class="email">CustomerController</code> was instantiating a controller too, so we need to inject the dependency <a id="id563" class="calibre1"/>injector there as well:</p><div class="informalexample"><pre class="programlisting">$newController = new BookController($this-&gt;di, $this-&gt;request);</pre></div></div></div>
<div class="book" title="Summary" id="1S2JE1-edcc22b134104d5db0bf3aa086c86851"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec57" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, you learned what MVC is, and how to write an application that follows that pattern. You also know how to use a router to route requests to controllers, Twig to write templates, and Composer to manage your dependencies and autoloader. You were introduced to dependency injection, and you even built your own implementation, even though it is a very controversial topic with many different points of view.</p><p class="calibre8">In the next chapter, we will go through one of the most important parts needed when writing good code and good applications: unit testing your code to get quick feedback from it.</p></div></body></html>