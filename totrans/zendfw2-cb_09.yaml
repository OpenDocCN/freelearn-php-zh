- en: Chapter 9. Catching Bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling Exceptions—your partner in crime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging and how it makes your life easier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing – why would you do it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up and using unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On 9 September, 1947 the first computer bug was found by Grace Hopper. This
    computer bug was an actual insect instead of a software bug. Since then we are
    basically chasing bugs in our software applications, and the more we learn to
    code the more we begin to appreciate good error handling, and catching bugs in
    time.
  prefs: []
  type: TYPE_NORMAL
- en: As a coder nothing is more annoying than getting customers on the phone that
    say "it doesn't work", without us knowing what actually is going on. That is why
    this chapter is focused on catching bugs early, and finding the cause of the bug
    more easily.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Exceptions – your partner in crime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To find the source of errors, good error handling should be implemented. In
    this recipe we'll talk about Exception handling within the Zend Framework 2 and
    how to optimally use it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can safely assume that we all know about try-catch and Exceptions, but to
    make sure nobody is caught out please take a look at the link to the PHP manual
    in the *See also* subsection in this section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exception handling is not that difficult to use, but it is a very useful tool
    if used correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Exception classes in Zend Framework 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This implementation of `try-catch` is also called cascading Exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Exceptions on dispatch or rendering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To implement the trigger on one of these events we should add some code to the
    `/module/Application/Module.php` file in one of our Modules (it doesn't specifically
    matter which one).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have seen how to do it, let's see how it actually works in Zend Framework
    2.
  prefs: []
  type: TYPE_NORMAL
- en: Exception classes in Zend Framework 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Zend Framework 2 throws a different Exception for almost every component of
    the framework, and although different in name they are all the same in functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all here is a list of Exceptions that are default to PHP but are overridden
    by Zend Framework 2 because Zend Framework 2 just likes to use Exceptions that
    are in the Zend namespace, instead of in the global namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BadMethodCallException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DomainException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExtensionNotLoadedException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InvalidArgumentException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InvalidCallbackException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LogicException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RuntimeException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Luckily we can use the global `\DomainException` as well as `\Zend\Stdlib\Exception\DomainException`
    (it is such a mouthful) when catching our Exceptions, as the Exceptions are overridden
    from the original.
  prefs: []
  type: TYPE_NORMAL
- en: It can however be useful if we are using a chain of catches to know where a
    specific Exception comes from; for example, when we catch a `RuntimeException`
    and we know that either `Zend\Cache` or `Zend\Authentication` can throw one. However
    usually it is quite clear what it might be or reactions to Exceptions might be
    different per instance.
  prefs: []
  type: TYPE_NORMAL
- en: Zend Framework 2, however, has docblocks for every class and method and luckily
    for us also has documented `@throws` as well. This means that we can easily look
    at the documentation and see what that specific functionality throws, that way
    we can easily wrap our code inside a `try-catch` block and handle the Exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: We can also just catch any `\Exception` that is thrown, instead of specifically
    targeting a named Exception, but we don't tend to do that as it doesn't give us
    good control over the errors occurring. In general we would like to be as specific
    as possible when it comes to Exceptions, and the rule is to catch them from most
    specific down to least specific.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions on dispatch or rendering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we don't handle exceptions on either dispatch or rendering, we are in for
    a bad time. One of the issues that can arise is the white screen issue where we
    won't see anything on the screen because of an error happening. During the development
    stage, this only leads to mild frustration for the developer, but think about
    the user that sees this on a live environment as they want to tell you their nephew/cousin/uncle
    is a better coder than us. We can't have that.
  prefs: []
  type: TYPE_NORMAL
- en: That is why we need to make sure that we listen to the `Zend\Mvc\MvcEvent::EVENT_DISPATCH_ERROR`
    and `Zend\Mvc\MvcEvent::EVENT_RENDER_ERROR` events. These events will be triggered
    when a controller or route is not found or an error occurrs during the rendering
    of the templates.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the example, this event is only triggered when an error occurs,
    when dispatching, or rendering. The exception retrieved can then be used to either
    log, or dump to the screen, whatever feels appropriate. The idea here is that
    we are able to debug effectively even if we don't see the error happening.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if this technique was implemented on the live application, it could
    log all the exceptions to a log (or e-mail to support) then we would be able to
    see errors that occur when we are "not around" to see it for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: About try-catch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `try-catch` block in PHP is one incredibly useful tool of the trade and
    we would need to use it as much as possible as chains of Exceptions are much easier
    to solve than a `return false` or `null` back from a method. Especially in combination
    of events we are able to catch anything in time, or at least make sure we are
    able to debug it in a reasonable fashion.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exceptions manual and the introduction to try-catch: [http://php.net/manual/en/language.exceptions.php](http://php.net/manual/en/language.exceptions.php)'
  prefs: []
  type: TYPE_NORMAL
- en: Logging and how it makes your life easier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides good error handling, logging is a good way to make sure you get the
    most knowledge of what is going on out of your system. Most of time we can even
    build it so that we can record events that lead up to an error, which can then
    be traced back to the original issue.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because we want to go all exotic with the logging in Zend Framework 2, it is
    required for us to install the FirePHP core on our web server. We can install
    this library through the Composer tool (we need to assume that we already use
    this on the server, otherwise it would get a bit too complicated).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install the FirePHP library by adding the following lines in the require
    section of the `composer.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we now execute `'php composer.phar update'` in the command line, it will
    install the library for use within our code later on. To make full use of the
    logger functionality, it would also be wise to use a browser that can understand
    FirePHP headers. With the Mozilla Firefox browser we need to install the Firebug
    and FirePHP add-ons to make it work. If we want to use FirePHP logging in Google's
    Chrome browser or Microsoft Internet Explorer, we need separate extensions/add-ons
    as well, as none of these support it by default.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we will show off examples on how to implement a logger system
    in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a really simple file logger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s implement a simple file logger first, which can be done in one of our
    configuration files. We will add our logger to our /`config/autoload/global.php`
    file as we want it available everywhere in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'That was pretty easy as we can see, and now everywhere we have the `ServiceManager`
    object to our disposal we can get the logger by doing something like the following
    `Controller` (file: `/module/Application/src/Application/Controller/IndexController.php`)
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a FirePHP logger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The FirePHP logger is the same as the Logger initialization shown before in
    `/config/autoload/global.php` with one difference, and that is `Zend\Log\Writer`
    attached to `Zend\Log\Logger`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logging is one of the most underestimated pieces of code that we kind of forget
    to implement. And when we implement it, we forget to make use of it regularly
    enough.
  prefs: []
  type: TYPE_NORMAL
- en: We all know that it is important, but for some reason we are hesitant to implement
    it on a regular basis.
  prefs: []
  type: TYPE_NORMAL
- en: What we are going to do is install a logger in our basic Zend Framework 2 application,
    and a more special way of logging with FirePHP.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a really simple file logger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we saw in the preceding `indexAction` method, we have simply put a debug
    statement in our `application.log` file, which will look similar like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The log methods we can use are `log()`, `info()`, `warn()`, `err()`, and `debug()`,
    if we use `log()`, we need to give it a priority first and then pass the message
    as parameters. As we can also see, assigned to `DEBUG` is the value `7`, this
    refers to the level of priority used. In our case `DEBUG` has priority `7`, but
    there are more priorities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a FirePHP logger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we now begin logging with the FirePHP writer, we will receive the following
    entries in our Browser console. (Press *F12* in Mozilla Firefox, Chrome, and Microsoft
    Internet Explorer.)
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a FirePHP logger](img/4841OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see this gives a quite clear view of the log items sent through the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that using the `debug()` log method in Zend Framework 2.2.4 still
    executes and outputs a `trace()` instead of the message we want to display when
    using the FirePHP writer. This is currently reported as a bug, but it hasn't been
    confirmed yet, so we don't know for sure if it will be ever solved.
  prefs: []
  type: TYPE_NORMAL
- en: However, using this `debug()` method results in a really (really) big return
    header and it will slow down the response times of a larger application by literally
    minutes.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing before we move on, please don't use the FirePHP `log()` method
    in a production environment, as everyone (literally) will be able to see what
    and when you logged in and out; and that is something you don't want.
  prefs: []
  type: TYPE_NORMAL
- en: About the Logger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Log\Logger` holds a collection of methods that can be used to log in a
    standardized fashion. The `Logger` has one or more `Zend\Log\Writer` objects attached
    to it, to which the `Logger` writes to. The `Writer` is the only class that does
    the actual writing to the requested log method.
  prefs: []
  type: TYPE_NORMAL
- en: With `Writer\FirePhp`, this is by sending headers to the client browser through
    the response, with the `Writer\Stream` it is a physical file (funny how we use
    physical here isn't it?).
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing – why would you do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is a form of testing that has been widely accepted in the programming
    world. Unfortunately a lot of PHP developers still lack the knowledge on how to
    utilize it to their benefit, or they just don't know how to get started. This
    recipe will try to change that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with Unit testing a Zend Framework 2 application, it is required
    that we have PHPUnit 3.7.x installed. We can do this in a couple of different
    ways, but the easiest and most recommended way is by installing it through Composer,
    which comes with the Zend Framework 2 application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install PHPUnit through Composer we just need to add the following lines
    to `composer.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After saving the `composer.json` file, run Composer to update the new requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After a short while, the Composer installer will be complete and we will be
    ready to begin creating our unit tests. We can see that we now have an extra directory
    in our vendor directory called phpunit.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can show how to really unit test our application, it is best that
    we show off the concept behind it first.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo-code examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will now examine a couple of pseudo-code examples that display an effective
    way of coding according to a (sort of) TDD principle (technically it will be PHP,
    but we won't take it too seriously as we just want to show some example).
  prefs: []
  type: TYPE_NORMAL
- en: For this example we will have a class, called `Person`, with only the `isAdult()`
    method in there. After we have defined the method, we should write our first test
    that should let our initial outcome fail.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we have no code in our method yet, the result will always be null, so this
    test will immediately fail as we expect a false to be returned back at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we execute PHPUnit now, it would (hypothetically) result in the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally seeing a failure would be considered wrong, however in this instance,
    we would know that our method does what we expect it to do: fail! The next step
    is to make the test pass, so let''s add a simple return `false` to our `isAdult`
    definition.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we know run the test again we will see that the test has now passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now it is time to continue by making sure that the test fails again, this time
    we want to make sure that we accept a parameter, `$age` and we want this value
    always to be an integer and higher or equal to 18, and if not we want to get `false`
    returned back as result.
  prefs: []
  type: TYPE_NORMAL
- en: So let's continue and edit the `test` script so that it fails again (never was
    failing so much fun).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now run the test again, we will see that the test fails, which in this
    case triggers us to rewrite the following code so that the test will pass again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And if we now run the test, the test will pass again, which means we can (if
    we need to) run the cycle again of making the test fail, change the code to let
    it pass again, etcetera, etcetera! The cycle will continue until we are happy
    with the result of the method and it exactly does what we planned it to do.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we talk about unit testing, a lot of developers have one of the following
    thoughts about it:'
  prefs: []
  type: TYPE_NORMAL
- en: They simply don't know what it is, or what its use is; or they know they should
    do it, but they tend to not do it.
  prefs: []
  type: TYPE_NORMAL
- en: Of course there is also the occasional "I don't see any positive side to it"
    kind of developer, but we will just ignore that comment for now.
  prefs: []
  type: TYPE_NORMAL
- en: What is unit testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unit testing is the art of testing the smallest testable part of an application.
    Unit tests are divided up in test cases, which are compartmentalized tests that
    should test only one specific part of your code.
  prefs: []
  type: TYPE_NORMAL
- en: This unit test can use other objects through the use of mock objects, fakes
    and method stubs, but the main part is that only one particular piece of code
    should be tested in a unit test at any given time. The idea behind this is that
    we have a small unit test which tests only a small part of the code, so when problems
    occur we don't have to look far and wide to find out where the problem lies.
  prefs: []
  type: TYPE_NORMAL
- en: In reference to Zend Framework 2 we would usually unit test the models, services
    and controllers but not the html output (unless we are testing the `ViewRenderer`
    perhaps).
  prefs: []
  type: TYPE_NORMAL
- en: When should we test? – before, or after code is written
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a pure **TDD** (**test-driven development**) point of view, it is a simple
    answer: before. The whole idea of TDD is that a test is written before development
    begins, and therefore it always fails. The reason why it is important that a test
    fails is that we then know that the test we wrote at least fails. If we write
    a test that has never failed, how can we know that it will fail when it actually
    should fail?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously there are also arguments for writing the test afterwards, one of
    them being that we cannot test code that we haven''t designed yet. Although there
    is a point to that argument, personally I don''t view it is a valid one. We can
    write tests beforehand, but that doesn''t mean that we should write the full test
    before the code is written. The idea is to do the following: write a test, let
    it fail, write code to let it pass, and repeat the process from the start again.
    It also forces you to think about the app architecture before you start coding
    your app.'
  prefs: []
  type: TYPE_NORMAL
- en: It is a matter of discipline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unit testing is a strong matter of discipline, as it requires us to stop being
    eager to code and write the test first. For a lot of developers this means that
    we should throw out our current "muscle-memory" coding and really think what we
    want to code, before we actually start to code.
  prefs: []
  type: TYPE_NORMAL
- en: Of course when we start a new piece of code we have an idea of what we want
    the functionality to do, for example getting records from the database. However
    it is important to think about what we want to get as a return from that functionality.
    Is it an array, or is it a `boolean`, does it throw Exceptions and what if we
    don't get valid parameters? All of these things are questions that are architecture
    related, but are usually not defined beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing works only because of a strong discipline in the team. If we were
    the only one in our team that would write the tests for the code, we would surely
    fail in being able to maintain it as other members of our team would (unintentionally
    probably) break our unit tests whenever they would change something in the code.
  prefs: []
  type: TYPE_NORMAL
- en: However, it cannot be under estimated that unit testing is an invaluable part
    of software development, even if done after the code is already written (as you
    can see I am all for writing tests first).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and using unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start using Unit testing in Zend Framework 2 can be a bit of a hassle. But
    don't worry; help is coming as we fly you through a proper set up of Zend Framework
    2 unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with Unit Testing a Zend Framework 2 application, it is required
    that we have PHPUnit 3.7.x installed. We can do this on a couple of different
    ways but the easiest and recommended way is by installing it through Composer
    which comes with the Zend Framework 2 application.
  prefs: []
  type: TYPE_NORMAL
- en: To install PHPUnit through composer we just need to add the following lines
    to `composer.json`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After saving the `composer.json` file, run Composer to update the new requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: After a short while the Composer installer will be complete and we will be ready
    to begin creating our unit tests. We can see that we now have an extra directory
    in our vendor directory called `phpunit`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up unit testing with PHPUnit is fairly simple in Zend Framework 2, and
    fortunately well documented as well.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the test framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get everything to work in order, we need to set up our separate test framework
    first. For that we will need three new files: `Bootstrap.php`, `TestConfig.php`,
    and `phpunit.xml`.'
  prefs: []
  type: TYPE_NORMAL
- en: Because we basically want to test per module (keeping it all separate from each
    other, remember) we need to set this up for every module we are testing.
  prefs: []
  type: TYPE_NORMAL
- en: First of all we should create the directory called `test` in the root of the
    `module` directory. In that directory we create a file called `phpunit.xml` in
    `/module/Application/test/`, which is used by PHPUnit to determine some configurations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This first file is used for the general configuration of PHPUnit, and has many
    more options than the ones we showed here, but these are not relevant for our
    setup right here.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we want is to set up the `TestConfig.php` file in `/module/Application/test/`,
    which is a simple configuration file that loads up the most basic configurations
    we need to start up the application and run our code. It is basically the same
    as the normal `application.config.php`, but we need it in a separate file as we
    want to be able to make changes without it affecting the main application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The next and last thing to set up in our testing framework is the `Bootstrap.php`
    file in `/module/Application/test/` that we referenced in the `phpunit.xml` file
    as our bootstrap. This bootstrap class is created by *Evan Coury* the primary
    author of the entire ZF2 module system, but we added the commentary to make it
    all a bit clearer of what is going on. It is important for us to know how this
    bootstrap works to ensure we can make optimal use of it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now let's start by creating the init() method, which will be used later on to
    bootstrap the application so that we can use it to test on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Up until now showed the definition of the configuration file, and it is now
    all merged for use by our bootstrap. Next up is the definition of the service
    manager.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That's the end of our initialization, and as we can see it is pretty straightforward
    what is being done. The bootstrap initialization first read out the configuration
    and then created the service manager. After the service manager was created, we
    used the module manager to load up the modules (and dependencies) we required
    for our tests. Now that we have defined our most important part of the class,
    let's define the rest of the methods that we used in the preceding `init()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we finally set up our testing framework, it is time to write a simple test
    to see if everything works. What we''ll do first is create a small Model (file
    `Company.php`: `/module/Application/src/Application/Model/`), which we are going
    to test.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it, no more coding at this point, as we first need to create our unit
    test (file `CompanyTest.php`: `/module/Application/test/Application/Model/`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: And there we go, a simple test that does nothing but prints an `I` (which means
    one incomplete test) in the terminal if we were to execute it. As we can see we
    also defined a `@covers` PHPDoc tag, which is always a good idea for the sake
    of good documentation to actually document what method you are testing.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To execute the PHPUnit tests, simple go to the `test` directory and type `phpunit`,
    which will trigger PHPUnit to test every file that ends in `Test.php` like `SomeModelTest.php`
    and look for methods that begin with `test` like `testSomeMethod`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's do a simple test now, which tests if our method return value is true or
    not (file `CompanyTest.php` in `/module/Application/test/Application/Model/`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If we now run PHPUnit again, we'll see that it has printed a nice big red `F`
    (which means the test failed) in the terminal. Now we know that the unit test
    fails, we will modify our model (file `Company.php` in `/module/Application/src/Application/Model/`)
    again to make sure it passes again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If we now run PHPUnit again, a `.` (which means that the test passed) simply
    appears in the terminal. We know now that our test worked, and that we can trust
    the outcome of the unit test as well. We can now use this test framework over
    and over again for every other method and module that we write.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we did first is set up a small testing framework that would load in anything
    we need for the module that we want to test. After that we wrote a couple of simple
    tests for some code that we wanted.
  prefs: []
  type: TYPE_NORMAL
- en: The test framework we set up is a test framework that can be used per module
    separately, as it is unwise to make one test framework for the whole application.
    What we are trying to achieve is that our modules are still as independent as
    they can be (considering of course that some modules will have dependencies),
    and that we can test them separately as well.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The framework we've set up is also available in the official documentation,
    which means that there is always support available if we are stuck with something.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The PHPUnit XML configuration file options:[http://phpunit.de/manual/3.7/en/appendixes.configuration.html](http://phpunit.de/manual/3.7/en/appendixes.configuration.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The PHPUnit cheat sheet: [https://gist.github.com/loonies/1255249](https://gist.github.com/loonies/1255249)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
