- en: Extending Plugins with Addons, Filters, and Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: uilding sites with WordPress involves using existing plugins or creating your
    own plugins. You should be able to extend existing plugins with new features as
    well as make your plugins extendable for other developers. We use addons to extend
    the functionality of a core plugin. So, it's important to keep your plugins extendable
    so that you can later use addons to add or remove functionality. On the other
    hand, using and customizing existing plugins with addons allows you to provide
    low-cost and quality solutions. So, you need to master the techniques of building
    addons for customizing plugin features as well as integrating multiple plugins.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explain the importance of addons while following the step-by-step
    guide to creating an addon for a plugin. WordPress uses a hook-based architecture
    and hence the built-in hooks are executed in a predefined sequence. We look at
    the proper execution of these hooks to prevent unnecessary conflicts. Then, we
    move into customization techniques for plugins while learning the advance uses
    of script loading and built-in AJAX features. We will be developing a product
    files addon for WooCommerce, in order to practically experience the customization
    process. Finally, we integrate the WooCommerce, MyCred, and BuddyPress plugins
    to learn the best practices of plugin integrations and their limitations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to addons development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic addon for the post attachments plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the WordPress core action execution process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing third-party plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying techniques for integrating plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating multiple plugins for continuous workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have the ability to customize third-party
    plugins using different techniques, and integrate multiple plugins to build a
    continuous workflow for your site.
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have WordPress 4.9.8 installed to follow this procedure.
    Even if you
  prefs: []
  type: TYPE_NORMAL
- en: have a later version of WordPress, the described examples should work with no
    significant problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter05](https://github.com/PacktPublishing/WordPress-Development-Quick-Start-Guide/tree/master/Chapter05)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2Q8LtBa](http://bit.ly/2Q8LtBa)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to addons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general terms, addons are components that change the behavior of a core component.
    As a developer, you might be familiar with using browser extensions to support
    development tasks. In such a scenario, the web browser acts as the core component
    and the extensions act as the addons that install on top of the web browser. The
    addons in WordPress follows the same concept. However, WordPress addons itself
    are plugins that change the behavior of a main plugin. Unlike browser extensions,
    addons in WordPress don't install on top of a plugin. Instead, they act as separate
    addon plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, addons are used to add new features to the core component. However,
    WordPress addons are developed to add, change, or remove features of a core component.
    Let''s take a look at some of the popular plugins with a large addons base:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WooCommerce**: This is an eCommerce plugin that allows you to sell physical
    goods as well as digital products. This plugin has an extensive addons base of
    over 250 addons in various categories. Payment gateways are the most popular type
    of addon in WooCommerce with over 75 addons. You can view and learn more about
    the addons base at [https://woocommerce.com/product-category/woocommerce-extensions/.](https://woocommerce.com/product-category/woocommerce-extensions/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy Digital Downloads**: This is an eCommerce solution allowing you to sell
    digital products. This plugin also offers over 100 addons while many of them fall
    into the marketing category. You can learn more about the addons base at [https://easydigitaldownloads.com/downloads/.](https://easydigitaldownloads.com/downloads/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WP Bakery Page Builder**:This is a plugin used for building page using pre-built
    components. Both WooCommerce and Easy Digital Downloads are free plugins in the
    WordPress plugin directory. However, this is a premium-only plugin with over 250
    addons in various categories. The UI elements is the most popular addon category
    for this plugin. You can view and learn more about the addons base at [https://wpbakery.com/addons/.](https://wpbakery.com/addons/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: hese are some of the plugins with a large addons base. The existence of addons
    means that the plugin is coded with necessary hooks for future extension. You
    can check more popular free and premium plugins to check the availability of addons.
    Also, you should check the role of each addon and how it interacts with the main
    plugin. Once you explore different types of addons, you will understand the types
    of hooks needed in development and how to add them to keep the code open for extension.
  prefs: []
  type: TYPE_NORMAL
- en: Creating addons for plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The process of creating addons is similar to the process we used for plugins.
    However, the possibility of creating an addon depends on the quality of the code
    in the core plugin. The core plugin should either provide an API to build addons
    or necessary hooks for extension. As many plugins don''t contain a separate API,
    most addons are built by using the existing hooks. Let''s see how we can create
    an addon for the post attachments plugin created in the previous chapter. Assume
    that we have the following requirements to be developed as an addon:'
  prefs: []
  type: TYPE_NORMAL
- en: Restrict attachment file types based on default WordPress user roles. Let's
    provide PDF file access only for non-subscriber members and all other file types
    to all users in the site.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download counter for attachments. We have to count the number of downloads for
    all attachments of a post, separately for guest users and logged-in users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to implement such requirements without touching the core plugin files,
    we need to check the availability of any hooks within the plugin. Unfortunately,
    we don't have any hooks within the plugin, as it was not planned for future extension.
    So, we have to make the plugin extendable, by adding the necessary hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a filter hook for restricting attachments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing attachment restrictions requires us to conditionally check the
    user permissions and hide the attachment for unauthorized users. So, we need a
    filter that can modify the output of attachments in list. Let''s add a filter
    to the file list code inside `wpqpa_file_attachment_list`. We need to replace
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'First, you should remove the preceding code and add the following code to the
    same location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Instead of directly adding each file HTML code to the `$display` variable, we
    use a custom filter called `wpqpa_post_attachment_list_item` with file details
    passed as a parameter. This filter allows us to modify the HTML for each file
    before it's delivered to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an action hook for counting downloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we looked at the process of using filter hooks to
    extend plugins. We can also use action hooks to extend plugins through addons.
    The process of counting downloads should be initialized just after the user clicks
    the Download link and before the file download popup is shown on the browser.
    So, we need an action hook within those two events. Let''s modify the `wpqpa_file_attachment_download`
    function to include a new action, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted line shows the modifications added to the existing code. This
    action allows us to implement additional features before the file is sent to the
    browser as a download. Now, we have the necessary hooks to create the addon and
    implement the features.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the attachments addon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, we have to start by creating a plugin directory with a main plugin
    file, and inserting the header comments to define it as a plugin. We are not going
    to repeat the code in this section. You can find a directory and files for attachments
    addon inside the `wpquick-attachments-addon` directory in source codes. We are
    going to start the development by restricting the PDF files to users with a subscriber
    role. Let''s implement the `wpqpa_post_attachment_list_item` filter we added in
    the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what this code does:'
  prefs: []
  type: TYPE_NORMAL
- en: The callback function has two parameters, with the first one being the HTML
    for displaying the file link and the second one being the details about the file
    from database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, we construct the path of the file by using the WordPress `wp_upload_dir`
    function and file path captured from our custom table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we use the PHP `mime_content_type` function to get the MIME type of the
    attachment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we filter the files with the MIME type for PDF.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we use the condition to check whether the file should be displayed to
    the user. The first part of the condition checks if we are logged into the site,
    as the file needs to be restricted for guest users. The second part of the condition
    checks if the user is logged in as a subscriber.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We restrict the file by emptying the content when one of these conditions is
    met.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we have implemented one of the addon features using a filter hook. Next,
    we can implement our second requirement for counting downloads using an action
    hook. Let''s implement the custom `wpqpa_before_download_post_attachment` action
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: First, we define the action with a callback function, `wpqaa_before_download_post_attachment`.
    The attachment data received from the `wp_wpqpa_post_attachments` table is passed
    as an array type parameter to this function. We use a conditional check to filter
    the logged in users and guest users. Our requirement is to count the total downloads
    for attachments of a single file. So, we can use the `wp_postmeta` table to store
    the download count.
  prefs: []
  type: TYPE_NORMAL
- en: In actual implementations, we may need to count the downloads for individual
    attachments, instead of the total count for all attachments in a post. In such
    a scenario, we can't use the `wp_postmeta` table as we can only store data based
    on post ID. So, we need to have an additional column in the `wp_wpqpa_post_attachments`
    table to keep and display the download counts for each attachment.
  prefs: []
  type: TYPE_NORMAL
- en: We can get the existing download count for a post using the `get_post_meta`
    function. Here, we use two keys called `wpqaa_member_download_count` and `wpqaa_guest_download_count`
    to separate the counts for guests and members. Later, we can use these keys to
    display the counts along with files.
  prefs: []
  type: TYPE_NORMAL
- en: In just a few lines of code, we have an addon that adds functionality to the
    core plugin and works independently. So, developing addons for any plugin is simple. However,
    the core plugin needs to provide the correct actions and filters, as well as developers
    being capable of finding the appropriate hooks.
  prefs: []
  type: TYPE_NORMAL
- en: The WordPress action execution process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we used some of the built-in actions and filters, while explaining
    the practical uses. However, you might be still trying to grab the concept, as
    it's not a practice used in pure PHP development. The process gets even tougher
    when coping with the lack of knowledge in the action execution process.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the action execution process?**'
  prefs: []
  type: TYPE_NORMAL
- en: WordPress has a set of built-in actions that are executed within the loading
    process of each and every request. Each of these actions has a sepcific responsibility
    in the loading process. The actions used for the loading process are executed
    in a predefined sequence. However, The WordPress Codex specially mentions that
    we shouldn't rely entirely on the loading process as it can vary based on the
    other components in the site.
  prefs: []
  type: TYPE_NORMAL
- en: This list may show only the first time each action is called, and in many cases
    no function is hooked to the action. Themes and plugins can cause actions to be
    called multiple times and at differing times during a request. This list should
    be viewed as a guideline or approximation of the WordPress action execution order,
    and not a concrete specification.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing features using these actions without considering the sequence can
    often lead to conflicts. In WordPress, execution of these actions in the admin
    page requests differs from a typical page request. So, we have to be aware of
    both the frontend action execution process as well as the backend action execution
    process.
  prefs: []
  type: TYPE_NORMAL
- en: The frontend action execution process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The frontend action execution process starts with the `muplugins_loaded` action,
    which fires after the must-use and network-activated plugins are completed loading.
    The process completes by executing the `shutdown` action. There are 40+ actions
    called in a typical request, where some of them have higher importance in the
    development tasks. However, some of these actions change based on the request,
    and hence we can only use this as guidance. Let''s take a look at the following
    illustration to understand the general actions and the order of execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e884d276-47f6-45a3-904e-77b432fd9e53.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's understand the illustration of the loading process. The process begins
    with the `muplugins_loaded` action and moves downwards until it reaches the `admin_bar_init`
    action. Then, it starts from the `add_admin_bar_menus` action in the second column
    and moves downward, and so on. We have highlighted some of the actions used frequently
    in development. You can learn more about the action execution process at [https://codex.wordpress.org/Plugin_API/Action_Reference](https://codex.wordpress.org/Plugin_API/Action_Reference).
    The order of execution of these actions is very important in custom development,
    especially when we use the built-in global objects of WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: First, we are going to create a new plugin called **WPQAL Action Loading**,
    to test the functionality when loading specific actions. The process of creating
    the plugin is same as the one used in previous occurrences. Therefore, you can
    check the source codes directory of this chapter to find the implementation for
    the WPQAL Action Loading plugin. Let's use the preceding illustration and some
    practical usage scenarios to understand the importance of proper use of actions.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 1 – Using parent plugin features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is commonly used in addon development, as we rely on the features of the
    main plugin. In addon development, we have to use constants, functions, classes,
    global objects from the main plugin. Unless we use the proper WordPress actions,
    these features may not be accessible within the addon. Assume that we have an
    addon plugin that gets loaded before the parent plugin. We can think of the **WPQPA
    Post Attachments** plugin as the main plugin and WPQAL Action Loading as the addon
    plugin to check this scenario. The WPQPA Post Attachments plugin is loaded after
    WPQAL Action Loading plugin. So, we can add the following line of code to main
    file of WPQAL Action Loading plugin and check the output by refreshing the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the constant used to define the plugin path of the **WPQPA Post Attachments**
    plugin and hence it should print the actual path to the browser. Instead, the
    output will be `WPQPA_PLUGIN_URL`, as string. The problem is we are trying to
    access a constant not defined when we are trying to access it. So, we need to
    access such constants, functions, variables when all plugins have completed the
    loading process. We can refer to the image and find an action called `plugins_loaded`.
    This action is executed after WordPress has completed loading all active plugins.
    So, let''s take a look at the proper implementation of the preceding code to print
    the plugin path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, you should see the correct plugin path printed to the browser. You can
    uncomment the code for *Scenario 1* in the WPQAL Action Loading plugin to test
    the scenario. To access features from other plugins, we must use `plugins_loaded`
    or a later action.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 2 – Accessing the WordPress post object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usually, we can use the WordPress global `$post` object in the post details
    page to get the necessary information about a post. Let''s assume we want to get
    the ID of the loaded post within a plugin function to execute some tasks. Let''s
    use the `init` action to print the post ID to the browser while accessing an individual
    post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We expect the post ID to be printed on the browser. However, we will get an
    empty output as the `$post` object is not loaded at this stage. So, we have to
    use an action executed later in the loading process. The global `$post` object
    is only accessible in the `wp` action and the actions executed afterward. Use
    the following code to test the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can see the ID printed to the browser. You can also test the process
    by using the actions between `init` and `wp` in the loading process.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 3 – Accessing the WordPress query object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WordPress executes many database queries in the process of loading a certain
    post, page or screen. In development, we might need to access the details of the
    query such as query variables, conditions, and even the complete `sql` query generated
    from WordPress functions. So, we use the global `$wp_query` variable to access
    query details as well as make necessary modifications before execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to access the `$wp_query` variable using the `pre_get_posts` action
    that gets executed after the query variable object is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the post is refreshed, you will see the details of the `$wp_query` variable
    with some parameters. But, most of the query conditions and queries are not set
    at this stage. Even though the query variable object is created, the actual query
    is not executed at this stage. This action allows us to make the modifications
    to the query using the `$query` variable passed to the function. Let''s use an
    action executed later in the process to check the `$wp_query` details using following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, you will see the complete `$wp_query` variable with all the query parameters,
    conditions, and actual SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: As we experienced in these three scenarios, the action loading process plays
    a major role in development. We need to use the proper action hooks to access
    built-in WordPress variables as well as execute certain core WordPress functions.
    The method of identifying which hook to be used for certain features may not be
    straightforward. You can define the necessary actions and print the details to
    the browser without using the `exit` statements. Then you will see the action
    execution process and which action is responsible for handling each WordPress
    built-in variable and method.
  prefs: []
  type: TYPE_NORMAL
- en: The backend action execution process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The backend action execution process starts with the `muplugins_loaded` action,
    which fires after the must-use and network-activated plugins are completed loading.
    The process completes by executing the `wp_dashboard_setup` action, instead of
    the `shutdown` action.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are six more actions in the backend execution process, compared to the
    frontend process. Let''s take a look at the following image to understand the
    actions and the order of execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b306c8f-5feb-4493-906f-7deec60a6311.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the initial part of the loading process is similar to the frontend
    process. Then, we see some admin-related actions executed for menus, styles, and
    header sections. So, you can use the same technique we used earlier to understand
    the execution of each action, its responsibility, and when we should use them.
  prefs: []
  type: TYPE_NORMAL
- en: How to use the priority of actions and filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We learned the action loading process and how it should be used to grab the
    proper data and execute the core features. However, developers may still get into
    trouble, even after knowing the loading process. This is due to the priority of
    executing actions. As we discussed, these actions can be executed multiple times
    within a request by WordPress core, theme, as well as other plugins. So, the same
    action hook will be implemented with different priorities. Consider the following
    code for using the `pre_get_posts` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the first part, we use the `pre_get_posts` action to call the `wpqal_pre_get_posts_action1`
    function and restrict site search to only posts. However, another plugin executes
    the same action with higher priority number of 20 and changes the searchable post
    types to both posts and products. So, our implementation doesn't work as expected.
    So, it's important to consider the action loading process as well as priority
    when working on a site with many plugins. Before implementing a critical hook,
    you should check the use of the same hook in other plugins of the site and make
    sure to use the correct priority to avoid conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the extendable features of third-party plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we already discovered in the *Creating addons for plugins* section, not all
    plugins are extendable. Even within extendable plugins, we have a low to high
    degree of extendibility in features. So, identifying the extendable features is
    not an easy task, especially when working with advanced plugins such as WooCommerce,
    BuddyPress, and bbPress.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](94db5df8-bbb4-4e75-ae88-fa38a9aabe05.xhtml), *Designing Flexible
    Frontends with Theme Development*, we identified the extendable features of a
    theme by searching for built-in actions and filters. We can use the same process
    for plugins, unless each and every hook in the plugin is documented on the plugin
    site. Let's take a quick look at the extendable features of the popular WooCommerce
    plugin. Use the code editor to search actions and filters within the WooCommerce
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: We are using WooCommerce 3.4.4 version, and we get 849 action executions and
    1,553 filter executions. So, this means we have over 2,000 locations where we
    can customize the WooCommerce plugin. In the process of customization, we have
    to find the necessary hooks with the support of documentation, checking the code
    files and experiences shared by other developers in development communities such
    as StackOverflow.
  prefs: []
  type: TYPE_NORMAL
- en: The availability of hooks differentiates from one plugin to another. Sometimes,
    we find plugins with a limited amount of hooks and popular plugins with thousands
    of hooks. So, you have to master the process of identifying the hook and how it
    impacts the plugin to be successful in customizing any plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing third-party plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As developers, we prefer building our own solutions compared to using third-party
    solutions. The main reason for building our own solutions is to gain more control
    over the features as well as future enhancements. However, the main purpose of
    using WordPress is to develop rapid low-cost solutions with the use of existing
    features. It's obvious that you have to work on customizing third-patty plugins
    at some point in your development career. These third-party plugins are developed
    to provide standard solutions to common problems. Therefore, these plugins won't
    fit into the complete requirements of most sites. Often, we have to adapt these
    plugins by adding, changing, or removing features. In this section, we are going
    to look at the techniques and implementation of plugin customization using sample
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Techniques for customizing third-party plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with themes, plugins consists of various types of common customization's.
    Most site owners and developers misunderstand the meaning of plugin customization.
    Often, they think of it as a process that completely changes the plugin to suit
    the needs of your site. However, we may only need a few style changes as the customization.
    Sometime,s we have quicker and simple ways to customize plugins compared to using
    advanced processes. So, it's important to understand the different types of customization's
    and techniques for implementing them. Let's go through some of the common types
    of customization's.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing look and feel using styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is one of the frequently used customization''s where you need all plugins
    to match the styles of the theme. We have three ways of applying style customization''s
    for a plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using theme styles files**: We can add the styles to the `style.cs` file
    of theme theme and override the plugin styles. This method should be only used
    in the child theme, when there are minor style changes to the plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using a custom CSS plugin**: There are many existing CSS plugins that allows
    us to add dynamic custom styles to various parts of the site without needing to
    create CSS files. These plugins provide a settings section, where we can add the
    dynamic CSS to be stored in the database and loaded to the site. This technique
    can be used for minor style customizations of many plugins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using an addon plugin**: This is the recommended method to keep the styles
    changes independent from other plugins. In this method, we have to create a simple
    addon plugin and include a new CSS file. Then, we can override the plugin styles
    by using new styles for the same CSS classes. We have to use the dependency parameter
    of the `wp_register_style` function to include the plugin CSS file as a dependency,
    and load our CSS file after loading the plugin CSS file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the common methods for changing the look and feel of a plugin. However,
    some plugins may provide you with a setting to add a dynamic plugin-specific CSS
    or settings to adjust the styles of different parts by modifying values.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the features with hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the beginning of this chapter, we have seen that the execution of hooks isn't
    always trivial. WordPress is using hooks all over the place, and this can sometimes
    make things complex. However, in plugin customization, this solution helps a lot,
    and we will see the benefit of using such a solution.
  prefs: []
  type: TYPE_NORMAL
- en: We may have to use different plugins every day. So, it's impossible to learn
    each and every feature of the plugins we us on different projects. Instead, we
    can look for files or classes that implement the customized feature. Then, we
    can search for possible hooks that supports our customization. Once the necessary
    hooks are found, we implement them based on the guidelines. Implementing a hook
    makes sure that the complete process for the feature is executed. If hooks were
    not available, we have to go through complete plugin files and classes to identify
    the location for the customization's. Also, we have to go through follow-up code
    to check if it affects our customization or possible future modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider an example from a popular WooCommerce plugin. Assume we want
    to execute certain code after the user completes product payment. So, we can just
    search for a payment success hook and its implementation. WooCommerce executes
    the `woocommerce_payment_complete` action after the payment. Therefore, we can
    implement it using the following code to execute any kind of custom code on completion
    of the payment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, within few lines of code, we have customized WooCommerce without
    spending too much time or getting in-depth knowledge of WooCommerce. Let''s assume
    there are no such hooks in WooCommerce. In such a case, first we have to find
    the `WC_Order` class and the `payment_complete` function used to handle the payment
    process. Then, we have to go through each and every line of code within the `payment_complete`
    function to understand the location for the completion of payment. You can already
    see the difficulty in the second process compared to the method of using hooks.
    So, we should always look for possible hooks to customize the plugins. There are
    two types of feature customization''s in plugin development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Customizing existing features**: Sometimes, we want to change or remove the
    existing features of a plugin. In such cases, we can implement an existing hook
    and change existing data or settings using the parameters passed to the function.
    Sometimes, we may want to go one step further by completely changing a feature
    with our own implementation. In such a case, we can remove the existing hook using
    the built-in `remove_action` or `remove_filter` functions. Then, we add the same
    hook with our own implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adding new features**: In customization''s, a high percentage of tasks are
    involved in adding new features, compared to modifying existing features. In this
    method, we implement the existing hooks similar to the previous section. However,
    we use our own code and add new features on top of existing features, rather than
    modifying the existing ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discussed different types of customization's in plugins. In the next section,
    we are going to customize a plugin by implementing a real-world requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Building the WooCommerce product file manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of changing or adding a new feature using hooks is the most common
    type of customization for third-party plugins. These hooks allow us to build advanced
    features without spending much time. In this section, we are going to implement
    a real-world use case to understand the hook-based customization process in detail.
    So, we have chosen to customize WooCommerce.
  prefs: []
  type: TYPE_NORMAL
- en: Assume we want to provide files related to each WooCommerce product. These files
    may contain product specifications, user guides, or any information related to
    the product. So, we need a way to upload these files while creating or editing
    a product. Then, we have to list them in the frontend product page as a separate
    tab. This might seem like an uphill task for developers not familiar with WooCommerce.
    However, the implementation is quite simple once we find out the necessary WooCommerce
    hooks. Also, another purpose of this implementation is to reuse the code from
    the post attachments plugin and learn the use of AJAX, instead of normal form
    submissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the implementation by creating a new plugin called **WQWPF Product
    Files** with the same process. You can find the plugin files inside the source
    codes directory for this chapter. Consider the initial code for the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The initial part of the code is similar to the code we used in WPQPA Post Attachments
    plugin, with the exception of removing the `file_name` column from the custom
    table for product files. This will be an addon for WooCommerce and hence we need
    to check whether WooCommerce is activated before executing any addon functions.
    Therefore, we use the `plugins_loaded` action to check the availability of `WooCommerce`
    class. We can use constants, classes, or functions to check the availability of
    a core plugin. When `WooCommerce` class is available, we add all the actions and
    filters related to the addon, so that they are executed only when `WooCommerce`
    is available. Now, we can start building the required functionalities for customization.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the file upload field to WooCommerce products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step in the development process is to provide an interface to let
    administrators upload files to products. We can implement this by using the metabox
    technique we used while building the post attachments plugin. However, we are
    trying to understand plugin customization and hence we are going to integrate
    this feature into WooCommerce. In the WooCommerce product creation screen, we
    can find a meta box called Product Data with various tabs such as General, Inventory,
    Shipping and so on. We are going to add a new tab to the meta box as Product Files.
    First, we have to look for actions or filters that let us modify the Product Data
    tabs. You can find a filter called `woocommerce_product_data_tabs` for customizing
    the tabs. Let''s use the following code to add a new tab using this filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This filter is dependent on WooCommerce and hence the `add_filter` line should
    be placed inside the `wqwpf_plugins_loaded_action` function. The existing tabs
    are passed as a parameter to the callback function of this filter. We add a new
    tab with a unique key and assign the necessary options. The `target` setting contains
    the ID of the HTML element that is used to display the content for this tab. The
    tab content will be added in next stage. The `class` setting defines an array
    of classes assigned to this tab. Here, we have used `show_if_simple` as the class.
    So, our tab will be only visible for Simple WooCommerce products. We need to add
    more classes in case we want to make the tab available for other product types.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, we added a new tab. We can also use this filter to remove
    existing tabs by using the `unset` function on `$tab` array elements, or change
    the settings of existing tabs by using the proper array key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is adding a file field to the tab for uploading files. We can
    find another action hook called `woocommerce_product_data_panels` for adding tab
    content. Let''s use it to add the file field, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we have added a file field to upload files, a button to initialize
    the upload process, and a hidden field to keep the nonce value. The structure
    of the HTML is copied from the other available tabs. The most important part is
    understanding how this tab content connects with the tab we created earlier. We
    have used `wqwpf_file_options` as the ID of the main container for the tab. We
    used the same ID as the `target` setting for our new tab. So, once the tab is
    clicked, WooCommerce will use the target setting to find the container and display
    it to the user. The following screen previews the new tab after using the custom
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5feef139-31d1-42b0-bfe8-cc388e892f0d.png)'
  prefs: []
  type: TYPE_IMG
- en: The new tab for Product Files is added between the Inventory and Shipping tabs.
    Now, we are ready to start uploading files.
  prefs: []
  type: TYPE_NORMAL
- en: Adding scripts for uploading files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](6bc0e5d5-b12d-4710-ac11-a600af054efa.xhtml), *Building Custom
    Modules with Plugin Development*, we created a plugin to upload attachments to
    posts. However, we had to select a file and upload files one by one while updating
    the post for each file. This is not ideal in situations where we have many files
    to be uploaded. Instead, we have to use AJAX and let the user upload multiple
    files without refreshing the browser. Before moving into the process of uploading
    files, we need to add the necessary scripts to the plugin. First, you have to
    create a new directory inside `wpquick-woo-product-files` as `js`, and create
    a new file called `wqwpf-admin.js`. Next, we can add the script to the plugins,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the preceding code to learn some of the important techniques in
    script loading. Let''s list the important parts of script loading:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Registering and enqueuing scripts**: Until this point, we only learned how
    to include CSS files. So, we can now move onto loading scripts with the `wp_register_script`
    function. Here, we are including a script in admin side and hence we have to use
    the `admin_enqueue_scripts` action to use a callback function for including scripts.
    The first line of the preceding code should be placed inside the `wqwpf_plugins_loaded_action`
    function, as it depends on the existence of WooCommerce. Inside the callback function,
    we can use the `wp_register_script` function to register a custom script for WordPress.
    The parameters of this function include a unique key for the script, a path to
    the script, and dependent script files. The script is only registered at this
    stage and not included in the browser. Then, we use `wp_enqueue_script` wherever
    we want to include the script to the browser using the key used in script registration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defining script dependencies**: We can define dependent scripts using the
    third parameter of the `wp_register_script` function. In this scenario, our script
    is coded using **jQuery**, and hence it''s a dependency. So, we add jQuery as
    the key to dependency array. WordPress has a set of built-in scripts with specific
    keys. We need to use these keys without loading these libraries from our own plugins
    or external sources. The list of available script libraries can be found at [https://developer.wordpress.org/reference/functions/wp_register_script#core-registered-scripts](https://developer.wordpress.org/reference/functions/wp_register_script#core-registered-scripts).
    You can use the key in the Handle column to load these dependencies. Once we define
    `script 2` as a dependency of `script 1`, the second script will be loaded before
    the first script. Apart from using core script files, we can also use custom script
    files as dependencies. Consider the following line of code:In this code, we are
    registering a script of another plugin with **jQuery** and `wpwpf_admin_js` scripts.
    So, both of these files will be loaded before loading the script with `upme_admin_js`
    as the handle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Localizing scripts**: Sometimes, we need to add necessary settings and dynamic
    data to specific scripts. WordPress allows us to add such data by using the `wp_localize_script`
    function. This function uses three parameters, starting with script handle, variable
    name, and the data. Once used, these data will be added inline to the browser,
    before loading the script file. Therefore, these data will be accessible within
    the specified script and the other scripts loaded after that defined script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this implementation, we are going to use AJAX, and hence we add the AJAX
    url to the script by using the `admin_url('admin-ajax.php')` function. More about
    AJAX will be discussed later in this section. Next, we add the necessary data
    using preferred array keys. Here, we are only adding messages as an array. We
    also add a nonce value to the script to verify the AJAX request from the server
    side. Once the page is loaded, you can use View Source option to check this data
    loaded before the `wqwpf_admin_js` script. Now, we have completed the script loading
    process and hence we can move into uploading product files.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading files to products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to upload files for products using AJAX requests.
    Before diving into AJAX, we need to complete the initial script with necessary
    data retrieval and validation. Add the following code to the `wqwpf-admin.js`
    file of our plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what this code does:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define a callback function for the `click` event of the Upload button,
    within the jQuery `ready` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `click` event, we need to capture the file and the post ID. We can't
    add our own form as the metabox is inside the WordPress form for creating posts.
    So, we use the form with the ID **post**, to capture the values of form fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we retrieve the container element used to display messages and reset the
    CSS classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we start the validation process for fields. Here, we have only filed field
    and hence checking for empty value is the only required validation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we check for any errors and display the error message by adding the
    necessary CSS classes and enabling the message container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the previous section, we used the `wp_localize_script` function to add the
    data to the scripts. In this section, we are using it to add the error message
    using the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this line, `WQWPFAdmin` is the variable name we used earlier and `Messages`
    is the sub-key of the main array. The `fileRequired` option in the `Messages`
    array will contain the actual message. Similarly, we can access the other data
    using respective keys. Now, we need to implement the AJAX request when the validation
    is completed without errors. Before that, we are going to have a brief introduction
    to AJAX.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to AJAX in WordPress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AJAX is an abbreviation for Asynchronous JavaScript And XML. This technology
    allows us to sent and retrieve data without refreshing the browser. So, the execution
    of repetitive tasks such as multiple file uploading can be simplified by using
    AJAX. Usually, we use a direct URL to execute AJAX requests. However, WordPress
    offers a built-in interface for executing AJAX requests and it's recommended to
    use this technique without using our own AJAX handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'WordPress uses a file called `admin-ajax.php` for handling requests, and the
    file is located inside the `wp-admin` directory. This file contains the necessary
    code for built-in core AJAX requests as well as code for supporting custom requests
    through *actions*. The action is responsible for handling the AJAX request and
    providing the output. Let''s consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines how we should use AJAX in WordPress. Each different
    AJAX request has an action name. We have to use the `wp_ajax_{action name}` or
    `wp_ajax_nopriv_{action name}` action to define the handling function for each
    request. The action with the `wp_ajax` prefix is used for requests when the user
    is already logged into the site. The action with `wp_ajax_nopriv` is used for
    guest users of the site. So, you have to define one or both of these actions depending
    on who is allowed to execute the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have the basic knowledge about AJAX in WordPress and the method for
    handling the request from the server side. So, we can get back to the file uploading
    process by implementing the AJAX call to upload files. The following code should
    be added to the `else` statement of the `click` event in the `wqwpf-admin.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what this code does:'
  prefs: []
  type: TYPE_NORMAL
- en: The first two lines resets message container and assigns form object to a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we use the `WQWPFAdmin` variable to retrieve the WordPress AJAX URL and
    assign a custom parameter called action with a custom action name. This action
    name will be used with the `wp_ajax` and `wp_ajax_nopriv` actions to connect the
    client-side request with the server side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we create a new `FormData` object to sent the data to the server. We can
    assign the necessary data to the `FormData` object by using the `append` function
    with key-value pairs. Here, we have added a file, nonce value, and post ID as
    form data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is configuring the AJAX request with the jQuery `ajax` function.
    You should be familiar with the settings of the AJAX function. Now, the request
    is executed from client side whenever the user clicks the Upload button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we use the success event of the `ajax` function to display the resulting
    message, reset the fields, and display a list of files uploaded to the product.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can complete the process by handling the server-side function for uploads.
    Let''s consider the following implementation with WordPress AJAX actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Only administrators are allowed to upload files to products, and hence we only
    use the action with the `wp_ajax` prefix for logged-in users. Here''s what this
    code does:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we have to capture the `POST` request data for post ID and nonce.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we use the `check_ajax_referer` function to check the nonce values. The
    first parameter of this function uses the action we defined inside the `wqwpf_admin_load_scripts`
    function by calling the `wp_create_nonce` function. The second and third parameters
    are used respectively for the nonce value key in the POST request and whether
    to `die` if nonce is invalid. We have set the third parameter as `false` since
    we want to display a custom error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once nonce is verified, we use the `wqwpf_process_file_upload` function to upload
    the files and get the results. The `wqwpf_process_file_upload` function is similar
    to the function we used in the post attachments plugin, and hence you can check
    the source code for this chapter to go through the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we save the file details to the custom table, similar to the post attachments
    plugin. Then, we retrieve the HTML with the list of uploaded files using the `wqwpf_product_file_list` function. The
    implementation of this function is similar to the one we used in post attachments
    plugin in [Chapter 4](6bc0e5d5-b12d-4710-ac11-a600af054efa.xhtml), *Building Custom
    Modules with Plugin Development*. Therefore, we are not going to include and discuss
    the source code. You can find the implementation of this function within the source
    codes for this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we return the output as a JSON-encoded array with a message, status,
    and the HTML for the list of uploaded files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Displaying uploaded files in products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last section, we displayed the list of files in the product edit screen
    and updated it each time we uploaded a new file using AJAX. Now, we need to complete
    the implementation by displaying the files list in the frontend product page as
    a new tab. We already used a common function to generate the list of files for
    a product, and hence it''s just a matter of using it within a product page tab.
    Let''s use the following code to display the file list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: WooCommerce provides a filter called `woocommerce_product_tabs` to add, modify,
    or remove tabs from the frontend product page. The existing tab details are passed
    as a parameter to this function. So, we add a new tab by using a unique key and
    assigning necessary settings. We have used a **Title** for the tab and custom
    callback function called `wqwpf_product_files_tab_content`. The **priority** setting
    defines the order of the tab within the product page. You can check the priority
    of existing tabs by executing a `var_dump` on the `$tabs` array and assigning
    the priority based on where you want to display the tab. Inside the callback function,
    we use the global `$post` object to retrieve the post ID and pass it to the `wqwpf_product_file_list`
    function to generate the files list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have completed the customization and added a new feature for uploading
    and displaying files for WooCommerce products. The product page will look similar
    to the following screen with the product files tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b437d1d-51c9-49eb-9541-a0ae7bd9ec59.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we have omitted the code and explanation for file downloading,
    uploading, and listing, as we used the same functions of the post attachments
    plugin, with minor modification. Make sure to check the implementation of these
    functions within the source code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating multiple plugins for a continuous workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of building plugins is to provide independent feature or set of
    features as a reusable module. So, most third-party plugins are designed to provide
    solutions to a specific feature and related sub-features. We rarely find third-party
    plugins that can power an entire system. BuddyPress is one of the few plugins
    that offers many of the features of a complete system such as a social network.
    In the previous section, we discussed the need for customizing third-party plugins.
    Here, we have to move one step further by understanding how to customize and integrate
    multiple plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Types of plugin integrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can integrate two plugins or more using the WordPress hook system. However,
    there are different types of integrations depending on who is responsible for
    providing the integration. It's important to understand these integration types
    in order avoid or control the risks, when the integrated plugins change behavior.
    Let's take a look at the types of plugin integrations.
  prefs: []
  type: TYPE_NORMAL
- en: Custom integrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This method is used when there are no integrations between the two plugins.
    Therefore, each plugin is not aware of the existence of other plugin. This is
    the most common scenario in WordPress development, as we rarely find the necessary
    plugins integrating with the other plugins needed for our site. In such a scenario,
    we have to create an addon plugin by implementing the integrations with necessary
    plugins. In this process, we use the existing hooks or functions of the necessary
    plugins and connect them to work together for our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: There is a major limitation in this method as connecting more and more plugins
    increases the risks of breaking the site functionality. We have no control over
    the integrated plugins as they are developed by third-party developers. So, when
    implementing such integrations, we have to use the same plugin versions without
    updating, or be prepared to check the integration and apply necessary fixes on
    updates of each plugin. You will see many sites using custom integrations with
    fixed versions of the integrated plugins. This is not the ideal process as keeping
    fixed versions of plugins increases security risks. Therefore, you should develop
    integrations with minimum dependency with each plugin, and be prepared to alter
    the integration when necessary to be compatible with plugin updates.
  prefs: []
  type: TYPE_NORMAL
- en: One-sided integrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this method, one of the two plugins provides an integration with the other
    plugin. However, the second plugin is not aware of the existence or integration
    of the first plugin. We can find many existing plugins with this type of integration.
    The integration is implemented within one of the plugins or an addon of the plugin.
    Let''s take a look at some of the popular plugins with one-sided integrations
    with other plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MyCred integration with WooCommerce**: MyCred is a point management system
    for WordPress and integrates with WooCommerce through the **Gateway** addon. The
    MyCred team is responsible for providing the integration and hence they will make
    sure the integration works with WooCommerce version updates. You can find more
    details about the integration at [https://mycred.me/add-ons/gateway/](https://mycred.me/add-ons/gateway/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy Digital Downloads integration with Gravity Forms**: Easy Digital Downloads
    is a plugin used to sell digital products. This plugin integrates with the popular
    **Gravity Forms** plugin through an addon called **Gravity Forms checkout**. The
    Easy Digital Downloads team is responsible for providing the integration and hence
    they will make sure the integration works with Gravity Forms version updates.
    You can find more details about the integration at [https://easydigitaldownloads.com/downloads/gravity-forms-checkout/](https://easydigitaldownloads.com/downloads/gravity-forms-checkout/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User Profiles Made Easy integration with WooCommerce**: User Profiles Made
    Easy is a frontend profile management system and provides a built-in integration
    with WooCommerce. In the previous two examples, integration was provided by a
    separate addon. In this scenario, integration is built into the plugin. The User
    Profiles Made Easy team is responsible for providing the integration, and hence
    they will make sure the integration works with WooCommerce version updates. You
    can find more details about the integration at [https://codecanyon.net/item/user-profiles-made-easy-wordpress-plugin/4109874](https://codecanyon.net/item/user-profiles-made-easy-wordpress-plugin/4109874).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As developers, we can use these kind of existing integrations with minor modifications.
    So, we can spend less time and avoid any risks compared to custom integration
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Mutual integrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this method, integration is supported by both plugins. Therefore, both plugins
    are aware of the existence and integration of the other plugin. Usually, this
    is implemented through functions or APIs designed for the other plugins. The developers
    from both plugins agrees to keep the features in way that integrates with the
    other plugin. As developers, we can directly use these integrations as the functionality
    is tested by both plugins. The risk of such integrations is quite low and requires
    less time.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at three common methods for integrations. We rarely find plugins with
    mutual integrations as it requires lot of effort from the developers of the two
    plugins. So, when a need for integration occurs, we have to check the availability
    of one-sided integrations, mainly through addons. You should always use the available
    integrations as they are used and tested by many users of that plugin. In scenarios
    where we can't find existing integrations, we have to use the custom integration
    process. In the custom integration process, we have to plan the solutions by reducing
    the impact on both plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations in custom plugin integrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of integrating plugins can be as simple as a few lines of code or
    as complex as thousands of lines of code. There are no recommended processes or
    techniques for integrating plugins. We have to find ways to connect plugins without
    affecting the other features or breaking the functionality on version upgrades.
    Let's take a look at some of the important things to be considered in the custom
    integration process.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the feasibility of integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the first step, where we explore the available hooks for integration.
    In the *Creating addons* section, we identified the limitations of the post attachments
    plugin due to lack of actions and filters. We might face similar situations in
    plugins integration, where the second plugin doesn't provide necessary hooks to
    integrate with the features of the first plugin. In such a case, our only option
    is to add custom hooks to one of the plugins. Even though it's not recommended
    and difficult to manage, developers use this method when there are no other alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that we use a frontend login plugin, and a content restriction plugin
    with a private page for each user. By default, the login plugin redirects the
    user to the backend profile after login. So, our integration requires us to redirect
    the user to the private page after login. We need to have at least one hook in
    the login plugin for modifying the redirection. Let''s assume we have the following
    filter in the login plugin to change the redirection URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can use the following code in the content restriction plugin to modify
    the URL and integrate the two plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The integration was possible due to the availability of the login redirect hook.
    So, we have to make sure necessary hooks exists and integration is feasible between
    two plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying exact data changes and hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the integration process, usually we use the data from the first plugin in
    the second plugin or execute a certain feature of the second plugin when an event
    occurred in first plugin. The main problem is the consistency and intergrity of
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Assume that we use a frontend profile management plugin to capture and display
    the user details using custom fields. We also use WooCommerce to capture payments
    for the members. Let's say we want to integrate the two plugins to synchronize
    the user profile data with WooCommerce customer data. So, when updating profile
    details from the profile management plugin, we need to also update the WooCommerce
    customer data, and vice-versa. If the two plugins use different data formats for
    the same field, there is going to be a conflict. In such situations, we have to
    convert the data when switching between the two plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the use of proper execution of hooks is important in integrations. Assume
    we have a user registrations plugin and a user groups plugin. The integration
    requires us to assign the user to a group after the registration process. Usually,
    we look for a function in the groups plugin that allows us to directly add users
    to a group by passing the necessary data. Then, we integrate the two plugins by
    using the registration success hook of the first plugin and executing the add
    user to group function within the hook. The main integration process works. But,
    the groups plugin may have other hooks that get executed after adding a user to
    a group. Such hooks may include features to send emails, assign group permissions,
    and so on. So, the overall process fails, even though the main integration works
    without issues. Therefore, it's important to consider all the hooks related to
    the integration process as well as data formats.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the impact with other plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, we use at least a few plugins in every website, and some sites may
    contain dozens of plugins. Some of these plugins may have existing integrations
    between them. Let's assume we need to implement a new feature by integrating two
    or more plugins. In such scenarios, it's not sufficient to check the data, hooks,
    and integration points of those two plugins. We have to also check the impact
    by other existing plugins, or the impact on other existing plugins not involved
    in the integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the same scenario discussed in the *Checking the feasibility
    of integrations* section. We integrated two plugins to redirect the user to a
    private page of the content restrictions plugin after login. Assume we have a
    third plugin not involved in the integration. This plugin is used to change the
    login redirection URL based on user role. Consider the following integration in
    the third plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The URL modification hook in user role based redirection plugin has a higher
    priority value, and hence is executed later than the hook used in the previous
    scenario. Therefore, the logged-in user will be redirected to the user role specific
    page, instead of the private page of the content restrictions plugin. So, our
    integration completely falls apart.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can prevent such issues by considering how other plugins use the data, and
    the hooks related to our integration process. In this scenario, we could prevent
    this situation by using a higher priority value for the hook in the first scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This line of code is executed after the filter code in the role-based redirection
    plugin, and hence our integration works without issues. However, now you must
    also check how our integration affects the functionality of the role-based redirection
    plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing multiple plugin integrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up to this point, we looked at the methods used in plugin integrations and
    important considerations. Now, it''s time to integrate a few plugins to understand
    their practical usage. We are going to integrate three popular plugins to illustrate
    the process. Let''s identify the plugins used for this integration and their functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WooCommerce**: This is the most popular eCommerce plugin. The main functionality
    is selling physical and digital goods. These days, it''s also being used for selling
    services, bookings, and memberships by modifying the features through addons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MyCred**: This is a point management plugin where you can allow users to
    earn points by doing various tasks in a site such as commenting, viewing content,
    publishing content, registering on the site, and so on. Then, you can reward these
    users by providing benefits with the use of these points.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BuddyPress**: This is a plugin used to build online communities in your site.
    The default features include user management, groups, messages, activities, friends,
    and notifications. Many people use this plugin to build mini-social networks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can take a look at the requirement for integrating these three plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Assume that we have a point system in our site using **MyCred**. Users can earn
    points through various tasks and spend those points to get wide range of benefits.
    In this scenario, we assume users only get points by purchasing products from
    the **WooCommerce** store. The points will be given for *completed orders* based
    on order value. Once the user reaches a specific number of points, the user will
    be added automatically to a private **BuddyPress** group.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting the implementation, we need to create a new plugin called **WPQPI
    Plugin Integrations** in a new plugin directory called `wpquick-plugin-integrations`.
    The process for creating the main file and using header comments to define the
    plugin will be the same as previous scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning points for completed orders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have to start the implementation by connecting WooCommerce and MyCred plugins
    to award points for completed orders. First, we need to find the ways for tracking
    the completion of a WooCommerce order. The simplest way is to use a search engine
    to check the availability of order complete hook, or go through the documentation
    of the WooCommerce plugin. We can find an action called `woocommerce_order_status_completed`
    for handling tasks after the completion of order. Let''s take a look at the implementation
    of order complete hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We can define the action using the `add_action` function with a specific callback
    function. The order ID is passed as a parameter to this function, and hence we
    can execute any tasks based on order details. The next task is to identify how
    we can add points in MyCred using custom code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have few tasks to be implemented before we can add points to orders. First,
    we have to add a new hook to enable points for WooCommerce orders. MyCred points
    are added through built-in and custom hooks. The available hooks can be viewed
    by visiting the Points | Hooks section in WordPress admin. You need to go through
    the MyCred documentation to find the necessary hooks for adding custom MyCred
    hooks. So, let''s create a new hook for enabling points for WooCommerce orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `mycred_setup_hooks` filter is used to add custom hooks to MyCred, or remove
    existing hooks. In this scenario, we add a new hook called `wpqpi_woo_purchase`
    for awarding points for WooCommerce purchases. The array defines the name of the
    hook, the description, and the PHP class to implement the point awarding procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added a custom class called `WPQPI_WooCommerce_Hooks`. Once this code
    is added, you will see a new hook named Points for WooCommerce Purchases in the
    Available Hooks section. You can drag the hook to Active Hooks section to make
    it work, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c13b2308-d53a-441c-8f50-aef6df6aa731.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to implement the class to award points for WooCommerce purchases.
    So, we need to implement the `mycred_load_hooks` action to load the hook set up
    in the previous section. Let''s take a look at the implementation of the `WPQPI_WooCommerce_Hooks`
    class inside the `mycred_load_hooks` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the hook, we just define the class by extending the `myCRED_Hook` core
    class of MyCred plugin. Then, we add the class constructor with unique ID and
    default settings. The settings include the number of points awarded by default
    and the text for the log entry of awarding points. This class executes a built-in
    function called `run`, while loading the hooks. This will be the point of integration
    where we define the WooCommerce order completed hook. Let''s see how we can implement
    the `run` function after the class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define any number of actions in the loading process of the MyCred hook
    created earlier. Here, we have the `woocommerce_order_status_completed` action
    and the callback function ready to be executed on successful orders. Now, we can
    move into the process of awarding points by implementing the `wpqpi_payment_complete`
    function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: First, we use the `$order_id` parameter to load the order details using the
    `wc_get_order` function. Next, we get the order total by calling the `get_total`
    function on the `$order` object, and divide it by 10 to generate the number of
    MyCred points for the order. Next, we get the ID of the user who purchased the
    products by using the `get_user` function on the `$order` object. Finally, we
    call the MyCred `add_creds` function to add the points to the user for the order.
  prefs: []
  type: TYPE_NORMAL
- en: The `add_creds` function has three required parameters and some optional parameters.
    The first three parameters are used respectively for the reference ID, user ID,
    and number of points to be awarded. The other parameters are not important for
    the scenario used in this book. Now, the two plugins are integrated to award MyCred
    points to the user on successful WooCommerce order completion. We have used an
    event of one plugin to integrate with another plugin by modifying the data of
    the second plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Adding users to BuddyPress private groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we completed the first part of the integration with
    MyCred and WooCommerce. The next step is to complete the integration by connecting
    MyCred with BuddyPress groups. As we discussed, the requirement is to assign users
    to a BuddyPress private group once they reach specific number of MyCred points.
    So, we have to look for a way to add users to a BuddyPress group. We can either
    check for the documentation or use a search engine to find the appropriate implementation.
    BuddPress provides a function called `groups_join_group` to add users into a group.
    Let''s use that function to modify the `wpqpi_payment_complete` function and add
    users to groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: First, we use the built-in `mycred_get_users_balance` function to receive the
    available points of the user. Then, we call the BuddyPress `groups_join_group`
    function with the group ID and user ID once the user balance has reached the limit
    we specified.
  prefs: []
  type: TYPE_NORMAL
- en: We have simplified the code in this scenario to illustrate the process of plugin
    integration. In an ideal scenario, we have to implement a lot more permission
    checks before we add a user to a group, and points to a user.
  prefs: []
  type: TYPE_NORMAL
- en: In this implementation, we only award points for WooCommerce orders, and the
    user can only use points to join the group. Therefore, we can implement the points
    checking process within the same function. When we award points for multiple tasks,
    this balance checking code needs to be implemented in all of these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have completed the integration and made three plugins work together
    for our requirements. Similarly, you can use existing hooks and functions to connect
    the necessary plugins for your requirements. However, I strongly recommend not
    to custom-integrate a large number of plugins in a single site, as it's hard to
    manage on plugin updates.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of customizing and extending plugins is crucial for building websites
    in a rapid process. So, we started extending plugins by creating an addon for
    the post attachments plugin developed in the previous chapter. Next, we looked
    at the WordPress core action execution process and its importance using sample
    scenarios. Then, we moved into the process of using various techniques for customizing
    plugins, while modifying WooCommerce product features. Finally, we looked at the
    different types of integrations between plugins, while integrating popular plugins
    to understand the process.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](e452b581-f38d-4c95-8a41-0c9a54b26a57.xhtml), *Practical Usage
    of WordPress APIs*, we will be exploring the built-in WordPress APIs, while learning
    how to use them practically in plugin development.
  prefs: []
  type: TYPE_NORMAL
