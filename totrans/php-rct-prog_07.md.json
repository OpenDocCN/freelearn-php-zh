["```php\n// filter_01.php \n$loop = new StreamSelectLoop(); \n$scheduler = new EventLoopScheduler($loop); \n$lastTimestamp = 0; \n\nObservable::interval(150, $scheduler) \n    ->filter(function() use (&$lastTimestamp) { \n        if ($lastTimestamp + 1 <= microtime(true)) { \n            $lastTimestamp = microtime(true); \n            return true; \n        } else { \n            return false; \n        } \n    }) \n    ->subscribe(new DebugSubject());\n\n$loop->run(); \n\n```", "```php\n$ php filter_01.php \n14:51:01 [] onNext: 0 (integer)\n14:51:02 [] onNext: 7 (integer)\n14:51:03 [] onNext: 14 (integer)\n14:51:04 [] onNext: 21 (integer)\n...\n\n```", "```php\n// ThrottleTimeOperator.php \nclass ThrottleTimeOperator implements OperatorInterface { \n  private $duration; \n  private $lastTimestamp = 0; \n\n  public function __construct($duration) { \n    $this->duration = $duration; \n  } \n\n  public function __invoke($observable, $observer, $sched=null) { \n    $disposable = $observable->filter(function() use ($observer) { \n      $now = microtime(true) * 1000; \n      if ($this->lastTimestamp + $this->duration <= $now) { \n        $this->lastTimestamp = $now; \n        return true; \n      } else { \n        return false; \n      } \n    })->subscribe($observer); \n\n    return $disposable; \n  } \n} \n\n```", "```php\n// throttle_time_01.php \n$loop = new StreamSelectLoop(); \n$scheduler = new EventLoopScheduler($loop); \n$lastTimestamp = 0; \n\nObservable::interval(150, $scheduler) \n    ->lift(function()  { \n        return new ThrottleTimeOperator(1000); \n    }) \n    ->subscribe(new DebugSubject()); \n\n$loop->run(); \n\n```", "```php\n// buffer_with_count_01.php \n$loop = new StreamSelectLoop(); \n$scheduler = new EventLoopScheduler($loop); \n$lastTimestamp = 0; \n\nObservable::interval(500, $scheduler) \n    ->bufferWithCount(4) \n    ->subscribe(new DebugSubject()); \n\n$loop->run(); \n\n```", "```php\n$ php buffer_with_count_01.php \n15:24:24 [] onNext: [0,1,2,3] (array)\n15:24:26 [] onNext: [4,5,6,7] (array)\n15:24:28 [] onNext: [8,9,10,11] (array)\n15:24:30 [] onNext: [12,13,14,15] (array)\n\n```", "```php\n// ProcessObservable.php \nclass ProcessObservable extends Observable { \n  private $cmd; \n  private $pidFile; \n\n  public function __construct($cmd, $pidFile = null) { \n    $this->cmd = $cmd; \n    $this->pidFile = $pidFile; \n  } \n\n  public function subscribe($observer, $scheduler = null) { \n    $process = new Process($this->cmd); \n    $process->start(); \n\n    $pid = $process->getPid(); \n    if ($this->pidFile) { \n      file_put_contents($this->pidFile, $pid); \n    } \n\n    $disposable = new CompositeDisposable(); \n    $autoObs = new AutoDetachObserver($observer); \n    $autoObs->setDisposable($disposable); \n\n    $cancelDisp = $schedulerâ†’schedulePeriodic(function() \n          use ($autoObs, $process, $pid, &$cancelDisp) { \n      if ($process->isRunning()) { \n        $output = $process->getIncrementalOutput(); \n        if ($output) { \n          $autoObs->onNext($output); \n        } \n      } elseif ($process->getExitCode() === 0) { \n        $output = $process->getIncrementalOutput(); \n        if ($output) { \n          $autoObs->onNext($output); \n        } \n        $autoObs->onCompleted(); \n      } else { \n        $e = new Exception($process->getExitCodeText()); \n        $autoObs->onError($e); \n      } \n    }, 0, 200); \n\n    $disposable->add($cancelDisp); \n    $disposable->add(new CallbackDisposable( \n          function() use ($process) { \n\n      $process->stop(1, SIGTERM); \n      if ($this->pidFile) { \n        unlink($this->pidFile); \n      } \n    })); \n\n    return $disposable; \n  } \n} \n\n```", "```php\n// sleep.php \n$name = $argv[1]; \n$time = intval($argv[2]); \n$elapsed = 0; \n\nwhile ($elapsed < $time) { \n    sleep(1); \n    $elapsed++; \n    printf(\"$name: $elapsed\\n\"); \n} \n\n```", "```php\n// process_observable_01.php \n$loop = new React\\EventLoop\\StreamSelectLoop(); \n$scheduler = new Rx\\Scheduler\\EventLoopScheduler($loop); \n\n$pid = tempnam(sys_get_temp_dir(), 'pid_proc1'); \n$obs = new ProcessObservable('php sleep.php proc1 3', $pid); \n$obs->subscribe(new DebugSubject(), $scheduler); \n\n$loop->run(); \n\n```", "```php\n$ php process_observable_01.php\n11:59:05 [] onNext: proc1: 1\n (string)\n11:59:06 [] onNext: proc1: 2\n (string)\n11:59:07 [] onNext: proc1: 3\n (string)\n11:59:07 [] onCompleted\n\n```", "```php\n// ServerManager.php \nclass ServerManagerCommand extends Command { \n  private $scheduler; \n  private $loop; \n  private $unixSocketFile; \n  private $output; \n  private $commands = [ \n    'n' => 'spawnNewServer', \n    'q' => 'quit', \n  ]; \n\n  protected function configure() { \n    $this->setName('manager'); \n    $this->addArgument('socket_file',InputOption::VALUE_REQUIRED); \n  } \n\n  protected function execute($input, $output) { \n    $this->output = $output; \n    $this->unixSocketFile = $input->getArgument('socket_file'); \n    @mkdir(dirname($this->unixSocketFile), 0766, true); \n\n    $loop = new React\\EventLoop\\StreamSelectLoop(); \n    $this->loop = $loop; \n    $this->scheduler = new EventLoopScheduler($this->loop); \n\n    $subject = new Subject(); \n    $stdin = $subject->asObservable(); \n\n    $stdinRes = fopen('php://stdin', 'r'); \n    $loop->addReadStream($stdinRes, function($s) use ($subject) { \n      $str = trim(fgets($s, 1024)); \n      $subject->onNext($str); \n    }); \n\n    foreach ($this->commands as $pattern => $method) { \n      $stdin \n        ->filter(function($string) use ($pattern) { \n          return $pattern == $string; \n        }) \n        ->subscribeCallback(function($value) use ($method) { \n          $this->$method($value); \n        }); \n    } \n\n    // ... We'll continue here later \n\n    $this->loop->run(); \n  } \n} \n\n$command = new ServerManagerCommand(); \n$application = new Application(); \n$application->add($command); \n$application->setDefaultCommand($command->getName()); \n$application->run(); \n\n```", "```php\nclass ServerManager extends Command { \n  /** @var DisposableInterface[] */ \n  private $processes = []; \n\n  // ... \n\n  private function spawnNewServer() { \n    $port = $this->startPort++; \n    $cmd = 'php GameServer.php game-server ' \n      . $this->unixSocketFile . ' ' . $port; \n    $cmd = escapeshellcmd($cmd); \n    $process = new ProcessObservable($cmd); \n    $this->output->writeln('Spawning process on port '.$port); \n\n    $this->processes[$port] = $process->subscribeCallback( \n      null, \n      function($e) use ($port) { \n        $msg = sprintf('%d: Error \"%s\"', $port, $e); \n        $this->output->writeln($msg); \n      }, \n      function() use ($port) { \n        $this->output->writeln(sprintf('%d: Ended', $port)); \n      }, $this->scheduler \n    ); \n  } \n\n  private function quit() { \n    foreach ($this->servers as $server) { \n      $server->close(); \n    } \n    foreach ($this->processes as $process) { \n      $process->dispose(); \n    } \n    $this->loop->stop(); \n  } \n} \n\n```", "```php\n// GameServer.php \nclass GameServer extends Command { \n  /** @var StreamObservable */ \n  private $streamObservable; \n\n  protected function configure() { \n    $this->setName('game-server'); \n    $this->addArgument('socket_file',InputOption::VALUE_REQUIRED); \n    $this->addArgument('port', InputOption::VALUE_REQUIRED); \n  } \n\n  protected function execute($input, $output) { \n    $file = $input->getArgument('socket_file'); \n    $port = $input->getArgument('port'); \n\n    $client = stream_socket_client(\"unix://\".$file, $errno, $err); \n    stream_set_blocking($client, 0); \n\n    $loop = new React\\EventLoop\\StreamSelectLoop(); \n    $this->streamObservable = new StreamObservable($client,$loop); \n    $this->streamObservable->send('init', ['port' => $port]); \n    $this->streamObservable->send('status', 'ready'); \n    $scheduler = new EventLoopScheduler($loop); \n\n    Observable::interval(500, $scheduler) \n      ->subscribeCallback(function($counter) { \n        $this->streamObservable->send('status', $counter); \n      }); \n\n    $loop->run(); \n    // WebSocket server will go here... \n  } \n} \n\n```", "```php\n//  StreamObservable.php \nclass StreamObservable extends Observable { \n  protected $stream; \n  protected $subject; \n  protected $loop; \n\n  public function __construct($stream, LoopInterface $loop) { \n    $this->stream = $stream; \n    $this->loop = $loop; \n    $this->subject = new Subject(); \n\n    $this->loop->addReadStream($this->stream, function ($stream) { \n      $data = trim(fgets($stream)); \n      $this->subject->onNext($data); \n    }); \n  } \n\n  public function subscribe($observer, $scheduler = null) { \n    return $this->subject->subscribe($observer); \n  } \n\n  public function send($type, $data) { \n    $message = ['type' => $type, 'data' => $data]; \n    fwrite($this->stream, json_encode($message) . \"\\n\"); \n  } \n\n  public function close() { \n    $this->loop->removeReadStream($this->stream); \n    fclose($this->stream); \n    $this->subject->onCompleted(); \n  } \n} \n\n```", "```php\nclass ServerManager extends Command { \n  // ... \n  private $statusSubject; \n  private $servers = []; \n\n  protected function execute($input, $output) { \n    // ... \n    @unlink($this->unixSocketFile); \n    $address = \"unix://\" . $this->unixSocketFile; \n    $server = stream_socket_server($address, $errno, $errMsg); \n    stream_set_blocking($server, 0); \n\n    $this->loop->addReadStream($server, function() use ($server) { \n      $client = stream_socket_accept($server); \n      $server = new GameServerStreamEndpoint($client,$this->loop); \n\n      $server->onInit()->then(function($port) use ($server) { \n        $msg = sprintf('Sub-process %d initialized', $port); \n        $this->output->writeln($msg); \n        $this->addServer($port, $server); \n      }); \n    }); \n\n    $this->statusSubject = new Subject(); \n    // ... We'll continue here later \n  } \n\n  private function addServer($port, $server) { \n    $this->servers[$port] = $server; \n    $this->statusSubject->onNext(null); \n  } \n} \n\n```", "```php\n// GameServerStreamEndpoint.php \nclass GameServerStreamEndpoint { \n  private $stream; \n  private $initDeferred; \n  private $status; \n\n  public function __construct($stream, LoopInterface $loop) { \n    $this->stream = new StreamObservable($stream, $loop); \n    $this->initDeferred = new Deferred(); \n\n    $decodedMessage = $this->stream \n      ->lift(function() { \n        return new JSONDecodeOperator(); \n      }); \n\n    $unsubscribe = $decodedMessage \n      ->filter(function($message) { \n        return $message['type'] == 'init'; \n      }) \n      ->pluck('data') \n      ->subscribeCallback(function($data) use (&$unsubscribe) { \n        $this->initDeferred->resolve($data['port']); \n        $unsubscribe->dispose(); \n      }); \n\n    $this->status = $decodedMessage \n      ->filter(function($message) { \n        return $message['type'] == 'status'; \n      }) \n      ->pluck('data') \n      ->multicast(new ReplaySubject(1)); \n    $this->status->connect(); \n  } \n\n  public function getStatus() { \n    return $this->status; \n  } \n\n  public function onInit() { \n    return $this->initDeferred->promise(); \n  } \n\n  public function close() { \n    return $this->stream->close(); \n  } \n} \n\n```", "```php\n// switch_latest_01.php  \n$range = [1]; \n$loop = new StreamSelectLoop(); \n$scheduler = new EventLoopScheduler($loop); \n\n$newServerTrigger = Observable::interval(1000, $scheduler); \n$statusUpdate = Observable::interval(600, $scheduler)->publish(); \n$statusUpdate->connect(); // Make it hot Observable \n\n$newServerTrigger \n    ->map(function() use (&$range, $statusUpdate) { \n        $range[] = count($range) + 1; \n        $observables = array_map(function($val) { \n            return Observable::just($val); \n        }, $range); \n\n        return $statusUpdate \n            ->combineLatest($observables, function() { \n                $values = func_get_args(); \n                array_shift($values); \n                return $values; \n            }); \n    }) \n    ->switchLatest() \n    ->take(8) \n    ->doOnCompleted(function() use ($loop) { \n        $loop->stop(); \n    }) \n    ->subscribe(new DebugSubject()); \n\n$loop->run(); \n\n```", "```php\n$ php switch_latest_01.php \n12:18:32 [] onNext: [1,2] (array)\n12:18:32 [] onNext: [1,2] (array)\n12:18:33 [] onNext: [1,2,3] (array)\n12:18:34 [] onNext: [1,2,3] (array)\n12:18:34 [] onNext: [1,2,3,4] (array)\n12:18:35 [] onNext: [1,2,3,4,5] (array)\n12:19:25 [] onNext: [1,2,3,4,5] (array)\n12:19:26 [] onNext: [1,2,3,4,5,6] (array)\n22:54:16 [] onCompleted\n\n```", "```php\nclass ServerManager extends Command { \n  // ... \n  protected function execute($input, $output) { \n    // ... \n    $this->statusSubject \n      ->map(function() { \n        $observables = array_map(function($server) { \n          /** @var GameServerStreamEndpoint $server */ \n          return $server->getStatus(); \n        }, $this->servers); \n\n        return Observable::just(true) \n          ->combineLatest($observables, function($array) { \n            $values = func_get_args(); \n            array_shift($values); \n            return $values; \n          }); \n      }) \n      ->switchLatest() \n      ->map(function($statuses) { \n        $updatedStatuses = []; \n        $ports = array_keys($this->servers); \n        foreach ($statuses as $index => $status) { \n          $updatedStatuses[$ports[$index]] = $status; \n        } \n        return $updatedStatuses; \n      }) \n      ->subscribeCallback(function($statuses) use ($output) { \n        $output->write(sprintf(\"\\033\\143\")); // clean screen \n        foreach ($statuses as $port => $status) { \n          $str = sprintf(\"%d: %s\", $port, $status); \n          $output->writeln($str); \n        } \n      }); \n\n    // ... \n  } \n} \n\n```", "```php\n$ php ServerManager.php manager ./var/server.sock\nListening on socket ./var/server.sock\nRunning ...\n\n```", "```php\n8888: 28\n8889: 15\n8890: 14\n8891: ready\n\n```", "```php\n$ composer require cboden/ratchet\n\n```", "```php\n// ChatServer.php \nuse Ratchet\\MessageComponentInterface; \nuse Ratchet\\ConnectionInterface; \n\nclass ChatServer implements MessageComponentInterface { \n  private $connections; \n  private $history = []; \n  private $subject; \n\n  public function __construct() { \n    $this->subject = new Subject(); \n  } \n\n  public function onOpen(ConnectionInterface $conn) { \n    $this->connections[] = $conn; \n    foreach (array_slice($this->history, -5, 5) as $msg) { \n      $conn->send($msg); \n    } \n    $this->subject->onNext(null); \n  } \n\n  public function onMessage(ConnectionInterface $from, $msg) { \n    $this->history[] = $msg; \n    foreach ($this->connections as $conn) { \n      if ($from !== $conn) { \n        $conn->send($msg); \n      } \n    } \n    $this->subject->onNext(null); \n  } \n\n  public function onClose(ConnectionInterface $conn) { \n    foreach ($this->connections as $index => $client) { \n      if ($conn !== $client) { \n        unset($this->connections[$index]); \n      } \n    } \n    $this->subject->onNext(null); \n  } \n\n  public function onError(ConnectionInterface $conn, $e) { \n    $this->onClose($conn); \n  } \n} \n\n```", "```php\nclass ChatServer implements MessageComponentInterface { \n  // ... \n  public function getObservable() { \n    return $this->subject \n      ->map(function() { \n        return sprintf('clients: %d, messages: %d', \n          $this->getClientsCount(), \n          $this->getChatHistoryCount() \n        ); \n      }); \n  } \n\n  private function getClientsCount() { \n    return count($this->connections); \n  } \n\n  private function getChatHistoryCount() { \n    return count($this->history); \n  } \n} \n\n```", "```php\nclass GameServer extends Command { \n  // ... \n  protected function execute($input, $output) { \n    // ... \n    $webSocketServer = new ChatServer(); \n    $socket = new Reactor($loop); \n    $socket->listen($port, '0.0.0.0'); \n    $server = new IoServer( \n      new HttpServer(new WsServer($webSocketServer)), \n      $socket, \n      $loop \n    ); \n\n    $webSocketServer->getObservable() \n      ->subscribeCallback(function($status) { \n        $this->streamObservable->send('status', $status); \n      }); \n\n    $server->run(); \n  } \n} \n\n```", "```php\nObservable::interval(500, $scheduler) \n  ->lift(function() { \n    return new ThrottleTimeOperator(2000); \n  }) \n  ->subscribeCallback(function($counter) { \n    $this->streamObservable->send('status', $counter); \n  }); \n\n```", "```php\n$ composer require ratchet/pawl 0.2.2 \n\n```", "```php\n// GameClient.php \nuse function Ratchet\\Client\\connect; \n\nclass GameClient extends Command { \n  protected function configure() { \n    $this->setName('chat-client'); \n    $this->addArgument('port', InputArgument::REQUIRED); \n    $this->addArgument('address', InputArgument::OPTIONAL, \n      '', '127.0.0.1'); \n  } \n\n  protected function execute($input, $output) { \n    $port = $input->getArgument('port'); \n    $address = $input->getArgument('address'); \n\n    $stdin = fopen('php://stdin', 'r'); \n    $loop = new StreamSelectLoop(); \n\n    connect('ws://' . $address . ':' . $port, [], [], $loop) \n      ->then(function($conn) use ($loop, $stdin, $output) { \n        $loop->addReadStream($stdin,  \n          function($stream) use ($conn, $output) { \n            $str = trim(fgets($stream, 1024)); \n            $conn->send($str); \n            $output->writeln(\"> ${str}\"); \n          }); \n\n          $conn->on('message', function($str) use ($conn,$output){ \n            $output->writeln(\"< ${str}\"); \n          }); \n        }, function ($e) use ($output) { \n            $msg = \"Could not connect: {$e->getMessage()}\"; \n            $output->writeln($msg); \n        }); \n  } \n} \n\n```", "```php\n$ php GameClient.php chat-client 8890\nHello, World!\n> Hello, World!\n< Test!\n\n```", "```php\n8888: ready\n8889: clients: 1, messages: 0\n8890: clients: 1, messages: 2\n8891: ready\n\n```"]