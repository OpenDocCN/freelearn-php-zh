- en: Chapter 5. Using the Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Dependency injection** is a software design pattern via which one or more
    dependencies are injected or passed by reference into an object. What this exactly
    means on a practical level is shown in the following two simple examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, you will see a simplified PHP example, where the `$database` object is
    created in the `getTotalCustomers` method. This means that the dependency on the
    database object is being locked in an object instance method. This makes for tight
    coupling, which has several disadvantages such as reduced reusability and a possible
    system-wide effect caused by changes made to some parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'A solution to this problem is to avoid methods with these sorts of dependencies
    by injecting a dependency into a method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, a `$database` object is passed (injected) into a method. That's all that
    dependency injection is—a simple concept that makes code loosely coupled. While
    the concept is simple, it may not be easy to implement it across large platforms
    such as Magento.
  prefs: []
  type: TYPE_NORMAL
- en: 'Magento has its own object manager and dependency injection mechanism that
    we will soon look at in detail in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: The object manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring class preferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using virtual types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To follow and test the code examples given in the following sections, we can
    use the code available at [https://github.com/ajzele/B05032-Foggyline_Di](https://github.com/ajzele/B05032-Foggyline_Di).
    To install it, we simply need to download it and put it in the `app/code/Foggyline/Di`
    directory. Then, run the following set of commands on the console within Magento''s
    root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The last command can be used repeatedly when testing the snippets presented
    in the following section. When `php bin/magento foggy:di` is run, it will run
    the code within the `execute` method in the `DiTestCommand` class. Therefore,
    we can use the `__construct` and `execute` methods from within the `DiTestCommand`
    class and the `di.xml` file itself as a playground for **DI**.
  prefs: []
  type: TYPE_NORMAL
- en: The object manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The initializing of objects in Magento is done via what is called the **object
    manager**. The object manager itself is an instance of the `Magento\Framework\ObjectManager\ObjectManager`
    class that implements the `Magento\Framework\ObjectManagerInterface` class. The
    `ObjectManager` class defines the following three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create($type, array $arguments = [])`: This creates a new object instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get($type)`: This retrieves a cached object instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configure(array $configuration)`: This configures the `di` instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The object manager can instantiate a PHP class, which can be a model, helper,
    or block object. Unless the class that we are working with has already received
    an instance of the object manager, we can receive it by passing `ObjectManagerInterface`
    into the class constructor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually, we don''t have to take care of the constructor parameter''s order
    in Magento. The following example will also enable us to fetch an instance of
    the object manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Though we can still use plain old PHP to instantiate an object such as `$object
    = new \Foggyline\Di\Model\Object()`, by using the object manager, we can take
    advantage of Magento's advanced object features such as automatic constructor
    dependency injection and object proxying.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples of using object manager''s `create` method to create
    new objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are a few examples of using object manager''s `get` method to
    create new objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The object manager's `create` method always returns a new object instance, while
    the `get` method returns a singleton.
  prefs: []
  type: TYPE_NORMAL
- en: Note how some of the string parameters passed to `create` and `get` are actually
    interface names and not strictly class names. We will soon see why this works
    with both class names and interface names. For now, it suffices to say that it
    works because of Magento's dependency injection implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have seen how the object manager has control over the instantiation
    of dependencies. However, by convention, the object manager isn't supposed to
    be used directly in Magento. Rather, it should be used for system-level things
    that bootstrap Magento. We are encouraged to use the module's `etc/di.xml` file
    to instantiate objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dissect one of the existing `di.xml` entries, such as the one found
    under the `vendor/magento/module-admin-notification/etc/adminhtml/di.xml` file
    for the `Magento\Framework\Notification\MessageList` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, what this means is that whenever an instance of `Magento\Framework\Notification\MessageList`
    is being created, the `messages` parameter is passed on to the constructor. The
    `messages` parameter is being defined as an array, which further consists of other
    string type items. In this case, values of these string type attributes are class
    names, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Magento\Framework\ObjectManager\ObjectManager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Magento\AdminNotification\Model\System\Message\Baseurl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Magento\AdminNotification\Model\System\Message\Security`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Magento\AdminNotification\Model\System\Message\CacheOutdated`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Magento\AdminNotification\Model\System\Message\Media\Synchronization\Error`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Magento\AdminNotification\Model\System\Message\Media\Synchronization\Success`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you now take a look at the constructor of `MessageList`, you will see that
    it is defined in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we modify the `MessageList` constructor as follows, the code will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we change the `MessageList` constructor to one of the following
    variations, the code will fail to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Another variation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The name of the `$messages` parameter in the constructor of the PHP class has
    to exactly match the name of the argument within the arguments' list of `di.xml`.
    The order of parameters in the constructor does not really matter as much as their
    naming.
  prefs: []
  type: TYPE_NORMAL
- en: Looking further in the `MessageList` constructor, if we execute `func_get_args`
    somewhere within it, the list of items within the $messages parameter will match
    and exceed the one shown in `vendor/magento/module-admin-notification/etc/adminhtml/di.xml`.
    This is so because the list is not final, as Magento collects the DI definitions
    from across entire the platform and merges them. So, if another module is modifying
    the `MessageList` type, the modifications will be reflected.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we perform a string search within all the `di.xml` files across the entire
    Magento code base for `<type name="Magento\Framework\Notification\MessageList">`,
    this will yield some additional `di.xml` files that have their own additions to
    the `MessageList` type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: What this means is that the `Magento\Indexer\Model\Message\Invalid` and `Magento\Tax\Model\System\Message\Notifications`
    string items are being added to the `messages` argument and are being made available
    within the `MessageList` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding DI example, we only had the `$messages` parameter defined as
    one argument of the `array` type, and the rest were its array items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a DI example for another type definition. This time,
    it is the one found under the `vendor/magento/module-backend/etc/di.xml` file
    and which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you will see a type with several different arguments passed to the constructor
    of the `Magento\Backend\Model\Url` class. If you now take a look at the constructor
    of the `Url` class, you will see that it is defined in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `__construct` method here clearly has more parameters than what's defined
    in the `di.xml` file. What this means is that the type argument entries in `di.xml`
    do not necessarily cover all the class `__construct` parameters. The arguments
    that are defined in `di.xml` simply impose the types of individual parameters
    defined in the PHP class itself. This works as long as the `di.xml` parameters
    are of the same type or descendants of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we would not pass the class type but interface into the PHP constructor
    and then set the type in `di.xml`. This is where the `type`, `preference`, and
    `virtualType` play a major role in `di.xml`. We have seen the role of `type`.
    Now, let's go ahead and see what `preference` does.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring class preferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great number of Magento's core classes pass interfaces around constructors.
    The benefit of this is that the object manager, with the help of `di.xml`, can
    decide which class to actually instantiate for a given interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine the `Foggyline\Di\Console\Command\DiTestCommand` class with
    a constructor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note how `$myArg1` is type hinted as the `\Foggyline\Di\Model\TestInterface`
    interface. The object manager knows that it needs to look into the entire `di.xml`
    for possible `preference` definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define `preference` within the module''s `di.xml` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are basically saying that when someone asks for an instance of `Foggyline\Di\Model\TestInterface`,
    give it an instance of the `Foggyline\Di\Model\Cart` object. For this to work,
    the `Cart` class has to implement `TestInterface` itself. Once the preference
    definition is in place, `$myArg1` shown in the preceding example becomes an object
    of the `Cart` class.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `preference` element is not reserved only to point out the
    preferred classes for some interfaces. We can use it to set the preferred class
    for some other class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s have a look at the `Foggyline\Di\Console\Command\DiTestCommand`
    class with a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note how `$myArg1` is now type hinted as the `\Foggyline\Di\Model\User` class.
    Like in the previous example, the object manager will look into `di.xml` for possible
    `preference` definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define the `preference` element within the module''s `di.xml` file,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: What this `preference` definition is saying is that whenever an instance of
    the `User` class is requested, pass an instance of the `Cart` object. This will
    work only if the `Cart` class extends from `User`. This is a convenient way of
    rewriting a class, where the class is being passed directly into another class
    constructor in place of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Since the class `__construct` parameters can be type hinted as either classes
    or interfaces and further manipulated via the `di.xml` preference definition,
    a question rises as to what is better. Is it better to use interfaces or specific
    classes? While the answer might not be fully clear, it is always preferable to
    use interfaces to specify the dependencies we are injecting into the system.
  prefs: []
  type: TYPE_NORMAL
- en: Using virtual types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with `type` and `preference`, there is another powerful feature of `di.xml`
    that we can use. The `virtualType` element enables us to define virtual types.
    Creating a virtual type is like creating a subclass of an existing class except
    for the fact that it's done in `di.xml` and not in code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual types** are a way of injecting dependencies into some of the existing
    classes without affecting other classes. To explain this via a practical example,
    let''s take a look at the following virtual type defined in the `app/etc/di.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `virtualType` definition in the preceding example is `Magento\Framework\Message\Session\Storage`,
    which extends from `Magento\Framework\Session\Storage` and overwrites the `namespace`
    parameter to the `message` string value. In `virtualType,` the `name` attribute
    defines the globally unique name of the virtual type, while the `type` attribute
    matches the real PHP class that the virtual type is based on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you look at the `type` definition, you will see that its `storage` argument
    is set to the object of `Magento\Framework\Message\Session\Storage`. The `Session\Storage`
    file is actually a virtual type. This allows `Message\Session` to be customized
    without affecting other classes that also declare a dependency on `Session\Storage`.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual types allow us to effectively change the behavior of a dependency when
    it is used in a specific class.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a look at the object manager and dependency injection,
    which are the foundations of Magento object management. We learned the meaning
    of the `type` and `preference` elements of dependency injection and how to use
    them to manipulate class construct parameters. Though there is much more to be
    said about dependency injection in Magento, the presented information should suffice
    and help us with other aspects of Magento.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will extend our journey into `di.xml` via the concept
    of plugins.
  prefs: []
  type: TYPE_NORMAL
