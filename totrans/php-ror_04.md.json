["```php\n# version_verification.rb\nputs \"We are running Ruby version #{RUBY_VERSION}\"\n```", "```php\nruby version_verifications.rb\n```", "```php\nWe are running Ruby version 2.6.8\n```", "```php\n# version_verification.rb\nputs \"Incompatible Ruby version\" if Gem::Version.new(RUBY_VERSION) < Gem::Version.new('3.0')\nputs \"We are running Ruby version #{RUBY_VERSION}\"\n```", "```php\nIncompatible Ruby version\nWe are running Ruby version 2.6.8\n```", "```php\n# version_verification.rb\nKernel::exit(1) if Gem::Version.new(RUBY_VERSION) < Gem::Version.new('3.0')\nputs \"We are running Ruby version #{RUBY_VERSION}\"\n```", "```php\necho $?\n```", "```php\n# version_verification.rb\nKernel::exit(1) if Gem::Version.new(RUBY_VERSION) > Gem::Version.new('2.6')\nputs \"We are running Ruby version #{RUBY_VERSION}\"\n```", "```php\nWe are running Ruby version 2.6.8\n```", "```php\nfirst_name = \"benjamin\"\nlast_name = \"BECKER\"\nputs \"My full name is #{first_name} #{last_name}\"\n```", "```php\nruby string_cases.rb\n```", "```php\nMy full name is benjamin BECKER.\n```", "```php\nfirst_name = \"benjamin\"\nlast_name = \"BECKER\"\nputs \"My full name is #{first_name.upcase} #{last_name}\"\n```", "```php\nMy full name is BENJAMIN BECKER.\n```", "```php\nfirst_name = \"benjamin\"\nlast_name = \"BECKER\"\nputs \"My full name is #{first_name} #{last_name.downcase}\"\n```", "```php\nMy full name is benjamin becker\n```", "```php\nfirst_name = \"benjamin\"\nlast_name = \"BECKER\"\nputs \"My full name is #{first_name} #{last_name}\".upcase\n```", "```php\nMY FULL NAME IS BENJAMIN BECKER\n```", "```php\nfirst_name = \"benjamin\"\nlast_name = \"BECKER\"\nputs \"My full name is #{first_name.capitalize} #{last_name.capitalize}\"\n```", "```php\nMy full name is Benjamin Becker\n```", "```php\nmary\n```", "```php\n# reading_file.rb\nFile.open(\"name.txt\")\n```", "```php\n# reading_file.rb\nfile_instance = File.open(\"name.txt\")\n```", "```php\n# reading_file.rb\nfile_instance = File.open(\"name.txt\")\nuser_name = file_instance.read\nputs \"The user's name is #{user_name}\"\n```", "```php\nThe user's name is mary\n```", "```php\nnancy\n```", "```php\nfull_name.txt with the following content:\n\n```", "```php\n\n We’re going to manipulate this file with another Ruby script called `full_name.rb`. Initially, the script is going to be the same as the `reading_file.rb` script. We can even just copy the file, but we are going to make some tweaks to separate the full name into `name` and `last_name`. We’ll also change the `name.txt` parameter to `full_name.txt`. So, let’s look at the code in the `full_name.rb` file:\n\n```", "```php\n\n If we execute this script on the shell with `ruby full_name.rb`, the output will be as follows:\n\n```", "```php\n\n There’s nothing unexpected here as the functionality is pretty much the same as the first script, `reading_file.rb`. But what if we wanted to have the name and the last name capitalized? We could try using the `capitalize()` method on the `user_name` variable. Let’s do that. The line where we output `user_name` will look like this:\n\n```", "```php\n\n However, when we run the script again, the output will be as follows:\n\n```", "```php\n\n Unfortunately for us, the `capitalize()` method only changes the first letter of the first word to uppercase. But do not despair, as we can accomplish the correct upper casing with just a single line of code. Before we do that, we will look at three additional methods: `split()`, `map()`, and `join()`.\nThe split() method\nWe can use `split()` to divide a word by spaces into an array. Simply put, `split()` would turn `paul smith` into an array of `[ \"paul\", \"smith\" ]`, which we can use in our current situation. So, let’s incorporate it into our code:\n\n```", "```php\n\n In the preceding code, we took the string from the file and applied the `split()` method.\nThis method divided the `paul smith` into an array of two elements. In the end, we used the element on the `0` slot (`user_name[0]`) and the `1` slot (`user_name[0]`) and embedded them into the string. For now, the output is the same, but with the advantage that we have divided the name into two words. We could apply the `capitalize()` method to both elements and be done with our task at hand. But this is when we have to take a step back and think in more broad terms for our script. What would happen if someone had a middle name? Or how would our script behave if a user had two last names? Our script would truncate part of the name in both of these cases. It is our job, as developers, to create code that is generic and that will behave properly, even with some unexpected input. This is where the `map()` method proves useful.\nThe map() method\nThe `map()` method is equivalent to iterating through an array and applying a method to each element of the array in a single line. It receives a method that we want to apply to each element as a parameter. So, let’s have another rewrite of our script:\n\n```", "```php\n\n Now, the output is something slightly strange, but closer to what we’re looking for. If we run this script again, we will get the following output:\n\n```", "```php\n\n We are almost there. Here, we are reading the name from the file, then dividing it by spaces into words, and finally applying each word to the `capitalize()` method. The problem with the output is that, yes, we’ve capitalized each element of the array, but then we are printing the whole array as a string, so the square brackets (`'[ ]'`) are included on the string. We are missing one last step, which is where the `join()` method comes in handy.\nThe join() method\nThe `join()` method does the opposite of `split()`. The `join()` method takes an array, converts it into a string, and glues each element with what we set as a parameter. So, the last step is to make the `user_name` array a string, each element separated by a white space. So, let’s add that last touch:\n\n```", "```php\n\n And with that, our generic script is done. Let’s take it out for a ride. If we were to run it on the shell, the output would be as follows:\n\n```", "```php\n\n Now, since we claim that our script is generic, it should not be an issue if we were to add a middle name. So, let’s change the name in the `full_name.txt` file:\n\n```", "```php\n\n If we were to run the script again, the output would be as follows:\n\n```", "```php\n\n We are still missing the other use case that I mentioned in which some people in some countries have two last names. So, let’s change the name one more time in our `full_name.txt` file:\n\n```", "```php\n\n As with the other examples, the script will run correctly and output the following:\n\n```", "```php\n\n We’ve successfully made a truly generic piece of code. It will work whether we add a single name, a generic name (name and last name), or a special combination of first, middle, and two last names. While the code is not as readable as other snippets we’ve read, I can guarantee that you will encounter a combination of the `split()`, `map()`, and `join()` methods whenever you move into more advanced code. Once we get to using the Ruby on Rails framework, you will see and use both of these methods there.\nSo far, we’ve only written code in read-only mode. Now, let’s look at creating and modifying file contents.\nCreating and modifying file contents\nOne practical use of reading and writing a file would be creating and modifying a counter value saved in a text file. What if we wanted to keep track of how many times a script has been executed? We could add a file with a number and each time we run the script, we could increment this value and simply output it to the user. We’ll start by creating a file called `counter.rb` with the following code:\n\n```", "```php\n\n Again, we are opening a file, but in this case, we’ve added an additional parameter (`\"w\"`) so that we can write contents to the file. Additionally, we are going to try to create the file with our script instead of creating it by ourselves. So, let’s run this script from the shell with `ruby counter.rb`. The output should be as follows:\n\n```", "```php\n\n Unfortunately for us, this is an error. If we look closer at the error description, it reads `not opened for reading`. This is because we set `\"w\"` mode, which is a write-only mode. We can only write to the file in this mode. However, we need to both read and write the contents of the file. Also, notice that the `counter.txt` file has been created, and that’s an advantage of `\"w\"` mode. If the file we are trying to write doesn’t exist, it will create it for us. We want this behavior, but we also want to be able to read the contents of the file. So, let’s change the mode to `\"a+\"` in our script:\n\n```", "```php\n\n Don’t forget to delete the `counter.txt` file and execute the script again. The output will now look like this:\n\n```", "```php\n\n If we check the folder in which our script is, we will notice that the `counter.txt` file has been created. However, the value is empty, which is unintended. So, let’s tweak our script to convert that into a number:\n\n```", "```php\n\n Notice that on line 3 of our script, we’ve added `.to_i` at the end of the line, which converts the contents of the string into a number. In this scenario, the file is empty and thus returns an empty string, which, in turn, is converted into a `0`. Let’s run this script again. The output will be as follows:\n\n```", "```php\n\n So far, so good. However, if we run it again, the output will remain the same as we have not added the functionality to increment the number. Let’s do just that:\n\n```", "```php\n\n With the last two lines, we’ve incremented the counter value by one and written the said value to the same `counter.txt` file. As a final test for this script, let’s delete the `counter.txt` file once more and run the script a few times. This should be the output:\n\n```", "```php\n\n With this output, we can confirm that our script has run correctly a couple of times. As I mentioned previously, even with the existence of DBs, file reading and writing can be useful, be it for saving configuration values or for logging, and it is fast and easy to implement. You can find additional examples and modes at [https://www.rubyguides.com/2015/05/working-with-files-ruby/](https://www.rubyguides.com/2015/05/working-with-files-ruby/).\nNow that we’ve established how we can read and write to and from files, let’s take a look at the next feature that will help us give our scripts more usefulness: command-line arguments.\nCommand-line arguments\nSo far, we’ve added both variable and fixed (either numeric or string) values to our code. To make our scripts more generic and more usable for other folks, we can add parameters that won’t be hardcoded within the code. If you’re not familiar with the term, *hardcoded* is the practice of writing fixed variable values within code. In our previous examples, we added the filename that we were going to open as a fixed value – that is, to change it, we would have to change the source code. To avoid that, we could pass the script a value (a filename, in this case) that whoever runs the script can change. Passing values to a script is what we commonly refer to as command-line arguments. We can have multiple arguments, a single argument, or as we’ve done so far, no arguments. Let’s start with a simple example, then work our way up to more complex examples that will help us make our scripts more generic.\nLet’s start by taking a string as a command-line argument on a script, format it, and output it to the shell. We will start by creating a script called `command_line.rb` with the following code:\n\n```", "```php\n\n In this script, we are using `ARGV`, which is an array that contains any parameters passed to our script, then assigns it to a variable, to finally pass its first value to a string to be outputted. Let’s try running the script. First, let’s try it with no arguments by running this on the shell:\n\n```", "```php\n\n This will output the following:\n\n```", "```php\n\n We received this output we have not passed any command-line arguments to our script. So, how do we pass arguments, you may ask? Well, it’s as simple as writing the value right after the filename when we run it. Now, let’s try this with a name value. On the shell, run the following:\n\n```", "```php\n\n We will now see the following output:\n\n```", "```php\n\n As we can see, Ruby detects a single value on the `ARGV` array, and as a result, the output shows the same value we passed to the script. Unlike the value we obtained through opening a file, the `ARGV` array works a bit differently. Let’s try adding a second argument to our script. Let’s run it with both a different name and a second parameter. Back in the shell, run the following:\n\n```", "```php\n\n The output will be as follows:\n\n```", "```php\n\n This is because we are only using the first value of the `input_arguments` array – that is, the value contained in `input_arguments[0]`. Ruby takes the string that is passed as an argument, automatically splits it by spaces, and then places each element in the `ARGV` array. Let’s use all of the arguments that are being passed and wrap up this example. We will take the `map()` and `join()` combo that we previously used in the file handling examples to glue and show all arguments passed to the script, and since it’s a name, we will capitalize it in the process. So, let’s tweak our script once more so that it does just that:\n\n```", "```php\n\n Now, let’s run it a couple of times with different names each time:\n\n```", "```php\n\n This will output the following:\n\n```", "```php\n\n Let’s try it with more parameters:\n\n```", "```php\n\n This will output the following:\n\n```", "```php\n\n The same goes for running it with fewer arguments. Let’s give this one more try with a single name:\n\n```", "```php\n\n This will also run but with a single name, just like on the first iteration of the script. The output will be as follows:\n\n```", "```php\n\n Now that we understand the basics of command-line arguments, let’s start giving them a bit more usefulness. Let’s write a script that will take two arguments, the first being a name and the second being a digit. We will get our script to get the digit and print the name as many times as that digit. We will also add an error message if the script is run with fewer or more arguments than what we need for our script to work. So, let’s start by creating a file called `validate_arguments.rb` and add the following code to it:\n\n```", "```php\n\n In this script, we get the command-line arguments and use the first one as the name and the last one as the counter for our cycle. With the `cycle_times` variable, we’re casting (or converting) the value of the last element of the `input_arguments` array from a string into an integer. Then, we’re using the `times` method to repeat a piece of code inside the curly brackets. Now, let’s try running our script with the following values:\n\n```", "```php\n\n As expected, the output of the script is as follows:\n\n```", "```php\n\n We may think our work here is done, but we’d be wrong. This is what we call the *happy path*, in which we feed our script values that the script is expecting and thus the script’s behavior is correct. However, this is utopic as this never happens in real life. In real life, the user will forget to feed the script both parameters or will feed the parameters in the wrong order. We, as coders, need to take this into account and code appropriately. We need to validate that the input we feed the script is either correct or that we need to tell the user that the parameters are incorrect. What happens if we invert the parameters? Let’s see:\n\n```", "```php\n\n This outputs nothing. Let’s try running the script with no arguments:\n\n```", "```php\n\n This also outputs nothing. This is a mistake on our side because we know how our script works, but someone who might be using the script doesn’t. There is no documentation and the least we can do is output error messages that can guide the user as to the correct usage of the script. Additionally, we have to assume that the end user does not know how to program and is not going to open the script to view its usage. So, let’s start by validating that the script only receives two arguments. Also, let’s add an error message to help the user out. Let’s create our validation in our code. Our `validate_arguments.rb` script will now look like this:\n\n```", "```php\n\n Now, when we run it again without any arguments, we will see an error message:\n\n```", "```php\n\n However, even though we are seeing an error, the script is still going through the whole code, which is not what we want. To prove this, let’s add another message at the end of the code:\n\n```", "```php\n\n Let’s run the script again (with no arguments):\n\n```", "```php\n\n The output will be as follows:\n\n```", "```php\n\n As we learned previously, we need to stop the execution of the script once we’ve figured out that we have errors. So, let’s fix this and stop the execution with a `Kernel::exit()` call. Let’s also add a suggestion to fix the problem:\n\n```", "```php\n\n Let’s run the script once again without arguments:\n\n```", "```php\n\n This time, we will get the correct output, and the execution will be stopped at the right point:\n\n```", "```php\n\n As you can see, we are no longer outputting the `But we are still running the script.` message. This is because once the script does not pass the validation block, its execution is stopped. This is great progress for our script. However, we are still missing one piece of validation. In previous examples, we inverted the arguments by passing the number and then the name. Even with our tweaks and validations, this is a use case that will still make our script behave erroneously. Let’s try it out:\n\n```", "```php\n\n This will output the following:\n\n```", "```php\n\n Again, we have no information as to why the output is empty, which can be very frustrating to the user. So, let’s add more validations to our script. We, as the creators of the script, know that the script is failing because the second argument should be a number – an integer, to be more precise. However, this validation can be slightly tricky because of the way a lot of programming languages behave, including Ruby and PHP. The behavior I’m referring to is the way Ruby converts a text string into an integer. As an example, a string such as `'22'` will be converted into an integer, `22`. However, the `'henry'` string will unexpectedly be converted into a valid `0`, and while this is not what we need, we can certainly take advantage of this behavior. For our script, we need the second argument to be larger than `0`. So, that’s exactly what we are going to validate:\n\n```", "```php\n\n Let’s run the script with the incorrect arguments again:\n\n```", "```php\n\n We will get the following output:\n\n```", "```php\n\n With that, we have successfully made our script validate that the input must be two arguments. If we feed the script either no arguments, one argument, or more than two arguments, it will fail and send an error message describing the correct usage of the script. Now that we’ve looked into different ways to add input to our script, let’s look at another way to interact with the user: user input.\nUser input\nSo far, we’ve made use of command-line arguments to make our scripts more generic, thus helping with what could be an automated script. Be it a shell script (as we’ve done so far) or a crontab script to be run at a designated time each day, we’ve learned the basic usage of these arguments that are fed to our scripts. But there is another type of argument that, while technically not a command-line argument, is closely related and is super useful when making scripts that interact with human users. In comes *user input*. User input helps us make a script more interactive with the user as it makes a pause in the execution of the script to wait for the user to type data and resume after the user has typed a carriage return (or the *Enter* key). This makes a more user-friendly interaction with the user. Let’s look at a simple example to see this interaction at play. We will create a file called `user_input.rb` and add the following code:\n\n```", "```php\n\n Now, let’s run it on our shell:\n\n```", "```php\n\n We will notice that the output shows the following message:\n\n```", "```php\n\n We will also notice that the shell looks slightly different as it is expecting input from us. So, let’s do that and type a name, hitting the *Enter* key right after entering it:\n\n```", "```php\n\n Immediately, the execution of our script continues and outputs the greeting that we included in our code:\n\n```", "```php\n\n Notice how interactive our script has become. It asks for your name; we type the name and immediately we are greeted. While this is friendlier and more interactive, we still need to fix a couple of things in our code. The method we are currently using (`Kernel::gets()`; see [https://ruby-doc.org/2.7.7/Kernel.html#method-i-gets](https://ruby-doc.org/2.7.7/Kernel.html#method-i-gets)) not only includes the name, but it also includes the return of carriage character (`\\n`) or in layman’s terms, the *Enter* key character. So, if we tried to compare the input to a string, we would be surprised to see that it wouldn’t behave as we would expect it to. Let’s try it with the following code:\n\n```", "```php\n\n Now, let’s re-run our script:\n\n```", "```php\n\n Let’s input the name `brandon`:\n\n```", "```php\n\n This time, notice that we don’t see the greeting. And this is not because of a typo. This is because the `Kernel::gets()` method is capturing a character at the end of the name. In comes another method to save the day: `chomp()`. The `chomp()` method removes carriage return characters and trailing new lines from the string. Please refer to [https://apidock.com/ruby/String/chomp](https://apidock.com/ruby/String/chomp) for more details regarding this method. Essentially, it cleans up our string and leaves the original text. So, let’s modify our code so that it includes this method. Our code will now look like this:\n\n```", "```php\n\n Let’s run it once more:\n\n```", "```php\n\n If we input the name `brandon` again, we will get the following result:\n\n```", "```php\n\n We will finally get the correct greeting. So, from now on, we will get input from the user with `gets.chomp` for safe measure. Now, let’s fetch an integer from the user and run some code multiple times, depending on the number the user typed:\n\n```", "```php\n\n Let’s run it on the shell again:\n\n```", "```php\n\n Now, let’s input the name `brandon` and enter `3` afterwards. This will be the whole sequence:\n\n```", "```php\n\n After entering `brandon`, we now output instructions to enter a digit, and right after that, we fetch an integer from the user. With this digit, we will print a `trying…` message and use the `sleep()` method to pause the execution for 1 second. If you would like more detailed information regarding the `sleep()` method, please check out [https://apidock.com/ruby/Kernel/sleep](https://apidock.com/ruby/Kernel/sleep). You will notice that the script will show the `trying…` message, pause for a second, show the second message, pause again, and finally show the last message, pause one last time, and finish the execution of the script. The `sleep()` method is useful when we are waiting for a process to finish. It’s especially useful when working with API calls, which may take some time to finish. As a final exercise, let’s dive into a script’s friendliness and usefulness.\nPutting it all together\nReading and understanding someone else’s code is essential to learning Ruby. With that intent, we will now look at the following example, which was written with some of the techniques we learned about in this chapter, and figure out what the script is doing:\n\n```", "```php\n\n For us to understand the intent of the script, we will divide it into six sections that we have commented on the code itself. This is not compulsory when writing code, but I’ve taken the liberty to do this for teaching purposes. So, let’s take a look at the first section:\n\n```", "```php\n\n Here, we are comparing our currently installed Ruby version and making sure that the version is higher than 2.6\\. If the version is lower than that, we print an error message and exit the program. This is something you might find very often in scripts as major versions tend to differ in terms of functionality and sometimes in syntax.\nLet’s move on to the next section of our script:\n\n```", "```php\n\n In this section, we are opening a file, but as we’ve seen in previous examples, it’s using `\"a+\"` mode so that if the file does not exist, it creates it. If the file already exists, it reads its contents. The script’s intent in this section is to read a user’s name from this file, but if the file is empty, the name will be empty too. This may seem slightly different from what we’ve been doing so far. However, let’s look at the next section, where this will make more sense. In sections 3 and 4, we can see the following:\n\n```", "```php\n\n In section 3, we can see that if the username fetched from the file is not empty, the script moves on to the next section. But if the username is empty, then we prompt the user to provide a username. Once the user types a username, the script will write the name to the `user_name.txt` file and move to section 4.\nIn section 4, the script simply writes a log entry to a `main.log` file in which it writes the name obtained from the user and the time in which the user did this. Lastly, the script assigns the `user_name` variable to be used later on in the script.\nIn section 5, we have this code:\n\n```", "```php\n\n In this section, we greet the user by capitalizing the name, print a welcoming message, and then print another aiding message so that the user knows what they’ll do next, which is enter a number.\nIn our last section, we are doing something similar to what we did in our previous looping example. Let’s take a look:\n\n```", "```php\n\n In section 6, which is the last section of the script, we’re getting a number from the user, then taking this number and doing a cycle to execute a code the number of times the user provided. The code to be executed simply shows a message for the user and adds multiple entry logs to the same `main.log` file. In this case, the script is also using the append writing mode so that when the script writes to this file, it will write contents at the end of the file instead of replacing the previous contents. This type of logging is both common and useful in the scripting and programming realms. It helps other users debug the functionality of the script, especially when things start failing. We are only missing one thing now: running the script. Let’s run it:\n\n```", "```php\n\n The first time we run this file, we will get the following output on the shell:\n\n```", "```php\n\n Let’s enter `daniel`. After we enter this name, we will get the following output:\n\n```", "```php\n\n Here, the script requires that we enter a number. Let’s type `2`. The script will respond with the following output:\n\n```", "```php\n\n Initially, this seems simple enough. However, if we take a look at the contents of the folder where our script resides, we’ll notice two new files: `main.log` and `user_name.txt` . If we open the `user_name.txt` file, its contents will coincide with the name we typed:\n\n```", "```php\n\n And if we look at the `main.log` file, we will see the following output:\n\n```", "```php\n\n This content coincides with what happened on the initial run of the script. It wrote `daniel` to the log and added two entries to the same log. Now, let’s run the script once more:\n\n```", "```php\n\n This time, we will notice that the script does not ask for a user, instead using the previous username we entered. The output will look like this:\n\n```", "```php\n\n This is very practical as we don’t need to enter the name every time we run the script. Lastly, it prompts us for a number to run the log process again. Let’s type `1` and wait for the response, which should look like this:\n\n```", "```php\n\n This time, as we typed `1`, the cycle only ran the code once, which is what we expected. I hope you found this reading exercise useful and I hope you make the habit of reading other developer’s code to both learn good practices and understand how to do things in Ruby.\nSummary\nIn this chapter, we learned how to write more useful scripts that we will probably reuse in the future. We also got a glimpse at some of the tools that Ruby has to handle text. We also learned how to open, read, and write content to and from a file and how this may come in handy when writing scripts. Lastly, we were exposed to Ruby’s command-line arguments, which make our automation work easier. We also learned of Ruby’s user input arguments, which make our scripts more interactive for users. Having learned this, we are now ready to undercover some misconceptions about PHP, Ruby, Ruby on Rails, and other frameworks.\n\n```"]