- en: Chapter 3. Your First Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。您的第一个应用程序
- en: Having learned about Laravel's conventions, working with dependencies using
    Composer, and setting up a development environment with Homestead, you are now
    ready to build your first application!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了 Laravel 的约定、使用 Composer 处理依赖关系以及使用 Homestead 设置开发环境之后，您现在可以准备构建您的第一个应用程序了！
- en: 'In this chapter, you will use the concepts presented in the previous two chapters
    in a practical way and learn how to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将以实际的方式使用前两章中介绍的概念，并学习如何执行以下操作：
- en: Plan the URLs and entities of your application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划您应用程序的 URL 和实体
- en: Troubleshoot common issues when getting started
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始时解决常见问题
- en: Define routes and their actions, as well as models and their relationships
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义路由及其操作，以及模型及其关系
- en: Prepare your database and learn how to interact with it using Eloquent
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备您的数据库并学习如何使用 Eloquent 与其交互
- en: Use the Blade template language to create hierarchical layouts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Blade 模板语言创建分层布局
- en: The first step in creating a web application is to identify and define its requirements.
    Then, once the main features have been decided, we derive the main entities as
    well as the URL structure of the application. Having a well-defined set of requirements
    and URLs is also essential for other tasks such as testing; this will be covered
    later in the book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 创建网络应用程序的第一步是确定和定义其需求。然后，一旦确定了主要功能，我们就推导出主要实体以及应用程序的 URL 结构。有一套明确的需求和 URL 对于其他任务（如测试）也是必不可少的；这将在本书的后续章节中介绍。
- en: A lot of new concepts are presented in this chapter. If you have trouble understanding
    something or if you are not quite sure where to place a particular snippet of
    code, you can download the annotated source code of the application from [http://packtpub.com/support](http://packtpub.com/support),
    which will help you to follow along.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了许多新概念。如果您对某些内容有疑问或不确定某个代码片段应该放在哪里，您可以下载应用程序的注释源代码，从 [http://packtpub.com/support](http://packtpub.com/support)，这将帮助您跟上进度。
- en: Planning our application
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划我们的应用程序
- en: We are going to build a browsable database of cat profiles. Visitors will be
    able to create pages for their cats and fill in basic information such as the
    name, date of birth, and breed of each cat. This application will implement the
    default **Create-Retrieve-Update-Delete** (**CRUD**) operations. We will also
    create an overview page with the option to filter cats by breed. All of the security,
    authentication, and permission features are intentionally left out, since they
    will be covered in the further chapters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个可浏览的猫档案数据库。访客将能够为他们的猫创建页面并填写基本信息，如每只猫的名字、出生日期和品种。此应用程序将实现默认的**创建-检索-更新-删除**（**CRUD**）操作。我们还将创建一个概述页面，用户可以选择按品种过滤猫。所有安全、身份验证和权限功能都故意省略，因为它们将在后续章节中介绍。
- en: Entities, relationships, and attributes
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体、关系和属性
- en: 'Firstly, we need to define the *entities* of our application. In broad terms,
    an entity is a thing (person, place, or object) about which the application should
    store data. From the requirements, we can extract the following entities and attributes:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义我们应用程序的*实体*。从广义上讲，实体是应用程序应该存储数据的东西（人、地点或对象）。根据需求，我们可以提取以下实体和属性：
- en: '**Cats**: They have a numeric identifier, a name, a date of birth, and a breed'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**猫**：它们有一个数字标识符、一个名字、一个出生日期和一个品种'
- en: '**Breeds**: They only have an identifier and a name'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**品种**：它们只有一个标识符和一个名字'
- en: This information will help us when defining the database schema that will store
    the entities, relationships, attributes, as well as the models, which are the
    PHP classes that represent the objects in our database.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息将帮助我们定义存储实体、关系、属性以及模型的数据库模式，这些模型是代表我们数据库中对象的 PHP 类。
- en: The map of our application
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们应用程序的地图
- en: We now need to think about the URL structure of our application. Having clean
    and expressive URLs has many benefits. On a usability level, the application will
    be easier to navigate and will look less intimidating to the user (descriptive
    URLs look far more appealing than a lengthy query string). For frequent users,
    individual pages will be easier to remember or bookmark and, if they contain relevant
    keywords, they will often rank higher in search engine results.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要考虑我们应用程序的URL结构。拥有干净且具有表达力的URL有很多好处。在可用性方面，应用程序将更容易导航，对用户来说看起来也不会那么令人生畏（描述性的URL比冗长的查询字符串更具吸引力）。对于频繁的用户来说，单独的页面更容易记住或收藏，如果它们包含相关关键词，它们通常在搜索引擎结果中排名更高。
- en: To fulfill the initial set of requirements, we are going to need the following
    routes in our application. A route is a URL and HTTP method to which the application
    will respond.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足初始的一组需求，我们需要在我们的应用程序中添加以下路由。路由是一个URL和HTTP方法，应用程序将对其做出响应。
- en: '| Method | Route | Description |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 路由 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `GET` | `/` | Index |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/` | 索引 |'
- en: '| `GET` | `/cats` | Overview page |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/cats` | 概览页面 |'
- en: '| `GET` | `/cats/breeds/:name` | Overview page for specific breed |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/cats/breeds/:name` | 特定品种的概览页面 |'
- en: '| `GET` | `/cats/:id` | Individual cat page |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/cats/:id` | 单个猫页面 |'
- en: '| `GET` | `/cats/create` | Form to create a new cat page |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/cats/create` | 创建新猫页面的表单 |'
- en: '| `POST` | `/cats` | Handle creation of new cat page |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/cats` | 处理创建新猫页面 |'
- en: '| `GET` | `/cats/:id/edit` | Form to edit existing cat page |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/cats/:id/edit` | 编辑现有猫页面的表单 |'
- en: '| `PUT` | `/cats/:id` | Handle updates to cat page |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `/cats/:id` | 处理猫页面的更新 |'
- en: '| `GET` | `/cats/:id/delete` | Form to confirm deletion of page |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/cats/:id/delete` | 确认删除页面的表单 |'
- en: '| `DELETE` | `/cats/:id` | Handle deletion of cat page |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `/cats/:id` | 处理猫页面的删除 |'
- en: 'You will shortly learn how Laravel helps us to turn this routing sketch into
    actual code. If you have written PHP applications without a framework, you can
    briefly reflect on how you would have implemented such a routing structure. To
    add some perspective, this is what the second to last URL could have looked like
    with a traditional PHP script (without URL rewriting): `/index.php?p=cats&id=1&_action=delete&confirm=true`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会了解到Laravel如何帮助我们把这个路由草图变成实际的代码。如果你在没有框架的情况下编写过PHP应用程序，你可以简要地反思一下你将如何实现这样的路由结构。为了增加一些视角，这是第二个到最后一个URL可能看起来像的传统PHP脚本（没有URL重写）：`/index.php?p=cats&id=1&_action=delete&confirm=true`。
- en: The preceding table can be prepared using a pen and paper, in a spreadsheet
    editor, or even in your favorite code editor, using ASCII characters. In the initial
    development phases, this table of routes is an important prototyping tool that
    makes you to think about URLs first and helps you define and refine the structure
    of your application iteratively.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表格可以使用笔和纸、电子表格编辑器，甚至在你最喜欢的代码编辑器中使用ASCII字符来准备。在初始开发阶段，这个路由表是一个重要的原型工具，它让你首先考虑URL，并帮助你迭代地定义和细化应用程序的结构。
- en: If you have worked with REST APIs, this kind of routing structure will look
    familiar to you. In RESTful terms, we have a `cats` resource that responds to
    the different HTTP verbs and provides an additional set of routes to display the
    necessary forms.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你与REST API合作过，这种路由结构对你来说将很熟悉。在RESTful术语中，我们有一个`cats`资源，它响应不同的HTTP动词，并提供了一组额外的路由来显示必要的表单。
- en: If, on the other hand, you have not worked with RESTful sites, the use of the
    `PUT` and `DELETE` HTTP methods might be new to you. Even though web browsers
    do not support these methods for standard HTTP requests, Laravel uses a technique
    that other frameworks such as Rails use, and emulates those methods by adding
    a `_method` input field to the forms. This way, they can be sent over a standard
    `POST` request and are then delegated to the correct route or controller method
    in the application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你没有与RESTful站点合作过，`PUT`和`DELETE` HTTP方法可能对你来说是新的。尽管网络浏览器不支持这些方法进行标准HTTP请求，但Laravel使用了一种其他框架（如Rails）使用的技巧，通过在表单中添加一个`_method`输入字段来模拟这些方法。这样，它们可以通过标准的`POST`请求发送，然后被委派到应用程序中的正确路由或控制器方法。
- en: Note also that none of the form submissions endpoints are handled with a `GET`
    method. This is primarily because they have side effects; a user can trigger the
    same action multiple times accidentally when using the browser history. Therefore,
    when they are called, these routes never display anything to the users. Instead,
    they redirect them after completing the action (for instance, `DELETE /cats/:id`
    will redirect the user to `GET /cats`).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，表单提交的端点都不是用 `GET` 方法处理的。这主要是因为它们有副作用；当用户在使用浏览器历史记录时，可能会意外地触发相同的操作多次。因此，当这些路由被调用时，它们永远不会向用户显示任何内容。相反，它们在完成操作后会将用户重定向（例如，`DELETE
    /cats/:id` 将将用户重定向到 `GET /cats`）。
- en: Starting the application
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动应用程序
- en: Now that we have the blueprints for the application, let's roll up our sleeves
    and start writing some code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了应用程序的蓝图，让我们卷起袖子开始编写一些代码。
- en: 'Start by opening a new terminal window and launch Homestead:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先打开一个新的终端窗口并启动 Homestead：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Navigate to the directory you have mapped to Homestead (by default this is
    `~/Code`):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到您映射到 Homestead 的目录（默认情况下为 `~/Code`）：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then use Composer to create a new Laravel project, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 Composer 创建一个新的 Laravel 项目，如下所示：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once Composer finishes downloading Laravel and resolving its dependencies, you
    will have a directory structure identical to the one presented in the first chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Composer 完成下载 Laravel 并解决其依赖关系，您将拥有与第一章中展示的相同的目录结构。
- en: Setting the application namespace
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置应用程序命名空间
- en: 'Applications in Laravel are namespaced. By default, this is just `App`—Laravel''s
    great, but it still can''t guess the name of your application! To set it to something
    more appropriate, we can use the Artisan command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 中的应用程序是命名空间的。默认情况下，这只是 `App`——Laravel 很棒，但它仍然无法猜测您应用程序的名称！为了将其设置为更合适的内容，我们可以使用
    Artisan 命令：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will update our application's namespace to be `Furbook` instead.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更新我们应用程序的命名空间为 `Furbook`。
- en: Writing the first routes
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写第一个路由
- en: 'Let''s start by writing the first two routes of our application at `app/Http/routes.php`.
    This file already contains some comments as well as a couple of sample routes.
    Remove the existing routes (but leave the opening `<?php` declaration) before
    adding the following routes:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写应用程序在 `app/Http/routes.php` 中的前两个路由开始。此文件已经包含了一些注释以及一些示例路由。在添加以下路由之前，请删除现有路由（但保留开头的
    `<?php` 声明）：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first parameter of the `get` method is the URI pattern. When a pattern is
    matched, the closure function in the second parameter is executed with any parameters
    that were extracted from the pattern. Note that the slash prefix in the pattern
    is optional; however, you should not have any trailing slashes. You can make sure
    that your routes work by opening your web browser and visiting `http://dev.furbook.com/cats/123`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 方法的第一个参数是 URI 模式。当模式匹配时，第二个参数中的闭包函数会执行，并带有从模式中提取的任何参数。请注意，模式中的斜线前缀是可选的；然而，您不应该有任何尾随斜线。您可以通过打开您的网络浏览器并访问
    `http://dev.furbook.com/cats/123` 来确保您的路由可以正常工作。'
- en: Restricting the route parameters
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制路由参数
- en: 'In the pattern of the second route, `{id}` currently matches any string or
    number. To restrict it so that it only matches numbers, we can chain a `where`
    method to our route as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个路由的模式中，`{id}` 当前匹配任何字符串或数字。为了限制它只匹配数字，我们可以在路由上链式调用一个 `where` 方法，如下所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `where` method takes two arguments: the first one is the name of the parameter
    and the second one is the regular expression pattern that it needs to match.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`where` 方法接受两个参数：第一个是参数的名称，第二个是需要匹配的正则表达式模式。'
- en: If you now try to visit an invalid URL, nginx (the server software serving the
    application) will display a **404 Not Found** error page.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在尝试访问一个无效的 URL，nginx（服务应用程序的服务器软件）将显示一个 **404 未找到** 错误页面。
- en: Handling HTTP exceptions
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 HTTP 异常
- en: When an error occurs in your application, Laravel raises an exception. This
    is also true for HTTP errors, as Laravel will raise an appropriate HTTP exception.
    Usually when an HTTP error occurs, you will want to display a response informing
    the user what went wrong. This is easy in Laravel 5, as all you need to do is
    create a view named after the HTTP status code you want it to display for in the
    `resources/views/errors` directory.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用程序发生错误时，Laravel 会抛出异常。这对于 HTTP 错误也是如此，因为 Laravel 会抛出适当的 HTTP 异常。通常，当发生
    HTTP 错误时，您可能希望显示一个响应，告知用户出了什么问题。在 Laravel 5 中，这很容易，您只需要在 `resources/views/errors`
    目录中创建一个以您希望显示的 HTTP 状态码命名的视图。
- en: For example, if you wanted to display a view for **404 Not Found** errors, then
    all you need to do is create a view at `resources/views/errors/404.blade.php`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想显示**404未找到**错误的视图，那么你只需要在`resources/views/errors/404.blade.php`创建一个视图。
- en: You can use this approach to handle other HTTP errors as well, such as **403
    Forbidden** errors; simply create a view at `resources/views/errors/403.blade.php`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这种方法处理其他HTTP错误，例如**403禁止访问**错误；只需在`resources/views/errors/403.blade.php`创建一个视图即可。
- en: We'll cover views later on in this chapter. In the meantime, you can find a
    list of HTTP status codes at [http://en.wikipedia.org/wiki/List_of_HTTP_status_codes](http://en.wikipedia.org/wiki/List_of_HTTP_status_codes).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面介绍视图。在此期间，你可以在[http://en.wikipedia.org/wiki/List_of_HTTP_status_codes](http://en.wikipedia.org/wiki/List_of_HTTP_status_codes)找到HTTP状态码列表。
- en: Performing redirections
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行重定向
- en: 'It is also possible to redirect visitors using the `redirect()` helper in your
    routes. If, for example, we wanted everyone to be redirected to `/cats` when they
    visit the application for the first time, we would write the following lines of
    code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用路由中的`redirect()`辅助函数重定向访客。例如，如果我们想当访客第一次访问应用程序时被重定向到`/cats`，我们会编写以下代码行：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can create the route for the URL we''re redirecting to:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为我们要重定向到的URL创建路由：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Returning views
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回视图
- en: The most frequent object that you will return from your routes is the `View`
    object. Views receive data from a route (or controller action) and inject it into
    a template, therefore helping you to separate the business and presentation logic
    in your application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你从路由返回的最常见的对象是`View`对象。视图从路由（或控制器操作）接收数据并将其注入到模板中，因此帮助你将应用程序中的业务逻辑和展示逻辑分离。
- en: 'To add your first view, simply create a file called `about.php` at `resources/views`
    and add the following content to it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加第一个视图，只需在`resources/views`中创建一个名为`about.php`的文件，并将其内容添加到其中：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, return the view using the `view()` helper function with the variable,
    `$number_of_cats`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用带有变量`$number_of_cats`的`view()`辅助函数返回视图：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, visit `/about` in your browser to see the rendered view. This view
    was written with plain PHP; however, Laravel comes with a powerful template language
    called Blade, which will be introduced later in this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在浏览器中访问`/about`以查看渲染的视图。这个视图是用纯PHP编写的；然而，Laravel附带了一个强大的模板语言，称为Blade，将在本章后面介绍。
- en: Preparing the database
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备数据库
- en: Before we can expand the functionality of our routes, we need to define the
    models of our application, prepare the necessary database schema, and populate
    the database with some initial data.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够扩展路由的功能之前，我们需要定义应用程序的模型，准备必要的数据库模式，并在数据库中填充一些初始数据。
- en: Homestead ships with a MySQL server built in, so we can use MySQL for our database;
    however, it does require a little bit of configuration first, before we can use
    a MySQL database in our application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Homestead内置了MySQL服务器，因此我们可以使用MySQL作为我们的数据库；然而，在我们可以使用应用程序中的MySQL数据库之前，需要先进行一些配置。
- en: The first step is to open our application's configuration file, which should
    have been created at `.env` when we created the application with Composer. Find
    the line that says `DB_DATABASE=homestead` and change it to `DB_DATABASE=furbook`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是打开我们应用程序的配置文件，该文件应该在用Composer创建应用程序时创建，文件名为`.env`。找到写着`DB_DATABASE=homestead`的那一行，并将其更改为`DB_DATABASE=furbook`。
- en: 'We can also add the database name to our Homestead configuration file, so that
    the database is created automatically for us. Open the file from the command line,
    using the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将数据库名添加到我们的Homestead配置文件中，这样数据库就会自动为我们创建。从命令行打开文件，使用以下命令：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Under the `databases` section, add a new line:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`databases`部分下，添加一行新内容：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Save the file, then run the `homestead provision` command to create the database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，然后运行`homestead provision`命令创建数据库。
- en: Creating Eloquent models
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Eloquent模型
- en: 'The first and easiest step is to define the models with which our application
    is going to interact. At the beginning of this chapter, we identified two main
    entities: *cats* and *breeds*. Laravel ships with Eloquent, a powerful ORM that
    lets you define these entities, map them to their corresponding database tables,
    and interact with them using PHP methods, rather than raw SQL. By convention,
    they are written in the singular form; a model named `Cat` will map to the `cats`
    table in the database, and a hypothetical `Mouse` model will map to the `mice`
    table. You can also manually define the name of the database table using the aptly-named
    `$table` property, in case your table name doesn''t follow the convention expected
    by Laravel:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步也是最简单的一步是定义我们的应用程序将要交互的模型。在本章的开始，我们确定了两个主要实体：*猫*和*品种*。Laravel附带Eloquent，这是一个强大的ORM，允许你定义这些实体，将它们映射到相应的数据库表中，并使用PHP方法而不是原始SQL与之交互。按照惯例，它们以单数形式编写；名为`Cat`的模型将映射到数据库中的`cats`表，一个假设的`Mouse`模型将映射到`mice`表。你也可以使用名为`$table`的属性手动定义数据库表名，以防你的表名不符合Laravel期望的约定：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Cat` model, saved at `app/Cat.php`, will have a `belongsTo` relationship
    with the `Breed` model, which is defined in the following code snippet:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在`app/Cat.php`的`Cat`模型将与`Breed`模型有一个`belongsTo`关系，这在以下代码片段中定义：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `$fillable` array defines the list of fields that Laravel can fill by **mass
    assignment**, which is a convenient way to assign attributes to a model. By convention,
    the column that Laravel will use to find the related model has to be called `breed_id`
    in the database. The `Breed` model, `app/Breed.php`, is defined with the inverse
    `hasMany` relationship as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`$fillable` 数组定义了Laravel可以通过**批量赋值**填充的字段列表，这是一种方便地将属性分配给模型的方法。按照惯例，Laravel将用于查找相关模型的列必须被命名为`breed_id`在数据库中。`Breed`模型，`app/Breed.php`，通过以下方式定义了反向的`hasMany`关系：'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'By default, Laravel expects a `created_at` and `updated_at` timestamp field
    in the database table. Since we are not interested in storing these timestamps
    with the breeds, we disable them in the model by setting the `$timestamps` property
    to `false`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Laravel期望数据库表中有一个`created_at`和`updated_at`的时间戳字段。由于我们对于存储品种的时间戳不感兴趣，我们在模型中将`$timestamps`属性设置为`false`来禁用它们：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is the entire code that is required in our models for now. We will discover
    various other features of Eloquent as we progress in this book; however, in this
    chapter, we will primarily use two methods: `all()` and `find()`. To illustrate
    their purpose, here are the SQL queries that they generate:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们目前模型中所需的所有代码。随着我们在本书中的进展，我们将发现Eloquent的许多其他特性；然而，在本章中，我们将主要使用两种方法：`all()`
    和 `find()`。为了说明它们的目的，以下是它们生成的SQL查询：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The properties of an Eloquent model can be retrieved with the `->` operator:
    `$cat->name`. The same goes for the properties of the related models, which are
    accessible with: `$cat->breed->name`. Behind the scenes, Eloquent will perform
    the necessary SQL joins.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent模型的属性可以通过`->`运算符检索：`$cat->name`。同样，相关模型的属性也可以通过以下方式访问：`$cat->breed->name`。在幕后，Eloquent将执行必要的SQL连接。
- en: Building the database schema
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建数据库模式
- en: 'Now that we have defined our models, we need to create the corresponding database
    schema. Thanks to Laravel''s support for migrations and its powerful schema builder,
    you will not have to write any SQL code and you will also be able to keep track
    of any schema changes in a version control system. To create your first migration,
    open a new terminal window and enter the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的模型，我们需要创建相应的数据库模式。得益于Laravel对迁移和强大的模式构建器的支持，你将不必编写任何SQL代码，你还可以在版本控制系统中跟踪任何模式更改。要创建你的第一个迁移，打开一个新的终端窗口并输入以下命令：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will create a new migration at `database/migrations/`. If you open the
    newly created file, you will find some code that Laravel has generated for you.
    Migrations always have an `up()` and `down()` method that defines the schema changes
    when migrating up or down. Migrating up is modifying the database schema (that
    is, adding a table at a later date), whereas, migrating down is the process of
    undoing that schema change. By convention, the table and field names are written
    in snake_case. Also, the table names are written in plural form.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`database/migrations/`创建一个新的迁移。如果你打开新创建的文件，你会找到Laravel为你生成的某些代码。迁移总是有一个`up()`和`down()`方法，该方法定义了向上迁移或向下迁移时的模式更改。向上迁移是修改数据库模式（即，在以后日期添加一个表），而向下迁移则是撤销该模式更改的过程。按照惯例，表和字段名称以snake_case形式编写。此外，表名以复数形式书写。
- en: 'Our `breeds` table migration will look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`breeds`表迁移将看起来像这样：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can repeat the process to also create our `cats` table schema:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过重复此过程来创建我们的`cats`表模式：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `date()` and `string()` methods create fields with the corresponding types
    (in this case, `DATE` and `VARCHAR`) in the database, `increments()` creates an
    auto-incrementing `INTEGER` primary key, and `timestamps()` adds the `created_at`
    and `updated_at DATETIME` fields that Eloquent expects, by default. The `nullable()`
    method specifies that the column can have `NULL` values.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`date()`和`string()`方法在数据库中创建对应类型的字段（在这种情况下，为`DATE`和`VARCHAR`），`increments()`创建一个自动增长的`INTEGER`主键，而`timestamps()`则添加Eloquent默认期望的`created_at`和`updated_at
    DATETIME`字段。`nullable()`方法指定该列可以具有`NULL`值。'
- en: 'Laravel offers the following methods for defining migrations:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel提供了以下方法来定义迁移：
- en: '| Command | Description |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '| It creates an auto-incrementing big integer column |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个自动增长的整数列 |'
- en: '|'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '| It creates a `BIGINT` column |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个`BIGINT`列 |'
- en: '|'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '| It creates a `BLOB` column |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个`BLOB`列 |'
- en: '|'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '| It creates a `BOOLEAN` column |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个`BOOLEAN`列 |'
- en: '|'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '| It creates a `CHAR` column with the given length |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个指定长度的`CHAR`列 |'
- en: '|'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| It creates a `DATE` column |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个`DATE`列 |'
- en: '|'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '| It creates a `DATETIME` column |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个`DATETIME`列 |'
- en: '|'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '| It creates a `DECIMAL` column with the given precision and scale |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个具有指定精度和小数的`DECIMAL`列 |'
- en: '|'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '| It creates a `DOUBLE` column, with 10 digits in total and 5 after the decimal
    point |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个带有10位总数和5位小数点的`DOUBLE`列 |'
- en: '|'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '| It creates an `ENUM` column |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个`ENUM`列 |'
- en: '|'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '| It creates a `FLOAT` column |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个`FLOAT`列 |'
- en: '|'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '| It creates an auto-incrementing integer column |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个自动增长的整数列 |'
- en: '|'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '| It creates an `INTEGER` column |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个`INTEGER`列 |'
- en: '|'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '| It creates a `JSON` column |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个`JSON`列 |'
- en: '|'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '| It creates a `LONGTEXT` column |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个`LONGTEXT`列 |'
- en: '|'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '| It creates a `MEDIUMINT` column |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个`MEDIUMINT`列 |'
- en: '|'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '| It creates a `MEDIUMTEXT` column |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个`MEDIUMTEXT`列 |'
- en: '|'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '| It creates two columns: `INTEGER taggable_id` and `STRING taggable_type`
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了两个列：`INTEGER taggable_id`和`STRING taggable_type` |'
- en: '|'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '| This is similar to timestamps (next), but allows `NULL` values |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 这与时间戳（下一节）类似，但允许`NULL`值 |'
- en: '|'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '| It adds a `remember_token VARCHAR` column |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 它添加了一个`remember_token VARCHAR`列 |'
- en: '|'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '| It creates a `TINYINT` column |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个`TINYINT`列 |'
- en: '|'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '| It adds a `deleted_at` column for soft deletes |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 它添加了一个用于软删除的`deleted_at`列 |'
- en: '|'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '| It creates a `VARCHAR` column |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个`VARCHAR`列 |'
- en: '|'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '| It creates a `VARCHAR` column of the given length |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个指定长度的`VARCHAR`列 |'
- en: '|'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '| It creates a `TEXT` column |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个`TEXT`列 |'
- en: '|'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '| It creates a `TIME` column |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个`TIME`列 |'
- en: '|'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '| It creates a `TIMESTAMP` column |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了一个`TIMESTAMP`列 |'
- en: '|'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '| It creates `created_at` and `deleted_at` columns |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 它创建了`created_at`和`deleted_at`列 |'
- en: We've also created a foreign key in the `cats` migration. This links the `breed_id`
    column value to an ID in the `breeds` table. This is so that we don't have to
    keep specifying the breed name over and over again. We can just reference one
    record in the `breeds` table. If that record is updated, then all `cats` linked
    to it will also be updated.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`cats`迁移中创建了一个外键。这会将`breed_id`列的值链接到`breeds`表中的一个ID。这样我们就不必反复指定品种名称。我们只需引用`breeds`表中的一条记录。如果该记录被更新，那么所有链接到它的`cats`也会被更新。
- en: 'To run both of the migrations, enter the following command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这两个迁移，请输入以下命令：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When it is run for the first time, this command will also create a `migrations`
    table that Laravel will use to keep track of the migrations that have been run.
    It will then run any outstanding migrations. On subsequent runs, the command will
    use the `migrations` table to determine if any migration files need running, and
    run them, if so.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当它第一次运行时，此命令还将创建一个`migrations`表，Laravel将使用它来跟踪已运行的所有迁移。然后它将运行任何未完成的迁移。在随后的运行中，命令将使用`migrations`表来确定是否有需要运行的迁移文件，如果有，则运行它们。
- en: We created our `breeds` table migration before the `cats` table migration because
    we have a **foreign key** in our `cats` table. If we were to try and create the
    `cats` table first, it will fail as the column it is referencing does not exist
    yet.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`cats`表迁移之前创建了我们的`breeds`表迁移，因为我们`cats`表中有一个**外键**。如果我们尝试首先创建`cats`表，它将失败，因为它引用的列尚不存在。
- en: Seeding the database
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化数据库
- en: 'Rather than manually populating our database, we can use the seeding helpers
    offered by Laravel. This time, there is no Artisan command to generate the file,
    but all we need to do is create a new class called `BreedsTableSeeder.php` at
    `database/seeds/`. This class extends Laravel''s `Seeder` class and defines the
    following `run()` method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是手动填充我们的数据库，我们可以使用Laravel提供的初始化助手。这次，没有Artisan命令来生成文件，我们只需要在`database/seeds/`中创建一个名为`BreedsTableSeeder.php`的新类。这个类扩展了Laravel的`Seeder`类，并定义了以下`run()`方法：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You can bulk insert an array but you can also insert arbitrary code in the `run()`
    method to load data from say, a CSV or JSON file. There are also third-party libraries
    that can help you generate large amounts of test data to fill your database, such
    as the excellent Faker.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`run()`方法中批量插入一个数组，也可以插入任意代码来从CSV或JSON文件加载数据。还有第三方库可以帮助你生成大量测试数据来填充你的数据库，例如出色的Faker。
- en: 'To control the order of execution of the seeders, Laravel lets you call them
    individually at `database/seeds/DatabaseSeeder.php`. In our case, since we only
    have one seeder, all we need to write is the following line:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制初始化器的执行顺序，Laravel允许你在`database/seeds/DatabaseSeeder.php`中单独调用它们。在我们的情况下，因为我们只有一个初始化器，我们只需要写以下这一行：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, we can seed the database by calling it, using the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过调用它来初始化数据库，使用以下命令：
- en: '[PRE51]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Seeding is good for initially populating a database. If we were to re-run the
    seed command, we would actually get an error as we're defining primary keys for
    our records; if we tried re-seeding, the database will trigger a duplicate primary
    key error. We can first truncate the table, but this will be dangerous if deployed
    to a production environment, as it will delete any user-contributed records, as
    well as your seed data definitions!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化对于最初填充数据库很有用。如果我们重新运行种子命令，实际上会得到一个错误，因为我们正在为我们的记录定义主键；如果我们尝试重新初始化，数据库将触发重复主键错误。我们可以首先截断表，但这在生产环境中部署时将是危险的，因为它将删除任何用户贡献的记录，以及你的种子数据定义！
- en: Mastering Blade
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握Blade
- en: 'Now that we have some information in our database, we need to define the templates
    that are going to display it. Blade is Laravel''s lightweight template language
    and its syntax is very easy to learn. Here are some examples of how Blade can
    reduce the number of keystrokes and increase the readability of your templates:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在数据库中有了一些信息，我们需要定义将要显示这些信息的模板。Blade是Laravel的轻量级模板语言，其语法非常容易学习。以下是一些Blade如何减少按键次数并提高模板可读性的示例：
- en: '| Standard PHP syntax | Blade syntax |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 标准PHP语法 | Blade语法 |'
- en: '| --- | --- |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE52]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '|'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE53]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '|'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE54]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '|'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '|'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '|'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '|'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If you use the default double braces notation, then variables are escaped. This
    is to protect against XSS vulnerabilities (explained in more detail in [Chapter
    7](ch07.html "Chapter 7. Authentication and Security"), *Authentication and Security*).
    If you really need the raw value of variable un-escaped, then you can use single
    braces, with two exclamation marks inside on each side. You should only do this
    if you trust the value that the variable contains.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用默认的双大括号表示法，那么变量会被转义。这是为了防止XSS漏洞（在[第7章](ch07.html "第7章。认证和安全")中详细解释，*认证和安全*）。如果你确实需要未转义的变量原始值，那么你可以使用单大括号，并在每侧内部使用两个感叹号。你应该只在信任变量包含的值时这样做。
- en: 'Blade also supports all of PHP''s major constructs to create loops and conditions:
    `@for`, `@foreach`, `@while`, `@if`, and `@elseif`, allowing you to avoid opening
    and closing the `<?php` tags everywhere in your templates.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Blade 还支持 PHP 的所有主要结构来创建循环和条件：`@for`、`@foreach`、`@while`、`@if` 和 `@elseif`，允许您在模板的任何地方避免打开和关闭
    `<?php` 标签。
- en: Creating a master view
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建主视图
- en: Blade lets you build hierarchical layouts by allowing the templates to be nested
    and extended. The following code snippet is the **master** template that we are
    going to use for our application. We will save it as `resources/views/layouts/master.blade.php`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Blade 允许您通过允许模板嵌套和扩展来构建分层布局。以下代码片段是我们将要用于我们应用程序的 **master** 模板。我们将将其保存为 `resources/views/layouts/master.blade.php`。
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The Bootstrap CSS framework is included to speed up the prototyping of the application
    interface. You can download it from [http://getbootstrap.com](http://getbootstrap.com)
    and place the minified CSS file at `public/css/`. To ensure that its path prefix
    is set correctly, even when Laravel is run from a subfolder, we use the `asset()`
    helper. You can see the complete list of Blade template helpers that are available
    to you, visit [http://laravel.com/docs/helpers](http://laravel.com/docs/helpers).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap CSS 框架被包含进来以加快应用程序界面的原型设计。您可以从 [http://getbootstrap.com](http://getbootstrap.com)
    下载它，并将压缩后的 CSS 文件放置在 `public/css/` 目录下。为了确保其路径前缀设置正确，即使 Laravel 从子目录运行，我们使用 `asset()`
    辅助函数。您可以通过访问 [http://laravel.com/docs/helpers](http://laravel.com/docs/helpers)
    来查看您可用的完整的 Blade 模板辅助函数列表。
- en: To inform the user about the outcome of certain actions, we have prepared a
    notification area between the header and the page content. This **flash data**
    (in other words, the session data that is only available for the next request)
    is passed and retrieved to and from the `Session` object.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通知用户某些操作的结果，我们在页眉和页面内容之间准备了一个通知区域。这个 **flash data**（换句话说，仅对下一个请求可用的会话数据）是通过
    `Session` 对象传递和检索的。
- en: 'The `@yield` directives act as placeholders for the different sections that
    a child view can populate and override. To see how a child template can re-use
    them, we are going to recreate the `about` view by changing its extension to `.blade.php`
    and extending our `master` layout template instead:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`@yield` 指令充当子视图可以填充和覆盖的不同部分的占位符。为了了解子模板如何重用它们，我们将通过将其扩展名更改为 `.blade.php` 并扩展我们的
    `master` 布局模板来重新创建 `about` 视图：'
- en: '[PRE59]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `@section ... @stop` directives delimit the blocks of content that are
    going to be injected into the master template. You can see how this is done in
    the following diagram:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`@section ... @stop` 指令定义了将要注入到主模板中的内容块。您可以在以下图表中看到这是如何完成的：'
- en: '![Creating a master view](img/B04308_03_01.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![创建主视图](img/B04308_03_01.jpg)'
- en: If you now reopen the `/about` route in your web browser, without changing anything
    in your previous route definition, you will see the new view. Laravel's view finder
    will simply use the new file, and since its name ends with `.blade.php`, treat
    it like a Blade template.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在在您的网络浏览器中重新打开 `/about` 路由，而不更改您之前的路由定义，您将看到新的视图。Laravel 的视图查找器将简单地使用新文件，并且由于它的名称以
    `.blade.php` 结尾，所以将其视为 Blade 模板。
- en: Back to the routes
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回到路由
- en: Now that we have a main layout template that we can extend and re-use, we can
    start to create the individual routes of our application at `app/Http/routes.php`,
    along with the different views that will display the application data.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以扩展和重用的主布局模板，我们就可以开始在 `app/Http/routes.php` 中创建我们应用程序的各个路由，以及将显示应用程序数据的不同视图。
- en: The overview page
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概览页面
- en: 'This is the *index* page that is going to display all of the cats using the
    `cats.index` view. We will also re-use this view for the second route where cats
    are filtered by breed, since both the routes are almost identical. Note that Laravel
    expects you to use the dot notation (`cats.index` and not `cats/index`) to refer
    to a view located inside a subdirectory:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将要显示所有猫的 *index* 页面，我们将使用 `cats.index` 视图来重用这个视图，因为这两个路由几乎相同。请注意，Laravel 预期您使用点表示法（`cats.index`
    而不是 `cats/index`）来引用位于子目录中的视图：
- en: '[PRE60]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The only novelty in these routes is the slightly more advanced Eloquent queries.
    While we already know that the `all()` method in the first route loads all of
    the entries from the `cats` table, the second route uses a more complex query.
    The `with('cats')` method will load any related `cat` models. The `whereName`
    is a dynamic method that creates a `WHERE` SQL clause, which will translate to
    `WHERE name = $name`. The long-hand expression of this will be `where('name',
    '=', $name)`. Finally, we fetch the first breed record (and related cat models)
    with the `first()` method.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路由的唯一新特性是稍微更高级的Eloquent查询。虽然我们已经知道第一个路由中的 `all()` 方法从 `cats` 表中加载所有条目，但第二个路由使用了一个更复杂的查询。`with('cats')`
    方法将加载任何相关的 `cat` 模型。`whereName` 是一个动态方法，它创建一个 `WHERE` SQL子句，这将转换为 `WHERE name
    = $name`。这个长表达式将是 `where('name', '=', $name)`。最后，我们使用 `first()` 方法获取第一个品种记录（和相关猫模型）。
- en: 'The template, saved at `cats/index.blade.php`, will look like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 保存于 `cats/index.blade.php` 的模板将看起来像这样：
- en: '[PRE61]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: With the help of a `foreach` loop, the view iterates over the list of cats that
    it received from the route. Since we will be using this view to display both the
    index page (`/cats`) as well as the breed overview page (`/cats/breeds/{breed}`),
    we used the `@if` directives in two places to conditionally display more information.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `foreach` 循环，视图遍历从路由接收到的猫列表。由于我们将使用此视图来显示索引页面（`/cats`）以及品种概述页面（`/cats/breeds/{breed}`），我们在两个地方使用了
    `@if` 指令来条件性地显示更多信息。
- en: Displaying a cat's page
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示猫的页面
- en: 'The next route is used to display a single cat. To find a cat by its ID, we
    use Eloquent''s `find()` method:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个路由用于显示单个猫。要按其ID查找猫，我们使用Eloquent的 `find()` 方法：
- en: '[PRE62]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Route-model binding
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由模型绑定
- en: 'Route-model binding is the method of automatically transforming a route parameter
    to a model instance, so we don''t have to manually retrieve the model. Since this
    is such a common pattern, Laravel provides you with a way to automatically bind
    a model to a route and, therefore, make your code shorter and more expressive.
    To bind the `$cat` variable to the `Cat` model, open `app/Providers/RouteServiceProvider.php`.
    Modify the `boot()` method so that it looks like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 路由模型绑定是将路由参数自动转换为模型实例的方法，因此我们不必手动检索模型。由于这是一个非常常见的模式，Laravel为你提供了一个自动将模型绑定到路由的方法，因此可以使你的代码更短、更易于表达。要将
    `$cat` 变量绑定到 `Cat` 模型，打开 `app/Providers/RouteServiceProvider.php`。修改 `boot()`
    方法，使其看起来像这样：
- en: '[PRE63]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This allows you to shorten your route and pass a `Cat` object to it instead:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你缩短路由，并将一个 `Cat` 对象传递给它：
- en: '[PRE64]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The view, `cats/show.blade.php`, does not contain any new directives. It simply
    displays the name of the cat with the links to edit or delete it. In the `content`
    section, we return its age and breed if the breed is set; this is shown in the
    following snippet:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 视图 `cats/show.blade.php` 不包含任何新的指令。它只是显示猫的名字，并提供编辑或删除的链接。在 `content` 部分，如果设置了品种，我们返回其年龄和品种；这将在以下代码片段中显示：
- en: '[PRE65]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Adding, editing, and deleting cats
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加、编辑和删除猫
- en: The next series of routes and views will be used to create, edit, and delete
    a cat page.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个系列的路由和视图将用于创建、编辑和删除一个猫页面。
- en: Until version 5, Laravel came with a package for creating common HTML and form
    elements. In Laravel 5 applications, we need to bring this package back into use.
    We do this via Composer.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 直到版本5，Laravel附带了一个用于创建常见HTML和表单元素的包。在Laravel 5应用程序中，我们需要将此包重新投入使用。我们通过Composer来完成此操作。
- en: 'In the `require` section of `composer.json`, add the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `composer.json` 的 `require` 部分添加以下代码：
- en: '[PRE66]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then run `$ composer update`. This will install the package. Next, we need
    to register the service provider and façades. Open `config/app.php` and add the
    following the `$providers` array:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行 `$ composer update`。这将安装该包。接下来，我们需要注册服务提供者和外观。打开 `config/app.php` 并将以下内容添加到
    `$providers` 数组中：
- en: '[PRE67]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then add the following two lines to the `$facades` array:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将以下两行添加到 `$facades` 数组中：
- en: '[PRE68]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This now gives us a lot of helpful methods with which to build forms in our
    templates.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在为我们提供了许多有用的方法，我们可以用这些方法在我们的模板中构建表单。
- en: Although Blade templates are hierarchical, it is still possible to include other
    templates in views, as you may be used to doing with the `include()` or `require()`
    functions in PHP. We will use this to share the form fields needed for both the
    create and edit templates.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Blade模板是分层的，但在视图中仍然可以包含其他模板，就像你可能习惯于使用PHP中的 `include()` 或 `require()` 函数一样。我们将使用此功能来共享创建和编辑模板所需的形式字段。
- en: 'In `resources/views/partials/forms/cat.blade.php`, add the following content:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `resources/views/partials/forms/cat.blade.php` 中添加以下内容：
- en: '[PRE69]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `Form::select()` helper builds a `<select>` dropdown with the different
    choices. It expects the list of choices to be passed to a multidimensional array.
    Rather than binding this array to each route, we can use **view composers**, another
    feature of Laravel, which allows you to bind a variable to a specific view each
    time.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`Form::select()`辅助函数构建一个包含不同选择的`<select>`下拉菜单。它期望将选择列表传递到一个多维数组中。我们不需要将此数组绑定到每个路由，可以使用Laravel的另一个特性——视图组合器，它允许你每次将一个变量绑定到特定的视图。'
- en: 'We can initialize a view composer by adding it to our application''s service
    provider. Open `app/Providers/AppServiceProvider.php` and change the `boot()`
    method to look like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将其添加到应用程序的服务提供者中来初始化一个视图组合器。打开`app/Providers/AppServiceProvider.php`并修改`boot()`方法，使其看起来像这样：
- en: '[PRE70]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We also need to resolve `ViewFactory`. At the top of the file, underneath the
    namespace declaration, add the following line:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要解析`ViewFactory`。在文件顶部，在命名空间声明之下，添加以下行：
- en: '[PRE71]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We now need to create the actual view composer class. We''ve specified the
    path, so let''s create the file and add the following code to it:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建实际的视图组合器类。我们已经指定了路径，所以让我们创建文件并添加以下代码到其中：
- en: '[PRE72]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now when the `partials.forms.cat` template partial is called, the view composer
    kicks in. When Laravel instantiates it, it'll read the constructor and automatically
    inject instances of the specified types. In our view composer's constructor, we
    specify that we need an instance of our `Breed` model, and then store the instance
    as a class property.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当调用`partials.forms.cat`模板部分时，视图组合器开始工作。当Laravel实例化它时，它会读取构造函数并自动注入指定类型的实例。在我们的视图组合器构造函数中，我们指定需要一个`Breed`模型实例，然后将该实例存储为类属性。
- en: Once the view composer has been initialized, the `compose()` method is called.
    This is where the actual binding of data to the view occurs. As our model is an
    Eloquent model, we can use the `lists()` method that fetches all records in an
    associative array, which is just what we need for our `select` list. The first
    parameter is the value that the user will see (the breed name in this instance)
    and the second parameter is what will be used as the `value` attribute in the
    `<option>` tag (the breed ID).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦视图组合器初始化完成，就会调用`compose()`方法。这是数据绑定到视图的实际发生之处。由于我们的模型是Eloquent模型，我们可以使用`lists()`方法来获取所有记录的关联数组，这正是我们为我们的`select`列表所需要的。第一个参数是用户将看到的值（在这个例子中是品种名称）和第二个参数是将在`<option>`标签中用作`value`属性的值（品种ID）。
- en: Now that we have a partial form with breed options automatically being injected
    when requested, we can continue on with building the create, edit, and delete
    views.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个部分表单，当请求时自动注入品种选项，我们可以继续构建创建、编辑和删除视图。
- en: 'The create view is straightforward: we extend out master layout, open our form,
    and then include the partial we''ve just created. In `resources/views/cats/create.blade.php`,
    add the following code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 创建视图很简单：我们扩展主布局，打开表单，然后包含我们刚刚创建的部分。在`resources/views/cats/create.blade.php`中添加以下代码：
- en: '[PRE73]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The edit template (`resources/views/cats/edit.blade.php`) will look similar,
    barring a few small changes:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑模板（`resources/views/cats/edit.blade.php`）看起来类似，除了几个小的改动：
- en: '[PRE74]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We didn't include the opening and closing form tags in the partial, as we need
    to change the action URL and method depending on the action. Also, in the edit
    template, we're using form-model binding to bind the `Cat` instance passed to
    our template, to the form. This automatically populates the values of the form
    fields with the value of the attributes in our `Cat` model instance.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在部分视图中，我们没有包含开始和结束的表单标签，因为我们需要根据操作改变动作URL和方法。此外，在编辑模板中，我们使用表单模型绑定将传递给模板的`Cat`实例绑定到表单上。这会自动将表单字段的值填充为我们的`Cat`模型实例中的属性值。
- en: 'Now that we have our views, we can create the corresponding routes:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了视图，我们可以创建相应的路由：
- en: '[PRE75]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You might have noticed that a new method `withSuccess()` is being used in the
    preceding routes in conjunction with our redirects. This isn't an explicitly defined
    method; instead, it is an example of **overloading** in Laravel. In the context
    of redirects, Laravel looks at method calls that have `with` in the beginning;
    it takes the latter part and assigns it to the session flash data. This includes
    the session variables that will be available in the next request, and the next
    request only. This makes it perfect for single-use data such as success messages,
    as we have seen earlier.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在先前的路由中，正在使用一个新的方法`withSuccess()`与我们的重定向一起使用。这不是一个明确定义的方法；相反，它是Laravel中**重载**的一个例子。在重定向的上下文中，Laravel查看以`with`开头的调用方法；它将后一部分分配给会话闪存数据。这包括将在下一个请求中可用的会话变量，以及下一个请求仅有的变量。这使得它非常适合像成功消息这样的单次使用数据，正如我们之前所看到的。
- en: If you look back at our master layout template, you can see the provision we
    have to check for any session variables with the key `success`; if it exists,
    we simply display it in a Bootstrap success alert.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回顾我们的主布局模板，您可以看到我们提供了检查具有键`success`的任何会话变量的方法；如果存在，我们只需在Bootstrap成功警报中显示它。
- en: Any input data that is received by the application and that you would normally
    access via the `$_GET` or `$_POST` variables is instead retrievable by using the
    `Input::get()` method. It is also possible to retrieve an array of all the input
    data with `Input::all()`. In the `POST /cats` and `PUT /cats/{cat}` routes respectively,
    we use the `create()` and `update()` methods from Eloquent with `Input::all()`
    as their argument. This is only possible because we specified the fields that
    are fillable in the `Cat` model beforehand.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序接收到的任何输入数据，您通常通过`$_GET`或`$_POST`变量访问，现在可以通过使用`Input::get()`方法检索。您还可以使用`Input::all()`检索所有输入数据的数组。在`POST
    /cats`和`PUT /cats/{cat}`路由中，我们分别使用Eloquent的`create()`和`update()`方法，并将`Input::all()`作为它们的参数。这仅因为我们之前在`Cat`模型中指定了可填充的字段。
- en: We now have a working application where users can add, edit, and delete cats.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以工作的应用程序，用户可以添加、编辑和删除猫。
- en: Moving from simple routing to powerful controllers
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从简单路由到强大的控制器
- en: So far, we have been creating **closure-based routes**. This is great for quickly
    prototyping applications, and is prevalent in micro-frameworks such as **Silex**
    and **Slim**; however, as your application grows, this approach might become cumbersome
    and limiting. The alternative (and recommended) approach to defining the logic
    to be executed when a route is requested is in controllers, the C in MVC.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在创建**基于闭包的路由**。这对于快速原型设计应用程序来说很棒，在像**Silex**和**Slim**这样的微框架中很常见；然而，随着应用程序的增长，这种方法可能会变得繁琐和限制。定义当请求路由时要执行的逻辑的替代（且推荐）方法是使用控制器，即MVC中的C。
- en: A controller is usually a class, containing one or more methods, also known
    as **actions**. You usually have a route map to a controller action.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器通常是一个类，包含一个或多个方法，也称为**动作**。您通常有一个路由映射到控制器动作。
- en: 'Consider the following example:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE76]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To achieve the same functionality with a controller and remove the business
    logic from the routes, create a new file at `app/Http/Controllers/UserController.php`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用控制器实现相同的功能并从路由中删除业务逻辑，请在新文件`app/Http/Controllers/UserController.php`中创建：
- en: '[PRE77]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This approach can greatly improve the reusability and testability of your code,
    especially if your theoretical `doSomething()` method is used in more than one
    controller action. You can test it just once in isolation, and then rely on it.
    When you venture into more advanced topics such as dependency injection, you can
    even swap entire classes when you instantiate the controller, but we will not
    cover this here.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以大大提高代码的可重用性和可测试性，特别是如果您的理论`doSomething()`方法在多个控制器动作中使用。您可以在隔离的情况下测试它一次，然后依赖它。当您进入更高级的主题，如依赖注入时，您甚至可以在实例化控制器时替换整个类，但这里我们不会涉及这一点。
- en: 'Finally, to tell Laravel which controller action to use, simply rewrite the
    route declaration as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了告诉Laravel使用哪个控制器动作，只需将路由声明重写如下：
- en: '[PRE78]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The root controller namespace (`App\Http\Controllers`) is automatically prepended
    to the controller class name to avoid the task of specifying it for each and every
    route.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 根控制器命名空间（`App\Http\Controllers`）自动添加到控制器类名之前，以避免为每个路由指定它的任务。
- en: Resource controllers
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源控制器
- en: 'Laravel greatly simplifies the creation of REST APIs with resource controllers.
    Since they adhere to conventions, there is only a limited defined set of actions
    that can be performed from the controller. In fact, all the routes we created
    earlier can be rewritten as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel通过资源控制器极大地简化了REST API的创建。由于它们遵循约定，因此从控制器中可以执行的操作集合是有限的。实际上，我们之前创建的所有路由都可以重写如下：
- en: '[PRE79]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This will register the following routes:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这将注册以下路由：
- en: '| Verb | Path | Action | Route Name |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 动词 | 路径 | 操作 | 路由名称 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `GET` | `/cat` | index | `cat.index` |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/cat` | 列表 | `cat.index` |'
- en: '| `GET` | `/cat/create` | create | `cat.create` |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/cat/create` | 创建 | `cat.create` |'
- en: '| `POST` | `/cat` | store | `cat.store` |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/cat` | 存储 | `cat.store` |'
- en: '| `GET` | `/cat/{id}` | show | `cat.show` |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/cat/{id}` | 显示 | `cat.show` |'
- en: '| `GET` | `/cat/{id}/edit` | edit | `cat.edit` |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/cat/{id}/edit` | 编辑 | `cat.edit` |'
- en: '| `PUT/PATCH` | `/cat/{id}` | update | `cat.update` |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `PUT/PATCH` | `/cat/{id}` | 更新 | `cat.update` |'
- en: '| `DELETE` | `/cat/{id}` | destroy | `cat.destroy` |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `/cat/{id}` | 删除 | `cat.destroy` |'
- en: 'Then, in your `CatController` class, you will have all of the different actions:
    `index`, `create`, `show`, `edit`, and so on. These will then be wired up to respond
    to the correct route and HTTP verb.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你的`CatController`类中，你将拥有所有不同的操作：`index`、`create`、`show`、`edit`等等。这些操作将被连接到正确的路由和HTTP动词。
- en: 'You can create a stub resource controller with the following Artisan command:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下Artisan命令创建一个资源控制器存根：
- en: '[PRE80]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Why not try re-writing the closure-based route actions into your new `CatController`
    class?
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不尝试将基于闭包的路由操作重写为你的新`CatController`类呢？
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered a lot in this chapter. You learned how to define routes, prepare
    the models of the application, and interact with them. Moreover, we have had a
    glimpse at the many powerful features of Eloquent, Blade, as well as the other
    convenient helpers in Laravel to create forms and input fields—all of this in
    under 200 lines of code!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涵盖了大量的内容。你学习了如何定义路由、准备应用程序的模型以及与之交互。此外，我们还对Eloquent、Blade以及其他Laravel中方便的辅助功能进行了简要了解，这些功能可以帮助创建表单和输入字段——所有这些都在200行代码以下完成！
- en: In the next chapter, you will learn more about Laravel's powerful ORM, Eloquent,
    which allows you to perform powerful database queries without writing a line of
    SQL.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解更多关于Laravel强大ORM，Eloquent的信息，它允许你无需编写一行SQL语句即可执行强大的数据库查询。
