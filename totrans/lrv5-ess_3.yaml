- en: Chapter 3. Your First Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having learned about Laravel's conventions, working with dependencies using
    Composer, and setting up a development environment with Homestead, you are now
    ready to build your first application!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will use the concepts presented in the previous two chapters
    in a practical way and learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Plan the URLs and entities of your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshoot common issues when getting started
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define routes and their actions, as well as models and their relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prepare your database and learn how to interact with it using Eloquent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Blade template language to create hierarchical layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first step in creating a web application is to identify and define its requirements.
    Then, once the main features have been decided, we derive the main entities as
    well as the URL structure of the application. Having a well-defined set of requirements
    and URLs is also essential for other tasks such as testing; this will be covered
    later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of new concepts are presented in this chapter. If you have trouble understanding
    something or if you are not quite sure where to place a particular snippet of
    code, you can download the annotated source code of the application from [http://packtpub.com/support](http://packtpub.com/support),
    which will help you to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: Planning our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to build a browsable database of cat profiles. Visitors will be
    able to create pages for their cats and fill in basic information such as the
    name, date of birth, and breed of each cat. This application will implement the
    default **Create-Retrieve-Update-Delete** (**CRUD**) operations. We will also
    create an overview page with the option to filter cats by breed. All of the security,
    authentication, and permission features are intentionally left out, since they
    will be covered in the further chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Entities, relationships, and attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, we need to define the *entities* of our application. In broad terms,
    an entity is a thing (person, place, or object) about which the application should
    store data. From the requirements, we can extract the following entities and attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cats**: They have a numeric identifier, a name, a date of birth, and a breed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Breeds**: They only have an identifier and a name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This information will help us when defining the database schema that will store
    the entities, relationships, attributes, as well as the models, which are the
    PHP classes that represent the objects in our database.
  prefs: []
  type: TYPE_NORMAL
- en: The map of our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now need to think about the URL structure of our application. Having clean
    and expressive URLs has many benefits. On a usability level, the application will
    be easier to navigate and will look less intimidating to the user (descriptive
    URLs look far more appealing than a lengthy query string). For frequent users,
    individual pages will be easier to remember or bookmark and, if they contain relevant
    keywords, they will often rank higher in search engine results.
  prefs: []
  type: TYPE_NORMAL
- en: To fulfill the initial set of requirements, we are going to need the following
    routes in our application. A route is a URL and HTTP method to which the application
    will respond.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Route | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/` | Index |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/cats` | Overview page |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/cats/breeds/:name` | Overview page for specific breed |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/cats/:id` | Individual cat page |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/cats/create` | Form to create a new cat page |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/cats` | Handle creation of new cat page |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/cats/:id/edit` | Form to edit existing cat page |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `/cats/:id` | Handle updates to cat page |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/cats/:id/delete` | Form to confirm deletion of page |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `/cats/:id` | Handle deletion of cat page |'
  prefs: []
  type: TYPE_TB
- en: 'You will shortly learn how Laravel helps us to turn this routing sketch into
    actual code. If you have written PHP applications without a framework, you can
    briefly reflect on how you would have implemented such a routing structure. To
    add some perspective, this is what the second to last URL could have looked like
    with a traditional PHP script (without URL rewriting): `/index.php?p=cats&id=1&_action=delete&confirm=true`.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding table can be prepared using a pen and paper, in a spreadsheet
    editor, or even in your favorite code editor, using ASCII characters. In the initial
    development phases, this table of routes is an important prototyping tool that
    makes you to think about URLs first and helps you define and refine the structure
    of your application iteratively.
  prefs: []
  type: TYPE_NORMAL
- en: If you have worked with REST APIs, this kind of routing structure will look
    familiar to you. In RESTful terms, we have a `cats` resource that responds to
    the different HTTP verbs and provides an additional set of routes to display the
    necessary forms.
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, you have not worked with RESTful sites, the use of the
    `PUT` and `DELETE` HTTP methods might be new to you. Even though web browsers
    do not support these methods for standard HTTP requests, Laravel uses a technique
    that other frameworks such as Rails use, and emulates those methods by adding
    a `_method` input field to the forms. This way, they can be sent over a standard
    `POST` request and are then delegated to the correct route or controller method
    in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note also that none of the form submissions endpoints are handled with a `GET`
    method. This is primarily because they have side effects; a user can trigger the
    same action multiple times accidentally when using the browser history. Therefore,
    when they are called, these routes never display anything to the users. Instead,
    they redirect them after completing the action (for instance, `DELETE /cats/:id`
    will redirect the user to `GET /cats`).
  prefs: []
  type: TYPE_NORMAL
- en: Starting the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the blueprints for the application, let's roll up our sleeves
    and start writing some code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening a new terminal window and launch Homestead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to the directory you have mapped to Homestead (by default this is
    `~/Code`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use Composer to create a new Laravel project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once Composer finishes downloading Laravel and resolving its dependencies, you
    will have a directory structure identical to the one presented in the first chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the application namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Applications in Laravel are namespaced. By default, this is just `App`—Laravel''s
    great, but it still can''t guess the name of your application! To set it to something
    more appropriate, we can use the Artisan command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will update our application's namespace to be `Furbook` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the first routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by writing the first two routes of our application at `app/Http/routes.php`.
    This file already contains some comments as well as a couple of sample routes.
    Remove the existing routes (but leave the opening `<?php` declaration) before
    adding the following routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter of the `get` method is the URI pattern. When a pattern is
    matched, the closure function in the second parameter is executed with any parameters
    that were extracted from the pattern. Note that the slash prefix in the pattern
    is optional; however, you should not have any trailing slashes. You can make sure
    that your routes work by opening your web browser and visiting `http://dev.furbook.com/cats/123`.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting the route parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the pattern of the second route, `{id}` currently matches any string or
    number. To restrict it so that it only matches numbers, we can chain a `where`
    method to our route as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `where` method takes two arguments: the first one is the name of the parameter
    and the second one is the regular expression pattern that it needs to match.'
  prefs: []
  type: TYPE_NORMAL
- en: If you now try to visit an invalid URL, nginx (the server software serving the
    application) will display a **404 Not Found** error page.
  prefs: []
  type: TYPE_NORMAL
- en: Handling HTTP exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an error occurs in your application, Laravel raises an exception. This
    is also true for HTTP errors, as Laravel will raise an appropriate HTTP exception.
    Usually when an HTTP error occurs, you will want to display a response informing
    the user what went wrong. This is easy in Laravel 5, as all you need to do is
    create a view named after the HTTP status code you want it to display for in the
    `resources/views/errors` directory.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you wanted to display a view for **404 Not Found** errors, then
    all you need to do is create a view at `resources/views/errors/404.blade.php`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use this approach to handle other HTTP errors as well, such as **403
    Forbidden** errors; simply create a view at `resources/views/errors/403.blade.php`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll cover views later on in this chapter. In the meantime, you can find a
    list of HTTP status codes at [http://en.wikipedia.org/wiki/List_of_HTTP_status_codes](http://en.wikipedia.org/wiki/List_of_HTTP_status_codes).
  prefs: []
  type: TYPE_NORMAL
- en: Performing redirections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is also possible to redirect visitors using the `redirect()` helper in your
    routes. If, for example, we wanted everyone to be redirected to `/cats` when they
    visit the application for the first time, we would write the following lines of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create the route for the URL we''re redirecting to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Returning views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most frequent object that you will return from your routes is the `View`
    object. Views receive data from a route (or controller action) and inject it into
    a template, therefore helping you to separate the business and presentation logic
    in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add your first view, simply create a file called `about.php` at `resources/views`
    and add the following content to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, return the view using the `view()` helper function with the variable,
    `$number_of_cats`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Finally, visit `/about` in your browser to see the rendered view. This view
    was written with plain PHP; however, Laravel comes with a powerful template language
    called Blade, which will be introduced later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can expand the functionality of our routes, we need to define the
    models of our application, prepare the necessary database schema, and populate
    the database with some initial data.
  prefs: []
  type: TYPE_NORMAL
- en: Homestead ships with a MySQL server built in, so we can use MySQL for our database;
    however, it does require a little bit of configuration first, before we can use
    a MySQL database in our application.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to open our application's configuration file, which should
    have been created at `.env` when we created the application with Composer. Find
    the line that says `DB_DATABASE=homestead` and change it to `DB_DATABASE=furbook`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add the database name to our Homestead configuration file, so that
    the database is created automatically for us. Open the file from the command line,
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the `databases` section, add a new line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Save the file, then run the `homestead provision` command to create the database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Eloquent models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first and easiest step is to define the models with which our application
    is going to interact. At the beginning of this chapter, we identified two main
    entities: *cats* and *breeds*. Laravel ships with Eloquent, a powerful ORM that
    lets you define these entities, map them to their corresponding database tables,
    and interact with them using PHP methods, rather than raw SQL. By convention,
    they are written in the singular form; a model named `Cat` will map to the `cats`
    table in the database, and a hypothetical `Mouse` model will map to the `mice`
    table. You can also manually define the name of the database table using the aptly-named
    `$table` property, in case your table name doesn''t follow the convention expected
    by Laravel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Cat` model, saved at `app/Cat.php`, will have a `belongsTo` relationship
    with the `Breed` model, which is defined in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$fillable` array defines the list of fields that Laravel can fill by **mass
    assignment**, which is a convenient way to assign attributes to a model. By convention,
    the column that Laravel will use to find the related model has to be called `breed_id`
    in the database. The `Breed` model, `app/Breed.php`, is defined with the inverse
    `hasMany` relationship as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, Laravel expects a `created_at` and `updated_at` timestamp field
    in the database table. Since we are not interested in storing these timestamps
    with the breeds, we disable them in the model by setting the `$timestamps` property
    to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the entire code that is required in our models for now. We will discover
    various other features of Eloquent as we progress in this book; however, in this
    chapter, we will primarily use two methods: `all()` and `find()`. To illustrate
    their purpose, here are the SQL queries that they generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties of an Eloquent model can be retrieved with the `->` operator:
    `$cat->name`. The same goes for the properties of the related models, which are
    accessible with: `$cat->breed->name`. Behind the scenes, Eloquent will perform
    the necessary SQL joins.'
  prefs: []
  type: TYPE_NORMAL
- en: Building the database schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have defined our models, we need to create the corresponding database
    schema. Thanks to Laravel''s support for migrations and its powerful schema builder,
    you will not have to write any SQL code and you will also be able to keep track
    of any schema changes in a version control system. To create your first migration,
    open a new terminal window and enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new migration at `database/migrations/`. If you open the
    newly created file, you will find some code that Laravel has generated for you.
    Migrations always have an `up()` and `down()` method that defines the schema changes
    when migrating up or down. Migrating up is modifying the database schema (that
    is, adding a table at a later date), whereas, migrating down is the process of
    undoing that schema change. By convention, the table and field names are written
    in snake_case. Also, the table names are written in plural form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `breeds` table migration will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can repeat the process to also create our `cats` table schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `date()` and `string()` methods create fields with the corresponding types
    (in this case, `DATE` and `VARCHAR`) in the database, `increments()` creates an
    auto-incrementing `INTEGER` primary key, and `timestamps()` adds the `created_at`
    and `updated_at DATETIME` fields that Eloquent expects, by default. The `nullable()`
    method specifies that the column can have `NULL` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Laravel offers the following methods for defining migrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates an auto-incrementing big integer column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `BIGINT` column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `BLOB` column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `BOOLEAN` column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `CHAR` column with the given length |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `DATE` column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `DATETIME` column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `DECIMAL` column with the given precision and scale |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `DOUBLE` column, with 10 digits in total and 5 after the decimal
    point |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates an `ENUM` column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `FLOAT` column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates an auto-incrementing integer column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates an `INTEGER` column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `JSON` column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `LONGTEXT` column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `MEDIUMINT` column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `MEDIUMTEXT` column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates two columns: `INTEGER taggable_id` and `STRING taggable_type`
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '| This is similar to timestamps (next), but allows `NULL` values |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '| It adds a `remember_token VARCHAR` column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `TINYINT` column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '| It adds a `deleted_at` column for soft deletes |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `VARCHAR` column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `VARCHAR` column of the given length |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `TEXT` column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `TIME` column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates a `TIMESTAMP` column |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '| It creates `created_at` and `deleted_at` columns |'
  prefs: []
  type: TYPE_TB
- en: We've also created a foreign key in the `cats` migration. This links the `breed_id`
    column value to an ID in the `breeds` table. This is so that we don't have to
    keep specifying the breed name over and over again. We can just reference one
    record in the `breeds` table. If that record is updated, then all `cats` linked
    to it will also be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run both of the migrations, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When it is run for the first time, this command will also create a `migrations`
    table that Laravel will use to keep track of the migrations that have been run.
    It will then run any outstanding migrations. On subsequent runs, the command will
    use the `migrations` table to determine if any migration files need running, and
    run them, if so.
  prefs: []
  type: TYPE_NORMAL
- en: We created our `breeds` table migration before the `cats` table migration because
    we have a **foreign key** in our `cats` table. If we were to try and create the
    `cats` table first, it will fail as the column it is referencing does not exist
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: Seeding the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rather than manually populating our database, we can use the seeding helpers
    offered by Laravel. This time, there is no Artisan command to generate the file,
    but all we need to do is create a new class called `BreedsTableSeeder.php` at
    `database/seeds/`. This class extends Laravel''s `Seeder` class and defines the
    following `run()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You can bulk insert an array but you can also insert arbitrary code in the `run()`
    method to load data from say, a CSV or JSON file. There are also third-party libraries
    that can help you generate large amounts of test data to fill your database, such
    as the excellent Faker.
  prefs: []
  type: TYPE_NORMAL
- en: 'To control the order of execution of the seeders, Laravel lets you call them
    individually at `database/seeds/DatabaseSeeder.php`. In our case, since we only
    have one seeder, all we need to write is the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can seed the database by calling it, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Seeding is good for initially populating a database. If we were to re-run the
    seed command, we would actually get an error as we're defining primary keys for
    our records; if we tried re-seeding, the database will trigger a duplicate primary
    key error. We can first truncate the table, but this will be dangerous if deployed
    to a production environment, as it will delete any user-contributed records, as
    well as your seed data definitions!
  prefs: []
  type: TYPE_NORMAL
- en: Mastering Blade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have some information in our database, we need to define the templates
    that are going to display it. Blade is Laravel''s lightweight template language
    and its syntax is very easy to learn. Here are some examples of how Blade can
    reduce the number of keystrokes and increase the readability of your templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Standard PHP syntax | Blade syntax |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: If you use the default double braces notation, then variables are escaped. This
    is to protect against XSS vulnerabilities (explained in more detail in [Chapter
    7](ch07.html "Chapter 7. Authentication and Security"), *Authentication and Security*).
    If you really need the raw value of variable un-escaped, then you can use single
    braces, with two exclamation marks inside on each side. You should only do this
    if you trust the value that the variable contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blade also supports all of PHP''s major constructs to create loops and conditions:
    `@for`, `@foreach`, `@while`, `@if`, and `@elseif`, allowing you to avoid opening
    and closing the `<?php` tags everywhere in your templates.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a master view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blade lets you build hierarchical layouts by allowing the templates to be nested
    and extended. The following code snippet is the **master** template that we are
    going to use for our application. We will save it as `resources/views/layouts/master.blade.php`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The Bootstrap CSS framework is included to speed up the prototyping of the application
    interface. You can download it from [http://getbootstrap.com](http://getbootstrap.com)
    and place the minified CSS file at `public/css/`. To ensure that its path prefix
    is set correctly, even when Laravel is run from a subfolder, we use the `asset()`
    helper. You can see the complete list of Blade template helpers that are available
    to you, visit [http://laravel.com/docs/helpers](http://laravel.com/docs/helpers).
  prefs: []
  type: TYPE_NORMAL
- en: To inform the user about the outcome of certain actions, we have prepared a
    notification area between the header and the page content. This **flash data**
    (in other words, the session data that is only available for the next request)
    is passed and retrieved to and from the `Session` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@yield` directives act as placeholders for the different sections that
    a child view can populate and override. To see how a child template can re-use
    them, we are going to recreate the `about` view by changing its extension to `.blade.php`
    and extending our `master` layout template instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@section ... @stop` directives delimit the blocks of content that are
    going to be injected into the master template. You can see how this is done in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a master view](img/B04308_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you now reopen the `/about` route in your web browser, without changing anything
    in your previous route definition, you will see the new view. Laravel's view finder
    will simply use the new file, and since its name ends with `.blade.php`, treat
    it like a Blade template.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a main layout template that we can extend and re-use, we can
    start to create the individual routes of our application at `app/Http/routes.php`,
    along with the different views that will display the application data.
  prefs: []
  type: TYPE_NORMAL
- en: The overview page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the *index* page that is going to display all of the cats using the
    `cats.index` view. We will also re-use this view for the second route where cats
    are filtered by breed, since both the routes are almost identical. Note that Laravel
    expects you to use the dot notation (`cats.index` and not `cats/index`) to refer
    to a view located inside a subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The only novelty in these routes is the slightly more advanced Eloquent queries.
    While we already know that the `all()` method in the first route loads all of
    the entries from the `cats` table, the second route uses a more complex query.
    The `with('cats')` method will load any related `cat` models. The `whereName`
    is a dynamic method that creates a `WHERE` SQL clause, which will translate to
    `WHERE name = $name`. The long-hand expression of this will be `where('name',
    '=', $name)`. Finally, we fetch the first breed record (and related cat models)
    with the `first()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template, saved at `cats/index.blade.php`, will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: With the help of a `foreach` loop, the view iterates over the list of cats that
    it received from the route. Since we will be using this view to display both the
    index page (`/cats`) as well as the breed overview page (`/cats/breeds/{breed}`),
    we used the `@if` directives in two places to conditionally display more information.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a cat's page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next route is used to display a single cat. To find a cat by its ID, we
    use Eloquent''s `find()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Route-model binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Route-model binding is the method of automatically transforming a route parameter
    to a model instance, so we don''t have to manually retrieve the model. Since this
    is such a common pattern, Laravel provides you with a way to automatically bind
    a model to a route and, therefore, make your code shorter and more expressive.
    To bind the `$cat` variable to the `Cat` model, open `app/Providers/RouteServiceProvider.php`.
    Modify the `boot()` method so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows you to shorten your route and pass a `Cat` object to it instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The view, `cats/show.blade.php`, does not contain any new directives. It simply
    displays the name of the cat with the links to edit or delete it. In the `content`
    section, we return its age and breed if the breed is set; this is shown in the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Adding, editing, and deleting cats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next series of routes and views will be used to create, edit, and delete
    a cat page.
  prefs: []
  type: TYPE_NORMAL
- en: Until version 5, Laravel came with a package for creating common HTML and form
    elements. In Laravel 5 applications, we need to bring this package back into use.
    We do this via Composer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `require` section of `composer.json`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run `$ composer update`. This will install the package. Next, we need
    to register the service provider and façades. Open `config/app.php` and add the
    following the `$providers` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following two lines to the `$facades` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This now gives us a lot of helpful methods with which to build forms in our
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: Although Blade templates are hierarchical, it is still possible to include other
    templates in views, as you may be used to doing with the `include()` or `require()`
    functions in PHP. We will use this to share the form fields needed for both the
    create and edit templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `resources/views/partials/forms/cat.blade.php`, add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `Form::select()` helper builds a `<select>` dropdown with the different
    choices. It expects the list of choices to be passed to a multidimensional array.
    Rather than binding this array to each route, we can use **view composers**, another
    feature of Laravel, which allows you to bind a variable to a specific view each
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can initialize a view composer by adding it to our application''s service
    provider. Open `app/Providers/AppServiceProvider.php` and change the `boot()`
    method to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to resolve `ViewFactory`. At the top of the file, underneath the
    namespace declaration, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to create the actual view composer class. We''ve specified the
    path, so let''s create the file and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Now when the `partials.forms.cat` template partial is called, the view composer
    kicks in. When Laravel instantiates it, it'll read the constructor and automatically
    inject instances of the specified types. In our view composer's constructor, we
    specify that we need an instance of our `Breed` model, and then store the instance
    as a class property.
  prefs: []
  type: TYPE_NORMAL
- en: Once the view composer has been initialized, the `compose()` method is called.
    This is where the actual binding of data to the view occurs. As our model is an
    Eloquent model, we can use the `lists()` method that fetches all records in an
    associative array, which is just what we need for our `select` list. The first
    parameter is the value that the user will see (the breed name in this instance)
    and the second parameter is what will be used as the `value` attribute in the
    `<option>` tag (the breed ID).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a partial form with breed options automatically being injected
    when requested, we can continue on with building the create, edit, and delete
    views.
  prefs: []
  type: TYPE_NORMAL
- en: 'The create view is straightforward: we extend out master layout, open our form,
    and then include the partial we''ve just created. In `resources/views/cats/create.blade.php`,
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The edit template (`resources/views/cats/edit.blade.php`) will look similar,
    barring a few small changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We didn't include the opening and closing form tags in the partial, as we need
    to change the action URL and method depending on the action. Also, in the edit
    template, we're using form-model binding to bind the `Cat` instance passed to
    our template, to the form. This automatically populates the values of the form
    fields with the value of the attributes in our `Cat` model instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our views, we can create the corresponding routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed that a new method `withSuccess()` is being used in the
    preceding routes in conjunction with our redirects. This isn't an explicitly defined
    method; instead, it is an example of **overloading** in Laravel. In the context
    of redirects, Laravel looks at method calls that have `with` in the beginning;
    it takes the latter part and assigns it to the session flash data. This includes
    the session variables that will be available in the next request, and the next
    request only. This makes it perfect for single-use data such as success messages,
    as we have seen earlier.
  prefs: []
  type: TYPE_NORMAL
- en: If you look back at our master layout template, you can see the provision we
    have to check for any session variables with the key `success`; if it exists,
    we simply display it in a Bootstrap success alert.
  prefs: []
  type: TYPE_NORMAL
- en: Any input data that is received by the application and that you would normally
    access via the `$_GET` or `$_POST` variables is instead retrievable by using the
    `Input::get()` method. It is also possible to retrieve an array of all the input
    data with `Input::all()`. In the `POST /cats` and `PUT /cats/{cat}` routes respectively,
    we use the `create()` and `update()` methods from Eloquent with `Input::all()`
    as their argument. This is only possible because we specified the fields that
    are fillable in the `Cat` model beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a working application where users can add, edit, and delete cats.
  prefs: []
  type: TYPE_NORMAL
- en: Moving from simple routing to powerful controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been creating **closure-based routes**. This is great for quickly
    prototyping applications, and is prevalent in micro-frameworks such as **Silex**
    and **Slim**; however, as your application grows, this approach might become cumbersome
    and limiting. The alternative (and recommended) approach to defining the logic
    to be executed when a route is requested is in controllers, the C in MVC.
  prefs: []
  type: TYPE_NORMAL
- en: A controller is usually a class, containing one or more methods, also known
    as **actions**. You usually have a route map to a controller action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'To achieve the same functionality with a controller and remove the business
    logic from the routes, create a new file at `app/Http/Controllers/UserController.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This approach can greatly improve the reusability and testability of your code,
    especially if your theoretical `doSomething()` method is used in more than one
    controller action. You can test it just once in isolation, and then rely on it.
    When you venture into more advanced topics such as dependency injection, you can
    even swap entire classes when you instantiate the controller, but we will not
    cover this here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to tell Laravel which controller action to use, simply rewrite the
    route declaration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The root controller namespace (`App\Http\Controllers`) is automatically prepended
    to the controller class name to avoid the task of specifying it for each and every
    route.
  prefs: []
  type: TYPE_NORMAL
- en: Resource controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Laravel greatly simplifies the creation of REST APIs with resource controllers.
    Since they adhere to conventions, there is only a limited defined set of actions
    that can be performed from the controller. In fact, all the routes we created
    earlier can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This will register the following routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Verb | Path | Action | Route Name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/cat` | index | `cat.index` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/cat/create` | create | `cat.create` |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/cat` | store | `cat.store` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/cat/{id}` | show | `cat.show` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/cat/{id}/edit` | edit | `cat.edit` |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT/PATCH` | `/cat/{id}` | update | `cat.update` |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `/cat/{id}` | destroy | `cat.destroy` |'
  prefs: []
  type: TYPE_TB
- en: 'Then, in your `CatController` class, you will have all of the different actions:
    `index`, `create`, `show`, `edit`, and so on. These will then be wired up to respond
    to the correct route and HTTP verb.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a stub resource controller with the following Artisan command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Why not try re-writing the closure-based route actions into your new `CatController`
    class?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot in this chapter. You learned how to define routes, prepare
    the models of the application, and interact with them. Moreover, we have had a
    glimpse at the many powerful features of Eloquent, Blade, as well as the other
    convenient helpers in Laravel to create forms and input fields—all of this in
    under 200 lines of code!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn more about Laravel's powerful ORM, Eloquent,
    which allows you to perform powerful database queries without writing a line of
    SQL.
  prefs: []
  type: TYPE_NORMAL
