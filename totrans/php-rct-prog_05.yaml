- en: Chapter 5. Testing RxPHP Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 测试RxPHP代码
- en: In this chapter, we're going to start testing code based on RxPHP. So far, we've
    been testing code by just running it and watching for the expected output in console.
    Of course, this isn't a very systematic approach, so it's time to start testing
    our code in an automatic way.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始基于RxPHP测试代码。到目前为止，我们只是通过运行代码并观察控制台中的预期输出来进行代码测试。当然，这不是一个非常系统化的方法，因此是时候以自动化的方式开始测试我们的代码了。
- en: 'More precisely, in this chapter we will do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 更确切地说，在本章中，我们将做以下几件事：
- en: Introduce the `doOn*()` operators
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍`doOn*()`算子
- en: Start using the PHPUnit library for unit testing code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用PHPUnit库进行单元测试
- en: Talk about testing asynchronous code in general and try some common pitfalls
    ourselves
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论一般性的异步代码测试，并尝试一些常见的陷阱
- en: Explore classes that come with RxPHP intended for testing and see how to use
    them separately, and how they fit into the great scheme of things
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索RxPHP附带用于测试的类，了解如何单独使用它们，以及它们如何融入整个方案中
- en: For demonstration purposes, create a `SumObservable` class that calculates the
    sum of all integers going through, and test it using RxPHP testing tools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了演示目的，创建一个`SumObservable`类，该类计算通过的所有整数的总和，并使用RxPHP测试工具对其进行测试
- en: Write a simplified `ForkJoinObservable` class and test it
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简化的`ForkJoinObservable`类并对其进行测试
- en: Stress how important it is to be aware of timing when testing Observables and
    operators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强调在测试Observables和算子时关注时间的重要性
- en: This chapter is going to be very code-intensive, although most of these examples
    are simple and aim to put things from previous chapters to the perspective of
    unit testing. Previous experience with unit testing with PHPUnit is helpful, but
    not required.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将非常注重代码，尽管大多数示例都很简单，目的是从单元测试的角度来看待之前章节的内容。虽然具有使用PHPUnit进行单元测试的经验会有所帮助，但并非必需。
- en: Apart from writing unit tests, there's a very common way of debugging Observable
    chains with `doOn*()` operators.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编写单元测试之外，使用`doOn*()`算子调试Observable链还有一种非常常见的方法。
- en: The doOn*() operators
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: doOn*()算子
- en: In the previous chapter, we've used the `map()` operator a couple of times to
    just print to the console what's happening inside our Observable chains. However,
    this isn't very convenient. The `map()` operator always needs to return a value
    that is passed further down the chain, and it can catch only `onNext` signals.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们多次使用了`map()`算子，只是为了将Observable链内部发生的事情打印到控制台。然而，这并不方便。`map()`算子总是需要返回一个值，并将其传递到链的下一部分，并且它只能捕获`onNext`信号。
- en: 'That''s why RxPHP has a couple of operators with the common prefix `doOn*`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么RxPHP有几个以`doOn*`为前缀的算子：
- en: '`doOnNext()`, `doOnError()`, `doOnCompleted()`: Each of these operators takes
    a callable as a parameter that is executed when they receive their respective
    signal'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnNext()`、`doOnError()`、`doOnCompleted()`：每个算子都接受一个参数，当它们接收到相应的信号时执行该参数指定的可调用对象'
- en: '`doOnEach()`: This operator takes an instance of `ObserverInterface` as a parameter
    and executes its handlers for each signal'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnEach()`: 这个算子接受一个`ObserverInterface`的实例作为参数，并为每个信号执行其处理程序'
- en: So these operators are very similar to the methods `subscribeCallback()` and `subscribe()`.
    The biggest advantage is in the way `doOn*` operators work internally. They never
    modify the value going through and just execute our callables, which is ideal
    for quickly debugging Observable chains or to perform side-effects without creating
    subscriptions (this includes everything related to subscribing to Observables
    as we talked about in [Chapter 3](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 3. Writing a Reddit Reader with RxPHP"), *Writing a Reddit Reader with
    RxPHP*).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些算子与`subscribeCallback()`和`subscribe()`方法非常相似。最大的优势在于`doOn*`算子内部的工作方式。它们永远不会修改通过的价值，只是执行我们的可调用对象，这对于快速调试Observable链或执行副作用而不创建订阅（这包括我们在[第3章](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "第3章。使用RxPHP编写Reddit阅读器")中讨论的与订阅Observables相关的一切）是非常理想的。
- en: 'We can see this with a very simple example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个非常简单的例子来看出这一点：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have a single subscriber that handles `onNext` and `onError` signals. Note
    that the `onError` handler is empty and it''s the `doOnError()` operator that
    prints the exception messages. Console output for this example is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个单独的订阅者来处理`onNext`和`onError`信号。注意，`onError`处理程序是空的，而`doOnError()`算子会打印异常信息。本例的控制台输出如下：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using the remaining `doOn*()` operators is exactly the same. We're obviously
    not going to use these operators to test RxPHP code, but these are often the easiest
    way to see what's emitted by our Observables.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用剩余的`doOn*()`操作符的方式完全相同。显然，我们不会使用这些操作符来测试RxPHP代码，但这些通常是查看我们的Observables发出的内容的最简单方式。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These operators have been simplified in RxPHP v2 and have the same signature
    as the `subscribe()` method in RxPHP v2, which is just `do()` instead of all its
    variants. Its functionality remains unchanged.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作符在RxPHP v2中已被简化，并且与RxPHP v2中的`subscribe()`方法具有相同的签名，即只是`do()`而不是所有变体。其功能保持不变。
- en: Installing the PHPUnit package
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装PHPUnit包
- en: 'Since we''re installing all dependencies throughout this book from the composer,
    we will do the same for PHPUnit:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在整本书中通过composer安装所有依赖项，因此我们将对PHPUnit做同样的事情：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This also creates a symlink into `vendor/bin/phpunit`, which we'll use to run
    our unit tests from the console.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这也在`vendor/bin/phpunit`中创建了一个符号链接，我们将使用它从控制台运行单元测试。
- en: 'PHPUnit supports multiple ways to install, including **PHAR** (**PHP archive**)
    format and installing it globally using the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit支持多种安装方式，包括**PHAR**（**PHP存档**）格式和通过以下方式全局安装：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you run into trouble installing PHPUnit, head over to the installation instructions
    at [https://phpunit.de/manual/5.6/en/installation.html](https://phpunit.de/manual/5.6/en/installation.html)
    .
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在安装PHPUnit时遇到麻烦，请前往安装说明[https://phpunit.de/manual/5.6/en/installation.html](https://phpunit.de/manual/5.6/en/installation.html)。
- en: However, unless you have a good reason to use one global instance of PHPUnit,
    it's better to install it per project. This way we can avoid dealing with issues
    involving unit testing code written for different PHPUnit versions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除非你有很好的理由使用一个PHPUnit的全局实例，否则最好按项目安装。这样我们可以避免处理为不同PHPUnit版本编写的单元测试代码的问题。
- en: Basics of writing tests using PHPUnit
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHPUnit编写测试的基本知识
- en: We're not going to go into very much detail about how to use PHPUnit, and instead
    leave it to its in-depth documentation ( [https://phpunit.de/manual/5.6/en/index.html](https://phpunit.de/manual/5.6/en/index.html)
    ). For the purpose of this chapter, we should, however, have a quick look at some
    of the basics we're going to use for the purposes of testing RxPHP code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍如何使用PHPUnit，而是将其留给其深入的文档（[https://phpunit.de/manual/5.6/en/index.html](https://phpunit.de/manual/5.6/en/index.html)）。然而，为了本章的目的，我们应该快速查看我们将用于测试RxPHP代码的一些基础知识。
- en: 'There are some basic rules we should follow:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该遵循一些基本规则：
- en: All tests for a single class, `MyClass`, go into a class called `MyClassTest`,
    which should inherit from `PHPUnit\Framework\TestCase`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有针对单个类`MyClass`的测试都应放入一个名为`MyClassTest`的类中，该类应继承自`PHPUnit\Framework\TestCase`。
- en: Each test scenario is represented by a function prefixed with `test` or annotated
    with `@test` annotation. This way it can be auto-discovered by PHPUnit.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个测试场景都由一个以`test`为前缀或带有`@test`注解的函数表示。这样，它就可以被PHPUnit自动发现。
- en: Each test function consists of one or more assertions using `assert*` methods
    (more on them later). If any one of them fails, the whole test scenario (one test
    function) is marked as failed. All assertions are inherited from `PHPUnit\Framework\TestCase`.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个测试函数由一个或多个使用`assert*`方法（稍后详细介绍）的断言组成。如果其中任何一个失败，整个测试场景（一个测试函数）将被标记为失败。所有断言都继承自`PHPUnit\Framework\TestCase`。
- en: We can specify dependencies between test scenarios using `@depends testname`
    annotation to change the order in which tests are executed.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`@depends testname`注解来指定测试场景之间的依赖关系，以改变测试执行的顺序。
- en: 'So, let''s write a minimalistic test class that demonstrates the preceding
    points. We can call this test class `DemoTest`, and it can make just a few assertions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们编写一个最小化的测试类来演示前面的要点。我们可以将这个测试类命名为`DemoTest`，并且它只需进行几个断言：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We used three different types of assertion. In general, all assertions compare
    an expected value and an actual value returned from a tested function. The following
    three assertions work in this way too:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了三种不同类型的断言。一般来说，所有断言都会比较一个预期的值和一个从测试函数返回的实际值。以下三个断言也是以这种方式工作的：
- en: '`assertTrue($condition)`: The tested condition needs to be true.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTrue($condition)`: 测试的条件需要为真。'
- en: '`assertEquals($expected, $actual)`: Checks that `$expected` and `$actual` values
    are equal. This single assertion handles multiple types of data separately, even
    those that aren''t comparable with the `==` operator. Apart from comparing basic
    types, such as strings, arrays, Booleans, and numbers, it can also compare `DOMDocument`
    instances, or any objects to match their attributes.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEquals($expected, $actual)`: 检查`$expected`和`$actual`的值是否相等。这个单独的断言可以分别处理多种类型的数据，即使它们不能用`==`运算符进行比较。除了比较基本类型，如字符串、数组、布尔值和数字之外，它还可以比较`DOMDocument`实例或任何对象的属性。'
- en: '`assertContains($needle, $haystack)`: Typically, checks that an array (haystack)
    contains a value, but can also check that a string contains another string.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertContains($needle, $haystack)`: 通常检查一个数组（haystack）是否包含一个值，但也可以检查一个字符串是否包含另一个字符串。'
- en: PHPUnit contains dozens of different assertion methods, and all of them work
    on the same principle. A full list is available in the documentation ( [https://phpunit.de/manual/current/en/appendixes.assertions.html](https://phpunit.de/manual/current/en/appendixes.assertions.html)
    ), and we can, of course, write our own. We're going to use a very limited number
    of assertions that are relevant for us, so we're good to go with these basic ones.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit包含数十种不同的断言方法，并且它们都遵循相同的原理。完整的列表可以在文档中找到（[https://phpunit.de/manual/current/en/appendixes.assertions.html](https://phpunit.de/manual/current/en/appendixes.assertions.html)），我们当然可以编写自己的。我们将使用非常有限的相关断言，所以这些基本的断言就足够了。
- en: 'Then, we can execute all test scenarios in the class from the console, using
    the PHPUnit command-line executable. It''s located in `vendor/bin`, and since
    we''re going to use it a lot we''ll make a symlink to the project root. We''ll
    do the same for the `autoload.php` script located in the vendor directory that
    we need as well:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从控制台使用PHPUnit命令行可执行文件执行类中的所有测试场景。它位于`vendor/bin`目录中，由于我们将大量使用它，我们将为项目根目录创建一个符号链接。我们还将为位于供应商目录中的`autoload.php`脚本做同样的事情：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we can run our test class with the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令运行我们的测试类：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some empty lines from the CLI output are purposely removed to keep them reasonably
    short.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行输出中故意删除了一些空行，以保持输出合理简短。
- en: 'We used two CLI parameters here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了两个命令行参数：
- en: '`--bootstrap`: Since we expect tests to work with various classes and functions
    from our project, we need to tell PHPUnit where it can find them. This parameter
    lets you specify a custom class loader (basically a PHP SPL autoloader). Fortunately,
    Composer already does everything for us, and generates `autoload.php` from our `composer.json`
    file. If we don''t use the `--bootstrap` parameter, PHPUnit will throw an error
    because it will be unable to find `PHPUnit\Framework\TestCase`.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--bootstrap`: 由于我们期望测试与我们的项目中的各种类和函数一起工作，我们需要告诉PHPUnit它们的位置。此参数允许您指定自定义类加载器（基本上是一个PHP
    SPL自动加载器）。幸运的是，Composer已经为我们做了所有这些工作，并从我们的`composer.json`文件中生成了`autoload.php`。如果我们不使用`--bootstrap`参数，PHPUnit将抛出一个错误，因为它将无法找到`PHPUnit\Framework\TestCase`。'
- en: '`phpunit_01.php`: This is the file containing the test we want to run. Note
    that we could also use a directory path to test all the files in that directory,
    or just a dot (`.`), to test all the files in the current directory.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`phpunit_01.php`: 这是包含我们想要运行的测试的文件。请注意，我们也可以使用目录路径来测试该目录中的所有文件，或者只使用点（`.`），来测试当前目录中的所有文件。'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PHPUnit allows the creation of a custom XML file with its configuration, so
    we don't have to include the `--bootstrap` parameter every time. To keep things
    simple, we're not using it. For more information, see the documentation at  [https://phpunit.de/manual/current/en/appendixes.configuration.html](https://phpunit.de/manual/current/en/appendixes.configuration.html)
    .
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: PHPUnit允许创建一个带有其配置的自定义XML文件，因此我们不必每次都包含`--bootstrap`参数。为了保持简单，我们没有使用它。有关更多信息，请参阅[https://phpunit.de/manual/current/en/appendixes.configuration.html](https://phpunit.de/manual/current/en/appendixes.configuration.html)的文档。
- en: 'The console output summarizes everything we need to know about the tests processed.
    We can see it ran one test case with four assertions. The line with a single dot
    (`.`) followed by `1 / 1 (100%)` means we executed a single test case and it succeeded.
    This isn''t very descriptive, so we can use another argument, `--testdox`, to
    make it more human-readable:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出总结了关于已处理的测试所需了解的所有信息。我们可以看到它运行了一个测试用例，包含四个断言。只有一个点（`.`）后面跟着`1 / 1 (100%)`的行表示我们执行了一个测试用例并且它成功了。这并不非常描述性，因此我们可以使用另一个参数`--testdox`来使其更易于阅读：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, instead of the dot (`.`), PHPUnit converted the class and function names
    into strings, and marked those that passed. This is definitely more understandable;
    however, it doesn't show error messages on the failed test, so we don't know why
    it failed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，而不是使用点（`.`），PHPUnit 将类和函数名称转换为字符串，并标记那些通过测试的。这确实更容易理解；然而，它没有在失败的测试上显示错误消息，所以我们不知道为什么它失败了。
- en: We'll use both formats in this chapter depending on the situation. Usually,
    when we expect a test to pass, we'll use the second, more readable, format. When
    we expect the test to fail, we'll use the first format to see where it failed
    and why (if it failed).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中根据情况使用这两种格式。通常，当我们期望测试通过时，我们会使用第二种、更易读的格式。当我们期望测试失败时，我们会使用第一种格式来查看它在哪里失败以及为什么（如果它失败了）。
- en: 'For demonstration purposes, we''ll also add a test that fails and another test
    that depends on the first test:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们还会添加一个失败的测试和一个依赖于第一个测试的测试：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first test case fails because it asserts that `5 == 6`. The second test
    case is skipped because the test it depends on failed. The failed test is then
    properly marked as failed, while the skipped test is omitted:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试用例失败了，因为它断言`5 == 6`。第二个测试用例被跳过，因为它依赖的测试失败了。失败的测试被正确地标记为失败，而跳过的测试被省略：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is all we need to know for now. Before jumping into testing RxPHP code,
    we should quickly talk about testing asynchronous code in general and one common
    pitfall we need to be aware of.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们只需要知道这些。在深入研究测试 RxPHP 代码之前，我们应该快速讨论一下一般性的异步代码测试，以及我们需要注意的一个常见陷阱。
- en: Testing asynchronous code
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试异步代码
- en: 'There''s one important caveat we need to know about when testing asynchronous
    code, and since everything we do with RxPHP is asynchronous it''s very relevant
    to us. Let''s consider the following function `asyncPowIterator()`, which we''re
    about to test:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试异步代码时，我们需要注意的一个重要注意事项，由于我们使用 RxPHP 做的所有事情都是异步的，这对我们来说非常相关。让我们考虑以下即将测试的函数`asyncPowIterator()`：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have a function, `asyncPowIterator()`, that calls a callable on each number
    in the range 1 to 5\. Notice that we made an intentional bug and instead of iterating
    the range 1 to 5, we'll just iterate 1 to 4.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个函数`asyncPowIterator()`，它对范围 1 到 5 中的每个数字调用一个可调用函数。请注意，我们故意制造了一个错误，而不是迭代范围
    1 到 5，我们只迭代 1 到 4。
- en: 'In order to test that this method produces correct values, we placed the assertion
    right into the callable. So, let''s run the test and see what happens:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个方法是否产生正确的值，我们将断言直接放入可调用函数中。那么，让我们运行测试看看会发生什么：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Well, the test passed, even though there's a bug that we know about.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，测试通过了，尽管我们知道有一个错误。
- en: 'The function in fact generates correct results, it''s just not called as many
    times as we expect. This means that to test this function properly, we need to
    count the calls of the callable as well, and then compare it to the expected value:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，该函数生成了正确的结果，只是没有像我们预期的那样被调用那么多次。这意味着为了正确测试这个函数，我们还需要计算可调用函数的调用次数，并将其与预期值进行比较：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we''re incrementing the `$count` variable every time we go through the
    callable and, if we run the test again, we''ll see it fails as it''s supposed
    to:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次我们通过可调用函数时，都会增加`$count`变量，如果我们再次运行测试，我们会看到它失败了，正如预期的那样：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now it fails as we want and we know that something's wrong.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它失败了，正如我们预期的那样，我们知道有问题。
- en: This is an important paradigm. When testing asynchronous code, we can't just
    test that it returns correct results; we also need to be sure it gets called at
    all.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的范式。在测试异步代码时，我们不仅需要测试它是否返回正确的结果；我们还需要确保它确实被调用。
- en: What we already know about unit testing could be enough to start testing our
    Observables and operators. RxPHP comes with a couple of classes intended for testing
    RxPHP code that can make our lives easier. All of these are used internally by
    RxPHP to test itself, so it's worth spending a little time learning about them,
    and start using them as well when testing our own code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解的单元测试知识可能足以开始测试我们的 Observables 和操作符。RxPHP 附带了一些用于测试 RxPHP 代码的类，可以使我们的工作更轻松。所有这些都是在
    RxPHP 内部用于测试自身的，所以花点时间学习它们，并在测试我们自己的代码时开始使用它们。
- en: Testing RxPHP code
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 RxPHP 代码
- en: Since [Chapter 2](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 2. Reactive Programming with RxPHP"), *Reactive Programming with RxPHP*,
    where we introduced Schedulers, we've been using them via `ImmediateScheduler`
    and `EventLoopScheduler`. Internally, `EventLoopScheduler` extends another Scheduler,
    called `VirtualTimeScheduler`, which is also used internally by `TestScheduler`,
    which we'll use for testing in a moment. But before we do that, let's see what's
    so interesting about `VirtualTimeScheduler`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们在 [第二章](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d "第二章。使用
    RxPHP 进行响应式编程")，*使用 RxPHP 进行响应式编程*，其中我们介绍了调度器，我们就通过 `ImmediateScheduler` 和 `EventLoopScheduler`
    使用它们。内部，`EventLoopScheduler` 扩展了另一个名为 `VirtualTimeScheduler` 的调度器，该调度器也被 `TestScheduler`
    内部使用，我们将稍后用于测试。但在我们这样做之前，让我们看看 `VirtualTimeScheduler` 有什么有趣之处。
- en: Introducing VirtualTimeScheduler
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 VirtualTimeScheduler
- en: With `ImmediateScheduler`, everything is executed immediately. The `VirtualTimeScheduler`
    keeps a priority queue of actions to be executed and gives us control over the
    order they're called.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ImmediateScheduler`，所有内容都会立即执行。`VirtualTimeScheduler` 维护一个待执行动作的优先队列，并让我们控制它们的调用顺序。
- en: 'In this example, we''ll make an instance of `VirtualTimeScheduler` and stack
    a couple of actions that will be executed with different delays using the `schedule($actionCallable,
    $delay)` method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个 `VirtualTimeScheduler` 实例，并使用 `schedule($actionCallable, $delay)`
    方法堆叠几个具有不同延迟的动作：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When we instantiate the `VirtualTimeScheduler` class, we also need to pass a
    starting time and a typical comparer function that decides which action is called
    first. Then, to actually start executing all the actions in the correct order,
    we need to call the `start()` method manually.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实例化 `VirtualTimeScheduler` 类时，我们还需要传递一个起始时间和一个典型的比较函数，该函数决定哪个动作首先被调用。然后，为了实际以正确的顺序执行所有动作，我们需要手动调用
    `start()` 方法。
- en: The `schedule()` method also takes as its last argument a delay from the starting
    time when it'll be executed. This means we can define actions in a different order
    than they're supposed to be executed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`schedule()` 方法还将其最后一个参数作为执行时的起始时间延迟。这意味着我们可以定义比它们实际执行顺序不同的动作。'
- en: 'This example will print numbers in the following order:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将按照以下顺序打印数字：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is actually what `EventLoopScheduler` does when we use it with an Observable
    that allows delayed execution, such as `IntervalObservable`. Let''s look again
    at the very basic example with the `interval()` operator in RxPHP 1.x:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是当我们将它与允许延迟执行的 Observable（例如 `IntervalObservable`）一起使用时，`EventLoopScheduler`
    所做的。让我们再次看看 RxPHP 1.x 中 `interval()` 操作符的非常基本的示例：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `EventLoopScheduler` class is based on the same principle as `VirtualTimeScheduler`
    (it also inherits `VirtualTimeScheduler`). The primary difference is that `EventLoopScheduler`
    uses a loop to reschedule action calls over and over again in the specified interval.
    In this example, by "action" we mean an `onNext()` call from `IntervalObservable`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventLoopScheduler` 类基于与 `VirtualTimeScheduler` 相同的原则（它也继承自 `VirtualTimeScheduler`）。主要区别在于
    `EventLoopScheduler` 使用循环在指定的间隔内反复重新调度动作调用。在这个例子中，“动作”指的是来自 `IntervalObservable`
    的 `onNext()` 调用。'
- en: 'The default delay for `schedule()` is `0`, so we can also use `VirtualTimeScheduler`
    instead of `ImmediateScheduler`. Consider the following example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`schedule()` 的默认延迟为 `0`，因此我们也可以使用 `VirtualTimeScheduler` 而不是 `ImmediateScheduler`。考虑以下示例：'
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As expected, this prints all items in the array in the order they''re specified:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，它按照指定的顺序打印出数组中的所有项：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now it should be obvious why we always check in all our methods whether there's
    a Scheduler passed, and if there isn't, we use the simplest `ImmediateScheduler`.
    This allows us to easily switch to any other Scheduler if we have a reason to.
    Well, one good reason is unit testing, of course.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该很明显，为什么我们总是在所有方法中检查是否传递了调度器，如果没有，我们就使用最简单的 `ImmediateScheduler`。这允许我们轻松切换到任何其他调度器，如果我们有理由这样做的话。好吧，一个很好的理由当然是单元测试。
- en: The `VirtualTimeScheduler` itself isn't used when testing RxPHP code, but it's
    wrapped with another Scheduler called `TestScheduler` that uses its principles
    under the hood and lets us schedule even more than just actions. Since `TestScheduler`
    uses a few other classes related to testing internally, we'll first have a look
    at them and then go back to `TestScheduler`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试 RxPHP 代码时，`VirtualTimeScheduler` 本身并不使用，但它被另一个名为 `TestScheduler` 的调度器所包装，该调度器在底层使用其原则，并允许我们调度比仅仅动作更多的内容。由于
    `TestScheduler` 在内部使用一些与测试相关的其他类，我们将首先查看它们，然后再回到 `TestScheduler`。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As its name suggests the `VirtualTimeScheduler` doesn't work with real time.
    The delays we set when calling the `schedule()` method are only used to execute
    actions in the correct order.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，`VirtualTimeScheduler`不与真实时间一起工作。当我们调用`schedule()`方法时设置的延迟仅用于按正确顺序执行动作。
- en: HotObservable and ColdObservable
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HotObservable和ColdObservable
- en: We know what hot and cold Observables are from [Chapter 02](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 2. Reactive Programming with RxPHP") , *Reactive Programming with RxPHP*.
    These have their universal variants as `HotObservable` and `ColdObservable` classes.
    Note that these are intended only for testing and not for production usage.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从[第二章](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d "第二章。使用RxPHP进行响应式编程")，*使用RxPHP进行响应式编程*中了解到热Observables和冷Observables是什么。它们有通用的变体，作为`HotObservable`和`ColdObservable`类。请注意，这些仅用于测试，而不是用于生产使用。
- en: 'We''ll first have a look at how `HotObservable` can be used, and then talk
    about each class used in this example separately:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看看如何使用`HotObservable`，然后分别讨论这个例子中使用的每个类：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We used two new classes, `Recorded` and `OnNextNotification`, which we haven''t
    met yet, so let''s talk about them:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了两个新的类，`Recorded`和`OnNextNotification`，我们之前还没有遇到过，所以让我们来谈谈它们：
- en: '`HotObservable`/`ColdObservable`: This class creates a hot or cold Observable,
    respectively. It takes as its argument a Scheduler and an array of actions that
    need to be scheduled for execution on the Scheduler we provide.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HotObservable`/`ColdObservable`: 这个类分别创建一个热或冷Observables。它接受一个调度器和需要在我们提供的调度器上调度执行的动作数组作为其参数。'
- en: '`Recorded`: This class represents a single message (instead of a callable we
    used in the previous examples) scheduled for delayed execution. This class has
    a very important method, `equal()`, to compare two instances for equal value,
    time of invocation, and message type.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Recorded`: 这个类表示一个用于延迟执行的单个消息（而不是我们在上一个例子中使用的可调用者）。这个类有一个非常重要的方法，`equal()`，用于比较两个实例是否具有相等的值、调用时间和消息类型。'
- en: '`OnNextNotification`: The action itself is represented by an instance of this
    class. It takes only one parameter representing its value, and its only purpose
    is to call `onNext()` on an observer when invoked. There are also `OnErrorNotification`
    and `OnCompletedNotification` classes, calling `onError` and `OnComplete` methods,
    respectively.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnNextNotification`: 这个动作本身由这个类的实例表示。它只接受一个参数来表示其值，并且它的唯一目的是在调用时在观察者上调用`onNext()`。还有`OnErrorNotification`和`OnCompletedNotification`类，分别调用`onError`和`OnComplete`方法。'
- en: 'When we run this example, we get the following result:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个例子时，我们得到以下结果：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The difference between `HotObservable` and `ColdObservable` is when they schedule
    their actions. The `HotObservable` class schedules everything right in its constructor,
    while `ColdObservable` does everything on subscription.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`HotObservable`和`ColdObservable`之间的区别在于它们调度动作的时间。`HotObservable`类在其构造函数中立即调度所有内容，而`ColdObservable`在订阅时执行所有操作。'
- en: MockObserver
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MockObserver
- en: Just like when we talked about testing asynchronous code and that we need to
    be able to tell when callables weren't called at all, we need the same thing in
    RxPHP when testing Observables. RxPHP comes with class `MockObserver`, which records
    all the messages it receives (including the exact time for each record from the
    Scheduler), so we can later compare them with expected messages in the correct
    order.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 就像当我们讨论测试异步代码并且需要能够判断可调用者是否根本未调用时，在测试RxPHP中的Observables时，我们也需要相同的功能。RxPHP提供了一个名为`MockObserver`的类，它记录它接收到的所有消息（包括每个记录的确切时间从调度器），这样我们就可以稍后按正确的顺序将它们与预期的消息进行比较。
- en: 'Consider the following code printing all messages from `MockObserver`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，它打印出`MockObserver`的所有消息：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Notice that we''ve also included `OnCompletedNotification`, which is called
    before the last value:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们还包括了`OnCompletedNotification`，它在最后一个值之前被调用：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can see that the value in each message is wrapped with the type of notification
    we used. Also, the last `onNext` call is recorded as well, even though it was
    emitted after `onComplete`. This is the correct behavior of `MockObserver`, because
    its only goal is to record messages and not to perform any logic.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，每个消息中的值都被我们使用的通知类型所包装。此外，最后一个`onNext`调用也被记录下来，即使它是在`onComplete`之后发出的。这是`MockObserver`的正确行为，因为它的唯一目标是记录消息，而不是执行任何逻辑。
- en: TestScheduler
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TestScheduler
- en: Now let's come back to the `TestScheduler` class we mentioned when talking about `VirtualTimeScheduler`.
    This class inherits `VirtualTimeScheduler` and provides a couple of methods related
    to scheduling events.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到之前在谈论 `VirtualTimeScheduler` 时提到的 `TestScheduler` 类。这个类继承自 `VirtualTimeScheduler`，并提供了一些与调度事件相关的方
    法。
- en: 'We''ll start with an example again and see what `TestScheduler` does for us:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次通过一个示例来开始，看看 `TestScheduler` 为我们做了什么：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We created five messages and we're expecting to receive only three. Also, this
    time, we're using the method `equals()` on instances of `Recorded` to compare
    them to each other. This will make sure we're receiving the correct number of
    messages in the correct order.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了五条消息，我们期望只收到三条。此外，这次我们使用 `equals()` 方法在 `Recorded` 实例上比较它们，以确保我们以正确的顺序收到了正确数量的消息。
- en: 'Let''s run this example and check that we receive messages as we expect in
    the `$expected` array, and then talk about what happens inside and why:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个示例，并检查我们是否按照 `$expected` 数组中预期的那样收到了消息，然后讨论内部发生的事情以及原因：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'So, where did the other two messages disappear to? The `TestScheduler` class
    has two very important methods for scheduling actions, which we''re going to use
    when testing RxPHP code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，其他两条消息去哪里了呢？`TestScheduler` 类有两个非常重要的方法用于调度动作，我们在测试 RxPHP 代码时会使用到这些方法：
- en: '`startWithTiming($create, $createTime, $subscribeTime, $disposeTime)`: This
    method schedules three actions. These actions are: creating an instance of the
    source Observable, subscribing to the Observable and finally disposing a disposable
    returned from the `subscribe()` call. Each action is scheduled for a specific
    time by one of the arguments. Since creating an instance of Observable is one
    of the scheduled actions, it needs to be passed as a callable that returns the
    Observable, and not directly as an argument.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startWithTiming($create, $createTime, $subscribeTime, $disposeTime)`: 这个方法调度三个动作。这些动作包括：创建源
    Observable 的实例、订阅 Observable 以及最终处置从 `subscribe()` 调用返回的可处置对象。每个动作都通过其中一个参数调度到特定的时间。由于创建
    Observable 实例是调度动作之一，因此需要传递一个返回 Observable 的可调用对象，而不是直接作为参数。'
- en: '`startWithCreate($create)`: This method calls the `startWithTiming()` method
    with default values. It''s equal to calling `startWithTiming($create, 100, 200,
    1000)`. The only argument is a callable that returns the source Observable.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startWithCreate($create)`: 这个方法使用默认值调用 `startWithTiming()` 方法。它等同于调用 `startWithTiming($create,
    100, 200, 1000)`。唯一的参数是一个返回源 Observable 的可调用对象。'
- en: Both these methods return an instance of `MockObserver`, which is also used
    to subscribe to the source Observable, so we don't need to create it ourselves.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法都返回 `MockObserver` 的一个实例，它也用于订阅源 Observable，因此我们不需要自己创建它。
- en: Now it should be obvious why we received just three messages when we actually
    scheduled five. The message delayed by 180 happens before we subscribe to the
    source Observable, and the last message, with a delay of 1200, happens after we've
    already called `dispose()`, which unsubscribed `TestObserver` from the source
    Observable.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该很明显，为什么我们实际上调度了五条消息，但只收到了三条。延迟 180 毫秒的消息在我们订阅源 Observable 之前发生，而最后一条延迟 1200
    毫秒的消息在我们已经调用 `dispose()` 方法之后发生，这导致 `TestObserver` 从源 Observable 中取消订阅。
- en: Comparing actual and expected messages with a `foreach` loop is, of course,
    possible, but it would be very tedious to do this in every single test we write.
    That's why RxPHP comes with `Rx\Functional\FunctionalTestCase` class, which we
    can use instead of `PHPUnit\Framework\TestCase` and which adds assertion methods
    specific to RxPHP code, most notably the `assertMessages()` method, which compares
    arrays of messages, just as we did in this example.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `foreach` 循环比较实际和预期的消息当然是可能的，但在我们编写的每个测试中这样做都会非常繁琐。这就是为什么 RxPHP 提供了 `Rx\Functional\FunctionalTestCase`
    类，我们可以用它来代替 `PHPUnit\Framework\TestCase`，并且它添加了针对 RxPHP 代码的特定断言方法，最显著的是 `assertMessages()`
    方法，它比较消息数组，就像我们在本例中所做的那样。
- en: Testing SumOperator
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 SumOperator
- en: All these classes are used by RxPHP to test its own code. Now we'll use them
    to test our own Observables and operators as well.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类都是 RxPHP 用于测试其自身代码的。现在我们将使用它们来测试我们自己的 Observables 和算子。
- en: 'For testing purposes, we''re going to write a simple operator that calculates
    the sum of all the integers it receives. When an `onComplete` arrives, it emits
    a single `onNext` with the sum of all numbers. It also emits `onError` when a
    non-integer value arrives:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，我们将编写一个简单的算子，该算子计算它接收到的所有整数的总和。当 `onComplete` 到达时，它发出一个包含所有数字总和的单个 `onNext`。它还在接收到非整数值时发出
    `onError`：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This operator is very straightforward, and since we already know all the utilities
    we need to properly test it, we can jump right into unit testing with PHPUnit.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算子非常直接，因为我们已经知道所有必要的工具来正确测试它，所以我们可以直接使用 PHPUnit 进行单元测试。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In fact, RxPHP already has a `sum()` operator, which is internally implemented
    as a `reduce()` operator that just adds values.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，RxPHP 已经有一个 `sum()` 算子，它内部实现为一个 `reduce()` 算子，只是添加值。
- en: Instead of `PHPUnit\Framework\TestCase`, we'll use `Rx\Functional\FunctionalTestCase`,
    which creates `TestScheduler` internally and automatically passes it to new hot/cold
    Observables, so we don't need to worry about Schedulers at all.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `Rx\Functional\FunctionalTestCase` 而不是 `PHPUnit\Framework\TestCase`，它内部创建
    `TestScheduler` 并自动将其传递给新的热/冷可观察对象，所以我们根本不需要担心调度器。
- en: RxPHP also contains a few helper functions to simplify creating `Recorded` objects.
    Instead of calling `new Recorded(200, new OnNextNotification(3))`, we can use `onNext(200,
    3)` function defined in the `rxphp/test/helper-functions.php` file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: RxPHP 还包含一些辅助函数来简化创建 `Recorded` 对象。我们不需要调用 `new Recorded(200, new OnNextNotification(3))`，而是可以使用在
    `rxphp/test/helper-functions.php` 文件中定义的 `onNext(200, 3)` 函数。
- en: 'In order to use these functions, and also the `FunctionalTestCase` class, we
    need to tell the autoloader where to find them by updating our `composer.json`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这些函数以及 `FunctionalTestCase` 类，我们需要通过更新我们的 `composer.json` 来告诉自动加载器它们的位置：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After updating `composer.json`, we need to regenerate the `autoload.php` script
    as well:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新 `composer.json` 之后，我们还需要重新生成 `autoload.php` 脚本：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we can use `onNext()`, `onComplete()`, `onError()`, and also the `FunctionalTestCase`
    class (don''t interchange the `onNext()` function from `helper-functions.php`
    with the `onNext()` method in observers; these are two separate things). Thanks
    to all this, the test class will then be pretty short:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `onNext()`、`onComplete()`、`onError()` 以及 `FunctionalTestCase` 类（不要将
    `helper-functions.php` 中的 `onNext()` 函数与观察者中的 `onNext()` 方法混淆；这是两件不同的事情）。多亏了所有这些，测试类将会相当短：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This test schedules a couple of messages and completes the Observable at time
    `460`, which causes the `SumOperator` to emit its accumulated value, and also
    to complete right after that.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试安排了一些消息并在时间 `460` 时完成可观察对象，这导致 `SumOperator` 发出其累积的值，并在之后立即完成。
- en: The callable for the `startWithCreate()` method creates a `HotObservable` class
    and connects it with our `SumOperator` using the `lift()` method we talked about
    extensively and used in  [Chapter 03](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 3. Writing a Reddit Reader with RxPHP") , *Writing a Reddit Reader with
    RxPHP*. At the end, we used `assertMessages()` to compare messages received by `MockObserver`
    with expected messages, just as we did in the previous example. Using `assertMessages()`
    from `FunctionalTestCase` is just more comfortable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`startWithCreate()` 方法的可调用函数创建了一个 `HotObservable` 类，并使用我们广泛讨论并用于 [第 03 章](part0033_split_000.html#VF2I2-bd355a22cf10407cb10df27e65585b8d
    "第 3. 编写 Reddit 读者使用 RxPHP")，*编写 Reddit 读者使用 RxPHP* 中提到的 `lift()` 方法，将其与我们的 `SumOperator`
    连接起来。最后，我们使用 `assertMessages()` 来比较 `MockObserver` 收到的消息与预期消息，就像我们在上一个示例中所做的那样。使用
    `FunctionalTestCase` 中的 `assertMessages()` 确实更加方便。'
- en: 'We can run the test to see that it really passes successfully:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行测试来查看它是否真的成功通过：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that even when `assertMessages()` has to compare two messages and make
    sure both arrays are the same size, it counts as a single assertion.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使 `assertMessages()` 必须比较两个消息并确保两个数组大小相同，它也只算作一个断言。
- en: 'Now let''s also test a situation where we pass an invalid value (a string in
    this case) that causes an `onError` message:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们也测试一种情况，我们传递一个无效的值（在这种情况下是一个字符串），这会导致一个 `onError` 消息：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We expect to receive an `onError` message at `250` and that's all. Even though
    there are two more messages scheduled, they won't arrive at `TestObservable`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望在 `250` 时收到一个 `onError` 消息，就这些。即使还有两个更多消息被安排，它们也不会到达 `TestObservable`。
- en: 'Of course, these two tests pass as expected:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这两个测试正如预期那样通过：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Testing ForkJoinObservable
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 ForkJoinObservable
- en: Now we can have a look at a slightly more complicated example. In RxPHP, there's
    an interesting operator called `forkJoin()`. This operator takes as its parameter
    an array of Observables, collects the last value emitted for each of them, and
    when they all complete, emits a single array with the last values for each Observable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看看一个稍微复杂一点的例子。在 RxPHP 中，有一个有趣的算子叫做 `forkJoin()`。这个算子接受一个可观察对象的数组作为参数，收集每个可观察对象发出的最后一个值，当它们全部完成时，它会发出一个包含每个可观察对象最后一个值的单个数组。
- en: 'This will make better sense when we look at the following marble diagram for
    `forkJoin()` operator in RxJS:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing ForkJoinObservable](img/00023.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: Marble diagram representing the forkJoin() operator in RxJS (http://reactivex.io/documentation/operators/zip.html)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to implement a simplified version of the `forkJoin()` operator
    as an Observable. To make it extra clear what it does, we''ll start with an example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will print the last value from each source Observable:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Our implementation will subscribe to each source Observable and keep the latest
    value emitted for each of them. Then, when all of them complete, it emits one
    `onNext()` and one `onComplete`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are just a couple of nested anonymous functions. Note that we also need
    to store all disposables in `CompositeDisposable` to be able to properly dispose
    all of them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing this class is very similar to what we did before. Pay special attention
    to the delays we use for each of the message calls:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We expect to receive `onNext()` with the last values for each source Observable
    at `800`, because this is the time when the second Observable completes. Also,
    even though the first Observable emitted one more value after its `onComplete`
    call, this will be ignored because it has already completed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, if we run the test case, it will pass as expected:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The most important thing we should keep in mind when testing RxPHP code is that
    time of invocation matters.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: We could, of course, just test that our Observables and operators produce the
    correct values, but this could leave some bugs unnoticed and hard to find. To
    take a specific example, a bug could cause an Observable to pass along values
    even after it was supposed to complete, or to fail on an error.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting scenario we can test is when one of the Observables never
    completes. In this case `ForkJoinObservable` won''t emit any value and not even
    the  `onComplete` signal:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If we reran the `ForkJoinObservableTest` class, we'd see that this test passes
    as well.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The real implementation of `ForkJoinObservable` is in RxPHP available since
    version 1.5 and is slightly more complicated. We'll come back to it in [Chapter
    10](part0070_split_000.html#22O7C1-bd355a22cf10407cb10df27e65585b8d "Chapter 10. Using
    Advanced Operators and Techniques in RxPHP"), *Using Advanced Operators and Techniques
    in RxPHP*. In [Appendix](part0081_split_000.html#2D7TI2-bd355a22cf10407cb10df27e65585b8d
    "Chapter Appendix.  Reusing RxPHP Techniques in RxJS"), *Reusing RxPHP Techniques
    in RxJS*, we'll learn about the new way of testing Rx code called "marble tests"
    implemented in RxPHP 2 and RxJS 5.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered unit testing code written using PHPUnit with utilities
    provided by the RxPHP package.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, we went through the `doOn*()` operators and the basics of
    unit testing with PHPUnit, and the problems we need to be aware of when unit testing
    asynchronous code. Next, we went in-depth into which classes aimed at unit testing
    are provided by RxPHP, how to use each of them, and which problems they solve.
    In particular, these were the `VirtualTimeScheduler`, `HotObservable`,  `ColdObservable`, `TestScheduler`,
    and `FunctionalTestCase` classes. In addition to this, we wrote example `SumOperator`
    and `ForkJoinObservable` classes to demonstrate how important it is to test that
    messages are emitted and received at the correct times.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们学习了 `doOn*()` 操作符以及使用 PHPUnit 进行单元测试的基础，以及在进行异步代码单元测试时需要注意的问题。接下来，我们深入探讨了
    RxPHP 提供的旨在单元测试的类，如何使用它们，以及它们解决的问题。特别是，这些是 `VirtualTimeScheduler`、`HotObservable`、`ColdObservable`、`TestScheduler`
    和 `FunctionalTestCase` 类。除此之外，我们还编写了示例 `SumOperator` 和 `ForkJoinObservable` 类，以展示在正确的时间发出和接收消息的重要性。
- en: In the following chapter, we'll have a deeper look at event loops in PHP and
    we'll introduce a more advanced concept of higher-order Observables in RxPHP.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更深入地探讨 PHP 中的事件循环，并介绍 RxPHP 中的更高阶的概念——高阶可观察者。
