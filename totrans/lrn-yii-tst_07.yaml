- en: Chapter 7. Having Fun Doing Browser Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have finally arrived at the last stage of testing: **acceptance testing**.
    This is the topmost way of testing your application with Codeception in Yii.'
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the initial chapters , functional and acceptance tests are quite
    similar in form and implementation, so you won't see anything particularly new
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to grasp the nature of the tests that we are going to create.
    We can recall from [Chapter 6](ch06.html "Chapter 6. Testing the API – PHPBrowser
    to the Rescue"), *Testing the API – PHPBrowser to the Rescue*, that functional
    tests are used to ensure the technical correctness of what we've built from a
    higher standpoint than unit tests. Whereas acceptance tests are the best way of
    ensuring that the acceptance criteria that were defined at the very beginning
    are still standing after everything is implemented and put together.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to review the existing tests, install and configure
    **Selenium,** and then implement a small feature that will tie everything together
    with the work that has already been done.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss two main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Selenium WebDriver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating acceptance tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Selenium WebDriver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yii is shipped with some acceptance tests. They cover the same elements as the
    functional tests that we've already seen. The only difference between these two
    tests is technical, and by looking at the configuration you can see that they've
    been configured to run with PHPBrowser. This setup may be good enough for you,
    or it may even be better because PHPBrowser runs faster than the available acceptance
    testing suites.
  prefs: []
  type: TYPE_NORMAL
- en: Setting aside PHPBrowser, which we've covered in [Chapter 6](ch06.html "Chapter 6. Testing
    the API – PHPBrowser to the Rescue"), *Testing the API – PHPBrowser to the Rescue*,
    Codeception can be used with other testing suites, which can perform more realistic
    frontend tests, including the JavaScript interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the choices you can have are Selenium WebDriver and PhantomJS. We won't
    touch PhantomJS, and it should be sufficient to know that it is a headless browser
    testing suite, which uses the WebDriver interface definition.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium WebDriver is also known as Selenium 2.0 + WebDriver. Together with
    Cucumber, it is probably the most well-known frontend testing tool available.
    Their use has been improved by some big companies, such as Google. They are stable
    and have lots of features.
  prefs: []
  type: TYPE_NORMAL
- en: This is a somewhat natural evolution of Selenium 1.0, which had limitations,
    such as using JavaScript for interacting with web pages. For this reason, it was
    running on the JavaScript sandbox. This meant that, in order to get around the
    same-origin policy, it had to run in conjunction with a Selenium RC server, which
    had some issues with the browser setup.
  prefs: []
  type: TYPE_NORMAL
- en: Now the Selenium Server has replaced the RC, while remaining retro-compatible
    and supporting WebDriver natively.
  prefs: []
  type: TYPE_NORMAL
- en: WebDriver uses a native implementation of the browser to interact with it. This
    means that it might not always be available for a specific combination of language
    /device. However, it provides the best flexibility for controlling a page without
    needing emulation.
  prefs: []
  type: TYPE_NORMAL
- en: Codeception uses a PHP implementation called php-webdriver, which was developed
    by Facebook; its source code and issue tracker can be found at [https://github.com/facebook/php-webdriver](https://github.com/facebook/php-webdriver).
  prefs: []
  type: TYPE_NORMAL
- en: In its simplest implementation and configuration, the Selenium Server just listens
    for calls as a service on a specific machine, and fires up the browser on the
    request to perform the tests.
  prefs: []
  type: TYPE_NORMAL
- en: So, as a first step, we need to install the Selenium Server, run it, configure
    it in Codeception, adjust the already existing tests such that they work with
    it, and then add the new tests to it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and running Selenium Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From version 1.7 onwards, Codeception includes the out-of-the-box php-webdriver
    library.
  prefs: []
  type: TYPE_NORMAL
- en: As reported in the documentation, which can be found either from Codeception
    ([http://codeception.com/11-20-2013/webdriver-tests-with-codeception.html](http://codeception.com/11-20-2013/webdriver-tests-with-codeception.html))
    or from the official page of Selenium ([http://docs.seleniumhq.org/docs/03_webdriver.jsp](http://docs.seleniumhq.org/docs/03_webdriver.jsp)),
    you need to download the server binary and then run it on the machine from, which
    you intend to run your browser.
  prefs: []
  type: TYPE_NORMAL
- en: Head to [http://www.seleniumhq.org/download/](http://www.seleniumhq.org/download/)
    and download the latest version of the software. In my case, it would be `selenium-server-standalone-2.44.0.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where you save it doesn''t matter because once it starts, its server will be
    listening to any network interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Configuring Yii to work with Selenium
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to have Codeception automatically pick up and use WebDriver, we need
    to adjust our acceptance suite configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is a straightforward process. We need to replace the PHPBrowser module
    with WebDriver and configure it.
  prefs: []
  type: TYPE_NORMAL
- en: '`url` (required): This is the hostname used to connect to your application
    to perform the tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`browser` (required): This will specify the browser that you want to use. Some
    other drivers are also available for mobile phones (Android and iOS), and more
    information about these can be obtained from the online Selenium documentation,
    available at [http://docs.seleniumhq.org/docs/03_webdriver.jsp#selenium-webdriver-s-drivers](http://docs.seleniumhq.org/docs/03_webdriver.jsp#selenium-webdriver-s-drivers).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host`: This key specifies the machine that will run the Selenium Server. By
    default, it will connect to your localhost. For example, I am using the VirtualBox
    host machine IP address. You can also specify the port and by default, it will
    use `4444`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restart`: This tells WebDriver to reset a session when a test is performed.
    This is particularly handy if you don''t want a state to be carried over from
    one test to another. For instance, you can use this when you need to (re)set the
    cookies to test the auto login functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window_size`: This just specifies the size of the window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other options, some of which will be quite handy for testing with
    multiple browsers. In particular, you have the ability to set the desired capabilities
    for Selenium 2.0, such as being able to pass a specific profile for the browser
    (quite handy when performing regression testing) and so on. More information about
    the WebDriver module, albeit not as much as I'd love to see, can be found on the
    Codeception documentation page at [http://codeception.com/docs/modules/WebDriver](http://codeception.com/docs/modules/WebDriver).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing WebDriver-led tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start implementing the interface that will hook into the API, which
    we implemented in [Chapter 6](ch06.html "Chapter 6. Testing the API – PHPBrowser
    to the Rescue"), *Testing the API – PHPBrowser to the Rescue*, it would be quite
    useful to look at the existing acceptance tests and see if there's anything new
    that we need to take into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find four tests: `HomeCept`, `AboutCept`, `LoginCept`, and `ContactCept`.'
  prefs: []
  type: TYPE_NORMAL
- en: As stated previously, the syntax is not unusual, and we can see that the level
    of knowledge of the underlying structure is more limited than the functional tests
    that we've covered.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing that we need to stress on once again is that all the actions
    that our `AcceptanceTester` can perform on the page, such as `click()`, `fillField(),`
    and the assertions that it can perform, such as `see()`, `seeLink()` and so on,
    accept a so-called Locator as one of its actual parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The Locator parameter can be either a string or an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'When passed as a string or a **fuzzy locator,** as it is called in the Codeception
    terminology, it tries to guess what you''re looking for by formally going through
    a series of steps. If you write `click(''foo'')`, then it will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It tries to find the element with the ID `#foo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It tries to find the class `.foo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it interprets it as an XPath expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it will throw an `ElementNotFound` exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can be more prescriptive when using the array notation or a **strict locator**.
  prefs: []
  type: TYPE_NORMAL
- en: '`[''id'' => ''foo'']` matches `<div id="foo">`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[''name'' => ''foo'']` matches `<div name="foo">`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[''css'' => ''input[type=input][value=foo]'']` matches `<input type="input"
    value="foo">`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[''xpath'' => "//input[@type=''submit''][contains(@value, ''foo'')]"]` matches
    `<input type="submit" value="foobar">`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[''link'' => ''Click here'']` matches `<a href="google.com">Click here</a>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[''class'' => ''foo'']` matches `<div class="foo">`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding examples have been taken from the Codeception documentation, which
    can be found at [http://codeception.com/docs/modules/WebDriver](http://codeception.com/docs/modules/WebDriver).
  prefs: []
  type: TYPE_NORMAL
- en: 'This explains clearly how to interact with the webpage. Now, the other important
    bit can be found in the already existing tests, such as `LoginCept` and `ContactCept`.
    Here, right before asserting the presence of the validation errors, we have the
    following condition-led statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Selenium introduces two types of wait: an implicit one and an explicit one.
    These cause the information to be fetched from the server, and then this information
    is interpreted and rendered.'
  prefs: []
  type: TYPE_NORMAL
- en: The implicit wait can be configured in the `acceptance.suite.yml` file, and
    it silently tells Selenium to poll for *X* seconds if the element it's looking
    for is not immediately available. By default, no implicit wait is set.
  prefs: []
  type: TYPE_NORMAL
- en: The explicit wait is similar to the preceding code snippet. Doing a simple `$I->wait(X)`
    triggers a `sleep()`, and allows the browser to perform the required operation.
    For example, it would help the browser in completing animations or finishing fetching
    and manipulating the server-side data.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways in which you can wait for something, and some of these
    ways can be a little more proactive, such as `waitForElement()`, `waitForElementChange()`,
    `waitForElementVisible()` and `waitForElementNotVisible()`. All these methods
    take a locator, using the aforementioned format, and a timeout in seconds as parameters.
    We will see how we can use these later on.
  prefs: []
  type: TYPE_NORMAL
- en: There are other methods provided by the WebDriver Codeception module that you
    can use, along with the ability to debug your tests, in case something doesn't
    go as you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to run the available tests and see them pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on which machine you'll be using for running these tests, their speed
    will change sensibly, although it will never be as fast as it's when performing
    unit tests, mostly because the whole browser stack has to be started for running
    these tests.
  prefs: []
  type: TYPE_NORMAL
- en: You will briefly see the browser opening and closing several times while performing
    the tests. Everything should look good at the end, and if it doesn't, then look
    into the `tests/codeception/_output/` folder. Here, you will find a markup and
    a screenshot of the page taken at the time of the failure. This debugging behavior
    is also found in the functional tests while using PHPBrowser.
  prefs: []
  type: TYPE_NORMAL
- en: Creating acceptance tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how the acceptance tests that use Selenium WebDriver are
    structured, we can start integrating the work done in the previous chapter and
    begin adding the tests we want.
  prefs: []
  type: TYPE_NORMAL
- en: For these kinds of tests, where normally the definition of the markup is left
    to whoever implements the layout, you would need to define the functionality of
    your interface, implement the tests, and then implement the markup and add the
    JavaScript functionality, if needed. After you've performed these, you will add
    the specifics of the DOM interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many developers leave the frontend functionality definition for
    the very end, working "tests first" will force you to change your way of working,
    anticipating with as much detail as needed what lies ahead and discovering immediately
    any critical aspects of the design.
  prefs: []
  type: TYPE_NORMAL
- en: We will try to implement something that is simple enough to get you started
    with from scratch and then you can improve upon or extend it later. We know that
    the HTTP Basic Auth, which we have used, does not permit a stateful login. Therefore,
    we will have to keep some sort of a session object in JavaScript to simulate it.
    How this is going to work can be taken from the tests that we have written for
    the User API. This is practical documentation at its best.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our scenario can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding syntax has been taken explicitly from the generated text version
    of our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the modal window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The work of implementing the modal window will be made easy by Bootstrap, which
    is a default framework bundled with the basic app.
  prefs: []
  type: TYPE_NORMAL
- en: The modal window is composed by an almost pre-determined markup and an additional
    JS, which provides the interaction part, thereby hooking it to the rest of the
    interface. I hope that the simplicity of its implementation will let you focus
    on the aim that lies behind it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code has deliberately been taken from the Bootstrap documentation,
    which can be found at [http://getbootstrap.com/javascript/#modals](http://getbootstrap.com/javascript/#modals).
    Since the modal window can be opened from any part of the website without going
    to the login page, we will have to add it to the overall layout template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have moved the modal form to a separate template, which will
    receive the model of the form as a variable, keeping everything self-contained
    and organized. Please note from where the model takes its value. We're going to
    discuss it while implementing the controller.
  prefs: []
  type: TYPE_NORMAL
- en: The `login-modal.php` template is just a rip-off of the original `login.php`
    template, which can be found in the same directory without `H1` in the title and
    the "remember me" checkbox. We just need to add a placeholder to show the error
    that is coming from the API. This is done to inform and debug it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can place this snippet right after the first paragraph of the copied markup.
  prefs: []
  type: TYPE_NORMAL
- en: Making the server side work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have said before, we want the modal window to be available everywhere.
    We are going to accomplish this by saving a publicly accessible property in the
    `SiteController`, so that we can retrieve it from the view. Remember that if you're
    coming from Yii 1, then views are now separate objects and not a part of the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the `init()` method to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once this is done, we can load our page without errors.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, we will add the interaction to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the JavaScript interaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will cover a couple of things in this section. We will discuss the basic
    functional interaction with the modal, the interaction with the form, and then
    learn how to close everything with the corner cases and error scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The interaction with the modal will be achieved by reusing the already existing
    login button, which is at the top right side of the menu. We will disable it,
    but remember that it will provide a fallback compatibility in case something goes
    wrong.
  prefs: []
  type: TYPE_NORMAL
- en: The basic open-and-close of the modal window is provided out-of-the-box. We
    will only trigger it when required, for example upon authentication success.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the first basic skeleton for the JS module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For this part of our application, we will need the module pattern for creating
    a self-contained application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by caching all the jQuery elements that we are going to need along
    the way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have logged in, we will swap the link with a "fake" logout button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need some data fields for holding our login information and creating
    some sort of a session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now comes the main part of our script, in which we will initialize our event
    listeners to the click and submit actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by appending and hiding our logout button; we will show it only
    when the login succeeds, and define the click action it should have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to disable the click event for the login button. Otherwise, we will
    be taken to the login page, instead of opening the modal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The modal triggering event is done automatically by modifying the markup of
    the login button. So, navigate to `views/layouts/main.php` and then adjust it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will deal with the form submission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After disabling the default submit event, we will need to capture the username
    and the password, and then save it for future use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `authorization` variable will hold our authorization header that is ready
    for dispatch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This code is simple enough. In case of success, we save the user ID for subsequent
    calls, we hide the login button and display the logout one, clear the error message,
    and hide the modal window. Otherwise, we just display the error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `beforesend` option will be initialized by the `authorize` function, which
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After doing this, we won't need anything else to interact with the page. So,
    let's put everything together.
  prefs: []
  type: TYPE_NORMAL
- en: Tying everything together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we only have to add our JS to the page and then finalize our
    tests. In order to add our file to the page, we need to know what assets and asset
    bundles are.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with Yii 2 assets bundles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yii 2 has radically changed the way assets are handled. It has introduced the
    concept of the asset bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Asset bundles are collections of scripts and style sheets that can have a higher
    degree of configurability as compared to the past.
  prefs: []
  type: TYPE_NORMAL
- en: 'This basic app already has a basic implementation. So, let''s navigate to `/assets/AppAsset.php`
    and see how the content is structured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `AppAsset` extends from the `yii\web\AssetBundle` class and it simply defines
    a series of public properties.
  prefs: []
  type: TYPE_NORMAL
- en: The first two properties, `$basePath` and `$baseUrl,` are the most important
    ones. `$basePath` defines where the assets are located on a publicly accessible
    location, while `$baseUrl` defines how their resource is linked to the web pages,
    that is, their URL.
  prefs: []
  type: TYPE_NORMAL
- en: This asset, by using these two properties, defines the so called "published
    asset". In other words, it defines a bundle of assets, which are available at
    a publicly accessible location.
  prefs: []
  type: TYPE_NORMAL
- en: You can have "external assets", which are comprised of resources from external
    locations, and "source assets", which are not comprised of resources from publicly
    available locations. These assets define only a `$sourcePath` property and Yii
    copies them to the publicly accessible assets folder, and names them accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Source assets are normally provided by libraries and widgets, and for this reason,
    we won't be covering them here. Published assets are recommended for incorporating
    assets into the page or pages by putting them somewhere in the `web/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: In the example earlier, you saw that we defined the asset dependencies, and
    in our case, it's done with jQuery and Bootstrap. This is exactly why we've used
    them for developing the main JavaScript module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we need to see how we can use the asset bundle for our markup. This
    can be done by looking at the top of the template view. For this, navigate to
    `/views/layouts/main.php`. Here, we can see these two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the old way of associating any asset with a specific layout, although
    it's not particularly advisable, hasn't been removed. This works in the same way
    as it was working in Yii 1, that is, by using `registerCssFile()` and `registerJsFile()`.
  prefs: []
  type: TYPE_NORMAL
- en: Assets have many other options, such as the ability to compress and compile
    SASS and LESS files, use Bower or NPM assets, and so on. Go to the documentation
    page, which is currently in a good shape and is quite comprehensive, at [http://www.yiiframework.com/doc-2.0/guide-structure-assets.html](http://www.yiiframework.com/doc-2.0/guide-structure-assets.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'For our work, we need to slightly adjust the asset bundle provided by adding
    the JS file and tweak it where it''s going to be added to the page, otherwise
    we will encounter some problems in running it before the page is parsed. Consider
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Once you've added the preceding lines to the asset bundle, you need to head
    back to the form template that is included in the modal. This, in fact, will generate
    some problems because it requires injecting some script into the page in order
    to make the client-side validation work. This is a major problem; most of the
    time you will have to override the way `ActiveForms` works, so you should learn
    how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The two options shown here will disable both the client-side validation and
    any additional scripting facility. Disabling only one option won't do the trick.
  prefs: []
  type: TYPE_NORMAL
- en: We can now load the page and no error message will be displayed on the console.
  prefs: []
  type: TYPE_NORMAL
- en: Finalizing the tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we just have to convert our scenarios into live code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start creating the test in the same way as we created unit tests and
    functional tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to the file and let''s start by asserting the initial statements:
    where we are and ensure that we are not logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this might seem like a simplistic way of determining whether the user
    is logged in, it serves the purpose. If we find that anything more complex is
    needed, then we can always add it to the mix later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important part of this test is the use of an explicit wait, `waitForElementVisible().`
    It does what it says on the tin: waits until the DOM element with class .modal
    is rendered and visible.'
  prefs: []
  type: TYPE_NORMAL
- en: The assertion made at the end does not check for any specific errors. So feel
    free to add any level of customization here, as I've tried to be as generic as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same goes for the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This interesting part of the test comes when we''re trying to access using
    valid credentials. In fact, as we''ve seen in the script we created previously,
    the modal window will be dismissed and the login button will be replaced by the
    logout link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to do this, we need to add another explicit wait for the AJAX call
    to complete and then the window will disappear. Using `waitForElementNotVisible()`
    might not do the trick because it involves animation. It also depends on the responsiveness
    of the system you''re testing on because it might not work as expected and fail
    from time to time. So, `wait()` seems like the simplest solution for the problem.
    Consider this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The last test doesn't need much attention and you should be able to understand
    it without facing any problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have put together our tests, let''s run them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Testing multiple browsers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Version 1.7 onwards, Codeception also provides a method for testing multiple
    browsers. This is not particularly difficult, and it can ensure that cross-browser
    compatibility is achieved.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is normally done by configuring environments in the `acceptance.suite.yml`
    file by adding something similar to the following at the bottom of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Each key under the `env` variable represents a specific browser you want to
    run the test on, and this is done by overriding the default configuration that
    we have already defined.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Within `env`, you can override just about any other key that was specified in
    the YAML configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: You can have several machines, each having different versions of the browsers,
    with Selenium Server listening on them, so you can also perform retro-compatibility
    tests when deciding which polyfills to use for the new features introduced recently
    and also depending on your browser support chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to trigger the various environments, just append the `--env <environment>`
    parameter to the `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Internet Explorer requires its own driver to be installed on the host machine
    and a few more steps to be performed to set it up correctly, which is covered
    in the Selenium documentation, which can be found at [https://code.google.com/p/selenium/wiki/InternetExplorerDriver](https://code.google.com/p/selenium/wiki/InternetExplorerDriver).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Selenium limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, you have probably seen how powerful Selenium is. By using the browser
    natively, you can finally interact with the website programmatically. This will
    save a huge portion of time that is normally spent by human beings on doing repetitive
    tasks. Repetitiveness is only a cause of problems when it comes into the hands
    of humans, so this is effectively a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately Selenium can't do everything, and if you have already started
    looking into it and researching its full use and potential, then you might have
    noticed that there are some limitations of its use.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly any kind of "pixel-perfect" tests are nearly impossible to recreate
    with Selenium, although some types of tests on designs can be created, specifically
    for responsive designs. Other frameworks, such as Galen cover this functionality
    ([http://galenframework.com/](http://galenframework.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: A few words need to be spent on hover effects, as they might be quite difficult
    to achieve and you may need to use the `moveMouseOver()` method for triggering
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered the final aspect of testing in this chapter. We've gone through
    the provided tests. We have also understood any additional syntax, configured
    Selenium, run the first batch of tests, and then moved on to implementing and
    tying the API previously developed into the interface with a modal login feature.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn about a lot of logs and how information
    can be generated by our tests to better our understanding of testing. We will
    also see if we've missed anything.
  prefs: []
  type: TYPE_NORMAL
