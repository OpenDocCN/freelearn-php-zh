<html><head></head><body>
		<div id="_idContainer008">
			<h1 id="_idParaDest-32" class="chapter-number"><a id="_idTextAnchor031"/>3</h1>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Code, Don’t Do Stunts</h1>
			<p>The advanced principles of clean code will actually help you to become an easily understood developer who is able to code more cleanly. They teach you to be consistent in your choices, to think about other developers and your team, and to make communication the main tool of our work. Even before the source code.</p>
			<p>It’s a fact: although the source code has a preponderant place in the developer’s job, we should not make it our main reason to be. It is a reality: the developer’s job is not to write code. It’s about finding a solution to a given problem while adapting to constraints that would get in the way. This is the basis of our job that we must absolutely keep in mind. And although the principles we have just seen in the previous chapter, such as SOLID, seem to be strongly linked to the code, we must try to have a more <em class="italic">“meta”</em> perspective on all this, thinking outside the box, and taking a step back. The principles mentioned are, objectively, tools that will allow us to solve the problems posed in an efficient and straightforward way.</p>
			<p>We can then ask ourselves the following questions: What is the real purpose of source code? What is its purpose, and can we allow ourselves to do anything with the most basic things in the language?</p>
			<p>These are the topics we’ll be covering in this chapter: </p>
			<ul>
				<li>Understanding code</li>
				<li>Be understood, not clever</li>
				<li>A note on maintainability</li>
			</ul>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Understanding code</h1>
			<p>Let’s first ask <a id="_idIndexMarker056"/>ourselves about the importance of code. What really is its importance for us developers in our daily lives? For that, let’s go back in time.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>A bit of history</h2>
			<p>Computer <a id="_idIndexMarker057"/>programming is, in fact, a transistor through which an electric current passes or does not pass. So, we end up with a binary system, with a value of <strong class="source-inline">0</strong> if the electric current does not pass through the transistor, and <strong class="source-inline">1</strong> if the electric current does pass. If you multiply this number of transistors by several billion, you end up with today’s processors. It works very well, and our world has been governed by this system for decades. However, there is a clear limitation: it is not humanly possible to understand and create applications with only 0s and 1s. So, we had to find a new way of writing these programs so that they became humanly possible and manageable.</p>
			<p>We then move to the first human-readable source code: the <strong class="bold">assembly</strong> language (often abbreviated <strong class="bold">ASM</strong>). Popularized <a id="_idIndexMarker058"/>at the end of the 1940s, this language finally made it possible to read files with a language that is more or less similar to our natural language, although assembly is a very low-level language (meaning that it is remarkably close to the language of the machine—namely, binary). One thing led to another, and higher-level languages appeared—the C language being the best known, seeing its first official version in 1972. The principle is simple: to be able to write computer programs with a language that is more and more natural for human beings. A tool then automatically translates this higher-level language into assembly and binary language that the machine can interpret.</p>
			<p>The C language is <a id="_idIndexMarker059"/>an excellent example of the usefulness and main purpose of a programming language. Indeed, this language, created by Dennis Ritchie and Brian Kernighan, was originally used to develop the Unix operating system. The point is that it was easier to create a programming language such as C to write the Unix operating system than to write the operating system with the tools of the time—namely, assembler (even if some parts of the Unix operating system are written in assembly, the vast majority of the source code is written in the C language). We’ll look at the actual purpose of programming languages and code next.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>The purpose of code</h2>
			<p>And <a id="_idIndexMarker060"/>this is where it all makes sense. The programming languages are there to help us to transcribe our ideas as easily as possible, and they are interpretable by the machine. But programming languages are not limited to transcribing our ideas to machines—their goal is also that other people can understand our ideas by reading our code, and without needing us. Programming languages are a subtle mix of the potential to be understood by a human while giving us the leeway to communicate with the machine and the possibilities to exploit its full potential. This is what <a id="_idIndexMarker061"/>defines the level of a programming language when we talk about high-level and low-level languages: the position of the cursor is between “ease of use and understanding” and “performance and possibilities offered by the language”. There are necessary trade-offs to be made. These are things to have in mind when choosing the most appropriate programming language when kicking off a new project. A perfect example is all the tools <a id="_idIndexMarker062"/>bundled in the <strong class="bold">PHP: Hypertext Preprocessor</strong> (<strong class="bold">PHP</strong>) language to deal <a id="_idIndexMarker063"/>with <strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) requests and responses, which makes it an excellent choice to create a web application. Most of the things you will need are already present, out of the box, and without the need to install anything to deal with the most basic and some pretty advanced web application features.</p>
			<p>PHP is written in C; it is a higher-level language than the C language. It is, therefore, easier to understand and more permissive but offers, in comparison to C, less extended performance and fewer possibilities. If you ever need to write some assembly code in PHP to communicate with some custom hardware, for instance, the statement is simple: you cannot. You will have to write a PHP extension, which will be written in the C language (which then allows you to write source code parts in the assembly language). This is a super-advanced case, of course, but you get the point.</p>
			<p>Let’s go further by comparing PHP and <strong class="bold">Hypertext Markup Language</strong> (<strong class="bold">HTML</strong>). Although HTML is <a id="_idIndexMarker064"/>not a programming language but a description language, it still has similarities with PHP: both languages are used to express human ideas that can be interpreted by the machine. The point is simple: for someone who doesn’t really know technical and programming languages, you will certainly be able to explain the content of an HTML file, what it represents, its semantics, and its <a id="_idIndexMarker065"/>purpose. In PHP, it’s a different matter. Indeed, between file splitting, class splitting, <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>), and all these other concepts, it will certainly take you much more time to make your non-technical interlocutor understand the purpose of all this. However, although HTML does not allow OOP, it does not allow conditional branching, writing to a file, managing requests sent to the server, and so on. So, we end up with a language that is much more understandable to a human being because it is very close to our natural language but with much fewer possibilities.</p>
			<p>Despite these differences, we must keep in mind the following thing—the languages’ main objective is exactly the same: to be understood by the greatest number of people and by the computer. Writing code means being understandable. It is to expose ideas. And just as in everyday life when you expose your ideas, the simpler and more straightforward you are, the more people will be able to understand you.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Be understood, not clever</h1>
			<p>It happens very often that in front of technical challenges and especially in source code, we want to do things in a fine, pretty, even “sexy” way, as some would say. This is completely normal—since code is a major part of our lives as developers, we sometimes want to show the extent of our abilities. Although this can be justified at times, it is often an awfully bad idea to want to show the complete extent of these talents. Obviously, our ego takes a hit—we must hold back sometimes. You just learned new ways of doing things, new ways of coding, and new principles of which you are ardently convinced. You have spent a weekend learning this new way of organizing your code and your project, you experience it as a revelation, and you are sure of it: you must show this new discovery to your colleagues and your team; it will revolutionize the project and bring only good things. Moreover, you will be given the credit for this new thing, and you will be the referent of it. However, this is not the right approach at all.</p>
			<p>Don’t be mistaken. Learning every day, on your own time or not, is an exceptional thing. If you have the opportunity to do so, you will come out better. On a side note: this isn’t mandatory in any way! Nothing should force yourself to code in your spare time. It’s totally OK to keep coding and programming for work.</p>
			<p>The desire to share your discoveries and experience with your peers is normal—even more than that, it’s healthy. Sharing knowledge to lift your loved ones up is the best thing ever, and explaining something is the best way to learn yourself. The mistake is to want to apply it immediately, from everywhere, all the time. Each way has its advantages and disadvantages. It is absolutely necessary to be aware of the disadvantages that it brings. In general, the most common ones are the application in the current project and the resistance to change from other people involved in the project. Just take the example of the famous SOLID principles: although their effectiveness is proven, they can be difficult to access for newcomers.</p>
			<p>Resistance to change is normal and natural for all people. Our brain likes regularity—it likes cycles and does not like the unexpected. This is obviously reflected in the work environment but also in all other aspects of life: diet, exercise, and sleep. For code and our work habits, it is exactly the same. Again, consistency and regularity are key.</p>
			<p>If you bring your new discoveries into the project, you’re going to have to consider the training of the people already in place. They will not necessarily want to change their habits if the habits already in place are appropriate and already meet the need. New habits also mean training all the people who do not know these ways of doing things. This requires personal investment, even a substantial one in some cases. It is then a question of learning hours either in personal time or during working hours, and these hours will therefore be hours where productivity will be reduced, undeniably. Sometimes this is necessary, and sometimes it’s even a promising idea. But then, you must be able to justify it to everyone, including the non-technical parties in the project, and this can clearly be a critical part, especially if you are pushed for time.</p>
			<p>Also, some programming practices can work wonders, be proven, and make life much easier. However, they have a huge disadvantage: the onboarding time on the project. Just take as an example the practice of “if-less programming”. This programming method says to never, absolutely never use <strong class="source-inline">if</strong> and conditional branching in your code. This calls for massive and pure use of <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>). On paper, it looks good, and the intellectual satisfaction of such a technique must be quite exceptional. Its efficiency once mastered is quite clear. Everything becomes smarter and the code becomes noticeably clear. In short, everything is in place for your next project to adopt if-less programming from the start.</p>
			<p>However, the day when someone comes to your project to help you and try to understand what you are doing (or even to maintain and evolve the project with you), the observation will be overwhelming: if the person doesn’t know this programming technique (being a technique far from a generality), the whole process of introducing the project will be painful. In addition to having to train the person in the functional constraints of the project, they will also have to be trained in a new programming technique that they are certainly not used to. This means understanding the project, understanding the stakes, changing one’s habits, changing one’s way of doing and working, and reshaping one’s way of thinking. We understand very quickly the cost of such an operation. It can be justified, but you have to be very sure of yourself and know all the risks in advance.</p>
			<p>We are talking about if-less programming here, but the same goes for other ways of doing things that <a id="_idIndexMarker066"/>are not a general rule. <strong class="bold">Test-driven development</strong> (<strong class="bold">TDD</strong>) is one of them! Integrating TDD into a project can be painful and complicated, as we have seen before. However, TDD mainly influences the order of doing things, more than learning a complete way of coding. It’s up to you to see, depending on your context and your constraints, to what extent these risks are worth taking.</p>
			<p>In any case, if you choose a new programming technique that can be described as exotic, you may have exemplary code, clean and efficient, and super-maintainable. The problem is that nobody will be able to understand it. Remember what was said in the previous section: code is used to express and convey ideas. It is used to be understood by machines and, especially, by human beings. It would be a shame to sacrifice the second point, which is why high-level programming languages were invented.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>A note on maintainability</h1>
			<p>And this is <a id="_idIndexMarker067"/>where it gets complicated. Your code is ready—it works. You have followed a new programming method, and the preliminary developments of the project have been going smoothly for several months. And it’s pretty obvious: there may have been no foundation on which to build your project; you were lucky enough to start from a blank sheet of paper. However, the question of maintainability will soon arise. Whichever programming technique you choose, whichever people are working on it, bugs will always appear. You may need new people to fix all this (and thus teach them your working methods). Are you sure that you have mastered your new methodologies enough to ensure the follow-up of an application over several years? It is quite possible, but you must be aware of this and know what to do if you get stuck on the maintenance of your application.</p>
			<p>The purpose of this chapter is not to discourage initiative and the testing of new work methodologies. It is more a matter of being fully aware of the risks of opting for new working methodologies, especially in the long term. We will see later that we must be incredibly careful about the latest trends that can disappear overnight.</p>
			<p>The same applies to programming syntaxes that may seem elegant at first glance but that are in reality a nightmare of maintainability. Among these practices, we can find, in a non-exhaustive way, those highlighted next.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Using binary operators and octal, hexadecimal, and binary notations</h2>
			<p>In general, the<a id="_idIndexMarker068"/> use of binary operators on integers to perform operations (left and right shifting, logical <strong class="source-inline">AND</strong>, logical <strong class="source-inline">OR</strong>, bit inversion, and so on) is more useless than anything else. Their rarity makes them a syntax that may seem elegant to perform certain operations. However, this is not the case, and mastering binary operations should not be a prerequisite for understanding PHP code.</p>
			<p>The use<a id="_idIndexMarker069"/> of octal, hexadecimal, and binary notations can be justified <a id="_idIndexMarker070"/>at times. For example, octal notation <a id="_idIndexMarker071"/>can be used when you want to play with file permissions. Hexadecimal can be used if you want to use flags on your methods, as well as binary notation. But in general, apart from making your code complicated to read, there is not much to it.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Assigning a variable and using gotos</h2>
			<p>A variable <a id="_idIndexMarker072"/>can be assigned at the same time as testing its value. Here’s an example:</p>
			<p class="source-code">if null === ($var = method()))</p>
			<p>At best, you save one line of code. But it’s been a long time since we cared about the size of application source files, which are optimized at runtime by the PHP interpreter anyway. There is no cost for assigning the variable before the test, and your code will become immediately more readable.</p>
			<p>A <strong class="source-inline">goto</strong> instruction <a id="_idIndexMarker073"/>allows you to skip entire parts of the code, and even “go up” in the code. Although it can be useful in some extremely specific cases, it should definitely not be used in most cases. For years now, the use of <strong class="source-inline">goto</strong> statements has been frowned upon in most programming languages. Indeed, they bring great complexity to the understanding of the code flow. There is a name when too many uses of <strong class="source-inline">goto</strong> are to be deplored: spaghetti code.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Excessively using comments</h2>
			<p>Sometimes, we <a id="_idIndexMarker074"/>see the abusive use of comments on sometimes several hundred lines to explain the type of all the variables, their utility, all the exceptions raised by the function, the return value in detail, and so on. We can even find source files where there are more comments than code. All these details can be omitted most of the time by a clear naming of your methods and variables. Furthermore, the typing of variables, arguments, and function returns in recent versions of PHP also solves this problem. However, using comments to produce documentation can be totally justified and should be used when possible. Nobody will ever complain because there is “too much documentation”. Feel free to write dozens of lines about what a class, interface, method, and so on is all about; more generally, descendant, technical and/or functional choices about it, and so on. When we speak about “abusive use of comments”, we’re talking about comments that are explaining what’s happening in the code.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Using ternary comparisons</h2>
			<p>Here’s an <a id="_idIndexMarker075"/>example of a ternary comparison:</p>
			<p class="source-code">$var === null ? 'is null' : 'is not null' </p>
			<p>Although ternary comparisons can make code concise and include a condition in—for example—the passing of an argument in a function, they should not be abused, especially nested ternary comparisons, which immediately become unreadable and headache-inducing at the first level of nesting. You can see proof of this in the following example: </p>
			<p class="source-code">$var === null ? 'is null' : is_int($var) ? 'is int' : 'is not null'</p>
			<p>This is not a very clear or readable line of code, which makes ternary conditions complicated to read when the condition is not a basic and simple one, as in the first example.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Using abbreviations </h2>
			<p>Here’s <a id="_idIndexMarker076"/>maybe the most common practice to be discouraged: the use of abbreviations all over the place. Again, at the end of the last millennium, we might have had reasons to use abbreviations: space and storage were much more limited than today, and code editors were not as smart with all the autocomplete<a id="_idIndexMarker077"/> features we have today. Therefore, naming a variable <strong class="source-inline">$userPasswordRequest</strong> instead of <strong class="source-inline">$usr</strong> will make everyone’s life easier: both yours and the developers who will come back to your code and won’t have to ask you what your abbreviations mean. Again, with the autocomplete tools we have today, it doesn’t make sense to name our variables this way.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Bringing micro-optimizations to your code</h2>
			<p>Micro-optimizations<a id="_idIndexMarker078"/> are very minor changes made to the code that may impair its readability, justified by the optimization of the code. Thus, it would be faster to execute. The problem is that this is often not useful, first because you don’t need to optimize an instruction to the nanosecond (because of the power of processors nowadays), but also because a lot of optimizations are done by language interpreters and compilers. So, you sacrifice part of the readability of your code for something that is not useful and that will be done automatically. Moreover, this often provokes sterile debates where nobody is more right than anyone else. In these debates of micro-optimization specific to PHP, we find in particular the position of the operators of incrementation (<strong class="source-inline">++</strong>) and decrementation (<strong class="source-inline">--</strong>) in position before or after the variables, the use of the backslash in front of the methods of the <strong class="bold">Standard PHP Library</strong> (<strong class="bold">SPL</strong>), or <a id="_idIndexMarker079"/>the static declaration or not of anonymous functions. Again, the answer is: think about consistency with the rest of the code and be pragmatic. You certainly don’t need the 10 nanoseconds that will be (perhaps, in some circumstances) saved by your optimization that will have started a heated debate within the development team.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Recoding the methods of the SPL </h2>
			<p>We have a<a id="_idIndexMarker080"/> lot of use for a language that has a very extensive standard library. The standard library is a set of classes and methods provided with each installation of PHP. Unfortunately, we quickly realize that it is quite unknown and offers more possibilities than you might think. As a result, we often find ourselves with SPL methods that are recoded in the project because the developer in question did not know about the existence of the standard method. This is extremely unfortunate and, in some cases, a real problem for the following reasons:</p>
			<ul>
				<li>SPL methods are available everywhere. There is no need to worry about whether they are available on this or that installation or setup.</li>
				<li>These <a id="_idIndexMarker081"/>methods are tested by the developers of the PHP interpreter, which is not necessarily the case for your methods.</li>
				<li>If one of these methods can be optimized or secured, it can be done thanks to the thousands of contributors and researchers of the language.</li>
				<li>These methods are thought and conceptualized to be as efficient as possible by people whose job is to create the most efficient algorithms possible.</li>
				<li>SPL methods can be written in the C language directly. This means that their performance will be unmatched no matter what you do in PHP. It would be a shame not to take advantage of this considerable benefit, especially on methods used intensively in applications where execution time can be critical. Furthermore, because they are written in C, the C compiler can offer very low-level optimizations on these methods, directly with assembly code. You won’t be able to do this by writing the method in PHP.</li>
			</ul>
			<p>Feel free to have a look at the official PHP documentation; some methods such as <strong class="source-inline">natsort()</strong> might surprise you and save you hours of development!</p>
			<p>The list could go on and on, but the point is that while you may enjoy using these things, you will be the only one who will feel any satisfaction. A junior developer might be completely lost at the sight of these practices, while a senior developer won’t understand the value of using these practices when clearer and simpler ones are available. Your code must be understood by as many people as possible. Show the extent of your skills, knowledge, and proficiency by producing some simple, trivial, and readable code for a problem that seemed overly complex at first.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Summary</h1>
			<p>Do you understand what is meant by “building on what we know”? We realize with a little hindsight that this is again a lot of common sense and altruism, thinking of the next developers who will pass over our code. Here, there was no question of scouts, SOLID, <strong class="bold">Keep It Simple, Stupid</strong> (<strong class="bold">KISS</strong>), or other principles. It’s about rethinking our very methods of writing code.</p>
			<p>We must remember that the basics can (and should) be questioned and not considered as set in stone. Self-confidence is a wonderful thing, and if you are able to combine this with continuous questioning of your habits in a perspective of continuous improvement, you are on the right track to becoming an excellent developer, being able to write clean code naturally, and bringing your collaborators with you in this practice.</p>
			<p>Taking the initiative is a remarkable thing; knowing the risks and evaluating them in your context is the key to striving for perfection. This way, you are able to know if it is really worth it, but also can justify your choices to the people running the project. Again, we come back to the ability to justify all our choices and actions when it comes to clean code. Clean code is not just about avoiding the use of binary operators or the use of hexadecimal notations. It means thinking about the environment, the constraints, and the surroundings of our project. Clean code is not only about code. Luckily, this is exactly what we will see in the next chapter.</p>
		</div>
	</body></html>