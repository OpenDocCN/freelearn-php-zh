<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Configuring and Using Databases"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Configuring and Using Databases</h1></div></div></div><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Connecting to a database</li><li class="listitem" style="list-style-type: disc">Executing simple queries</li><li class="listitem" style="list-style-type: disc">Executing queries using the TableGateway</li><li class="listitem" style="list-style-type: disc">Optimization with a DB profiler</li><li class="listitem" style="list-style-type: disc">Creating a Database Access Object</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Introduction</h1></div></div></div><p>Obviously databases are essential if we want to store data, and with all the different kinds of database engines around, it is sometimes hard to see the wood through the trees. Zend Framework 2, however, brings us a bit of hope of standardizing the way we work with databases. In this chapter, we will be showing loads of examples from database connections to optimizing the performance of our queries.</p><div class="section" title="Default database engines available"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Default database engines available</h2></div></div></div><p>Zend Framework 2 has a default collection of database drivers available to use, and obviously it also supports the PHP PDO extension for a more standardized way of using databases.</p><div class="section" title="IBM DB2 driver"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec129"/>IBM DB2 driver</h3></div></div></div><p>
<span class="strong"><strong>IBM DB2</strong></span> is a database server <a id="id352" class="indexterm"/>designed by IBM and is the second most used DBMS according to IDC's report of 2009 (<a class="ulink" href="http://www.marketresearch.com/IDC-v2477/Worldwide-Database-Management-Systems-Forecast-2393193/view-stat/ibm-14.html">http://www.marketresearch.com/IDC-v2477/Worldwide-Database-Management-Systems-Forecast-2393193/view-stat/ibm-14.html</a>). The database engine can be traced back to the 1970's and was mainly only available for the IBM mainframe until the 1990's when it started supporting other more widely used operating systems.</p><p>Nowadays, the DB2 is mainly used in ZF2 for the IBM i Power Systems such as the AS/400, but remains a very powerful database engine.</p><p>Requirements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The IBM DB2 Universal <a id="id353" class="indexterm"/>Database client needs to be installed on the PHP machine</li><li class="listitem" style="list-style-type: disc">PHP configured either with the <code class="literal">--with-IBM_DB2</code> option or enabled (and installed) the <code class="literal">ibm_db2</code> extension in <code class="literal">php.ini</code></li></ul></div></div><div class="section" title="MySQLi driver"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec130"/>MySQLi driver</h3></div></div></div><p>For PHP developers, this is probably the most used database engine, the <span class="strong"><strong>MySQLi</strong></span> instead of the normal MySQL driver gives <a id="id354" class="indexterm"/>the extension several advantages over modern MySQL system versions (4.1.3 and newer). This improved extension supports the following modern MySQL functionality:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Enhanced server support</li><li class="listitem" style="list-style-type: disc">Transaction support</li><li class="listitem" style="list-style-type: disc">Prepared statements support</li><li class="listitem" style="list-style-type: disc">Object-oriented interface</li><li class="listitem" style="list-style-type: disc">Multiple statements support</li><li class="listitem" style="list-style-type: disc">Enhanced debugging availability</li></ul></div><p>The requirements for MySQLi driver is that the PHP is configured either with the <code class="literal">--with-mysql</code> or <code class="literal">--with-mysqli</code> option or enabled (and installed) the <code class="literal">mysql</code> and <code class="literal">mysqli</code> extension in <code class="literal">php.ini</code>.</p></div><div class="section" title="OCI8 driver"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec131"/>OCI8 driver</h3></div></div></div><p>OCI8 driver supports Oracle <a id="id355" class="indexterm"/>Database 11g, 10g, 9i, and 8i (according to the PHP manual), and is widely used in the PHP community.</p><p>Requirements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Oracle 9ir2, 10g, or 11g Client libraries on the PHP machine</li><li class="listitem" style="list-style-type: disc">PHP configured either with the <code class="literal">--with-oci8</code> option or enabled (and installed) the <code class="literal">oci8</code> extension in <code class="literal">php.ini</code></li></ul></div></div><div class="section" title="PGSQL driver"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec132"/>PGSQL driver</h3></div></div></div><p>
<span class="strong"><strong>PostgreSQL</strong></span> is an object-relational <a id="id356" class="indexterm"/>database and is my personal favorite, this database has been around since 1995 and is used by websites such as Reddit, Instagram, and Yahoo!.</p><p>The requirement for this is that the PHP is configured either with the <code class="literal">--with-pgsql</code> option or enabled (and installed) the <code class="literal">pgsql</code> extension in <code class="literal">php.ini</code>.</p></div><div class="section" title="SQLSRV driver"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec133"/>SQLSRV driver</h3></div></div></div><p>Microsoft SQL Server (and SQL Azure) <a id="id357" class="indexterm"/>is a database that works exclusively on Microsoft Windows, and is widely considered being a very good and stable database engine. Versions 3.0 or higher of the PHP extension support SQL Server 2005.</p><p>Requirements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Microsoft SQL Server 2012 Native Client needs to be installed on the PHP machine</li><li class="listitem" style="list-style-type: disc">The extension <code class="literal">php_sqlsrv_5*_nts.dll</code> or <code class="literal">php_sqlsrv_5*_ts.dll</code> should be enabled (and installed) on the PHP machine</li></ul></div></div><div class="section" title="PDO driver"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec134"/>PDO driver</h3></div></div></div><p>The PDO extension in PHP is <a id="id358" class="indexterm"/>probably the best method of connecting to a database available. Not only does it have a wide selection of database engines it supports, but also a more standardized way of working with them, which makes it easier to support in the long run (and that is a pro in the long run).</p><p>Not only is it easier to support, for example, its standardized way of connecting to databases and executing queries makes it much easier for us developers to switch.</p><p>The requirements for this is that at least one <code class="literal">pdo</code> extension needs to be enabled in the <code class="literal">php.ini</code> file or otherwise it won't work.</p><p>All the drivers communicate with PHP through either as the built-in compilation or used as an extension on the library. Without these extensions PHP would be unable to figure out how to communicate with the specific libraries. Some extensions (such as the Oracle one) require even more, like client libraries to make it work.</p><p>We should always check the php.net documentation for the requirements of the specific extension we try to enable.</p></div></div></div></div>
<div class="section" title="Connecting to a database"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Connecting to a database</h1></div></div></div><p>After seeing all the database <a id="id359" class="indexterm"/>types that Zend Framework 2 supports, we can finally start connecting to them. In this recipe, we will connect to a MySQL server and show different ways of doing this.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec68"/>Getting ready</h2></div></div></div><p>To make full of the following recipe, a Zend Framework 2 skeleton application should be used, with a MySQL server available to connect to. Don't forget that connecting to a MySQL server requires the <code class="literal">mysql</code> and <code class="literal">mysqli</code> extensions enabled in PHP.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec69"/>How to do it…</h2></div></div></div><p>In this recipe we'll give some examples of how to connect to a single database or multiple databases.</p><div class="section" title="Connecting to a MySQL database through the configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec135"/>Connecting to a MySQL database through the configuration</h3></div></div></div><p>We can <a id="id360" class="indexterm"/>make the following change to <a id="id361" class="indexterm"/>the <code class="literal">/config/autoload/global.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php

return array(

  // Set up the service manager
  'service_manager' =&gt; array(

    // Initiate the connection at the start of the 
    // application
    'factories' =&gt; array(

      // Use the service factory to start up our db 
      // adapter
      'Zend\Db\Adapter\Adapter' =&gt;
      'Zend\Db\Adapter\AdapterServiceFactory',
    ),

    'aliases' =&gt; array(
      // Use this db alias in the controllers to get the 
      // initialized connection. The value of the db key refers to 
      // the factories key with the same name.
      'db' =&gt; 'Zend\Db\Adapter\Adapter',
    ),
  ),
  'db' =&gt; array(
    // We want to use the PDO to connect to the database
    'driver' =&gt; 'pdo',

    // DSN, or data source name is a connection url that 
    // shows the driver (in this case the PDO) where to 
    // connect to. The first bit is the driver to use, 
    // then follows the database name and the host. More    
    // information on the dsn options can be found here:
    // http://php.net/manual/en/pdo.construct.php
    'dsn' =&gt; 'mysql:dbname=some_db_name;host=localhost',

    // Username and password (or at the very least the 
    // password) should NOT be in the global.php. This 
    // file usually will be committed to a version 
    // control, which means your password will be 
    // publicly available.
    'username'  =&gt; 'aGreatUser',
    'password'  =&gt; 'somePassword',
  ),
);</pre></div><p>As we can see in the example, <a id="id362" class="indexterm"/>setting up the database configuration is quite easy. Now, if you were wondering how to use a <a id="id363" class="indexterm"/>configuration like this in a real world example, let's consider the following controller:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;

class SomeController extends AbstractActionController
{
  public function indexAction()
  {
    // Get the db adapter through our service manager
    $db = $this-&gt;getServiceLocator()-&gt;get('db');

    // Now we can execute queries
    $query = $db-&gt;query('SELECT * FROM table');
  }
}</pre></div><p>As we can see it is very easy <a id="id364" class="indexterm"/>to get it <a id="id365" class="indexterm"/>going now in the controller.</p></div><div class="section" title="Connecting to multiple databases through the configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec136"/>Connecting to multiple databases through the configuration</h3></div></div></div><p>Some applications <a id="id366" class="indexterm"/>require us to connect to <a id="id367" class="indexterm"/>multiple databases at the same time, and we can easily achieve that in Zend Framework 2 as well by doing the following in the <code class="literal">/config/autoload/global.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?php
return array(
  'db' =&gt; array(
    'adapters' =&gt; array(
      // The first (default) database connection
      'db_one' =&gt; array(
        'driver' =&gt; 'pdo',
        'dsn' =&gt; 'mysql:dbname=db_1;host=localhost',
        'username'  =&gt; 'someUser',
        'password'  =&gt; 'aGreatPassword',
      ),

      // Now the second database connection
      'db_two' =&gt; array(
        'driver' =&gt; 'pdo',
        'dsn' =&gt; 'mysql:dbname=db_2;host=localhost',
        'username'  =&gt; 'someOtherUser',
        'password'  =&gt; 'anotherGreatPassword',
      ),
    ),
  ),
  'service_manager' =&gt; array(
    // Let's make sure our adapters get instantiated
    'abstract_factories' =&gt; array(      
      'Zend\Db\Adapter\AdapterAbstractServiceFactory',
    ),
  ),
);</pre></div><p>In our controllers (or anywhere <a id="id368" class="indexterm"/>where we can <a id="id369" class="indexterm"/>access the service manager) we can easily get the <code class="literal">db</code> DBAdapter now by doing the following:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;

class SomeController extends AbstractActionController
{
  public function indexAction()
  {
    // Get the first db adapter
    $dbOne = $this-&gt;getServiceLocator()-&gt;get('db_one'); 

    // Get the second db adapter
    $dbOne = $this-&gt;getServiceLocator()-&gt;get('db_two');
  }
}</pre></div></div><div class="section" title="Connecting to a MySQL database through code"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec137"/>Connecting to a MySQL database through code</h3></div></div></div><p>Although it is less clean <a id="id370" class="indexterm"/>than the method we showed before, <a id="id371" class="indexterm"/>sometimes it is just necessary to connect through good old instantiation.</p><p>First let's see an example if we want to connect to a MySQL server:</p><div class="informalexample"><pre class="programlisting">&lt;?php 

// We need to import this to use the Db Adapter
use Zend\Db\Adapter\Adapter;

class someClass 
{
  // This is the property where our database adapter will be 
  // stored in 
  private $db;

  // First we want to connect to the database on instantiation of 
  // this class
  public function __construct()
  {
    // Create the new database adapter
    $this-&gt;db = new Adapter(array(
      'driver' =&gt; 'Pdo_Mysql', 
      'hostname' =&gt; 'localhost',
      'database' =&gt; 'example_database',
      'username' =&gt; 'developer',
      'password' =&gt; 'developer-password'
    ));
  }

  // This method will execute a query on the database, to show 
  // how easy it is to now make use of our database
  public function someData()
  {
    // Create a statement where we select everything from our 
    // tableName table
    $statement = $this-&gt;db-&gt;createStatement(
      "SELECT * FROM tableName"
    );

    return $statement-&gt;execute();
  }
}</pre></div><p>We now can easily <a id="id372" class="indexterm"/>execute the queries on the <a id="id373" class="indexterm"/>instantiated <code class="literal">$db</code>.</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec70"/>How it works…</h2></div></div></div><p>In Zend Framework 2 there are many ways of defining a database connection, in this section we will discuss three of them.</p><div class="section" title="Connecting to a MySQL database through the configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec138"/>Connecting to a MySQL database through the configuration</h3></div></div></div><p>The first method we <a id="id374" class="indexterm"/>are going to show is connecting to a (could be of any type) database through the configuration files. This is probably the <a id="id375" class="indexterm"/>easiest to do, but would obviously not always be what we want. However, in the case of less code is better maintainability, we should always consider the option of connecting to a database like this.</p><p>We should refrain from putting business logic in the controller, as that is not what a MVC is for, we just showed it here <a id="id376" class="indexterm"/>as an example only. We can get the db adapter from anywhere where we have the service manager in reach.</p></div><div class="section" title="Connecting to multiple databases through the configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec139"/>Connecting to multiple databases through the configuration</h3></div></div></div><p>As we can see we now <a id="id377" class="indexterm"/>have our adapters defined in the <code class="literal">db =&gt; adapters</code> array instead of the <code class="literal">db</code> array directly. This functionality can be achieved in any version of Zend Framework 2 greater or equal to 2.2.</p></div><div class="section" title="About the ServiceManager"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec140"/>About the ServiceManager</h3></div></div></div><p>When we use the <a id="id378" class="indexterm"/>
<code class="literal">ServiceManager</code> for connecting to our database, the <code class="literal">ServiceManager</code> first checks if it has the key we need. If the key is found it first checks in its internal registry if there is already an instance for the requested service. If not, it will use the <a id="id379" class="indexterm"/>
<code class="literal">config</code> data to instantiate it. After instantiation is completed it will stash away the reference in its internal registry, which can be retrieved again the next time we request it. This way the database adapter (or any other service) will be only instantiated once by the <code class="literal">ServiceManager</code>. Instantiating the database connection this way has a couple of pros:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We always have one connection to the database, which is usually limited on the server side</li><li class="listitem" style="list-style-type: disc">We don't spend valuable time connecting and reinitializing the connection constantly</li><li class="listitem" style="list-style-type: disc">No memory is wasted on multiple instances</li></ul></div></div></div></div>
<div class="section" title="Executing simple queries"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec32"/>Executing simple queries</h1></div></div></div><p>Querying the database is <a id="id380" class="indexterm"/>obviously something that we need to do once we are connected to the database. This recipe explains how this can be done, and the different methods available.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec71"/>Getting ready</h2></div></div></div><p>To make full of the following recipe, a Zend Framework 2 skeleton application should be used, with a MySQL server available to connect to. Don't forget that connecting to a MySQL server requires the <code class="literal">mysql</code> and <code class="literal">mysqli</code> extension enabled in PHP.</p><p>We have configured a database called <code class="literal">book</code>, with the table <code class="literal">cards</code> that has the columns <code class="literal">id</code>, <code class="literal">color</code>, <code class="literal">type</code>, and <code class="literal">value</code>. The SQL query to create the database and table are included in the code that comes with the book.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec72"/>How to do it…</h2></div></div></div><p>Queries come in all sort of forms, <a id="id381" class="indexterm"/>and in this recipe we will discuss some basic querying.</p><div class="section" title="Using raw SQL"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec141"/>Using raw SQL</h3></div></div></div><p>We'll be <a id="id382" class="indexterm"/>editing in the <code class="literal">/module/Application/src/Application/Controller/IndexController.php</code> file for this example:</p><div class="informalexample"><pre class="programlisting">&lt;?php 

namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;

class IndexController extends AbstractActionController
{
  public function indexAction()
  {
    // Let's assume there is a service called 'db' that connect to 
    // the database
    $connection = $this-&gt;getServiceLocator()-&gt;get('db');
        
    // We now start to build up our query
    $query = $connection-&gt;query(
      // We will put our raw SQL statement in here, and 
      // every variable we want to put in we replace with 
      // a question mark. This means we will fill in the 
      // blanks later.
      "SELECT * FROM cards WHERE type = ?", 

      // We don't want to execute the statement yet, just 
      // prepare it.
      Adapter::QUERY_MODE_PREPARE
    );

    // These are the parameters that will replace the question 
    // marks (?) in the SQL statement above, in the defined order
    $replacements = array('number');

    // Now execute the query with the parameters attached to 
    // replace
    $result = $query-&gt;execute($replacements);
    
    // Iterate over the results
    foreach ($result as $res) {
      // Do something with the result, in this case a raw echo
      echo '&lt;pre&gt;'. print_r($res, true). '&lt;/pre&gt;';
    }
  }
}</pre></div><p>An example using an array or <a id="id383" class="indexterm"/>the <code class="literal">ParameterContainer</code> object <a id="id384" class="indexterm"/>for passing variables:</p><div class="informalexample"><pre class="programlisting">// We now start to build up our query
$query = $connection-&gt;query(
  // We will put our raw SQL statement in here, and 
  // every variable we want to put in we replace with 
  // a question mark. This means we will fill in the 
  // blanks later.
  "SELECT * FROM cards WHERE type = ?", 

  // These are the parameters that will replace the question 
  // marks (?) in the SQL statement above, in the defined order
  array('number')
);</pre></div></div><div class="section" title="Using the prepared statements"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec142"/>Using the prepared statements</h3></div></div></div><p>We'll be <a id="id385" class="indexterm"/>editing in the <code class="literal">/module/Application/src/Application/Controller/IndexController.php</code> file for this <a id="id386" class="indexterm"/>example:</p><div class="informalexample"><pre class="programlisting">&lt;?php 

namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;

class IndexController extends AbstractActionController
{
  public function indexAction()
  {
    // Let's assume there is a service called 'db' that connect to 
    // the database
    $connection = $this-&gt;getServiceLocator()-&gt;get('db');
  
    // Now let's create a prepared statement
    $statement = $connection-&gt;createStatement();

    // Set up the prepared statement
    $statement-&gt;setSql("
      SELECT 
      * 
      FROM cards 
      WHERE type = :type
      AND color = :color
    ");

    // Create a new parameter container to store our where 
    // parameters in
    $container = new ParameterContainer(array(
      // These are the variables used in the same order as 
      // displayed in the where condition
      'type' =&gt; 'picture', 'color' =&gt; 'diamond'
    ));

    // Set the container to be used in our statement 
    $statement-&gt;setParameterContainer($container);

    // Prepare the statement for use with the database
    $statement-&gt;prepare();
      
    // Now execute the statement and get the resultset
    $result = $statement-&gt;execute();

    // Iterate over the results
    foreach ($result as $res) {
      // Do something with the result, in this case a raw echo
    echo '&lt;pre&gt;'. print_r($res, true). '&lt;/pre&gt;';
    }
  }
}</pre></div></div><div class="section" title="Quote identifier"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec143"/>Quote identifier</h3></div></div></div><p>This method will quote an <a id="id387" class="indexterm"/>identifier that is going to be used in a SQL query in a <a id="id388" class="indexterm"/>safe way:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Adapter is of type Zend\Db\Adapter\Adapter
echo $adapter-&gt;getPlatform()-&gt;quoteIdentifier('some_var');</pre></div><p>The preceding code will give the following output:</p><div class="informalexample"><pre class="programlisting">"some_var"</pre></div></div><div class="section" title="Quote identifier chain"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec144"/>Quote identifier chain</h3></div></div></div><p>The <code class="literal">quoteIdentifierChain</code> <a id="id389" class="indexterm"/>method <a id="id390" class="indexterm"/>will quote multiple identifiers and glue them together with the identifier <a id="id391" class="indexterm"/>separator (see method <code class="literal">getIdentifierSeparator()</code>):</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Adapter is of type Zend\Db\Adapter\Adapter
echo $adapter-&gt;getPlatform()-&gt;quoteIdentifierChain(array(
  'some_table', 'some_column'
));</pre></div><p>The preceding code will give the following output:</p><div class="informalexample"><pre class="programlisting">"some_table"."some_column"</pre></div></div><div class="section" title="Quote (trusted) value"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec145"/>Quote (trusted) value</h3></div></div></div><p>
<code class="literal">quoteValue</code> and <code class="literal">quoteTrustedValue</code> <a id="id392" class="indexterm"/>are used for quoting values used in for example WHERE clauses. <code class="literal">quoteTrustedValue()</code> should only be used when we trust the value (for example if we put it in ourselves): The following is an example of <code class="literal">quoteValue</code> and <code class="literal">quoteTrustedValue</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// You can either use quoteValue or quoteTrustedValue,
// quoteValue will log an error in the PHP error log if 
// there is no driver or module available to quote the 
// value. Both methods output the same value.
echo $adapter-&gt;getPlatform()-&gt;quoteValue("great-value");

// Adapter is of type Zend\Db\Adapter\Adapter
echo $adapter-&gt;getPlatform()-&gt;quoteTrustedValue("great-value");</pre></div><p>The preceding code will give the <a id="id393" class="indexterm"/>following output:</p><div class="informalexample"><pre class="programlisting">'great-value'</pre></div></div><div class="section" title="Quote value list"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec146"/>Quote value list</h3></div></div></div><p>Quote value list quotes an entire <a id="id394" class="indexterm"/>list of values and returns them, separated by a comma. Comes in handy, for example, if we want to use a list in a <code class="literal">WHERE</code> clause where we use an <code class="literal">IN</code> <a id="id395" class="indexterm"/>operator. There is no method that handles trusted values, so we should be aware that this could trigger errors in our PHP error log if there are no drivers or modules available to quote the value, however, it will always return the expected values. The following is an example of <code class="literal">quoteValueList</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Adapter is of type Zend\Db\Adapter\Adapter
echo $adapter-&gt;getPlatform()-&gt;quoteValueList(array(
  "value_one", "value_two"
));</pre></div><p>The preceding code will give the following output:</p><div class="informalexample"><pre class="programlisting">'value_one', 'value_two'</pre></div></div><div class="section" title="Quote identifier in fragment"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec147"/>Quote identifier in fragment</h3></div></div></div><p>The <code class="literal">quoteIdentifierInFragment</code> <a id="id396" class="indexterm"/>method plucks out the identifiers by a RegEx pattern, and makes sure <a id="id397" class="indexterm"/>only the right identifiers are quoted. If we are using characters outside the following characters: A-z,0-9, *, "." or  'AS', we will need to <a id="id398" class="indexterm"/>give them up as a safe word by using the second parameter.</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Adapter is of type Zend\Db\Adapter\Adapter
echo $adapter-&gt;getPlatform()-&gt;quoteIdentifierInFragment(
  '(fork.* AS spoon)',

   // Use the braces as a safe word so that they
   // will not be quoted.
   array('(', ')')
);</pre></div><p>The preceding code gives the following output:</p><div class="informalexample"><pre class="programlisting">`fork`.* AS `spoon`</pre></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec73"/>How it works…</h2></div></div></div><p>Let's understand the <a id="id399" class="indexterm"/>operations we just did.</p><div class="section" title="Using raw SQL"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec148"/>Using raw SQL</h3></div></div></div><p>The first method of executing <a id="id400" class="indexterm"/>SQL is by simply using the <code class="literal">query()</code> method on the database connection. This is the simplest form of querying, and it has it pros and cons, one pro is that the queries are quick and easy, the con is that it isn't really useful for reuse as the query constantly needs either new input every time we execute it, or needs the variables passed into it every time we want to execute it.</p><p>As we can see in the example, we created a query first with the mode set to <code class="literal">QUERY_MODE_PREPARE</code>, which in effect means that the query isn't executed straight away, but just prepared for execution. When we come to execute the query, we see that we parse the variables for the <code class="literal">WHERE</code> clause with the <code class="literal">execute()</code> method. The <code class="literal">execute()</code> statement then executes the query and gives the result back.</p><p>Instead of the second parameter to <code class="literal">query()</code>, we could also do either <code class="literal">QUERY_MODE_EXECUTE</code> to immediately execute the query (and thus returning the result set straight away) or parse an array with parameters or <code class="literal">ParameterContainer</code>. For more information on <code class="literal">ParameterContainer</code> see the following section.</p><p>If we parse either an array or a <a id="id401" class="indexterm"/>
<code class="literal">ParameterContainer</code> object as the last option of <code class="literal">query()</code>, it would both lead to the query parameters being filled and the query mode to be put on <code class="literal">QUERY_MODE_PREPARE</code>. This means that because we already parsed the parameters for our query into the <code class="literal">query()</code> method, we don't have to add them again in the <code class="literal">execute()</code> method.</p></div><div class="section" title="Using prepared statements"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec149"/>Using prepared statements</h3></div></div></div><p>The <code class="literal">query()</code> method is described <a id="id402" class="indexterm"/>as a convenience function and is not <a id="id403" class="indexterm"/>really usefully when we want to protect ourselves against SQL injection or want to use a single query multiple times with different parameters. The <a id="id404" class="indexterm"/>
<code class="literal">createStatement()</code> function on the other hand provides a great way of storing and preparing a SQL before use in a safe and responsible way.</p><p>As seen in the example, we have executed a similar statement such as the <code class="literal">query()</code> method, however this method is much more maintainable and reusable than the <code class="literal">query()</code> method. By using <code class="literal">ParameterContainer</code> we can easily inject our variables into the SQL and manage them simply because of the container nature of the object.</p><p>Because we used <code class="literal">:type</code> and <code class="literal">:color</code> the statement knows that our parameter array (<code class="literal">ParameterContainer</code> implements the <code class="literal">ArrayAccess</code> class) should contain the keys <code class="literal">type</code> and <code class="literal">color</code> to match them to the SQL statement.</p></div><div class="section" title="Quoting in our SQL"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec150"/>Quoting in our SQL</h3></div></div></div><p>Usually where there is database <a id="id405" class="indexterm"/>access there is user input, and if there is one thing we should never trust it is user input. Although the majority of people have no intention of <a id="id406" class="indexterm"/>hacking your website, a malicious few will try to do so.</p><p>Zend Framework 2 offers a range of quote methods which we can use to protect ourselves from any harm. We should note however that these are just a small set of tools that you can use in prevention of a disastrous situation, and we advice that a full range of utilities is used to prevent SQL injection.</p></div><div class="section" title="Using createStatement"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec151"/>Using createStatement</h3></div></div></div><p>When we use <code class="literal">createStatement()</code> the result objects are instantiated through the driver, so the workings of a statement for <a id="id407" class="indexterm"/>MySQL can be different from Oracle (can, and <a id="id408" class="indexterm"/>will I think). Once we create a statement it will also automatically connect to the database, which is handy but we must be wary that we are not creating the statement on places where we might not need the database. If we omit such a thing it might create a leak that isn't necessary in the first place, although probably not such a big leak but a leak nonetheless.</p><p>The <code class="literal">query()</code> method works <a id="id409" class="indexterm"/>directly on the connection adapter, and although quick in use isn't recommended to use in 'real life' situations as it doesn't promote reusability (in my personal opinion). If in doubt, it is always best to do <code class="literal">createStatement()</code>, unless we are simply testing some things out <a id="id410" class="indexterm"/>then we can use <code class="literal">query()</code> instead.</p></div></div></div>
<div class="section" title="Executing queries using TableGateway"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Executing queries using TableGateway</h1></div></div></div><p>After we have seen how to <a id="id411" class="indexterm"/>execute simply queries, it is now <a id="id412" class="indexterm"/>time to tell you about the <code class="literal">TableGateway</code>, and it's incredible functionality. This recipe is all about querying the database through this and showing off its capabilities.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec74"/>Getting ready</h2></div></div></div><p>To make full of the following recipe, a Zend Framework 2 skeleton application should be used, with a MySQL server available to connect to. Don't forget that connecting to a MySQL server requires the <code class="literal">mysql</code> and <code class="literal">mysqli</code> extension enabled in PHP.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec75"/>How to do it…</h2></div></div></div><p>What we are going to do first is insert a record in our sample table. After that we will check that it was inserted successfully. Next, we will update the record with some new data, and if that worked we will delete it again from the table.</p><div class="section" title="Inserting a new record"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec152"/>Inserting a new record</h3></div></div></div><p>Before we go about updating a <a id="id413" class="indexterm"/>record, it might be handy if we actually have a record that we can use to update first. Zend Framework 2 has some new nifty database tools that make our lives a little easier when it comes to data handling.</p><p>The cards table has the following columns:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">id</code> (primary key)</li><li class="listitem" style="list-style-type: disc"><code class="literal">color</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">value</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">type</code></li></ul></div><p>Let's consider the following <a id="id414" class="indexterm"/>example (<code class="literal">/module/Application/src/Application/Controller/IndexController.php</code>):</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\Db\TableGateway\TableGateway;

class IndexController extends AbstractActionController
{
  public function indexAction()
  {
    // Let's assume there is a service called 'db' that connect to 
    // the database
    $connection = $this-&gt;getServiceLocator()-&gt;get('db');
    
    // Let's make this object for examples later on
    // $sql = new Sql($this-&gt;connection);
    
    // Create a new Zend\Db\Sql\Insert object
    // You can also do $sql-&gt;insert();
    $insert = new Insert('cards');
    
    // Define the columns in the table, although not 
    //required, it is best practice
    $insert-&gt;columns(array(
      'id',
      'color',
      'type',
      'value',
    ));
    
    // Assign the values we want to insert, the column 
    // names are in the keys so that the code knows what 
    // to insert where.
    $insert-&gt;values(array(
      'color' =&gt; 'diamond',
      'type' =&gt; 'picture',
      'value' =&gt; 'Goblin'
    ));
    
    // Create a new table gateway to perform our SQL on
    $tableGateway = new TableGateway(
      'cards', $connection
    );

    // We will now use the TableGateway to insert our 
    // statement in the table.
    // The insert() / insertWith() method throws an 
    // exception whenever the query goes wrong. We need to  
    // make sure we catch that.
    try {
      $tableGateway-&gt;insertWith($insert);

      // If we reach this point we can assume that the 
      // query went fine.
      echo "Insert success!";
      $hasResult = true;
    } catch (Exception $e) {
      echo "Insert failed.";
    }
  }
}</pre></div><p>That concludes the table insert, and obviously this is only one way of inserting data in the table. Another way to execute the <a id="id415" class="indexterm"/>insert statement would be to use the <code class="literal">$sql</code> object we created before. If we do that we <a id="id416" class="indexterm"/>can get rid of <code class="literal">TableGateway</code> and just use that instead.</p><p>If we would prefer that we could go about it like this:</p><div class="informalexample"><pre class="programlisting">// This will prepare a StatementInterface for us to use
$statement = $sql-&gt;prepareStatementForSqlObject(
  // Put the insert object in here
  $insert
);

// Now we simply execute the statement to insert the 
// record.
$statement-&gt;execute();</pre></div></div><div class="section" title="Updating a record"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec153"/>Updating a record</h3></div></div></div><p>We can now go on with <a id="id417" class="indexterm"/>checking if the insertion went fine, and following that we will <a id="id418" class="indexterm"/>update the record with some new data:</p><div class="informalexample"><pre class="programlisting">// If an Exception happened, we will have a false in our 
// result.
if (isset($hasResult)) {
  // Let's get the primary key from our last insert for 
  // later use.
  $primaryKey = $tableGateway-&gt;getLastInsertValue();
  
  // Now let's update our record
  // You can also do $sql-&gt;update();
  $update = new Update('cards');

  // Set the new values (and column names as keys) for 
  // the data we want to update.
  $update-&gt;set(array(
    'color' =&gt; 'spade',
    'value' =&gt; '10',
    'type' =&gt; 'number',
  ));
    
  // Now create a where statement
  $where = new Where();

  // We want to match our record on the primary key that 
  // we got back from our insertion.
  $where-&gt;equalTo("id", $primaryKey);
    
  // Set the where in the update statement so that we 
  // use that when executing the update. We can add as 
  // many where statements as we like, but we only match 
  // on one here.
  $update-&gt;where($where);
    
  // Now update the record
  $updated = $tableGateway-&gt;updateWith($update);</pre></div><p>The result of the update will be the amount of rows affected by our <code class="literal">update</code> statement. In our case that would only be one <a id="id419" class="indexterm"/>record as we match exactly with the primary key of the <a id="id420" class="indexterm"/>table.</p></div><div class="section" title="Deleting a record"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec154"/>Deleting a record</h3></div></div></div><p>Now, we are done with all our <a id="id421" class="indexterm"/>updates we want to begin deleting this record again, so let's <a id="id422" class="indexterm"/>look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">// Delete everything again
// You can also do $sql-&gt;delete();
$delete = new Delete('cards');
      
// We can use the same where statement as before!
$delete-&gt;where($where);

// Now let's delete it, as there is nothing else to it.
$deleted = $tableGateway-&gt;deleteWith($delete);</pre></div><p>Well that was easy. We could just use <a id="id423" class="indexterm"/>the same <code class="literal">where</code> statement as it already defined the clause to filter on our primary key from before.</p></div><div class="section" title="Advanced selects – joins conditions"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec155"/>Advanced selects – joins conditions</h3></div></div></div><p>When developing web application <a id="id424" class="indexterm"/>we will require more than one table in our queries for most of the time, this is because we just need to pull a lot of data from everywhere to get the results we need. One way of doing this is by using join conditions in our <code class="literal">select</code> statement.</p><p>Let's just take a look at the following table composition, we are going in our virtual environment:</p><p>The <code class="literal">people</code> table will have the following columns:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Id</code> (primary key)</li><li class="listitem" style="list-style-type: disc"><code class="literal">First_name</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Last_name</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Age</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Gender</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Address_Id</code> (foreign key to <code class="literal">addresses</code> table)</li></ul></div><p>The <code class="literal">addresses</code> table will have the following columns:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Id</code> (primary key)</li><li class="listitem" style="list-style-type: disc"><code class="literal">Street</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Number</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Postcode</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">City</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Country</code></li></ul></div><p>What we want to achieve here is to retrieve the address that belongs to a person and show that in our result.</p><p>Let's look at an example (<code class="literal">/module/Application/src/Application/Controller/IndexController.php</code>) of how we could achieve that in the <a id="id425" class="indexterm"/>best possible way:</p><div class="informalexample"><pre class="programlisting">&lt;?php 

namespace Application\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\Db\TableGateway\TableGateway;

class IndexController extends AbstractActionController
{
  public function indexAction()
  {
    // Let's assume there is a service called 'db' that connect to 
    // the database
    $connection = $this-&gt;getServiceLocator()-&gt;get('db');

    // First create our Zend\Db\Sql\Sql object, and let's 
    // assume $connection has a Zend\Db\Adapter defined.
    $sql = new Sql($connection);

    // Now create a Zend\Db\Sql\Select statement with 
    // 'people' as the table we want to select from.
    $select = $sql-&gt;select('people');

    // By default we will select all the fields, but let's 
    // just change that a bit for sake of the example
    $select-&gt;columns(array('first_name', 'last_name'));

    // Now set up our join condition
    $select-&gt;join(
      // We want to join the 'addresses' table
      'addresses',

      // We now define the join condition to match the 
      // records on 
      'addresses.id = people.address_id',

      // We want to select different columns than the 
      // default wildcard selection.
      array('street', 'number', 'city', 'postcode'),

      // We want to do a LEFT JOIN on the table
      Select::JOIN_LEFT
    );

    // Now we are ready to execute the statement.
    $statement = $sql-&gt;prepareStatementForSqlObject(
      $select
    );

    // .. And finally execute it
    $records = $statement-&gt;execute();

    // Output to the screen for convenience
    echo '&lt;pre&gt;'. print_r($records, true). '&lt;/pre&gt;';
  }
}</pre></div><p>This is how simple it is to create a <a id="id426" class="indexterm"/>
<code class="literal">join</code> condition on a <code class="literal">select</code> statement. Piece of pie!</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec76"/>How it works…</h2></div></div></div><p>In Zend Framework 2 they have separated all the actions such as <code class="literal">Insert</code>, <code class="literal">DropTable</code>, <code class="literal">Update</code>, <code class="literal">Delete</code>, and <code class="literal">Where</code> into classes of their own, which makes it very reusable for developers. The great thing about it is that it also makes the code much clearer.</p><p>
<code class="literal">TableGatewayInterface</code> <a id="id427" class="indexterm"/>defines a minimum selection of methods that are implemented by <code class="literal">AbstractTableGateway</code> and also <code class="literal">TableGateway</code>, as that extends from <code class="literal">AbstractTableGateway</code> in the first place. <code class="literal">TableGateway</code>, for short, implements most common features needed to do table operations.</p><p>The <code class="literal">TableGatewayInterface</code>, therefore, defines the following methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getTable()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">select($where = null)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">insert($set)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">update($set, $where = null)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">delete($where)</code></li></ul></div></div></div>
<div class="section" title="Optimizating with a DB profiler"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Optimizating with a DB profiler</h1></div></div></div><p>One of the most common <a id="id428" class="indexterm"/>bottlenecks in an application is the querying to the database, as sometimes we just don't know how much is being queried, or we can't find out why something is going wrong. This recipe provides us with the tools to find even the smallest query used.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec77"/>Getting ready</h2></div></div></div><p>A database profiler is used to find bottlenecks in query performance and is a great tool to debug the queries that are executed in a session and of course the time it takes for them to execute. Once we develop bigger applications we tend to forget when and how certain pieces of code execute, which sometimes can lead to unnecessary complexity in our code.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec78"/>How to do it…</h2></div></div></div><p>Profiling an application's database usage can give a clear overview on the performance of our application, in this recipe we will discuss how to set up a simple profiler.</p><div class="section" title="Setting up a new profiler"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec156"/>Setting up a new profiler</h3></div></div></div><p>Setting up a new profiler is really <a id="id429" class="indexterm"/>easy as at the moment there is only one class in Zend Framework 2 that can be used as a profiler. This class is called <code class="literal">Zend\Db\Adapter\Profiler\Profiler</code> and can be instantiated right away. Let's take a look at the following snippet:</p><div class="informalexample"><pre class="programlisting">&lt;?php
use Zend\Db\Adapter\Profiler\Profiler;

// Instantiate the Zend\Db\Adapter\Profiler\Profiler
$profiler = new Profiler();  

// Let's assume $connection is an active Db\Adapter,
// we then need to set the profiler to be used by the 
// adapter.
$connection-&gt;setProfiler($profiler);</pre></div><p>That's it; this is basically all that is needed to start profiling everything from the database. The only thing that is left to do for us is to get the profiles back whenever we are done with querying (or whenever we need it really). Let's consider the following example:</p><div class="informalexample"><pre class="programlisting">&lt;?php
// This will return all the statements that have been 
// executed by the adapter.
$results = $profiler-&gt;getProfiles();</pre></div><p>The <code class="literal">$result</code> variable will now be filled with the statistical information about the statements executed. This result <a id="id430" class="indexterm"/>could look similar to the following:</p><div class="informalexample"><pre class="programlisting">array(3) {
   [0] =&gt; array(5) {
     ["sql"] =&gt; string(77) 
        "INSERT INTO `cards` (`color`, `type`, `value`) 
        VALUES (:color, :type, :value)"
     ["parameters"] =&gt; object(
  Zend\Db\Adapter\ParameterContainer)#255 (3) {
         ["data":protected] =&gt; array(3) {
         ["color"] =&gt; string(7) "diamond"
         ["type"] =&gt; string(7) "picture"
         ["value"] =&gt; string(6) "Goblin"
      }
     ["positions":protected] =&gt; array(3) {
       [0] =&gt; string(5) "color"
       [1] =&gt; string(4) "type"
       [2] =&gt; string(5) "value"
      }
       ["errata":protected] =&gt; array(0) {
      }
    }
     ["start"] =&gt; float(1372316727.1188)
     ["end"] =&gt; float(1372316727.1209)
     ["elapse"] =&gt; float(0.0020461082458496)
  }
}</pre></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec79"/>How it works…</h2></div></div></div><p>The database profiler is first being attached to the database adapter, making the adapter aware of the existence of the profiler. The adapter will start profiling (it does this by using the <code class="literal">Profiler::profileStart()</code> method) the statement every time it executes a statement, making sure that <a id="id431" class="indexterm"/>everything important will be logged about the statement.</p><p>When the database adapter has finished executing the statement, it will let the profiler know that the statement is done (it will execute the <code class="literal">Profiler::profileFinish() </code>method).</p><p>As we can see from the previous example we can view the SQL statement executed and also the parameters used. After that the start time, end time, and time elapsed are also added so that we can spot any potential <a id="id432" class="indexterm"/>bottlenecks in the code easily.</p><p>All in all this is very useful tool that requires almost nothing in code to work, and is still efficient for developers who want to find faults in their databases' performance.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec80"/>There's more…</h2></div></div></div><p>Another great little tool we can take a look at is the Zend Developer Tools, which is a module made by Zend that fits in <a id="id433" class="indexterm"/>Zend Framework 2 that provides very useful debugging tools. If we want to know more, we can find the tools at <a class="ulink" href="https://github.com/zendframework/ZendDeveloperTools">https://github.com/zendframework/ZendDeveloperTools</a>.</p></div></div>
<div class="section" title="Creating a Database Access Object"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Creating a Database Access Object</h1></div></div></div><p>Although we can use a dozen <a id="id434" class="indexterm"/>different methods to standardize our database functionality, a Database Access Object (or DAO) can be used efficiently to achieve this. This recipe is a working example of how to make your own, and begin organizing your functionality.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec81"/>Getting ready</h2></div></div></div><p>Database Access Object (from now on DAO) is used to simplify functionality to and from our database(s). The idea behind a DAO is to create mapping classes that have a single responsibility on their functionality. This means that, for example, we have a table called <code class="literal">cards</code>, which also has a mapping called <code class="literal">Cards</code>. This <code class="literal">Cards</code> mapping will then contain all the functionality we need to use in that table.</p><p>This could include, for example, the CRUD (Create, Read, Update, and Delete) functionality, but also more complex methods such as calculations. The idea behind a mapping class is that we are able to hide the layout of the database and provide an interface for the rest of the application, which is reliable and consistent without the application needing to know how the database is structured.</p><p>For the recipe we will use the database <a id="id435" class="indexterm"/>layout that has a table called <code class="literal">cards</code>, with the following columns:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">id</code> (primary key)</li><li class="listitem" style="list-style-type: disc"><code class="literal">color</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">value</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">type</code></li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec82"/>How to do it…</h2></div></div></div><p>A DAO is a great way of organizing our database functionality in the application, so that we will always have a clear structure of our logic. In this recipe, we'll show how to make one of our own.</p><div class="section" title="Creating our new module and configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec157"/>Creating our new module and configuration</h3></div></div></div><p>Our DAO is going be in a <a id="id436" class="indexterm"/>completely separate module, as that is the best way of separating the different pieces of code. So, we go ahead to create a new <a id="id437" class="indexterm"/>module DAO, which should have the following directory structure:</p><div class="informalexample"><pre class="programlisting">module\DAO\
  config\
    module.config.php
  src\
    DAO\
  Connection\
    Connector.php
  DTO\
    Cards.php

Mapper\
  Cards.php
  MapperAbstract.php
  MapperInterface.php
  Module.php</pre></div><p>Once we have created the necessary folders, we can copy the default <code class="literal">Module.php</code> from the <code class="literal">Application</code> module over to our <code class="literal">DAO</code> folder. We then open our new <code class="literal">Module.php</code>, and make sure the <code class="literal">namespace</code> is set to <code class="literal">DAO</code> as well.</p><p>Now, it is time to create a <a id="id438" class="indexterm"/>new <code class="literal">/module/DAO/config/module.config.php</code> file and add the following lines:</p><div class="informalexample"><pre class="programlisting">&lt;?php

return array(
  // This is going to be the configuration from which we 
  // will read. Obviously the username/password should 
  // be in the local.php but we will just put it here 
  // example wise.
  'dao' =&gt; array(
    'hostname' =&gt; 'localhost',
    'username' =&gt; 'some_user',
    'password' =&gt; 'some_password',
    'database' =&gt; 'book',

    // This mapper will contain all of our mapper 
    // classes such as DAO\Db\Mapper\Cards and let them 
    // know which table they need to connect to.
    'mapper' =&gt; array(
      'Cards' =&gt; 'cards',
    ),
  ),

  // Initialize our service manager so that we can reach 
  // our mappers from anywhere else in the application 
  // (every mapper should have its own entry) and our 
  // connector which should be reached only by the 
  // mappers and not anywhere else
  'service_manager' =&gt; array(
    'invokables' =&gt; array(
      'DAO_Connector' =&gt;'DAO\Db\Connection\Connector',
      'DAO_Mapper_Cards' =&gt;'DAO\Db\Mapper\Cards',
    ),
  ),
);</pre></div><p>This pretty basic configuration will be <a id="id439" class="indexterm"/>used by our database connector later on to get the connection details from.</p></div><div class="section" title="Creating a connector"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec158"/>Creating a connector</h3></div></div></div><p>Next, we want to <a id="id440" class="indexterm"/>create our connector, which is basically a class that will create a database adapter and set everything up for us. It will not do <a id="id441" class="indexterm"/>anything else than that, so we should be able to code one easily.</p><p>Let's now create a file called <code class="literal">/module/DAO/src/DAO/db/Connection/Connector.php</code> in the <code class="literal">DAO\Db\Connection</code> <code class="literal">namespace</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Set the correct namespace
namespace DAO\Db\Connection;

// We will be using the following classes
use Zend\ServiceManager\ServiceLocatorAwareInterface;
use Zend\ServiceManager\ServiceLocatorInterface;
use Zend\Db\Adapter\Adapter;

// We are going to make this as a Service, so make sure 
// we implement the ServiceLocatorAwareInterface
class Connector implements ServiceLocatorAwareInterface 
{
  // Our service locator will be placed in here
  protected $serviceLocator;

  // Now set our service manager instance required by the 
  // ServiceLocatorAwareInterface
  public function setServiceLocator(ServiceLocatorInterface $serviceLocator)
  {
    $this-&gt;serviceLocator = $serviceLocator;
  }

  // And add our getter for the service manager, as is required by 
  // the ServiceLocatorAwareInterface
  public function getServiceLocator()
  {
    return $this-&gt;serviceLocator;
  }

  /**
   * Initializes a connection and returns a fresh 
   * adapter.
   *
   * @return \Zend\Db\Adapter\Adapter
   * @throws \Exception
   */
  public function initialize()
  {
    // Get the configuration from the module.config.php
    $dao = $this-&gt;getServiceLocator()-&gt;get('config');

    // The following array of configuration items should 
    // be in there
    $configItems = array(
      'hostname', 
      'username', 
      'database', 
      'password'
    );

    // Check if everything is there in the configuration
    foreach ($configItems as $required) {
      if (!in_array($required, array_keys($dao['dao']))) 
      {
        // If there is a config item missing, just let
        // the develop know
        throw new \Exception("{$required} is not in the DAO configuration!");
      }
    }
    
    // We can assume we have everything, now set up our 
    // MySQL connection
    return new Adapter(array(
      'driver' =&gt; 'Pdo_Mysql',
      'database' =&gt; $dao['dao']['database'],
      'hostname' =&gt; $dao['dao']['hostname'],
      'username' =&gt; $dao['dao']['username'],
      'password' =&gt; $dao['dao']['password'],
    ));
  }
}</pre></div><p>That is it for the class definition; we are now able to initialize the connection if we have the right items available in our <a id="id442" class="indexterm"/>configuration. If not, the <a id="id443" class="indexterm"/>method will throw an exception and let us know anyway.</p></div><div class="section" title="Creating a mapper interface"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec159"/>Creating a mapper interface</h3></div></div></div><p>We want to create a <a id="id444" class="indexterm"/>mapper interface now on which we will base all our future mapper classes. We do this because we want to make sure that all our mapper classes contain at least some of the methods we want. Our mapper <a id="id445" class="indexterm"/>interface will, therefore, define a small selection of methods we want our mapper classes to have.</p><p>Now, let's create file called <code class="literal">/module/DAO/src/DAO/Db/Mapper/MapperInterface.php</code> in the <code class="literal">DAO\Db\Mapper</code> <code class="literal">namespace</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Make sure we have the namespace right
namespace DAO\Db\Mapper;

// Note that this is an interface, and not a regular 
// class.
interface MapperInterface
{
  // We need an insert method in our mapper.  
  public function insert($data);

  // And obviously we want to update data
  public function update($data);

  // If we want to update, we also want to delete data
  public function delete($id);

  // And of course we want to load one specific record
  public function load($id);
  
  // Last but not least we also want a method to get all 
  // the records in the table
  public function getAll();
}</pre></div><p>As we see this is a pretty <a id="id446" class="indexterm"/>straightforward file as <a id="id447" class="indexterm"/>interfaces don't actually do any implementation of the code at all.</p></div><div class="section" title="Creating an abstract mapper class"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec160"/>Creating an abstract mapper class</h3></div></div></div><p>Although the interface <a id="id448" class="indexterm"/>doesn't implement any of the code, an abstract class can. We want to create a file called <code class="literal">/module/DAO/src/DAO/Db/Mapper/MapperAbstract.php</code> in the same <code class="literal">DAO\Db\Mapper</code> <code class="literal">namespace</code>, <a id="id449" class="indexterm"/>which will contain a method that will create a connection to the database, point to the right table, and return a freshly baked <code class="literal">Zend\Db\Sql\Sql</code> object:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Namespace, do I need to say more ;-)
namespace DAO\Db\Mapper;

// Use the following classes
use Zend\ServiceManager\ServiceLocatorAwareInterface;
use Zend\ServiceManager\ServiceLocatorInterface;
use Zend\Db\Sql\Sql;

// Note that we are again using the 
// ServiceLocatorAwareInterface and therefore need to 
// implement the getServiceLocator and setServiceLocator 
// (not shown here).
class MapperAbstract implements ServiceLocatorAwareInterface 
{
  // Our sql object will be put here
  private $sqlObject;

  // We'll just put our service locator in here	
  protected $serviceLocator;</pre></div><p>Everything set up, now let's create the method we need for our connection (don't forget to create <code class="literal">setServiceLocator</code> and <a id="id450" class="indexterm"/>
<code class="literal">getServiceLocator</code> <a id="id451" class="indexterm"/>methods as well!):</p><div class="informalexample"><pre class="programlisting">// This method will set up our connection, initialize 
// the right table and return a Sql object
protected function getSqlObject()
{
  // We only want to set up our connection once, no 
  // point in doing it more, right?

  if ($this-&gt;connection === null) {
    // Get our configuration from the 
    // module.config.php
    $config = $this-&gt;getServiceLocator()-&gt;get('config');

  // Get our class name
  $class = explode('\\', get_class($this));
	
  // Now check if our class name is defined in the 
  // mapper configuration of the dao configuration, 
  // so that we can get our table name. Looks more 
  // complicated than it is really.
  if (isset($config['dao']['mapper']) === true &amp;&amp; isset($config['dao']['mapper'][end($class)])) {

    // Get the database adapter from our connector
    $adapter = $this-&gt;getServiceLocator()
                    -&gt;get('DAO_Connector')
                    -&gt;initialize();

    // We have a configuration, now return our SQL 
    // object with the right table name included
    $this-&gt;sqlObject = new Sql(
      $adapter, 
      $config['dao']['mapper'][end($class)]
    );
      } else {
        // Make sure the developer knows not all the 
        // configuration is set.
        throw new \Exception("Configuration dao\mapper\\". end($class). " not set.");
   }
    } 

    // Now return our sql object
    return $this-&gt;sqlObject;
  }
}</pre></div><p>Our freshly created connection method can now be used by mappers to get a <code class="literal">Zend\Db\Sql\Sql</code> object, which is <a id="id452" class="indexterm"/>relevant to the <a id="id453" class="indexterm"/>table they want to work in.</p></div><div class="section" title="Creating a Data Transfer Object"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec161"/>Creating a Data Transfer Object</h3></div></div></div><p>Now, let's create <a id="id454" class="indexterm"/>a new <span class="strong"><strong>Data Transfer </strong></span>
<a id="id455" class="indexterm"/>
<span class="strong"><strong>Object</strong></span> (<span class="strong"><strong>DTO</strong></span>) file called <code class="literal">/module/DAO/src/DAO/Db/DTO/Cards.php</code> in the <code class="literal">DAO\Db\DTO</code> <code class="literal">namespace</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?php

// Namespace, quite essential
namespace DAO\Db\DTO;

// We should name our class simply Cards, as that is 
// used in the mapper later on as well
class Cards
{
  // Our 'cards' table exists of an id column, color, 
  // type and value, let's just define them as private 
  // properties.
  private $id;
  private $color;
  private $type;
  private $value;</pre></div><p>Now that we have set our private properties, we will also create some basic getters and setters for them. Use the following <a id="id456" class="indexterm"/>code for getters:</p><div class="informalexample"><pre class="programlisting">public function getId() { return $this-&gt;id; }
public function getColor() { return $this-&gt;color; }
public function getType() { return $this-&gt;type; }
public function getValue() { return $this-&gt;value; }</pre></div><p>The getters are now done, which was pretty easy, now let's do the setters:</p><div class="informalexample"><pre class="programlisting">// The id will only be set if we update a record, or 
// when we retrieve a record from a database. Never 
// when we want to insert a record.
public function setId($id) {
  $this-&gt;id = $id;
}

// Make sure we can only use colors that are valid in 
// our table.
public function setColor($color) 
{
  $validColors = array('diamond', 'spade', 'heart', 'club');

  if (in_array($color,$validColors)== false) {
    throw new \Exception(
      "Type can only be 'diamond', 'spade', 'heart'".   
      "or 'club'."
    );
  }

  $this-&gt;color = $color;
}

// Make sure only a valid type is entered.
public function setType($type) 
{
  $validTypes = array('number', 'picture');

  if (!in_array($type, $validTypes)) {
    throw new \Exception(
      "Type can only be 'number' or 'picture'."
    );
  }
    
  $this-&gt;type = $type;
}

// A value can only have a maximum of 6 character
public function setValue($value) 
{
  $maxValue = 6;

  if (strlen($value) &gt;$maxValue) {
    throw new \Exception(
      "Maximum length of value is 6."
    );
  }
    
  $this-&gt;value = $value;
}</pre></div><p>The setters were obviously a little more complicated as we also wanted to make sure the data we put in is valid for our database. This way we can safely parse object to the mapper later on and be sure that everything will go all right.</p><p>Now, create the last method <a id="id457" class="indexterm"/>which is a construct <a id="id458" class="indexterm"/>so that we can easily set the properties without needing to do that manually afterwards:</p><div class="informalexample"><pre class="programlisting">  public function __construct($type, $value, $color, $id = null) 
  {
    // Id is optional, so see if it is parsed or not
    if ($id !== null) $this-&gt;setId($id);
    
    $this-&gt;setColor($color);
    $this-&gt;setType($type);
    $this-&gt;setValue($value);
  }
}</pre></div><p>We now created a simple DTO which we can use to communicate to some methods in our mapper. Now, last but not least let's create the mapper class!</p></div><div class="section" title="Creating a mapper class"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec162"/>Creating a mapper class</h3></div></div></div><p>The mapper will be the <a id="id459" class="indexterm"/>main DAO class that we will use <a id="id460" class="indexterm"/>in the application because it will be the class that has the methods for <code class="literal">insert</code>, <code class="literal">getAll</code>, and so on.</p><p>Let's start by creating a <code class="literal">/module/DAO/src/DAO/Db/Mapper/Cards.php</code> file in the <code class="literal">DAO\Db\Mapper</code> <code class="literal">namespace</code> and add the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace DAO\Db\Mapper;

use Zend\Db\Sql\Where;
use DAO\Db\DTO\Cards as CardsDto;
use DAO\Db\Mapper\MapperInterface;

// This class will extend and implement both our 
// Abstract as our Interface class
class Cards extends MapperAbstract implements MapperInterface
{</pre></div><p>Let's create a method for deleting a row first:</p><div class="informalexample"><pre class="programlisting">/**
 * Delete a specific row.
 * 
 * @param int $id
 */
public function delete($id) 
{
  // Get our fresh Sql object from our Abstract method
  $sql = $this-&gt;getSqlObject();
    
  // Create a new WHERE clause
  $where = new Where();

  // When deleting we want to match on an id
  $where-&gt;equalTo('id', $id);

  // Statements can throw exceptions, so make sure we 
  //catch them in time.
  try {
    // Create a new delete object with our where class    
    // attached and then immediately turn it into a 
    // statement. That is called pure laziness
    $statement = $sql-&gt;prepareStatementForSqlObject(               
      $sql-&gt;delete()-&gt;where($where)
    );
      
    // Execute the statement
    $result = $statement-&gt;execute();
      
    // If there is more than 0 rows deleted return 
    // true, otherwise false
    return $result-&gt;getAffectedRows() &gt; 0;
  } catch (\Exception $e) {
    // Something went terribly wrong, just ignore it 
    // for now ;-)
    // TIP: Don't do this in real life, at least log your 
    //exceptions.
    return false;
  }
}</pre></div><p>We have created a simple <code class="literal">delete</code> <a id="id461" class="indexterm"/>method, now let's continue and create <a id="id462" class="indexterm"/>our <code class="literal">getAll</code> method, which will retrieve all the records in the database:</p><div class="informalexample"><pre class="programlisting">/**
 * Returns all the records in the database.
 * 
 * @return \DAO\Db\DTO\Cards
 */
public function getAll()
{
  // Get the SQL object
  $sql = $this-&gt;getSqlObject();

  // Prepare a select statement
  $statement = $sql-&gt;prepareStatementForSqlObject(
    $sql-&gt;select()
  );

  // Execute the freshly made statement
  $records = $statement-&gt;execute();

  // Create our return array
  $retval = array();
    
  // Loop through the records and add them to the 
  // result array
  foreach ($records as $row) {
    // Create a new Cards DTO and assign our record
    $retval[] = new CardsDto(
      $row['type'], 
      $row['value'], 
      $row['color'], 
      $row['id']
    );
  }
    
  return $retval;
}</pre></div><p>After we have <a id="id463" class="indexterm"/>created our <code class="literal">getAll</code>, which returns an array with Cards DTO's we will now create the method to insert <a id="id464" class="indexterm"/>a record:</p><div class="informalexample"><pre class="programlisting">/**
 * Inserts a record.
 * 
 * @param \DAO\Db\DTO\Cards $data
 */
public function insert($data)
{
  // We can easily insert this as we know the DTO has 
  // already taken care of the validation of the values.
  if (!$data instanceof DAO\Db\DTO\Cards) {
    throw new \Exception(
      "Data needs to be of type DAO\Db\DTO\Cards"
    );
  }
  
  // Get our SQL object
  $sql = $this-&gt;getSqlObject();
    
  try {
    // Create our insert statement with the values 
    // assigned into it.
    $statement = $sql-&gt;prepareStatementForSqlObject(
      $sql-&gt;insert()
          -&gt;values(array(
            'color' =&gt; $data-&gt;getColor(),
            'type' =&gt; $data-&gt;getType(),
            'value' =&gt; $data-&gt;getValue()
      ))
  );
  
    // Execute our statement
    $result = $statement-&gt;execute();
      
    // Return our primary key after insertion
    return $result-&gt;getGeneratedValue();
  } catch (\Exception $e) { 
    // Something went wrong, handle exception and 
    // return false
    return false;
    }
  }</pre></div><p>Now, let's continue to <a id="id465" class="indexterm"/>our <code class="literal">load</code> method, which will return only one record:</p><div class="informalexample"><pre class="programlisting">public function load($id) 
{
  // Get the SQL object
  $sql = $this-&gt;connection();
    
  // A fresh WHERE clause
  $where = new Where();
  $where-&gt;equalTo('id', $id);
    
  try {
    // Prepare a select statement with the where 
    // clause attached.
    $statement = $sql-&gt;prepareStatementForSqlObject(
      $sql-&gt;select()-&gt;where($where)
    );
    
    // Execute the statement and return the first row
    $record = $statement-&gt;execute()-&gt;current();
    
    // Now let's return a fresh Cards DTO object
    return new CardsDto(
      $record['type'], 
      $record['value'], 
      $record['color'], 
      $record['id']
    );
  } catch (\Exception $e) {
 return false;
  }
}</pre></div><p>We now created the <code class="literal">load</code> <a id="id466" class="indexterm"/>method, which will return a Cards DTO object for us to use, now last but not least the <code class="literal">update</code> method:</p><div class="informalexample"><pre class="programlisting">  public function update($data) 
  {
    // We can easily insert this as we know the DTO has 
    // already taken care of the validation of the   
    // values.
    if (get_class($data) !== 'DAO\Db\DTO\Cards') {
      throw new \Exception(
        "Data needs to be of type DAO\Db\DTO\Cards"
      );
    }
    
    if ($data-&gt;getId() === null) {
      throw new \Exception(
           "Can't update anything if we don't have a card id!"
      );
    }
  
    // Get the connection
    $sql = $this-&gt;connection();
    
    try {
      // Create the WHERE clause
      $where = new Where();
      $where-&gt;equalTo('id', $data-&gt;getId());

      // Create the update class
      $update = $sql-&gt;update();

      // Set the where clause
      $update-&gt;where($where);
      $update-&gt;set(array(
        'color' =&gt; $data-&gt;getColor(),
        'type' =&gt; $data-&gt;getType(),
        'value' =&gt; $data-&gt;getValue()
      ));
      
      // Create the statement
      $statement = $sql-&gt;prepareStatementForSqlObject($update);
      
      // Execute the statement
      $result = $statement-&gt;execute();
      
      // If more than 0 rows were updated return true, 
      // otherwise false
      return $result-&gt;getAffectedRows() &gt; 0;
    } catch (\Exception $e) { 
      return false;
    }
  }
}</pre></div><p>We have now successfully created a mapper class and that also concludes our DAO. We can now easily get the mapper through <a id="id467" class="indexterm"/>the service manager in (for example) a controller (<code class="literal">/module/Cards/src/Cards/Controller/CardController.php</code>) by using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?php

namespace Cards\Controller;

use Zend\Mvc\Controller\AbstractActionController;

class CardsController extends AbstractActionController
{
  public function viewAction()
  {
    if (!$this-&gt;getParam('id'))
        throw new \Exception("Missing id");

    // Get the record to load from the query string
    $id = $this-&gt;params()-&gt;fromQuery('id');

    // Get the card mapper from the service manager
    $cardMapper = $this-&gt;getServiceLocator()
                       -&gt;get('DAO_Mapper_Cards');

    // Load the requested card
    $card = $cardMapper-&gt;load($id);

    // Dump the loaded record to the screen
    echo '&lt;pre&gt;'. Print_r($card, true). '&lt;/pre&gt;';
  }
}</pre></div><p>And, because we created an abstract and interface it is really easy for us to create new mappers as well. Obviously it <a id="id468" class="indexterm"/>requires us to be consistent, but that is a good thing.</p></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec83"/>How it works…</h2></div></div></div><div class="section" title="About the DAO"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec163"/>About the DAO</h3></div></div></div><p>A DAO or Database Access <a id="id469" class="indexterm"/>Object is a design pattern that creates an abstract environment for developers to access their database related methods. This means that we create a standardized environment for us to work in, which is not only consistent but also very stable. Because, we limit ourselves in our way of working with database queries and objects we create a piece of code which is very easy to work with.</p><p>In this recipe, we created a very simple DAO, which (to my personal opinion) is a good basis, but probably not the most efficient way of creating one. We just took one example how a DAO can be implemented, but we should never shut our eyes to the literally dozens of different ways of implementing it.</p></div><div class="section" title="About the recipe"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec164"/>About the recipe</h3></div></div></div><p>Because our configuration contains a mapper array with all the mapper class names (<code class="literal">DAO\Db\Mapper\Cards</code> becomes simply cards in the configuration) we cannot go wrong. This separates the local configuration of the database environment from the code. So if we were to change the table name to 'books' we only have to change the configuration and the code would still work!</p><p>We are going to create a DTO so that we can easily insert/update and return records through a standardized way. So instead of returning an array in our selections we can then return an object which will contain everything we need. This way we make sure our data is filtered and simply transferrable.</p><p>As we can see in the <code class="literal">insert</code> method in the Mapper class we assume the DTO object contains the right information for us to insert our record. Although this method is far from perfect, it is a good method of separating our checking and validating of the data to another object (in our case the DTO) so we can just concentrate on inserting the record. This separation is essential to a good working DAO.</p></div></div></div></body></html>