- en: Chapter 10. Using Advanced Operators and Techniques in RxPHP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 在RxPHP中使用高级操作符和技术
- en: This is the last chapter dedicated to explaining new RxPHP operators. There
    are few topics that didn't fit into any of the preceding chapters, so we'll cover
    them now. A couple of times we'll revisit Observable multicasting from [Chapter
    8](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d "Chapter 8. Multicasting
    in RxPHP and PHP7 pthreads Extension") , *Multicasting in RxPHP and PHP7 pthreads
    Extension*, in practical examples and also four new operators, `zip()`, `window()`,
    `materialize()`, and `dematerialize()`, which are more advanced techniques for
    modifying Observable chains.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一章，专门用于解释新的RxPHP操作符。有一些主题没有适合前几章，所以我们现在将涵盖它们。我们将多次回顾来自[第8章](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d
    "第8章. RxPHP和PHP7 pthreads扩展中的多播")，*RxPHP和PHP7 pthreads扩展中的多播*的Observable多播，在实践示例中，还有四个新的操作符，`zip()`、`window()`、`materialize()`和`dematerialize()`，它们是修改Observable链的更高级技术。
- en: 'In particular, in this chapter we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在本章中，我们将涵盖以下主题：
- en: The `zip()` and `window()` operators that work with higher-order Observables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与高阶Observables一起工作的`zip()`和`window()`操作符
- en: The `materialize()` and `dematerialize()` operators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`materialize()`和`dematerialize()`操作符'
- en: Error propagation in Observable chains and how to properly catch exceptions
    from user-defined callbacks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Observable链中的错误传播以及如何正确捕获用户定义回调的异常
- en: Theory around creating hot/cold Observables and the difference in unsubscribing
    and completing Observable chains
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建热/冷Observables的理论以及取消订阅和完成Observables链之间的差异
- en: Creating anonymous operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建匿名操作符
- en: Writing a recursive `DirectoryIteratorObservable` that emits all files in a
    directory and all its subdirectories
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个递归的`DirectoryIteratorObservable`，它会在目录及其所有子目录中发出所有文件
- en: Writing a variant of `DirectoryIteratorObservable` based on multicasting
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于多播编写`DirectoryIteratorObservable`的变体
- en: Writing an FTP client based on RxPHP
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于RxPHP编写FTP客户端
- en: Using RxPHP in blocking and synchronous applications
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在阻塞和同步应用程序中使用RxPHP
- en: We've seen so many RxPHP operators throughout this entire book. All of them
    worked with values in some way or another.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们已经看到了许多RxPHP操作符。它们都以某种方式与值一起工作。
- en: However, there are also operators that are, in principle, similar to those used
    by hot Observables or cold Observables when testing the RxPHP code that we saw
    in [Chapter 5](part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d
    "Chapter 5. Testing RxPHP Code") , *Testing RxPHP Code*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有一些操作符在原则上与我们在[第5章](part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d
    "第5章. 测试RxPHP代码")中看到的用于测试RxPHP代码的热Observables或冷Observables的操作符相似，*测试RxPHP代码*。
- en: The zip() operator
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`zip()`操作符'
- en: The `zip()` operator is similar to the `ForkJoinObservable` that we implemented
    ourselves in [Chapter 5](part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d
    "Chapter 5. Testing RxPHP Code"), *Testing RxPHP Code*. The main difference is
    that it internally stores all emissions for each source Observable in a separate
    queue and then re-emits their values when all sources have a value at a specific
    index.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()`操作符类似于我们在[第5章](part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d
    "第5章. 测试RxPHP代码")中实现的`ForkJoinObservable`。主要区别在于它内部将每个源Observables的所有发射存储在单独的队列中，然后在所有源在特定索引处都有值时重新发射它们的值。'
- en: 'This will be understood better by looking at the following example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看以下示例可以更好地理解这一点：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have three source Observables where each of them emits a different number
    of items. Then the `zip()` operator emits an array of values only when all the
    sources have emissions at the same index. So we know that `DebugSubject` will
    receive only two items because the `$obs2` Observable emits only two items.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个源Observables，其中每个都发出不同数量的项目。然后`zip()`操作符只在所有源在相同索引处都有发射时发出值数组。因此我们知道`DebugSubject`将只接收两个项目，因为`$obs2`
    Observables只发出两个项目。
- en: In other words, the `zip()` operator can't make the third emission because it
    doesn't have a third value for the second `$obs2` Observable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`zip()`操作符不能产生第三次发射，因为它没有为第二个`$obs2` Observables提供第三个值。
- en: 'The output from this example is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的输出如下：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that it contains only the first two values for each source Observable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它只包含每个源Observables的前两个值。
- en: 'We can have a look at another and more complicated example that simulates asynchronous
    emission from multiple source Observables:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看看另一个更复杂的示例，该示例模拟了来自多个源Observables的异步发射：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since each source Observable emits with a different interval, the `zip()` operator
    will have to emit according to the slowest one, which emits every 1000ms. Values
    for the rest of the Observables are then stacked internally in queues.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个源 `Observable` 以不同的间隔发射，`zip()` 操作符将不得不根据最慢的一个发射，它每1000毫秒发射一次。其余 `Observable`
    的值随后在内部队列中堆叠。
- en: 'This example will print the following output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子会打印以下输出：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that we're actually not losing values. All values that weren't re-emitted
    yet are kept inside the `zip()` operator.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意实际上我们没有丢失任何值。所有尚未重新发射的值都被保存在 `zip()` 操作符内部。
- en: The window() operator
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`window()` 操作符'
- en: The `window()` operator belongs among the more advanced higher-order Observables.
    We've seen the `switchLatest()` operator in [Chapter 6](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "Chapter 6. PHP Streams API and Higher-Order Observables"), *PHP Streams API and
    Higher-Order Observables*, and we know that it automatically subscribes to the
    latest Observable emitted from its source Observable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`window()` 操作符属于更高级的更高阶 `Observable` 之一。我们在 [第6章](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "第6章。PHP Streams API 和更高阶 `Observable`") 中看到了 `switchLatest()` 操作符，*PHP Streams
    API 和更高阶 `Observable`*，并且我们知道它会自动订阅其源 `Observable` 发射的最新 `Observable`。'
- en: The exact opposite is the `window()` operator that takes a so called "window
    boundary" Observable as an argument and splits the source emissions into separate
    Observables based on emission from the "window boundary" Observable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反的是 `window()` 操作符，它接受一个所谓的“窗口边界” `Observable` 作为参数，并根据“窗口边界” `Observable`
    的发射将源发射分成单独的 `Observable`。
- en: 'An example will definitely make this more obvious:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子肯定会使这一点更加明显：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have a source Observable emitting 10 items in total. The `window()` operator
    splits them into chunks of three items because of the Observable in the `$windowBoundary`
    variable that we pass as an argument to `window()`. This means that we'll make
    four Observables in total where the first three emit three items (and then complete)
    and the last one just a single item (and then it completes as well).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个总共发射10个项目的源 `Observable`。由于我们传递给 `window()` 的 `$windowBoundary` 变量中的 `Observable`，`window()`
    操作符将它们分成三个项目的块。这意味着我们将总共创建四个 `Observable`，其中前三个发射三个项目（然后完成），最后一个只发射一个项目（然后它也完成）。
- en: To make this even more obvious, we added the `doOnNext()` operator to print
    a log every time we create a new Observable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这一点更加明显，我们添加了 `doOnNext()` 操作符，以便每次创建新的 `Observable` 时都打印一条日志。
- en: The `switchLatest()` operator is then used to always subscribe only to the latest
    Observable emitted by `window()`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `switchLatest()` 操作符始终只订阅 `window()` 发射的最新 `Observable`。
- en: 'So in the console it''ll look like we split the source into chunks of three
    items. In other words, we split the source into windows of three times:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此在控制台里看起来我们是将源数据分成了三个项目的块。换句话说，我们将源数据分成了三个时间单位的窗口：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You're probably wondering what's this all good for. The `window()` operator,
    optionally takes a selector function. This function receives as an argument the
    current window before pushing it to its observers. For us this means that we can
    further chain operators to it before it's passed further, which can be very useful.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这有什么好处。`window()` 操作符可以可选地接受一个选择函数。这个函数接收当前窗口作为参数，在将其推送到观察者之前。对我们来说，这意味着我们可以在它进一步传递之前将其与更多的操作符链式连接，这可能非常有用。
- en: Imagine we're in a situation where we're receiving messages of many different
    types, but we want to be able to guarantee that we pass through only one message
    of each type every 100 messages.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们处于这样一个情况：我们正在接收许多不同类型的消息，但我们希望保证每100条消息中只通过每种类型的一条消息。
- en: 'We can simulate such a situation by creating a source Observable with 500 items
    where we repeat only three different characters. Then split it into windows with
    100 items each and use the selector function to chain the new window Observables
    with the `distinct()` operator:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个包含500个项目的源 `Observable` 来模拟这种情况，其中我们只重复三种不同的字符。然后将其分成每个100个项目的窗口，并使用选择函数将新的窗口
    `Observable` 与 `distinct()` 操作符链式连接：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Every Observable emitted by the `window()` operator has its own instance of
    the `distinct()` operator, so after every 100 items we start comparing distinct
    items all over again.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `window()` 操作符发射的每个 `Observable` 都有自己的 `distinct()` 操作符实例，因此每100个项目后，我们又开始重新比较不同的项目。
- en: 'This example prints the following output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子会打印以下输出：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the order of characters is always going to be different because the
    source is generated randomly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，字符的顺序总是会有所不同，因为源是随机生成的。
- en: We can see that even though each window contains 100 items, these are always
    filtered by the `distinct()` operator that we chained to the window Observable
    in the selector function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，尽管每个窗口包含100个项目，但这些项目总是通过我们在选择函数中连接到窗口可观察对象的`distinct()`运算符进行过滤。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `window()` operator definitely falls into the group of more advanced and
    not so common operators in practice. In RxJS 5 there're even more variants of
    this operator for more specific use cases.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`window()`运算符确实属于更高级且不太常见的运算符之一。在RxJS 5中，甚至有更多这个运算符的变体，用于更具体的用例。'
- en: The materialize() and dematerialize() operators
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`materialize()`和`dematerialize()`运算符'
- en: In [Chapter 5](part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d
    "Chapter 5. Testing RxPHP Code") , *Testing RxPHP Code*, when we talked about
    testing in RxPHP, we weren't using real values, and instead were passing some
    special recorded objects that wrapped the actual value with `OnNextNotification`
    (or its `error` or `complete` variants). We did this because of the `TestScheduler`
    class and because we had to be able to uniquely identify each value in order to
    compare object references and not just their values. Comparing just values wouldn't
    guarantee that they are identical because primitive types such as strings or integers
    aren't passed by reference by default.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0043_split_000.html#190861-bd355a22cf10407cb10df27e65585b8d "第5章。测试RxPHP代码")，*测试RxPHP代码*，当我们讨论RxPHP中的测试时，我们没有使用真实值，而是传递了一些特殊记录的对象，这些对象使用`OnNextNotification`（或其`error`或`complete`变体）包装了实际值。我们这样做是因为`TestScheduler`类，以及我们必须能够唯一地识别每个值，以便比较对象引用而不是它们的值。仅比较值不能保证它们是相同的，因为默认情况下，原始类型（如字符串或整数）不是通过引用传递的。
- en: There are two operators that use a similar principle. These are `materialize()`
    and `dematerialize()`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个运算符使用类似的原则。这些是`materialize()`和`dematerialize()`。
- en: The first one takes each value, wraps it with a notification object, and re-emits
    it as a typical `onNext` signal. This includes `error` and `complete` signals
    as well. These are wrapped and re-emitted like any other value, and after that
    a complete signal is sent.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个操作符会取每个值，将其包装在一个通知对象中，并以典型的`onNext`信号重新发射。这包括`error`和`complete`信号。这些信号就像任何其他值一样被包装和重新发射，之后发送一个完整的信号。
- en: 'This means we can completely ignore error signals or handle them as regular
    values. Before we talk more about what we can do with all this, let''s consider
    the following example where we''ll see what the `materialize()` operator actually
    does:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以完全忽略错误信号或像处理常规值一样处理它们。在我们更多地讨论我们可以用所有这些做什么之前，让我们考虑以下示例，我们将看到`materialize()`运算符实际上做什么：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is just a `RangeObservable` that emits three values and then sends complete
    signals. The `materialize()` operator converts each signal into an object, so
    this example will print the following output to the console:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个仅发出三个值然后发送完整信号的`RangeObservable`。`materialize()`运算符将每个信号转换为对象，因此这个例子将在控制台打印以下输出：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see that `DebugSubject` received five signals in total. The first three
    are just numbers emitted by the source `RangeObservable`. Then follows the complete
    signal from the source, wrapped as well, and after that another complete signal,
    but this time emitted by the `materialize()` operator itself.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`DebugSubject`总共接收了五个信号。前三个是源`RangeObservable`发出的数字。然后是源发出的完整信号，也被包装了，之后是另一个完整信号，但这次是由`materialize()`运算符本身发出的。
- en: 'Now let''s have a look at another example where we emit an error:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看另一个例子，其中我们将发射一个错误：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is very similar to the previous example, but this time we're forcing one
    error signal among normal emissions. As we said, the `materialize()` operator
    wraps the error and then calls `complete`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这与上一个例子非常相似，但这次我们在正常发射中强制包含一个错误信号。正如我们所说，`materialize()`运算符包装错误并调用`complete`。
- en: 'When we run this example, we''ll see that the wrapped value `4` never arrived
    to `DebugSubject` since it has already unsubscribed because of the `complete`
    signal:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个例子时，我们会看到包装的值`4`从未到达`DebugSubject`，因为它已经因为`complete`信号而取消订阅：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So what's all this actually good for when we can't, in fact, skip either the
    `error` or the `complete` signals?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当我们实际上不能跳过`error`或`complete`信号时，所有这些到底有什么用？
- en: While `materialize()` wraps signals with a notification object, there's also
    the exact opposite operator called `dematerialize()`. And, of course, we can use
    these two operators independently of each other.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`materialize()`会将信号包裹在通知对象中，但还有一个完全相反的操作符叫做`dematerialize()`。当然，我们可以独立使用这两个操作符。
- en: Customizing error bubbling with dematerialize()
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`dematerialize()`自定义错误冒泡
- en: Imagine that we have an Observable chain that needs to emit multiple errors,
    but it can't decide which of these are severe and need to be propagated further
    down the chain and which can be safely ignored. In a normal Observable chain,
    the first error would cause immediate unsubscription.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们有一个需要发出多个错误的Observable链，但它无法决定这些错误中哪些是严重的，需要进一步传播到链的下方，哪些可以安全地忽略。在一个正常的Observable链中，第一个错误会导致立即取消订阅。
- en: With clever usage of notification objects and the `dematerialize()` operator,
    we can let the error pop up when we want.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过巧妙地使用通知对象和`dematerialize()`操作符，我们可以让错误在我们想要的时候出现。
- en: In the following example, we generate a series of nine numbers. Every third
    number is then converted into an error notification. The errors aren't important
    and can be safely ignored. But the sixth number is different, and when it appears
    we always want to signal an error.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们生成一系列九个数字。然后，每隔第三个数字被转换为一个错误通知。这些错误并不重要，可以安全地忽略。但是第六个数字是不同的，当它出现时，我们总是想发出一个错误信号。
- en: 'Consider the following example that generates multiple error signals and wraps
    them with notifications:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，它生成多个错误信号并将它们包裹在通知中：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This example uses `materialize()` at the beginning to convert all values to
    notifications. Then, inside the `map()` operator, we unwrap all notifications
    with their `accept()` method that propagates their value to the appropriate callable
    (it's like calling `subscribe()` on an Observable). This way we can see its value
    and just return it as it is or eventually return `OnErrorNotification` instead.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例在开始时使用`materialize()`将所有值转换为通知。然后，在`map()`操作符内部，我们使用它们的`accept()`方法解包所有通知，将它们的值传播到适当的可调用对象（就像在Observable上调用`subscribe()`一样）。这样我们就可以看到它的值，并直接返回它，或者最终返回`OnErrorNotification`。
- en: 'When we run this example, we''ll get the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个示例时，我们会得到以下输出：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is what we wanted to get. None of the errors actually did anything, and
    they were all emitted as a normal `onNext` signal. Note that instead of number
    six we have a `LogicException`. Now the last thing is to filter out all errors
    that are unimportant for us. This means all errors except the single `LogicException`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们想要得到的结果。实际上，没有任何错误做了任何事情，它们都被作为正常的`onNext`信号发出。注意，我们用`LogicException`代替了数字六。现在最后一件事是过滤掉对我们来说不重要的所有错误。这意味着除了单个`LogicException`之外的所有错误。
- en: 'We''ll prepend the `filter()` and `dematerialize()` operators before the `subscribe()`
    call. We have to use `dematerialize()` to turn notifications to their respective
    signals. So the preceding example will look like the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`subscribe()`调用之前添加`filter()`和`dematerialize()`操作符。我们必须使用`dematerialize()`将通知转换为相应的信号。因此，前面的示例将看起来像以下这样：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we rerun this finalized example, we''ll get the following output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新运行这个最终示例，我们会得到以下输出：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All the other errors were ignored by the `filter()` operator and the only one
    that was preserved and unwrapped with `dematerialize()` is the `LogicException`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他错误都被`filter()`操作符忽略了，唯一被保留并使用`dematerialize()`解包的是`LogicException`。
- en: This method of handling errors is obviously a hack that we typically don't want
    to do, but it's good to know that even this is possible with RxPHP out of the
    box, without creating custom observers or Observables.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种处理错误的方法显然是一种我们通常不想做的黑客技巧，但了解即使使用RxPHP也可以直接做到这一点，而不需要创建自定义观察者或Observables，这是很好的。
- en: Error handling in RxPHP operator chains
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxPHP操作符链中的错误处理
- en: You may be wondering why we can't just emit multiple errors from an Observable
    and then use `materialize()` to wrap them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们不能直接从Observable发出多个错误，然后使用`materialize()`来包裹它们。
- en: 'Consider the following example with `Observable::create` that emits two errors:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下使用`Observable::create`发出两个错误的示例：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It might look like this example should wrap all the values and errors into
    notifications because we put the `materialize()` operator right after the `Observable::create`.
    Let''s see what happens when we run this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子看起来应该将所有值和错误都包裹在通知中，因为我们把`materialize()`操作符放在`Observable::create`之后。让我们看看当我们运行它时会发生什么：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So why can we only see the emissions up to the first error even though we used
    `materialize()`?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么尽管我们使用了 `materialize()`，我们只能看到直到第一个错误为止的发射？
- en: Every time we use `lift()`, we're actually creating a new instance of `AnonymousObservable`.
    This Observable creates an instance of `AutoDetachObserver` internally on subscription,
    and after that, it calls its subscription callable. This `AutoDetachObserver`
    class automatically calls `dispose()` on its internal disposable object (which
    unsubscribes from the source) when it receives the `error` or `complete` signal.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们使用 `lift()`，实际上是在创建一个 `AnonymousObservable` 的新实例。这个 Observable 在订阅时内部创建一个
    `AutoDetachObserver` 实例，然后调用其订阅可调用项。这个 `AutoDetachObserver` 类在接收到 `error` 或 `complete`
    信号时会自动调用其内部的可处置对象（从而取消订阅源）。
- en: Since almost all operators internally use `lift()`, they are also using `AutoDetachObserver`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于几乎所有的操作符内部都使用 `lift()`，因此它们也使用 `AutoDetachObserver`。
- en: This includes `Observable::create()`, which is just a static method that creates
    a new `AnonymousObservable`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括 `Observable::create()`，它只是一个创建新的 `AnonymousObservable` 的静态方法。
- en: So this is why an Observable can never emit more than one `error` or `complete`
    signal. They will always be ignored because the `AutoDetachObserver` class has
    already unsubscribed when it received the first one.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是为什么 Observable 永远不能发射超过一个 `error` 或 `complete` 信号。因为 `AutoDetachObserver`
    类在收到第一个信号时已经取消订阅，所以它们总是会被忽略。
- en: The default error handler
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认错误处理器
- en: We know that each observer can take as an optional parameter an error handler
    that is called on error notification. Although the default behavior is different
    than we might expect. If we do specify the error callable, we can handle the error
    however we want to.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，每个观察者都可以将错误处理器作为一个可选参数，在错误通知时被调用。尽管默认行为与我们可能预期的不同。如果我们指定了错误可调用项，我们可以按自己的意愿处理错误。
- en: 'For example, consider the following example where we specify only the error
    handler:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下只指定错误处理器的示例：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When we run this example we''ll see that the handler is called properly:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个示例时，我们会看到处理器被正确调用：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now what happens if don''t set any error handler at all? We can see this situation
    in the following example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们根本不设置任何错误处理器会发生什么？我们可以在以下示例中看到这种情况：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''re using the `CallbackObserver` without any parameter, so the following
    output is what we''ll get:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用不带任何参数的 `CallbackObserver`，所以以下输出就是我们将会得到的：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The exception was simply rethrown. We didn't set any error callable, so this
    is probably something we didn't expect to happen. It's good to be aware of this
    behavior because it means that if we don't handle error notifications they might
    cause unexpected script termination.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 异常只是被重新抛出。我们没有设置任何错误可调用项，所以这可能是我们没有预料到发生的事情。了解这种行为是好的，因为它意味着如果我们不处理错误通知，它们可能会引起意外的脚本终止。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The default error handling is the same in RxJS 5; however, there's an ongoing
    discussion whether this is the correct way Rx should behave. It's likely that
    in the future versions of RxJS this behavior will change.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxJS 5 中，默认的错误处理是相同的；然而，有一个持续的讨论，关于 Rx 应该如何表现。很可能会在 RxJS 的未来版本中改变这种行为。
- en: Catching exceptions inside operators
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在操作符内部捕获异常
- en: A similar principle applies also when calling any user defined functions inside
    an Observable or an operator. For example, when using the `map()` operator the
    callable is wrapped with a try-catch block. Any exception thrown inside our callable
    is then sent as an error notification.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Observable 或操作符内部调用任何用户定义的函数时，也适用类似的原则。例如，当使用 `map()` 操作符时，可调用项被封装在一个 try-catch
    块中。在可调用项内部抛出的任何异常随后会被发送为错误通知。
- en: This means that neither Observables nor operators are supposed to throw exceptions
    unless something unexpected occurs that shouldn't happen under normal circumstances.
    Throwing an exception inside a user defined callable is a valid use case.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 Observables 和操作符不应该抛出异常，除非发生某些在正常情况下不应该发生的不寻常情况。在用户定义的可调用项内部抛出异常是一个有效用例。
- en: 'We can test the difference on these two examples. First we''ll throw an exception
    inside the selector function to the `zip()` operator from the same example we
    saw previously:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过这两个示例测试它们之间的差异。首先，我们将在之前看到的示例中的选择器函数内部抛出一个异常给 `zip()` 操作符：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The exception will be caught and sent as an error notification:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 异常将被捕获并作为错误通知发送：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this example, we will see what happens when we try to use a regular object
    instead of a source Observable:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到当我们尝试使用普通对象而不是源 Observable 时会发生什么：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that this type of error is catchable in PHP7:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在PHP7中这种类型的错误是可以捕获的：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The exception was left to terminate the script execution because this is a situation
    that shouldn't happen. It probably means that we have a bug in our code where
    we unintentionally wanted to use an `stdClass` instance instead of an Observable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 异常被留下以终止脚本执行，因为这种情况不应该发生。这很可能意味着我们在代码中有一个错误，无意中想要使用`stdClass`实例而不是可观察对象。
- en: The Observable::create() method versus the Subject class
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable::create()方法与Subject类
- en: Apart from creating custom Observables, we know that we can use the `Observable::create()`
    static method or an instance of the `Subject` class to emit items by ourselves,
    but so far we haven't talked about which one we should choose over the other and
    why.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建自定义可观察对象外，我们知道我们可以使用`Observable::create()`静态方法或`Subject`类的实例来自行发出项目，但到目前为止，我们还没有讨论过我们应该选择哪一个以及为什么。
- en: As a rule of thumb it's usually better to use `Observable::create()`. It's not
    always possible, but it has its advantages.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 根据经验法则，通常最好使用`Observable::create()`。虽然并不总是可能，但它有其优点。
- en: 'For the next couple of examples, let''s consider that we want to work with
    an API that implements the following interface. This could be any Facebook/Twitter/WebSocket
    or system API:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个示例中，让我们假设我们想要与实现以下接口的API一起工作。这可以是任何Facebook/Twitter/WebSocket或系统API：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Hot/cold Observables and Observable::create()
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 热冷可观察对象和Observable::create()
- en: In the most general sense an Observable is just a function that connects an
    observer with the producer of values. By producer we understand any source of
    values that is unrelated to RxPHP. For example, this can be any class implementing
    our `RemoteAPI` interface.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在最一般的意义上，一个可观察对象只是一个将观察者与值的生产者连接起来的函数。通过生产者，我们理解任何与RxPHP无关的值源。例如，这可以是任何实现我们的`RemoteAPI`接口的类。
- en: We'll see that this works well with our definitions of hot/cold Observables
    from [Chapter 2](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 2. Reactive Programming with RxPHP"), *Reactive Programming with RxPHP*.
    A cold Observable creates its producer (in our case, connects to the remote API)
    on subscription. This means that we don't want to make any remote calls to the
    API until we have at least one observer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到这与我们从[第2章](part0024_split_000.html#MSDG2-bd355a22cf10407cb10df27e65585b8d
    "第2章。使用RxPHP进行响应式编程")，*使用RxPHP进行响应式编程*中定义的热冷可观察对象很好地工作。冷可观察对象在订阅时创建其生产者（在我们的例子中，连接到远程API）。这意味着在我们至少有一个观察者之前，我们不想对API进行任何远程调用。
- en: 'So a cold Observable internally using the RemoteAPI interface could look like
    the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，内部使用RemoteAPI接口的冷可观察对象可能看起来像以下这样：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This fulfills our expectations from a cold Observable. The producer doesn't
    exist until we subscribe and it automatically also closes the connection when
    unsubscribing because we returned the `CallbackDisposable` instance from the callback
    to the `Observable::create()` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这满足了我们对冷可观察对象的期望。生产者在我们订阅之前不存在，并且在取消订阅时也会自动关闭连接，因为我们从回调中返回了`CallbackDisposable`实例到`Observable::create()`方法。
- en: 'If we wanted to create a hot Observable with the `Observable::create()` method
    it would be similar, but this time the Observable is not responsible for neither
    creating nor closing the producer:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用`Observable::create()`方法创建一个热可观察对象，那么它将是相似的，但这次可观察对象既不负责创建也不负责关闭生产者：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The producer is created independently on the hot Observable and subscribing/unsubscribing
    to it has no effect on the producer.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者是在热可观察对象上独立创建的，订阅/取消订阅它对生产者没有影响。
- en: You might be wondering how is this all related to comparing `Observable::create()`
    and the `Subject` class?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这一切与比较`Observable::create()`和`Subject`类有什么关系？
- en: The point is that we can't simply do the same with Subjects. We could of course
    use a Subject in this scenario, but than we'd have to handle all subscription
    and unsubscription logic ourselves (including creating/closing the producer).
    Nonetheless, in [Chapter 8](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d
    "Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension"), *Multicasting
    in RxPHP and PHP7 pthreads Extension*, we talked about the internal states in
    Subjects, which is also very relevant here.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是，我们无法简单地用Subject来做同样的事情。当然，我们可以在这种情况下使用Subject，但那时我们就必须自己处理所有订阅和取消订阅的逻辑（包括创建/关闭生产者）。尽管如此，在[第8章](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d
    "第8章。在RxPHP和PHP7 pthreads扩展中的多播")，*在RxPHP和PHP7 pthreads扩展中的多播*中，我们讨论了Subject的内部状态，这在这里也非常相关。
- en: As a rule of thumb, every time you end up using a Subject think whether you
    could achieve the same with `Observable::create()` instead.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，每次你使用Subject时，都要考虑是否可以用`Observable::create()`来实现相同的效果。
- en: Call stack length and EventLoopScheduler
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用栈长度和EventLoopScheduler
- en: When developing PHP applications, it's handy to enable the Xdebug extension
    that we can use to debug our code. However this comes with the cost of reduced
    performance, higher memory usage, and a limited number of possible nested function
    calls.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发PHP应用程序时，启用Xdebug扩展很有用，我们可以用它来调试我们的代码。然而，这会带来性能降低、内存使用增加以及可能嵌套函数调用数量的限制。
- en: 'The last issue is relevant to us in particular. For example, in RxPHP when
    we make a long operator chain and use the `ImmediateScheduler` method. Consider
    the following very long chain of operators:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题与我们特别相关。例如，在RxPHP中，当我们创建一个长的操作符链并使用`ImmediateScheduler`方法时。考虑以下非常长的操作符链：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This example chains nine operators and then in the observer prints the entire
    call stack. We know that the call stack will start at the subscriber's `onNext`
    handler and traverse upwards via `onNext()` calls to the `RangeObservable` where
    it starts emitting values. Then the stack goes back to the bottom via `subscribe()`
    calls.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们链式连接了九个操作符，然后在观察者中打印整个调用栈。我们知道调用栈将从订阅者的`onNext`处理程序开始，通过`onNext()`调用向上遍历到`RangeObservable`，它开始发出值。然后通过`subscribe()`调用将堆栈返回到底部。
- en: 'The shortened output looks as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 缩短的输出如下：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can see that this call stack contains 103 nested function calls. This would
    be obviously hard to debug, so we can reduce its length by using `EventLoopScheduler`
    instead of `defaultImmediateScheduler`. This will make every callback to the `schedule()`
    method run as a separate event by `EventLoopScheduler`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个调用栈包含了103个嵌套函数调用。这显然很难调试，因此我们可以通过使用`EventLoopScheduler`而不是`defaultImmediateScheduler`来缩短其长度。这将使得每个回调到`schedule()`方法的调用都由`EventLoopScheduler`作为一个单独的事件来运行。
- en: 'We''ll set the Scheduler right in the `Observable::range()` call as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`Observable::range()`调用中直接设置调度器，如下所示：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now when we run this example the call stack will contain only 65 nested calls:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们运行这个例子时，调用栈将只包含65个嵌套调用：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This obviously comes with a cost, so using the `EventLoopScheduler` class is
    always going to be slower than using the default `ImmediateScheduler`. Also the
    emissions that are wrapped with `schedule()` are called from the event loop and
    not from the place the `schedule()` method was invoked.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然会带来一些成本，因此使用`EventLoopScheduler`类总是会比使用默认的`ImmediateScheduler`慢。此外，用`schedule()`包装的排放是从事件循环而不是从调用`schedule()`方法的地方调用的。
- en: This can make debugging even harder, but the `EventLoopScheduler` class is especially
    useful when we don't want to block the execution thread and also want to let other
    code be executed (thanks to its event loop). In [Chapter 6](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "Chapter 6. PHP Streams API and Higher-Order Observables"), *PHP Streams API and
    Higher-Order Observables*, we talked about even loops in great detail and how
    it's important not to block the execution thread. In such cases, using `EventLoopScheduler`
    is a very good choice.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会使调试变得更加困难，但`EventLoopScheduler`类在我们不希望阻塞执行线程，同时还想让其他代码被执行（归功于其事件循环）时特别有用。在[第6章](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "第6章。PHP Streams API和高级观察者")中，我们详细讨论了事件循环以及为什么不要阻塞执行线程的重要性。在这种情况下，使用`EventLoopScheduler`是一个非常不错的选择。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using an asynchronous Scheduler is also relevant to RxJS because in a JavaScript
    environment the call stack length is limited.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步调度器对RxJS也很有关系，因为在JavaScript环境中调用栈长度是有限的。
- en: Unsubscribing versus completing an Observable
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消订阅与完成Observable
- en: We know that when we have an observer we'll stop receiving items when the source
    Observable completes or when we manually unsubscribe. However, we haven't talked
    about why we might choose one over the other.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，当我们有一个观察者时，当源Observable完成或当我们手动取消订阅时，我们将停止接收项目。然而，我们还没有讨论为什么我们可能选择其中一个而不是另一个。
- en: 'There''re basically two ways to stop receiving items:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上有两种停止接收项目的方法：
- en: Unsubscribe from the source Observable
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源Observable取消订阅
- en: Using an operator that completes the chain (such as the `takeUntil()` operator)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用完成链的操作符（如`takeUntil()`操作符）
- en: By unsubscribing we usually mean that we don't want to be receiving items any
    more. This obviously doesn't mean that the source Observable stopped sending items
    or sent the complete notification. We're just no longer interested in the items
    coming from the source.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说取消订阅时，通常意味着我们不再希望接收任何项目。这显然并不意味着源可观察对象停止发送项目或发送了完整的通知。我们只是不再对来自源的项目感兴趣。
- en: 'As an important consequence to manually unsubscribing, the complete handler
    is never called. Consider the following example where we unsubscribe after receiving
    a few items:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为手动取消订阅的重要后果，完整的处理程序永远不会被调用。考虑以下示例，我们在收到几个项目后取消订阅：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that we had to use the `EventLoopScheduler` class instead of the default
    one because we need to run the observer callables as separate events in the loop.
    If we used the `ImmediateScheduler` class then the `$subscription` variable would
    always be null because all the callables would be called within the `subscribe()`
    call. In other words, the `$subscription` variable would be unassigned.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须使用 `EventLoopScheduler` 类而不是默认类，因为我们需要在循环中将观察者可调用对象作为单独的事件运行。如果我们使用 `ImmediateScheduler`
    类，那么 `$subscription` 变量将始终为 null，因为所有可调用对象都会在 `subscribe()` 调用中调用。换句话说，`$subscription`
    变量将不会被分配。
- en: 'When we run this demo we can see that it prints the first three items and then
    ends and no complete handler was called:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个演示时，我们可以看到它打印了前三个项目然后结束，并且没有调用完整的处理程序：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'But what if we''re in a situation where the complete handler is important and
    we always want to call it when we unsubscribe? In such cases we can use any operator
    that sends a complete notification, for example, `takeUntil()` and an instance
    of the `Subject` class:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们处于一个完整的处理程序很重要且我们总是希望在取消订阅时调用它的情境中呢？在这种情况下，我们可以使用任何发送完整通知的操作符，例如 `takeUntil()`
    和 `Subject` 类的实例：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We're using the `$subject` variable to notify the `takeUntil()` operator that
    we want to complete and then manually call the `onNext()` method inside a callable
    passed to the `CallbackObserver` class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `$subject` 变量来通知 `takeUntil()` 操作符我们想要完成，然后在传递给 `CallbackObserver` 类的可调用对象内部手动调用
    `onNext()` 方法。
- en: 'This way we ensured that apart from just unsubscribing the observer, we''ll
    also call the complete handler, as we can see from the console output:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们确保了，除了取消观察者的订阅外，我们还会调用完整的处理程序，正如我们从控制台输出中可以看到的那样：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Whether we want to simply unsubscribe or send the complete notification is up
    to us. A big advantage of using a `Subject` class and the `takeUntil()` operator
    is that we can easily complete multiple chains by using a single `onNext()` call.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是想简单地取消订阅还是发送完整的通知，这取决于我们。使用 `Subject` 类和 `takeUntil()` 操作符的一个大优点是，我们可以通过使用单个
    `onNext()` 调用来轻松完成多个链。
- en: If we wanted to just unsubscribe multiple chains, then we'd have to collect
    and keep all their disposables and then call `dispose()` on all of them manually.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想取消多个链的订阅，那么我们就必须收集并保留它们的所有可处置对象，然后手动在它们上面调用 `dispose()`。
- en: Anonymous operators
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名操作符
- en: We've been using the `lift()` method to use custom operators in Observable chains
    a lot. In RxPHP v1, it's also the only way to implement custom operators. This
    method takes as a parameter the so called **operator factory**, which is a callable
    that returns an instance of the operator we want to use. This method is called
    every time we subscribe, so it might be called just once in total.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在大量使用 `lift()` 方法在可观察对象链中使用自定义操作符。在 RxPHP v1 中，这也是实现自定义操作符的唯一方式。该方法接受所谓的
    **操作符工厂** 作为参数，这是一个返回我们想要使用的操作符实例的可调用对象。该方法在每次订阅时都会被调用，所以它总共可能只被调用一次。
- en: When using operators, we're making use of PHP's magic `__invoke()` method that
    allows us to use any object just as if it were a function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用操作符时，我们利用了 PHP 的魔法 `__invoke()` 方法，它允许我们像使用函数一样使用任何对象。
- en: 'Let''s consider this simple example that shows the `__invoke()` method:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的示例，它展示了 `__invoke()` 方法：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We make an instance of `MyClass` that we used as if it was a regular function
    with `$obj(3,4)`. If we run this example, we''ll get the correct result:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 `MyClass` 的实例，我们像使用常规函数一样使用 `$obj(3,4)`。如果我们运行这个示例，我们会得到正确的结果：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Operators in RxPHP use the same principle. In fact the `lift()` method is deep
    inside the `Observable` class, defined as the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: RxPHP 中的操作符使用相同的原理。实际上，`lift()` 方法深深嵌套在 `Observable` 类中，定义如下：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The callable `$operatorFactory` doesn't need to return an operator object at
    all. It can just return another callable that'll take three arguments and do whatever
    it wants to. This is useful when we want to do a one-time operation where it doesn't
    make sense to make it reusable and write a custom operator for it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 可调用`$operatorFactory`根本不需要返回一个操作符对象。它可以只返回另一个可调用，该可调用将接受三个参数并执行它想要的任何操作。这在我们需要执行一次性的操作，使其不可重用且不需要编写自定义操作符时非常有用。
- en: 'For example, we can make the same operations on the source Observable and the
    observer just like in any other operator class:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以像在其他操作符类中一样对源Observable和观察者执行相同的操作：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that we have a `$prevValue` variable that is kept in this context, and
    we can use it among all invocations of the `onNext` signals.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们有一个在上下文中保持的`$prevValue`变量，我们可以在所有`onNext`信号的调用中使用它。
- en: Writing a custom DirectoryIteratorObservable
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义的DirectoryIteratorObservable
- en: In the previous chapter, we used a couple of `DirectoryIterators` to recursively
    get all files in a directory and all its subdirectories. When iterating files,
    we might want to filter not only by filenames, but also by file size or access
    restrictions. Ideally, we could have a custom Observable that just checks the
    files names to match a certain pattern and then emits `SplFileInfo` objects so
    we can implement our filtering logic ourselves.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了一些`DirectoryIterators`来递归地获取目录及其所有子目录中的所有文件。在迭代文件时，我们可能不仅想要根据文件名过滤，还想要根据文件大小或访问限制过滤。理想情况下，我们可以有一个自定义的Observable，它只检查文件名是否匹配某个模式，然后发出`SplFileInfo`对象，这样我们就可以自己实现过滤逻辑。
- en: 'For this purpose, we''ll write our own `DirectoryIteratorObservable` that does
    all this and has some extra options on top of that. We can split the implementation
    into two smaller chunks:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将编写我们自己的`DirectoryIteratorObservable`，它执行所有这些操作，并且还有一些额外的选项。我们可以将实现拆分为两个更小的部分：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We're still using `RecursiveIteratorIterator` internally; however, we have full
    control over it and won't let other developers fiddle with it. Somebody could,
    for instance, use `rewind()` or `seek()` methods and unintentionally move the
    inner pointer, not to mention that using three different iterators to traverse
    a directory structure is a little too much and not easily reusable.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然在内部使用`RecursiveIteratorIterator`；然而，我们完全控制它，不会让其他开发者随意操作它。例如，有人可能会使用`rewind()`或`seek()`方法，无意中移动内部指针，更不用说使用三个不同的迭代器遍历目录结构有点过于复杂，且不易重用。
- en: That's why our Observable hides all this from the user and has just a couple
    of input parameters. We definitely want to be able to set a pattern to filter
    files right away. Sometimes we might want to traverse several directories recursively
    and other times just a single directory, so we'll have a separate parameter for
    this. The last behavior we want to be able to modify is what this operator is
    going to emit. By default, it's the `SplFileInfo` object, but if we set a custom
    selector function we can emit, for example, just the file names.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们的Observable隐藏了所有这些内容，并且只有几个输入参数。我们绝对希望能够立即设置一个模式来过滤文件。有时我们可能想要递归遍历多个目录，有时则只遍历单个目录，因此我们将为此设置一个单独的参数。我们想要能够修改的最后一种行为是这个操作符将要发出什么。默认情况下，它是`SplFileInfo`对象，但如果我们设置一个自定义的选择器函数，我们可以发出，例如，仅文件名。
- en: 'The main logic is in the `subscribe()` method, which is built around a `scheduleRecursive()`
    method from the `Scheduler` class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 主要逻辑在`subscribe()`方法中，该方法围绕`Scheduler`类中的`scheduleRecursive()`方法构建：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that in RxPHP v2 the `subscribe()` method doesn't take the `Scheduler`
    as a parameter. This means that we'd access the `Scheduler` class directly with
    the `Scheduler::getImmediate()` static method instead.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在RxPHP v2中，`subscribe()`方法不接收`Scheduler`作为参数。这意味着我们将直接使用`Scheduler::getImmediate()`静态方法来直接访问`Scheduler`类。
- en: We're looping over all values produced by the iterator and emitting them until
    we reach the end, where we emit just the complete signal. Note that we're wrapping
    the call to the selector function, so if it throws an exception we'll emit it
    as an `error` signal.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在遍历迭代器产生的所有值，直到我们到达末尾，在那里我们只发出完整的信号。注意，我们正在包装对选择器函数的调用，所以如果它抛出异常，我们将将其作为`error`信号发出。
- en: 'We can test this Observable on the same directory structure from the Symfony3
    template, as we did in the previous chapter:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在与上一章相同的目录结构上测试这个Observable，就像我们之前做的那样：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will print a very long list of file names (when `SplFileInfo` objects are
    type-casted to strings they return only filenames).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印一个非常长的文件名列表（当 `SplFileInfo` 对象被类型转换为字符串时，它们只返回文件名）。
- en: Note that, internally, this Observable works similarly to, for example, `RangeObservable`.
    In fact, it doesn't keep an array of observers and instead immediately emits all
    values to the observer that subscribed (we also move the iterator's inner pointer
    to the start with `rewind()`). The consequences are obvious.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在内部，这个可观察对象的工作方式与例如 `RangeObservable` 类似。实际上，它不保留观察者数组，而是立即向订阅了它的观察者发出所有值（我们也会使用
    `rewind()` 将迭代器的内部指针移动到开始位置）。后果是显而易见的。
- en: If we subscribe twice to this Observable, it'll loop the entire iterable twice
    as well.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们两次订阅这个可观察对象，它也会将整个可迭代对象循环两次。
- en: DirectoryIteratorSharedObservable
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DirectoryIteratorSharedObservable
- en: 'So this looks like a good use-case for multicasting. Of course, we could append
    the `publish()` operator every time we use `DirectoryIteratorObservable`, but
    this would be error prone as we could easily forget to use it. Instead, we can
    make another Observable that wraps `DirectoryIteratorObservable`, and appends
    the `publish()` operator to it every time:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这看起来是一个多播的良好用例。当然，我们可以在每次使用 `DirectoryIteratorObservable` 时附加 `publish()`
    操作符，但这很容易出错，因为我们很容易忘记使用它。相反，我们可以创建另一个包装 `DirectoryIteratorObservable` 的可观察对象，并在每次都附加
    `publish()` 操作符：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This Observable is just a wrapper around the original `DirectoryIteratorObservable`,
    which is internally instantiated and then chained with `publish()`. We're purposely
    using `publish()` and not `share()`. The `share()`operator also appends the `refCount()`
    operator, which automatically subscribes/unsubscribes based on the number of observers.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可观察对象只是原始 `DirectoryIteratorObservable` 的包装，它内部实例化，然后与 `publish()` 链接。我们故意使用
    `publish()` 而不是 `share()`。`share()` 操作符也会附加 `refCount()` 操作符，它根据观察者的数量自动订阅/取消订阅。
- en: This is useful with Observables that need to perform some asynchronous operation,
    such as downloading data (our `CURLObservable`) or running code in parallel (our
    `ThreadPoolOperator`). With Observables that emit all their values immediately
    on subscription, such as `RangeObservable` or our fresh `DirectoryIteratorObservable`,
    it wouldn't work as we expect. All values would be emitted to the first observer
    because of the immediate call to the `connect()` method inside the `refCount()`
    operator.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于需要执行一些异步操作的可观察对象很有用，例如下载数据（我们的 `CURLObservable`）或并行运行代码（我们的 `ThreadPoolOperator`）。对于在订阅时立即发出所有值的可观察对象，如
    `RangeObservable` 或我们新的 `DirectoryIteratorObservable`，它不会像我们预期的那样工作。所有值都会因为 `refCount()`
    操作符内部对 `connect()` 方法的立即调用而发送给第一个观察者。
- en: 'Now we can test this operator by subscribing multiple observers and then calling
    the `connect()` method:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过订阅多个观察者并调用 `connect()` 方法来测试这个操作符：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output for this demo will be a list of file names where each of the observers
    will receive a single item at a time from the current directory:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示的输出将是一个文件名列表，每个观察者将一次接收到当前目录中的一个项目：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We avoided reemitting the same directory structure for each observer and multicasted
    items from the source with the `public()` operator and manually called the `connect()`
    method.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们避免了为每个观察者重新发出相同的目录结构，并使用 `public()` 操作符从源多播项目，并手动调用 `connect()` 方法。
- en: FTP client with RxPHP
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RxPHP 的 FTP 客户端
- en: For this example, let's imagine that we're running an FTP server where we want
    to perform a couple of operations. PHP has built-in support for FTP connections,
    so we don't need to install any extra libraries.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，让我们假设我们正在运行一个 FTP 服务器，我们想在服务器上执行一些操作。PHP 内置了对 FTP 连接的支持，因此我们不需要安装任何额外的库。
- en: Our goal is to be able to do some basic operations with an FTP connection while
    utilizing what we know from RxPHP. When working with Observables, most of the
    time we've been using them in operator chains, but Observables can be used as
    asynchronous inputs or outputs as well. When returning a value from an asynchronous
    function, we'd usually use a Promise, but the same principles work with Observables
    too, and we can also benefit from chaining them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是能够在使用 RxPHP 的同时，对 FTP 连接执行一些基本操作。当与可观察对象一起工作时，我们大多数时候都是将它们用在操作符链中，但可观察对象也可以用作异步输入或输出。当从异步函数返回一个值时，我们通常会使用
    Promise，但与可观察对象一起，同样的原则也适用，我们还可以从链式操作中受益。
- en: Note that all FTP calls in PHP are blocking. Some functions have their non-blocking
    variants, such as functions to upload or download files, but others, such as functions
    that change or list a directory, are always blocking. For this reason, we'll stay
    only with their blocking variants. This way we can handle their correct and error
    states with Observables. This is also going to be a nice example where we can
    use multicasting.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，PHP中的所有FTP调用都是阻塞的。一些函数有它们的非阻塞变体，例如上传或下载文件的函数，但其他函数，例如更改或列出目录的函数，总是阻塞的。因此，我们将只使用它们的阻塞变体。这样我们可以用可观察对象处理它们的正确和错误状态。这还将是一个很好的例子，我们可以在这里使用多播。
- en: So this is going to be an example of how to use RxPHP in a synchronous and blocking
    application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这将是一个如何在同步和阻塞应用程序中使用RxPHP的例子。
- en: 'We''ll split our first `FTPClient` class into two smaller chunks and see how
    we can implement RxPHP in this use-case:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的第一个`FTPClient`类分成两个更小的部分，看看我们如何在这个用例中实现RxPHP：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These are the most basic methods we need. Many FTP functions in PHP return just
    true or false based on whether they succeeded or not. We used this in the constructor
    to throw exceptions if any of these cases fail.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要的最基本的方法。PHP中的许多FTP函数只是根据它们是否成功返回true或false。我们在构造函数中使用了这个方法，如果这些情况中的任何一个失败，就会抛出异常。
- en: Then there's the first method that returns an Observable. When we want to get
    a list of all the files and directories in a directory, we'll call the `listFiles()`
    method. This method returns an Observable from the array of files it received.
    As we said, FTP functions in PHP are blocking, so we're not calling `ftp_nlist()`
    asynchronously and need to wait until it finishes. The fact that we're returning
    an Observable means that we can feed this Observable into another method in this
    `FTPClient` class that takes an Observable as an argument.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是第一个返回一个可观察对象（Observable）的方法。当我们想要获取一个目录中所有文件和目录的列表时，我们会调用`listFiles()`方法。这个方法从它接收到的文件数组中返回一个可观察对象。正如我们所说的，FTP在PHP中是阻塞的，所以我们不会异步调用`ftp_nlist()`，需要等待它完成。我们返回一个可观察对象的事实意味着我们可以将这个可观察对象喂给这个`FTPClient`类中的另一个方法，该方法接受一个可观察对象作为参数。
- en: We're purposely using `Observable::defer` in order to postpone the actual network
    request until we subscribe to it. We'll see why this is important when we start
    writing a test application for `FTPClient`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意使用`Observable::defer`来推迟实际的网络请求，直到我们订阅它。当我们开始为`FTPClient`编写测试应用程序时，我们会看到为什么这很重要。
- en: 'We can now have a look at three more methods that''ll get the file size, download
    files from the FTP server, or upload files to the server:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看另外三个方法，它们将获取文件大小，从FTP服务器下载文件，或将文件上传到服务器：
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The last two methods are very similar in principle. They both take an Observable as
    an argument and subscribe to it. Then they create an internal Subject that is
    used to emit successful uploads/downloads and errors. The same Subject is then
    turned into an Observable with an `asObservable()` operator and returned.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个方法在原则上非常相似。它们都接受一个可观察对象作为参数并订阅它。然后它们创建一个内部Subject，用于发出成功的上传/下载和错误。然后，使用`asObservable()`运算符将相同的Subject转换为可观察对象并返回。
- en: What's interesting with this approach is that we don't need to know which files
    we want to download/upload in advance. In other words, we can call these methods
    with instances of Subject and just carry on executing our code. Then, sometime
    later, we can start pushing items to these Subjects, which will cause the files
    to be downloaded/uploaded. We'll see this in a moment.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的有趣之处在于，我们不需要提前知道我们想要下载/上传哪些文件。换句话说，我们可以用Subject的实例调用这些方法，然后继续执行我们的代码。然后，在稍后的某个时候，我们可以开始向这些Subject中推送项目，这将导致文件被下载/上传。我们稍后会看到这一点。
- en: We also implemented the `size()` method that takes as an argument an Observable
    and subscribes to it. This method is internally implemented with `Observable::create()`
    for the same reason as `listDir()`. We want to defer emitting any values until
    there's at least one subscription.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还实现了`size()`方法，它接受一个可观察对象作为参数并订阅它。这个方法内部使用`Observable::create()`实现，原因与`listDir()`相同。我们想要延迟发出任何值，直到至少有一个订阅。
- en: 'Now we can start using this class in a simple demo application that''ll first
    just connect to an FTP server, list all files and directories, and then try to
    change the current directory to the last one in the list:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在一个简单的演示应用程序中使用这个类，首先连接到FTP服务器，列出所有文件和目录，然后尝试将当前目录更改为列表中的最后一个：
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We're using `listDir()` to get the content of the current directory, which is
    the root directory for this user. Then we take just the last item and try to go
    inside that directory. We used the `ftp_nlist()` function internally in `listDir()`
    where it returns all files and directories together, so how do we know that the
    last item in the list is really a directory and not a file?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`listDir()`来获取当前目录的内容，这是此用户的根目录。然后我们只取最后一个项目并尝试进入该目录。在`listDir()`内部，我们使用了`ftp_nlist()`函数，它返回所有文件和目录，因此我们如何知道列表中的最后一个项目真的是目录而不是文件？
- en: 'If it was a file, then the call to `chdir()` would throw an exception. A simple
    way to distinguish files from directories is by checking their size. Directories
    always have a size of `-1`, while ordinary files have a real size that is always
    greater or equal to `0`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个文件，那么对`chdir()`的调用将抛出异常。区分文件和目录的一个简单方法是通过检查它们的大小。目录始终具有大小`-1`，而普通文件具有始终大于或等于`0`的实际大小：
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This demonstrates very well what we talked about. We have a Subject that we
    pass as an argument to the `size()` method. This method is not going to subscribe
    to it until its own chain has an observer, which happens on the last line with
    `DebugSubject`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好地展示了我们之前讨论的内容。我们有一个Subject对象，将其作为参数传递给`size()`方法。这个方法不会订阅它，直到它自己的链有一个观察者，这在最后一行通过`DebugSubject`实现。
- en: We're still not calling any `ftp_size()` because the `Subject` class in the
    `$getFileSizesSubject` variable hasn't emitted any items yet. This happens when
    we call `listDir()`, which itself first calls `ftp_nlist()` to get a list of all
    files and directories and then starts emitting items to the `Subject` class, which
    then simply takes the item and re-emits it to its own observer, which is the callable
    inside the `size()` method.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然没有调用任何`ftp_size()`，因为`$getFileSizesSubject`变量中的`Subject`类还没有发射任何项目。这发生在我们调用`listDir()`时，它首先调用`ftp_nlist()`来获取所有文件和目录的列表，然后开始向`Subject`类发射项目，该类只是简单地取项目并将其重新发射给它的观察者，即`size()`方法内部的调用者。
- en: Since `size()` is based on `Observable::create()` and `subscribe()` methods,
    it doesn't make any network calls until we start sending it items. This might
    happen any time after we called it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`size()`方法基于`Observable::create()`和`subscribe()`方法，它在我们开始发送项目之前不会进行任何网络调用。这可能在调用它之后的任何时候发生。
- en: This all might look a little confusing, but all we're doing is just passing
    items between a couple of Observables.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切可能看起来有点令人困惑，但我们所做的只是将项目在几个Observables之间传递。
- en: Another obvious use-case could be listing only files in a directory and then
    downloading all of them. We have two methods that require an Observable as a source
    of files. With `size()` they will be checked for their file size (to see whether
    they're files at all) and for `download()` to download them. Of course, we don't
    want to make two separate calls for each of these methods, so we'll use the output
    from the Observable with only files (that is, the `$fileSizes` variable) as the
    source Observable for the `download()` method.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个明显的用例可能是只列出目录中的文件，然后下载所有这些文件。我们有两个需要文件Observables作为源的方法。使用`size()`，它们将检查文件大小（以查看它们是否真的是文件）和`download()`来下载它们。当然，我们不希望为每个这些方法都进行两次单独的调用，所以我们将使用只包含文件的Observable的输出（即`$fileSizes`变量）作为`download()`方法的源Observable。
- en: 'In order to make this example a little more complicated, we''ll assume that
    we want to use the list of files once more and, for example, just print the file
    names and their sizes:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个例子稍微复杂一些，我们假设我们想要再次使用文件列表，例如，只打印文件名和它们的大小：
- en: '[PRE51]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the `$filesToDownload` variable, we're storing a predefined chain of operators
    that emits only file names coming from `$fileSizes`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在`$filesToDownload`变量中，我们存储了一个预定义的操作符链，它只发射来自`$fileSizes`的文件名。
- en: 'If we run this demo application, we''ll get the following output (depending
    on the FTP server we are connected to):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个演示应用程序，我们将得到以下输出（取决于我们连接到的FTP服务器）：
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We can see that both Observables based on emissions from `$fileSizes` are sharing
    the same connection (the `doOnNext()` operator is called just once for each item).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，基于`$fileSizes`发射的这两个Observables正在共享相同的连接（对于每个项目，`doOnNext()`操作符只被调用一次）。
- en: 'We could also create methods listing only files or only directories. This could
    look like the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以创建只列出文件或只列出目录的方法。这可以看起来像以下这样：
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: These both use the same principle as postponing subscriptions, as we explained
    previously.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者都使用了我们之前解释的延迟订阅的相同原则。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered a couple of slightly unusual examples that are possible
    with RxPHP, and which didn't fit into any of the previous chapters. These aren't
    things that we use on a daily basis, but it's good to know that features such
    as these are possible.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些稍微不寻常的例子，这些例子是RxPHP可能实现的，但它们并不适合之前的任何章节。这些并不是我们日常使用的东西，但了解这些功能是可能的。
- en: In particular, we went through the operators `zip()`, `window()`, `materialize()`,
    and `dematerialize()`. We saw how to propagate and handle errors in Observable
    chains and what role `AutoDetachObserver` has. Also, we compared the `Observable::create()`
    static method and the `Subject` class and when unsubscribing and completing an
    Observable chain. Apart from this, we created anonymous operators and wrote the
    `DirectoryIteratorObservable` class that recursively iterates a directory structure.
    Finally, we used RxPHP to make a simple FTP client that uses Observables for inputs
    and outputs.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们在`zip()`、`window()`、`materialize()`和`dematerialize()`操作符上进行了操作。我们看到了如何在Observable链中传播和处理错误，以及`AutoDetachObserver`的作用。此外，我们还比较了`Observable::create()`静态方法和`Subject`类，以及取消订阅和完成Observable链的情况。除此之外，我们还创建了匿名操作符，并编写了`DirectoryIteratorObservable`类，该类递归地迭代目录结构。最后，我们使用RxPHP创建了一个简单的FTP客户端，该客户端使用Observables进行输入和输出。
- en: In the last chapter, we're going to talk about implementations of Reactive Extension
    in languages other than PHP. Most notably, we'll have a look at RxJS-what it is,
    how it's related to RxPHP, and what differences we can encounter in a JavaScript
    environment from PHP.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们将讨论除PHP之外的语言中Reactive Extension的实现。最值得注意的是，我们将查看RxJS——它是什么，它与RxPHP的关系，以及我们可能在JavaScript环境中遇到的不同之处。
- en: Chapter Appendix.  Reusing RxPHP Techniques in RxJS
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节附录。在RxJS中重用RxPHP技术
- en: Throughout this entire book, we've mentioned very often that certain functionality
    (such as operators or certain Observables) work differently in RxPHP and RxJS.
    Some operators from RxJS aren't even available in RxPHP yet. There're also features
    of RxJS that aren't even possible to make in RxPHP because of the nature of PHP
    interpreter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们经常提到某些功能（如操作符或某些Observables）在RxPHP和RxJS中的工作方式不同。RxJS中的一些操作符甚至还没有在RxPHP中提供。还有RxJS的特性，由于PHP解释器的性质，甚至无法在RxPHP中实现。
- en: We've referred to RxJS a lot even though Reactive Extensions were first developed
    for .NET as Rx.NET.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Reactive Extensions最初是为.NET开发的Rx.NET，但我们已经大量提到了RxJS。
- en: In this chapter, we're going to focus on the differences between current RxPHP
    and RxJS. Also, the knowledge of RxJS is very useful today because its popularity
    is still rising thanks to JavaScript frameworks such as Angular 2 that heavily
    rely on RxJS.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注当前RxPHP和RxJS之间的差异。此外，RxJS的知识在今天是很有用的，因为它的受欢迎程度仍在上升，这得益于像Angular 2这样的JavaScript框架，这些框架严重依赖于RxJS。
- en: 'Topics covered in this chapter are going to be a little unusual because these
    will combine PHP and JavaScript (ECMAScript 6 - ES6, in particular):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及的主题将有些不寻常，因为这些将结合PHP和JavaScript（特别是ECMAScript 6 - ES6）：
- en: We'll see what RxJS is, and we'll talk about where it stands in today's world
    of JavaScript
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将了解RxJS是什么，以及它在当今JavaScript世界中的地位。
- en: We'll write a few very simple demos of RxJS, introducing us to synchronous and
    asynchronous code in JavaScript
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将编写几个非常简单的RxJS演示，介绍JavaScript中的同步和异步代码。
- en: We'll talk about asynchronous events in JavaScript and how we can benefit from
    them in RxJS
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将讨论JavaScript中的异步事件以及我们如何在RxJS中从中受益。
- en: We'll see how and why higher order Observables behave differently in RxJS and
    RxPHP
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将了解为什么和如何在RxJS和RxPHP中高阶Observables表现不同。
- en: We'll talk about operators that aren't available in RxPHP right now but are
    fully functional in RxJS
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将讨论RxPHP目前不可用但在RxJS中完全功能的操作符。
- en: We expect you to know at least the basics of JavaScript and ideally the new
    ES6 standard (aka ES2015) as well. This isn't required of course since RxJS can
    be used with plain old JavaScript (ES5.1 to be precise), but it's very relevant
    to RxJS and its development process.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望你至少了解JavaScript的基础知识，理想情况下还了解新的ES6标准（也称为ES2015）。当然，这不是必需的，因为RxJS可以使用纯旧JavaScript（确切地说，是ES5.1），但它与RxJS及其开发过程非常相关。
- en: Also, ES6 is already very well supported by Node.js, so we don't have any reason
    not to use it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ES6已经被Node.js很好地支持，所以我们没有理由不使用它。
- en: Don't worry if you can't get your head around the new ES6 syntax that we'll
    use in this chapter. If you want to know more about ES6, you can have a look at
    a quick summary of the new functionalities it provides at [https://github.com/lukehoban/es6features](https://github.com/lukehoban/es6features)
    .
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对本章中我们将使用的新的ES6语法感到困惑，请不要担心。如果你想了解更多关于ES6的信息，你可以查看它提供的功能快速总结，链接为[https://github.com/lukehoban/es6features](https://github.com/lukehoban/es6features)。
- en: We're going to run all examples in this chapter by Node.js runtime ( [https://nodejs.org](https://nodejs.org)
    ). If you're not familiar with Node.js, it's basically an environment that uses
    Chrome's V8 JavaScript engine and lets us run JavaScript code from a console.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Node.js运行时（[https://nodejs.org](https://nodejs.org)）运行本章中的所有示例。如果你不熟悉Node.js，它基本上是一个使用Chrome的V8
    JavaScript引擎的环境，允许我们在控制台中运行JavaScript代码。
- en: What is RxJS?
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，RxJS是什么？
- en: Very simply, RxJS is an implementation of Reactive Extensions in JavaScript.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，RxJS是JavaScript中Reactive Extensions的实现。
- en: Now, get ready to get super confused.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，准备好陷入极度困惑吧。
- en: 'Until December 2016, there were two major implementations of RxJS:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 直到2016年12月，RxJS有两大主要实现：
- en: '**RxJS 4**: This is the older implementation most people are familiar with.
    Its source code is available at [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)
    , and it''s written in JavaScript (ES5). As we said at the beginning of this chapter,
    RxPHP refers at this moment mostly to this older RxJS 4 version that''ll become
    obsolete in the near future.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RxJS 4**：这是大多数人熟悉的老版本实现。它的源代码可在[https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)找到，并且是用JavaScript（ES5）编写的。正如我们在本章开头所说，RxPHP目前主要指的是即将过时的这个老版本的RxJS
    4。'
- en: '**RxJS 5**: The newer and completely rewritten RxJS that will replace the older
    RxJS 4\. Its source code is available at [https://github.com/ReactiveX/rxjs](https://github.com/ReactiveX/rxjs)
    , and it''s completely written in TypeScript 2.0.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RxJS 5**：这是更新且完全重写的RxJS，将取代旧的RxJS 4。它的源代码可在[https://github.com/ReactiveX/rxjs](https://github.com/ReactiveX/rxjs)找到，并且完全使用TypeScript
    2.0编写。'
- en: 'Because we''ve mentioned yet another programming language called TypeScript,
    we should quickly look at what JavaScript versions are actually out there and
    where (and also if) we can use them:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们提到了另一种名为TypeScript的编程语言，我们应该快速了解一下目前实际存在的JavaScript版本，以及我们可以在哪里（以及是否）使用它们：
- en: '**ES5.1**: The good old JavaScript that probably everybody has encountered
    at some point.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ES5.1**：这是每个人都可能在某一点上遇到的老式JavaScript。'
- en: '**ES6** (also named **ES2015**): This is the newer standard of JavaScript.
    It''s backward compatible with ES5.1, and it brings features such as classes,
    generators, arrow functions, and the `let` keyword to create block scoped variables.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ES6**（也称为**ES2015**）：这是JavaScript的新标准。它与ES5.1向后兼容，并引入了诸如类、生成器、箭头函数以及`let`关键字来创建块作用域变量等功能。'
- en: '**ES7** (**ES2016**): This is the even newer standard of JavaScript that brings
    in yet more features such as the `async`/`await` keyword to avoid creating callback
    hells.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ES7**（**ES2016**）：这是JavaScript的更新标准，它带来了更多功能，例如`async`/`await`关键字，以避免创建回调地狱。'
- en: '**TypeScript**: This is a superset of ES6 specification supplemented with type
    checking and is in the latest versions, also with features from ES7 such as the
    `async`/`await` keyword.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypeScript**：这是ES6规范的超集，增加了类型检查，并且在最新版本中，还包含了ES7的功能，如`async`/`await`关键字。'
- en: So TypeScript was the language of choice for RxJS 5 because of its compatibility
    with ES6 and type checking that helps prevent a lot of bugs in compile time.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，TypeScript是RxJS 5的首选语言，因为它与ES6的兼容性以及有助于在编译时预防许多错误的类型检查。
- en: 'Well, while speaking of compiling, we should probably mention where we can
    actually run any of these new and fancy languages:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在谈论编译的时候，我们可能应该提到我们实际上可以在哪里运行这些新潮的语言：
- en: ES5.1 is supported by every current browser including mobile browsers and Node.js.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES5.1被所有当前浏览器包括移动浏览器和Node.js支持。
- en: 'ES6 can already be used with the two major JavaScript engines: Chrome''s V8
    and SpiderMonkey (used by FireFox). Although current compatibility with ES6 is
    pretty good (as we can see at [http://kangax.github.io/compat-table/es6/](http://kangax.github.io/compat-table/es6/)
    ), it''s still not possible to rely only on ES6 for browser-based applications.
    We obviously need to also support older browsers and mobile devices. For this
    reason, any code written in ES6 needs to be compiled to ES5 using a compiler such
    as babel ( [https://babeljs.io/](https://babeljs.io/) ) or traceur ( [https://github.com/google/traceur-compiler](https://github.com/google/traceur-compiler)
    ). This doesn''t apply to Node.js where we can freely use ES6 since Node.js v4
    is already pretty old, and the penetration of different Node.js versions isn''t
    such a problem like those we''re used to from web browsers (there''s one important
    exception with ES6 module imports that we''ll mention later).'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES6 已经可以在两个主要的 JavaScript 引擎中使用：Chrome 的 V8 和 SpiderMonkey（Firefox 所使用）。尽管当前与
    ES6 的兼容性相当好（如我们可以在 [http://kangax.github.io/compat-table/es6/](http://kangax.github.io/compat-table/es6/)
    上看到），但仍然不能仅依靠 ES6 来开发基于浏览器的应用程序。显然，我们还需要支持旧版浏览器和移动设备。因此，任何用 ES6 编写的代码都需要使用编译器（如
    babel [https://babeljs.io/](https://babeljs.io/)）或 traceur [https://github.com/google/traceur-compiler](https://github.com/google/traceur-compiler)）编译成
    ES5。这并不适用于 Node.js，因为在 Node.js v4 已经相当老旧的情况下，我们可以自由地使用 ES6，而且不同 Node.js 版本的渗透率并不是像我们从网络浏览器所习惯的那样成为一个问题（有一个重要的例外，即
    ES6 模块导入，我们稍后会提到）。
- en: ES7 brings some features that are already implemented natively in JavaScript
    engines (see [http://kangax.github.io/compat-table/es2016plus/](http://kangax.github.io/compat-table/es2016plus/)
    ); however, this is still music of the future. We're not going to use ES7 features
    in Node.js in this chapter, to avoid compiling our code from ES7 to ES6.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES7 带来了一些已经在 JavaScript 引擎中本地实现的特性（见 [http://kangax.github.io/compat-table/es2016plus/](http://kangax.github.io/compat-table/es2016plus/)）；然而，这仍然是未来的音乐。我们不会在本章中使用
    ES7 特性，以避免将我们的代码从 ES7 编译到 ES6。
- en: TypeScript is a relatively new language made by Microsoft and the community
    around it. It's not going to be natively supported by any JavaScript engines.
    It uses different syntax and new keywords that aren't compatible with either ES6
    or ES7\. This means that TypeScript code always needs to be compiled to ES6 or
    more commonly to ES5.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 是由微软及其社区开发的一种相对较新的语言。它不会被任何 JavaScript 引擎原生支持。它使用不同的语法和新关键字，这些关键字与
    ES6 或 ES7 都不兼容。这意味着 TypeScript 代码始终需要编译成 ES6，更常见的是编译成 ES5。
- en: On the other hand, it's important to note that TypeScript is a superset of ES6\.
    This means that any ES5 or ES6 code is also a valid TypeScript code that makes
    reusing already existing JavaScript very easy.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，值得注意的是，TypeScript 是 ES6 的超集。这意味着任何 ES5 或 ES6 代码都是有效的 TypeScript 代码，这使得重用现有的
    JavaScript 变得非常容易。
- en: This is in contrast to other languages that can be compiled to ES5, such as
    Dart made by Google. Dart isn't compatible with JavaScript at all, and basically,
    all code needs to be rewritten to Dart. This might be one of the reasons why TypeScript
    is so popular today despite the fact that it came later than Dart.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他可以编译成 ES5 的语言形成对比，例如由 Google 制作的 Dart。Dart 完全不兼容 JavaScript，基本上，所有代码都需要重写为
    Dart。这可能是 TypeScript 今天如此受欢迎的原因之一，尽管它比 Dart 晚推出。
- en: So for this chapter, we're going to use Node.js (ideally, v6.9+, but basically,
    any v4+ should be fine) and ES6.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于本章，我们将使用 Node.js（理想情况下，v6.9+，但基本上，任何 v4+ 都应该没问题）和 ES6。
- en: JavaScript module systems
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 模块系统
- en: To add to the confusion when talking about current JavaScript standards, we
    should also mention different module systems used today to define dependencies
    between JavaScript files.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论当前的 JavaScript 标准时，我们还应该提到今天用于定义 JavaScript 文件之间依赖关系的不同模块系统。
- en: Working with JavaScript was always tedious because there was never any unified
    way to split code into multiple files and load it on demand or even to bundle
    it.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JavaScript 总是令人烦恼，因为没有统一的方式来将代码分割成多个文件，按需加载，甚至打包。
- en: 'So now we have nice ES6 syntax for ES6 modules available, let''s consider the
    following code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了用于 ES6 模块的漂亮的 ES6 语法，让我们考虑以下代码：
- en: '[PRE54]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Can you tell in what environment we can run this code natively today?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你能告诉我们今天在什么环境中可以原生运行这段代码吗？
- en: This was a trick question. We can't run it anywhere because no JavaScript engine
    supports ES6 modules yet, not even Node.js.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个陷阱问题。我们无法在任何地方运行它，因为目前没有任何 JavaScript 引擎支持 ES6 模块，甚至 Node.js 也不支持。
- en: Note
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to know more about why implementing ES6 modules into Node.js is
    so complicated, read this article by one of the Node.js developers at [https://hackernoon.com/node-js-tc-39-and-modules-a1118aecf95e](https://hackernoon.com/node-js-tc-39-and-modules-a1118aecf95e)
    .
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于为什么将ES6模块实现到Node.js中如此复杂的原因，请阅读Node.js开发者之一在[https://hackernoon.com/node-js-tc-39-and-modules-a1118aecf95e](https://hackernoon.com/node-js-tc-39-and-modules-a1118aecf95e)
    发表的文章。
- en: Node.js at this moment supports only using the `require()` function to load
    modules in the CommonJS format (in fact, it's not exactly the CommonJS format;
    it's just very close to it). The `require()` function is natively available only
    in Node.js. If we wanted to use `require()` also in the browser, we'd need a polyfill
    or a bundler to merge multiple JavaScript files linked via `require()` calls into
    a single bundle.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 目前Node.js仅支持使用`require()`函数以CommonJS格式（实际上，它并不完全符合CommonJS格式；它只是非常接近）加载模块。`require()`函数仅在Node.js中本地可用。如果我们想在浏览器中使用`require()`，我们需要一个polyfill或打包器来将多个通过`require()`调用的JavaScript文件合并成一个单一包。
- en: If we really wanted to use ES6 module definitions right now, this would be another
    reason we'd have to compile our code. Note that we could actually compile ES6
    code into another ES6 code, only to transform ES6 imports to one of the current
    module formats, such as UMD, CommonJS, AMD, SystemJS, or globals.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的想现在就使用ES6模块定义，这将是我们必须编译代码的另一个原因。请注意，我们实际上可以将ES6代码编译成另一种ES6代码，只是为了将ES6导入转换成当前的模块格式之一，如UMD、CommonJS、AMD、SystemJS或全局变量。
- en: This has been resolved by various bundling tools, such as Browserify, webpack,
    SystemJS-Builder, or rollup.js. However, this just added yet another layer of
    complexity. Moreover, these tools just bundle multiple files into a single bundle.
    If we have a more complicated application where we need to load third-party libraries
    (that can be bundled in any format, which includes even the most basic Angular2
    or React applications) we need to also care about module loaders.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经被各种打包工具解决，例如Browserify、webpack、SystemJS-Builder或rollup.js。然而，这又增加了一层复杂性。此外，这些工具只是将多个文件打包成一个单一包。如果我们有一个更复杂的应用程序，需要加载第三方库（这些库可以打包成任何格式，包括最基本的Angular2或React应用程序），我们还需要关注模块加载器。
- en: Module loaders are, for example, SystemJS, require.js, require1k, curl.js, and
    probably dozens more.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 模块加载器例如有SystemJS、require.js、require1k、curl.js，以及可能还有更多。
- en: 'This all means that when we start working on a JavaScript project today, we
    need to plan ahead the following four different things:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，当我们今天开始一个JavaScript项目时，我们需要提前规划以下四个不同的事情：
- en: What language I'm going to use? this has an effect on the features available
    and also on the compiler you have to use
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将使用哪种语言？这会影响可用的功能和必须使用的编译器
- en: To what module format am I going to compile my source code?
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将把源代码编译成哪种模块格式？
- en: What bundling tool I'm going to use?
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将使用哪种打包工具？
- en: How I am going to require my bundled project (by just including it via the `<script>`
    tag or do I need a module loader)?
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将如何要求我的打包项目（仅仅通过`<script>`标签包含它，或者我需要一个模块加载器）？
- en: So, RxJS 4 avoided almost all of this because it's written in ES5\. The only
    necessary task is bundling it into a single file that can be loaded as easily
    as just using the `<script>` tag.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，RxJS 4几乎避免了所有这些问题，因为它是用ES5编写的。唯一必要的任务是将其打包成一个可以像使用`<script>`标签一样轻松加载的单个文件。
- en: With RxJS 5, it gets more complicated.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RxJS 5，事情变得更加复杂。
- en: The deployment process of RxJS 5
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RxJS 5的部署过程
- en: The entire RxJS 5 project is written in TypeScript. This means that it needs
    to be compiled to ES5, so we can use it in a browser or in Node.js.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 整个RxJS 5项目是用TypeScript编写的。这意味着它需要编译成ES5，这样我们就可以在浏览器或Node.js中使用它。
- en: 'The process goes as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 流程如下：
- en: The entire source code is first compiled to ES6 using the TypeScript compiler
    with the ES6 module resolution.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个源代码首先使用TypeScript编译器并使用ES6模块解析编译成ES6。
- en: The ES6 code is then compiled again using `closure-compiler-js` made by Google,
    which generates ES5 code.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后使用Google开发的`closure-compiler-js`将ES6代码再次编译，生成ES5代码。
- en: This ES5 code is bundled using rollup.js (before rollup.js, they were using
    Browserify) to create a single UMD bundle.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用rollup.js（在rollup.js之前，他们使用Browserify）将ES5代码打包成一个单一的UMD包。
- en: This bundled file together with ES5 versions of each file along with their source
    maps and `.d.ts` files (TypeScript declaration file) are then uploaded to an npm
    repository. When we use RxJS 5 in, for example, Node.js, we will usually require
    only this single UMD bundle. When using RxJS 5 in a browser, we can just include
    it via the `<script>` tag thanks to the UMD module format.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个捆绑文件以及每个文件的 ES5 版本、它们的源映射和 `.d.ts` 文件（TypeScript 声明文件）随后被上传到 npm 仓库。当我们例如在
    Node.js 中使用 RxJS 5 时，我们通常会只要求这个单一的 UMD 捆绑。当在浏览器中使用 RxJS 5 时，我们可以通过 `<script>`
    标签包含它，多亏了 UMD 模块格式。
- en: Note
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Universal Module Definition** (**UMD**) is a universal module format that
    acts as AMD, CommonJS, SystemJS, or global depending on the environment loading
    it.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用模块定义**（**UMD**）是一种通用的模块格式，根据加载它的环境，它可以作为 AMD、CommonJS、SystemJS 或全局模块。'
- en: As we can see, developing applications in today's JavaScript is no joke. We'll
    see that it also has some benefits. In particular, prototypical-based inheritance
    can ease extending the existing Observables, which isn't possible in PHP for instance.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在今天的 JavaScript 中开发应用程序可不是闹着玩的。我们将看到它也有一些好处。特别是，基于原型的继承可以简化扩展现有的 Observables，这在
    PHP 等语言中是不可能的。
- en: But before that, let's see how we can use RxJS 5 in Node.js.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 但在那之前，让我们看看如何在 Node.js 中使用 RxJS 5。
- en: A quick introduction to RxJS 5 in Node.js
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 中 RxJS 5 的快速介绍
- en: We're already pretty experienced reactive developers, so none of these examples
    should surprise us.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经非常熟悉反应式开发，所以这些例子中的任何一个都不应该让我们感到惊讶。
- en: 'We''ll start by installing RxJS 5 via `npm` (basically, a dependency management
    tool similar to Composer in PHP):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过 `npm` 安装 RxJS 5（基本上，这是一个类似于 PHP 中的 Composer 的依赖管理工具）：
- en: '[PRE55]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As we said earlier, we''re going to use ES6 syntax, but we want to avoid recompiling
    our code because of ES6 imports. That''s why we''ll always use the `require()`
    function to load dependencies. This example should be very simple:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所说，我们将使用 ES6 语法，但因为我们想避免因为 ES6 导入而重新编译我们的代码。这就是为什么我们总是使用 `require()` 函数来加载依赖。这个例子应该非常简单：
- en: '[PRE56]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We loaded RxJS 5 with `rxjs/Rx` under the Rx constant. Node.js knows where to
    find the `rxjs` package (it automatically looks for packages into the `node_modules`
    directory). The full name `rxjs/Rx` means that it'll load file from `./node_modules/rxjs/Rx.js`.
    It is like the entry point of this library. It contains a lot of `require()` calls
    and then it exports all the classes we as developers are allowed to use. All these
    classes are then accessible with the `Rx` prefix (for example, `Rx.Subject` or
    `Rx.TestScheduler`).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Rx 常量下通过 `rxjs/Rx` 加载了 RxJS 5。Node.js 知道在哪里可以找到 `rxjs` 包（它会在 `node_modules`
    目录中自动查找包）。完整的名称 `rxjs/Rx` 表示它将从 `./node_modules/rxjs/Rx.js` 加载文件。这就像是这个库的入口点。它包含了很多
    `require()` 调用，然后导出我们作为开发者可以使用的所有类。所有这些类都可以通过 `Rx` 前缀访问（例如，`Rx.Subject` 或 `Rx.TestScheduler`）。
- en: 'The arrow syntax `val => val % 2 == 0` we''re using is just a shortcut to declare
    an anonymous function with a return statement:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的箭头语法 `val => val % 2 == 0` 只是一个声明带有返回语句的匿名函数的快捷方式：
- en: '[PRE57]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The arrow `=>` also makes the inner closure take the `this` context from its
    parent, but we're not going make use of this a lot here.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头 `=>` 也使得内部闭包从其父级中获取 `this` 上下文，但在这里我们不会大量使用它。
- en: 'To run this demo, we''ll just need Node.js runtime:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个演示，我们只需要 Node.js 运行时：
- en: '[PRE58]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Even with this very primitive example, we can already see how different it is
    from PHP. When using Composer, we don't need to worry about where our dependencies
    come from because they're always loaded by the SPL autoloader usually generated
    by Composer.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是这个非常原始的例子，我们也能看到它与 PHP 的不同。当使用 Composer 时，我们不需要担心依赖的来源，因为它们总是由 Composer 通常生成的
    SPL 自动加载器加载。
- en: Asynchronous calls in RxJS
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RxJS 中的异步调用
- en: 'Every time we wanted to make code in PHP asynchronous, we had to stick to event
    loops: in particular, `StreamSelectLoop` and `EventLoopScheduler`, and there was
    no way around it. Every `IntervalObservable` had to take as an argument a Scheduler
    (however, in RxPHP 2 this is done automatically for us so we usually don''t need
    to worry about it).'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们想在 PHP 中实现异步代码时，都必须坚持使用事件循环：特别是 `StreamSelectLoop` 和 `EventLoopScheduler`，而且别无选择。每个
    `IntervalObservable` 都必须接受一个调度器作为参数（然而，在 RxPHP 2 中，这会自动为我们完成，所以我们通常不需要担心它）。
- en: This is in RxJS, and in general, any JavaScript environment completely different
    from PHP.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 RxJS 中，并且在一般情况下，任何与 PHP 完全不同的 JavaScript 环境。
- en: 'Consider the following example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE59]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that we're using no loops and no Schedulers. In fact in RxJS 5, it's not
    that common for operators to take a Scheduler as an argument. The majority of
    operators don't because they don't need to schedule anything (such as the `map()`
    or `filter()` operators) and usually only those that need to work with timers
    do (basically, all operators containing work "time").
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有使用任何循环和调度器。实际上，在 RxJS 5 中，操作符作为参数传递调度器并不常见。大多数操作符不需要这样做，因为它们不需要安排任何事情（例如
    `map()` 或 `filter()` 操作符），通常只有需要与计时器一起工作的操作符才需要（基本上，所有包含“时间”工作的操作符）。
- en: This also implies that we don't need to worry about the different parts of our
    application is using different even loops. We discussed this topic in [Chapter
    06](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d "Chapter 6. PHP
    Streams API and Higher-Order Observables") , *PHP Streams API and Higher-Order
    Observables*, and [Chapter 07](part0054_split_000.html#1JFUC2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 7. Implementing Socket IPC and WebSocket Server/Client") , *Implementing
    Socket IPC and WebSocket Server/Client*, where we saw that this, left unattended,
    may cause deadlocks.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们不需要担心应用程序的不同部分使用不同的事件循环。我们已经在 [第 06 章](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "第 6 章。PHP Streams API 和高阶可观察对象")，*PHP Streams API 和高阶可观察对象*，以及 [第 07 章](part0054_split_000.html#1JFUC2-bd355a22cf10407cb10df27e65585b8d
    "第 7 章。实现套接字 IPC 和 WebSocket 服务器/客户端")，*实现套接字 IPC 和 WebSocket 服务器/客户端* 中讨论了这个问题，我们看到了，如果置之不理，这可能会导致死锁。
- en: 'We can run this demo and see ever-increasing counters triggering:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行这个演示，并看到不断增长的计数器触发：
- en: '[PRE60]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: A good question is why is it so simple in JavaScript and yet needs to be so
    complicated in PHP?
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好问题是为什么在 JavaScript 中如此简单，而在 PHP 中却需要如此复杂？
- en: Node.js and asynchronous events
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js 和异步事件
- en: Node.js is in fact one large event loop based on the libuv library ( [http://docs.libuv.org/](http://docs.libuv.org/)
    ).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 实际上是一个基于 libuv 库（[http://docs.libuv.org/](http://docs.libuv.org/)）的大事件循环。
- en: 'Let''s consider the following example that demonstrates adding a new callback
    to the event loop:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例，该示例演示了将新的回调函数添加到事件循环中：
- en: '[PRE61]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: When we run an application in Node.js, it takes our code as a single callback
    and starts executing it. Somewhere in our code, we're calling the `setTimeout()`
    function that takes as argument another callback that will be executed after some
    period of time. However, we called `setTimeout()` without providing any timeout.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Node.js 中运行应用程序时，它将我们的代码作为单个回调函数开始执行。在我们的代码中某个地方，我们调用了 `setTimeout()` 函数，该函数接受另一个回调函数作为参数，该回调函数将在一段时间后执行。然而，我们没有提供任何超时参数就调用了
    `setTimeout()`。
- en: This in fact doesn't matter because `setTimeout()` adds the callback to the
    event loop to be run as the last one after all other callbacks are executed. Using
    callbacks, we can easily make Node.js run our code asynchronously. It's also typical
    for Node.js that all system calls are asynchronous and take callbacks as parameters
    in order to be non-blocking.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这并不重要，因为 `setTimeout()` 将回调函数添加到事件循环中，在所有其他回调函数执行完毕后作为最后一个运行。使用回调函数，我们可以轻松地使
    Node.js 异步运行我们的代码。在 Node.js 中，所有系统调用都是异步的，并且以回调函数作为参数，以便非阻塞。
- en: 'The output in the console is as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出如下：
- en: '[PRE62]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We can see that the callback was really called after the outer callback got
    finished. When there're no more callbacks in the event loop and no callbacks are
    pending, then Node.js terminates.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在外部回调函数完成后，回调函数确实被调用了。当事件循环中没有更多的回调函数，并且没有挂起的回调函数时，Node.js 就会终止。
- en: Deep inside libuv, there's actually a thread pool that runs in parallel and
    handles system calls that can be run concurrently. Nonetheless, this has no effect
    on our code because Node.js will always execute callbacks one after another. This
    is a huge difference to PHP where none of this exists and the only way to schedule
    asynchronous calls is using custom event loops just like we did with `StreamSelectLoop`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在 libuv 的深处，实际上有一个并行运行的线程池，它处理可以并发运行的系统调用。尽管如此，这对我们的代码没有影响，因为 Node.js 总是依次执行回调函数。这与
    PHP 形成鲜明对比，在 PHP 中，这些都不存在，唯一安排异步调用的方式是使用自定义事件循环，就像我们使用 `StreamSelectLoop` 一样。
- en: Keep in mind that from our point of view, Node.js is always single threaded
    and strictly sequential. This means that just like in PHP if we write code that
    is blocking, it's going to block the execution thread as well. Node.js never executes
    callbacks in parallel. This of course applies to browser JavaScript environments
    as well.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，从我们的角度来看，Node.js始终是单线程且严格顺序的。这意味着就像在PHP中一样，如果我们编写了阻塞的代码，它将阻塞执行线程。Node.js永远不会并行执行回调。这当然也适用于浏览器JavaScript环境。
- en: If we wanted to run code in parallel, we could spawn subprocesses just like
    we did for example in [Chapter 06](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "Chapter 6. PHP Streams API and Higher-Order Observables") , *PHP Streams API
    and Higher-Order Observables*.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要并行运行代码，我们可以像在[第06章](part0050_split_000.html#1FLS41-bd355a22cf10407cb10df27e65585b8d
    "第6章。PHP Streams API和高级观察者")中那样，例如在*PHP Streams API和高级观察者*中，生成子进程。
- en: Lossy backpressure with the debounceTime() operator
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用debounceTime()操作符的损失性背压
- en: We know what backpressure is already from [Chapter 07](part0054_split_000.html#1JFUC2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 7. Implementing Socket IPC and WebSocket Server/Client") , *Implementing
    Socket IPC and WebSocket Server/Client*. A typical use case in RxJS is `debounceTime()`
    that takes a value and then waits until the specified timeout expires before re-emitting
    it further. This is very useful, for example, when creating an autocomplete feature
    where we want to postpone sending AJAX requests when the user is still typing
    into an input field (as we saw in [Chapter 1](part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d
    "Chapter 1. Introduction to Reactive Programming") , *Introduction to Reactive
    Programming*).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从[第07章](part0054_split_000.html#1JFUC2-bd355a22cf10407cb10df27e65585b8d
    "第7章。实现Socket IPC和WebSocket服务器/客户端")中了解了背压是什么，*实现Socket IPC和WebSocket服务器/客户端*。在RxJS中，一个典型的用例是`debounceTime()`，它接受一个值，然后等待指定的超时时间到期后再重新发出它。这在创建自动完成功能时非常有用，我们希望当用户仍在输入字段中输入时推迟发送AJAX请求（正如我们在[第1章](part0015_split_000.html#E9OE1-bd355a22cf10407cb10df27e65585b8d
    "第1章。响应式编程简介")中看到的，*响应式编程简介*）。
- en: 'Let''s have a look at its marble diagram:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的油管图：
- en: '![Lossy backpressure with the debounceTime() operator](img/00034.jpeg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![使用debounceTime()操作符的损失性背压](img/00034.jpeg)'
- en: 'In order to illustrate a practical example of `debounceTime()`, consider the
    following example:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`debounceTime()`的一个实际示例，考虑以下示例：
- en: '[PRE63]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This example emits a value every 100 ms and every fifth value is delayed by
    250 ms. That's why most of the values are ignored by `debounceTime()` because
    this operator requires an at least 200 ms long period without any emission from
    the source.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的实际示例，它使用JavaScript的异步回调来使用`debounceTime()`。这个示例每100毫秒发出一个值，每隔第五个值延迟250毫秒。这就是为什么大多数值都被`debounceTime()`忽略，因为这个操作符要求源至少有200毫秒的周期没有发出任何值。
- en: 'The output is as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE64]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: There's one very nice practical example for `debounceTime()` that makes use
    of JavaScript's asynchronous callbacks.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`debounceTime()`有一个非常实用的例子，它利用了JavaScript的异步回调。
- en: In the first chapter, when talking about reactive programming, we mentioned
    that a common application that we consider "reactive" is Excel. We have multiple
    cells with equations that define their relations and every change to any cell
    is propagated to the entire spreadsheet.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，当我们谈论响应式编程时，我们提到的一个常见的被认为是“响应式”的应用是Excel。我们有许多带有定义它们关系的方程的单元格，任何单元格的任何变化都会传播到整个电子表格。
- en: 'Let''s consider the following spreadsheet with three input values `A`, `B`,
    and `C` and the following equations we made on them:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下包含三个输入值`A`、`B`和`C`以及我们在这上面建立的以下方程的电子表格：
- en: '![Lossy backpressure with the debounceTime() operator](img/00035.jpeg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![使用debounceTime()操作符的损失性背压](img/00035.jpeg)'
- en: Now, how can we create something similar in RxJS? We can represent each cell
    as `BehaviorSubject` with a default value (we need to use Subjects in order to
    be able to change cell values later). Then, each equation (for example, `A + B`)
    will be held by `combineLatest()`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何在RxJS中创建类似的东西呢？我们可以将每个单元格表示为带有默认值的`BehaviorSubject`（我们需要使用Subjects以便以后能够更改单元格的值）。然后，每个方程（例如，`A
    + B`）将由`combineLatest()`持有。
- en: 'The preceding spreadsheet could look like this in RxJS:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的电子表格在RxJS中可能看起来像这样：
- en: '[PRE65]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We're using `combineLatest()` to get notified when any of the source Observables
    for each equation change. We also have multiple `do()` operators to log what's
    going on in our Observable chains.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `combineLatest()` 来通知当每个方程的任何源可观察对象发生变化时。我们还有多个 `do()` 操作符来记录我们的可观察链中正在发生的事情。
- en: 'When we run this demo, we''ll see the following output:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个演示时，我们将看到以下输出：
- en: '[PRE66]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This is obviously correct. Each equation was called exactly once.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是正确的。每个方程都恰好被调用了一次。
- en: 'Now, let''s imagine that we change the `B` cell value to `4` after the default
    values were propagated. This means that it''ll need to recalculate `AB`, `BC`,
    and `ABBC`. The desired state after updating the `B` cell should look like the
    following screenshot:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们在默认值传播之后将 `B` 细胞的值更改为 `4`。这意味着它需要重新计算 `AB`、`BC` 和 `ABBC`。更新 `B` 细胞后的期望状态应如下截图所示：
- en: '![Lossy backpressure with the debounceTime() operator](img/00036.jpeg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![使用 debounceTime() 操作符的损失性背压](img/00036.jpeg)'
- en: 'Append these two lines to the source file:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下两行添加到源文件中：
- en: '[PRE67]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, rerun the example and pay attention to what equations were evaluated:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重新运行示例并注意哪些方程被评估了：
- en: '[PRE68]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The first three are alright. Then, we set `B = 4`, which triggers the recalculation
    of `A + B,` and right after that, `AB + BC` equals `10`. Well, this is not correct
    because we haven't updated also `B + C`, which comes next. Then, after updating
    `BC`, the `AB + BC` is recalculated again and the correct value is set to `ABBC`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个是正确的。然后，我们将 `B` 设置为 `4`，这触发了 `A + B` 的重新计算，紧接着 `AB + BC` 等于 `10`。嗯，这是不正确的，因为我们还没有更新
    `B + C`，它紧接着出现。然后，在更新 `BC` 之后，`AB + BC` 再次重新计算，并将正确的值设置为 `ABBC`。
- en: We could just ignore this because the result is correct at the end. However,
    if the number of cells and the number of equations grew, then each redundant update
    would still cause an update to the page's DOM. As a result, this could make the
    page laggy and the user might notice the cells blinking.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地忽略它，因为最终结果是正确的。然而，如果单元格和方程的数量增加，那么每个多余的更新仍然会导致页面 DOM 的更新。结果，这可能会使页面变得卡顿，用户可能会注意到单元格闪烁。
- en: So how can we avoid this?
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们如何避免这种情况呢？
- en: We said that when `debounceTime()` receives a value, it stores it internally
    and starts a timeout. Then it doesn't re-emit any value until the timeout's callback
    is evaluated, which re-emits only the last value `debounceTime()` received. We
    can use this to our advantage by knowing that we can set `0` timeout, which won't
    delay the callback but just puts in at the end of Node.js's event loop.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过，当 `debounceTime()` 收到一个值时，它会将其存储在内部并开始一个超时。然后，它不会重新发出任何值，直到超时回调被评估，这只会重新发出
    `debounceTime()` 收到的最后一个值。我们可以利用这一点，通过设置 `0` 超时，这样就不会延迟回调，但只是将其放在 Node.js 事件循环的末尾。
- en: 'In other words, when we use `debounceTime(0)`, we''ll ignore all values that
    `debounceTime()` receives until the end of this callback. So, we can use this
    to calculate `AB + BC`:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当我们使用 `debounceTime(0)` 时，我们将忽略 `debounceTime()` 收到的所有值，直到回调的末尾。因此，我们可以用它来计算
    `AB + BC`：
- en: '[PRE69]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now if we run the code again, we''ll see the output we wanted:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们再次运行代码，我们将看到我们想要的输出：
- en: '[PRE70]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This is definitely an advanced use case that we won't encounter on a daily basis,
    but it's nice to see that we can use JavaScript internals to our advantage.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是一个高级用例，我们不会在日常工作中遇到，但看到我们可以利用 JavaScript 内部机制是很不错的。
- en: Note that this is something very difficult to do in RxPHP without using an event
    loop and custom operators, yet relatively simple in JavaScript.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 RxPHP 中不使用事件循环和自定义操作符做这件事是非常困难的，但在 JavaScript 中相对简单。
- en: Higher-order Observables in RxJS 5 and RxPHP
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJS 5 和 RxPHP 中的高阶可观察对象
- en: When developing browser applications, we very often need to make AJAX calls
    to fetch data asynchronously. For example, in Angular2, this is very common, and
    in fact, any AJAX request made using Angular2's HTTP service returns an Observable
    where we typically chain the `map()` operator to decode JSON and then use `subscribe()`
    to be notified when the response is ready.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发浏览器应用程序时，我们非常经常需要执行 AJAX 调用来异步获取数据。例如，在 Angular2 中，这非常常见，实际上，使用 Angular2
    的 HTTP 服务发出的任何 AJAX 请求都会返回一个可观察对象，我们通常将 `map()` 操作符链式调用以解码 JSON，然后使用 `subscribe()`
    来通知响应已准备好。
- en: 'We can simulate such a situation with the following code:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下代码来模拟这种情况：
- en: '[PRE71]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Variable data contains a JSON-serialized array of objects that we decode and
    pass to the observer. The output looks like the following:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 变量数据包含一个 JSON 序列化的对象数组，我们将其解码并传递给观察者。输出如下所示：
- en: '[PRE72]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Well, it works, but what if we wanted to receive only objects with the `name`
    property starting with the letter `B`? Right now, we received the entire array
    of objects as a single emission.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，它确实有效，但如果我们只想接收具有以字母`B`开头的`name`属性的物体呢？目前，我们接收到的整个物体数组作为一个单独的发射。
- en: So, the question is how can we unpack the array and emit every single object
    separately?
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，问题是我们如何解包数组并分别发射每个单独的物体？
- en: 'One option that can be used in RxJS and RxPHP in exactly the same way is using
    `concatMap()` (`mergeMap()` would work as well) and return a new Observable created
    from an iterable object. In RxJS, this could be as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJS和RxPHP中可以以完全相同方式使用的一个选项是使用`concatMap()`（`mergeMap()`也可以）并返回一个由可迭代对象创建的新Observables。在RxJS中，这可以如下所示：
- en: '[PRE73]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In RxJS 5, `Observable.from()` takes as a parameter any array-like object and
    emits all its items. In RxPHP, we'd use `Observable::fromArray()` instead.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJS 5中，`Observable.from()`接受任何类似数组的对象作为参数，并发出所有项。在RxPHP中，我们会使用`Observable::fromArray()`代替。
- en: 'Now the output is a single item because the rest was skipped thanks to the
    `filter()` operator:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出是一个单独的项，因为其余的项被`filter()`操作符跳过了：
- en: '[PRE74]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In RxJS 5, there's also another and quite clever way to achieve the same result.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJS 5中，还有另一种相当巧妙的方法可以达到相同的结果。
- en: We've talked about operators that work with higher-order Observables, such as
    `mergeAll()` or `concatAll()`. These subscribe to an Observable that emits Observables.
    Due to RxJS 5 inner implementation, we can use a little trick and use operators
    that normally work with only higher-order Observables to work with arrays as well.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了与高阶Observables一起工作的操作符，例如`mergeAll()`或`concatAll()`。它们订阅一个发出Observables的Observables。由于RxJS
    5的内部实现，我们可以使用一个小技巧，使用通常只与高阶Observables一起工作的操作符来处理数组。
- en: 'Let''s see how `concatAll()` can be used to achieve the same result as `concatMap()`
    in the preceding example:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`concatAll()`在先前的示例中达到与`concatMap()`相同的结果：
- en: '[PRE75]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: So, this obviously shouldn't work. How can `concatAll()` subscribe to an array?
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这显然不应该工作。`concatAll()`如何订阅一个数组？
- en: The answer lies in the way `concatAll()`, and basically, all operators working
    with higher-order Observables internally subscribe to items emitted by the source
    Observable. In PHP, we'd expect that all of them have to be other Observables,
    but this is not the case for RxJS 5.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在于`concatAll()`以及基本上，所有与高阶Observables一起工作的操作符在内部都会订阅源Observables发出的项。在PHP中，我们预计它们都必须是其他Observables，但RxJS
    5并非如此。
- en: Some operators in RxJS 5 subscribe to inner Observables via a function named
    `subscribeToResult()` (it's defined in `src/util/subscribeToResult.ts`). This
    function has multiple handlers for different types of items. There's of course
    a handler for Observables, but apart from that, it also knows how to work with
    Promises as well as JavaScript arrays.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 5中的一些操作符通过一个名为`subscribeToResult()`的函数（它在`src/util/subscribeToResult.ts`中定义）订阅内部Observables。这个函数对不同类型的项有多个处理程序。当然，有一个处理Observables的处理程序，但除此之外，它还知道如何与Promises以及JavaScript数组一起工作。
- en: When we used `concatAll()` earlier, the `subscribeToResult()` function just
    iterated the array and re-emitted all its values. Note that it just iterated the
    array internally. It didn't create another Observable from it.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们之前使用`concatAll()`时，`subscribeToResult()`函数只是迭代数组并重新发出所有值。请注意，它只是内部迭代数组。它没有从它创建另一个Observables。
- en: So, these were just two, but useful, differences we can encounter when switching
    from RxPHP to RxJS 5.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这只是两个，但有用的，我们在从RxPHP切换到RxJS 5时可能会遇到的不同点。
- en: Operators specific for RxJS 5
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适用于RxJS 5的特定操作符
- en: As we said, there are extra operators in RxJS 5 that aren't available in RxPHP
    right now. There are in fact, quite of few of them, but many are very similar
    in principle. We mentioned some of them in [Chapter 07](part0054_split_000.html#1JFUC2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 7. Implementing Socket IPC and WebSocket Server/Client") , *Implementing
    Socket IPC and WebSocket Server/Client*, such as `audit()` or `throttle(),` including
    all their variations that use timeouts or other Observables to create time windows.
    Also, all operators derived from `buffer()` aren't so interesting for us.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，RxJS 5中还有一些额外的操作符目前RxPHP中没有。实际上，它们相当多，但许多在原则上非常相似。我们在[第07章](part0054_split_000.html#1JFUC2-bd355a22cf10407cb10df27e65585b8d
    "第7章。实现Socket IPC和WebSocket服务器/客户端")，*实现Socket IPC和WebSocket服务器/客户端*中提到了一些，例如`audit()`或`throttle()`，包括所有使用超时或其他Observables创建时间窗口的变体。此外，所有从`buffer()`派生的操作符对我们来说都不那么有趣。
- en: We'll have a look at the three of them that serve some other interesting purposes.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看这三个运算符，它们服务于一些其他有趣的目的。
- en: The expand() operator
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: expand()运算符
- en: The interesting thing about the `expand()` operator is that it works recursively.
    It takes as a parameter a callback that needs to return another Observable. The
    callback is then applied to all values emitted by the returned Observable. This
    goes on as long as the returned Observables emit values.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '`expand()`运算符有趣的地方在于它的工作是递归的。它接受一个参数，即需要返回另一个Observable的回调。然后，这个回调被应用于返回的Observable发出的所有值。只要返回的Observables发出值，这个过程就会继续。'
- en: 'Consider the following example where we use `expand()` to recursively multiply
    a value by two as long as the result is less than 32:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，我们使用`expand()`递归地将一个值乘以二，直到结果小于32：
- en: '[PRE76]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We stop the recursion by not emitting any value and returning just `Observable.empty()`
    (which emits just a complete signal).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过不发出任何值并只返回`Observable.empty()`（它只发出完成信号）来停止递归。
- en: 'All intermediate values produced by all the recursive calls are re-emitted
    by `expand()`, so the output from this example will look as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 所有递归调用产生的所有中间值都会由`expand()`重新发出，所以这个示例的输出将如下所示：
- en: '[PRE77]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The finally() operator
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: finally()运算符
- en: As the name suggests, this operator executes its callback on both the `error`
    and `complete` signals. It's important to see the difference between `finally()`
    and just subscribing and using the same callbacks for error and complete signals.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，这个运算符在`error`和`complete`信号上都会执行其回调。看到`finally()`和仅订阅并使用相同的回调来处理错误和完成信号之间的区别是很重要的。
- en: 'The `finally()` operator doesn''t turn cold Observables to hot. So, it''s more
    similar to the `do()` operator than to the `subscribe()` method:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally()`运算符不会将冷Observables转换为热。所以，它更类似于`do()`运算符，而不是`subscribe()`方法：'
- en: '[PRE78]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The first subscription will receive only the first value and then the `error`
    signal. Note the order in which we used the `finally()` operator and the `subscribe()`
    call. Operator `finally()` comes first so it also receives the error signal first.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次订阅将只收到第一个值，然后是`error`信号。注意我们使用`finally()`运算符和`subscribe()`调用的顺序。运算符`finally()`先使用，所以它也先收到错误信号。
- en: The second subscription is analogous. Also, this one uses `onErrorResumeNext()`
    to ignore the error signal (even though it won't receive the last value because
    it has already unsubscribed). It'll receive just the complete signal. Again, note
    where the `finally()` operator is used.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次订阅是类似的。此外，这个示例使用了`onErrorResumeNext()`来忽略错误信号（即使它不会收到最后一个值，因为它已经退订了）。它只会收到完成信号。再次注意`finally()`运算符的使用位置。
- en: 'When we run this example, we''ll get the following output:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个示例时，我们会得到以下输出：
- en: '[PRE79]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Even though both `finally()` operators are used before `subscribe()` (which
    is obvious because these are operators that need to be somewhere in the chain),
    their callbacks were executed after the error or complete callbacks from `subscribe()`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管两个`finally()`运算符都在`subscribe()`之前使用（这是显而易见的，因为这些都是需要在链中某处的运算符），但它们的回调是在`subscribe()`的错误或完成回调之后执行的。
- en: This is the fundamental difference of the `do()` operator and also the reason
    why `finally()` might come in handy in certain situations.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`do()`运算符的基本区别，也是为什么在某些情况下`finally()`可能很有用的原因。
- en: The withLatestFrom() operator
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: withLatestFrom()运算符
- en: In [Chapter 07](part0054_split_000.html#1JFUC2-bd355a22cf10407cb10df27e65585b8d
    "Chapter 7. Implementing Socket IPC and WebSocket Server/Client") , *Implementing
    Socket IPC and WebSocket Server/Client*, and [Chapter 8](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d
    "Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension") , *Multicasting
    in RxPHP and PHP7 pthreads Extension*, we used the `combineLatest()` operator,
    and we mentioned that in RxJS 5, there's also a slightly modified variant.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第07章](part0054_split_000.html#1JFUC2-bd355a22cf10407cb10df27e65585b8d "第7章。实现Socket
    IPC和WebSocket服务器/客户端")，*实现Socket IPC和WebSocket服务器/客户端*，和[第8章](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d
    "第8章。在RxPHP和PHP7 pthreads扩展中的多播")，*在RxPHP和PHP7 pthreads扩展中的多播*中，我们使用了`combineLatest()`运算符，并提到在RxJS
    5中还有一个稍微修改过的变体。
- en: The `combineLatest()` operator takes multiple source Observables and emits their
    most recent values as an array when any of them emit a value. Then, there's the
    `withLatestFrom()` operator that takes multiple sources as well, but this operator
    emits a value only when its direct predecessor in the chain emits a value (its
    source Observable).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`combineLatest()` 操作符接收多个源可观察对象，并在其中任何一个发出值时，作为数组发出它们的最新的值。然后，有 `withLatestFrom()`
    操作符也接收多个源，但这个操作符只在它的直接前驱在链中发出值（它的源可观察对象）时发出值。'
- en: 'Consider the following example with multiple timers:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下具有多个计时器的示例：
- en: '[PRE80]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Both `source1` and `source2` emit multiple values every second. However, `withLatestFrom()`
    re-emits their values only when `Observable.interval(1000)` emits a value.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`source1` 和 `source2` 每秒都会发出多个值。然而，`withLatestFrom()` 只在 `Observable.interval(1000)`
    发出值时重新发出它们的值。'
- en: 'The output from this demo is as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示的输出如下：
- en: '[PRE81]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Use cases for this operator are very similar to those for `combineLatest()`.
    We just have a better control of the re-emission, which could be useful, for example,
    to implement caching mechanisms where the 1-second interval could control when
    we want to refresh the cache.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符的使用案例与 `combineLatest()` 的使用案例非常相似。我们只是对重新发出的控制更好，这可能非常有用，例如，实现缓存机制，其中
    1 秒的间隔可以控制我们想要刷新缓存的时间。
- en: While speaking of caching, we will have a look at the last and very nice example
    in this book.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论缓存的同时，我们将看看这本书中最后一个非常棒的示例。
- en: Caching HTTP requests with publishReplay() and take()
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 publishReplay() 和 take() 缓存 HTTP 请求
- en: This example is my favorite. I show this demo to people who want to start with
    RxJS and they're overwhelmed by the complexity and don't see the practical advantage.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是我的最爱。我向那些想要开始使用 RxJS 的人展示这个演示，他们被复杂性压倒了，看不到实际的优势。
- en: A very common use case in frontend development is that we need to cache results
    from AJAX calls. For example, we might have a server that we want to query once
    a minute at most. All subsequent calls under one minute won't spawn another AJAX
    call but receive only the cached data.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端开发中一个非常常见的用例是我们需要缓存 AJAX 调用的结果。例如，我们可能有一个我们希望每分钟最多查询一次的服务器。在一分钟内所有的后续调用都不会产生另一个
    AJAX 调用，而是只接收缓存的数据。
- en: 'This can all be done by leveraging the `publishReplay()` and `take()` operators:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以通过利用 `publishReplay()` 和 `take()` 操作符来完成：
- en: '[PRE82]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We're creating mock requests with the `mockDataFetch()` function that increments
    the counter every time it's called (this is to make sure that we're not making
    more calls to the server than we think). Then, we delay this Observable to pretend
    it takes some time.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `mockDataFetch()` 函数创建模拟请求，每次调用时都会增加计数器（这是为了确保我们没有比我们认为的更多地向服务器发出调用）。然后，我们延迟这个可观察对象，以假装它需要一些时间。
- en: Every time we want to get current data from a cache or from a fresh AJAX request,
    we use the `mockHttpCache()` function that returns an Observable.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们想要从缓存或从新的 AJAX 请求中获取当前数据时，我们都会使用 `mockHttpCache()` 函数，该函数返回一个可观察对象。
- en: 'Let''s have a look at how we schedule a couple of calls and then make sure
    that this really works as we expect from the console output. After this, we can
    explain why this works:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何安排几个调用，并确保这确实像我们预期的从控制台输出中工作。之后，我们可以解释为什么它会这样工作：
- en: '[PRE83]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We're making five requests in total. The first two should receive the same response.
    The next two will receive another response, and the last one will have the third
    response. For illustrational purposes, we're caching responses only for 1 second.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总共发出五个请求。前两个应该收到相同的响应。接下来的两个将收到另一个响应，最后一个将收到第三个响应。为了说明目的，我们只缓存响应 1 秒。
- en: 'Now, let''s see the console output:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看控制台输出：
- en: '[PRE84]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: So, it really works as we want; but how?
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它确实像我们想要的那样工作；但它是如何做到的？
- en: The `publishReplay(1, 1000)` operator multicasts responses for 1 second via
    `ReplaySubject` (see [Chapter 8](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d
    "Chapter 8. Multicasting in RxPHP and PHP7 pthreads Extension") , *Multicasting
    in RxPHP and PHP7 pthreads Extension*, for more info on multicasting). After 1
    second, it discards the stored result.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`publishReplay(1, 1000)` 操作符通过 `ReplaySubject` 在 1 秒内多播响应（见第 8 章 [Chapter 8](part0061_split_000.html#1Q5IA1-bd355a22cf10407cb10df27e65585b8d
    "第 8 章. RxPHP 和 PHP7 pthreads 扩展中的多播"，了解更多关于多播的信息），1 秒后，它将丢弃存储的结果。'
- en: 'When we call `mockHttpCache()`, one of these situations occur:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `mockHttpCache()` 时，以下情况之一会发生：
- en: We subscribe to `ReplaySubject` that already has a cached response. In that
    case, on subscription, it immediately calls `next()` and sends this value to its
    new subscriber. Since there's `take(1)` operator, it passes the value and the
    chain completes. The `ReplaySubject` then checks whether the subscriber has stopped
    after passing it the cached value. Thanks to `take(1)` it does stop, so `ReplaySubject`
    won't subscribe to the deferred Observable.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们订阅了一个已经缓存了响应的 `ReplaySubject`。在这种情况下，在订阅时，它会立即调用 `next()` 并将此值发送给新的订阅者。由于存在
    `take(1)` 操作符，它传递了值并完成链。然后 `ReplaySubject` 检查在传递缓存值后订阅者是否停止。多亏了 `take(1)`，它确实停止了，所以
    `ReplaySubject` 不会订阅延迟的 Observable。
- en: We subscribe to `ReplaySubject`, but it doesn't have any valid response cached
    and/or it also needs to subscribe to the deferred Observable that triggers a new
    AJAX request. When the request is ready, it's passed down the chain where `take(1)`
    re-emits it and completes.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们订阅了 `ReplaySubject`，但它没有有效的响应缓存，并且还需要订阅触发新 AJAX 请求的延迟 Observable。当请求准备好时，它被传递到链中，`take(1)`
    重新发出它并完成。
- en: So this was a pretty short and clever way to make already sophisticated functionality
    that would normally require using at least one `setTimeout()` and at a minimum
    two state variables to keep the cached response and the time it was created.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是一种相当简短且巧妙的方法，可以制作出通常需要至少使用一个 `setTimeout()` 和至少两个状态变量来保持缓存响应及其创建时间的复杂功能。
- en: Summary
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This final chapter was dedicated to RxJS 5 to show that while most principles
    are the same, there are a couple of differences that we can take advantage of.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一章是专门献给 RxJS 5 的，以展示尽管大多数原则是相同的，但也有一些我们可以利用的差异。
- en: After reading this chapter, you should know the differences between RxJS 4 and
    RxJS 5, what technologies are used to develop and deploy RxJS 5, how Node.js handles
    asynchronous code, and what operators are present in RxJS 5 already but aren't
    implemented in RxPHP yet.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完这一章后，你应该了解 RxJS 4 和 RxJS 5 之间的差异，了解用于开发和部署 RxJS 5 的技术，了解 Node.js 如何处理异步代码，以及
    RxJS 5 中已经存在但尚未在 RxPHP 中实现的操作符。
- en: Hopefully, you'll take the best out of RxJS and RxPHP and use it to write faster
    and more readable code yourself.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能从 RxJS 和 RxPHP 中汲取精华，并自己用它来编写更快、更易读的代码。
